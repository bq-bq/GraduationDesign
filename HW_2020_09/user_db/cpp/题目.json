{
    "__update_time__": 1601013370.922991,
    "field_names": [
        "题目名",
        "问题",
        "主程序",
        "答案程序",
        "随机输入产生程序",
        "开始时间",
        "截止时间"
    ],
    "field_types": [
        "text",
        "text",
        "text",
        "text",
        "text",
        "time",
        "time"
    ],
    "foreign_keys": {},
    "primary_keys": [],
    "rows": [
        [
            "1.1 (C++)",
            "Design a class, Matrix5x5, to represent 5 by 5 matrixes.<br> \nThis class should have the following member functions:\n<ol>\n<li>double get(int, int)</li>\n<li>void set(int, int, double)</li>\n<li>Matrix5x5 operator + (Matrix5x5 &amp;, Matrix5x5 &amp;) </li>\n</ol>\n\n<u>EXAMPLE INPUT</u>\n<pre>1\n2\n3\n4\n</pre>\n\n<u>EXAMPLE OUTPUT</u>\n<pre>4 0 0 0 0 \n0 0 0 0 0 \n0 0 0 0 0 \n0 0 0 4 0 \n0 0 0 0 2 \n</pre>",
            "#include \"source.cpp\"\n#include <iostream>\nusing namespace std;\n\nvoid print(Matrix5x5 & matrix) {\n\tfor (int row = 0; row < 5; ++ row) {\n\t\tfor (int col = 0; col < 5; ++ col) {\n\t\t\tcout << matrix.get(row, col) << ' ';\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nint main() {\n\tMatrix5x5 m1, m2, m3;\n\tdouble value;\n\tcin >> value;\n\tm1.set(0, 0, value);\n\tcin >> value;\n\tm1.set(4, 4, value);\n\tcin >> value;\n\tm2.set(0, 0, value);\n\tcin >> value;\n\tm2.set(3, 3, value);\n\tm3 = m1 + m2;\n\tprint(m3);\n}",
            "class Matrix5x5\n{\npublic:\n\tdouble data[5][5];\n\t\n\tMatrix5x5() {\n\t\tfor (int row = 0; row < 5; ++ row) {\n\t\t\tfor (int col = 0; col < 5; ++ col) {\n\t\t\t\tthis->data[row][col] = 0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdouble get(int row, int col) {\n\t\treturn this->data[row][col];\n\t}\n\t\n\tvoid set(int row, int col, double value) {\n\t\tthis->data[row][col] = value;\n\t}\n\t\n\tMatrix5x5 operator + (Matrix5x5 & that) {\n\t\tMatrix5x5 m;\n\t\tfor (int row = 0; row < 5; ++ row) {\n\t\t\tfor (int col = 0; col < 5; ++ col) {\n\t\t\t\tdouble sum = this->get(row, col) + that.get(row, col);\n\t\t\t\tm.set(row, col, sum);\n\t\t\t}\n\t\t}\n\t\treturn m;\n\t}\n};",
            "from random import randint\nprint(randint(1,9))\nprint(randint(1,9))\nprint(randint(1,9))\nprint(randint(1,9))",
            1587693600.0,
            1603976400.0
        ],
        [
            "1.2 (C++)",
            "Design a class <i>School</i>.<br> \nThis class has the following member functions:\n<ol>\n<li>void setName(char name[])</li>\n<li>void setAge(int year)</li>\n<li>void operator ++ ()</li>\n</ol>\n\n<u>EXAMPLE INPUT</u>\n<pre>SYSU\n99\n</pre>\n\n<u>EXAMPLE OUTPUT</u>\n<pre>NO_NAME 0\nSYSU 99\nSYSU 100 \n</pre>",
            "#include \"source.cpp\"\n#include <iostream>\nusing namespace std;\n\nvoid print(School & school) {\n\tcout << school.name << ' ' << school.age << endl;\n}\n\nint main() {\n\tSchool school;\n\tprint(school);\n\t\n\tchar name[10];\n\tcin >> name;\n\tschool.setName(name);\n\tint age;\n\tcin >> age;\n\tschool.setAge(age);\n\tprint(school);\n\t\n\t++ school;\n\tprint(school);\n}",
            "#include <cstring>\n\nclass School\n{\npublic:\n\tchar name[20];\n\tint age;\n\t\n\tSchool() {\n\t\tstrcpy(this->name, \"NO_NAME\");\n\t\tthis->age = 0;\n\t}\n\t\n\tvoid setName(const char name[]) {\n\t\tstrcpy(this->name, name);\n\t}\n\t\n\tvoid setAge(int age) {\n\t\tthis->age = age;\n\t}\n\t\n\tvoid operator ++ () {\n\t\t++ this->age;\n\t}\n};",
            "from random import randint\n\ndef random_str(k):\n\tchars = 'abcdefghijklmnopqrstuvwxyz'.upper()\n\ttext = ''\n\tfor i in range(k):\n\t\ttext += chars[randint(0,len(chars)-1)]\n\treturn text\n\ndef random_int(k):\n\tval = randint(1,9)\n\tfor i in range(k-1):\n\t\tval = val * 10 + randint(0,9)\n\treturn val\n\nprint(random_str(5))\nprint(random_int(2))\n",
            1588212000,
            1588218000
        ],
        [
            "2.1 (C++)",
            "Design a class Matrix that has the following private member variables:\n<ol>\n<li>int rows</li>\n<li>int columns</li>\n<li>double * values</li>\n</ol>\nBesides, it has the following public functions:\n<ol>\n<li>A constructor Matrix(int rows, int column), which initializes all elements in the matrix to all 0's.</li>\n<li>A destructor.</li>\n<li>A print function which prints each row of elements in a single line, with each element preceded with 4 spaces.</li>\n</ol>\n\n<u>EXAMPLE INPUT</u>\n<pre>4 5</pre>\n\n<u>EXAMPLE OUTPUT</u>\n<pre>    0    0    0    0    0\n    0    0    0    0    0\n    0    0    0    0    0\n    0    0    0    0    0</pre>",
            "#include \"source.cpp\"\n\nint main() {\n\tint rows;\n\tint columns;\n\tcin >> rows >> columns;\n\tMatrix matrix1(rows, columns);\n\tmatrix1.print();\n}",
            "#include <iostream>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nclass Matrix\n{\n\t\nprivate:\n\t\n\tint rows;\n\tint columns;\n\tdouble * values;\n\t\npublic:\n\t\n\tint size(int dimension) const {\n\t\tswitch (dimension) {\n\t\t\tcase 1: return rows;\n\t\t\tcase 2: return columns;\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tvoid set(int row, int column, double value) {\n\t\t-- row;\n\t\t-- column;\n\t\tvalues[row * columns + column] = value;\n\t}\n\t\n\tdouble get(int row, int column) const {\n\t\t-- row;\n\t\t-- column;\n\t\treturn values[row * columns + column];\n\t}\n\nprivate:\n\t\n\tvoid assign0(int rows, int columns) {\n\t\t(*this).rows = rows;\n\t\t(*this).columns = columns;\n\t\t(*this).values = new double[rows * columns];\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tset(i, j, 0.0);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid assign0(int rows, int columns, const double values[]) {\n\t\t(*this).rows = rows;\n\t\t(*this).columns = columns;\n\t\t(*this).values = new double[rows * columns];\n\t\tint count = 0;\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tset(i, j, values[count]);\n\t\t\t\t++ count;\n\t\t\t}\n\t\t}\n\t}\n\t\npublic:\n\t\n\tMatrix(int rows, int columns) {\n\t\tassign0(rows, columns);\n\t}\n\t\n\tMatrix(int rows, int columns, const double values[]) {\n\t\tassign0(rows, columns, values);\n\t}\n\t\n\tMatrix(const Matrix & matrix2) {\n\t\tassign0(matrix2.rows, matrix2.columns, matrix2.values);\n\t}\n\t\n\t~Matrix() {\n\t\tdelete [] values;\n\t}\n\t\n\tvoid print() const {\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tcout << \"    \" << get(i, j);\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\t\n\tMatrix & operator = (const Matrix & matrix2) {\n\t\tdelete [] values;\n\t\tassign0(matrix2.rows, matrix2.columns, matrix2.values);\n\t\treturn (*this);\n\t}\n\t\n\tMatrix getColumn(int column) const {\n\t\tMatrix columnMatrix(rows, 1);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tdouble value = get(i, column);\n\t\t\tcolumnMatrix.set(i, 1, value);\n\t\t}\n\t\treturn columnMatrix;\n\t}\n\n\tMatrix getRow(int row) const {\n\t\tMatrix rowMatrix(1, columns);\n\t\tfor (int i = 1; i <= columns; ++ i) {\n\t\t\tdouble value = get(row, i);\n\t\t\trowMatrix.set(1, i, value);\n\t\t}\n\t\treturn rowMatrix;\n\t}\n\t\n\tMatrix concatenateRows(const Matrix & matrix2) const {\n\t\tMatrix matrix(rows + matrix2.rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= matrix2.rows; ++ i) {\n\t\t\tfor (int j = 1; j <= matrix2.columns; ++ j) {\n\t\t\t\tdouble value = matrix2.get(i, j);\n\t\t\t\tmatrix.set(rows + i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix concatenateColumns(const Matrix & matrix2) const {\n\t\tMatrix matrix(rows, columns + matrix2.columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= matrix2.rows; ++ i) {\n\t\t\tfor (int j = 1; j <= matrix2.columns; ++ j) {\n\t\t\t\tdouble value = matrix2.get(i, j);\n\t\t\t\tmatrix.set(i, columns + j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix reshape(int rows, int columns) const {\n\t\tMatrix matrix(rows, columns);\n\t\tint count = 0;\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\t\tint row2 = 1 + count % (*this).rows;\n\t\t\t\tint column2 = 1 + count / (*this).rows;\n\t\t\t\t++ count;\n\t\t\t\tdouble value = get(row2, column2);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\t\n\tMatrix transpose() const {\n\t\tMatrix matrix(columns, rows);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(j, i, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator * (const Matrix & matrix2) const {\n\t\tMatrix matrix(rows, matrix2.columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= matrix2.columns; ++ j) {\n\t\t\t\tdouble sum = 0;\n\t\t\t\tfor (int k = 1; k <= columns; ++ k) {\n\t\t\t\t\tdouble value1  = get(i, k);\n\t\t\t\t\tdouble value2 = matrix2.get(k, j);\n\t\t\t\t\tsum += value1 * value2;\n\t\t\t\t}\n\t\t\t\tmatrix.set(i, j, sum);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\n\tMatrix operator * (double times) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value * times);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator + (const Matrix & matrix2) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value1 = get(i, j);\n\t\t\t\tdouble value2 = matrix2.get(i, j);\n\t\t\t\tmatrix.set(i, j, value1 + value2);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator + (double value2) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value + value2);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator - (const Matrix & matrix2) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value1 = get(i, j);\n\t\t\t\tdouble value2 = matrix2.get(i, j);\n\t\t\t\tmatrix.set(i, j, value1 - value2);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator - (double value2) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value - value2);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix max() const {\n\t\tif (rows == 1) {\n\t\t\treturn transpose().max();\n\t\t}\n\t\tMatrix matrix(1, columns);\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tdouble max = get(1, j);\n\t\t\tfor (int i = 2; i <= rows; ++ i) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tif (max < value) max = value;\n\t\t\t}\n\t\t\tmatrix.set(1, j, max);\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix min() const {\n\t\tif (rows == 1) {\n\t\t\treturn transpose().min();\n\t\t}\n\t\tMatrix matrix(1, columns);\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tdouble min = get(1, j);\n\t\t\tfor (int i = 2; i <= rows; ++ i) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tif (min > value) min = value;\n\t\t\t}\n\t\t\tmatrix.set(1, j, min);\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix sum() const {\n\t\tif (rows == 1) {\n\t\t\treturn transpose().sum();\n\t\t}\n\t\tMatrix matrix(1, columns);\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tdouble sum = 0;\n\t\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\t\tsum += get(i, j);\n\t\t\t}\n\t\t\tmatrix.set(1, j, sum);\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix pow(double exponent) {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tvalue = ::pow(value, exponent);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix exp() {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tvalue = ::exp(value);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix log() {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tvalue = ::log(value);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix abs() {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tvalue = std::abs(value);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\n\tdouble norm(int k) {\n\t\tif (rows == 1) {\n\t\t\treturn transpose().norm(k);\n\t\t}\n\t\treturn ::pow(abs().pow(k).sum().get(1, 1), (1.0 / k));\n\t}\n\n};",
            "from random import randint\nprint(randint(3,9))\nprint(randint(3,9))",
            1588824000,
            1589461200
        ],
        [
            "2.2 (C++)",
            "Design a class Matrix that has the following private member variables:\n<ol>\n<li>int rows</li>\n<li>int columns</li>\n<li>double * values</li>\n</ol>\nBesides, it has the following public functions:\n<ol>\n<li>A constructor Matrix(int rows, int column, double values[]), which initializes all elements in the matrix to the given values. Note that the given values are in one-dimensional, you need to fill then into the two-dimensional matrix correctly.</li>\n<li>A destructor.</li>\n<li>A print function which prints each row of elements in a single line, with each element using 5 character spaces.</li>\n</ol>\n\n<u>EXAMPLE INPUT</u>\n<pre>4 5\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20</pre>\n\n<u>EXAMPLE OUTPUT</u>\n<pre>    1    2    3    4    5\n    6    7    8    9   10\n   11   12   13   14   15\n   16   17   18   19   20</pre>",
            "#include \"source.cpp\"\n\nint main() {\n\tint rows;\n\tint columns;\n\tdouble values[1000];\n\tcin >> rows >> columns;\n\tfor (int i = 0; i < rows * columns; ++ i) {\n\t\tcin >> values[i];\n\t}\n\tMatrix matrix1(rows, columns, values);\n\tmatrix1.print();\n}",
            "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nclass Matrix\n{\n\t\nprivate:\n\t\n\tint rows;\n\tint columns;\n\tdouble * values;\n\t\npublic:\n\t\n\tint size(int dimension) const {\n\t\tswitch (dimension) {\n\t\t\tcase 1: return rows;\n\t\t\tcase 2: return columns;\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tvoid set(int row, int column, double value) {\n\t\t-- row;\n\t\t-- column;\n\t\tvalues[row * columns + column] = value;\n\t}\n\t\n\tdouble get(int row, int column) const {\n\t\t-- row;\n\t\t-- column;\n\t\treturn values[row * columns + column];\n\t}\n\nprivate:\n\t\n\tvoid assign0(int rows, int columns) {\n\t\t(*this).rows = rows;\n\t\t(*this).columns = columns;\n\t\t(*this).values = new double[rows * columns];\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tset(i, j, 0.0);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid assign0(int rows, int columns, const double values[]) {\n\t\t(*this).rows = rows;\n\t\t(*this).columns = columns;\n\t\t(*this).values = new double[rows * columns];\n\t\tint count = 0;\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tset(i, j, values[count]);\n\t\t\t\t++ count;\n\t\t\t}\n\t\t}\n\t}\n\t\npublic:\n\t\n\tMatrix(int rows, int columns) {\n\t\tassign0(rows, columns);\n\t}\n\t\n\tMatrix(int rows, int columns, const double values[]) {\n\t\tassign0(rows, columns, values);\n\t}\n\t\n\tMatrix(const Matrix & matrix2) {\n\t\tassign0(matrix2.rows, matrix2.columns, matrix2.values);\n\t}\n\t\n\t~Matrix() {\n\t\tdelete [] values;\n\t}\n\t\n\tvoid print() const {\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tcout << setw(5) << get(i, j);\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\t\n\tMatrix & operator = (const Matrix & matrix2) {\n\t\tdelete [] values;\n\t\tassign0(matrix2.rows, matrix2.columns, matrix2.values);\n\t\treturn (*this);\n\t}\n\t\n\tMatrix getColumn(int column) const {\n\t\tMatrix columnMatrix(rows, 1);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tdouble value = get(i, column);\n\t\t\tcolumnMatrix.set(i, 1, value);\n\t\t}\n\t\treturn columnMatrix;\n\t}\n\n\tMatrix getRow(int row) const {\n\t\tMatrix rowMatrix(1, columns);\n\t\tfor (int i = 1; i <= columns; ++ i) {\n\t\t\tdouble value = get(row, i);\n\t\t\trowMatrix.set(1, i, value);\n\t\t}\n\t\treturn rowMatrix;\n\t}\n\t\n\tMatrix concatenateRows(const Matrix & matrix2) const {\n\t\tMatrix matrix(rows + matrix2.rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= matrix2.rows; ++ i) {\n\t\t\tfor (int j = 1; j <= matrix2.columns; ++ j) {\n\t\t\t\tdouble value = matrix2.get(i, j);\n\t\t\t\tmatrix.set(rows + i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix concatenateColumns(const Matrix & matrix2) const {\n\t\tMatrix matrix(rows, columns + matrix2.columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= matrix2.rows; ++ i) {\n\t\t\tfor (int j = 1; j <= matrix2.columns; ++ j) {\n\t\t\t\tdouble value = matrix2.get(i, j);\n\t\t\t\tmatrix.set(i, columns + j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix reshape(int rows, int columns) const {\n\t\tMatrix matrix(rows, columns);\n\t\tint count = 0;\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\t\tint row2 = 1 + count % (*this).rows;\n\t\t\t\tint column2 = 1 + count / (*this).rows;\n\t\t\t\t++ count;\n\t\t\t\tdouble value = get(row2, column2);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\t\n\tMatrix transpose() const {\n\t\tMatrix matrix(columns, rows);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(j, i, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator * (const Matrix & matrix2) const {\n\t\tMatrix matrix(rows, matrix2.columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= matrix2.columns; ++ j) {\n\t\t\t\tdouble sum = 0;\n\t\t\t\tfor (int k = 1; k <= columns; ++ k) {\n\t\t\t\t\tdouble value1  = get(i, k);\n\t\t\t\t\tdouble value2 = matrix2.get(k, j);\n\t\t\t\t\tsum += value1 * value2;\n\t\t\t\t}\n\t\t\t\tmatrix.set(i, j, sum);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\n\tMatrix operator * (double times) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value * times);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator + (const Matrix & matrix2) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value1 = get(i, j);\n\t\t\t\tdouble value2 = matrix2.get(i, j);\n\t\t\t\tmatrix.set(i, j, value1 + value2);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator + (double value2) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value + value2);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator - (const Matrix & matrix2) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value1 = get(i, j);\n\t\t\t\tdouble value2 = matrix2.get(i, j);\n\t\t\t\tmatrix.set(i, j, value1 - value2);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator - (double value2) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value - value2);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix max() const {\n\t\tif (rows == 1) {\n\t\t\treturn transpose().max();\n\t\t}\n\t\tMatrix matrix(1, columns);\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tdouble max = get(1, j);\n\t\t\tfor (int i = 2; i <= rows; ++ i) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tif (max < value) max = value;\n\t\t\t}\n\t\t\tmatrix.set(1, j, max);\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix min() const {\n\t\tif (rows == 1) {\n\t\t\treturn transpose().min();\n\t\t}\n\t\tMatrix matrix(1, columns);\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tdouble min = get(1, j);\n\t\t\tfor (int i = 2; i <= rows; ++ i) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tif (min > value) min = value;\n\t\t\t}\n\t\t\tmatrix.set(1, j, min);\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix sum() const {\n\t\tif (rows == 1) {\n\t\t\treturn transpose().sum();\n\t\t}\n\t\tMatrix matrix(1, columns);\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tdouble sum = 0;\n\t\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\t\tsum += get(i, j);\n\t\t\t}\n\t\t\tmatrix.set(1, j, sum);\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix pow(double exponent) {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tvalue = ::pow(value, exponent);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix exp() {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tvalue = ::exp(value);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix log() {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tvalue = ::log(value);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix abs() {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tvalue = std::abs(value);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\n\tdouble norm(int k) {\n\t\tif (rows == 1) {\n\t\t\treturn transpose().norm(k);\n\t\t}\n\t\treturn ::pow(abs().pow(k).sum().get(1, 1), (1.0 / k));\n\t}\n\n};",
            "from random import randint\nr = randint(3,9)\nc = randint(3,9)\nprint(r, c)\nfor i in range(r*c):\n\tprint(randint(1,99), end=' ')\n",
            1588824000,
            1589461200
        ],
        [
            "2.3 (C++)",
            "Design a class Matrix that has the following private member variables:\n<ol>\n<li>int rows</li>\n<li>int columns</li>\n<li>double * values</li>\n</ol>\nBesides, it has the following public functions:\n<ol>\n<li>A constructor Matrix(int rows, int column, double values[]), which initializes all elements in the matrix to the given values. Note that the given values are in one-dimension, you need to fill them into the two-dimensional matrix correctly.</li>\n<li>A copy constructor Matrix(const Matrix &amp; matrix2).</li>\n<li>A destructor.</li>\n<li>A print function which prints each row of elements in a single line, with each element preceded with 4 spaces.</li>\n</ol>\n\n<u>EXAMPLE INPUT</u>\n<pre>4 5\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20</pre>\n\n<u>EXAMPLE OUTPUT</u>\n<pre>    1    2    3    4    5\n    6    7    8    9    10\n    11    12    13    14    15\n    16    17    18    19    20</pre>",
            "#include \"source.cpp\"\n\nint main() {\n\tint rows;\n\tint columns;\n\tdouble values[1000];\n\tcin >> rows >> columns;\n\tfor (int i = 0; i < rows * columns; ++ i) {\n\t\tcin >> values[i];\n\t}\n\tMatrix matrix1(rows, columns, values);\n\tMatrix matrix2(matrix1);\n\tmatrix2.print();\n}",
            "#include <iostream>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nclass Matrix\n{\n\t\nprivate:\n\t\n\tint rows;\n\tint columns;\n\tdouble * values;\n\t\npublic:\n\t\n\tint size(int dimension) const {\n\t\tswitch (dimension) {\n\t\t\tcase 1: return rows;\n\t\t\tcase 2: return columns;\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tvoid set(int row, int column, double value) {\n\t\t-- row;\n\t\t-- column;\n\t\tvalues[row * columns + column] = value;\n\t}\n\t\n\tdouble get(int row, int column) const {\n\t\t-- row;\n\t\t-- column;\n\t\treturn values[row * columns + column];\n\t}\n\nprivate:\n\t\n\tvoid assign0(int rows, int columns) {\n\t\t(*this).rows = rows;\n\t\t(*this).columns = columns;\n\t\t(*this).values = new double[rows * columns];\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tset(i, j, 0.0);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid assign0(int rows, int columns, const double values[]) {\n\t\t(*this).rows = rows;\n\t\t(*this).columns = columns;\n\t\t(*this).values = new double[rows * columns];\n\t\tint count = 0;\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tset(i, j, values[count]);\n\t\t\t\t++ count;\n\t\t\t}\n\t\t}\n\t}\n\t\npublic:\n\t\n\tMatrix(int rows, int columns) {\n\t\tassign0(rows, columns);\n\t}\n\t\n\tMatrix(int rows, int columns, const double values[]) {\n\t\tassign0(rows, columns, values);\n\t}\n\t\n\tMatrix(const Matrix & matrix2) {\n\t\tassign0(matrix2.rows, matrix2.columns, matrix2.values);\n\t}\n\t\n\t~Matrix() {\n\t\tdelete [] values;\n\t}\n\t\n\tvoid print() const {\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tcout << \"    \" << get(i, j);\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\t\n\tMatrix & operator = (const Matrix & matrix2) {\n\t\tdelete [] values;\n\t\tassign0(matrix2.rows, matrix2.columns, matrix2.values);\n\t\treturn (*this);\n\t}\n\t\n\tMatrix getColumn(int column) const {\n\t\tMatrix columnMatrix(rows, 1);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tdouble value = get(i, column);\n\t\t\tcolumnMatrix.set(i, 1, value);\n\t\t}\n\t\treturn columnMatrix;\n\t}\n\n\tMatrix getRow(int row) const {\n\t\tMatrix rowMatrix(1, columns);\n\t\tfor (int i = 1; i <= columns; ++ i) {\n\t\t\tdouble value = get(row, i);\n\t\t\trowMatrix.set(1, i, value);\n\t\t}\n\t\treturn rowMatrix;\n\t}\n\t\n\tMatrix concatenateRows(const Matrix & matrix2) const {\n\t\tMatrix matrix(rows + matrix2.rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= matrix2.rows; ++ i) {\n\t\t\tfor (int j = 1; j <= matrix2.columns; ++ j) {\n\t\t\t\tdouble value = matrix2.get(i, j);\n\t\t\t\tmatrix.set(rows + i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix concatenateColumns(const Matrix & matrix2) const {\n\t\tMatrix matrix(rows, columns + matrix2.columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= matrix2.rows; ++ i) {\n\t\t\tfor (int j = 1; j <= matrix2.columns; ++ j) {\n\t\t\t\tdouble value = matrix2.get(i, j);\n\t\t\t\tmatrix.set(i, columns + j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix reshape(int rows, int columns) const {\n\t\tMatrix matrix(rows, columns);\n\t\tint count = 0;\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\t\tint row2 = 1 + count % (*this).rows;\n\t\t\t\tint column2 = 1 + count / (*this).rows;\n\t\t\t\t++ count;\n\t\t\t\tdouble value = get(row2, column2);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\t\n\tMatrix transpose() const {\n\t\tMatrix matrix(columns, rows);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(j, i, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator * (const Matrix & matrix2) const {\n\t\tMatrix matrix(rows, matrix2.columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= matrix2.columns; ++ j) {\n\t\t\t\tdouble sum = 0;\n\t\t\t\tfor (int k = 1; k <= columns; ++ k) {\n\t\t\t\t\tdouble value1  = get(i, k);\n\t\t\t\t\tdouble value2 = matrix2.get(k, j);\n\t\t\t\t\tsum += value1 * value2;\n\t\t\t\t}\n\t\t\t\tmatrix.set(i, j, sum);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\n\tMatrix operator * (double times) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value * times);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator + (const Matrix & matrix2) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value1 = get(i, j);\n\t\t\t\tdouble value2 = matrix2.get(i, j);\n\t\t\t\tmatrix.set(i, j, value1 + value2);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator + (double value2) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value + value2);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator - (const Matrix & matrix2) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value1 = get(i, j);\n\t\t\t\tdouble value2 = matrix2.get(i, j);\n\t\t\t\tmatrix.set(i, j, value1 - value2);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator - (double value2) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value - value2);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix max() const {\n\t\tif (rows == 1) {\n\t\t\treturn transpose().max();\n\t\t}\n\t\tMatrix matrix(1, columns);\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tdouble max = get(1, j);\n\t\t\tfor (int i = 2; i <= rows; ++ i) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tif (max < value) max = value;\n\t\t\t}\n\t\t\tmatrix.set(1, j, max);\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix min() const {\n\t\tif (rows == 1) {\n\t\t\treturn transpose().min();\n\t\t}\n\t\tMatrix matrix(1, columns);\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tdouble min = get(1, j);\n\t\t\tfor (int i = 2; i <= rows; ++ i) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tif (min > value) min = value;\n\t\t\t}\n\t\t\tmatrix.set(1, j, min);\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix sum() const {\n\t\tif (rows == 1) {\n\t\t\treturn transpose().sum();\n\t\t}\n\t\tMatrix matrix(1, columns);\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tdouble sum = 0;\n\t\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\t\tsum += get(i, j);\n\t\t\t}\n\t\t\tmatrix.set(1, j, sum);\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix pow(double exponent) {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tvalue = ::pow(value, exponent);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix exp() {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tvalue = ::exp(value);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix log() {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tvalue = ::log(value);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix abs() {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tvalue = std::abs(value);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\n\tdouble norm(int k) {\n\t\tif (rows == 1) {\n\t\t\treturn transpose().norm(k);\n\t\t}\n\t\treturn ::pow(abs().pow(k).sum().get(1, 1), (1.0 / k));\n\t}\n\n};",
            "from random import randint\nr = randint(3,9)\nc = randint(3,9)\nprint(r, c)\nfor i in range(r*c):\n\tprint(randint(1,99), end=' ')",
            1588824000,
            1589461200
        ],
        [
            "2.4 (C++)",
            "Design a class Matrix that has the following private member variables:\n<ol>\n<li>int rows</li>\n<li>int columns</li>\n<li>double * values</li>\n</ol>\nBesides, it has the following public functions:\n<ol>\n<li>A constructor Matrix(int rows, int column), which initializes all elements in the matrix to 0's.</li>\n<li>A constructor Matrix(int rows, int column, double values[]), which initializes all elements in the matrix to the given values. Note that the given values are in one-dimension, you need to fill them into the two-dimensional matrix correctly.</li>\n<li>A destructor.</li>\n<li>A print function which prints each row of elements in a single line, with each element preceded by 4 spaces.</li>\n<li>A function set(int row, int column, double value) that sets a value of an element in the matrix. Note that indexes in Matrix starts from 1 instead of 0.</li>\n<li>The operator =.</li>\n</ol>\n\n<u>EXAMPLE INPUT</u>\n<pre>4 5\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20\n2 3\n1.5</pre>\n\n<u>EXAMPLE OUTPUT</u>\n<pre>    1    2    3    4    5\n    6    7    1.5    9    10\n    11    12    13    14    15\n    16    17    18    19    20</pre>",
            "#include \"source.cpp\"\n\nint main() {\n\tint rows;\n\tint columns;\n\tdouble values[1000];\n\tcin >> rows >> columns;\n\tfor (int i = 0; i < rows * columns; ++ i) {\n\t\tcin >> values[i];\n\t}\n\tMatrix matrix1(rows, columns, values);\n\n\tint row;\n\tint column;\n\tdouble value;\n\tcin >> row >> column >> value;\n\tMatrix matrix2(0, 0);\n\tmatrix2 = matrix1;\n\tmatrix2.set(row, column, value);\n\tmatrix2.print();\n\t\n}",
            "#include <iostream>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nclass Matrix\n{\n\t\nprivate:\n\t\n\tint rows;\n\tint columns;\n\tdouble * values;\n\t\npublic:\n\t\n\tint size(int dimension) const {\n\t\tswitch (dimension) {\n\t\t\tcase 1: return rows;\n\t\t\tcase 2: return columns;\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tvoid set(int row, int column, double value) {\n\t\t-- row;\n\t\t-- column;\n\t\tvalues[row * columns + column] = value;\n\t}\n\t\n\tdouble get(int row, int column) const {\n\t\t-- row;\n\t\t-- column;\n\t\treturn values[row * columns + column];\n\t}\n\nprivate:\n\t\n\tvoid assign0(int rows, int columns) {\n\t\t(*this).rows = rows;\n\t\t(*this).columns = columns;\n\t\t(*this).values = new double[rows * columns];\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tset(i, j, 0.0);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid assign0(int rows, int columns, const double values[]) {\n\t\t(*this).rows = rows;\n\t\t(*this).columns = columns;\n\t\t(*this).values = new double[rows * columns];\n\t\tint count = 0;\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tset(i, j, values[count]);\n\t\t\t\t++ count;\n\t\t\t}\n\t\t}\n\t}\n\t\npublic:\n\t\n\tMatrix(int rows, int columns) {\n\t\tassign0(rows, columns);\n\t}\n\t\n\tMatrix(int rows, int columns, const double values[]) {\n\t\tassign0(rows, columns, values);\n\t}\n\t\n\tMatrix(const Matrix & matrix2) {\n\t\tassign0(matrix2.rows, matrix2.columns, matrix2.values);\n\t}\n\t\n\t~Matrix() {\n\t\tdelete [] values;\n\t}\n\t\n\tvoid print() const {\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tcout << \"    \" << get(i, j);\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\t\n\tMatrix & operator = (const Matrix & matrix2) {\n\t\tdelete [] values;\n\t\tassign0(matrix2.rows, matrix2.columns, matrix2.values);\n\t\treturn (*this);\n\t}\n\t\n\tMatrix getColumn(int column) const {\n\t\tMatrix columnMatrix(rows, 1);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tdouble value = get(i, column);\n\t\t\tcolumnMatrix.set(i, 1, value);\n\t\t}\n\t\treturn columnMatrix;\n\t}\n\n\tMatrix getRow(int row) const {\n\t\tMatrix rowMatrix(1, columns);\n\t\tfor (int i = 1; i <= columns; ++ i) {\n\t\t\tdouble value = get(row, i);\n\t\t\trowMatrix.set(1, i, value);\n\t\t}\n\t\treturn rowMatrix;\n\t}\n\t\n\tMatrix concatenateRows(const Matrix & matrix2) const {\n\t\tMatrix matrix(rows + matrix2.rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= matrix2.rows; ++ i) {\n\t\t\tfor (int j = 1; j <= matrix2.columns; ++ j) {\n\t\t\t\tdouble value = matrix2.get(i, j);\n\t\t\t\tmatrix.set(rows + i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix concatenateColumns(const Matrix & matrix2) const {\n\t\tMatrix matrix(rows, columns + matrix2.columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= matrix2.rows; ++ i) {\n\t\t\tfor (int j = 1; j <= matrix2.columns; ++ j) {\n\t\t\t\tdouble value = matrix2.get(i, j);\n\t\t\t\tmatrix.set(i, columns + j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix reshape(int rows, int columns) const {\n\t\tMatrix matrix(rows, columns);\n\t\tint count = 0;\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\t\tint row2 = 1 + count % (*this).rows;\n\t\t\t\tint column2 = 1 + count / (*this).rows;\n\t\t\t\t++ count;\n\t\t\t\tdouble value = get(row2, column2);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\t\n\tMatrix transpose() const {\n\t\tMatrix matrix(columns, rows);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(j, i, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator * (const Matrix & matrix2) const {\n\t\tMatrix matrix(rows, matrix2.columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= matrix2.columns; ++ j) {\n\t\t\t\tdouble sum = 0;\n\t\t\t\tfor (int k = 1; k <= columns; ++ k) {\n\t\t\t\t\tdouble value1  = get(i, k);\n\t\t\t\t\tdouble value2 = matrix2.get(k, j);\n\t\t\t\t\tsum += value1 * value2;\n\t\t\t\t}\n\t\t\t\tmatrix.set(i, j, sum);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\n\tMatrix operator * (double times) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value * times);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator + (const Matrix & matrix2) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value1 = get(i, j);\n\t\t\t\tdouble value2 = matrix2.get(i, j);\n\t\t\t\tmatrix.set(i, j, value1 + value2);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator + (double value2) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value + value2);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator - (const Matrix & matrix2) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value1 = get(i, j);\n\t\t\t\tdouble value2 = matrix2.get(i, j);\n\t\t\t\tmatrix.set(i, j, value1 - value2);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator - (double value2) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value - value2);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix max() const {\n\t\tif (rows == 1) {\n\t\t\treturn transpose().max();\n\t\t}\n\t\tMatrix matrix(1, columns);\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tdouble max = get(1, j);\n\t\t\tfor (int i = 2; i <= rows; ++ i) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tif (max < value) max = value;\n\t\t\t}\n\t\t\tmatrix.set(1, j, max);\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix min() const {\n\t\tif (rows == 1) {\n\t\t\treturn transpose().min();\n\t\t}\n\t\tMatrix matrix(1, columns);\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tdouble min = get(1, j);\n\t\t\tfor (int i = 2; i <= rows; ++ i) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tif (min > value) min = value;\n\t\t\t}\n\t\t\tmatrix.set(1, j, min);\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix sum() const {\n\t\tif (rows == 1) {\n\t\t\treturn transpose().sum();\n\t\t}\n\t\tMatrix matrix(1, columns);\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tdouble sum = 0;\n\t\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\t\tsum += get(i, j);\n\t\t\t}\n\t\t\tmatrix.set(1, j, sum);\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix pow(double exponent) {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tvalue = ::pow(value, exponent);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix exp() {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tvalue = ::exp(value);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix log() {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tvalue = ::log(value);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix abs() {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tvalue = std::abs(value);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\n\tdouble norm(int k) {\n\t\tif (rows == 1) {\n\t\t\treturn transpose().norm(k);\n\t\t}\n\t\treturn ::pow(abs().pow(k).sum().get(1, 1), (1.0 / k));\n\t}\n\n};",
            "from random import randint\nr = randint(3,9)\nc = randint(3,9)\nprint(r, c)\nfor i in range(r*c):\n\tprint(randint(1,99), end=' ')\nr = randint(1,r)\nc = randint(1,c)\nv = randint(1,1000)/1000\nprint()\nprint(r,c)\nprint(v)",
            1589508000,
            1590066000
        ],
        [
            "2.5 (C++)",
            "Design a class Matrix that has the following private member variables:\n<ol>\n<li>int rows</li>\n<li>int columns</li>\n<li>double * values</li>\n</ol>\nBesides, it has the following public functions:\n<ol>\n<li>A constructor Matrix(int rows, int column), which initializes all elements in the matrix to 0's.</li>\n<li>A constructor Matrix(int rows, int column, double values[]), which initializes all elements in the matrix to the given values. Note that the given values are in one-dimension, you need to fill them into the two-dimensional matrix correctly.</li>\n<li>A destructor.</li>\n<li>A print function which prints each row of elements in a single line, with each element preceded by 4 spaces.</li>\n<li>A function getRow(int row), which returns a row matrix for the given row.</li>\n<li>A function getColumn(int column), which returns a column matrix for the given column.</li>\n</ol>\n\n<u>EXAMPLE INPUT</u>\n<pre>4 5\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20\n2\n3\n</pre>\n\n<u>EXAMPLE OUTPUT</u>\n<pre>    1    2    3    4    5\n    6    7    8    9    10\n    11    12    13    14    15\n    16    17    18    19    20\n\n    6    7    8    9    10\n\n    3\n    8\n    13\n    18</pre>",
            "#include \"source.cpp\"\n\nint main() {\n\tint rows;\n\tint columns;\n\tdouble values[1000];\n\tcin >> rows >> columns;\n\tfor (int i = 0; i < rows * columns; ++ i) {\n\t\tcin >> values[i];\n\t}\n\tMatrix matrix1(rows, columns, values);\n\tmatrix1.print();\n\tcout << endl;\n\n\tint row;\n\tint column;\n\tcin >> row >> column;\n\tmatrix1.getRow(row).print();\n\tcout << endl;\n\tmatrix1.getColumn(column).print();\n\t\n}",
            "#include <iostream>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nclass Matrix\n{\n\t\nprivate:\n\t\n\tint rows;\n\tint columns;\n\tdouble * values;\n\t\npublic:\n\t\n\tint size(int dimension) const {\n\t\tswitch (dimension) {\n\t\t\tcase 1: return rows;\n\t\t\tcase 2: return columns;\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tvoid set(int row, int column, double value) {\n\t\t-- row;\n\t\t-- column;\n\t\tvalues[row * columns + column] = value;\n\t}\n\t\n\tdouble get(int row, int column) const {\n\t\t-- row;\n\t\t-- column;\n\t\treturn values[row * columns + column];\n\t}\n\nprivate:\n\t\n\tvoid assign0(int rows, int columns) {\n\t\t(*this).rows = rows;\n\t\t(*this).columns = columns;\n\t\t(*this).values = new double[rows * columns];\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tset(i, j, 0.0);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid assign0(int rows, int columns, const double values[]) {\n\t\t(*this).rows = rows;\n\t\t(*this).columns = columns;\n\t\t(*this).values = new double[rows * columns];\n\t\tint count = 0;\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tset(i, j, values[count]);\n\t\t\t\t++ count;\n\t\t\t}\n\t\t}\n\t}\n\t\npublic:\n\t\n\tMatrix(int rows, int columns) {\n\t\tassign0(rows, columns);\n\t}\n\t\n\tMatrix(int rows, int columns, const double values[]) {\n\t\tassign0(rows, columns, values);\n\t}\n\t\n\tMatrix(const Matrix & matrix2) {\n\t\tassign0(matrix2.rows, matrix2.columns, matrix2.values);\n\t}\n\t\n\t~Matrix() {\n\t\tdelete [] values;\n\t}\n\t\n\tvoid print() const {\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tcout << \"    \" << get(i, j);\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\t\n\tMatrix & operator = (const Matrix & matrix2) {\n\t\tdelete [] values;\n\t\tassign0(matrix2.rows, matrix2.columns, matrix2.values);\n\t\treturn (*this);\n\t}\n\t\n\tMatrix getColumn(int column) const {\n\t\tMatrix columnMatrix(rows, 1);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tdouble value = get(i, column);\n\t\t\tcolumnMatrix.set(i, 1, value);\n\t\t}\n\t\treturn columnMatrix;\n\t}\n\n\tMatrix getRow(int row) const {\n\t\tMatrix rowMatrix(1, columns);\n\t\tfor (int i = 1; i <= columns; ++ i) {\n\t\t\tdouble value = get(row, i);\n\t\t\trowMatrix.set(1, i, value);\n\t\t}\n\t\treturn rowMatrix;\n\t}\n\t\n\tMatrix concatenateRows(const Matrix & matrix2) const {\n\t\tMatrix matrix(rows + matrix2.rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= matrix2.rows; ++ i) {\n\t\t\tfor (int j = 1; j <= matrix2.columns; ++ j) {\n\t\t\t\tdouble value = matrix2.get(i, j);\n\t\t\t\tmatrix.set(rows + i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix concatenateColumns(const Matrix & matrix2) const {\n\t\tMatrix matrix(rows, columns + matrix2.columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= matrix2.rows; ++ i) {\n\t\t\tfor (int j = 1; j <= matrix2.columns; ++ j) {\n\t\t\t\tdouble value = matrix2.get(i, j);\n\t\t\t\tmatrix.set(i, columns + j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix reshape(int rows, int columns) const {\n\t\tMatrix matrix(rows, columns);\n\t\tint count = 0;\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\t\tint row2 = 1 + count % (*this).rows;\n\t\t\t\tint column2 = 1 + count / (*this).rows;\n\t\t\t\t++ count;\n\t\t\t\tdouble value = get(row2, column2);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\t\n\tMatrix transpose() const {\n\t\tMatrix matrix(columns, rows);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(j, i, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator * (const Matrix & matrix2) const {\n\t\tMatrix matrix(rows, matrix2.columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= matrix2.columns; ++ j) {\n\t\t\t\tdouble sum = 0;\n\t\t\t\tfor (int k = 1; k <= columns; ++ k) {\n\t\t\t\t\tdouble value1  = get(i, k);\n\t\t\t\t\tdouble value2 = matrix2.get(k, j);\n\t\t\t\t\tsum += value1 * value2;\n\t\t\t\t}\n\t\t\t\tmatrix.set(i, j, sum);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\n\tMatrix operator * (double times) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value * times);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator + (const Matrix & matrix2) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value1 = get(i, j);\n\t\t\t\tdouble value2 = matrix2.get(i, j);\n\t\t\t\tmatrix.set(i, j, value1 + value2);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator + (double value2) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value + value2);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator - (const Matrix & matrix2) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value1 = get(i, j);\n\t\t\t\tdouble value2 = matrix2.get(i, j);\n\t\t\t\tmatrix.set(i, j, value1 - value2);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator - (double value2) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value - value2);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix max() const {\n\t\tif (rows == 1) {\n\t\t\treturn transpose().max();\n\t\t}\n\t\tMatrix matrix(1, columns);\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tdouble max = get(1, j);\n\t\t\tfor (int i = 2; i <= rows; ++ i) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tif (max < value) max = value;\n\t\t\t}\n\t\t\tmatrix.set(1, j, max);\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix min() const {\n\t\tif (rows == 1) {\n\t\t\treturn transpose().min();\n\t\t}\n\t\tMatrix matrix(1, columns);\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tdouble min = get(1, j);\n\t\t\tfor (int i = 2; i <= rows; ++ i) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tif (min > value) min = value;\n\t\t\t}\n\t\t\tmatrix.set(1, j, min);\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix sum() const {\n\t\tif (rows == 1) {\n\t\t\treturn transpose().sum();\n\t\t}\n\t\tMatrix matrix(1, columns);\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tdouble sum = 0;\n\t\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\t\tsum += get(i, j);\n\t\t\t}\n\t\t\tmatrix.set(1, j, sum);\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix pow(double exponent) {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tvalue = ::pow(value, exponent);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix exp() {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tvalue = ::exp(value);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix log() {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tvalue = ::log(value);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix abs() {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tvalue = std::abs(value);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n  \n\tdouble norm(int k) {\n\t\tif (rows == 1) {\n\t\t\treturn transpose().norm(k);\n\t\t}\n\t\treturn ::pow(abs().pow(k).sum().get(1, 1), (1.0 / k));\n\t}\n\n};",
            "from random import randint\nr = randint(3,9)\nc = randint(3,9)\nprint(r, c)\nfor i in range(r*c):\n\tprint(randint(1,99), end=' ')\nr = randint(1,r)\nc = randint(1,c)\nprint()\nprint(r)\nprint(c)",
            1588824000,
            1589461200
        ],
        [
            "2.6 (C++)",
            "Design a class Matrix that has the following private member variables:\n<ol>\n<li>int rows</li>\n<li>int columns</li>\n<li>double * values</li>\n</ol>\nBesides, it has the following public object functions:\n<ol>\n<li>A constructor Matrix(int rows, int column, double values[]), which initializes all elements in the matrix to the given values. Note that the given values are in one-dimensional, you need to fill then into the two-dimensional matrix correctly.</li>\n<li>A copy constructor Matrix(const Matrix & matrix2).</li>\n<li>A destructor.</li>\n<li>A print function which prints each row of elements in a single line, with each element preceded with 4 spaces.</li>\n<li>A function Matrix Matrix::concatenateRows(const Matrix & matrix2) const, which returns a matrix that is the concatenation of the rows of the invisible object parameter and <i>matrix2</i>.</li>\n<li>A function Matrix Matrix::concatenateColumns(const Matrix & matrix2) const, which returns a matrix that is the concatenation of the columns of the invisible object parameter and <i>matrix2</i>.</li>\n</ol>\n\n<u>EXAMPLE INPUT</u>\n<pre>4 5\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20\n4 5\n21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40</pre>\n\n<u>EXAMPLE OUTPUT</u>\n<pre>    1    2    3    4    5\n    6    7    8    9    10\n    11    12    13    14    15\n    16    17    18    19    20\n    21    22    23    24    25\n    26    27    28    29    30\n    31    32    33    34    35\n    36    37    38    39    40\n\n    1    2    3    4    5    21    22    23    24    25\n    6    7    8    9    10    26    27    28    29    30\n    11    12    13    14    15    31    32    33    34    35\n    16    17    18    19    20    36    37    38    39    40</pre>",
            "#include \"source.cpp\"\n\nMatrix read() {\n\tint rows;\n\tint columns;\n\tdouble values[1000];\n\tcin >> rows >> columns;\n\tfor (int i = 0; i < rows * columns; ++ i) {\n\t\tcin >> values[i];\n\t}\n\tMatrix matrix(rows, columns, values);\n\treturn matrix;\n}\n\nint main() {\n\tMatrix matrix1 = read(); // calls copy constructor\n\tMatrix matrix2 = read();\n\t\n\tmatrix1.concatenateRows(matrix2).print();\n\tcout << endl;\n\tmatrix1.concatenateColumns(matrix2).print();\n}",
            "#include <iostream>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nclass Matrix\n{\n\t\nprivate:\n\t\n\tint rows;\n\tint columns;\n\tdouble * values;\n\t\npublic:\n\t\n\tint size(int dimension) const {\n\t\tswitch (dimension) {\n\t\t\tcase 1: return rows;\n\t\t\tcase 2: return columns;\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tvoid set(int row, int column, double value) {\n\t\t-- row;\n\t\t-- column;\n\t\tvalues[row * columns + column] = value;\n\t}\n\t\n\tdouble get(int row, int column) const {\n\t\t-- row;\n\t\t-- column;\n\t\treturn values[row * columns + column];\n\t}\n\nprivate:\n\t\n\tvoid assign0(int rows, int columns) {\n\t\t(*this).rows = rows;\n\t\t(*this).columns = columns;\n\t\t(*this).values = new double[rows * columns];\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tset(i, j, 0.0);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid assign0(int rows, int columns, const double values[]) {\n\t\t(*this).rows = rows;\n\t\t(*this).columns = columns;\n\t\t(*this).values = new double[rows * columns];\n\t\tint count = 0;\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tset(i, j, values[count]);\n\t\t\t\t++ count;\n\t\t\t}\n\t\t}\n\t}\n\t\npublic:\n\t\n\tMatrix(int rows, int columns) {\n\t\tassign0(rows, columns);\n\t}\n\t\n\tMatrix(int rows, int columns, const double values[]) {\n\t\tassign0(rows, columns, values);\n\t}\n\t\n\tMatrix(const Matrix & matrix2) {\n\t\tassign0(matrix2.rows, matrix2.columns, matrix2.values);\n\t}\n\t\n\t~Matrix() {\n\t\tdelete [] values;\n\t}\n\t\n\tvoid print() const {\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tcout << \"    \" << get(i, j);\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\t\n\tMatrix & operator = (const Matrix & matrix2) {\n\t\tdelete [] values;\n\t\tassign0(matrix2.rows, matrix2.columns, matrix2.values);\n\t\treturn (*this);\n\t}\n\t\n\tMatrix getColumn(int column) const {\n\t\tMatrix columnMatrix(rows, 1);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tdouble value = get(i, column);\n\t\t\tcolumnMatrix.set(i, 1, value);\n\t\t}\n\t\treturn columnMatrix;\n\t}\n\n\tMatrix getRow(int row) const {\n\t\tMatrix rowMatrix(1, columns);\n\t\tfor (int i = 1; i <= columns; ++ i) {\n\t\t\tdouble value = get(row, i);\n\t\t\trowMatrix.set(1, i, value);\n\t\t}\n\t\treturn rowMatrix;\n\t}\n\t\n\tMatrix concatenateRows(const Matrix & matrix2) const {\n\t\tMatrix matrix(rows + matrix2.rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= matrix2.rows; ++ i) {\n\t\t\tfor (int j = 1; j <= matrix2.columns; ++ j) {\n\t\t\t\tdouble value = matrix2.get(i, j);\n\t\t\t\tmatrix.set(rows + i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix concatenateColumns(const Matrix & matrix2) const {\n\t\tMatrix matrix(rows, columns + matrix2.columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= matrix2.rows; ++ i) {\n\t\t\tfor (int j = 1; j <= matrix2.columns; ++ j) {\n\t\t\t\tdouble value = matrix2.get(i, j);\n\t\t\t\tmatrix.set(i, columns + j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix reshape(int rows, int columns) const {\n\t\tMatrix matrix(rows, columns);\n\t\tint count = 0;\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\t\tint row2 = 1 + count % (*this).rows;\n\t\t\t\tint column2 = 1 + count / (*this).rows;\n\t\t\t\t++ count;\n\t\t\t\tdouble value = get(row2, column2);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\t\n\tMatrix transpose() const {\n\t\tMatrix matrix(columns, rows);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(j, i, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator * (const Matrix & matrix2) const {\n\t\tMatrix matrix(rows, matrix2.columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= matrix2.columns; ++ j) {\n\t\t\t\tdouble sum = 0;\n\t\t\t\tfor (int k = 1; k <= columns; ++ k) {\n\t\t\t\t\tdouble value1  = get(i, k);\n\t\t\t\t\tdouble value2 = matrix2.get(k, j);\n\t\t\t\t\tsum += value1 * value2;\n\t\t\t\t}\n\t\t\t\tmatrix.set(i, j, sum);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\n\tMatrix operator * (double times) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value * times);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator + (const Matrix & matrix2) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value1 = get(i, j);\n\t\t\t\tdouble value2 = matrix2.get(i, j);\n\t\t\t\tmatrix.set(i, j, value1 + value2);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator + (double value2) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value + value2);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator - (const Matrix & matrix2) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value1 = get(i, j);\n\t\t\t\tdouble value2 = matrix2.get(i, j);\n\t\t\t\tmatrix.set(i, j, value1 - value2);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator - (double value2) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value - value2);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix max() const {\n\t\tif (rows == 1) {\n\t\t\treturn transpose().max();\n\t\t}\n\t\tMatrix matrix(1, columns);\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tdouble max = get(1, j);\n\t\t\tfor (int i = 2; i <= rows; ++ i) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tif (max < value) max = value;\n\t\t\t}\n\t\t\tmatrix.set(1, j, max);\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix min() const {\n\t\tif (rows == 1) {\n\t\t\treturn transpose().min();\n\t\t}\n\t\tMatrix matrix(1, columns);\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tdouble min = get(1, j);\n\t\t\tfor (int i = 2; i <= rows; ++ i) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tif (min > value) min = value;\n\t\t\t}\n\t\t\tmatrix.set(1, j, min);\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix sum() const {\n\t\tif (rows == 1) {\n\t\t\treturn transpose().sum();\n\t\t}\n\t\tMatrix matrix(1, columns);\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tdouble sum = 0;\n\t\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\t\tsum += get(i, j);\n\t\t\t}\n\t\t\tmatrix.set(1, j, sum);\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix pow(double exponent) {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tvalue = ::pow(value, exponent);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix exp() {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tvalue = ::exp(value);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix log() {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tvalue = ::log(value);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix abs() {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tvalue = std::abs(value);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\n\tdouble norm(int k) {\n\t\tif (rows == 1) {\n\t\t\treturn transpose().norm(k);\n\t\t}\n\t\treturn ::pow(abs().pow(k).sum().get(1, 1), (1.0 / k));\n\t}\n\n};",
            "from random import randint\nr = randint(3,9)\nc = randint(3,9)\nprint(r, c)\nfor i in range(r*c):\n\tprint(randint(1,99), end=' ')\nprint()\nprint(r, c)\nfor i in range(r*c):\n\tprint(randint(1,99), end=' ')",
            1588824000,
            1589461200
        ],
        [
            "2.7 (C++)",
            "Design a class Matrix that has the following private member variables:\n<ol>\n<li>int rows</li>\n<li>int columns</li>\n<li>double * values</li>\n</ol>\nBesides, it has the following public object functions:\n<ol>\n<li>A constructor Matrix(int rows, int column, double values[]), which initializes all elements in the matrix to the given values. Note that the given values are in one-dimensional, you need to fill then into the two-dimensional matrix correctly.</li>\n<li>A copy constructor Matrix(const Matrix & matrix2).</li>\n<li>A destructor.</li>\n<li>A print function which prints each row of elements in a single line, with each element preceded with 4 spaces.</li>\n<li>A function Matrix Matrix::reshape(int rows, int columns) const, which returns a matrix that has the same elements as the default parameter of this object function (the invisible object parameter), but has different rows and columns as given by the parameters. Elements are moved from the invisible object parameter into the returned matrix ordered first by column and then by row.</li>\n</ol>\n\n<u>EXAMPLE INPUT</u>\n<pre>4 6\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24\n6 4</pre>\n\n<u>EXAMPLE OUTPUT</u>\n<pre>    1    2    3    4    5    6\n    7    8    9    10    11    12\n    13    14    15    16    17    18\n    19    20    21    22    23    24\n\n    1    14    4    17\n    7    20    10    23\n    13    3    16    6\n    19    9    22    12\n    2    15    5    18\n    8    21    11    24</pre>",
            "#include \"source.cpp\"\n\nMatrix read() {\n\tint rows;\n\tint columns;\n\tdouble values[1000];\n\tcin >> rows >> columns;\n\tfor (int i = 0; i < rows * columns; ++ i) {\n\t\tcin >> values[i];\n\t}\n\tMatrix matrix(rows, columns, values);\n\treturn matrix;\n}\n\nint main() {\n\tMatrix matrix = read(); // calls copy constructor\n\tmatrix.print();\n\tcout << endl;\n\n\tint rows;\n\tint columns;\n\tcin >> rows >> columns;\n\n\tmatrix.reshape(rows, columns).print();\n}",
            "#include <iostream>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nclass Matrix\n{\n\t\nprivate:\n\t\n\tint rows;\n\tint columns;\n\tdouble * values;\n\t\npublic:\n\t\n\tint size(int dimension) const {\n\t\tswitch (dimension) {\n\t\t\tcase 1: return rows;\n\t\t\tcase 2: return columns;\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tvoid set(int row, int column, double value) {\n\t\t-- row;\n\t\t-- column;\n\t\tvalues[row * columns + column] = value;\n\t}\n\t\n\tdouble get(int row, int column) const {\n\t\t-- row;\n\t\t-- column;\n\t\treturn values[row * columns + column];\n\t}\n\nprivate:\n\t\n\tvoid assign0(int rows, int columns) {\n\t\t(*this).rows = rows;\n\t\t(*this).columns = columns;\n\t\t(*this).values = new double[rows * columns];\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tset(i, j, 0.0);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid assign0(int rows, int columns, const double values[]) {\n\t\t(*this).rows = rows;\n\t\t(*this).columns = columns;\n\t\t(*this).values = new double[rows * columns];\n\t\tint count = 0;\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tset(i, j, values[count]);\n\t\t\t\t++ count;\n\t\t\t}\n\t\t}\n\t}\n\t\npublic:\n\t\n\tMatrix(int rows, int columns) {\n\t\tassign0(rows, columns);\n\t}\n\t\n\tMatrix(int rows, int columns, const double values[]) {\n\t\tassign0(rows, columns, values);\n\t}\n\t\n\tMatrix(const Matrix & matrix2) {\n\t\tassign0(matrix2.rows, matrix2.columns, matrix2.values);\n\t}\n\t\n\t~Matrix() {\n\t\tdelete [] values;\n\t}\n\t\n\tvoid print() const {\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tcout << \"    \" << get(i, j);\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\t\n\tMatrix & operator = (const Matrix & matrix2) {\n\t\tdelete [] values;\n\t\tassign0(matrix2.rows, matrix2.columns, matrix2.values);\n\t\treturn (*this);\n\t}\n\t\n\tMatrix getColumn(int column) const {\n\t\tMatrix columnMatrix(rows, 1);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tdouble value = get(i, column);\n\t\t\tcolumnMatrix.set(i, 1, value);\n\t\t}\n\t\treturn columnMatrix;\n\t}\n\n\tMatrix getRow(int row) const {\n\t\tMatrix rowMatrix(1, columns);\n\t\tfor (int i = 1; i <= columns; ++ i) {\n\t\t\tdouble value = get(row, i);\n\t\t\trowMatrix.set(1, i, value);\n\t\t}\n\t\treturn rowMatrix;\n\t}\n\t\n\tMatrix concatenateRows(const Matrix & matrix2) const {\n\t\tMatrix matrix(rows + matrix2.rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= matrix2.rows; ++ i) {\n\t\t\tfor (int j = 1; j <= matrix2.columns; ++ j) {\n\t\t\t\tdouble value = matrix2.get(i, j);\n\t\t\t\tmatrix.set(rows + i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix concatenateColumns(const Matrix & matrix2) const {\n\t\tMatrix matrix(rows, columns + matrix2.columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= matrix2.rows; ++ i) {\n\t\t\tfor (int j = 1; j <= matrix2.columns; ++ j) {\n\t\t\t\tdouble value = matrix2.get(i, j);\n\t\t\t\tmatrix.set(i, columns + j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix reshape(int rows, int columns) const {\n\t\tMatrix matrix(rows, columns);\n\t\tint count = 0;\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\t\tint row2 = 1 + count % (*this).rows;\n\t\t\t\tint column2 = 1 + count / (*this).rows;\n\t\t\t\t++ count;\n\t\t\t\tdouble value = get(row2, column2);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\t\n\tMatrix transpose() const {\n\t\tMatrix matrix(columns, rows);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(j, i, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator * (const Matrix & matrix2) const {\n\t\tMatrix matrix(rows, matrix2.columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= matrix2.columns; ++ j) {\n\t\t\t\tdouble sum = 0;\n\t\t\t\tfor (int k = 1; k <= columns; ++ k) {\n\t\t\t\t\tdouble value1  = get(i, k);\n\t\t\t\t\tdouble value2 = matrix2.get(k, j);\n\t\t\t\t\tsum += value1 * value2;\n\t\t\t\t}\n\t\t\t\tmatrix.set(i, j, sum);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\n\tMatrix operator * (double times) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value * times);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator + (const Matrix & matrix2) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value1 = get(i, j);\n\t\t\t\tdouble value2 = matrix2.get(i, j);\n\t\t\t\tmatrix.set(i, j, value1 + value2);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator + (double value2) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value + value2);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator - (const Matrix & matrix2) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value1 = get(i, j);\n\t\t\t\tdouble value2 = matrix2.get(i, j);\n\t\t\t\tmatrix.set(i, j, value1 - value2);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator - (double value2) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value - value2);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix max() const {\n\t\tif (rows == 1) {\n\t\t\treturn transpose().max();\n\t\t}\n\t\tMatrix matrix(1, columns);\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tdouble max = get(1, j);\n\t\t\tfor (int i = 2; i <= rows; ++ i) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tif (max < value) max = value;\n\t\t\t}\n\t\t\tmatrix.set(1, j, max);\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix min() const {\n\t\tif (rows == 1) {\n\t\t\treturn transpose().min();\n\t\t}\n\t\tMatrix matrix(1, columns);\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tdouble min = get(1, j);\n\t\t\tfor (int i = 2; i <= rows; ++ i) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tif (min > value) min = value;\n\t\t\t}\n\t\t\tmatrix.set(1, j, min);\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix sum() const {\n\t\tif (rows == 1) {\n\t\t\treturn transpose().sum();\n\t\t}\n\t\tMatrix matrix(1, columns);\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tdouble sum = 0;\n\t\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\t\tsum += get(i, j);\n\t\t\t}\n\t\t\tmatrix.set(1, j, sum);\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix pow(double exponent) {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tvalue = ::pow(value, exponent);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix exp() {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tvalue = ::exp(value);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix log() {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tvalue = ::log(value);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix abs() {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tvalue = std::abs(value);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\n\tdouble norm(int k) {\n\t\tif (rows == 1) {\n\t\t\treturn transpose().norm(k);\n\t\t}\n\t\treturn ::pow(abs().pow(k).sum().get(1, 1), (1.0 / k));\n\t}\n\n};",
            "from random import randint\nr = randint(3,9)\nc = randint(3,9)\nprint(r, c)\nfor i in range(r*c):\n\tprint(randint(1,99), end=' ')\nprint()\nfor i in range(100):\n\tr2 = randint(3,9)\n\tif r2 == r: continue\n\tif r*c % r2 == 0:\n\t\tprint(r2, r*c//r2)\n\t\tbreak\nelse:\n\tprint(c, r)\n",
            1589508000,
            1590066000
        ],
        [
            "2.8 (C++)",
            "Design a class Matrix that has the following private member variables:\n<ol>\n<li>int rows</li>\n<li>int columns</li>\n<li>double * values</li>\n</ol>\nBesides, it has the following public object functions:\n<ol>\n<li>A constructor Matrix(int rows, int column, double values[]), which initializes all elements in the matrix to the given values. Note that the given values are in one-dimensional, you need to fill then into the two-dimensional matrix correctly.</li>\n<li>A copy constructor Matrix(const Matrix & matrix2).</li>\n<li>A destructor.</li>\n<li>A print function which prints each row of elements in a single line, with each element preceded with 4 spaces.</li>\n<li>A function Matrix Matrix::transpose(), which returns a matrix that is the transpose of the default parameter (the invisible object parameter).</li>\n</ol>\n\n<u>EXAMPLE INPUT</u>\n<pre>4 5\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20</pre>\n\n<u>EXAMPLE OUTPUT</u>\n<pre>    1    2    3    4    5\n    6    7    8    9    10\n    11    12    13    14    15\n    16    17    18    19    20\n\n    1    6    11    16\n    2    7    12    17\n    3    8    13    18\n    4    9    14    19\n    5    10    15    20</pre>",
            "#include \"source.cpp\"\n\nMatrix read() {\n\tint rows;\n\tint columns;\n\tdouble values[1000];\n\tcin >> rows >> columns;\n\tfor (int i = 0; i < rows * columns; ++ i) {\n\t\tcin >> values[i];\n\t}\n\tMatrix matrix(rows, columns, values);\n\treturn matrix;\n}\n\nint main() {\n\tMatrix matrix = read(); // calls copy constructor\n\tmatrix.print();\n\tcout << endl;\n\t\n\tmatrix.transpose().print();\n}",
            "#include <iostream>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nclass Matrix\n{\n\t\nprivate:\n\t\n\tint rows;\n\tint columns;\n\tdouble * values;\n\t\npublic:\n\t\n\tint size(int dimension) const {\n\t\tswitch (dimension) {\n\t\t\tcase 1: return rows;\n\t\t\tcase 2: return columns;\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tvoid set(int row, int column, double value) {\n\t\t-- row;\n\t\t-- column;\n\t\tvalues[row * columns + column] = value;\n\t}\n\t\n\tdouble get(int row, int column) const {\n\t\t-- row;\n\t\t-- column;\n\t\treturn values[row * columns + column];\n\t}\n\nprivate:\n\t\n\tvoid assign0(int rows, int columns) {\n\t\t(*this).rows = rows;\n\t\t(*this).columns = columns;\n\t\t(*this).values = new double[rows * columns];\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tset(i, j, 0.0);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid assign0(int rows, int columns, const double values[]) {\n\t\t(*this).rows = rows;\n\t\t(*this).columns = columns;\n\t\t(*this).values = new double[rows * columns];\n\t\tint count = 0;\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tset(i, j, values[count]);\n\t\t\t\t++ count;\n\t\t\t}\n\t\t}\n\t}\n\t\npublic:\n\t\n\tMatrix(int rows, int columns) {\n\t\tassign0(rows, columns);\n\t}\n\t\n\tMatrix(int rows, int columns, const double values[]) {\n\t\tassign0(rows, columns, values);\n\t}\n\t\n\tMatrix(const Matrix & matrix2) {\n\t\tassign0(matrix2.rows, matrix2.columns, matrix2.values);\n\t}\n\t\n\t~Matrix() {\n\t\tdelete [] values;\n\t}\n\t\n\tvoid print() const {\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tcout << \"    \" << get(i, j);\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\t\n\tMatrix & operator = (const Matrix & matrix2) {\n\t\tdelete [] values;\n\t\tassign0(matrix2.rows, matrix2.columns, matrix2.values);\n\t\treturn (*this);\n\t}\n\t\n\tMatrix getColumn(int column) const {\n\t\tMatrix columnMatrix(rows, 1);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tdouble value = get(i, column);\n\t\t\tcolumnMatrix.set(i, 1, value);\n\t\t}\n\t\treturn columnMatrix;\n\t}\n\n\tMatrix getRow(int row) const {\n\t\tMatrix rowMatrix(1, columns);\n\t\tfor (int i = 1; i <= columns; ++ i) {\n\t\t\tdouble value = get(row, i);\n\t\t\trowMatrix.set(1, i, value);\n\t\t}\n\t\treturn rowMatrix;\n\t}\n\t\n\tMatrix concatenateRows(const Matrix & matrix2) const {\n\t\tMatrix matrix(rows + matrix2.rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= matrix2.rows; ++ i) {\n\t\t\tfor (int j = 1; j <= matrix2.columns; ++ j) {\n\t\t\t\tdouble value = matrix2.get(i, j);\n\t\t\t\tmatrix.set(rows + i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix concatenateColumns(const Matrix & matrix2) const {\n\t\tMatrix matrix(rows, columns + matrix2.columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= matrix2.rows; ++ i) {\n\t\t\tfor (int j = 1; j <= matrix2.columns; ++ j) {\n\t\t\t\tdouble value = matrix2.get(i, j);\n\t\t\t\tmatrix.set(i, columns + j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix reshape(int rows, int columns) const {\n\t\tMatrix matrix(rows, columns);\n\t\tint count = 0;\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\t\tint row2 = 1 + count % (*this).rows;\n\t\t\t\tint column2 = 1 + count / (*this).rows;\n\t\t\t\t++ count;\n\t\t\t\tdouble value = get(row2, column2);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\t\n\tMatrix transpose() const {\n\t\tMatrix matrix(columns, rows);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(j, i, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator * (const Matrix & matrix2) const {\n\t\tMatrix matrix(rows, matrix2.columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= matrix2.columns; ++ j) {\n\t\t\t\tdouble sum = 0;\n\t\t\t\tfor (int k = 1; k <= columns; ++ k) {\n\t\t\t\t\tdouble value1  = get(i, k);\n\t\t\t\t\tdouble value2 = matrix2.get(k, j);\n\t\t\t\t\tsum += value1 * value2;\n\t\t\t\t}\n\t\t\t\tmatrix.set(i, j, sum);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\n\tMatrix operator * (double times) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value * times);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator + (const Matrix & matrix2) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value1 = get(i, j);\n\t\t\t\tdouble value2 = matrix2.get(i, j);\n\t\t\t\tmatrix.set(i, j, value1 + value2);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator + (double value2) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value + value2);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator - (const Matrix & matrix2) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value1 = get(i, j);\n\t\t\t\tdouble value2 = matrix2.get(i, j);\n\t\t\t\tmatrix.set(i, j, value1 - value2);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator - (double value2) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value - value2);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix max() const {\n\t\tif (rows == 1) {\n\t\t\treturn transpose().max();\n\t\t}\n\t\tMatrix matrix(1, columns);\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tdouble max = get(1, j);\n\t\t\tfor (int i = 2; i <= rows; ++ i) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tif (max < value) max = value;\n\t\t\t}\n\t\t\tmatrix.set(1, j, max);\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix min() const {\n\t\tif (rows == 1) {\n\t\t\treturn transpose().min();\n\t\t}\n\t\tMatrix matrix(1, columns);\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tdouble min = get(1, j);\n\t\t\tfor (int i = 2; i <= rows; ++ i) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tif (min > value) min = value;\n\t\t\t}\n\t\t\tmatrix.set(1, j, min);\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix sum() const {\n\t\tif (rows == 1) {\n\t\t\treturn transpose().sum();\n\t\t}\n\t\tMatrix matrix(1, columns);\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tdouble sum = 0;\n\t\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\t\tsum += get(i, j);\n\t\t\t}\n\t\t\tmatrix.set(1, j, sum);\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix pow(double exponent) {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tvalue = ::pow(value, exponent);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix exp() {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tvalue = ::exp(value);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix log() {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tvalue = ::log(value);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix abs() {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tvalue = std::abs(value);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\n\tdouble norm(int k) {\n\t\tif (rows == 1) {\n\t\t\treturn transpose().norm(k);\n\t\t}\n\t\treturn ::pow(abs().pow(k).sum().get(1, 1), (1.0 / k));\n\t}\n\n};",
            "from random import randint\nr = randint(3,9)\nc = randint(3,9)\nprint(r, c)\nfor i in range(r*c):\n\tprint(randint(1,99), end=' ')",
            1589508000,
            1590066000
        ],
        [
            "2.9 (C++)",
            "Design a class Matrix that has the following private member variables:\n<ol>\n<li>int rows</li>\n<li>int columns</li>\n<li>double * values</li>\n</ol>\nBesides, it has the following public object functions:\n<ol>\n<li>A constructor Matrix(int rows, int column, double values[]), which initializes all elements in the matrix to the given values. Note that the given values are in one-dimensional, you need to fill then into the two-dimensional matrix correctly.</li>\n<li>A copy constructor Matrix(const Matrix &amp; matrix2).</li>\n<li>A destructor.</li>\n<li>A print function which prints each row of elements in a single line, with each element preceded with 4 spaces.</li>\n<li>An operator Matrix Matrix::operator + (const Matrix &amp; matrix2) const.</li>\n<li>An operator Matrix Matrix::operator + (double value) const.</li>\n<li>An operator Matrix Matrix::operator - (const Matrix &amp; matrix2) const.</li>\n<li>An operator Matrix Matrix::operator - (double value) const.</li>\n</ol>\n\n<u>EXAMPLE INPUT</u>\n<pre>4 4\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16\n4 4\n16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1\n8</pre>\n\n<u>EXAMPLE OUTPUT</u>\n<pre>    1    2    3    4\n    5    6    7    8\n    9    10    11    12\n    13    14    15    16\n\n    16    15    14    13\n    12    11    10    9\n    8    7    6    5\n    4    3    2    1\n\n    17    17    17    17\n    17    17    17    17\n    17    17    17    17\n    17    17    17    17\n\n    -15    -13    -11    -9\n    -7    -5    -3    -1\n    1    3    5    7\n    9    11    13    15\n\n    9    10    11    12\n    13    14    15    16\n    17    18    19    20\n    21    22    23    24\n\n    -7    -6    -5    -4\n    -3    -2    -1    0\n    1    2    3    4\n    5    6    7    8</pre>",
            "#include \"source.cpp\"\n\nMatrix read() {\n\tint rows;\n\tint columns;\n\tdouble values[1000];\n\tcin >> rows >> columns;\n\tfor (int i = 0; i < rows * columns; ++ i) {\n\t\tcin >> values[i];\n\t}\n\tMatrix matrix(rows, columns, values);\n\treturn matrix;\n}\n\nint main() {\n\tMatrix matrix1 = read(); // calls copy constructor\n\tMatrix matrix2 = read();\n\t\n\tdouble value;\n\tcin >> value;\n\t\n\tmatrix1.print();\n\tcout << endl;\n\tmatrix2.print();\n\tcout << endl;\n\t\n\tMatrix matrix3 = matrix1 + matrix2;\n\tmatrix3.print();\n\tcout << endl;\n\t\n\tMatrix matrix4 = matrix1 - matrix2;\n\tmatrix4.print();\n\tcout << endl;\n\t\n\tMatrix matrix5 = matrix1 + value;\n\tmatrix5.print();\n\tcout << endl;\n\n\tMatrix matrix6 = matrix1 - value;\n\tmatrix6.print();\n\tcout << endl;\n}",
            "#include <iostream>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nclass Matrix\n{\n\t\nprivate:\n\t\n\tint rows;\n\tint columns;\n\tdouble * values;\n\t\npublic:\n\t\n\tint size(int dimension) const {\n\t\tswitch (dimension) {\n\t\t\tcase 1: return rows;\n\t\t\tcase 2: return columns;\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tvoid set(int row, int column, double value) {\n\t\t-- row;\n\t\t-- column;\n\t\tvalues[row * columns + column] = value;\n\t}\n\t\n\tdouble get(int row, int column) const {\n\t\t-- row;\n\t\t-- column;\n\t\treturn values[row * columns + column];\n\t}\n\nprivate:\n\t\n\tvoid assign0(int rows, int columns) {\n\t\t(*this).rows = rows;\n\t\t(*this).columns = columns;\n\t\t(*this).values = new double[rows * columns];\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tset(i, j, 0.0);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid assign0(int rows, int columns, const double values[]) {\n\t\t(*this).rows = rows;\n\t\t(*this).columns = columns;\n\t\t(*this).values = new double[rows * columns];\n\t\tint count = 0;\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tset(i, j, values[count]);\n\t\t\t\t++ count;\n\t\t\t}\n\t\t}\n\t}\n\t\npublic:\n\t\n\tMatrix(int rows, int columns) {\n\t\tassign0(rows, columns);\n\t}\n\t\n\tMatrix(int rows, int columns, const double values[]) {\n\t\tassign0(rows, columns, values);\n\t}\n\t\n\tMatrix(const Matrix & matrix2) {\n\t\tassign0(matrix2.rows, matrix2.columns, matrix2.values);\n\t}\n\t\n\t~Matrix() {\n\t\tdelete [] values;\n\t}\n\t\n\tvoid print() const {\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tcout << \"    \" << get(i, j);\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\t\n\tMatrix & operator = (const Matrix & matrix2) {\n\t\tdelete [] values;\n\t\tassign0(matrix2.rows, matrix2.columns, matrix2.values);\n\t\treturn (*this);\n\t}\n\t\n\tMatrix getColumn(int column) const {\n\t\tMatrix columnMatrix(rows, 1);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tdouble value = get(i, column);\n\t\t\tcolumnMatrix.set(i, 1, value);\n\t\t}\n\t\treturn columnMatrix;\n\t}\n\n\tMatrix getRow(int row) const {\n\t\tMatrix rowMatrix(1, columns);\n\t\tfor (int i = 1; i <= columns; ++ i) {\n\t\t\tdouble value = get(row, i);\n\t\t\trowMatrix.set(1, i, value);\n\t\t}\n\t\treturn rowMatrix;\n\t}\n\t\n\tMatrix concatenateRows(const Matrix & matrix2) const {\n\t\tMatrix matrix(rows + matrix2.rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= matrix2.rows; ++ i) {\n\t\t\tfor (int j = 1; j <= matrix2.columns; ++ j) {\n\t\t\t\tdouble value = matrix2.get(i, j);\n\t\t\t\tmatrix.set(rows + i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix concatenateColumns(const Matrix & matrix2) const {\n\t\tMatrix matrix(rows, columns + matrix2.columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= matrix2.rows; ++ i) {\n\t\t\tfor (int j = 1; j <= matrix2.columns; ++ j) {\n\t\t\t\tdouble value = matrix2.get(i, j);\n\t\t\t\tmatrix.set(i, columns + j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix reshape(int rows, int columns) const {\n\t\tMatrix matrix(rows, columns);\n\t\tint count = 0;\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\t\tint row2 = 1 + count % (*this).rows;\n\t\t\t\tint column2 = 1 + count / (*this).rows;\n\t\t\t\t++ count;\n\t\t\t\tdouble value = get(row2, column2);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\t\n\tMatrix transpose() const {\n\t\tMatrix matrix(columns, rows);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(j, i, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator * (const Matrix & matrix2) const {\n\t\tMatrix matrix(rows, matrix2.columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= matrix2.columns; ++ j) {\n\t\t\t\tdouble sum = 0;\n\t\t\t\tfor (int k = 1; k <= columns; ++ k) {\n\t\t\t\t\tdouble value1  = get(i, k);\n\t\t\t\t\tdouble value2 = matrix2.get(k, j);\n\t\t\t\t\tsum += value1 * value2;\n\t\t\t\t}\n\t\t\t\tmatrix.set(i, j, sum);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\n\tMatrix operator * (double times) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value * times);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator + (const Matrix & matrix2) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value1 = get(i, j);\n\t\t\t\tdouble value2 = matrix2.get(i, j);\n\t\t\t\tmatrix.set(i, j, value1 + value2);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator + (double value2) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value + value2);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator - (const Matrix & matrix2) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value1 = get(i, j);\n\t\t\t\tdouble value2 = matrix2.get(i, j);\n\t\t\t\tmatrix.set(i, j, value1 - value2);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator - (double value2) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value - value2);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix max() const {\n\t\tif (rows == 1) {\n\t\t\treturn transpose().max();\n\t\t}\n\t\tMatrix matrix(1, columns);\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tdouble max = get(1, j);\n\t\t\tfor (int i = 2; i <= rows; ++ i) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tif (max < value) max = value;\n\t\t\t}\n\t\t\tmatrix.set(1, j, max);\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix min() const {\n\t\tif (rows == 1) {\n\t\t\treturn transpose().min();\n\t\t}\n\t\tMatrix matrix(1, columns);\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tdouble min = get(1, j);\n\t\t\tfor (int i = 2; i <= rows; ++ i) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tif (min > value) min = value;\n\t\t\t}\n\t\t\tmatrix.set(1, j, min);\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix sum() const {\n\t\tif (rows == 1) {\n\t\t\treturn transpose().sum();\n\t\t}\n\t\tMatrix matrix(1, columns);\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tdouble sum = 0;\n\t\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\t\tsum += get(i, j);\n\t\t\t}\n\t\t\tmatrix.set(1, j, sum);\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix pow(double exponent) {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tvalue = ::pow(value, exponent);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix exp() {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tvalue = ::exp(value);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix log() {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tvalue = ::log(value);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix abs() {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tvalue = std::abs(value);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\n\tdouble norm(int k) {\n\t\tif (rows == 1) {\n\t\t\treturn transpose().norm(k);\n\t\t}\n\t\treturn ::pow(abs().pow(k).sum().get(1, 1), (1.0 / k));\n\t}\n\n};",
            "from random import randint\nr = randint(3,9)\nc = randint(3,9)\nprint(r, c)\nfor i in range(r*c):\n\tprint(randint(1,99), end=' ')\nprint()\nprint(r, c)\nfor i in range(r*c):\n\tprint(randint(1,99), end=' ')\nprint()\nprint(randint(1,999)/100)",
            1590026400,
            1590032400
        ],
        [
            "2.10 (C++)",
            "Design a class Matrix that has the following private member variables:\n<ol>\n<li>int rows</li>\n<li>int columns</li>\n<li>double * values</li>\n</ol>\nBesides, it has the following public object functions:\n<ol>\n<li>A constructor Matrix(int rows, int column, double values[]), which initializes all elements in the matrix to the given values. Note that the given values are in one-dimensional, you need to fill then into the two-dimensional matrix correctly.</li>\n<li>A copy constructor Matrix(const Matrix &amp; matrix2).</li>\n<li>A destructor.</li>\n<li>A print function which prints each row of elements in a single line, with each element preceded with 4 spaces.</li>\n<li>An operator Matrix Matrix::operator * (const Matrix &amp; matrix2) const.</li>\n<li>An operator Matrix Matrix::operator * (double value) const.</li>\n</ol>\n\n<u>EXAMPLE INPUT</u>\n<pre>4 5\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20\n5 4\n20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1\n8</pre>\n\n<u>EXAMPLE OUTPUT</u>\n<pre>    1    2    3    4    5\n    6    7    8    9    10\n    11    12    13    14    15\n    16    17    18    19    20\n\n    20    19    18    17\n    16    15    14    13\n    12    11    10    9\n    8    7    6    5\n    4    3    2    1\n\n    140    125    110    95\n    440    400    360    320\n    740    675    610    545\n    1040    950    860    770\n\n    8    16    24    32    40\n    48    56    64    72    80\n    88    96    104    112    120\n    128    136    144    152    160</pre>",
            "#include \"source.cpp\"\n\nMatrix read() {\n\tint rows;\n\tint columns;\n\tdouble values[1000];\n\tcin >> rows >> columns;\n\tfor (int i = 0; i < rows * columns; ++ i) {\n\t\tcin >> values[i];\n\t}\n\tMatrix matrix(rows, columns, values);\n\treturn matrix;\n}\n\nint main() {\n\tMatrix matrix1 = read(); // calls copy constructor\n\tMatrix matrix2 = read();\n\t\n\tdouble value;\n\tcin >> value;\n\t\n\tmatrix1.print();\n\tcout << endl;\n\tmatrix2.print();\n\tcout << endl;\n\t\n\tMatrix matrix3 = matrix1 * matrix2;\n\tmatrix3.print();\n\tcout << endl;\n\t\n\tMatrix matrix4 = matrix1 * value;\n\tmatrix4.print();\n\tcout << endl;\n}",
            "#include <iostream>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nclass Matrix\n{\n\t\nprivate:\n\t\n\tint rows;\n\tint columns;\n\tdouble * values;\n\t\npublic:\n\t\n\tint size(int dimension) const {\n\t\tswitch (dimension) {\n\t\t\tcase 1: return rows;\n\t\t\tcase 2: return columns;\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tvoid set(int row, int column, double value) {\n\t\t-- row;\n\t\t-- column;\n\t\tvalues[row * columns + column] = value;\n\t}\n\t\n\tdouble get(int row, int column) const {\n\t\t-- row;\n\t\t-- column;\n\t\treturn values[row * columns + column];\n\t}\n\nprivate:\n\t\n\tvoid assign0(int rows, int columns) {\n\t\t(*this).rows = rows;\n\t\t(*this).columns = columns;\n\t\t(*this).values = new double[rows * columns];\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tset(i, j, 0.0);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid assign0(int rows, int columns, const double values[]) {\n\t\t(*this).rows = rows;\n\t\t(*this).columns = columns;\n\t\t(*this).values = new double[rows * columns];\n\t\tint count = 0;\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tset(i, j, values[count]);\n\t\t\t\t++ count;\n\t\t\t}\n\t\t}\n\t}\n\t\npublic:\n\t\n\tMatrix(int rows, int columns) {\n\t\tassign0(rows, columns);\n\t}\n\t\n\tMatrix(int rows, int columns, const double values[]) {\n\t\tassign0(rows, columns, values);\n\t}\n\t\n\tMatrix(const Matrix & matrix2) {\n\t\tassign0(matrix2.rows, matrix2.columns, matrix2.values);\n\t}\n\t\n\t~Matrix() {\n\t\tdelete [] values;\n\t}\n\t\n\tvoid print() const {\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tcout << \"    \" << get(i, j);\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\t\n\tMatrix & operator = (const Matrix & matrix2) {\n\t\tdelete [] values;\n\t\tassign0(matrix2.rows, matrix2.columns, matrix2.values);\n\t\treturn (*this);\n\t}\n\t\n\tMatrix getColumn(int column) const {\n\t\tMatrix columnMatrix(rows, 1);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tdouble value = get(i, column);\n\t\t\tcolumnMatrix.set(i, 1, value);\n\t\t}\n\t\treturn columnMatrix;\n\t}\n\n\tMatrix getRow(int row) const {\n\t\tMatrix rowMatrix(1, columns);\n\t\tfor (int i = 1; i <= columns; ++ i) {\n\t\t\tdouble value = get(row, i);\n\t\t\trowMatrix.set(1, i, value);\n\t\t}\n\t\treturn rowMatrix;\n\t}\n\t\n\tMatrix concatenateRows(const Matrix & matrix2) const {\n\t\tMatrix matrix(rows + matrix2.rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= matrix2.rows; ++ i) {\n\t\t\tfor (int j = 1; j <= matrix2.columns; ++ j) {\n\t\t\t\tdouble value = matrix2.get(i, j);\n\t\t\t\tmatrix.set(rows + i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix concatenateColumns(const Matrix & matrix2) const {\n\t\tMatrix matrix(rows, columns + matrix2.columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= matrix2.rows; ++ i) {\n\t\t\tfor (int j = 1; j <= matrix2.columns; ++ j) {\n\t\t\t\tdouble value = matrix2.get(i, j);\n\t\t\t\tmatrix.set(i, columns + j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix reshape(int rows, int columns) const {\n\t\tMatrix matrix(rows, columns);\n\t\tint count = 0;\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\t\tint row2 = 1 + count % (*this).rows;\n\t\t\t\tint column2 = 1 + count / (*this).rows;\n\t\t\t\t++ count;\n\t\t\t\tdouble value = get(row2, column2);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\t\n\tMatrix transpose() const {\n\t\tMatrix matrix(columns, rows);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(j, i, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator * (const Matrix & matrix2) const {\n\t\tMatrix matrix(rows, matrix2.columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= matrix2.columns; ++ j) {\n\t\t\t\tdouble sum = 0;\n\t\t\t\tfor (int k = 1; k <= columns; ++ k) {\n\t\t\t\t\tdouble value1  = get(i, k);\n\t\t\t\t\tdouble value2 = matrix2.get(k, j);\n\t\t\t\t\tsum += value1 * value2;\n\t\t\t\t}\n\t\t\t\tmatrix.set(i, j, sum);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\n\tMatrix operator * (double times) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value * times);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator + (const Matrix & matrix2) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value1 = get(i, j);\n\t\t\t\tdouble value2 = matrix2.get(i, j);\n\t\t\t\tmatrix.set(i, j, value1 + value2);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator + (double value2) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value + value2);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator - (const Matrix & matrix2) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value1 = get(i, j);\n\t\t\t\tdouble value2 = matrix2.get(i, j);\n\t\t\t\tmatrix.set(i, j, value1 - value2);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator - (double value2) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value - value2);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix max() const {\n\t\tif (rows == 1) {\n\t\t\treturn transpose().max();\n\t\t}\n\t\tMatrix matrix(1, columns);\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tdouble max = get(1, j);\n\t\t\tfor (int i = 2; i <= rows; ++ i) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tif (max < value) max = value;\n\t\t\t}\n\t\t\tmatrix.set(1, j, max);\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix min() const {\n\t\tif (rows == 1) {\n\t\t\treturn transpose().min();\n\t\t}\n\t\tMatrix matrix(1, columns);\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tdouble min = get(1, j);\n\t\t\tfor (int i = 2; i <= rows; ++ i) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tif (min > value) min = value;\n\t\t\t}\n\t\t\tmatrix.set(1, j, min);\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix sum() const {\n\t\tif (rows == 1) {\n\t\t\treturn transpose().sum();\n\t\t}\n\t\tMatrix matrix(1, columns);\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tdouble sum = 0;\n\t\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\t\tsum += get(i, j);\n\t\t\t}\n\t\t\tmatrix.set(1, j, sum);\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix pow(double exponent) {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tvalue = ::pow(value, exponent);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix exp() {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tvalue = ::exp(value);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix log() {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tvalue = ::log(value);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix abs() {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tvalue = std::abs(value);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\n\tdouble norm(int k) {\n\t\tif (rows == 1) {\n\t\t\treturn transpose().norm(k);\n\t\t}\n\t\treturn ::pow(abs().pow(k).sum().get(1, 1), (1.0 / k));\n\t}\n\n};",
            "from random import randint\nr = randint(3,9)\nc = randint(3,9)\nprint(r, c)\nfor i in range(r*c):\n\tprint(randint(1,9), end=' ')\nprint()\nprint(c, r)\nfor i in range(r*c):\n\tprint(randint(1,9), end=' ')\nprint()\nprint(randint(1,999)/100)",
            1589508000,
            1590066000
        ],
        [
            "2.11 (C++)",
            "<p>Design a class Matrix that has the following private member variables:\n<ol>\n<li>int rows</li>\n<li>int columns</li>\n<li>double * values</li>\n</ol>\nBesides, it has the following public object functions:\n<ol>\n<li>A constructor Matrix(int rows, int column, double values[]), which initializes all elements in the matrix to the given values. Note that the given values are in a one-dimensional array, you need to fill them into the two-dimensional matrix correctly.</li>\n<li>A copy constructor Matrix(const Matrix &amp; matrix2).</li>\n<li>A destructor.</li>\n<li>A print function which prints each row of elements in a single line, with each element preceded with 4 spaces.</li>\n<li>A function Matrix Matrix::max() const.</li>\n<li>A function Matrix Matrix::min() const.</li>\n<li>A function Matrix Matrix::sum() const.</li>\n</ol>\nThe last three functions return a row matrix if the 'this' matrix contains multiple rows. For the max function, the returned row matrix consists of the largest values in each columns of the 'this'&nbsp;<span style=\"font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, &quot;Noto Sans&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 1rem;\">matrix.</span></p><p>They return a 1-by-1 matrix otherwise.<br>\n<br>\n\n<u>EXAMPLE INPUT</u>\n<pre>4 5\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20</pre>\n\n<u>EXAMPLE OUTPUT</u>\n<pre>    1    2    3    4    5\n    6    7    8    9    10\n    11    12    13    14    15\n    16    17    18    19    20\n\n    16    17    18    19    20\n\n    20\n\n    1    2    3    4    5\n\n    1\n\n    34    38    42    46    50\n\n    210</pre></p>",
            "#include \"source.cpp\"\n\nMatrix read() {\n\tint rows;\n\tint columns;\n\tdouble values[1000];\n\tcin >> rows >> columns;\n\tfor (int i = 0; i < rows * columns; ++ i) {\n\t\tcin >> values[i];\n\t}\n\tMatrix matrix(rows, columns, values);\n\treturn matrix;\n}\n\nint main() {\n\tMatrix matrix1 = read(); // calls copy constructor\n\tmatrix1.print();\n\tcout << endl;\n\t\n\tmatrix1.max().print();\n\tcout << endl;\n\tmatrix1.max().max().print();\n\tcout << endl;\n\n\tmatrix1.min().print();\n\tcout << endl;\n\tmatrix1.min().min().print();\n\tcout << endl;\n\n\tmatrix1.sum().print();\n\tcout << endl;\n\tmatrix1.sum().sum().print();\n\tcout << endl;\n}",
            "#include <iostream>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nclass Matrix\n{\n\t\nprivate:\n\t\n\tint rows;\n\tint columns;\n\tdouble * values;\n\t\npublic:\n\t\n\tint size(int dimension) const {\n\t\tswitch (dimension) {\n\t\t\tcase 1: return rows;\n\t\t\tcase 2: return columns;\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tvoid set(int row, int column, double value) {\n\t\t-- row;\n\t\t-- column;\n\t\tvalues[row * columns + column] = value;\n\t}\n\t\n\tdouble get(int row, int column) const {\n\t\t-- row;\n\t\t-- column;\n\t\treturn values[row * columns + column];\n\t}\n\nprivate:\n\t\n\tvoid assign0(int rows, int columns) {\n\t\t(*this).rows = rows;\n\t\t(*this).columns = columns;\n\t\t(*this).values = new double[rows * columns];\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tset(i, j, 0.0);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid assign0(int rows, int columns, const double values[]) {\n\t\t(*this).rows = rows;\n\t\t(*this).columns = columns;\n\t\t(*this).values = new double[rows * columns];\n\t\tint count = 0;\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tset(i, j, values[count]);\n\t\t\t\t++ count;\n\t\t\t}\n\t\t}\n\t}\n\t\npublic:\n\t\n\tMatrix(int rows, int columns) {\n\t\tassign0(rows, columns);\n\t}\n\t\n\tMatrix(int rows, int columns, const double values[]) {\n\t\tassign0(rows, columns, values);\n\t}\n\t\n\tMatrix(const Matrix & matrix2) {\n\t\tassign0(matrix2.rows, matrix2.columns, matrix2.values);\n\t}\n\t\n\t~Matrix() {\n\t\tdelete [] values;\n\t}\n\t\n\tvoid print() const {\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tcout << \"    \" << get(i, j);\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\t\n\tMatrix & operator = (const Matrix & matrix2) {\n\t\tdelete [] values;\n\t\tassign0(matrix2.rows, matrix2.columns, matrix2.values);\n\t\treturn (*this);\n\t}\n\t\n\tMatrix getColumn(int column) const {\n\t\tMatrix columnMatrix(rows, 1);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tdouble value = get(i, column);\n\t\t\tcolumnMatrix.set(i, 1, value);\n\t\t}\n\t\treturn columnMatrix;\n\t}\n\n\tMatrix getRow(int row) const {\n\t\tMatrix rowMatrix(1, columns);\n\t\tfor (int i = 1; i <= columns; ++ i) {\n\t\t\tdouble value = get(row, i);\n\t\t\trowMatrix.set(1, i, value);\n\t\t}\n\t\treturn rowMatrix;\n\t}\n\t\n\tMatrix concatenateRows(const Matrix & matrix2) const {\n\t\tMatrix matrix(rows + matrix2.rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= matrix2.rows; ++ i) {\n\t\t\tfor (int j = 1; j <= matrix2.columns; ++ j) {\n\t\t\t\tdouble value = matrix2.get(i, j);\n\t\t\t\tmatrix.set(rows + i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix concatenateColumns(const Matrix & matrix2) const {\n\t\tMatrix matrix(rows, columns + matrix2.columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= matrix2.rows; ++ i) {\n\t\t\tfor (int j = 1; j <= matrix2.columns; ++ j) {\n\t\t\t\tdouble value = matrix2.get(i, j);\n\t\t\t\tmatrix.set(i, columns + j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix reshape(int rows, int columns) const {\n\t\tMatrix matrix(rows, columns);\n\t\tint count = 0;\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\t\tint row2 = 1 + count % (*this).rows;\n\t\t\t\tint column2 = 1 + count / (*this).rows;\n\t\t\t\t++ count;\n\t\t\t\tdouble value = get(row2, column2);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\t\n\tMatrix transpose() const {\n\t\tMatrix matrix(columns, rows);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(j, i, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator * (const Matrix & matrix2) const {\n\t\tMatrix matrix(rows, matrix2.columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= matrix2.columns; ++ j) {\n\t\t\t\tdouble sum = 0;\n\t\t\t\tfor (int k = 1; k <= columns; ++ k) {\n\t\t\t\t\tdouble value1  = get(i, k);\n\t\t\t\t\tdouble value2 = matrix2.get(k, j);\n\t\t\t\t\tsum += value1 * value2;\n\t\t\t\t}\n\t\t\t\tmatrix.set(i, j, sum);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\n\tMatrix operator * (double times) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value * times);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator + (const Matrix & matrix2) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value1 = get(i, j);\n\t\t\t\tdouble value2 = matrix2.get(i, j);\n\t\t\t\tmatrix.set(i, j, value1 + value2);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator + (double value2) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value + value2);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator - (const Matrix & matrix2) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value1 = get(i, j);\n\t\t\t\tdouble value2 = matrix2.get(i, j);\n\t\t\t\tmatrix.set(i, j, value1 - value2);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator - (double value2) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value - value2);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix max() const {\n\t\tif (rows == 1) {\n\t\t\treturn transpose().max();\n\t\t}\n\t\tMatrix matrix(1, columns);\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tdouble max = get(1, j);\n\t\t\tfor (int i = 2; i <= rows; ++ i) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tif (max < value) max = value;\n\t\t\t}\n\t\t\tmatrix.set(1, j, max);\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix min() const {\n\t\tif (rows == 1) {\n\t\t\treturn transpose().min();\n\t\t}\n\t\tMatrix matrix(1, columns);\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tdouble min = get(1, j);\n\t\t\tfor (int i = 2; i <= rows; ++ i) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tif (min > value) min = value;\n\t\t\t}\n\t\t\tmatrix.set(1, j, min);\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix sum() const {\n\t\tif (rows == 1) {\n\t\t\treturn transpose().sum();\n\t\t}\n\t\tMatrix matrix(1, columns);\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tdouble sum = 0;\n\t\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\t\tsum += get(i, j);\n\t\t\t}\n\t\t\tmatrix.set(1, j, sum);\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix pow(double exponent) {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tvalue = ::pow(value, exponent);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix exp() {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tvalue = ::exp(value);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix log() {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tvalue = ::log(value);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix abs() {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tvalue = std::abs(value);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\n\tdouble norm(int k) {\n\t\tif (rows == 1) {\n\t\t\treturn transpose().norm(k);\n\t\t}\n\t\treturn ::pow(abs().pow(k).sum().get(1, 1), (1.0 / k));\n\t}\n\n};",
            "from random import randint\nr = randint(3,9)\nc = randint(3,9)\nprint(r, c)\nfor i in range(r*c):\n\tprint(randint(1,99), end=' ')",
            1589508000,
            1590066000
        ],
        [
            "2.12 (C++)",
            "Design a class Matrix that has the following private member variables:\n<ol>\n<li>int rows</li>\n<li>int columns</li>\n<li>double * values</li>\n</ol>\nBesides, it has the following public object functions:\n<ol>\n<li>A constructor Matrix(int rows, int column, double values[]), which initializes all elements in the matrix to the given values. Note that the given values are in one-dimensional, you need to fill then into the two-dimensional matrix correctly.</li>\n<li>A copy constructor Matrix(const Matrix & matrix2).</li>\n<li>A destructor.</li>\n<li>A print function which prints each row of elements in a single line, with each element preceded with 4 spaces.</li>\n<li>A element-wise function Matrix Matrix::pow(double exponent).</li>\n<li>A element-wise function Matrix Matrix::exp().</li>\n<li>A element-wise function Matrix Matrix::log().</li>\n<li>A element-wise function Matrix Matrix::abs().</li>\n</ol>\n\n<u>EXAMPLE INPUT</u>\n<pre>4 4\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16\n2</pre>\n\n<u>EXAMPLE OUTPUT</u>\n<pre>    1    2    3    4\n    5    6    7    8\n    9    10    11    12\n    13    14    15    16\n\n    1    4    9    16\n    25    36    49    64\n    81    100    121    144\n    169    196    225    256\n\n    2.71828    7.38906    20.0855    54.5982\n    148.413    403.429    1096.63    2980.96\n    8103.08    22026.5    59874.1    162755\n    442413    1.2026e+06    3.26902e+06    8.88611e+06\n\n    0    0.693147    1.09861    1.38629\n    1.60944    1.79176    1.94591    2.07944\n    2.19722    2.30259    2.3979    2.48491\n    2.56495    2.63906    2.70805    2.77259\n\n    1    2    3    4\n    5    6    7    8\n    9    10    11    12\n    13    14    15    16</pre>",
            "#include \"source.cpp\"\n\nMatrix read() {\n\tint rows;\n\tint columns;\n\tdouble values[1000];\n\tcin >> rows >> columns;\n\tfor (int i = 0; i < rows * columns; ++ i) {\n\t\tcin >> values[i];\n\t}\n\tMatrix matrix(rows, columns, values);\n\treturn matrix;\n}\n\nint main() {\n\tMatrix matrix = read(); // calls copy constructor\n\t\n\tdouble exponent;\n\tcin >> exponent;\n\t\n\tmatrix.print();\n\tcout << endl;\n\tmatrix.pow(exponent).print();\n\tcout << endl;\n\tmatrix.exp().print();\n\tcout << endl;\n\tmatrix.log().print();\n\tcout << endl;\n\tmatrix.abs().print();\n\tcout << endl;\n}",
            "#include <iostream>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nclass Matrix\n{\n\t\nprivate:\n\t\n\tint rows;\n\tint columns;\n\tdouble * values;\n\t\npublic:\n\t\n\tint size(int dimension) const {\n\t\tswitch (dimension) {\n\t\t\tcase 1: return rows;\n\t\t\tcase 2: return columns;\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tvoid set(int row, int column, double value) {\n\t\t-- row;\n\t\t-- column;\n\t\tvalues[row * columns + column] = value;\n\t}\n\t\n\tdouble get(int row, int column) const {\n\t\t-- row;\n\t\t-- column;\n\t\treturn values[row * columns + column];\n\t}\n\nprivate:\n\t\n\tvoid assign0(int rows, int columns) {\n\t\t(*this).rows = rows;\n\t\t(*this).columns = columns;\n\t\t(*this).values = new double[rows * columns];\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tset(i, j, 0.0);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid assign0(int rows, int columns, const double values[]) {\n\t\t(*this).rows = rows;\n\t\t(*this).columns = columns;\n\t\t(*this).values = new double[rows * columns];\n\t\tint count = 0;\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tset(i, j, values[count]);\n\t\t\t\t++ count;\n\t\t\t}\n\t\t}\n\t}\n\t\npublic:\n\t\n\tMatrix(int rows, int columns) {\n\t\tassign0(rows, columns);\n\t}\n\t\n\tMatrix(int rows, int columns, const double values[]) {\n\t\tassign0(rows, columns, values);\n\t}\n\t\n\tMatrix(const Matrix & matrix2) {\n\t\tassign0(matrix2.rows, matrix2.columns, matrix2.values);\n\t}\n\t\n\t~Matrix() {\n\t\tdelete [] values;\n\t}\n\t\n\tvoid print() const {\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tcout << \"    \" << get(i, j);\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\t\n\tMatrix & operator = (const Matrix & matrix2) {\n\t\tdelete [] values;\n\t\tassign0(matrix2.rows, matrix2.columns, matrix2.values);\n\t\treturn (*this);\n\t}\n\t\n\tMatrix getColumn(int column) const {\n\t\tMatrix columnMatrix(rows, 1);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tdouble value = get(i, column);\n\t\t\tcolumnMatrix.set(i, 1, value);\n\t\t}\n\t\treturn columnMatrix;\n\t}\n\n\tMatrix getRow(int row) const {\n\t\tMatrix rowMatrix(1, columns);\n\t\tfor (int i = 1; i <= columns; ++ i) {\n\t\t\tdouble value = get(row, i);\n\t\t\trowMatrix.set(1, i, value);\n\t\t}\n\t\treturn rowMatrix;\n\t}\n\t\n\tMatrix concatenateRows(const Matrix & matrix2) const {\n\t\tMatrix matrix(rows + matrix2.rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= matrix2.rows; ++ i) {\n\t\t\tfor (int j = 1; j <= matrix2.columns; ++ j) {\n\t\t\t\tdouble value = matrix2.get(i, j);\n\t\t\t\tmatrix.set(rows + i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix concatenateColumns(const Matrix & matrix2) const {\n\t\tMatrix matrix(rows, columns + matrix2.columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= matrix2.rows; ++ i) {\n\t\t\tfor (int j = 1; j <= matrix2.columns; ++ j) {\n\t\t\t\tdouble value = matrix2.get(i, j);\n\t\t\t\tmatrix.set(i, columns + j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix reshape(int rows, int columns) const {\n\t\tMatrix matrix(rows, columns);\n\t\tint count = 0;\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\t\tint row2 = 1 + count % (*this).rows;\n\t\t\t\tint column2 = 1 + count / (*this).rows;\n\t\t\t\t++ count;\n\t\t\t\tdouble value = get(row2, column2);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\t\n\tMatrix transpose() const {\n\t\tMatrix matrix(columns, rows);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(j, i, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator * (const Matrix & matrix2) const {\n\t\tMatrix matrix(rows, matrix2.columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= matrix2.columns; ++ j) {\n\t\t\t\tdouble sum = 0;\n\t\t\t\tfor (int k = 1; k <= columns; ++ k) {\n\t\t\t\t\tdouble value1  = get(i, k);\n\t\t\t\t\tdouble value2 = matrix2.get(k, j);\n\t\t\t\t\tsum += value1 * value2;\n\t\t\t\t}\n\t\t\t\tmatrix.set(i, j, sum);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\n\tMatrix operator * (double times) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value * times);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator + (const Matrix & matrix2) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value1 = get(i, j);\n\t\t\t\tdouble value2 = matrix2.get(i, j);\n\t\t\t\tmatrix.set(i, j, value1 + value2);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator + (double value2) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value + value2);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator - (const Matrix & matrix2) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value1 = get(i, j);\n\t\t\t\tdouble value2 = matrix2.get(i, j);\n\t\t\t\tmatrix.set(i, j, value1 - value2);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator - (double value2) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value - value2);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix max() const {\n\t\tif (rows == 1) {\n\t\t\treturn transpose().max();\n\t\t}\n\t\tMatrix matrix(1, columns);\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tdouble max = get(1, j);\n\t\t\tfor (int i = 2; i <= rows; ++ i) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tif (max < value) max = value;\n\t\t\t}\n\t\t\tmatrix.set(1, j, max);\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix min() const {\n\t\tif (rows == 1) {\n\t\t\treturn transpose().min();\n\t\t}\n\t\tMatrix matrix(1, columns);\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tdouble min = get(1, j);\n\t\t\tfor (int i = 2; i <= rows; ++ i) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tif (min > value) min = value;\n\t\t\t}\n\t\t\tmatrix.set(1, j, min);\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix sum() const {\n\t\tif (rows == 1) {\n\t\t\treturn transpose().sum();\n\t\t}\n\t\tMatrix matrix(1, columns);\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tdouble sum = 0;\n\t\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\t\tsum += get(i, j);\n\t\t\t}\n\t\t\tmatrix.set(1, j, sum);\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix pow(double exponent) {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tvalue = ::pow(value, exponent);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix exp() {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tvalue = ::exp(value);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix log() {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tvalue = ::log(value);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix abs() {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tvalue = std::abs(value);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\n\tdouble norm(int k) {\n\t\tif (rows == 1) {\n\t\t\treturn transpose().norm(k);\n\t\t}\n\t\treturn ::pow(abs().pow(k).sum().get(1, 1), (1.0 / k));\n\t}\n\n};",
            "from random import randint\nr = randint(3,6)\nc = randint(3,6)\nprint(r, c)\nfor i in range(r*c):\n\tprint(randint(1,9), end=' ')\nprint()\nprint(randint(2,4))",
            1589508000,
            1590066000
        ],
        [
            "2.13 (C++)",
            "Design a class Full that implements interface Matrix:\nFull should has the following public object functions in addition:\n<ol>\n<li>A constructor Full(int rows, int column), which initializes all elements in the matrix to 0's.</li>\n<li>A constructor Full(int rows, int column, double values[]), which initializes all elements in the matrix to the given values. Note that the given values are in one-dimensional, you need to fill then into the two-dimensional matrix correctly.</li>\n<li>A constructor Full(const Matrix &amp; matrix2).</li>\n<li>A destructor.</li>\n<li>A print function which prints each row of elements in a single line, with each element preceded with 4 spaces.</li>\n</ol>\n\n<b><u>HINT</u></b><br>\n本题涉及 pure virtual function, abstract class 和 interface 的内容。<br>\n<ol>\n<li>The function <u>int size(int)</u> function return the 2-dimensional size of the matrix: it returns the size in the first dimension (the number of rows) if the argument is 1, and returns size in the second dimension (the number of column) if the argument is 2.</li>\n<li>The class <u>Full</u> that you will define must <i>implement</i> the interface class <i>Matrix</i>, which means that it need to <i>override</i> the <u>operator =</u> as it is in <i>Matrix</i>, along with all other pure virtual object functions in <i>Matrix</i>.</li>\n<li>Don't forget to provide the constructor <i>Full(const Matrix &amp; matrix2)</i> in our class.</li>\n</ol>\n\n<u>EXAMPLE INPUT</u>\n<pre>4 4\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16</pre>\n\n<u>EXAMPLE OUTPUT</u>\n<pre>constructor 1\n    0    0    0\n    0    0    0\n    0    0    0\nconstructor 2\n    1    2    3    4\n    5    6    7    8\n    9    10    11    12\n    13    14    15    16\nconstructor 3\n    1    2    3    4\n    5    6    7    8\n    9    10    11    12\n    13    14    15    16\noperator =\n    1    2    3    4\n    5    6    7    8\n    9    10    11    12\n    13    14    15    16\n</pre>",
            "#include <iostream>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nclass Matrix\n{\t\npublic:\n\t\n\tvirtual int size(int dimension) const = 0;\n\t\n\tvirtual void set(int row, int column, double value) = 0;\n\t\n\tvirtual double get(int row, int column) const = 0;\n\t\n\tvirtual void print() const = 0;\n\t\n\tvirtual Matrix & operator = (const Matrix & matrix2) = 0;\n};\n\n#include \"source.cpp\"\n\nFull readMatrix() {\n\tint rows;\n\tint columns;\n\tdouble values[1000];\n\tcin >> rows >> columns;\n\tfor (int i = 0; i < rows * columns; ++ i) {\n\t\tcin >> values[i];\n\t}\n\tFull matrix(rows, columns, values);\n\treturn matrix;\n}\n\nvoid printMatrix(const Matrix & matrix) {\n\tmatrix.print();\n}\n\nint main() {\n\tcout << \"constructor 1\" << endl;\n\tFull full1(3, 3);\n\tMatrix & matrix1 = full1; // down-casting\n\tmatrix1.print();\n\t\n\tcout << \"constructor 2\" << endl;\n\tconst Matrix & matrix2 = readMatrix();\n\tmatrix2.print();\n\t\n\tcout << \"constructor 3\" << endl;\n\tFull full3 = matrix2;\n\tMatrix & matrix3 = full3;\n\tprintMatrix(matrix3);\n\t\n\tcout << \"operator =\" << endl;\n\tmatrix3.set(1, 1, 10.0);\n\tmatrix3 = matrix2;\n\tmatrix3.print();\n}",
            "#include <iostream>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nclass Full : public Matrix\n{\n\t\nprivate:\n\t\n\tint rows;\n\tint columns;\n\tdouble * values;\n\t\npublic:\n\t\n\tint size(int dimension) const {\n\t\tswitch (dimension) {\n\t\t\tcase 1: return rows;\n\t\t\tcase 2: return columns;\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tvoid set(int row, int column, double value) {\n\t\t-- row;\n\t\t-- column;\n\t\tvalues[row * columns + column] = value;\n\t}\n\t\n\tdouble get(int row, int column) const {\n\t\t-- row;\n\t\t-- column;\n\t\treturn values[row * columns + column];\n\t}\n\nprivate:\n\t\n\tvoid assign0(int rows, int columns) {\n\t\t(*this).rows = rows;\n\t\t(*this).columns = columns;\n\t\t(*this).values = new double[rows * columns];\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tset(i, j, 0.0);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid assign0(int rows, int columns, const double values[]) {\n\t\t(*this).rows = rows;\n\t\t(*this).columns = columns;\n\t\t(*this).values = new double[rows * columns];\n\t\tint count = 0;\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tset(i, j, values[count]);\n\t\t\t\t++ count;\n\t\t\t}\n\t\t}\n\t}\n\t\npublic:\n\t\n\tFull(int rows, int columns) {\n\t\tassign0(rows, columns);\n\t}\n\t\n\tFull(int rows, int columns, const double values[]) {\n\t\tassign0(rows, columns, values);\n\t}\n\t\n\tFull(const Matrix & matrix2) {\n\t\tdouble * values2 = new double[matrix2.size(1) * matrix2.size(2)];\n\t\tint count = 0;\n\t\tfor (int i = 0; i < matrix2.size(1); ++ i) {\n\t\t\tfor (int j = 0; j < matrix2.size(2); ++ j) {\n\t\t\t\tvalues2[count] = matrix2.get(i+1, j+1);\n\t\t\t\t++ count;\n\t\t\t}\n\t\t}\n\t\tassign0(matrix2.size(1), matrix2.size(2), values2);\n\t\tdelete [] values2;\n\t}\n\t\n\t~Full() {\n\t\tdelete [] values;\n\t}\n\t\n\tvoid print() const {\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tcout << \"    \" << get(i, j);\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\t\n\tMatrix & operator = (const Matrix & matrix2) {\n\t\tdelete [] values;\n\t\tdouble * values2 = new double[matrix2.size(1) * matrix2.size(2)];\n\t\tint count = 0;\n\t\tfor (int i = 0; i < matrix2.size(1); ++ i) {\n\t\t\tfor (int j = 0; j < matrix2.size(2); ++ j) {\n\t\t\t\tvalues2[count] = matrix2.get(i+1, j+1);\n\t\t\t\t++ count;\n\t\t\t}\n\t\t}\n\t\tassign0(matrix2.size(1), matrix2.size(2), values2);\n\t\tdelete [] values2;\n\t\treturn (*this);\n\t}\n\t\n\tFull getColumn(int column) const {\n\t\tFull columnMatrix(rows, 1);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tdouble value = get(i, column);\n\t\t\tcolumnMatrix.set(i, 1, value);\n\t\t}\n\t\treturn columnMatrix;\n\t}\n\n\tFull getRow(int row) const {\n\t\tFull rowMatrix(1, columns);\n\t\tfor (int i = 1; i <= columns; ++ i) {\n\t\t\tdouble value = get(row, i);\n\t\t\trowMatrix.set(1, i, value);\n\t\t}\n\t\treturn rowMatrix;\n\t}\n\t\n\tFull concatenateRows(const Matrix & matrix2) const {\n\t\tFull matrix(rows + matrix2.size(1), columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= matrix2.size(1); ++ i) {\n\t\t\tfor (int j = 1; j <= matrix2.size(2); ++ j) {\n\t\t\t\tdouble value = matrix2.get(i, j);\n\t\t\t\tmatrix.set(rows + i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tFull concatenateColumns(const Matrix & matrix2) const {\n\t\tFull matrix(rows, columns + matrix2.size(2));\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= matrix2.size(1); ++ i) {\n\t\t\tfor (int j = 1; j <= matrix2.size(2); ++ j) {\n\t\t\t\tdouble value = matrix2.get(i, j);\n\t\t\t\tmatrix.set(i, columns + j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tFull reshape(int rows, int columns) const {\n\t\tFull matrix(rows, columns);\n\t\tint count = 0;\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\t\tint row2 = 1 + count % (*this).rows;\n\t\t\t\tint column2 = 1 + count / (*this).rows;\n\t\t\t\t++ count;\n\t\t\t\tdouble value = get(row2, column2);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\t\n\tFull transpose() const {\n\t\tFull matrix(columns, rows);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(j, i, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tFull operator * (const Matrix & matrix2) const {\n\t\tFull matrix(rows, matrix2.size(2));\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= matrix2.size(2); ++ j) {\n\t\t\t\tdouble sum = 0;\n\t\t\t\tfor (int k = 1; k <= columns; ++ k) {\n\t\t\t\t\tdouble value1  = get(i, k);\n\t\t\t\t\tdouble value2 = matrix2.get(k, j);\n\t\t\t\t\tsum += value1 * value2;\n\t\t\t\t}\n\t\t\t\tmatrix.set(i, j, sum);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\n\tFull operator * (double times) const {\n\t\tFull matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value * times);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tFull operator + (const Matrix & matrix2) const {\n\t\tFull matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value1 = get(i, j);\n\t\t\t\tdouble value2 = matrix2.get(i, j);\n\t\t\t\tmatrix.set(i, j, value1 + value2);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tFull operator + (double value2) const {\n\t\tFull matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value + value2);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tFull operator - (const Matrix & matrix2) const {\n\t\tFull matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value1 = get(i, j);\n\t\t\t\tdouble value2 = matrix2.get(i, j);\n\t\t\t\tmatrix.set(i, j, value1 - value2);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tFull operator - (double value2) const {\n\t\tFull matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tmatrix.set(i, j, value - value2);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tFull max() const {\n\t\tif (rows == 1) {\n\t\t\treturn transpose().max();\n\t\t}\n\t\tFull matrix(1, columns);\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tdouble max = get(1, j);\n\t\t\tfor (int i = 2; i <= rows; ++ i) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tif (max < value) max = value;\n\t\t\t}\n\t\t\tmatrix.set(1, j, max);\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tFull min() const {\n\t\tif (rows == 1) {\n\t\t\treturn transpose().min();\n\t\t}\n\t\tFull matrix(1, columns);\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tdouble min = get(1, j);\n\t\t\tfor (int i = 2; i <= rows; ++ i) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tif (min > value) min = value;\n\t\t\t}\n\t\t\tmatrix.set(1, j, min);\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tFull sum() const {\n\t\tif (rows == 1) {\n\t\t\treturn transpose().sum();\n\t\t}\n\t\tFull matrix(1, columns);\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tdouble sum = 0;\n\t\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\t\tsum += get(i, j);\n\t\t\t}\n\t\t\tmatrix.set(1, j, sum);\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tFull pow(double exponent) {\n\t\tFull matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tvalue = ::pow(value, exponent);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tFull exp() {\n\t\tFull matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tvalue = ::exp(value);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tFull log() {\n\t\tFull matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tvalue = ::log(value);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tFull abs() {\n\t\tFull matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tdouble value = get(i, j);\n\t\t\t\tvalue = std::abs(value);\n\t\t\t\tmatrix.set(i, j, value);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\n\tdouble norm(int k) {\n\t\tif (rows == 1) {\n\t\t\treturn transpose().norm(k);\n\t\t}\n\t\treturn ::pow(abs().pow(k).sum().get(1, 1), (1.0 / k));\n\t}\n\n};",
            "from random import randint\nr = randint(3,6)\nc = randint(3,6)\nprint(r, c)\nfor i in range(r*c):\n\tprint(randint(1,9), end=' ')",
            1591322400,
            1589202000
        ],
        [
            "2.15 (C++)",
            "Design a class Sparse that implements interface Matrix:\nSparse should has the following public object functions in addition:\n<ol>\n<li>A constructor Sparse(int rows, int column), which initializes all elements in the matrix to 0's.</li>\n<li>A function Sparse Sparse::operator + (Sparse &amp; sparse2), which returns the pair-wise sum of two sparse matrixes.</li>\n</ol>\n\n<b><u>HINT</u></b><br>\n稀疏矩阵是大多数元素都为0的矩阵。<br>\n因此，存储稀疏矩阵的时候只存储不为0的元素可以节省空间。<br>\n例如，完整地存储一个1000000x1000000的浮点数矩阵需要8TB的内存。<br>\n但是，如果矩阵只有10个非0元素，那么我们只需记录这10个元素在矩阵中的位置和值。<br>\n要记录这10个元素中的每一个，我们可以使用一个3元组(行,列,值)，这个3元组的类<i>Entry</i>已经在主程序定义好。<br>\n要记录这10个元素，我们可以用一个<i>vector&lt;Entry&gt;</i>存储10个<i>Entry</i>的对象。<br>\n要获得这10个非0元素的值，只需查找这个<i>vector</i>。<br>\n位置(行,列)不在这个<i>vector</i>中的元素，就是值为0的元素。<br>\n题目中要求实现的<i>print</i>函数，只输出非0元素(的3元组表示)。顺序为小行优先，同行则小列优先。<br>\n<br>\n\n<u>EXAMPLE INPUT</u>\n<pre>1000000 1000000\n\n1 1 10\n1 1000000 50\n1000000 1000000 20\n\n1 1000000 30\n1000000 1 40\n1 1 -10</pre>\n\n<u>EXAMPLE OUTPUT</u>\n<pre>(1,1000000,80)\n(1000000,1,40)\n(1000000,1000000,20)</pre>",
            "class Entry\n{\npublic:\n\tint row;\n\tint column;\n\tdouble value;\n};\n\t\nclass Matrix\n{\t\npublic:\n\tvirtual int size(int dimension) const = 0;\n\t\n\tvirtual void set(int row, int column, \n\tdouble value) = 0;\n\t\n\tvirtual double get(int row, int column) \n\tconst = 0;\n\t\n\tvirtual void print() = 0;\n\t\n};\n\n#include \"source.cpp\"\n\n#include <iostream>\nusing namespace std;\n\nvoid print(Matrix & matrix) {\n\tmatrix.print();\n}\n\nvoid readAndSetElement(Matrix & matrix) {\n\tint row;\n\tint column;\n\tdouble value;\n\tcin >> row >> column >> value;\n\tmatrix.set(row, column, value);\n}\n\nvoid readAndSetMultipleElements(Matrix & matrix, int count) {\n\tfor (int i = 0; i < count; ++ i) {\n\t\treadAndSetElement(matrix);\n\t}\n}\n\nint main() {\n\tint rows;\n\tint columns;\n\tcin >> rows >> columns;\n\t\n\tSparse sparse1(rows, columns);\n\treadAndSetMultipleElements(sparse1, 3);\n\t\n\tSparse sparse2(rows, columns);\n\treadAndSetMultipleElements(sparse2, 3);\n\t\n\tSparse sparse3 = sparse1 + sparse2;\n\tprint(sparse3);\n}",
            "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Sparse : public Matrix\n{\t\nprivate:\n\t\n\tint rows;\n\tint columns;\n\tvector<Entry> entries;\n\t\n\tint find0(int row, int column) const {\n\t\tfor (int i = 0; i < entries.size(); ++ i) {\n\t\t\tEntry entry = entries[i];\n\t\t\tif (entry.row == row && entry.column == column) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tvoid remove0(int index) {\n\t\tfor (int i = index; i < entries.size() - 1; ++ i) {\n\t\t\tentries[i] = entries[i + 1];\n\t\t}\n\t\tentries.pop_back();\n\t}\n\t\n\tvoid insert0(int row, int column, double value) {\n\t\tint size = entries.size();\n\t\t// find a position to insert the entry\n\t\tint index = 0;\n\t\tfor (; index < size; ++ index) {\n\t\t\tEntry entry = entries[index];\n\t\t\tif (entry.row > row) break;\n\t\t\tif (entry.row == row && entry.column > column) break;\n\t\t}\n\t\t// increase the size of the entry vector\n\t\tEntry entry;\n\t\tentries.push_back(entry);\n\t\t// for all entries behide the insertion position, move 1 position\n\t\tfor (int i = size - 1; i >= index; -- i) {\n\t\t\tentries[i + 1] = entries[i];\n\t\t}\n\t\t// set the inserted entry\n\t\tentry.row = row;\n\t\tentry.column = column;\n\t\tentry.value = value;\n\t\tentries[index] = entry;\n\t}\n\t\n\tvoid set0(int index, double value) {\n\t\tEntry & entry = entries[index];\n\t\tentry.value = value;\n\t}\n\t\npublic:\n\n\tint size(int dimension) const {\n\t\tswitch (dimension) {\n\t\t\tcase 1: return rows;\n\t\t\tcase 2: return columns;\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tvoid set(int row, int column, double value) {\n\t\tint index = find0(row, column);\n\t\tif (index == -1) { // such element is 0\n\t\t\tif (value != 0) {\n\t\t\t\tinsert0(row, column, value);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (value == 0) {\n\t\t\t\tremove0(index);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tset0(index, value);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdouble get(int row, int column) const {\n\t\tint index = find0(row, column);\n\t\tif (index == -1) { // such element is 0\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\treturn entries[index].value;\n\t\t}\n\t}\n\t\npublic:\n\t\n\tSparse(int rows, int columns) {\n\t\t(*this).rows = rows;\n\t\t(*this).columns = columns;\n\t\t(*this).entries.clear();\n\t}\n\t\n\tvoid print() {\n\t\tfor (int i = 0; i < entries.size(); ++ i) {\n\t\t\tEntry entry = entries[i];\n\t\t\tcout << \"(\" << entry.row << \",\" <<\n\t\t\t\tentry.column << \",\" <<\n\t\t\t\tentry.value << \")\" << endl;\n\t\t}\n\t}\n\t\n\tSparse operator + (Sparse & sparse2) {\n\t\tSparse sparse3(*this);\n\t\tfor (int i = 0; i < sparse2.entries.size(); ++ i) {\n\t\t\tEntry entry = sparse2.entries[i];\n\t\t\tdouble value = get(entry.row, entry.column);\n\t\t\tvalue += entry.value;\n\t\t\tsparse3.set(entry.row, entry.column, value);\n\t\t}\n\t\treturn sparse3;\n\t}\n\t\n};",
            "from random import randint\nr = randint(10000,20000)\nc = randint(10000,20000)\nprint(r,c)\n\nprint()\nr2 = randint(1,r)\nc2 = randint(1,c)\nfor i in range(3):\n\tif i == 1:\n\t\tr1 = r2\n\t\tc1 = c2\n\telse:\n\t\tr1 = randint(1,r)\n\t\tc1 = randint(1,c)\n\tv = randint(1,999)/100\n\tprint(r1,c1,v)\n\nprint()\nfor i in range(3):\n\tif i != 0:\n\t\tif i == 1:\n\t\t\tr1 = r2\n\t\t\tc1 = c2\n\t\telse:\n\t\t\tr1 = randint(1,r)\n\t\t\tc1 = randint(1,c)\n\t\tv = randint(1,999)/100\n\telse:\n\t\tv = -v\t\t\n\tprint(r1,c1,v)",
            1591322400,
            1589202000
        ],
        [
            "2.16 (C++)",
            "Design a class Sparse that implements interface Matrix:\nSparse should has the following public object functions in addition:\n<ol>\n<li>A constructor Sparse(int rows, int column), which initializes all elements in the matrix to 0's.</li>\n<li>A function Sparse Sparse::operator * (Sparse & sparse2), which returns the product of two sparse matrixes.</li>\n</ol>\n\n<u>EXAMPLE INPUT</u>\n<pre>1000000 2000000 3000000\n\n1 1 10\n1 2000000 50\n1000000 2000000 20\n\n1 3000000 30\n2000000 1 40\n1 1 -10</pre>\n\n<u>EXAMPLE OUTPUT</u>\n<pre>(1,1,1900)\n(1,3000000,300)\n(1000000,1,800)</pre>",
            "class Entry\n{\npublic:\n\tint row;\n\tint column;\n\tdouble value;\n};\n\t\nclass Matrix\n{\t\npublic:\n\tvirtual int size(int dimension) const = 0;\n\t\n\tvirtual void set(int row, int column, \n\tdouble value) = 0;\n\t\n\tvirtual double get(int row, int column) \n\tconst = 0;\n\t\n\tvirtual void print() = 0;\n\t\n};\n\n#include \"source.cpp\"\n\n#include <iostream>\nusing namespace std;\n\nvoid print(Matrix & matrix) {\n\tmatrix.print();\n}\n\nvoid readAndSetElement(Matrix & matrix) {\n\tint row;\n\tint column;\n\tdouble value;\n\tcin >> row >> column >> value;\n\tmatrix.set(row, column, value);\n}\n\nvoid readAndSetMultipleElements(Matrix & matrix, int count) {\n\tfor (int i = 0; i < count; ++ i) {\n\t\treadAndSetElement(matrix);\n\t}\n}\n\nint main() {\n\tint rows;\n\tint columns;\n\tint & rows2 = columns;\n\tint columns2;\n\t\n\tcin >> rows >> columns >> columns2;\n\t\n\tSparse sparse1(rows, columns);\n\treadAndSetMultipleElements(sparse1, 3);\n\t\n\tSparse sparse2(rows2, columns2);\n\treadAndSetMultipleElements(sparse2, 3);\n\n\tSparse sparse3 = sparse1 * sparse2;\n\tprint(sparse3);\n}",
            "#include <iostream> \n#include <vector> \nusing namespace std; \n\t\n///////////////////////// \n// class Comparator & Sorter \n// \n\ntemplate <typename T> \nclass Comparator \n{ \npublic:\n\t/*\n\tReturns 0 if equal, -1 if obj1 < obj2, and 1 othewise.\n\t*/\n\tvirtual int compare(const T & obj1, const T & obj2) const = 0; \n}; \n\ntemplate <typename E> \nclass Sorter \n{ \npublic: \n\n\t/*\n\tFind the index of the largest element among the first 'len'-th elements in \n\tthe container.\n\t*/\n\tint findMaxIndex(const vector<E> & container, int len, \n\t\t\t\t\tconst Comparator<E> & cmp) {\n\t\tint indexOfMax = 0; \n\t\tfor (int i = 1; i < len; ++ i) { \n\t\t\tif (cmp.compare(container[indexOfMax], container[i]) == -1) { \n\t\t\t\tindexOfMax = i; \n\t\t\t} \n\t\t} \n\t\treturn indexOfMax; \n\t} \n\t \n\t/*\n\tSwap elements in the given positions.\n\t*/\n\tvoid swap(vector<E> & container, int index1, int index2) { \n\t\tE tuple1 = container[index1]; \n\t\tE tuple2 = container[index2]; \n\t\tcontainer[index1] = tuple2; \n\t\tcontainer[index2] = tuple1; \n\t} \n\n\t/*\n\tSort the elements in a container with a comparator.\n\t*/\n\tvoid sort(vector<E> & container, const Comparator<E> & cmp) { \n\t\tfor (int len = container.size(); len >= 2; -- len) { \n\t\t\tint index = findMaxIndex(container, len, cmp); \n\t\t\tint last = len - 1; \n\t\t\tif (index == last) continue; \n\t\t\tswap(container, index, last); \n\t\t} \n\t} \n\n}; \n\n///////////////////////// \n// class Sparse \n// \n\nclass Sparse : public Matrix \n{ \n\t/*\n\tYou are not supposed write the following functions.\n\t- The copy constructor: Sparse(const Sparse &)\n\t- The assignment operator: Sparse & operator = (const Sparse &)\n\t- The destructor: ~Sparse()\n\t\n\t* Why?\n\t\n\tBecause C++ will compose them, and the composed ones work just fine\n\tif the class has no member variable of type address.\n\t\n\tOtherwise (class has address member variables), \n\tyou have to write these functions.\n\t\n\t* What about addresses inside the member variables?\n\t\n\tThe will be taken care of automatically. For instance, \n\tin the following program, the copy constructor of 'triples' will \n\tbe called in the composed copy constructor of class Sparse.\n\t\n\tLikewisely, the assignment operator of 'triples' will be called in \n\tthe composed assignment operator of class Sparse; the destructor of \n\t'triples' will be called in the destructor of class Sparse; and the \n\tdefault constructor (if there is on) of 'triples' will be called \n\tin the default constructor of class Sparse.\n\t\n\t*/\n\t\nprivate: \n\tint rows; \n\tint columns; \n\tvector<Entry> triples;\n\t\n\t/*\n\tFor a 2-D matrix element, find the index of its triple representation \n\twithin 'triples'\n\t*/\n\tint findTriple0(int row, int column) const {\n\t\tfor (int i = 0; i < triples.size(); ++ i) { \n\t\t\tif (triples[i].row == row and triples[i].column == column) { \n\t\t\t\treturn i; \n\t\t\t} \n\t\t} \n\t\treturn -1;\n\t}\n\t\n\t/*\n\tAdd a triple representation to 'triples'\n\t*/\n\tvoid addTriple0(int row, int column, double value) {\n\t\tEntry triple;\n\t\ttriple.row = row;\n\t\ttriple.column = column;\n\t\ttriple.value = value;\n\t\tthis->triples.push_back(triple);\n\t}\t\n\t\n\t/*\n\tRemove a triple representation from 'triples'\n\t*/\n\tvoid removeTripleAtIndex0(int index) {\n\t\ttriples[index] = triples[triples.size() - 1];\n\t\ttriples.pop_back();\n\t}\n\npublic: \n\n\t/*\n\tReturn the size of the matrix on the given dimension.\n\t*/\n\tvirtual int size(int dimension) const { \n\t\tswitch (dimension) {\n\t\tcase 1: return this->rows;\n\t\tcase 2: return this->columns;\n\t\t}\n\t\treturn 0;\n\t} \n\t  \n\t/*\n\tAdd an element into the sparse matrix.\n\tNo need to represent zeros.\n\t*/\n\tvirtual void set(int row, int column, double value) { \n\t\tint index = this->findTriple0(row, column);\n\t\tif (index == -1) {\n\t\t\tif (value != 0) {\n\t\t\t\taddTriple0(row, column, value);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (value != 0) {\n\t\t\t\tthis->triples[index].value = value;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tremoveTripleAtIndex0(index);\n\t\t\t}\n\t\t} \n\t}  \n\t  \n\t/*\n\tGet an element using a 2-D matrix index.\n\t*/\n\tvirtual double get(int row, int column) const { \n\t\tint index = this->findTriple0(row, column);\n\t\treturn (index == -1 ? 0 : this->triples[index].value); \n\t}\n\t\n\t/*\n\tAssignment from an abstract Matrix reference\n\t*/\n\tvirtual Matrix & operator = (const Matrix & matrix2) { \n\t\t(*this) = (Sparse &)matrix2; // calls the composed \n\t\t\t\t\t\t\t\t// 'operator = (const Sparse &)'\n\t\treturn *this;\n\t} \n\t\n\t/*\n\tThe composed assigment operator function looks exactly like:\n\t\n\tvirtual Sparse & operator = (const Sparse & matrix2) { \n\t\tthis->rows = matrix2.rows;\n\t\tthis->columns = matrix2.columns;\n\t\tthis->triples = matrix2.triples;\n\t\treturn *this;\n\t}\n\t*/\n\n\t/*\n\tCreate a sparse matrix with a given size and all zero elements.\n\t*/\n\tSparse(int rows, int columns) { \n\t\tthis->rows = rows; \n\t\tthis->columns = columns; \n\t} \n\t\n\t/*\n\tCreate a sparse matrix by copying an existing matrix.\n\t*/\n\tSparse(const Matrix & matrix2) { \n\t\t(*this) = matrix2;\n\t} \n\t \n\tvirtual void print() { \n\t\tthis->sortTriples(); \n\t\tthis->printAllTriples(); \n\t}\n\t\nprivate: \n\n\t/*\n\tA comparator to be used when sorting triple representations,\n\twhich orders triples first by row-indexes, then by column-indexes.\n\t*/\n\tclass TripleComparator : public Comparator<Entry> \n\t{ \n\tpublic: \n\t\tint compare(const Entry & triple1, const Entry & triple2) const { \n\t\t\tif (triple1.row > triple2.row) return 1; \n\t\t\tif (triple2.row > triple1.row) return -1; \n\t\t\tif (triple1.column > triple2.column) return 1; \n\t\t\tif (triple2.column > triple1.column) return -1; \n\t\t\treturn 0; \n\t\t} \n\t}; \n\n\t/*\n\tSort triple representation of the elements in the matrix,\n\tordered first by row-indexes, then by column-indexes.\n\t*/\n\tvoid sortTriples() { \n\t\tSorter<Entry>().sort(this->triples, TripleComparator()); \n\t} \n\t\n\t/*\n\tPrint all triples.\n\t*/\n\tvoid printAllTriples() const { \n\t\tfor (int i = 0; i < triples.size(); ++ i) {\n\t\t\tthis->printTriple(triples[i]);\n\t\t}\n\t\tcout << endl;\n\t} \n\t \n\t/*\n\tPrint a single triple.\n\t*/\n\tvoid printTriple(const Entry & triple) const { \n\t\tcout << \"(\" << triple.row << \",\" << triple.column << \n\t\t\t\",\" << triple.value << \")\" << endl; \n\t} \n\n/*\npublic: \n\tvirtual Iterator * iterator() const { \n\t\treturn new SparseIterator(this); \n\t}\n\t \n\t/////////////////////////// \n\t// inner class SparseIterator \n\t// \n\n\nprivate: \n\tclass SparseIterator : public Iterator \n\t{ \n\tprivate: \n\t\tconst Sparse * matrix; \n\t\tint count; \n\n\tpublic: \n\t\tSparseIterator(const Sparse * matrix2) { \n\t\t\tmatrix = matrix2; \n\t\t\tcount = 0; \n\t\t} \n\n\t\tvirtual bool hasNext() const { \n\t\t\treturn count < matrix->tuples.size(); \n\t\t} \n\t \n\t\tvirtual const Entry & next() { \n\t\t\treturn matrix->tuples[count ++]; \n\t\t} \n\n\t}; // end of inner class \n\n*/\n\nprivate:\n\t/*\n\tAdd the given value to the value on the given 2-D position.\n\t*/\n\tvoid addToElement0(int row, int column, double value) {\n\t\tdouble original = this->get(row, column);\n\t\tthis->set(row, column, original + value);\n\t}\n\t\npublic:\n\t\n\t/*\n\tReturns the sum of two matrixes.\n\t*/\n\tSparse operator + (const Sparse & sparse2) const {\n\t\tSparse sparse1(*this);\n\t\tfor (int i = 0; i < sparse2.triples.size(); ++ i) {\n\t\t\tEntry triple = sparse2.triples[i];\n\t\t\tsparse1.addToElement0(triple.row, triple.column, triple.value);\n\t\t}\n\t\treturn sparse1;\n\t}\n\t\n\t/*\n\tReturns the product of two matrixes.\n\t*/\t\n\tSparse operator * (const Sparse & sparse2) const {\n\t\tconst Sparse & sparse1 = *this;\n\t\tSparse sparse3(sparse1.rows, sparse2.columns);\n\t\tfor (int i = 0; i < sparse1.triples.size(); ++ i) {\n\t\t\tconst Entry & triple1 = sparse1.triples[i];\n\t\t\tfor (int j = 0; j < sparse2.triples.size(); ++ j) {\n\t\t\t\tconst Entry & triple2 = sparse2.triples[j];\n\t\t\t\t\n\t\t\t\tif (triple1.column != triple2.row) continue;\n\t\t\t\tdouble value = triple1.value * triple2.value;\n\t\t\t\tsparse3.addToElement0(triple1.row, triple2.column, value);\n\t\t\t}\n\t\t}\n\t\treturn sparse3;\n\t}\n\t \n};",
            "from random import randint\nr = randint(10000,20000)\nc = randint(10000,20000)\ncc = randint(10000,20000)\nprint(r,c,cc)\nr1 = randint(1,r)\nr2 = randint(1,r)\nc1 = randint(1,c)\nc2 = randint(1,c)\ncc1 = randint(1,cc)\ncc2 = randint(1,cc)\nrc = [(r1,c1), (r1,c2), (r2,c2), (c1,cc1), (c1,cc2), (c2,cc1)]\nfor r3,c3 in rc:\n\tv = randint(1,999)/100\n\tprint(r3,c3,v)\n",
            1591322400,
            1589202000
        ],
        [
            "6.1 (C++)",
            "把 Matrix 类改为模板容器类。\n<br><br>\n<u>OUTPUT</u>\n<pre>constructor 1\n    0    0    0\n    0    0    0\n    0    0    0\nconstructor 2\n    1    2    3\n    4    5    6\n    7    8    9\ncopy constructor\n    1    2    3\n    4    5    6\n    7    8    9\nget\n    10    2    3\n    4    5    6\n    7    8    9\noperator =\n    1    2    3\n    4    5    6\n    7    8    9\nconstructor 1\n            \n            \n            \nconstructor 2\n    A    B    C\n    C    D    E\n    F    G    H\ncopy constructor\n    A    B    C\n    C    D    E\n    F    G    H\nget\n    IJK    B    C\n    C    D    E\n    F    G    H\noperator =\n    A    B    C\n    C    D    E\n    F    G    H\n</pre>",
            "#include <iostream>\n#include <string>\nusing namespace std;\n\n#include \"source.cpp\"\n\nint main4double() {\n\tcout << \"constructor 1\" << endl;\n\tMatrix<double> matrix1(3, 3);\n\tmatrix1.print();\n\t\n\tconst double values2[] = {\n\t\t1, 2, 3,\n\t\t4, 5, 6,\n\t\t7, 8, 9,\n\t};\n\tcout << \"constructor 2\" << endl;\n\tMatrix<double> matrix2(3, 3, values2);\n\tmatrix2.print();\n\t\n\tcout << \"copy constructor\" << endl;\n\tMatrix<double> matrix3 = matrix2;\n\tmatrix3.print();\n\t\n\tcout << \"get\" << endl;\n\tmatrix3.get(1, 1) = 10.0;\n\tmatrix3.print();\n\t\n\tcout << \"operator =\" << endl;\n\tmatrix3 = matrix2;\n\tmatrix3.print();\n}\n\nint main4string() {\n\tcout << \"constructor 1\" << endl;\n\tMatrix<string> matrix1(3, 3);\n\tmatrix1.print();\n\t\n\tconst string values2[] = {\n\t\t\"A\", \"B\", \"C\",\n\t\t\"C\", \"D\", \"E\",\n\t\t\"F\", \"G\", \"H\"\n\t};\n\tcout << \"constructor 2\" << endl;\n\tMatrix<string> matrix2(3, 3, values2);\n\tmatrix2.print();\n\t\n\tcout << \"copy constructor\" << endl;\n\tMatrix<string> matrix3 = matrix2;\n\tmatrix3.print();\n\t\n\tcout << \"get\" << endl;\n\tmatrix3.get(1, 1) = \"IJK\";\n\tmatrix3.print();\n\t\n\tcout << \"operator =\" << endl;\n\tmatrix3 = matrix2;\n\tmatrix3.print();\n}\n\nint main() {\n\tmain4double();\n\tmain4string();\n}",
            "#include <iostream>\nusing namespace std;\n\ntemplate <typename T>\nclass Matrix\n{\n\t\nprivate:\n\t\n\tint rows;\n\tint columns;\n\tT * values;\n\t\npublic:\n\t\n\tint size(int dimension) const {\n\t\tswitch (dimension) {\n\t\t\tcase 1: return rows;\n\t\t\tcase 2: return columns;\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tT & get(int row, int column) const {\n\t\t-- row;\n\t\t-- column;\n\t\treturn values[row * columns + column];\n\t}\n\nprivate:\n\t\n\tvoid assign0(int rows, int columns) {\n\t\t(*this).rows = rows;\n\t\t(*this).columns = columns;\n\t\t(*this).values = new T[rows * columns];\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tget(i, j) = T();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid assign0(int rows, int columns, const T values[]) {\n\t\t(*this).rows = rows;\n\t\t(*this).columns = columns;\n\t\t(*this).values = new T[rows * columns];\n\t\tint count = 0;\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tget(i, j) = values[count];\n\t\t\t\t++ count;\n\t\t\t}\n\t\t}\n\t}\n\t\npublic:\n\t\n\tMatrix(int rows, int columns) {\n\t\tassign0(rows, columns);\n\t}\n\t\n\tMatrix(int rows, int columns, const T values[]) {\n\t\tassign0(rows, columns, values);\n\t}\n\t\n\tMatrix(const Matrix & matrix2) {\n\t\tassign0(matrix2.rows, matrix2.columns, matrix2.values);\n\t}\n\t\n\t~Matrix() {\n\t\tdelete [] values;\n\t}\n\t\n\tvoid print() const {\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tcout << \"    \" << get(i, j);\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\t\n\tMatrix & operator = (const Matrix & matrix2) {\n\t\tdelete [] values;\n\t\tassign0(matrix2.rows, matrix2.columns, matrix2.values);\n\t\treturn (*this);\n\t}\n\t\n};",
            "",
            1590112800,
            1590670800
        ],
        [
            "6.2 (C++)",
            "Design a template class Matrix that has the following private member variables:\n<ol>\n<li>int rows</li>\n<li>int columns</li>\n<li>T * values</li>\n</ol>\n, where T is the type parameter.<br>\nBesides, it has the following public functions:\n<ol>\n<li>A constructor Matrix(int rows, int column), which initializes all elements in the matrix to all 0's.</li>\n<li>A destructor.</li>\n<li>A print function which prints each row of elements in a single line, with each element preceded with 4 spaces.</li>\n</ol>\n\n<u>EXAMPLE INPUT</u>\n<pre>3 4</pre>\n\n<u>EXAMPLE OUTPUT</u>\n<pre>    0    0    0    0\n    0    0    0    0\n    0    0    0    0\n\n    0    0    0    0\n    0    0    0    0\n    0    0    0    0</pre>",
            "#include \"source.cpp\"\n\nint main() {\n\tint rows;\n\tint columns;\n\tcin >> rows >> columns;\n\t\n\tMatrix<double> matrix1(rows, columns);\n\tmatrix1.print();\n\tcout << endl;\n\t\n\tMatrix<int> matrix2(rows, columns);\n\tmatrix2.print();\n}",
            "#include <iostream>\nusing namespace std;\n\ntemplate <typename T>\nclass Matrix\n{\n\t\nprivate:\n\t\n\tint rows;\n\tint columns;\n\tT * values;\n\t\npublic:\n\t\n\tint size(int dimension) const {\n\t\tswitch (dimension) {\n\t\t\tcase 1: return rows;\n\t\t\tcase 2: return columns;\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tT & get(int row, int column) const {\n\t\t-- row;\n\t\t-- column;\n\t\treturn values[row * columns + column];\n\t}\n\nprivate:\n\t\n\tvoid assign0(int rows, int columns) {\n\t\t(*this).rows = rows;\n\t\t(*this).columns = columns;\n\t\t(*this).values = new T[rows * columns];\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tget(i, j) = 0.0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid assign0(int rows, int columns, const T values[]) {\n\t\t(*this).rows = rows;\n\t\t(*this).columns = columns;\n\t\t(*this).values = new T[rows * columns];\n\t\tint count = 0;\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tget(i, j) = values[count];\n\t\t\t\t++ count;\n\t\t\t}\n\t\t}\n\t}\n\t\npublic:\n\t\n\tMatrix(int rows, int columns) {\n\t\tassign0(rows, columns);\n\t}\n\t\n\tMatrix(int rows, int columns, const T values[]) {\n\t\tassign0(rows, columns, values);\n\t}\n\t\n\tMatrix(const Matrix & matrix2) {\n\t\tassign0(matrix2.rows, matrix2.columns, matrix2.values);\n\t}\n\t\n\t~Matrix() {\n\t\tdelete [] values;\n\t}\n\t\n\tvoid print() const {\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tcout << \"    \" << get(i, j);\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\t\n\tMatrix & operator = (const Matrix & matrix2) {\n\t\tdelete [] values;\n\t\tassign0(matrix2.rows, matrix2.columns, matrix2.values);\n\t\treturn (*this);\n\t}\n\t\n\tMatrix getColumn(int column) const {\n\t\tMatrix columnMatrix(rows, 1);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tT & value = get(i, column);\n\t\t\tcolumnMatrix.get(i, 1) = value;\n\t\t}\n\t\treturn columnMatrix;\n\t}\n\n\tMatrix getRow(int row) const {\n\t\tMatrix rowMatrix(1, columns);\n\t\tfor (int i = 1; i <= columns; ++ i) {\n\t\t\tT & value = get(row, i);\n\t\t\trowMatrix.get(1, i) = value;\n\t\t}\n\t\treturn rowMatrix;\n\t}\n\t\n\tMatrix concatenateRows(const Matrix & matrix2) const {\n\t\tMatrix matrix(rows + matrix2.rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tT & value = get(i, j);\n\t\t\t\tmatrix.get(i, j) = value;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= matrix2.rows; ++ i) {\n\t\t\tfor (int j = 1; j <= matrix2.columns; ++ j) {\n\t\t\t\tT & value = matrix2.get(i, j);\n\t\t\t\tmatrix.get(rows + i, j) = value;\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix concatenateColumns(const Matrix & matrix2) const {\n\t\tMatrix matrix(rows, columns + matrix2.columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tT & value = get(i, j);\n\t\t\t\tmatrix.get(i, j) = value;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= matrix2.rows; ++ i) {\n\t\t\tfor (int j = 1; j <= matrix2.columns; ++ j) {\n\t\t\t\tT & value = matrix2.get(i, j);\n\t\t\t\tmatrix.get(i, columns + j) = value;\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix reshape(int rows, int columns) const {\n\t\tMatrix matrix(rows, columns);\n\t\tint count = 0;\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\t\tint row2 = 1 + count % (*this).rows;\n\t\t\t\tint column2 = 1 + count / (*this).rows;\n\t\t\t\t++ count;\n\t\t\t\tT & value = get(row2, column2);\n\t\t\t\tmatrix.get(i, j) = value;\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\t\n\tMatrix transpose() const {\n\t\tMatrix matrix(columns, rows);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tT & value = get(i, j);\n\t\t\t\tmatrix.get(j, i) = value;\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator * (const Matrix & matrix2) const {\n\t\tMatrix matrix(rows, matrix2.columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= matrix2.columns; ++ j) {\n\t\t\t\tT sum = 0;\n\t\t\t\tfor (int k = 1; k <= columns; ++ k) {\n\t\t\t\t\tT & value1  = get(i, k);\n\t\t\t\t\tT & value2 = matrix2.get(k, j);\n\t\t\t\t\tsum += value1 * value2;\n\t\t\t\t}\n\t\t\t\tmatrix.get(i, j) = sum;\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\n\tMatrix operator * (T times) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tT & value = get(i, j);\n\t\t\t\tmatrix.get(i, j) = value * times;\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator + (const Matrix & matrix2) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tT & value1 = get(i, j);\n\t\t\t\tT & value2 = matrix2.get(i, j);\n\t\t\t\tmatrix.get(i, j) = value1 + value2;\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator + (T value2) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tT & value = get(i, j);\n\t\t\t\tmatrix.get(i, j) = value + value2;\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator - (const Matrix & matrix2) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tT & value1 = get(i, j);\n\t\t\t\tT & value2 = matrix2.get(i, j);\n\t\t\t\tmatrix.get(i, j) = value1 - value2;\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator - (T value2) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tT & value = get(i, j);\n\t\t\t\tmatrix.get(i, j) = value - value2;\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix max() const {\n\t\tif (rows == 1) {\n\t\t\treturn transpose().max();\n\t\t}\n\t\tMatrix matrix(1, columns);\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tT max = get(1, j);\n\t\t\tfor (int i = 2; i <= rows; ++ i) {\n\t\t\t\tT & value = get(i, j);\n\t\t\t\tif (max < value) max = value;\n\t\t\t}\n\t\t\tmatrix.get(1, j) = max;\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix min() const {\n\t\tif (rows == 1) {\n\t\t\treturn transpose().min();\n\t\t}\n\t\tMatrix matrix(1, columns);\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tT min = get(1, j);\n\t\t\tfor (int i = 2; i <= rows; ++ i) {\n\t\t\t\tT & value = get(i, j);\n\t\t\t\tif (min > value) min = value;\n\t\t\t}\n\t\t\tmatrix.get(1, j) = min;\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix sum() const {\n\t\tif (rows == 1) {\n\t\t\treturn transpose().sum();\n\t\t}\n\t\tMatrix matrix(1, columns);\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tT sum = 0;\n\t\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\t\tsum += get(i, j);\n\t\t\t}\n\t\t\tmatrix.get(1, j) = sum;\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n};",
            "from random import randint\nprint(randint(3,9))\nprint(randint(3,9))",
            1590631200,
            1590637200
        ],
        [
            "6.3 (C++)",
            "Design a template class Matrix that has the following private member variables:\n<ol>\n<li>int rows</li>\n<li>int columns</li>\n<li>vector&lt;T&gt; values</li>\n</ol>\n, where T is the type parameter.<br>\nBesides, it has the functions such that the main function runs correctly with the following output.<br>\n<br>\n<u>EXAMPLE OUTPUT</u>\n<pre>constructor 1\n    0    0    0\n    0    0    0\n    0    0    0\nconstructor 2\n    1    2    3\n    4    5    6\n    7    8    9\ncopy constructor\n    1    2    3\n    4    5    6\n    7    8    9\noperator =\n    1    2    3\n    4    5    6\n    7    8    9\ngetColumn\n    2\n    5\n    8\ngetRow\n    4    5    6\nconcatenateRows\n    0    0    0\n    0    0    0\n    0    0    0\n    1    2    3\n    4    5    6\n    7    8    9\nconcatenateColumns\n    0    0    0    1    2    3\n    0    0    0    4    5    6\n    0    0    0    7    8    9\nreshape\n    0    0    2\n    0    0    5\n    0    0    8\n    0    1    3\n    0    4    6\n    0    7    9\ntranspose\n    1    4    7\n    2    5    8\n    3    6    9\noperator +\n    2    4    6\n    8    10    12\n    14    16    18\noperator +\n    11    12    13\n    14    15    16\n    17    18    19\noperator -\n    0    2    4\n    -2    0    2\n    -4    -2    0\noperator -\n    -9    -8    -7\n    -6    -5    -4\n    -3    -2    -1\noperator *\n    66    78    90\n    78    93    108\n    90    108    126\noperator *\n    2    4    6\n    8    10    12\n    14    16    18\nmax\n9\nmin\n1\nsum\n45\n</pre>",
            "#include \"source.cpp\"\n\nint main() {\n\tcout << \"constructor 1\" << endl;\n\tMatrix<double> matrix1(3, 3);\n\tmatrix1.print();\n\t\n\tconst double values1[] = {\n\t\t1, 2, 3,\n\t\t4, 5, 6,\n\t\t7, 8, 9,\n\t};\n\tvector<double> values2;\n\tfor (int i = 0; i < 9; ++ i) {\n\t\tvalues2.push_back(values1[i]);\n\t}\n\t\n\tcout << \"constructor 2\" << endl;\n\tMatrix<double> matrix2(3, 3, values2);\n\tmatrix2.print();\n\t\n\tcout << \"copy constructor\" << endl;\n\tMatrix<double> matrix3 = matrix2;\n\tmatrix3.print();\n\t\n\tcout << \"operator =\" << endl;\n\tmatrix3.get(1, 1) = 10.0;\n\tmatrix3 = matrix2;\n\tmatrix3.print();\n\t\n\tcout << \"getColumn\" << endl;\n\tmatrix2.getColumn(2).print();\n\tcout << \"getRow\" << endl;\n\tmatrix2.getRow(2).print();\n\t\n\tcout << \"concatenateRows\" << endl;\n\tmatrix1.concatenateRows(matrix2).print();\n\tcout << \"concatenateColumns\" << endl;\n\tmatrix1.concatenateColumns(matrix2).print();\n\t\n\tcout << \"reshape\" << endl;\n\tmatrix1.concatenateColumns(matrix2).\n\t\treshape(6, 3).print();\n\t\n\tcout << \"transpose\" << endl;\n\tmatrix2.transpose().print();\n\t\n\tcout << \"operator +\" << endl;\n\t(matrix2 + matrix2).print();\n\tcout << \"operator +\" << endl;\n\t(matrix2 + 10).print();\n\tcout << \"operator -\" << endl;\n\t(matrix2.transpose() - matrix2).print();\n\tcout << \"operator -\" << endl;\n\t(matrix2 - 10).print();\n\t\n\tcout << \"operator *\" << endl;\n\t(matrix2.transpose() * matrix2).print();\n\tcout << \"operator *\" << endl;\n\t(matrix2 * 2).print();\n\t\n\tcout << \"max\" << endl;\n\tcout << matrix2.max().max().get(1, 1) << endl;\n\tcout << \"min\" << endl;\n\tcout << matrix2.min().min().get(1, 1) << endl;\n\tcout << \"sum\" << endl;\n\tcout << matrix2.sum().sum().get(1, 1) << endl;\t\t\n}",
            "#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate <typename T>\nclass Matrix\n{\npublic:\n\t\n\tint rows;\n\tint columns;\n\tvector<T> values;\n\t\npublic:\n\t\n\tT & get(int row, int column) {\n\t\t-- row;\n\t\t-- column;\n\t\treturn values[row * columns + column];\n\t}\n\t\n\tconst T & get(int row, int column) const {\n\t\t-- row;\n\t\t-- column;\n\t\treturn values[row * columns + column];\n\t}\n\t\n\tvoid print() const {\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tcout << \"    \" << get(i, j);\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\t\t\n\tint size(int dimension) const {\n\t\tswitch (dimension) {\n\t\t\tcase 1: return rows;\n\t\t\tcase 2: return columns;\n\t\t}\n\t\treturn 0;\n\t}\n\t\nprivate:\n\t\n\tvoid assign0(int rows, int columns) {\n\t\t(*this).rows = rows;\n\t\t(*this).columns = columns;\n\t\t(*this).values.clear();\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\t(*this).values.push_back(0.0);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid assign0(int rows, int columns, const vector<T> & values) {\n\t\t(*this).rows = rows;\n\t\t(*this).columns = columns;\n\t\t(*this).values.clear();\n\t\tint count = 0;\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\t(*this).values.push_back(values[count]);\n\t\t\t\t++ count;\n\t\t\t}\n\t\t}\n\t}\n\t\npublic:\n\t\n\tMatrix(int rows, int columns) {\n\t\tassign0(rows, columns);\n\t}\n\t\n\tMatrix(int rows, int columns, const vector<T> & values) {\n\t\tassign0(rows, columns, values);\n\t}\n\t\n\tMatrix(const Matrix & matrix2) {\n\t\tassign0(matrix2.rows, matrix2.columns, matrix2.values);\n\t}\n\t\t\n\tMatrix & operator = (const Matrix & matrix2) {\n\t\tassign0(matrix2.rows, matrix2.columns, matrix2.values);\n\t\treturn (*this);\n\t}\n\t\n\tMatrix getColumn(int column) const {\n\t\tMatrix columnMatrix(rows, 1);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tconst T & value = get(i, column);\n\t\t\tcolumnMatrix.get(i, 1) = value;\n\t\t}\n\t\treturn columnMatrix;\n\t}\n\n\tMatrix getRow(int row) const {\n\t\tMatrix rowMatrix(1, columns);\n\t\tfor (int i = 1; i <= columns; ++ i) {\n\t\t\tconst T & value = get(row, i);\n\t\t\trowMatrix.get(1, i) = value;\n\t\t}\n\t\treturn rowMatrix;\n\t}\n\t\n\tMatrix concatenateRows(const Matrix & matrix2) const {\n\t\tMatrix matrix(rows + matrix2.rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tconst T & value = get(i, j);\n\t\t\t\tmatrix.get(i, j) = value;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= matrix2.rows; ++ i) {\n\t\t\tfor (int j = 1; j <= matrix2.columns; ++ j) {\n\t\t\t\tconst T & value = matrix2.get(i, j);\n\t\t\t\tmatrix.get(rows + i, j) = value;\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix concatenateColumns(const Matrix & matrix2) const {\n\t\tMatrix matrix(rows, columns + matrix2.columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tconst T & value = get(i, j);\n\t\t\t\tmatrix.get(i, j) = value;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= matrix2.rows; ++ i) {\n\t\t\tfor (int j = 1; j <= matrix2.columns; ++ j) {\n\t\t\t\tconst T & value = matrix2.get(i, j);\n\t\t\t\tmatrix.get(i, columns + j) = value;\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix reshape(int rows, int columns) const {\n\t\tMatrix matrix(rows, columns);\n\t\tint count = 0;\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\t\tint row2 = 1 + count % (*this).rows;\n\t\t\t\tint column2 = 1 + count / (*this).rows;\n\t\t\t\t++ count;\n\t\t\t\tconst T & value = get(row2, column2);\n\t\t\t\tmatrix.get(i, j) = value;\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\t\n\tMatrix transpose() const {\n\t\tMatrix matrix(columns, rows);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tconst T & value = get(i, j);\n\t\t\t\tmatrix.get(j, i) = value;\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator * (const Matrix & matrix2) const {\n\t\tMatrix matrix(rows, matrix2.columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= matrix2.columns; ++ j) {\n\t\t\t\tT sum = 0;\n\t\t\t\tfor (int k = 1; k <= columns; ++ k) {\n\t\t\t\t\tconst T & value1  = get(i, k);\n\t\t\t\t\tconst T & value2 = matrix2.get(k, j);\n\t\t\t\t\tsum += value1 * value2;\n\t\t\t\t}\n\t\t\t\tmatrix.get(i, j) = sum;\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\n\tMatrix operator * (T times) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tconst T & value = get(i, j);\n\t\t\t\tmatrix.get(i, j) = value * times;\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator + (const Matrix & matrix2) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tconst T & value1 = get(i, j);\n\t\t\t\tconst T & value2 = matrix2.get(i, j);\n\t\t\t\tmatrix.get(i, j) = value1 + value2;\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator + (T value2) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tconst T & value = get(i, j);\n\t\t\t\tmatrix.get(i, j) = value + value2;\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator - (const Matrix & matrix2) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tconst T & value1 = get(i, j);\n\t\t\t\tconst T & value2 = matrix2.get(i, j);\n\t\t\t\tmatrix.get(i, j) = value1 - value2;\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix operator - (T value2) const {\n\t\tMatrix matrix(rows, columns);\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tconst T & value = get(i, j);\n\t\t\t\tmatrix.get(i, j) = value - value2;\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix max() const {\n\t\tif (rows == 1) {\n\t\t\treturn transpose().max();\n\t\t}\n\t\tMatrix matrix(1, columns);\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tT max = get(1, j);\n\t\t\tfor (int i = 2; i <= rows; ++ i) {\n\t\t\t\tconst T & value = get(i, j);\n\t\t\t\tif (max < value) max = value;\n\t\t\t}\n\t\t\tmatrix.get(1, j) = max;\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix min() const {\n\t\tif (rows == 1) {\n\t\t\treturn transpose().min();\n\t\t}\n\t\tMatrix matrix(1, columns);\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tT min = get(1, j);\n\t\t\tfor (int i = 2; i <= rows; ++ i) {\n\t\t\t\tconst T & value = get(i, j);\n\t\t\t\tif (min > value) min = value;\n\t\t\t}\n\t\t\tmatrix.get(1, j) = min;\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tMatrix sum() const {\n\t\tif (rows == 1) {\n\t\t\treturn transpose().sum();\n\t\t}\n\t\tMatrix matrix(1, columns);\n\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\tT sum = 0;\n\t\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\t\tsum += get(i, j);\n\t\t\t}\n\t\t\tmatrix.get(1, j) = sum;\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n};",
            "",
            1590112800,
            1590670800
        ],
        [
            "7.1 (C++)",
            "Design a class named Triangle that extends class GeometricObject,\nwhich is given below. \nThe class contains:\n<ol>\n<li>Three double data field named side1, side2, and side3 with default values 1.0 to denote three sides of the triangle.</li>\n<li>A no-arg constructor that creates a default triangle (side1=side2=side3=1.0).</li>\n<li>A constructor that creates a triangle with the specified side1, side2, and side3.</li>\n<li>The accessor functions for all three data fields.</li>\n<li>A function named getArea() that returns the area of this triangle.</li>\n<li>A function named getPerimeter() that returns the perimeter of the triangle.</li>\n</ol>\nHint:\nFor an triangle with sides of lengths a, b, and c, respectively:<br>\ns = (a + b + c) / 2;<br>\narea = sqrt(s * (s - a) * (s - b) * (s - c));<br>\n<br>\n<u>EXMAPLE INPUT:</u>\n<pre>1 1.5 1 yellow</pre>\n\n<u>EXMAPLE OUTPUT:</u>\n<pre>triangle.getColor() = yellow\ntriangle.getSide1() = 1\ntriangle.getSide2() = 1.5\ntriangle.getSide3() = 1\ntriangle.getArea() = 0.496078\ntriangle.getPerimeter() = 3.5</pre>",
            "#include <string>\nusing namespace std;\n\nclass GeometricObject\n{\nprivate:\n\tstring color;\n\t\npublic:\n\tGeometricObject() {\n\t\tcolor = \"black\";\n\t}\n\t\n\tstring getColor() {\n\t\treturn color;\n\t}\n\t\n\tvoid setColor(string color2) {\n\t\tcolor = color2;\n\t}\n\t\n\tstring toString() {\n\t\treturn \"GeometricObject color=\" + color;\n\t}\n\t\n};\n\n#include \"source.cpp\"\n\n#include <iostream>\n\nint main() {\n\tdouble side1;\n\tdouble side2;\n\tdouble side3;\n\tcin >> side1;\n\tcin >> side2;\n\tcin >> side3;\n\t\n\tstring color;\n\tcin >> color;\n\t\n\tTriangle triangle(side1, side2, side3);\n\ttriangle.setColor(color);\n\t\n\tcout << \"triangle.getColor() = \" << triangle.getColor() << endl;\n\tcout << \"triangle.getSide1() = \" << triangle.getSide1() << endl;\n\tcout << \"triangle.getSide2() = \" << triangle.getSide2() << endl;\n\tcout << \"triangle.getSide3() = \" << triangle.getSide3() << endl;\n\tcout << \"triangle.getArea() = \" << triangle.getArea() << endl;\n\tcout << \"triangle.getPerimeter() = \" << triangle.getPerimeter() << endl;\n\t\n}",
            "#include <cmath>\n\nclass Triangle : public GeometricObject\n{\nprivate:\n\tdouble side1;\n\tdouble side2;\n\tdouble side3;\n\t\npublic:\n\tTriangle() {\n\t\tside1 = 1.0;\n\t\tside2 = 1.0;\n\t\tside3 = 1.0;\n\t}\n\t\n\tTriangle(double side1, double side2, double side3) {\n\t\tTriangle::side1 = side1;\n\t\tTriangle::side2 = side2;\n\t\tTriangle::side3 = side3;\n\t}\n\t\n\tdouble getSide1() {\n\t\treturn side1;\n\t}\n\t\n\tdouble getSide2() {\n\t\treturn side2;\n\t}\n\t\n\tdouble getSide3() {\n\t\treturn side3;\n\t}\n\t\n\tdouble getArea() {\n\t\tdouble s = (side1 + side2 + side3) / 2;\n\t\tdouble area = sqrt(s * (s - side1) * (s - side2) * (s - side3));\n\t\treturn area;\n\t}\n\t\n\tdouble getPerimeter() {\n\t\treturn side1 + side2 + side3;\n\t}\n\t\n};",
            "from random import randint\na = randint(30,99)\nb = randint(30,99)\nc = randint(abs(a-b)+1,a+b-1)\ncolor = ['red','green','blue','yellow','black','orange','black','white','pink','purple']\nprint(a/10,b/10,c/10,color[randint(0,len(color)-1)])",
            1590717600,
            1591275600
        ],
        [
            "7.2 (C++)",
            "完成split函数<br>\n\n<b>EXAMPLE INPUT<B>\n<pre>\n123   abcde   567     \n   ds   tete dfsd   567   \n  asd  te sdfs   567\n</pre>\n\n<b>EXAMPLE OUTPUT</b>\n<pre>\n123\nabcde\n567\nds\ntete\ndfsd\n567\nasd\nte\nsdfs\n567\n</pre>",
            "#include \"source.cpp\"\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nvoid test() {\n\tstring line;\n\tgetline(cin, line);\n\tvector<string> words = split(line);\n\tfor (int i = 0; i < words.size(); ++ i) {\n\t\tcout << words[i] << endl;\n\t}\n}\n\nint main() {\n\ttest();\n\ttest();\n\ttest();\n}",
            "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nvector<string> split(const string & line) {\n\tvector<string> words;\n\tstring word;\n\tfor (int i = 0; i < line.size(); ++ i) {\n\t\tchar c = line[i];\n\t\tif (c == ' ') {\n\t\t\tif (word.size() != 0) {\n\t\t\t\twords.push_back(word);\n\t\t\t\tword = \"\";\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tword += c;\n\t\t}\n\t}\n\tif (word.size() > 0) {\n\t\twords.push_back(word);\n\t}\n\treturn words;\n}",
            "from random import randint\n\ndef random_str(k):\n\tchars = 'abcdefghijklmnopqrstuvwxyz'.upper()\n\ttext = ''\n\tfor i in range(k):\n\t\ttext += chars[randint(0,len(chars)-1)]\n\treturn text\n\ndef random_int(k):\n\tval = randint(1,9)\n\tfor i in range(k-1):\n\t\tval = val * 10 + randint(0,9)\n\treturn val\n\nfor i in range(3):\n\tfor j in range(randint(3,6)):\n\t\tk = randint(0,1)\n\t\tif k == 0:\n\t\t\tprint(random_str(randint(3,9)), end=' ')\n\t\telse:\n\t\t\tprint(random_int(randint(3,6)), end=' ')\n\tprint()\n",
            1591236000,
            1591242000
        ],
        [
            "8.1 (C++)",
            "Design a class Full that implements interface Matrix:\nFull should has the following public object functions in addition:\n<ol>\n<li>A constructor Full(int rows, int column), which initializes all elements in the matrix to 0's.</li>\n<li>A constructor Full(int rows, int column, double values[]), which initializes all elements in the matrix to the given values. Note that the given values are in one-dimensional, you need to fill then into the two-dimensional matrix correctly.</li>\n<li>A constructor Full(const Matrix &amp; matrix2).</li>\n<li>A destructor.</li>\n<li>A print function which prints each row of elements in a single line, with each element preceded with 4 spaces.</li>\n</ol>\n\n<b><u>HINT</u></b><br>\n本题涉及 pure virtual function, abstract class 和 interface 的内容。<br>\n<ol>\n<li>The function <u>int size(int)</u> function return the 2-dimensional size of the matrix: it returns the size in the first dimension (the number of rows) if the argument is 1, and returns size in the second dimension (the number of column) if the argument is 2.</li>\n<li>The class <u>Full</u> that you will define must <i>implement</i> the interface class <i>Matrix</i>, which means that it need to <i>override</i> the <u>operator =</u> as it is in <i>Matrix</i>, along with all other pure virtual object functions in <i>Matrix</i>.</li>\n<li>Don't forget to provide the constructor <i>Full(const Matrix &amp; matrix2)</i> in our class.</li>\n</ol>\n\n<u><b>EXAMPLE INPUT</b></u>\n<pre>4 4\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16</pre>\n\n<u><b>EXAMPLE OUTPUT</b></u>\n<pre>constructor 1\n    0    0    0\n    0    0    0\n    0    0    0\nconstructor 2\n    1    2    3    4\n    5    6    7    8\n    9    10    11    12\n    13    14    15    16\nconstructor 3\n    1    2    3    4\n    5    6    7    8\n    9    10    11    12\n    13    14    15    16\noperator =\n    1    2    3    4\n    5    6    7    8\n    9    10    11    12\n    13    14    15    16\n</pre>",
            "#include <iostream>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nclass Matrix\n{\t\npublic:\n\t\n\tvirtual int size(int dimension) const = 0;\n\t\n\tvirtual void set(int row, int column, double value) = 0;\n\t\n\tvirtual double get(int row, int column) const = 0;\n\t\n\tvirtual void print() const = 0;\n\t\n\tvirtual Matrix & operator = (const Matrix & matrix2) = 0;\n};\n\n#include \"source.cpp\"\n\nFull readMatrix() {\n\tint rows;\n\tint columns;\n\tdouble values[1000];\n\tcin >> rows >> columns;\n\tfor (int i = 0; i < rows * columns; ++ i) {\n\t\tcin >> values[i];\n\t}\n\tFull matrix(rows, columns, values);\n\treturn matrix;\n}\n\nvoid printMatrix(const Matrix & matrix) {\n\tmatrix.print();\n}\n\nint main() {\n\tcout << \"constructor 1\" << endl;\n\tFull full1(3, 3);\n\tMatrix & matrix1 = full1; // down-casting\n\tmatrix1.print();\n\t\n\tcout << \"constructor 2\" << endl;\n\tconst Matrix & matrix2 = readMatrix();\n\tmatrix2.print();\n\t\n\tcout << \"constructor 3\" << endl;\n\tFull full3 = matrix2;\n\tMatrix & matrix3 = full3;\n\tprintMatrix(matrix3);\n\t\n\tcout << \"operator =\" << endl;\n\tmatrix3.set(1, 1, 10.0);\n\tmatrix3 = matrix2;\n\tmatrix3.print();\n}",
            "class Full : public Matrix\n{\n\t\nprivate:\n\t\n\tint rows;\n\tint columns;\n\tdouble * values;\n\t\npublic:\n\t\n\tint size(int dimension) const {\n\t\tswitch (dimension) {\n\t\t\tcase 1: return rows;\n\t\t\tcase 2: return columns;\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tvoid set(int row, int column, double value) {\n\t\t-- row;\n\t\t-- column;\n\t\tvalues[row * columns + column] = value;\n\t}\n\t\n\tdouble get(int row, int column) const {\n\t\t-- row;\n\t\t-- column;\n\t\treturn values[row * columns + column];\n\t}\n\t\nprivate:\n\t\n\tvoid assign0(int rows, int columns) {\n\t\t(*this).rows = rows;\n\t\t(*this).columns = columns;\n\t\t(*this).values = new double[rows * columns];\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tset(i, j, 0.0);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid assign0(int rows, int columns, const double values[]) {\n\t\t(*this).rows = rows;\n\t\t(*this).columns = columns;\n\t\t(*this).values = new double[rows * columns];\n\t\tint count = 0;\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tset(i, j, values[count]);\n\t\t\t\t++ count;\n\t\t\t}\n\t\t}\n\t}\n\t\npublic:\n\t\n\tFull(int rows, int columns) {\n\t\tassign0(rows, columns);\n\t}\n\t\n\tFull(int rows, int columns, const double values[]) {\n\t\tassign0(rows, columns, values);\n\t}\n\t\n\tFull(const Matrix & matrix2) {\n\t\tFull & full2 = (Full &)matrix2;\n\t\tassign0(full2.rows, full2.columns, full2.values);\n\t}\n\t\n\t~Full() {\n\t\tdelete [] values;\n\t}\n\t\n\tvoid print() const {\n\t\tfor (int i = 1; i <= rows; ++ i) {\n\t\t\tfor (int j = 1; j <= columns; ++ j) {\n\t\t\t\tcout << \"    \" << get(i, j);\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\t\n\tMatrix & operator = (const Matrix & matrix2) {\n\t\tdelete [] values;\n\t\tFull & full2 = (Full &)matrix2;\n\t\tassign0(full2.rows, full2.columns, full2.values);\n\t\treturn (*this);\n\t}\n\t\n};",
            "from random import randint\nr = randint(3,6)\nc = randint(3,6)\nprint(r, c)\nfor i in range(r*c):\n\tprint(randint(1,99), end=' ')",
            1591322400,
            1591880400
        ],
        [
            "8.2 (C++)",
            "Design a class Sparse that implements interface Matrix:\nSparse should has the following public object functions in addition:\n<ol>\n<li>A constructor Sparse(int rows, int column), which initializes all elements in the matrix to 0's.</li>\n<li>A copy constructor Sparse(Matrix & matrix2).</li>\n<li>A destructor.</li>\n<li>A print function which prints each entry of non-zero element in a single line. Only the triples for the non-zero elements are printed. The triples are ordered first by their row indexes, then by their column indexes.</li>\n</ol>\n\n<b>Hint:</b>\n<ol>\n<li>A sparse matrix is a matrix where most elements are 0's. To represent a sparse matrix efficiently, we only need to store its non-zero elements. Each non-zero element is store with a 3-tuple (row, col, value), where <i>row</i> and  <i>col</i> are the row-number and column-number of the element, and <i>value</i> is the value of the element. The class <i>Entry</i> below is the class for this 3-tuple.</li>\n<li>An <i>iterator</i> is a class to visit all of the elements in a container. In this exercise, you need to implement an iterator to inspect all non-zero elements in your <i>Sparse</i> matrix. For more about iterator, please refer to my <a href=\"http://cse.sysu.edu.cn/file/test2/file?filename=Ref03.CppLiu.zip&saveas=Ref03.CppLiu.zip\">lecture note</a> (lectureNote6-8.pdf).</li>\n</ol>\n\n<u>EXAMPLE INPUT</u>\n<pre>1000000 1000000\n1 1 10\n1000000 1000000 20\n1 1000000 30\n1000000 1 40</pre>\n\n<u>EXAMPLE OUTPUT</u>\n<pre>(1,1,10)\n(1000000,1000000,20)\n\n(1,1,10)\n(1000000,1000000,20)\n\n(1,1,10)\n(1,1000000,30)\n(1000000,1,40)\n(1000000,1000000,20)\n\n(1,1,10)\n(1,1000000,30)\n(1000000,1,40)\n(1000000,1000000,20)</pre>",
            "class Entry\n{\npublic:\n\tint row;\n\tint column;\n\tdouble value;\n};\n\t\nclass Iterator\n{\npublic:\n\tvirtual bool hasNext() const = 0;\n\tvirtual const Entry & next() = 0;\n};\n\t\nclass Matrix\n{\npublic:\n\t\n\tvirtual Iterator * iterator() const  = 0; //增加了const\n\t\n\tvirtual int size(int dimension) const = 0;\n\t\n\tvirtual void set(int row, int column, double value) = 0;\n\t\n\tvirtual double get(int row, int column) const = 0;\n\t\n\tvirtual void print() = 0;\n\t\n\tvirtual Matrix & operator = (const Matrix & matrix2) = 0;\n};\n\n#include \"source.cpp\"\n\n#include <iostream>\nusing namespace std;\n\nvoid printMatrix(Matrix & matrix) {\n\tmatrix.print();\n}\n\n// 新增\nvoid printMatrix2(const Matrix & matrix) {\n\tIterator * it = matrix.iterator();\n\twhile (it->hasNext()) {\n\t\tEntry entry = it->next();\n\t\tcout << \"(\" << entry.row << \",\" << entry.column <<\n\t\t\t\",\" << entry.value << \")\" << endl;\n\t}\n\tdelete it;\n}\n\nint main() {\n\tint rows;\n\tint columns;\n\tcin >> rows >> columns;\n\t\n\tint row1;\n\tint column1;\n\tdouble value1;\n\tcin >> row1 >> column1 >> value1;\n\t\n\tint row2;\n\tint column2;\n\tdouble value2;\n\tcin >> row2 >> column2 >> value2;\n\t\n\tint row3;\n\tint column3;\n\tdouble value3;\n\tcin >> row3 >> column3 >> value3;\n\t\n\tint row4;\n\tint column4;\n\tdouble value4;\n\tcin >> row4 >> column4 >> value4;\n\t\n\t\n\tSparse sparse1(rows, columns);\n\tMatrix & matrix1 = sparse1;\n\tmatrix1.set(row1, column1, value1);\n\tmatrix1.set(row2, column2, value2);\n\tmatrix1.print();\n\tcout << endl;\n\t\n\tSparse sparse2(sparse1);\n\tMatrix & matrix2 = sparse2;\n\tmatrix2.print();\n\tcout << endl;\n\t\n\tmatrix2.set(row3, column3, value3);\n\tmatrix2.set(row4, column4, value4);\n\tmatrix1 = matrix2;\n\tmatrix1.print();\n\tcout << endl;\n\t\n\t// 新增\n\tprintMatrix2(matrix1);\n\t\n}",
            "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Sparse : public Matrix\n{\t\nprivate:\n\t\n\tint rows;\n\tint columns;\n\tvector<Entry> entries;\n\t\n\tint find0(int row, int column) const {\n\t\tfor (int i = 0; i < entries.size(); ++ i) {\n\t\t\tEntry entry = entries[i];\n\t\t\tif (entry.row == row && entry.column == column) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tvoid remove0(int index) {\n\t\tfor (int i = index; i < entries.size() - 1; ++ i) {\n\t\t\tentries[i] = entries[i + 1];\n\t\t}\n\t\tentries.pop_back();\n\t}\n\t\n\tvoid insert0(int row, int column, double value) {\n\t\tint size = entries.size();\n\t\t// find a position to insert the entry\n\t\tint index = 0;\n\t\tfor (; index < size; ++ index) {\n\t\t\tEntry entry = entries[index];\n\t\t\tif (entry.row > row) break;\n\t\t\tif (entry.row == row && entry.column > column) break;\n\t\t}\n\t\t// increase the size of the entry vector\n\t\tEntry entry;\n\t\tentries.push_back(entry);\n\t\t// for all entries behide the insertion position, move 1 position\n\t\tfor (int i = size - 1; i >= index; -- i) {\n\t\t\tentries[i + 1] = entries[i];\n\t\t}\n\t\t// set the inserted entry\n\t\tentry.row = row;\n\t\tentry.column = column;\n\t\tentry.value = value;\n\t\tentries[index] = entry;\n\t}\n\t\n\tvoid set0(int index, double value) {\n\t\tEntry & entry = entries[index];\n\t\tentry.value = value;\n\t}\n\t\nprivate:\n\n\tclass Iterator1 : public Iterator\n\t{\n\tprivate:\n\t\tconst Sparse * sparse;\n\t\tint index;\n\t\t\n\tpublic:\n\t\tIterator1(const Sparse * sparse2) {\n\t\t\tsparse = sparse2;\n\t\t\tindex = 0;\n\t\t}\n\t\t\n\t\tbool hasNext() const {\n\t\t\treturn index < (*sparse).entries.size();\n\t\t}\n\t\t\n\t\tconst Entry & next() {\n\t\t\tconst Entry & entry = (*sparse).entries[index];\n\t\t\t++ index;\n\t\t\treturn entry;\n\t\t}\n\t\t\n\t};\n\t\npublic:\n\n\tIterator * iterator() const {\n\t\treturn new Iterator1(this);\n\t}\n\npublic:\n\n\tint size(int dimension) const {\n\t\tswitch (dimension) {\n\t\t\tcase 1: return rows;\n\t\t\tcase 2: return columns;\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tvoid set(int row, int column, double value) {\n\t\tint index = find0(row, column);\n\t\tif (index == -1) { // such element is 0\n\t\t\tif (value != 0) {\n\t\t\t\tinsert0(row, column, value);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (value == 0) {\n\t\t\t\tremove0(index);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tset0(index, value);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdouble get(int row, int column) const {\n\t\tint index = find0(row, column);\n\t\tif (index == -1) { // such element is 0\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\treturn entries[index].value;\n\t\t}\n\t}\n\t\nprivate:\n\t\n\tvoid assign0(int rows, int columns) {\n\t\t(*this).rows = rows;\n\t\t(*this).columns = columns;\n\t\t(*this).entries.clear();\n\t}\n\t\n\tvoid assign0(const Matrix & matrix2) {\n\t\trows = matrix2.size(1);\n\t\tcolumns = matrix2.size(2);\n\t\tentries.clear();\n\t\tIterator * it = matrix2.iterator();\n\t\twhile ((*it).hasNext()) {\n\t\t\tEntry entry = (*it).next();\n\t\t\tentries.push_back(entry);\n\t\t}\n\t\tdelete it;\n\t}\n\t\npublic:\n\t\n\tSparse(int rows, int columns) {\n\t\tassign0(rows, columns);\n\t}\n\t\n\tSparse(const Matrix & matrix2) {\n\t\tassign0(matrix2);\n\t}\n\t\n\tvoid print() {\n\t\tIterator * it = iterator();\n\t\twhile ((*it).hasNext()) {\n\t\t\tEntry entry = (*it).next();\n\t\t\tcout << \"(\" << entry.row << \",\" <<\n\t\t\t\tentry.column << \",\" <<\n\t\t\t\tentry.value << \")\" << endl;\n\t\t}\n\t\tdelete it;\n\t}\n\t\n\tMatrix & operator = (const Matrix & matrix2) {\n\t\tassign0(matrix2);\n\t\treturn (*this);\n\t}\n\t\n};",
            "from random import randint\nr = randint(10000,90000)\nc = randint(10000,90000)\nprint(r,c)\nfor i in range(4):\n\tr1 = randint(1,r)\n\tc1 = randint(1,c)\n\tv = randint(1,999)/100\n\tprint(r1,c1,v)\n",
            1591322400,
            1589202000
        ],
        [
            "8.3 (C++)",
            "Design a class Sparse that implements interface Matrix:\nSparse should has the following public object functions in addition:\n<ol>\n<li>A constructor Sparse(int rows, int column), which initializes all elements in the matrix to 0's.</li>\n<li>A function Sparse Sparse::operator + (Sparse & sparse2), which returns the pair-wise sum of two sparse matrixes.</li>\n</ol>\n\n<b><u>HINT</u></b><br>\n稀疏矩阵是大多数元素都为0的矩阵。<br>\n因此，存储稀疏矩阵的时候只存储不为0的元素可以节省空间。<br>\n例如，完整地存储一个1000000x1000000的浮点数矩阵需要8TB的内存。<br>\n但是，如果矩阵只有10个非0元素，那么我们只需记录这10个元素在矩阵中的位置和值。<br>\n要记录这10个元素中的每一个，我们可以使用一个3元组(行,列,值)，这个3元组的类<i>Entry</i>已经在主程序定义好。<br>\n要记录这10个元素，我们可以用一个<i>vector&lt;Entry&gt;</i>存储10个<i>Entry</i>的对象。<br>\n要获得这10个非0元素的值，只需查找这个<i>vector</i>。<br>\n位置(行,列)不在这个<i>vector</i>中的元素，就是值为0的元素。<br>\n题目中要求实现的<i>print</i>函数，只输出非0元素(的3元组表示)。顺序为小行优先，同行则小列优先。<br>\n<br>\n\n<u>EXAMPLE INPUT</u>\n<pre>1000000 1000000\n\n1 1 10\n1 1000000 50\n1000000 1000000 20\n\n1 1000000 30\n1000000 1 40\n1 1 -10</pre>\n\n<u>EXAMPLE OUTPUT</u>\n<pre>(1,1000000,80)\n(1000000,1,40)\n(1000000,1000000,20)</pre>",
            "class Entry\n{\npublic:\n\tint row;\n\tint column;\n\tdouble value;\n};\n\t\nclass Matrix\n{\t\npublic:\n\tvirtual int size(int dimension) const = 0;\n\t\n\tvirtual void set(int row, int column, \n\tdouble value) = 0;\n\t\n\tvirtual double get(int row, int column) \n\tconst = 0;\n\t\n\tvirtual void print() = 0;\n\t\n};\n\n#include \"source.cpp\"\n\n#include <iostream>\nusing namespace std;\n\nvoid print(Matrix & matrix) {\n\tmatrix.print();\n}\n\nvoid readAndSetElement(Matrix & matrix) {\n\tint row;\n\tint column;\n\tdouble value;\n\tcin >> row >> column >> value;\n\tmatrix.set(row, column, value);\n}\n\nvoid readAndSetMultipleElements(Matrix & matrix, int count) {\n\tfor (int i = 0; i < count; ++ i) {\n\t\treadAndSetElement(matrix);\n\t}\n}\n\nint main() {\n\tint rows;\n\tint columns;\n\tcin >> rows >> columns;\n\t\n\tSparse sparse1(rows, columns);\n\treadAndSetMultipleElements(sparse1, 3);\n\t\n\tSparse sparse2(rows, columns);\n\treadAndSetMultipleElements(sparse2, 3);\n\t\n\tSparse sparse3 = sparse1 + sparse2;\n\tprint(sparse3);\n}",
            "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Sparse : public Matrix\n{\t\nprivate:\n\t\n\tint rows;\n\tint columns;\n\tvector<Entry> entries;\n\t\n\tint find0(int row, int column) const {\n\t\tfor (int i = 0; i < entries.size(); ++ i) {\n\t\t\tEntry entry = entries[i];\n\t\t\tif (entry.row == row && entry.column == column) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tvoid remove0(int index) {\n\t\tfor (int i = index; i < entries.size() - 1; ++ i) {\n\t\t\tentries[i] = entries[i + 1];\n\t\t}\n\t\tentries.pop_back();\n\t}\n\t\n\tvoid insert0(int row, int column, double value) {\n\t\tint size = entries.size();\n\t\t// find a position to insert the entry\n\t\tint index = 0;\n\t\tfor (; index < size; ++ index) {\n\t\t\tEntry entry = entries[index];\n\t\t\tif (entry.row > row) break;\n\t\t\tif (entry.row == row && entry.column > column) break;\n\t\t}\n\t\t// increase the size of the entry vector\n\t\tEntry entry;\n\t\tentries.push_back(entry);\n\t\t// for all entries behide the insertion position, move 1 position\n\t\tfor (int i = size - 1; i >= index; -- i) {\n\t\t\tentries[i + 1] = entries[i];\n\t\t}\n\t\t// set the inserted entry\n\t\tentry.row = row;\n\t\tentry.column = column;\n\t\tentry.value = value;\n\t\tentries[index] = entry;\n\t}\n\t\n\tvoid set0(int index, double value) {\n\t\tEntry & entry = entries[index];\n\t\tentry.value = value;\n\t}\n\t\npublic:\n\n\tint size(int dimension) const {\n\t\tswitch (dimension) {\n\t\t\tcase 1: return rows;\n\t\t\tcase 2: return columns;\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tvoid set(int row, int column, double value) {\n\t\tint index = find0(row, column);\n\t\tif (index == -1) { // such element is 0\n\t\t\tif (value != 0) {\n\t\t\t\tinsert0(row, column, value);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (value == 0) {\n\t\t\t\tremove0(index);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tset0(index, value);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdouble get(int row, int column) const {\n\t\tint index = find0(row, column);\n\t\tif (index == -1) { // such element is 0\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\treturn entries[index].value;\n\t\t}\n\t}\n\t\npublic:\n\t\n\tSparse(int rows, int columns) {\n\t\t(*this).rows = rows;\n\t\t(*this).columns = columns;\n\t\t(*this).entries.clear();\n\t}\n\t\n\tvoid print() {\n\t\tfor (int i = 0; i < entries.size(); ++ i) {\n\t\t\tEntry entry = entries[i];\n\t\t\tcout << \"(\" << entry.row << \",\" <<\n\t\t\t\tentry.column << \",\" <<\n\t\t\t\tentry.value << \")\" << endl;\n\t\t}\n\t}\n\t\n\tSparse operator + (Sparse & sparse2) {\n\t\tSparse sparse3(*this);\n\t\tfor (int i = 0; i < sparse2.entries.size(); ++ i) {\n\t\t\tEntry entry = sparse2.entries[i];\n\t\t\tdouble value = get(entry.row, entry.column);\n\t\t\tvalue += entry.value;\n\t\t\tsparse3.set(entry.row, entry.column, value);\n\t\t}\n\t\treturn sparse3;\n\t}\n\t\n};",
            "from random import randint\nr = randint(10000,20000)\nc = randint(10000,20000)\nprint(r,c)\n\nprint()\nr2 = randint(1,r)\nc2 = randint(1,c)\nfor i in range(3):\n\tif i == 1:\n\t\tr1 = r2\n\t\tc1 = c2\n\telse:\n\t\tr1 = randint(1,r)\n\t\tc1 = randint(1,c)\n\tv = randint(1,999)/100\n\tprint(r1,c1,v)\n\nprint()\nfor i in range(3):\n\tif i != 0:\n\t\tif i == 1:\n\t\t\tr1 = r2\n\t\t\tc1 = c2\n\t\telse:\n\t\t\tr1 = randint(1,r)\n\t\t\tc1 = randint(1,c)\n\t\tv = randint(1,999)/100\n\telse:\n\t\tv = -v\t\t\n\tprint(r1,c1,v)",
            1591322400,
            1591880400
        ],
        [
            "8.4 (C++)",
            "Design a class Sparse that implements interface Matrix:\nSparse should has the following public object functions in addition:\n<ol>\n<li>A constructor Sparse(int rows, int column), which initializes all elements in the matrix to 0's.</li>\n<li>A function Sparse Sparse::operator * (Sparse & sparse2), which returns the product of two sparse matrixes.</li>\n</ol>\n\n<u>EXAMPLE INPUT</u>\n<pre>1000000 2000000 3000000\n\n1 1 10\n1 2000000 50\n1000000 2000000 20\n\n1 3000000 30\n2000000 1 40\n1 1 -10</pre>\n\n<u>EXAMPLE OUTPUT</u>\n<pre>(1,1,1900)\n(1,3000000,300)\n(1000000,1,800)</pre>",
            "class Entry\n{\npublic:\n\tint row;\n\tint column;\n\tdouble value;\n};\n\t\nclass Matrix\n{\t\npublic:\n\tvirtual int size(int dimension) const = 0;\n\t\n\tvirtual void set(int row, int column, \n\tdouble value) = 0;\n\t\n\tvirtual double get(int row, int column) \n\tconst = 0;\n\t\n\tvirtual void print() = 0;\n\t\n};\n\n#include \"source.cpp\"\n\n#include <iostream>\nusing namespace std;\n\nvoid print(Matrix & matrix) {\n\tmatrix.print();\n}\n\nvoid readAndSetElement(Matrix & matrix) {\n\tint row;\n\tint column;\n\tdouble value;\n\tcin >> row >> column >> value;\n\tmatrix.set(row, column, value);\n}\n\nvoid readAndSetMultipleElements(Matrix & matrix, int count) {\n\tfor (int i = 0; i < count; ++ i) {\n\t\treadAndSetElement(matrix);\n\t}\n}\n\nint main() {\n\tint rows;\n\tint columns;\n\tint & rows2 = columns;\n\tint columns2;\n\t\n\tcin >> rows >> columns >> columns2;\n\t\n\tSparse sparse1(rows, columns);\n\treadAndSetMultipleElements(sparse1, 3);\n\t\n\tSparse sparse2(rows2, columns2);\n\treadAndSetMultipleElements(sparse2, 3);\n\n\tSparse sparse3 = sparse1 * sparse2;\n\tprint(sparse3);\n}",
            "#include <iostream> \n#include <vector> \nusing namespace std; \n\t\n///////////////////////// \n// class Comparator & Sorter \n// \n\ntemplate <typename T> \nclass Comparator \n{ \npublic:\n\t/*\n\tReturns 0 if equal, -1 if obj1 < obj2, and 1 othewise.\n\t*/\n\tvirtual int compare(const T & obj1, const T & obj2) const = 0; \n}; \n\ntemplate <typename E> \nclass Sorter \n{ \npublic: \n\n\t/*\n\tFind the index of the largest element among the first 'len'-th elements in \n\tthe container.\n\t*/\n\tint findMaxIndex(const vector<E> & container, int len, \n\t\t\t\t\tconst Comparator<E> & cmp) {\n\t\tint indexOfMax = 0; \n\t\tfor (int i = 1; i < len; ++ i) { \n\t\t\tif (cmp.compare(container[indexOfMax], container[i]) == -1) { \n\t\t\t\tindexOfMax = i; \n\t\t\t} \n\t\t} \n\t\treturn indexOfMax; \n\t} \n\t \n\t/*\n\tSwap elements in the given positions.\n\t*/\n\tvoid swap(vector<E> & container, int index1, int index2) { \n\t\tE tuple1 = container[index1]; \n\t\tE tuple2 = container[index2]; \n\t\tcontainer[index1] = tuple2; \n\t\tcontainer[index2] = tuple1; \n\t} \n\n\t/*\n\tSort the elements in a container with a comparator.\n\t*/\n\tvoid sort(vector<E> & container, const Comparator<E> & cmp) { \n\t\tfor (int len = container.size(); len >= 2; -- len) { \n\t\t\tint index = findMaxIndex(container, len, cmp); \n\t\t\tint last = len - 1; \n\t\t\tif (index == last) continue; \n\t\t\tswap(container, index, last); \n\t\t} \n\t} \n\n}; \n\n///////////////////////// \n// class Sparse \n// \n\nclass Sparse : public Matrix \n{ \n\t/*\n\tYou are not supposed write the following functions.\n\t- The copy constructor: Sparse(const Sparse &)\n\t- The assignment operator: Sparse & operator = (const Sparse &)\n\t- The destructor: ~Sparse()\n\t\n\t* Why?\n\t\n\tBecause C++ will compose them, and the composed ones work just fine\n\tif the class has no member variable of type address.\n\t\n\tOtherwise (class has address member variables), \n\tyou have to write these functions.\n\t\n\t* What about addresses inside the member variables?\n\t\n\tThe will be taken care of automatically. For instance, \n\tin the following program, the copy constructor of 'triples' will \n\tbe called in the composed copy constructor of class Sparse.\n\t\n\tLikewisely, the assignment operator of 'triples' will be called in \n\tthe composed assignment operator of class Sparse; the destructor of \n\t'triples' will be called in the destructor of class Sparse; and the \n\tdefault constructor (if there is on) of 'triples' will be called \n\tin the default constructor of class Sparse.\n\t\n\t*/\n\t\nprivate: \n\tint rows; \n\tint columns; \n\tvector<Entry> triples;\n\t\n\t/*\n\tFor a 2-D matrix element, find the index of its triple representation \n\twithin 'triples'\n\t*/\n\tint findTriple0(int row, int column) const {\n\t\tfor (int i = 0; i < triples.size(); ++ i) { \n\t\t\tif (triples[i].row == row and triples[i].column == column) { \n\t\t\t\treturn i; \n\t\t\t} \n\t\t} \n\t\treturn -1;\n\t}\n\t\n\t/*\n\tAdd a triple representation to 'triples'\n\t*/\n\tvoid addTriple0(int row, int column, double value) {\n\t\tEntry triple;\n\t\ttriple.row = row;\n\t\ttriple.column = column;\n\t\ttriple.value = value;\n\t\tthis->triples.push_back(triple);\n\t}\t\n\t\n\t/*\n\tRemove a triple representation from 'triples'\n\t*/\n\tvoid removeTripleAtIndex0(int index) {\n\t\ttriples[index] = triples[triples.size() - 1];\n\t\ttriples.pop_back();\n\t}\n\npublic: \n\n\t/*\n\tReturn the size of the matrix on the given dimension.\n\t*/\n\tvirtual int size(int dimension) const { \n\t\tswitch (dimension) {\n\t\tcase 1: return this->rows;\n\t\tcase 2: return this->columns;\n\t\t} \n\t} \n\t  \n\t/*\n\tAdd an element into the sparse matrix.\n\tNo need to represent zeros.\n\t*/\n\tvirtual void set(int row, int column, double value) { \n\t\tint index = this->findTriple0(row, column);\n\t\tif (index == -1) {\n\t\t\tif (value != 0) {\n\t\t\t\taddTriple0(row, column, value);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (value != 0) {\n\t\t\t\tthis->triples[index].value = value;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tremoveTripleAtIndex0(index);\n\t\t\t}\n\t\t} \n\t}  \n\t  \n\t/*\n\tGet an element using a 2-D matrix index.\n\t*/\n\tvirtual double get(int row, int column) const { \n\t\tint index = this->findTriple0(row, column);\n\t\treturn (index == -1 ? 0 : this->triples[index].value); \n\t}\n\t\n\t/*\n\tAssignment from an abstract Matrix reference\n\t*/\n\tvirtual Matrix & operator = (const Matrix & matrix2) { \n\t\t(*this) = (Sparse &)matrix2; // calls the composed \n\t\t\t\t\t\t\t\t// 'operator = (const Sparse &)'\n\t\treturn *this;\n\t} \n\t\n\t/*\n\tThe composed assigment operator function looks exactly like:\n\t\n\tvirtual Sparse & operator = (const Sparse & matrix2) { \n\t\tthis->rows = matrix2.rows;\n\t\tthis->columns = matrix2.columns;\n\t\tthis->triples = matrix2.triples;\n\t\treturn *this;\n\t}\n\t*/\n\n\t/*\n\tCreate a sparse matrix with a given size and all zero elements.\n\t*/\n\tSparse(int rows, int columns) { \n\t\tthis->rows = rows; \n\t\tthis->columns = columns; \n\t} \n\t\n\t/*\n\tCreate a sparse matrix by copying an existing matrix.\n\t*/\n\tSparse(const Matrix & matrix2) { \n\t\t(*this) = matrix2;\n\t} \n\t \n\tvirtual void print() { \n\t\tthis->sortTriples(); \n\t\tthis->printAllTriples(); \n\t}\n\t\nprivate: \n\n\t/*\n\tA comparator to be used when sorting triple representations,\n\twhich orders triples first by row-indexes, then by column-indexes.\n\t*/\n\tclass TripleComparator : public Comparator<Entry> \n\t{ \n\tpublic: \n\t\tint compare(const Entry & triple1, const Entry & triple2) const { \n\t\t\tif (triple1.row > triple2.row) return 1; \n\t\t\tif (triple2.row > triple1.row) return -1; \n\t\t\tif (triple1.column > triple2.column) return 1; \n\t\t\tif (triple2.column > triple1.column) return -1; \n\t\t\treturn 0; \n\t\t} \n\t}; \n\n\t/*\n\tSort triple representation of the elements in the matrix,\n\tordered first by row-indexes, then by column-indexes.\n\t*/\n\tvoid sortTriples() { \n\t\tSorter<Entry>().sort(this->triples, TripleComparator()); \n\t} \n\t\n\t/*\n\tPrint all triples.\n\t*/\n\tvoid printAllTriples() const { \n\t\tfor (int i = 0; i < triples.size(); ++ i) {\n\t\t\tthis->printTriple(triples[i]);\n\t\t}\n\t\tcout << endl;\n\t} \n\t \n\t/*\n\tPrint a single triple.\n\t*/\n\tvoid printTriple(const Entry & triple) const { \n\t\tcout << \"(\" << triple.row << \",\" << triple.column << \n\t\t\t\",\" << triple.value << \")\" << endl; \n\t} \n\n/*\npublic: \n\tvirtual Iterator * iterator() const { \n\t\treturn new SparseIterator(this); \n\t}\n\t \n\t/////////////////////////// \n\t// inner class SparseIterator \n\t// \n\n\nprivate: \n\tclass SparseIterator : public Iterator \n\t{ \n\tprivate: \n\t\tconst Sparse * matrix; \n\t\tint count; \n\n\tpublic: \n\t\tSparseIterator(const Sparse * matrix2) { \n\t\t\tmatrix = matrix2; \n\t\t\tcount = 0; \n\t\t} \n\n\t\tvirtual bool hasNext() const { \n\t\t\treturn count < matrix->tuples.size(); \n\t\t} \n\t \n\t\tvirtual const Entry & next() { \n\t\t\treturn matrix->tuples[count ++]; \n\t\t} \n\n\t}; // end of inner class \n\n*/\n\nprivate:\n\t/*\n\tAdd the given value to the value on the given 2-D position.\n\t*/\n\tvoid addToElement0(int row, int column, double value) {\n\t\tdouble original = this->get(row, column);\n\t\tthis->set(row, column, original + value);\n\t}\n\t\npublic:\n\t\n\t/*\n\tReturns the sum of two matrixes.\n\t*/\n\tSparse operator + (const Sparse & sparse2) const {\n\t\tSparse sparse1(*this);\n\t\tfor (int i = 0; i < sparse2.triples.size(); ++ i) {\n\t\t\tEntry triple = sparse2.triples[i];\n\t\t\tsparse1.addToElement0(triple.row, triple.column, triple.value);\n\t\t}\n\t\treturn sparse1;\n\t}\n\t\n\t/*\n\tReturns the product of two matrixes.\n\t*/\t\n\tSparse operator * (const Sparse & sparse2) const {\n\t\tconst Sparse & sparse1 = *this;\n\t\tSparse sparse3(sparse1.rows, sparse2.columns);\n\t\tfor (int i = 0; i < sparse1.triples.size(); ++ i) {\n\t\t\tconst Entry & triple1 = sparse1.triples[i];\n\t\t\tfor (int j = 0; j < sparse2.triples.size(); ++ j) {\n\t\t\t\tconst Entry & triple2 = sparse2.triples[j];\n\t\t\t\t\n\t\t\t\tif (triple1.column != triple2.row) continue;\n\t\t\t\tdouble value = triple1.value * triple2.value;\n\t\t\t\tsparse3.addToElement0(triple1.row, triple2.column, value);\n\t\t\t}\n\t\t}\n\t\treturn sparse3;\n\t}\n\t \n};",
            "from random import randint\nr = randint(10000,20000)\nc = randint(10000,20000)\ncc = randint(10000,20000)\nprint(r,c,cc)\nprint()\nr1 = randint(1,r)\nr2 = randint(1,r)\nc1 = randint(1,c)\nc2 = randint(1,c)\ncc1 = randint(1,cc)\ncc2 = randint(1,cc)\nrc = [(r1,c1), (r1,c2), (r2,c2), (c1,cc1), (c1,cc2), (c2,cc1)]\nfor i,(r3,c3) in enumerate(rc):\n\tv = randint(1,999)/100\n\tif i == 3: print()\n\tprint(r3,c3,v)",
            1591322400,
            1591880400
        ],
        [
            "8.5 (C++)",
            "The Point2D class was created to model a point in a two-dimensional space.<br>\nThe Point2D class has the properties x and y that represent the x and the y coordinates, two getter functions for x and y, and the function for returning the distance between two points.<br>\nCreate a class named Point3D to model a point in a three-dimensional space.\nLet Point3D be derived from Point2D with the following additional features:\n<ol>\n<li>A data field named z that represents the z-coordinate.</li>\n<li>A no-arg constructor that constructs a point with coordinate (0,0,0).</li>\n<li>A constructor that constructs a point with three specified coordinates.</li>\n<li>A getter function that returns the value for the z coordinate.</li>\n<li>Override the distance function to return the distance between two points in \n  the tree dimensional space.</li>\n</ol>\nHint: In order to override a function in a base class, a derived class should define a function with exactly the same signature. A signature of a function includes the function name and the list of its parameter types.<br>\n<br>\n\n<u>EXAMPLE INPUT:</u>\n<pre>1 2 3\n10 20 30</pre>\n \n<u>EXAMPLE OUTPUT:</u>\n<pre>point1.getX() = 1\npoint1.getY() = 2\npoint1.getZ() = 3\npoint2.getX() = 10\npoint2.getY() = 20\npoint2.getZ() = 30\npoint1.distance(point2) = 33.6749</pre>",
            "#include <cmath>\n\nclass Point2D\n{\nprivate:\n\tdouble x;\n\tdouble y;\n\t\npublic:\n\tPoint2D() {\n\t\tx = 0;\n\t\ty = 0;\n\t}\n\t\n\tdouble getX() {\n\t\treturn x;\n\t}\n\t\n\tdouble getY() {\n\t\treturn y;\n\t}\n\t\n\tvoid setX(double x) {\n\t\tthis->x = x;\n\t}\n\t\n\tvoid setY(double y) {\n\t\tthis->y = y;\n\t}\n\t\n\tvirtual double distance(Point2D & point2) {\n\t\tdouble dx = x - point2.x;\n\t\tdouble dy = y - point2.y;\n\t\treturn sqrt(dx * dx + dy * dy);\n\t}\n\t\n};\n\n#include \"source.cpp\"\n\n#include <iostream>\nusing namespace std;\n\nvoid printDistance(Point2D & point1, Point2D & point2) {\n\tcout << \"point1.distance(point2) = \" << \n\t\tpoint1.distance(point2) << endl;\n}\n\nint main() {\n\tdouble x1;\n\tdouble y1;\n\tdouble z1;\n\tdouble x2;\n\tdouble y2;\n\tdouble z2;\n\tcin >> x1;\n\tcin >> y1;\n\tcin >> z1;\n\tcin >> x2;\n\tcin >> y2;\n\tcin >> z2;\n\t\n\tPoint3D point1(x1, y1, z1);\n\tPoint3D point2(x2, y2, z2);\n\t\n\tcout << \"point1.getX() = \" << point1.getX() << endl;\n\tcout << \"point1.getY() = \" << point1.getY() << endl;\n\tcout << \"point1.getZ() = \" << point1.getZ() << endl;\n\tcout << \"point2.getX() = \" << point2.getX() << endl;\n\tcout << \"point2.getY() = \" << point2.getY() << endl;\n\tcout << \"point2.getZ() = \" << point2.getZ() << endl;\n\t\n\tprintDistance(point1, point2);\n}",
            "class Point3D : public Point2D\n{\nprivate:\n\tdouble z;\n\t\npublic:\n\tPoint3D() {\n\t\tsetX(0);\n\t\tsetY(0);\n\t\tz = 0;\n\t}\n\t\n\tPoint3D(double x2, double y2, double z2) {\n\t\tsetX(x2);\n\t\tsetY(y2);\n\t\tz = z2;\n\t}\n\n\tdouble getZ() {\n\t\treturn z;\n\t}\n\n\tvirtual double distance(Point2D & point2) {\n\t\tPoint3D & point = (Point3D &)point2;\n\t\tdouble dx = getX() - point.getX();\n\t\tdouble dy = getY() - point.getY();\n\t\tdouble dz = z - point.z;\n\t\treturn sqrt(dx * dx + dy * dy + dz * dz);\n\t}\n\t\n};",
            "from random import randint\nprint(randint(10,30),randint(10,30),randint(10,30))\nprint(randint(100,300),randint(100,300),randint(100,300))",
            1591840800,
            1591846800
        ],
        [
            "9.1 (C++)",
            "<p>Write a class Circle.\n</p><p>Implement comparison operators (&lt;, &lt;=, ==, !=, &gt;, &gt;=) that compares their radii.\n<br>&nbsp;<b>Example input:\n</b><br>&nbsp;<span style=\"font-family: &quot;Courier New&quot;;\">12.34\n 23.45</span>\n</p><p><br>&nbsp;<b>Example output:\n</b><br><span style=\"font-family: &quot;Courier New&quot;;\">010<br></span><span style=\"font-family: &quot;Courier New&quot;; font-size: 1rem;\">110\n<br>100<br>011<br>101<br></span><span style=\"font-family: &quot;Courier New&quot;; font-size: 1rem;\">001</span></p>",
            "#include \"source.cpp\"\n\n#include <iostream>\nusing namespace std;\n\nint main() {\n\tdouble radius1;\n\tdouble radius2;\n\tcin >> radius1;\n\tcin >> radius2;\n\t\n\tCircle circle1(radius1);\n\tCircle circle2(radius2);\n\t\n\tcout << (circle1 < circle1) << (circle1 < circle2) << (circle2 < circle1) << endl;\n\tcout << (circle1 <= circle1) << (circle1 <= circle2) << (circle2 <= circle1) << endl;\n\tcout << (circle1 == circle1) << (circle1 == circle2) << (circle2 == circle1) << endl;\n\tcout << (circle1 != circle1) << (circle1 != circle2) << (circle2 != circle1) << endl;\n\tcout << (circle1 >= circle1) << (circle1 >= circle2) << (circle2 >= circle1) << endl;\n\tcout << (circle1 > circle1) << (circle1 > circle2) << (circle2 > circle1) << endl;\n\t\n}",
            "class Circle\n{\nprivate:\n\tdouble radius;\n\t\npublic:\n\tCircle(double radius2) {\n\t\tradius = radius2;\n\t}\n\t\n\tbool operator < (Circle & circle) {\n\t\treturn radius < circle.radius;\n\t}\n\t\n\tbool operator <= (Circle & circle) {\n\t\treturn radius <= circle.radius;\n\t}\n\t\n\tbool operator == (Circle & circle) {\n\t\treturn radius == circle.radius;\n\t}\n\t\n\tbool operator != (Circle & circle) {\n\t\treturn radius != circle.radius;\n\t}\n\t\n\tbool operator >= (Circle & circle) {\n\t\treturn radius >= circle.radius;\n\t}\n\t\n\tbool operator > (Circle & circle) {\n\t\treturn radius > circle.radius;\n\t}\n\t\n};",
            "from random import randint\nprint(randint(1000,9999)/100, randint(1000,9999)/100)",
            1592532000,
            1593090000
        ],
        [
            "9.2 (C++)",
            "<p>Please write a class <b>I</b></p><p>Example input:\n<pre>100\n10000\n</pre>\n\nExample output:\n<pre>100\n10000\n</pre></p>",
            "#include <vector>\n#include <iostream>\nusing namespace std;\n\nclass Tensor\n{\n\tvector<int> sizes;\n\tvector<double> values;\n\t\n\tint _index(const vector<int> & indexes) const {\n\t\tint index = 0;\n\t\tfor (int i = 0; i < this->sizes.size(); ++ i) {\n\t\t\tindex *= sizes[i];\n\t\t\tindex += indexes[i];\n\t\t}\n\t\treturn index;\n\t}\n\t\npublic:\n\tint numel() const {\n\t\tif (this->sizes.size() == 0) return 0;\n\t\tint size = 1;\n\t\tfor (int i = 0; i < this->sizes.size(); ++ i) size *= sizes[i];\n\t\treturn size;\n\t}\n\t\n\tTensor(vector<int> sizes) {\n\t\tthis->sizes = sizes;\n\t\tthis->values.resize(this->numel());\n\t\tfor (int i = 0; i < this->numel(); ++ i) this->values[i] = 0;\n\t}\n\t\n\tdouble & get(const vector<int> & indexes) {\n\t\treturn values[this->_index(indexes)];\n\t}\n};\n\n#include \"source.cpp\"\n\nint main() {\n\tI sizes(3,4,5);\n\tTensor t(sizes);\n\tI index(0,0,3);\n\tcin >> t.get(index);\n\tcout << t.get(index) << endl;\n\t\n\tTensor t2(I(2,3,4,5));\n\tcin >> t2.get(I(1,2,3,4));\n\tcout << t2.get(I(1,2,3,4)) << endl;\n}",
            "class I\n{\n\tvector<int> indexes;\npublic:\n\tI(int i1, int i2=-1, int i3=-1, int i4=-1) {\n\t\tindexes.push_back(i1);\n\t\tif (i2 != -1) indexes.push_back(i2);\n\t\tif (i3 != -1) indexes.push_back(i3);\n\t\tif (i4 != -1) indexes.push_back(i4);\n\t}\n\toperator vector<int>() const {\n\t\treturn this->indexes;\n\t}\n};",
            "from random import randint\nprint(randint(1000,9999)/100)\nprint(randint(1000,9999)/100)",
            1592532000,
            1593090000
        ],
        [
            "10.1 (C++)",
            "<h3>In this exercise, you need to know how and when to <u>throw</u> an exception.</h3>\nDesign a class Matrix that throws the following exceptions:\n<ol>\n<li>A out_of_range exception, which is thrown whenever a user access an element in a matrix via an out-of-range row/column index. This exception is thrown by object functions <i>get</i> and <i>set</i>. This exception is defined by C++ in a library file named &lt;stdexcept&gt;</li>\n<li>A MatrixSizesDoNotMatchException is thrown whenever adding two matrixes, whose rows or columns do not equal. You need to define this exception class. This exception is thrown in the object function <i>operator +</i>.</li>\n</ol>\n\n<u>EXAMPLE INPUT</u>\n<pre>2 3\n1 2 3\n4 5 6\n\n1 2\n2 4\n\n2 3\n2 3 4\n3 4 5\n\n2 4\n1 2 3 4\n4 3 2 1</pre>\n\n<u>EXAMPLE OUTPUT</u>\n<pre>value = 2\ncaught: out_of_range\n(2,3)\n 3 5 7\n 7 9 11\ncaught: MatrixSizesDoNotMatchException\n</pre>",
            "#include <vector>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tvector<double> elements;\n\t\npublic:\n\tMatrix(int rows, int columns) {\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tfor (int i = 0; i < rows * columns;  ++ i) {\n\t\t\telements.push_back(0.0);\n\t\t}\n\t}\n\t\n\tint size(int dimension) const {\n\t\tswitch (dimension) {\n\t\tcase 1: return rows;\n\t\tcase 2: return columns;\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tdouble get(int row, int column) const;\n\t\n\tvoid set(int row, int column, double value);\n\t\n\tMatrix operator + (const Matrix & matrix2) const;\n};\n\n#include \"source.cpp\"\n\n#include <iostream>\nusing namespace std;\n\nMatrix read() {\n\tint rows;\n\tint columns;\n\tcin >> rows >> columns;\n\tMatrix matrix(rows, columns);\n\tfor (int i = 0; i < rows; ++ i) {\n\t\tfor (int j = 0; j < columns; ++ j) {\n\t\t\tdouble value;\n\t\t\tcin >> value;\n\t\t\tmatrix.set(i + 1, j + 1, value);\n\t\t}\n\t}\n\treturn matrix;\n}\n\nvoid print(const Matrix & matrix) {\n\tint rows = matrix.size(1);\n\tint columns = matrix.size(2);\n\tcout << \"(\" << rows << \",\" << columns << \")\" << endl;\n\tfor (int i = 0; i < rows; ++ i) {\n\t\tfor (int j = 0; j < columns; ++ j) {\n\t\t\tcout << \" \" << matrix.get(i + 1, j + 1);\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nvoid test1(const Matrix & matrix) {\n\tfor (int i = 0; i < 2; ++ i) {\n\t\tint row;\n\t\tint column;\n\t\tcin >> row >> column;\n\t\ttry {\n\t\t\tdouble value = matrix.get(row, column);\n\t\t\tcout << \"value = \" << value << endl;\n\t\t}\n\t\tcatch (out_of_range & ex) {\n\t\t\tcout << \"caught: out_of_range\" << endl;\n\t\t}\n\t}\n}\n\nvoid test2(const Matrix & matrix) {\n\tfor (int i = 0; i < 2; ++ i) {\n\t\tMatrix matrix2 = read();\n\t\ttry {\n\t\t\tmatrix2 = matrix + matrix2;\n\t\t\tprint(matrix2);\n\t\t}\n\t\tcatch (MatrixSizesDoNotMatchException & ex) {\n\t\t\tcout << \"caught: MatrixSizesDoNotMatchException\" << endl;\n\t\t}\n\t}\n}\n\nint main() {\n\tMatrix matrix = read();\n\ttest1(matrix);\n\ttest2(matrix);\n}",
            "#include <stdexcept>\nusing namespace std;\n\ndouble Matrix::get(int row, int column) const {\n\tif (row <= 0 || row > rows) {\n\t\tthrow out_of_range(\"row\");\n\t}\n\tif (column <= 0 || column > columns) {\n\t\tthrow out_of_range(\"column\");\n\t}\n\tint index = (row - 1) * columns + column - 1;\n\treturn elements[index];\n}\n\nvoid Matrix::set(int row, int column, double value) {\n\tif (row <= 0 || row > rows) {\n\t\tthrow out_of_range(\"row\");\n\t}\n\tif (column <= 0 || column > columns) {\n\t\tthrow out_of_range(\"column\");\n\t}\n\tint index = (row - 1) * columns + column - 1;\n\telements[index] = value;\n}\n\nclass MatrixSizesDoNotMatchException {};\n\nMatrix Matrix::operator + (const Matrix & matrix2) const {\n\tif (rows != matrix2.rows || columns != matrix2.columns) {\n\t\tthrow MatrixSizesDoNotMatchException();\n\t}\n\tMatrix matrix3(rows, columns);\n\tfor (int i = 0; i < rows; ++ i) {\n\t\tfor (int j = 0; j < columns; ++ j) {\n\t\t\tdouble value1 = get(i + 1, j + 1);\n\t\t\tdouble value2 = matrix2.get(i + 1, j + 1);\n\t\t\tmatrix3.set(i + 1, j + 1, value1 + value2);\n\t\t}\n\t}\n\treturn matrix3;\n}",
            "from random import randint\n\ndef print_rand_mat(r,c):\n\tprint(r,c)\n\tfor i in range(r):\n\t\tfor j in range(c):\n\t\t\tprint(randint(1,9), end=' ')\n\t\tprint()\n\t\t\nr = randint(2,6)\nc = randint(2,6)\nprint_rand_mat(r,c)\n\nprint()\nfor i in range(2):\n\tout = randint(0,1)\n\tif out == 0:\n\t\tprint(randint(1,r), randint(1,c))\n\telse:\n\t\tprint(randint(1,9), randint(1,9))\n\t\t\nfor i in range(2):\n\tprint()\n\tout = randint(0,1)\n\tif out == 0:\n\t\tprint_rand_mat(r,c)\n\telse:\n\t\tprint_rand_mat(randint(1,9), randint(1,9))",
            1593309600,
            1593694800
        ],
        [
            "10.2 (C++)",
            "<h3>In this exercise, you need to know how and when to <u>catch</u> an exception.</h3>\nA class Vector is given, which throws the following exceptions:\n<ol>\n<li>A out_of_range exception, which is thrown whenever a user accesses an element in a vector via an out-of-range index. This exception is thrown by object functions <i>get</i> and <i>set</i>. This exception is defined by C++ in a library file named &lt;stdexcept&gt;</li>\n<li>A NonPositiveValueException is thrown whenever a user setting an non-positive element. This exception class is a sub-class of the out_of_range exception class. This exception is thrown in the object function <i>set</i>.</li>\n</ol>\n\nIn this exercise, you need to write some catch-blocks following the try-block in the main function. These catch-block should display the information regarding the exceptions caught, as shown in the example input/output.<br><br>\n\n<u>EXAMPLE INPUT</u>\n<pre>10\n1 2 3 4 5 6 7 8 9 10\n\n3 30\n7 70\n12 120\n5 -10\n8 0</pre>\n\n<u>EXAMPLE OUTPUT</u>\n<pre>1 2 3 30 5 6 7 8 9 10 \n1 2 3 30 5 6 7 70 9 10 \ncaught: out_of_range\ncaught: NonPositiveValueException\ncaught: NonPositiveValueException</pre>",
            "#include <stdexcept>\nusing namespace std;\n\nclass NonPositiveValueException : public out_of_range\n{\npublic:\n\tNonPositiveValueException() : out_of_range(\"non-negative\") {\n\t}\n};\n\nclass Vector\n{\nprivate:\n\tint length;\n\tdouble * elements;\n\t\n\tvoid assign(const Vector & vector) {\n\t\tlength = vector.length;\n\t\telements = new double[length];\n\t\tfor (int i = 0; i < length; ++ i) {\n\t\t\telements[i] = vector.elements[i];\n\t\t}\n\t}\n\t\npublic:\n\tVector(int size) {\n\t\tlength = size;\n\t\telements = new double[size];\n\t}\n\t\n\t~Vector() {\n\t\tdelete [] elements;\n\t}\n\t\n\tVector(const Vector & vector) {\n\t\tassign(vector);\n\t}\n\t\n\tVector & operator = (const Vector & vector) {\n\t\tdelete [] elements;\n\t\tassign(vector);\n\t\treturn *this;\n\t}\n\t\n\tint size() const {\n\t\treturn length;\n\t}\n\t\n\tdouble get(int index) const {\n\t\tif (index < 0 || index >= length) {\n\t\t\tthrow out_of_range(\"index\");\n\t\t}\n\t\treturn elements[index];\n\t}\n\t\n\tvoid set(int index, double value) {\n\t\tif (index < 0 || index >= length) {\n\t\t\tthrow out_of_range(\"index\");\n\t\t}\n\t\tif (value <= 0) {\n\t\t\tthrow NonPositiveValueException();\n\t\t}\n\t\telements[index] = value;\n\t}\n\n};\n\n#include <iostream>\nusing namespace std;\n\nVector read() {\n\tint size;\n\tcin >> size;\n\tVector vector(size);\n\tfor (int i = 0; i < size; ++ i) {\n\t\tdouble value;\n\t\tcin >> value;\n\t\tvector.set(i, value);\n\t}\n\treturn vector;\n}\n\nvoid print(const Vector & vector) {\n\tfor (int i = 0; i < vector.size(); ++ i) {\n\t\tcout << vector.get(i) << \" \";\n\t}\n\tcout << endl;\n}\n\nint main() {\n\tVector vector = read();\n\tfor (int i = 0; i < 5; ++ i) {\n\t\n\t\ttry {\n\t\t\tint index;\n\t\t\tdouble value;\n\t\t\tcin >> index >> value;\n\t\t\tvector.set(index, value);\n\t\t\tprint(vector);\n\t\t}\n#include \"source.cpp\"\n\n\t}\n}",
            "\t\tcatch (NonPositiveValueException & ex) {\n\t\t\tcout << \"caught: NonPositiveValueException\" << endl;\n\t\t}\n\t\tcatch (out_of_range & ex) {\n\t\t\tcout << \"caught: out_of_range\" << endl;\n\t\t}",
            "from random import randint\n\ndef print_rand_vec(r):\n\tprint(r)\n\tfor i in range(r):\n\t\tprint(randint(1,9), end=' ')\n\tprint()\n\t\t\nr = randint(10,20)\nprint_rand_vec(r)\nprint()\n\nfor i in range(5):\n\tout = randint(0,1)\n\tif out == 0:\n\t\tprint(randint(1,r), randint(1,99))\n\telse:\n\t\tprint(randint(1,99), randint(1,99))",
            1593655200,
            1593661200
        ],
        [
            "11.1 (C++)",
            "请写一个简单的 C++ 词法分析器。<br>\n改作业时的实际的保留字和常量的类型不会多于example input中。<br>\n<br>\n<b><u>EXAMPLE INPUT</u><b><br>\n<pre>class Cat {\npublic:\n\tint id;\n\tCat(int id) {\n\t\tthis-&gt;id = id;\n\t}\n\tvoid print() {\n\t\tcout &lt;&lt; id;\n\t}\n};\n\nint main() {\n\tCat cat(123);\n\tcat.print();\n}\n</pre>\n\n<br>\n<b><u>EXAMPLE OUTPUT</u><b><br>\n<pre>class\nCat\n{\npublic\n:\nint\nid\n;\nCat\n(\nint\nid\n)\n{\nthis\n-&gt;\nid\n=\nid\n;\n}\nvoid\nprint\n(\n)\n{\ncout\n&lt;&lt;\nid\n;\n}\n}\n;\nint\nmain\n(\n)\n{\nCat\ncat\n(\n123\n)\n;\ncat\n.\nprint\n(\n)\n;\n}\n</pre></b></b></b></b>",
            "#include \"source.cpp\"\n\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nstring readAll() {\n\tstring all;\n\tstring line;\n\twhile (getline(cin, line))\n\t\tall += line + '\\n';\n\treturn all;\n}\n\nint main() {\n\tstring program = readAll();\n\tvector<string> words = lexicalAnalysis(program);\n\tfor (int i = 0; i < words.size(); ++ i) {\n\t\tcout << words[i] << endl;\n\t}\n}",
            "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint matchSet(const string & program, int index, string set[], int set_count) {\n\tfor (int i = 0; i < set_count; ++ i) {\n\t\tif (program.size() < index + set[i].size()) continue;\n\t\tstring text = program.substr(index, set[i].size());\n\t\t//cout << \"Test: set[i] = \" << set[i] << endl;\n\t\tif (text == set[i]) return set[i].size();\n\t}\n\treturn 0;\n}\n\nstring keywords[] = { \"int\", \"double\", \"char\", \"const\", \"if\", \"else\", \"while\", \"for\", \"return\",\n\t\t\t\t\t\t\"class\", \"public\", \"private\", \"this\", \"static\" };\nint keyword_count = 13;\n\nint matchKeyword(const string & program, int index) {\n\treturn matchSet(program, index, keywords, keyword_count);\n}\n\nint matchNumber(const string & program, int index) {\n\tint len = 0;\n\twhile (index + len < program.size()) {\n\t\tchar c = program[index + len];\n\t\t//cout << \"Test: c = \" << c << endl;\n\t\tif (c >= '0' and c <= '9') ++ len;\n\t\telse break;\n\t}\n\treturn len;\n}\n\nint matchIdentifier(const string & program, int index) {\n\tint len = 0;\n\twhile (index + len < program.size()) {\n\t\tchar c = program[index + len];\n\t\tif (c == '_' or \n\t\t\tc >= 'A' and c <= 'Z' or \n\t\t\tc >= 'a' and c <= 'z' or \n\t\t\tlen > 0 and c >= '0' and c <= '9') ++ len;\n\t\telse break;\n\t}\n\treturn len;\n}\n\nstring symbols[] = { \"!=\", \"!\", \"%=\", \"%\", \"^=\", \"^\", \"&=\", \"&&\", \"&\", \"*=\", \"*\", \"(\", \")\", \n                     \"--\", \"-=\", \"->\", \"-\", \"++\", \"+=\", \"+\", \"==\", \"=\", \"[\", \"{\", \"]\", \"}\",\n                     \"|=\", \"||\", \"|=\", \";\", \"::\", \":\", \".\", \"<<\", \"/=\", \"/\" };\nint symbol_count = 34;\n\nint matchSymbol(const string & program, int index) {\n\treturn matchSet(program, index, symbols, symbol_count);\n}\n\nint matchBlank(const string & program, int index) {\n\tint len = 0;\n\twhile (index + len < program.size()) {\n\t\tchar c = program[index + len];\n\t\tif (c == ' ' or c == '\\t' or c == '\\r' or c == '\\n') ++ len;\n\t\telse break;\n\t}\n\treturn len;\n}\n\nvector<string> lexicalAnalysis(const string & program) {\n\tvector<string> lexicons;\n\tint index = 0;\n\twhile (index < program.size()) {\n\t\tint id_len = matchIdentifier(program, index);\n\t\tint key_len = matchKeyword(program, index);\n\t\tif (id_len > key_len) {\n\t\t\tlexicons.push_back(program.substr(index, id_len));\n\t\t\tindex += id_len;\n\t\t\tcontinue;\n\t\t} \n\t\tif (key_len > 0) {\n\t\t\tlexicons.push_back(program.substr(index, key_len));\n\t\t\tindex += key_len;\n\t\t\tcontinue;\n\t\t}\n\t\tint sym_len = matchSymbol(program, index);\n\t\tif (sym_len > 0) {\n\t\t\tlexicons.push_back(program.substr(index, sym_len));\n\t\t\tindex += sym_len;\n\t\t\tcontinue;\n\t\t}\n\t\tint num_len = matchNumber(program, index);\n\t\tif (num_len > 0) {\n\t\t\tlexicons.push_back(program.substr(index, num_len));\n\t\t\tindex += num_len;\n\t\t\tcontinue;\n\t\t}\n\t\tint blank_len = matchBlank(program, index);\n\t\tif (blank_len > 0) {\n\t\t\t//lexicons.push_back(program.substr(index, blank_len ));\n\t\t\tindex += blank_len ;\n\t\t\tcontinue;\n\t\t}\n\t\tif (id_len == 0 and key_len == 0 and sym_len == 0 and num_len == 0 and blank_len == 0) {\n\t\t\tcout << \"Lexical error at \" << index << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn lexicons;\n}",
            "from random import randint\ntext = '''class {class} {{\npublic:\n\tint {var};\n\t{class}(int id) {{\n\t\tthis->{var} = id;\n\t}}\n\tvoid {func}() {{\n\t\tcout << {var};\n\t}}\n}};\n\nint main() {{\n\t{class} {obj}(123);\n\t{obj}.{func}();\n}}'''\nmm = {'class':['Cat','Fish','Pig','Human','Car','Boat','Bus'],\n\t 'var':['id','age','name','phone','score','grade'],\n\t 'func':['print','calculate','println','show','list','plot'],\n\t 'obj':['obj1','obj2','obj3','obj4','obj5','obj6'],\n\t }\nm = {k:v[randint(0,len(v)-1)] for k,v in mm.items()}\nprint(text.format(**m))",
            1585713600,
            1585713600
        ],
        [
            "11.2 (C++)",
            "请写一个简单的 四则运算 词法分析器。<br>\n<br>\n<b>EXAMPLE INPUT<b><br>\n<pre>1 +2 *\n(46-5)\n</pre>\n\n<br>\n<b>EXAMPLE OUTPUT<b><br>\n<pre>1\n+\n2\n*\n(\n46\n-\n5\n)\n</pre></b></b></b></b>",
            "#include \"source.cpp\"\n\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nstring readAll() {\n\tstring all;\n\tstring line;\n\twhile (getline(cin, line))\n\t\tall += line + '\\n';\n\treturn all;\n}\n\nint main() {\n\tstring program = readAll();\n\tvector<string> words = lexicalAnalysis(program);\n\tfor (int i = 0; i < words.size(); ++ i) {\n\t\tcout << words[i] << endl;\n\t}\n}",
            "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint matchSet(const string & program, int index, string set[], int set_count) {\n\tfor (int i = 0; i < set_count; ++ i) {\n\t\tif (program.size() < index + set[i].size()) continue;\n\t\tstring text = program.substr(index, set[i].size());\n\t\t//cout << \"Test: set[i] = \" << set[i] << endl;\n\t\tif (text == set[i]) return set[i].size();\n\t}\n\treturn 0;\n}\n\n/*\nstring keywords[] = { \"int\", \"double\", \"char\", \"const\", \"if\", \"else\", \"while\", \"for\", \"return\",\n\t\t\t\t\t\t\"class\", \"public\", \"private\", \"this\", \"static\" };\nint keyword_count = 13;\n\nint matchKeyword(const string & program, int index) {\n\treturn matchSet(program, index, keywords, keyword_count);\n}\n*/\n\nint matchNumber(const string & program, int index) {\n\tint len = 0;\n\twhile (index + len < program.size()) {\n\t\tchar c = program[index + len];\n\t\t//cout << \"Test: c = \" << c << endl;\n\t\tif (c >= '0' and c <= '9') ++ len;\n\t\telse break;\n\t}\n\treturn len;\n}\n\nint matchIdentifier(const string & program, int index) {\n\tint len = 0;\n\twhile (index + len < program.size()) {\n\t\tchar c = program[index + len];\n\t\tif (c == '_' or \n\t\t\tc >= 'A' and c <= 'Z' or \n\t\t\tc >= 'a' and c <= 'z' or \n\t\t\tlen > 0 and c >= '0' and c <= '9') ++ len;\n\t\telse break;\n\t}\n\treturn len;\n}\n\nstring symbols[] = { \"!=\", \"!\", \"%=\", \"%\", \"^=\", \"^\", \"&=\", \"&&\", \"&\", \"*=\", \"*\", \"(\", \")\", \n                     \"--\", \"-=\", \"->\", \"-\", \"++\", \"+=\", \"+\", \"==\", \"=\", \"[\", \"{\", \"]\", \"}\",\n                     \"|=\", \"||\", \"|=\", \";\", \"::\", \":\", \".\", \"<<\", \"/=\", \"/\" };\nint symbol_count = 36;\n\nint matchSymbol(const string & program, int index) {\n\treturn matchSet(program, index, symbols, symbol_count);\n}\n\nint matchBlank(const string & program, int index) {\n\tint len = 0;\n\twhile (index + len < program.size()) {\n\t\tchar c = program[index + len];\n\t\tif (c == ' ' or c == '\\t' or c == '\\r' or c == '\\n') ++ len;\n\t\telse break;\n\t}\n\treturn len;\n}\n\nvector<string> lexicalAnalysis(const string & program) {\n\tvector<string> lexicons;\n\tint index = 0;\n\twhile (index < program.size()) {\n\t\tint id_len = matchIdentifier(program, index);\n\t\t//int key_len = matchKeyword(program, index);\n\t\t//if (id_len > key_len) {\n\t\tif (id_len > 0) {\n\t\t\tlexicons.push_back(program.substr(index, id_len));\n\t\t\tindex += id_len;\n\t\t\tcontinue;\n\t\t} \n\t\t//if (key_len > 0) {\n\t\t//\tlexicons.push_back(program.substr(index, key_len));\n\t\t//\tindex += key_len;\n\t\t//\tcontinue;\n\t\t//}\n\t\tint sym_len = matchSymbol(program, index);\n\t\tif (sym_len > 0) {\n\t\t\tlexicons.push_back(program.substr(index, sym_len));\n\t\t\tindex += sym_len;\n\t\t\tcontinue;\n\t\t}\n\t\tint num_len = matchNumber(program, index);\n\t\tif (num_len > 0) {\n\t\t\tlexicons.push_back(program.substr(index, num_len));\n\t\t\tindex += num_len;\n\t\t\tcontinue;\n\t\t}\n\t\tint blank_len = matchBlank(program, index);\n\t\tif (blank_len > 0) {\n\t\t\t//lexicons.push_back(program.substr(index, blank_len ));\n\t\t\tindex += blank_len ;\n\t\t\tcontinue;\n\t\t}\n\t\t//if (id_len == 0 and key_len == 0 and sym_len == 0 and num_len == 0 and blank_len == 0) {\n\t\tif (id_len == 0 and sym_len == 0 and num_len == 0 and blank_len == 0) {\n\t\t\tcout << \"Lexical error at \" << index << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn lexicons;\n}",
            "from random import randint\nops = ['(','+','-','*','/']\nspaces = ['','','','',' ',' ',' ',' ','\\n']\ndef rand_eq(num_ops):\n\tif num_ops == 0:\n\t\treturn str(randint(0,99))\n\top = ops[randint(0,len(ops)-1)]\n\tlspace = spaces[randint(0,len(spaces)-1)]\n\trspace = spaces[randint(0,len(spaces)-1)]\n\tif op == '(':\n\t\treturn '(' + lspace + rand_eq(num_ops-1) + rspace + ')'\n\telse:\n\t\tlops = randint(0,num_ops-1)\n\t\trops = num_ops-1 - lops\n\t\treturn rand_eq(lops) + lspace + op + rspace + rand_eq(rops)\n\t\nnum_ops = randint(4,8)\nprint(rand_eq(num_ops))\n",
            1585713600,
            1585713600
        ],
        [
            "12.1 (C++)",
            "<p>请为Grammar写operator &gt;&gt;</p><p>\n<b>EXAMPLE INPUT</b>\n<pre>Num\t&lt;=\t+-  Num  \nProd\t&lt;=\tNum  */  Num  \nProd\t&lt;=\tProd  */  Num  \nProd\t&lt;=\tNum  \nSum\t&lt;=\tProd  +-  Prod  \nSum\t&lt;=\tSum  +-  Prod  \nSum\t&lt;=\tProd  \nNum\t&lt;=\t(  Sum  )  \nS\t&lt;=\tSum\n</pre>\n<b>EXAMPLE OUTPUT</b>\n<pre>Num\t&lt;=\t+-  Num  \nProd\t&lt;=\tNum  */  Num  \nProd\t&lt;=\tProd  */  Num  \nProd\t&lt;=\tNum  \nSum\t&lt;=\tProd  +-  Prod  \nSum\t&lt;=\tSum  +-  Prod  \nSum\t&lt;=\tProd  \nNum\t&lt;=\t(  Sum  )  \nS\t&lt;=\tSum\n</pre></p>",
            "#include <string>\n#include <vector>\n#include <iostream>\nusing namespace std;\n\nclass Grammar\n{\npublic:\n\tstring to;\n\tvector<string> from;\n\n\tGrammar(string to, string from1, string from2=\"\", string from3=\"\", string from4=\"\", string from5=\"\") {\n\t\tthis->to = to;\n\t\tif (from1.size() > 0) from.push_back(from1);\n\t\tif (from2.size() > 0) from.push_back(from2);\n\t\tif (from3.size() > 0) from.push_back(from3);\n\t\tif (from4.size() > 0) from.push_back(from4);\n\t\tif (from5.size() > 0) from.push_back(from5);\n\t}\n\t\n\tGrammar() {}\n};\n\nostream & operator << (ostream & out, const Grammar & grammar) {\n\tout << grammar.to << \"\\t<=\\t\";\n\tfor (int i = 0; i < grammar.from.size(); ++ i)\n\t\tcout << grammar.from[i] << \"  \";\n\treturn out;\n}\n\n#include \"source.cpp\"\n\nint main() {\n\tfor (int i = 0; i < 9; ++ i) {\n\t\tGrammar grammar;\n\t\tcin >> grammar;\n\t\tcout << grammar << endl;\n\t}\n}",
            "#include <sstream>\nusing namespace std;\n\nistream & operator >> (istream & in, Grammar & grammar) {\n\tstring line;\n\tgetline(in, line);\n\tstringstream ss(line);\n\tstring to;\n\tstring from1;\n\tstring from2;\n\tstring from3;\n\tstring from4;\n\tstring from5;\n\tss >> to >> from1 >> from1;\n\tif (ss) ss >> from2;\n\tif (ss) ss >> from3;\n\tif (ss) ss >> from4;\n\tif (ss) ss >> from5;\n\tgrammar = Grammar(to, from1, from2, from3, from4, from5);\n\treturn in;\n}",
            "from random import randint\n\ndef random_str(k):\n\tchars = 'abcdefghijklmnopqrstuvwxyz'.upper()\n\ttext = ''\n\tfor i in range(k):\n\t\ttext += chars[randint(0,len(chars)-1)]\n\treturn text\n\ndef random_ops(k):\n\tchars = '+-*/'\n\ttext = ''\n\tfor i in range(k):\n\t\ttext += chars[randint(0,len(chars)-1)]\n\treturn text\n\ndef print_line():\n\tprint(random_str(randint(3,6)), end='')\n\tprint('\\t<=\\t', end='')\n\tfor i in range(randint(2,5)):\n\t\tif randint(0,2) == 0:\n\t\t\tprint(random_ops(randint(1,3)), end='  ')\n\t\telse:\n\t\t\tprint(random_str(randint(3,9)), end='  ')\n\tprint()\n\t\t\nfor i in range(9):\n\tprint_line()",
            1585713600,
            1585713600
        ],
        [
            "13.1 (C++)",
            "<p>在课堂上讲的哈希表的基础上，扩展出一个以整数为键的只有一个类型参数的哈希表类HT。\n</p><p><b>HINT</b>：尝试用2行代码完成该题。\n</p><p><b>EXAMPLE INPUT</b>\n<pre>2000\n</pre>\n\n<b>EXAMPLE OUTPUT</b>\n<pre>2000\ntext51\ntext151\ntext251\ntext351\ntext451\ntext551\ntext651\ntext751\ntext851\ntext951\ntext1051\ntext1151\ntext1251\ntext1351\ntext1451\ntext1551\ntext1651\ntext1751\ntext1851\ntext1951\n0\n</pre></p>",
            "#include <vector>\n#include <string>\nusing namespace std;\n\nint operator % (const string & text, int max) {\n\tint code = 0;\n\tfor (int i = 0; i < text.size(); ++ i) {\n\t\tint code1 = text[i];\n\t\tcode1 = code1 << (i * 8 % 24);\n\t\tcode = code ^ code1;\n\t}\n\treturn code % max;\n}\n\nclass NoSuchKeyException {};\n\ntemplate <typename K, typename V>\nclass HashTable\n{\nprivate:\n\t\t\n\tclass Entry\n\t{\n\tpublic:\n\t\tK key;\n\t\tV value;\n\t\tbool isInUse;\n\t\t\n\t\tEntry() {\n\t\t\tisInUse = false;\n\t\t}\n\t};\n\t\n\tEntry * entries;\n\t\n\tint capacity;\n\tint count;\n\t\n\tvoid initialize(int capacity2) {\n\t\tcount = 0;\n\t\tcapacity = capacity2;\n\t\tentries = new Entry[capacity];\n\t}\n\t\n\tvoid assign(const HashTable & map2) {\n\t\tcount = map2.count;\n\t\tcapacity = map2.capacity;\n\t\tentries = new Entry[capacity];\n\t\tfor (int i = 0; i < capacity; ++ i) {\n\t\t\tentries[i] = map2.entries[i];\n\t\t}\n\t}\n\t\npublic:\n\t\n\tHashTable() {\n\t\tinitialize(2);\n\t}\n\t\n\t~HashTable() {\n\t\tdelete [] entries;\n\t}\n\t\n\tHashTable(const HashTable & map2) {\n\t\tassign(map2);\n\t}\n\t\n\tHashTable & operator = (const HashTable & map2) {\n\t\tdelete [] entries;\n\t\tassign(map2);\n\t\treturn (*this);\n\t}\n\t\n\tvoid clear() {\n\t\tdelete [] entries;\n\t\tinitialize(2);\n\t}\n\t\nprivate:\n\t\n\tint hashIndex(const K & key) const {\n\t\treturn key % capacity;\n\t}\n\t\n\tint find(const K & key) const {\n\t\tint index = hashIndex(key);\n\t\twhile (true) {\n\t\t\tif (! entries[index].isInUse) {\n\t\t\t\treturn index;\n\t\t\t}\n\t\t\tif (entries[index].key == key) {\n\t\t\t\treturn index;\n\t\t\t}\n\t\t\tindex = (index + 1) % capacity;\n\t\t}\n\t}\n\t\n\tvoid resize(int capacity2) {\n\t\tEntry * entries0 = entries;\n\t\tint capacity0 = capacity;\n\t\tinitialize(capacity2);\n\t\tfor (int i = 0; i < capacity0; ++ i) {\n\t\t\tif (entries0[i].isInUse) {\n\t\t\t\tput(entries0[i].key, entries0[i].value);\n\t\t\t}\n\t\t}\n\t\tdelete [] entries0;\n\t}\n\t\npublic:\n\t\n\tvoid put(const K & key, const V & value) {\n\t\tint index = find(key);\n\t\tentries[index].value = value;\n\t\tif (entries[index].isInUse) return;\n\t\t\n\t\tentries[index].isInUse = true;\n\t\tentries[index].key = key;\n\t\t\n\t\t++ count;\n\t\tif (count > capacity / 2) {\n\t\t\tresize(capacity * 2);\n\t\t}\n\t}\n\t\n\tV get(const K & key) const {\n\t\tint index = find(key);\n\t\tif (! entries[index].isInUse) {\n\t\t\tthrow NoSuchKeyException();\n\t\t}\n\t\treturn entries[index].value;\n\t}\n\t\n\tbool remove(const K & key) {\n\t\tint index = find(key);\n\t\tif (! entries[index].isInUse) return false;\n\t\tfillNotInUseEntry(index);\n\t\t\n\t\t-- count;\n\t\tif (count < capacity / 4) {\n\t\t\tresize(capacity / 2);\n\t\t}\n\t\treturn true;\n\t}\n\t\nprivate:\n\t\n\tvoid fillNotInUseEntry(int index) {\n\t\tint next = index;\n\t\twhile (true) {\n\t\t\tnext = (next + 1) % capacity;\n\t\t\tif (! entries[next].isInUse) {\n\t\t\t\tentries[index].isInUse = false;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint index0 = hashIndex(entries[next].key);\n\t\t\tif (index < next) {\n\t\t\t\tif (index0 > index &&\n\t\t\t\t\tindex0 <= next) continue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (index0 > index ||\n\t\t\t\t\tindex0 <= next) continue;\n\t\t\t}\n\t\t\tentries[index] = entries[next];\n\t\t\tindex = next;\n\t\t}\n\t}\n\t\npublic:\n\t\n\tbool containsKey(const K & key) const {\n\t\tint index = find(key);\n\t\treturn (entries[index].isInUse);\n\t}\n\t\n\tint size() const {\n\t\treturn count;\n\t}\n\n\tvector<K> getKeys() const {\n\t\tvector<K> vec;\n\t\tfor (int i = 0; i < capacity; ++ i) {\n\t\t\tif (entries[i].isInUse) {\n\t\t\t\tvec.push_back(entries[i].key);\n\t\t\t}\n\t\t}\n\t\treturn vec;\n\t}\n\t\n};\n\n#include \"source.cpp\"\n\n\n////////////////////////////////////\n// TEST\n\n#include <iostream>\n#include <sstream>\nusing namespace std;\n\nint main() {\n\tint test_count;\n\tcin >> test_count;\n\tHT<string> map;\n\tfor (int i = 0; i < test_count; ++ i) {\n\t\tstringstream ss;\n\t\tss << \"text\" << (1 + i);\n\t\tmap.put(i * 10, ss.str());\n\t}\n\tcout << map.size() << endl;\n\tfor (int i = 0; i < test_count; ++ i) {\n\t\tif (! map.containsKey(i * 10)) {\n\t\t\tcout << \"bad\" << endl;\n\t\t}\n\t\telse if (i % 100 == 50) {\n\t\t\tcout << map.get(i * 10) << endl;\n\t\t}\n\t}\n\tvector<int> keys = map.getKeys();\n\tfor (int i = 0; i < keys.size(); ++ i) {\n\t\tmap.remove(keys[i]);\n\t}\n\tcout << map.size() << endl;\n}",
            "template <typename E>\nclass HT : public HashTable<int, E> {};",
            "from random import randint\nprint(randint(1000,2300))",
            1585713600,
            1585713600
        ],
        [
            "13.2 (C++)",
            "<p>写出一个键和值的类型都可以是string或int的哈希表类HT。\n</p><p><b>EXAMPLE INPUT</b>\n</p><pre>1 2 3 4 5 6 7 8\n</pre>\n\n<b>EXAMPLE OUTPUT</b>\n<pre>4\n2\n4\n6\n8\n</pre><p></p>",
            "#include \"source.cpp\"\n\n#include <iostream>\n#include <sstream>\nusing namespace std;\n\nint main() {\n\tHT map;\n\tint key1;\n\tint value1;\n\tcin >> key1 >> value1;\n\tmap.put(key1, value1);\n\tstring key2;\n\tstring value2;\n\tcin >> key2 >> value2;\n\tmap.put(key2, value2);\n\tint key3;\n\tstring value3;\n\tcin >> key3 >> value3;\n\tmap.put(key3, value3);\n\tstring key4;\n\tint value4;\n\tcin >> key4 >> value4;\n\tmap.put(key4, value4);\n\tcout << map.size() << endl;\n\tcout << (int)map.get(key1) << endl;\n\tcout << (string)map.get(key2) << endl;\n\tcout << (string)map.get(key3) << endl;\n\tcout << (int)map.get(key4) << endl;\n}",
            "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint operator % (const string & text, int max) {\n\tint code = 0;\n\tfor (int i = 0; i < text.size(); ++ i) {\n\t\tint code1 = text[i];\n\t\tcode1 = code1 << (i * 8 % 24);\n\t\tcode = code ^ code1;\n\t}\n\treturn code % max;\n}\n\nclass NoSuchKeyException {};\n\ntemplate <typename K, typename V>\nclass HashTable\n{\nprivate:\n\t\t\n\tclass Entry\n\t{\n\tpublic:\n\t\tK key;\n\t\tV value;\n\t\tbool isInUse;\n\t\t\n\t\tEntry() {\n\t\t\tisInUse = false;\n\t\t}\n\t};\n\t\n\tEntry * entries;\n\t\n\tint capacity;\n\tint count;\n\t\n\tvoid initialize(int capacity2) {\n\t\tcount = 0;\n\t\tcapacity = capacity2;\n\t\tentries = new Entry[capacity];\n\t}\n\t\n\tvoid assign(const HashTable & map2) {\n\t\tcount = map2.count;\n\t\tcapacity = map2.capacity;\n\t\tentries = new Entry[capacity];\n\t\tfor (int i = 0; i < capacity; ++ i) {\n\t\t\tentries[i] = map2.entries[i];\n\t\t}\n\t}\n\t\npublic:\n\t\n\tHashTable() {\n\t\tinitialize(2);\n\t}\n\t\n\t~HashTable() {\n\t\tdelete [] entries;\n\t}\n\t\n\tHashTable(const HashTable & map2) {\n\t\tassign(map2);\n\t}\n\t\n\tHashTable & operator = (const HashTable & map2) {\n\t\tdelete [] entries;\n\t\tassign(map2);\n\t\treturn (*this);\n\t}\n\t\n\tvoid clear() {\n\t\tdelete [] entries;\n\t\tinitialize(2);\n\t}\n\t\nprivate:\n\t\n\tint hashIndex(const K & key) const {\n\t\treturn key % capacity;\n\t}\n\t\n\tint find(const K & key) const {\n\t\tint index = hashIndex(key);\n\t\twhile (true) {\n\t\t\tif (! entries[index].isInUse) {\n\t\t\t\treturn index;\n\t\t\t}\n\t\t\tif (entries[index].key == key) {\n\t\t\t\treturn index;\n\t\t\t}\n\t\t\tindex = (index + 1) % capacity;\n\t\t}\n\t}\n\t\n\tvoid resize(int capacity2) {\n\t\tEntry * entries0 = entries;\n\t\tint capacity0 = capacity;\n\t\tinitialize(capacity2);\n\t\tfor (int i = 0; i < capacity0; ++ i) {\n\t\t\tif (entries0[i].isInUse) {\n\t\t\t\tput(entries0[i].key, entries0[i].value);\n\t\t\t}\n\t\t}\n\t\tdelete [] entries0;\n\t}\n\t\npublic:\n\t\n\tvoid put(const K & key, const V & value) {\n\t\tint index = find(key);\n\t\tentries[index].value = value;\n\t\tif (entries[index].isInUse) return;\n\t\t\n\t\tentries[index].isInUse = true;\n\t\tentries[index].key = key;\n\t\t\n\t\t++ count;\n\t\tif (count > capacity / 2) {\n\t\t\tresize(capacity * 2);\n\t\t}\n\t}\n\t\n\tV & get(const K & key) {\n\t\tint index = find(key);\n\t\tif (! entries[index].isInUse) {\n\t\t\tcout << \"NoSuchKeyException: \" << key << endl;\n\t\t\treturn entries[index].value;\n\t\t\t// throw NoSuchKeyException();\n\t\t}\n\t\treturn entries[index].value;\n\t}\n\t\n\tbool remove(const K & key) {\n\t\tint index = find(key);\n\t\tif (! entries[index].isInUse) return false;\n\t\tfillNotInUseEntry(index);\n\t\t\n\t\t-- count;\n\t\tif (count < capacity / 4) {\n\t\t\tresize(capacity / 2);\n\t\t}\n\t\treturn true;\n\t}\n\t\nprivate:\n\t\n\tvoid fillNotInUseEntry(int index) {\n\t\tint next = index;\n\t\twhile (true) {\n\t\t\tnext = (next + 1) % capacity;\n\t\t\tif (! entries[next].isInUse) {\n\t\t\t\tentries[index].isInUse = false;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint index0 = hashIndex(entries[next].key);\n\t\t\tif (index < next) {\n\t\t\t\tif (index0 > index &&\n\t\t\t\t\tindex0 <= next) continue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (index0 > index ||\n\t\t\t\t\tindex0 <= next) continue;\n\t\t\t}\n\t\t\tentries[index] = entries[next];\n\t\t\tindex = next;\n\t\t}\n\t}\n\t\npublic:\n\t\n\tbool containsKey(const K & key) const {\n\t\tint index = find(key);\n\t\treturn (entries[index].isInUse);\n\t}\n\t\n\tint size() const {\n\t\treturn count;\n\t}\n\n\tvector<K> getKeys() const {\n\t\tvector<K> vec;\n\t\tfor (int i = 0; i < capacity; ++ i) {\n\t\t\tif (entries[i].isInUse) {\n\t\t\t\tvec.push_back(entries[i].key);\n\t\t\t}\n\t\t}\n\t\treturn vec;\n\t}\n\t\n};\n\n#include <stdexcept>\nusing namespace std;\n\nclass SI\n{\n\tbool is_int;\n\tint key1;\n\tstring key2;\npublic:\n\tSI() {}\n\tSI(int key) {\n\t\tis_int = true;\n\t\tkey1 = key;\n\t}\n\tSI(const string & key) {\n\t\tis_int = false;\n\t\tkey2 = key;\n\t}\n\tbool operator == (const SI & that) const {\n\t\tif (is_int != that.is_int) return false;\n\t\tif (is_int)\n\t\t\treturn key1 == that.key1;\n\t\treturn key2 == that.key2;\n\t}\n\tbool isInt() const {\n\t\treturn is_int;\n\t}\n\tint operator % (int size) const {\n\t\tif (is_int) return key1 % size;\n\t\treturn key2 % size;\n\t}\n\toperator int() const {\n\t\tif (! is_int) throw runtime_error(\"Cannot convert a string to an integer\");\n\t\treturn key1;\n\t}\n\toperator string() const {\n\t\tif (is_int) throw runtime_error(\"Cannot convert an integer to a string\");\n\t\treturn key2;\n\t}\n};\n\nostream & operator << (ostream & out, const SI & si) {\n\tif (si.isInt()) out << int(si);\n\telse out << string(si);\n\treturn out;\n}\n\nclass HT : public HashTable<SI, SI> {\npublic:\n\tSI & operator[] (const SI & index) {\n\t\treturn get(index);\n\t}\n};\n",
            "from random import randint\nfor i in range(8):\n\tprint(randint(1,99), end=' ')",
            1585713600,
            1585713600
        ],
        [
            "15.1 (C++)",
            "Please write a class <i>Table</i>, such that the main function outputs as follows.\n<br><br>\n<b>OUTPUT</b>\n<pre>{\n\theaders: ['AA','BB',],\n\trows: [\n\t\t['123','456',],\n\t\t['234','567',],\n\t],\n}\n</pre>",
            "#include \"source.cpp\"\n\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nostream & operator << (ostream & out, const Table & table) {\n\tout << table.json() << endl;\n\treturn out;\n}\n\nint main() {\n\tTable t1; // 空表\n\tt1.addCol(\"AA\"); // 变为一个有1列, 表头为[\"AA\"], 0行数据的表\n\tt1.addCol(\"BB\"); // 变为一个有2列, 表头为[\"AA\", \"BB\"], 0行数据的表\n\tvector<string> vec;\n\tvec.push_back(\"123\");\n\tvec.push_back(\"456\");\n\tt1[0] = vec; // 表格允许设置最后一个不存在的行(这时自动添加尾行), 变为一个有2列, 表头为[\"AA\", \"BB\"], 有1行数据的表\n\tvec[0] = \"234\";\n\tvec[1] = \"567\";\n\tt1[1] = vec; // 表格允许设置最后一个不存在的行(这时自动添加尾行), 变为一个有2列, 表头为[\"AA\", \"BB\"], 有2行数据的表\n\tcout << t1 << endl; // 以json格式输出表格(如example output所示), 以便其他程序读入\n}",
            "#include <iostream>\n#include <string>\n#include <vector>\n#include <stdexcept>\n#include <sstream>\nusing namespace std;\n\nclass IndexOutOfBoundsException : public runtime_error {\npublic:\n\tIndexOutOfBoundsException() : runtime_error(\"Index out of bounds\") {}\n};\n\nclass AssignmentException : public runtime_error {\npublic:\n\tAssignmentException() : runtime_error(\"AssignmentException\") {}\n};\n\nclass List\n{\nprivate:\n\tvector<string> data;\npublic:\n\tList() {\n\n\t}\n};\n\nclass Table\n{\nprivate:\n\tvector<string> headers;\n\tvector<vector<string> > rows;\n\n\tint _getIndex(int index0, int size0) {\n\t\tint index = index0;\n\t\tif (index < 0) index += size0;\n\t\tif (index > size0) throw IndexOutOfBoundsException();\n\t\treturn index;\n\t}\n\n\tstatic void _insert(vector<string> & vec, const string & text, int index) {\n\t\tint size0 = vec.size();\n\t\tif (index == size0) {\n\t\t\tvec.push_back(text);\n\t\t\treturn;\n\t\t}\n\t\tvec.push_back(\"\");\n\t\tfor (int i = size0; i >= index; -- i) {\n\t\t\tvec[i + 1] = vec[i];\n\t\t}\n\t\tvec[index] = text;\n\t}\n\t\n\tclass RowRef\n\t{\n\tprivate:\n\t\tTable & table;\n\t\tint row_index;\n\tpublic:\n\t\tRowRef(Table & t, int row) : table(t), row_index(row) {};\n\t\t\n\t\tRowRef & operator = (const vector<string> & vec) {\n\t\t\t// cout << table.rows.size() << endl;\n\t\t\tvector<string> & row = table.rows[row_index];\n\t\t\tif (row.size() != vec.size()) throw AssignmentException();\n\t\t\tfor (int i = 0; i < row.size(); ++ i) {\n\t\t\t\trow[i] = vec[i];\n\t\t\t}\n\t\t\treturn *this;\n\t\t}\n\t\t\n\t\toperator vector<string> () const {\n\t\t\tvector<string> & row = table.rows[row_index];\n\t\t\tvector<string> vec;\n\t\t\tfor (int i = 0; i < row.size(); ++ i) {\n\t\t\t\tvec.push_back(row[i]);\n\t\t\t}\n\t\t\treturn vec;\n\t\t}\n\t};\n\npublic:\n\tint rowCount() {\n\t\treturn rows.size();\n\t}\n\n\tint colCount() {\n\t\treturn headers.size();\n\t}\n\n\tTable & addCol(string colName, int index=-1) {\n\t\tindex = _getIndex(index, headers.size() + 1);\n\t\t// cout << \"index: \" << index << endl;\n\t\t_insert(headers, colName, index);\n\t\tfor (int i = 0; i < rows.size(); ++ i) {\n\t\t\t_insert(rows[i], \"\", index);\n\t\t}\n\t\treturn *this;\n\t}\n\n\tTable & addRow(int index=-1) {\n\t\tindex = _getIndex(index, rows.size() + 1);\n\t\tvector<string> new_row;\n\t\tfor (int i = 0; i < headers.size(); ++ i) new_row.push_back(\"\");\n\t\tint size0 = rows.size();\n\t\tif (index == size0) {\n\t\t\trows.push_back(new_row);\n\t\t}\n\t\telse {\n\t\t\trows.push_back(new_row);\n\t\t\tfor (int i = size0; i >= index; -- i) {\n\t\t\t\trows[i + 1] = rows[i];\n\t\t\t}\n\t\t\trows[index] = new_row;\n\t\t}\n\t\treturn *this;\n\t}\n\t\n\tRowRef operator [] (int row_index) {\n\t\tif (rows.size() == row_index) addRow(row_index);\n\t\treturn RowRef(*this, row_index);\n\t}\n\t\n\tstring json() const {\n\t\tstringstream ss;\n\t\tss << \"{\\n\\theaders: [\";\n\t\tfor (int i = 0; i < headers.size(); ++ i) {\n\t\t\tss << \"'\" << headers[i] << \"',\";\n\t\t}\n\t\tss << \"],\\n\\trows: [\";\n\t\tfor (int i = 0; i < rows.size(); ++ i) {\n\t\t\tss << \"\\n\\t\\t[\";\n\t\t\tfor (int j = 0; j < rows[i].size(); ++ j) {\n\t\t\t\tss << \"'\" << rows[i][j] << \"',\";\n\t\t\t}\n\t\t\tss << \"],\";\n\t\t}\n\t\tss << \"\\n\\t],\\n}\";\n\t\treturn ss.str();\n\t}\n\n};",
            "",
            1593741600,
            1594299600
        ],
        [
            "15.2 (C++)",
            "Please modify the simple Python compiler as follows:\n<ul>\n<li>Combine all CPP file into a single file</li>\n<li>Input from STDIO instead of from a Python file</li>\n<li>Load library from an internal string instead of from \"lib/builtins.py\"</li>\n</ul>\n\n<b>EXAMPLE INPUT</b>\n<pre>\ndef test_loop(n):\n\tfor i in range(n):\n\t\tprint(1 + i)\n\ndef test_condition(c):\n\tif c:\n\t\tprint(\"yes\")\n\telse:\n\t\tprint(\"no\")\n\ntest_loop(10)\ntest_condition(True)\n</pre>\n\n<b>EXAMPLE OUTPUT</b>\n<pre>\n( function_def ( def def )( id test_loop )( -LRB- -LRB- )( id n )( -RRB- -RRB- )( : : ) )\n( for_statement ( for for )( id i )( in in )( function_call ( id range )( -LRB- -LRB- )( id n )( -RRB- -RRB- ) )( : : ) )\n( function_call ( id print )( -LRB- -LRB- )( expression ( int 1 )( + + )( id i ) )( -RRB- -RRB- ) )\n( function_def ( def def )( id test_condition )( -LRB- -LRB- )( id c )( -RRB- -RRB- )( : : ) )\n( if_statement ( if if )( id c )( : : ) )\n( function_call ( id print )( -LRB- -LRB- )( str \"yes\" )( -RRB- -RRB- ) )\n( else_statement ( else else )( : : ) )\n( function_call ( id print )( -LRB- -LRB- )( str \"no\" )( -RRB- -RRB- ) )\n( function_call ( id test_loop )( -LRB- -LRB- )( int 10 )( -RRB- -RRB- ) )\n( function_call ( id test_condition )( -LRB- -LRB- )( True True )( -RRB- -RRB- ) )\n( __main__( function_def( for_statement( function_call _ ) ) )( function_def( if_statement( function_call _ ) )( else_statement( function_call _ ) ) )( function_call _ )( function_call _ ) )\n</pre>",
            "#include \"source.cpp\"",
            "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <stdexcept>\nusing namespace std;\n\n#include <cstring>\n\nint operator % (const string & text, int max) {\n\tint code = 0;\n\tfor (int i = 0; i < text.size(); ++ i) {\n\t\tint code1 = text[i];\n\t\tcode1 = code1 << (i * 8 % 24);\n\t\tcode = code ^ code1;\n\t}\n\treturn code % max;\n}\n\nclass NoSuchKeyException {};\n\ntemplate <typename K, typename V>\nclass HashTable\n{\nprivate:\n\t\t\n\tclass Entry\n\t{\n\tpublic:\n\t\tK key;\n\t\tV value;\n\t\tbool isInUse;\n\t\t\n\t\tEntry() {\n\t\t\tisInUse = false;\n\t\t}\n\t};\n\t\n\tEntry * entries;\n\t\n\tint capacity;\n\tint count;\n\t\n\tvoid initialize(int capacity2) {\n\t\tcount = 0;\n\t\tcapacity = capacity2;\n\t\tentries = new Entry[capacity];\n\t}\n\t\n\tvoid assign(const HashTable & map2) {\n\t\tcount = map2.count;\n\t\tcapacity = map2.capacity;\n\t\tentries = new Entry[capacity];\n\t\tfor (int i = 0; i < capacity; ++ i) {\n\t\t\tentries[i] = map2.entries[i];\n\t\t}\n\t}\n\t\npublic:\n\t\n\tHashTable() {\n\t\tinitialize(2);\n\t}\n\t\n\t~HashTable() {\n\t\tdelete [] entries;\n\t}\n\t\n\tHashTable(const HashTable & map2) {\n\t\tassign(map2);\n\t}\n\t\n\tHashTable & operator = (const HashTable & map2) {\n\t\tdelete [] entries;\n\t\tassign(map2);\n\t\treturn (*this);\n\t}\n\t\n\tvoid clear() {\n\t\tdelete [] entries;\n\t\tinitialize(2);\n\t}\n\t\nprivate:\n\t\n\tint hashIndex(const K & key) const {\n\t\treturn key % capacity;\n\t}\n\t\n\tint find(const K & key) const {\n\t\tint index = hashIndex(key);\n\t\twhile (true) {\n\t\t\tif (! entries[index].isInUse) {\n\t\t\t\treturn index;\n\t\t\t}\n\t\t\tif (entries[index].key == key) {\n\t\t\t\treturn index;\n\t\t\t}\n\t\t\tindex = (index + 1) % capacity;\n\t\t}\n\t}\n\t\n\tvoid resize(int capacity2) {\n\t\tEntry * entries0 = entries;\n\t\tint capacity0 = capacity;\n\t\tinitialize(capacity2);\n\t\tfor (int i = 0; i < capacity0; ++ i) {\n\t\t\tif (entries0[i].isInUse) {\n\t\t\t\tput(entries0[i].key, entries0[i].value);\n\t\t\t}\n\t\t}\n\t\tdelete [] entries0;\n\t}\n\t\npublic:\n\t\n\tvoid put(const K & key, const V & value) {\n\t\tint index = find(key);\n\t\tentries[index].value = value;\n\t\tif (entries[index].isInUse) return;\n\t\t\n\t\tentries[index].isInUse = true;\n\t\tentries[index].key = key;\n\t\t\n\t\t++ count;\n\t\tif (count > capacity / 2) {\n\t\t\tresize(capacity * 2);\n\t\t}\n\t}\n\t\n\tV get(const K & key) const {\n\t\tint index = find(key);\n\t\tif (! entries[index].isInUse) {\n\t\t\tthrow NoSuchKeyException();\n\t\t}\n\t\treturn entries[index].value;\n\t}\n\t\n\tbool remove(const K & key) {\n\t\tint index = find(key);\n\t\tif (! entries[index].isInUse) return false;\n\t\tfillNotInUseEntry(index);\n\t\t\n\t\t-- count;\n\t\tif (count < capacity / 4) {\n\t\t\tresize(capacity / 2);\n\t\t}\n\t\treturn true;\n\t}\n\t\nprivate:\n\t\n\tvoid fillNotInUseEntry(int index) {\n\t\tint next = index;\n\t\twhile (true) {\n\t\t\tnext = (next + 1) % capacity;\n\t\t\tif (! entries[next].isInUse) {\n\t\t\t\tentries[index].isInUse = false;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint index0 = hashIndex(entries[next].key);\n\t\t\tif (index < next) {\n\t\t\t\tif (index0 > index &&\n\t\t\t\t\tindex0 <= next) continue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (index0 > index ||\n\t\t\t\t\tindex0 <= next) continue;\n\t\t\t}\n\t\t\tentries[index] = entries[next];\n\t\t\tindex = next;\n\t\t}\n\t}\n\t\npublic:\n\t\n\tbool containsKey(const K & key) const {\n\t\tint index = find(key);\n\t\treturn (entries[index].isInUse);\n\t}\n\t\n\tint size() const {\n\t\treturn count;\n\t}\n\n\tvector<K> getKeys() const {\n\t\tvector<K> vec;\n\t\tfor (int i = 0; i < capacity; ++ i) {\n\t\t\tif (entries[i].isInUse) {\n\t\t\t\tvec.push_back(entries[i].key);\n\t\t\t}\n\t\t}\n\t\treturn vec;\n\t}\n\t\n};\n\n////////////////////////////////////////////////////////////////////////////////\n\nstruct Token\n{\n\tint line;\n\tint pos;\n\tstring type;\n\tstring text;\n};\n\nint operator % (const Token & t, int base) {\n\treturn (t.line * 12347 + t.pos) % base;\n}\n\nbool operator == (const Token & t1, const Token & t2) {\n\treturn t1.line == t2.line && t1.pos == t2.pos;\n}\n\nostream & operator << (ostream & out, const Token & t) {\n\tout << t.line << '\\t' << t.pos << '\\t' << t.type << \"\\t\\\"\" << t.text << \"\\\"\";\n\treturn out;\n}\n\nvoid read_lines(istream & in, vector<string> & lines) {\n\tstring line;\n\twhile (getline(in, line)) {\n\t\tlines.push_back(line);\n\t}\n}\n\nToken make_token(int line, int pos, int len, const string & source, const string & type) {\n\tToken t;\n\tt.line = line;\n\tt.pos = pos;\n\tt.type = type;\n\tt.text = source.substr(pos, len);\n\treturn t;\n}\n\n////////////////////\n// RULES BEGIN\n\nToken find_indent(int line, const string & source) {\n\tint len = 0;\n\tfor (int i = 0; i < source.size(); ++ i) {\n\t\tif (source[i] == '\\t')\n\t\t\t++ len;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn make_token(line, 0, len, source, \"indent\");\n}\n\nToken find_blank(int line, const string & source, int start) {\n\tint len = 0;\n\tfor (int i = start; i < source.size(); ++ i) {\n\t\tif (source[i] == '\\t' || source[i] == ' ')\n\t\t\t++ len;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn make_token(line, start, len, source, \"blank\");\n}\n\nToken find_string(int line, const string & source, int start) {\n\tint len = 0;\n\tbool was_backslash = false;\n\tfor (int i = start; i < source.size(); ++ i) {\n\t\tchar c = source[i];\n\t\tif (i == start) {\n\t\t\tif (c == '\"') ++ len;\n\t\t\telse break;\n\t\t}\n\t\telse {\n\t\t\tif (was_backslash) {\n\t\t\t\tif (c == '\\\\' || c == 'r' || c == 'n' ||\n\t\t\t\t\tc == 't' || c == '\"')\n\t\t\t\t\t++ len;\n\t\t\t\telse break;\n\t\t\t\twas_backslash = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (c == '\"') {\n\t\t\t\t\t++ len;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t++ len;\n\t\t\t\twas_backslash = (c == '\\\\');\n\t\t\t}\n\t\t} \n\t}\n\treturn make_token(line, start, len, source, \"str\");\t\n}\n\nToken find_int(int line, const string & source, int start) {\n\tif (start < source.size()) {\n\t\tif (source[start] == '0' && (start + 1 == source.size() || (source[start + 1] < '0' || source[start + 1] > '9')))\n\t\t\treturn make_token(line, start, 1, source, \"int\");\n\t}\n\tint len = 0;\n\tfor (int i = start; i < source.size(); ++ i) {\n\t\tif ((i != start && source[i] >= '0' && source[i] <= '9' ) ||\n\t\t\t(source[i] >= '1' && source[i] <= '9'))\n\t\t\t++ len;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn make_token(line, start, len, source, \"int\");\t\n}\n\nToken find_id(int line, const string & source, int start) {\n\tint len = 0;\n\tfor (int i = start; i < source.size(); ++ i) {\n\t\tif ((i != start && source[i] >= '0' && source[i] <= '9') ||\n\t\t\t(source[i] >= 'A' && source[i] <= 'Z') ||\n\t\t\t(source[i] >= 'a' && source[i] <= 'z') ||\n\t\t\tsource[i] == '_')\n\t\t\t++ len;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn make_token(line, start, len, source, \"id\");\n}\n\nconst char *keywords[] = {\n\t\"class\", \"def\", \"if\", \"else\", \"for\", \"in\", \"return\", \"yield\", \"and\", \"or\", \"not\", \"pass\",\n\t\"True\", \"False\", \"None\",\n\t\"(\", \")\", \"[\", \"]\", \"{\", \"}\", \":\", \",\", \".\", \n\t\"==\", \">\", \"<\", \"<=\", \">=\", \"!=\", \"=\", \n\t\"+=\", \"-=\", \"*=\", \"/=\", \"//=\", \"%=\", \"&=\", \"^=\", \"|=\", \n\t\"+\", \"-\", \"**\", \"*\", \"//\", \"/\", \"%\", \"&\", \"^\", \"|\"\n};\n\nToken find_keyword(int line, const string & source, int start) {\n\tint keyword = -1;\n\tfor (int i = 0; i < sizeof(keywords) / sizeof(const char *); ++ i) {\n\t\tif (source.compare(start, strlen(keywords[i]), keywords[i]) == 0) {\n\t\t\tkeyword = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (keyword == -1)\n\t\treturn make_token(line, start, 0, source, \"\");\n\treturn make_token(line, start, strlen(keywords[keyword]), source, keywords[keyword]);\t\n}\n\nToken find_comment(int line, const string & source, int start) {\n\tint len = 0;\n\tfor (int i = start; i < source.size(); ++ i) {\n\t\tif (i != start || source[i] == '#')\n\t\t\t++ len;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn make_token(line, start, len, source, \"comment\");\n}\n\n////////////////////\n// RULES END\n\ntypedef Token (* find_function)(int, const string &, int);\n\nvoid add_tokens(HashTable<Token, Token> & tokens, int lineno, const string & line, find_function find, bool can_conflict) {\n\tint start = 0;\n\twhile (start < line.size()) {\n\t\tToken t = find(lineno, line, start);\n\t\tif (t.text.size() > 0) {\n\t\t\tif (can_conflict) {\n\t\t\t\tif (tokens.containsKey(t)) {\n\t\t\t\t\tToken old_t = tokens.get(t);\n\t\t\t\t\tif (old_t.text.size() < t.text.size())\n\t\t\t\t\t\ttokens.put(t, t);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttokens.put(t, t);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (tokens.containsKey(t)) {\n\t\t\t\t\tToken old_t = tokens.get(t);\n\t\t\t\t\tstringstream ss;\n\t\t\t\t\tss << \"Conflicting tokens:\" << endl;\n\t\t\t\t\tss << old_t << endl;\n\t\t\t\t\tss << t << endl;\n\t\t\t\t\tthrow runtime_error(ss.str());\n\t\t\t\t}\n\t\t\t\ttokens.put(t, t);\n\t\t\t}\n\t\t\tstart += t.text.size();\n\t\t}\n\t\telse\n\t\t\t++ start;\n\t}\n}\n\nvoid get_tokens(vector<string> & lines, vector<vector<Token> > & tokens) {\n\tHashTable<Token, Token> all_tokens;\n\tfor (int i = 0; i < lines.size(); ++ i) {\n\t\tToken indent = find_indent(i, lines[i]);\n\t\tif (indent.text.size() > 0)\n\t\t\tall_tokens.put(indent, indent);\n\t\tadd_tokens(all_tokens, i, lines[i], find_string, false);\n\t\tadd_tokens(all_tokens, i, lines[i], find_int, false);\n\t\tadd_tokens(all_tokens, i, lines[i], find_comment, false);\n\t\tadd_tokens(all_tokens, i, lines[i], find_keyword, false);\n\t\tadd_tokens(all_tokens, i, lines[i], find_id, true);\n\t\tadd_tokens(all_tokens, i, lines[i], find_blank, true);\n\t\t// TODO: add more lexical matching functions\n\t}\n\tToken index;\n\tfor (int i = 0; i < lines.size(); ++ i) {\n\t\ttokens.push_back(vector<Token>());\n\t\tindex.line = i;\n\t\tindex.pos = 0;\n\t\twhile (index.pos < lines[i].size()) {\n\t\t\tif (! all_tokens.containsKey(index)) {\n\t\t\t\tstringstream ss;\n\t\t\t\tss << \"Lexical error at line #\" << (index.line + 1) << \" char #\" << index.pos;\n\t\t\t\tthrow runtime_error(ss.str());\n\t\t\t}\n\t\t\tToken t = all_tokens.get(index);\n\t\t\tif (t.type != \"blank\")\n\t\t\t\ttokens[i].push_back(t);\n\t\t\tindex.pos += t.text.size();\n\t\t}\n\t}\n} \n\n////////////////////////////////////////////////////////////////////////////////\n\nstruct Node\n{\n\tint index;\n\tint span;\n\tstring type;\n\tvector<Node> children; // for non-terminal\n\tToken token; // for terminal, as \"indent\" for non-terminal\n};\n\nbool operator == (const Node & n1, const Node & n2) {\n\treturn n1.index == n2.index && n1.span == n2.span && n1.type == n2.type;\n}\n\nstring to_tree_text(string text) {\n\tfor (int i = 0; i < text.size(); ++ i)\n\t\tif (text[i] == ' ') text[i] = '_';\n\tif (text == \"(\") text = \"-LRB-\";\n\tif (text == \")\") text = \"-RRB-\";\n\treturn text;\n}\n\nvoid print_node(ostream & out, const Node & node, int indent=0) {\n\t// for (int i = 0; i < indent; ++ i) out << '\\\t';\n\tif (node.children.size() == 0) {\n\t\tout << \"( \" << to_tree_text(node.type) << ' ' << to_tree_text(node.token.text) << \" )\";\n\t}\n\telse {\n\t\t// out << node.type << \"\\\tindex=\" << node.index << \"\\\tspan=\" << node.span << endl;\n\t\tout << \"( \" << to_tree_text(node.type) << \" \";\n\t\tfor (int i = 0; i < node.children.size(); ++ i) {\n\t\t\tprint_node(out, node.children[i], indent + 1);\n\t\t}\n\t\tout << \" )\";\n\t}\n}\n\nostream & operator << (ostream & out, const Node & node) {\n\tprint_node(out, node, 0);\n\treturn out;\n}\n\n////////////////////\n// RULES BEGIN\n\nvoid make_node(const vector<Node> & node_list, vector<Node> & matched, const string & type, int len) {\n\tif (node_list.size() != len) return;\n\tNode node;\n\tnode.type = type;\n\tfor (int i = 0; i < len; ++ i)\n\t\tnode.children.push_back(node_list[i]);\n\tmatched.push_back(node);\n}\n\nvoid match_function_def(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() < 5) return;\n\tif (node_list[0].type != \"def\") return;\n\tif (node_list[1].type != \"id\") return;\n\tif (node_list[2].type != \"(\") return;\n\tint index = 3;\n\twhile (node_list[index].type == \"id\") {\n\t\t++ index;\n\t\tif (node_list.size() > index && node_list[index].type == \",\") {\n\t\t\t++ index;\n\t\t\tif (node_list.size() <= index || node_list[index].type != \"id\") return;\n\t\t}\n\t\telse break;\n\t}\n\tif (node_list.size() <= index || node_list[index].type != \")\") return;\n\t++ index;\n\tif (node_list.size() <= index || node_list[index].type != \":\") return;\n\t++ index;\n\tmake_node(node_list, matched, \"function_def\", index);\n}\n\nvoid match_expression(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() == 1) {\n\t\tif (node_list[0].type == \"function_call\" ||\n\t\t\tnode_list[0].type == \"str\" ||\n\t\t\tnode_list[0].type == \"id\" ||\n\t\t\tnode_list[0].type == \"int\" ||\n\t\t\tnode_list[0].type == \"None\" ||\n\t\t\tnode_list[0].type == \"True\" ||\n\t\t\tnode_list[0].type == \"False\")\n\t\t{\n\t\t\tmake_node(node_list, matched, \"expression1\", 1); // term\n\t\t}\n\t\telse if (node_list[0].type == \"expression1\") {\n\t\t\tmake_node(node_list, matched, \"expression2\", 1); // factor\n\t\t}\n\t\telse if (node_list[0].type == \"expression2\") {\n\t\t\tmake_node(node_list, matched, \"expression3\", 1); // exp\n\t\t}\n\t\telse if (node_list[0].type == \"expression3\") {\n\t\t\tmake_node(node_list, matched, \"expression4\", 1); // cmp\n\t\t}\n\t\telse if (node_list[0].type == \"expression4\") {\n\t\t\tmake_node(node_list, matched, \"expression5\", 1); // and\n\t\t}\n\t\telse if (node_list[0].type == \"expression5\") {\n\t\t\tmake_node(node_list, matched, \"expression\", 1); // or\n\t\t}\n\t}\n\tif (node_list.size() == 3) {\n\t\tif (node_list[0].type == \"(\" && node_list[1].type == \"expression\" && node_list[2].type == \")\") {\n\t\t\tmake_node(node_list, matched, \"expression1\", 3); // term\n\t\t}\n\t\telse if ((node_list[0].type == \"expression1\" || node_list[0].type == \"expression2L\") && node_list[1].type == \"operator_mul\" && node_list[2].type == \"expression1\") {\n\t\t\tmake_node(node_list, matched, \"expression2\", 3); // factor\n\t\t\tmake_node(node_list, matched, \"expression2L\", 3);\n\t\t}\n\t\telse if ((node_list[0].type == \"expression2\" || node_list[0].type == \"expression3L\") && node_list[1].type == \"operator_add\" && node_list[2].type == \"expression2\") {\n\t\t\tmake_node(node_list, matched, \"expression3\", 3); // exp\n\t\t\tmake_node(node_list, matched, \"expression3L\", 3);\n\t\t}\n\t\telse if ((node_list[0].type == \"expression3\" || node_list[0].type == \"expression4L\") && node_list[1].type == \"operator_cmp\" && node_list[2].type == \"expression3\") {\n\t\t\tmake_node(node_list, matched, \"expression4\", 3); // cmp\n\t\t\tmake_node(node_list, matched, \"expression4L\", 3);\n\t\t}\n\t\telse if ((node_list[0].type == \"expression4\" || node_list[0].type == \"expression5L\") && node_list[1].type == \"operator_and\" && node_list[2].type == \"expression4\") {\n\t\t\tmake_node(node_list, matched, \"expression5\", 3); // and\n\t\t\tmake_node(node_list, matched, \"expression5L\", 3);\n\t\t}\n\t\telse if ((node_list[0].type == \"expression5\" || node_list[0].type == \"expression6L\") && node_list[1].type == \"operator_or\" && node_list[2].type == \"expression5\") {\n\t\t\tmake_node(node_list, matched, \"expression\", 3); // and\n\t\t\tmake_node(node_list, matched, \"expression6L\", 3);\n\t\t}\n\t}\n}\n\nvoid match_function_call(const vector<Node> & node_list, vector<Node> & matched, int start=0) {\n\tif (node_list.size() < 4) return;\n\tif (node_list[0].type != \"id\") return;\n\tif (node_list[1].type != \"(\") return;\n\tint index = 2;\n\twhile (node_list[index].type == \"expression\") {\n\t\t++ index;\n\t\tif (node_list.size() > index && node_list[index].type == \",\") {\n\t\t\t++ index;\n\t\t\tif (node_list.size() <= index || node_list[index].type != \"expression\") return;\n\t\t}\n\t\telse break;\n\t}\n\tif (node_list.size() <= index || node_list[index].type != \")\") return;\n\t++ index;\n\tmake_node(node_list, matched, \"function_call\", index);\n}\n\nvoid match_for(const vector<Node> & node_list, vector<Node> & matched, int start=0) {\n\tif (node_list.size() != 5) return;\n\tif (node_list[0].type != \"for\") return;\n\tif (node_list[1].type != \"id\") return;\n\tif (node_list[2].type != \"in\") return;\n\tif (node_list[3].type != \"expression\") return;\n\tif (node_list[4].type != \":\") return;\n\tmake_node(node_list, matched, \"for_statement\", 5);\n}\n\nvoid match_if(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() != 3) return;\n\tif (node_list[0].type != \"if\") return;\n\tif (node_list[1].type != \"expression\") return;\n\tif (node_list[2].type != \":\") return;\n\tmake_node(node_list, matched, \"if_statement\", 3);\n}\n\nvoid match_else(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() != 2) return;\n\tif (node_list[0].type != \"else\") return;\n\tif (node_list[1].type != \":\") return;\n\tmake_node(node_list, matched, \"else_statement\", 2);\n}\n\nvoid match_operator(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() != 1) return;\n\tif (node_list[0].type == \"+\" || node_list[0].type == \"-\") {\n\t\tmake_node(node_list, matched, \"operator_add\", 1);\n\t}\n\telse if (node_list[0].type == \"*\" || node_list[0].type == \"/\" || node_list[0].type == \"%\") {\n\t\tmake_node(node_list, matched, \"operator_mul\", 1);\n\t}\n\telse if (node_list[0].type == \"==\" || node_list[0].type == \">\" || node_list[0].type == \"<\" \n\t\t || node_list[0].type == \">=\" || node_list[0].type == \"<=\" || node_list[0].type == \"!=\") {\n\t\tmake_node(node_list, matched, \"operator_cmp\", 1);\n\t}\n\telse if (node_list[0].type == \"and\") {\n\t\tmake_node(node_list, matched, \"operator_and\", 1);\n\t}\n\telse if (node_list[0].type == \"or\") {\n\t\tmake_node(node_list, matched, \"operator_or\", 1);\n\t}\n}\n\nvoid match_assign(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() != 3) return;\n\tif (node_list[0].type != \"id\") return;\n\tif (node_list[1].type != \"=\") return;\n\tif (node_list[2].type != \"expression\") return;\n\tmake_node(node_list, matched, \"assign_statement\", 3);\n}\n\nvoid match_yield(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() != 2) return;\n\tif (node_list[0].type != \"yield\") return;\n\tif (node_list[1].type != \"expression\") return;\n\tmake_node(node_list, matched, \"yield_statement\", 2);\n}\n\nvoid match_return(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() == 1) {\n\t\tif (node_list[0].type != \"return\") return;\n\t\tmake_node(node_list, matched, \"return_statement\", 1);\n\t}\n\telse if (node_list.size() == 2) {\n\t\tif (node_list[0].type != \"return\") return;\n\t\tif (node_list[1].type != \"expression\") return;\n\t\tmake_node(node_list, matched, \"return_statement\", 2);\n\t}\n}\n\nvoid match_pass(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() == 1) {\n\t\tif (node_list[0].type != \"pass\") return;\n\t\tmake_node(node_list, matched, \"pass_statement\", 1);\n\t}\n}\n\n////////////////////\n// RULES END\n\nvector<Node> check_rules(vector<Node> & node_list) {\n\tvector<Node> matched;\n\tmatch_function_def(node_list, matched);\n\tmatch_expression(node_list, matched);\n\tmatch_function_call(node_list, matched);\n\tmatch_for(node_list, matched);\n\tmatch_if(node_list, matched);\n\tmatch_else(node_list, matched);\n\tmatch_assign(node_list, matched);\n\tmatch_yield(node_list, matched);\n\tmatch_return(node_list, matched);\n\tmatch_operator(node_list, matched);\n\tmatch_pass(node_list, matched);\n\treturn matched;\n}\n\nvoid check_sequences(vector<vector<Node> > & nodes, vector<Node> & node_list, \n\tint index, vector<Node> & to_check) \n{\n\tNode last_node = node_list[node_list.size() - 1];\n\tint next_index = index + last_node.span;\n\t// cout << next_index << ' ' << nodes.size() << endl;\n\tif (next_index > nodes.size()) {\n\t\tthrow runtime_error(\"Internal error: incorrect next_index\");\n\t}\n\tvector<Node> matched = check_rules(node_list);\n\tfor (int i = 0; i < matched.size(); ++ i) {\n\t\tmatched[i].index = matched[i].children[0].index;\n\t\tmatched[i].span = 0;\n\t\tfor (int j = 0; j < matched[i].children.size(); ++ j)\n\t\t\tmatched[i].span += matched[i].children[j].span;\n\t\tfor (int j = 0; j < to_check.size(); ++ j) {\n\t\t\tif (to_check[j] == matched[i]) {\n\t\t\t\tstringstream ss;\n\t\t\t\tss << \"Internal error: repeated nodes:\" << endl;\n\t\t\t\tss << to_check[j] << endl;\n\t\t\t\tss << matched[i] << endl;\n\t\t\t\tthrow runtime_error(ss.str());\n\t\t\t}\n\t\t}\n\t\tto_check.push_back(matched[i]);\n\t}\n\t// for (int i = 0; i < matched.size(); ++ i) {\n\t// \tcout << matched[i] << endl;\n\t// }\n\tif (next_index == nodes.size()) return;\n\tfor (int i = 0; i < nodes[next_index].size(); ++ i) {\n\t\tNode node = nodes[next_index][i];\n\t\tnode_list.push_back(node);\n\t\tcheck_sequences(nodes, node_list, next_index, to_check);\n\t\tnode_list.pop_back();\n\t}\n}\n\nbool startswith(const string & text, const string & prefix) {\n\tint size = prefix.size();\n\tif (text.size() < size) return false;\n\tstring prefix2 = text.substr(0, size);\n\treturn prefix2 == prefix;\n}\n\nbool endswith(const string & text, const string & postfix) {\n\tint size = postfix.size();\n\tif (text.size() < size) return false;\n\tstring postfix2 = text.substr(text.size() - size, size);\n\treturn postfix2 == postfix;\n}\n\nNode parse_line(int lineno, vector<Token> & tokens) {\n\tvector<vector<Node> > nodes;\n\tvector<Node> to_check;\n\tint span = tokens.size();\n\tfor (int i = 0; i < tokens.size(); ++ i) {\n\t\tif (tokens[i].type == \"indent\") {\n\t\t\t-- span;\n\t\t\tcontinue;\n\t\t}\n\t\tNode node;\n\t\tnode.type = tokens[i].type;\n\t\tnode.index = nodes.size();\n\t\tnode.span = 1;\n\t\tnode.token = tokens[i];\n\t\tnodes.push_back(vector<Node>());\n\t\tto_check.push_back(node);\n\t}\n\twhile (to_check.size() > 0) {\n\t\tNode first = to_check[to_check.size() - 1];\n\t\t// cout << \"--->\" << '\\\t' << first << endl;\n\t\tto_check.pop_back();\n\t\tvector<Node> node_list;\n\t\tnode_list.push_back(first);\n\t\tnodes[first.index].push_back(first);\n\t\tcheck_sequences(nodes, node_list, first.index, to_check);\n\t}\n\tint result = -1;\n\tfor (int i = 0; i < nodes[0].size(); ++ i) {\n\t\tif (nodes[0][i].span == span) \n\t\t\tresult = i;\n\t}\n\tif (result == -1) {\n\t\tstringstream ss;\n\t\tss << \"Syntax error in line: \" << (lineno + 1);\n\t\tthrow runtime_error(ss.str());\n\t}\n\treturn nodes[0][result];\n}\n\nstruct Line\n{\n\tint level;\n\tNode node;\n\tvector<Line> children;\n};\n\nvoid print_line(ostream & out, const Line & line, int indent=0) {\n\t// for (int i = 0; i < indent; ++ i) out << '\\\t';\n\tif (line.children.size() == 0) {\n\t\t// out << \"( \" << line.node.type << \"@\" << line.level << \" _ )\";\n\t\tout << \"( \" << line.node.type << \" _ )\";\n\t}\n\telse {\n\t\t// out << \"( \" << line.node.type << \"@\" << line.level << \" \";\n\t\tout << \"( \" << line.node.type;\n\t\tfor (int i = 0; i < line.children.size(); ++ i) {\n\t\t\tprint_line(out, line.children[i], indent + 1);\n\t\t}\n\t\tout << \" )\";\n\t}\n}\n\nostream & operator << (ostream & out, const Line & line) {\n\tprint_line(out, line, 0);\n\treturn out;\n}\n\nvoid indent_error(const Token & indent) {\n\tstringstream ss;\n\tss << \"Inconsistent indentation at line: \" << indent.line;\n\tthrow runtime_error(ss.str());\n}\n\nvoid get_tree(vector<string> & lines, Line & tree) {\n\tvector<vector<Token> > tokens;\n\tvector<Node> nodes;\n\tvector<Token> indents;\n\tget_tokens(lines, tokens);\n\tfor (int i = 0; i < tokens.size(); ++ i) {\n\t\tif (tokens[i].size() > 0) {\n\t\t\tif (tokens[i][0].type == \"indent\")\n\t\t\t\tindents.push_back(tokens[i][0]);\n\t\t\telse\n\t\t\t\tindents.push_back(Token());\n\t\t\tnodes.push_back(parse_line(i, tokens[i]));\n\t\t}\n\t}\n\ttree.level = 0;\n\ttree.node.type = \"__main__\";\n\ttree.node.token.text = \"__main__\";\n\ttree.node.index = 0;\n\ttree.node.span = 0;\n\tvector<Line *> stack;\n\tvector<string> indent_stack;\n\tstack.push_back(&tree);\n\tindent_stack.push_back(\"\");\n\tfor (int i = 0; i < nodes.size(); ++ i) {\n\t\tstring last_indent = indent_stack[indent_stack.size() - 1];\n\t\tLine next;\n\t\tnext.node = nodes[i];\n\t\tLine * parent = stack[stack.size() - 1];\n\t\tif (indents[i].text == last_indent) {\n\t\t\tnext.level = parent->level + 1;\n\t\t\tparent->children.push_back(next);\n\t\t}\n\t\telse {\n\t\t\tif (startswith(indents[i].text, last_indent)) {\n\t\t\t\tindent_stack.push_back(indents[i].text);\n\t\t\t\tif (parent->children.size() == 0) indent_error(indents[i]);\n\t\t\t\tparent = &parent->children[parent->children.size() - 1];\n\t\t\t\tstack.push_back(parent);\n\t\t\t\tnext.level = parent->level + 1;\n\t\t\t\tparent->children.push_back(next);\n\t\t\t}\n\t\t\telse {\n\t\t\t\twhile (true) {\n\t\t\t\t\tif (indents[i].text == last_indent) {\n\t\t\t\t\t\tnext.level = parent->level + 1;\n\t\t\t\t\t\tparent->children.push_back(next);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (startswith(last_indent, indents[i].text)) {\n\t\t\t\t\t\tindent_stack.pop_back();\n\t\t\t\t\t\tlast_indent = indent_stack[indent_stack.size() - 1];\n\t\t\t\t\t\tstack.pop_back();\n\t\t\t\t\t\tif (stack.size() == 0) indent_error(indents[i]);\n\t\t\t\t\t\tparent = stack[stack.size() - 1];\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tindent_error(indents[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid print_nodes(ostream & out, const Line & line) {\n\tif (line.node.type != \"__main__\")\n\t\tout << line.node << endl;\n\tif (line.children.size() == 0) return;\n\tfor (int i = 0; i < line.children.size(); ++ i) {\n\t\tprint_nodes(out, line.children[i]);\n\t}\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid optim_exp(Node & node) {\n\tif (node.children.size() == 1) {\n\t\tNode child = node.children[0];\n\t\tnode = child;\n\t}\n\telse if (node.children.size() == 3 && node.children[0].type == \"(\" && node.children[2].type == \")\") {\n\t\tNode child = node.children[1];\n\t\tnode = child;\n\t}\n\tif (startswith(node.type, \"expression\"))\n\t\tnode.type = \"expression\";\n}\n\nvoid optim(Node & node) {\n\tfor (int i = 0; i < node.children.size(); ++ i)\n\t\toptim(node.children[i]);\n\tif (startswith(node.type, \"expression\"))\n\t\toptim_exp(node);\n\tif (startswith(node.type, \"operator_\"))\n\t\tnode = node.children[0];\n}\n\nvoid optim(Line & line) {\n\toptim(line.node);\n\tfor (int i = 0; i < line.children.size(); ++ i) {\n\t\toptim(line.children[i]);\n\t}\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#define foreach(type, item, vec) for (vector<type>::iterator item=vec.begin(); item != vec.end(); ++ item)\n\nvoid assert_true(bool test, const string & err_msg) {\n\tif (! test) throw runtime_error(err_msg);\n}\n\n//////////\n// TYPES\n\nstruct Variable\n{\n\tstring type;\n\tvirtual void print() {\n\t\tcout << type;\n\t}\n\tvirtual Variable * copy() {\n\t\tstringstream ss;\n\t\tss << \"'\" << type << \".copy' is not implemented\";\n\t\tassert_true(false, ss.str());\n\t\treturn 0;\n\t}\n\tvirtual Variable * __eq__(Variable * op) {\n\t\tstringstream ss;\n\t\tss << \"'\" << type << \".__eq__' is not implemented\";\n\t\tassert_true(false, ss.str());\n\t\treturn 0;\n\t}\n};\n\nstruct Int : public Variable\n{\n\tint intValue;\n\tInt(int value) {\n\t\ttype = \"int\";\n\t\tintValue = value;\n\t}\n\tvoid print() {\n\t\tcout << intValue;\n\t}\n\tvirtual Variable * copy() {\n\t\treturn new Int(intValue);\n\t}\n\tVariable * __add__(Int * op) {\n\t\tInt * ret = (Int *)copy();\n\t\tret->intValue += op->intValue;\n\t\treturn ret;\n\t}\n\tVariable * __mul__(Int * op) {\n\t\tInt * ret = (Int *)copy();\n\t\tret->intValue *= op->intValue;\n\t\treturn ret;\n\t}\n\tVariable * __mod__(Int * op) {\n\t\tInt * ret = (Int *)copy();\n\t\tret->intValue = ret->intValue % op->intValue;\n\t\treturn ret;\n\t}\n\tVariable * __eq__(Variable * op) {\n\t\tInt * op2 = (Int *)op;\n\t\treturn new Int(intValue == op2->intValue);\n\t}\n};\n\nstruct Bool : public Variable\n{\n\tbool boolValue;\n\tBool(bool value) {\n\t\ttype = \"bool\";\n\t\tboolValue = value;\n\t}\n\tvoid print() {\n\t\tif (boolValue) cout << \"True\";\n\t\telse cout << \"False\";\n\t}\n\tvirtual Variable * copy() {\n\t\treturn new Bool(boolValue);\n\t}\n\tVariable * __and__(Bool * op) {\n\t\tBool * ret = (Bool *)copy();\n\t\tret->boolValue = ret->boolValue && op->boolValue;\n\t\treturn ret;\n\t}\n\tVariable * __or__(Bool * op) {\n\t\tBool * ret = (Bool *)copy();\n\t\tret->boolValue = ret->boolValue || op->boolValue;\n\t\treturn ret;\n\t}\n\tVariable * __eq__(Variable * op) {\n\t\tBool * op2 = (Bool *)op;\n\t\treturn new Bool(boolValue == op2->boolValue);\n\t}\n};\n\n\nstruct Str : public Variable\n{\n\tstring strValue;\n\tStr(string value) {\n\t\ttype = \"str\";\n\t\tstrValue = value;\n\t}\n\tvoid print() {\n\t\tbool was_backslash = false;\n\t\tfor (int i = 1; i < strValue.size() - 1; ++ i) {\n\t\t\tchar c = strValue[i];\n\t\t\tif (was_backslash) {\n\t\t\t\tstring err_msg = \"Unknown sequence '\\\\?'\";\n\t\t\t\tswitch (c) {\n\t\t\t\t\tcase '\\\\': cout << '\\\\'; break;\n\t\t\t\t\tcase 'r': cout << '\\r'; break;\n\t\t\t\t\tcase 't': cout << '\\t'; break;\n\t\t\t\t\tcase 'n': cout << '\\n'; break;\n\t\t\t\t\tcase '\"': cout << '\"'; break;\n\t\t\t\t\tdefault: err_msg[err_msg.size() - 2] = c; assert_true(false, err_msg);\n\t\t\t\t}\n\t\t\t\twas_backslash = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (c == '\\\\') was_backslash = true;\n\t\t\t\telse cout << c;\n\t\t\t}\n\t\t}\n\t}\n\tvirtual Variable * copy() {\n\t\treturn new Str(strValue);\n\t}\n};\n\nstruct Function : public Variable\n{\n\tLine * line;\n\tFunction(Line & value) {\n\t\ttype = \"function\";\n\t\tline = &value;\n\t}\n\tvoid print() {\n\t\tcout << type << '\\t';\n\t\tprint_node(cout, line->node);\n\t}\n};\n\nstruct Pointer : public Variable\n{\n\tvoid * pointer;\n\tPointer(void * value) {\n\t\ttype = \"pointer\";\n\t\tpointer = value;\n\t}\n};\n\nstruct Variables\n{\n\tHashTable<string, Variable*> map;\n\n\tvoid print() {\n\t\tvector<string> names = map.getKeys();\n\t\tforeach (string, name, names) {\n\t\t\tcout << *name << '\\t';\n\t\t\tmap.get(*name)->print();\n\t\t\tcout << endl;\n\t\t}\n\t}\n\n\tbool hasVariable(const string & name) {\n\t\treturn map.containsKey(name);\n\t}\n\n\tvoid assertVariable(const string & name) {\n\t\tstringstream ss;\n\t\tss << \"Variable '\" << name << \"' is undefined\"; \n\t\tassert_true(map.containsKey(name), ss.str());\t\t\n\t}\n\n\tvoid assertType(const string & name, const string & type) {\n\t\tstringstream ss;\n\t\tss << \"Require '\" << type << \"', got '\" << map.get(name)->type << \"' \"; \n\t\tassert_true(map.get(name)->type == type, ss.str());\t\t\n\t}\n\n\tstring getType(const string & name) {\n\t\tassertVariable(name);\n\t\treturn map.get(name)->type;\n\t}\n\n\tvoid delVariable(const string & name, bool del=true) {\n\t\tassertVariable(name);\n\t\tif (del) delete map.get(name);\n\t\tmap.remove(name);\n\t}\n\n\tvoid setVariable(const string & name, Variable * v) {\n\t\tif (map.containsKey(name))\n\t\t\tdelete map.get(name);\n\t\tmap.put(name, v);\n\t}\n\n\tVariable * getVariable(const string & name) {\n\t\tassertVariable(name);\n\t\treturn map.get(name);\n\t}\n\n\tvoid releaseAll() {\n\t\tvector<string> names = map.getKeys();\n\t\tforeach (string, name, names)\n\t\t\tdelVariable(*name);\n\t}\n\n};\n\nstruct Context\n{\n\tstring owner;\n\tVariables & global_variables;\n\tVariables & local_variables;\n\tHashTable<string, int> global_used;\n\tvector<int> lines_running;\n\n\tContext(const string & owner_, Variables & global_variables_, Variables & local_variables_) : \n\t\towner(owner_), global_variables(global_variables_), local_variables(local_variables_) {}\n\n\tbool is_global(const string & name, bool is_assign) {\n\t\tif (local_variables.hasVariable(name)) return false;\n\t\tif (global_used.containsKey(name)) return true;\n\t\tif (is_assign) return false;\n\t\tglobal_variables.assertVariable(name);\n\t\tglobal_used.put(name, 0);\n\t\treturn true;\n\t}\n\n\tVariable * getVariable(const string & name) {\n\t\tif (is_global(name, false))\n\t\t\treturn global_variables.getVariable(name);\n\t\telse\n\t\t\treturn local_variables.getVariable(name);\n\t}\n\n\tvoid setVariable(const string & name, Variable * v) {\n\t\tif (is_global(name, true))\n\t\t\treturn global_variables.setVariable(name, v);\n\t\telse\n\t\t\treturn local_variables.setVariable(name, v);\n\t}\n\n};\n\n////////////////////\n// FUNCTIONS\n\nvoid run_builtin_range(Context & context) {\n\tVariable * v = context.local_variables.getVariable(\"n\");\n\tassert_true(v->type == \"int\", \"'range' requires a single 'int' argument\");\n\tint n = ((Int *)v)->intValue;\n\tint level = 2;\n\tif (context.lines_running.size() == level)\n\t\tcontext.lines_running.push_back(0);\n\telse\n\t\t++ context.lines_running[level];\n\tif (context.lines_running[level] >= n) return;\n\tcontext.local_variables.setVariable(\"$ret\", new Int(context.lines_running[level]));\n}\n\nint max_print_calls = 1000;\n\nvoid run_builtin_print(Context & context) {\n\tassert_true(-- max_print_calls > 0, \"Exceeds max_print_calls == 100\");\n\tVariable * v = context.local_variables.getVariable(\"n\");\n\tif (v == 0) cout << \"None\";\n\telse v->print();\n\tcout << endl;\n}\n\nvoid run_builtin(const string & function_name, Context & context) {\n\tif (function_name == \"range\") {\n\t\trun_builtin_range(context);\n\t}\n\telse if (function_name == \"print\") {\n\t\trun_builtin_print(context);\n\t}\n\telse {\n\t\tstringstream ss;\n\t\tss << \"Unknow builtin: \" << function_name << endl;\n\t\tassert_true(false, ss.str());\n\t}\n}\n\nvoid register_builtins(vector<string> & lines, Line & tree, Variables & global_variables) {\n\tget_tree(lines, tree);\n\toptim(tree);\n\tforeach (Line, line, tree.children) {\n\t\tstringstream ss;\n\t\tss << \"Invalid line in 'builtins.py: \" << line->node.type << endl;\n\t\tassert_true(line->node.type == \"function_def\", ss.str());\n\t\tline->node.type = \"builtin\";\n\t\tstring function_name = line->node.children[1].token.text;\n\t\tglobal_variables.setVariable(function_name, new Function(*line));\n\t}\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid run_lines(vector<Line> & lines, Context & context);\nvoid run_line(Line & line, Context & context);\nVariable * run_exp(Node & exp, Context & context);\n\nLine & get_function(const string & function_name, Context & context) {\n\tVariable * v = context.getVariable(function_name);\n\tstringstream ss;\n\tss << \"Not a function: \" << function_name;\n\tassert_true(v->type == \"function\" || v->type == \"builtin\", ss.str());\n\tFunction * func_var = (Function *)v;\n\treturn *(func_var->line);\n}\n\nvoid init_function_parameters(Node & func_node, Context & callee_context, Node & call_node, Context & caller_context) {\n\tint num_args = call_node.children.size() - 3;\n\tint num_params = func_node.children.size() - 5;\n\tstringstream ss;\n\tss << \"Function '\" << call_node.children[0].token.text << \"' arguments not agree\" << endl;\n\tss << \"\\tCaller gives \" << num_args << \" at line: \" << (func_node.children[0].token.line + 1) << endl;\n\tss << \"\\tCallee requires \" << num_params << \" at line: \" << (call_node.children[0].token.line + 1) << endl;\n\tassert_true(num_args == num_params, ss.str());\n\tfor (int i = 0; i < num_params; ++ i) {\n\t\tNode & arg_exp = call_node.children[2 + i];\n\t\tVariable * arg_value = run_exp(arg_exp, caller_context);\n\t\tstring parameter_name = func_node.children[3 + i].token.text;\n\t\tcallee_context.local_variables.setVariable(parameter_name, arg_value);\n\t}\t\n}\n\nVariable * run_function(Node & call_node, Context & context) {\n\tstring function_name = call_node.children[0].token.text;\n\tLine & func_line = get_function(function_name, context);\n\tVariables func_local_variables;\n\tContext func_context(function_name, context.global_variables, func_local_variables);\n\tinit_function_parameters(func_line.node, func_context, call_node, context);\n\t// func_local_variables.print();\n\tif (func_line.node.type == \"builtin\" && func_line.children.size() == 1 && func_line.children[0].node.type == \"pass_statement\")\n\t\trun_builtin(function_name, func_context);\n\telse {\n\t\twhile (func_context.lines_running.size() <= func_line.level)\n\t\t\tfunc_context.lines_running.push_back(-100);\n\t\trun_lines(func_line.children, func_context);\n\t}\n\tVariable * ret = 0;\n\tif (func_local_variables.hasVariable(\"$ret\")) {\n\t\tret = func_local_variables.getVariable(\"$ret\");\n\t\tfunc_local_variables.delVariable(\"$ret\", false);\n\t}\n\tfunc_local_variables.releaseAll();\n\treturn ret;\n}\n\nvoid pass_result(Context & from, Context & to, const string & name) {\n\tVariable * ret = from.local_variables.getVariable(\"$ret\");\n\tfrom.local_variables.delVariable(\"$ret\", false);\n\tto.local_variables.setVariable(name, ret);\n}\n\nContext * init_generator_context(Context & context, Line & gen_def_line, Node & gen_call_node) {\n\tVariables * local_variables = new Variables();\n\tstring gen_func_name = gen_call_node.children[0].token.text;\n\tContext * gen_context = new Context(gen_func_name, context.global_variables, *local_variables);\n\tinit_function_parameters(gen_def_line.node, *gen_context, gen_call_node, context);\n\tcontext.local_variables.setVariable(\"$gen\", new Pointer(gen_context));\n\twhile (gen_context->lines_running.size() <= gen_def_line.level)\n\t\tgen_context->lines_running.push_back(-100);\n\treturn gen_context;\n}\n\nvoid release_generator_context(Context & context) {\n\tPointer * v = (Pointer *)context.local_variables.getVariable(\"$gen\");\n\tContext * gen = (Context *)v->pointer;\n\tcontext.local_variables.delVariable(\"$gen\");\n\tgen->local_variables.releaseAll();\n\tdelete &(gen->local_variables);\n\tdelete gen;\n}\n\nvoid print_int_vector(vector<int> & vec) {\n\tfor (int i = 0; i < vec.size(); ++ i) cout << \" \" << vec[i];\n\tcout << endl;\n}\n\nvoid run_for_statement(Line & for_line, Context & context) {\n\tstring loop_variable_name = for_line.node.children[1].token.text;\n\tNode & gen_node = for_line.node.children[3];\n\tif (gen_node.type == \"function_call\") {\n\t\tstring gen_func_name = gen_node.children[0].token.text;\n\t\tLine & gen_def_line = get_function(gen_func_name, context);\n\t\tContext * gen_context = 0;\n\t\tif (context.local_variables.hasVariable(\"$gen\")) {\n\t\t\tPointer * gen = (Pointer *)context.local_variables.getVariable(\"$gen\");\n\t\t\tgen_context = (Context *)(gen->pointer);\n\t\t\tstringstream ss;\n\t\t\tss << \"Inconsistent generator context: required '\" << gen_func_name << \"', got '\" << gen_context->owner << \"'\";\n\t\t\tassert_true(gen_context->owner == gen_func_name, ss.str());\n\t\t}\n\t\telse \n\t\t\tgen_context = init_generator_context(context, gen_def_line, gen_node);\n\t\tbool done = false;\n\t\twhile (true) {\n\t\t\tif (gen_def_line.node.type == \"builtin\" && gen_def_line.children.size() == 1 && gen_def_line.children[0].node.type == \"pass_statement\")\n\t\t\t\trun_builtin(gen_func_name, *gen_context);\n\t\t\telse\n\t\t\t\trun_lines(gen_def_line.children, *gen_context);\n\t\t\tif (! gen_context->local_variables.hasVariable(\"$ret\")) {\n\t\t\t\tdone = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpass_result(*gen_context, context, loop_variable_name);\n\t\t\trun_lines(for_line.children, context);\n\t\t\tif (context.local_variables.hasVariable(\"$ret\")) break;\n\t\t}\n\t\tif (done) release_generator_context(context);\n\t}\n\telse {\n\t\tstringstream ss;\n\t\tss << \"Unknow generator type: \" << gen_node.type;\n\t\tassert_true(false, ss.str());\n\t}\n}\n\nVariable * run_id(Node & exp, Context & context) {\n\tstring name = exp.token.text;\n\tif (context.local_variables.hasVariable(name))\n\t\treturn context.local_variables.getVariable(name)->copy();\n\tif (context.global_variables.hasVariable(name))\n\t\treturn context.global_variables.getVariable(name)->copy();\n\tstringstream ss;\n\tss << \"Undefined variable: \" << name << endl;\n\tassert_true(false, ss.str());\n\treturn 0;\n}\n\nvoid check_op_type(const string & op, const string & required_type, const string & type) {\n\tstringstream ss;\n\tss << \"The operand of \" << op << \" must be '\" << required_type <<\"' instead of '\" << type << \"'\" << endl;\n\tassert_true(required_type == type, ss.str());\n}\n\nVariable * run_expression(Node & exp, Context & context) {\n\tstring op = \"?\";\n\tif (exp.children.size() == 3) {\n\t\top = exp.children[1].token.text;\n\t\tVariable * left = run_exp(exp.children[0], context);\n\t\tVariable * right = run_exp(exp.children[2], context);\n\t\tif (op == \"+\") {\n\t\t\tcheck_op_type(op, \"int\", left->type);\n\t\t\tcheck_op_type(op, \"int\", right->type);\n\t\t\treturn ((Int *)left)->__add__((Int *)right);\n\t\t}\n\t\telse if (op == \"*\") {\n\t\t\tcheck_op_type(op, \"int\", left->type);\n\t\t\tcheck_op_type(op, \"int\", right->type);\n\t\t\treturn ((Int *)left)->__mul__((Int *)right);\n\t\t}\n\t\telse if (op == \"%\") {\n\t\t\tcheck_op_type(op, \"int\", left->type);\n\t\t\tcheck_op_type(op, \"int\", right->type);\n\t\t\treturn ((Int *)left)->__mod__((Int *)right);\n\t\t}\n\t\telse if (op == \"and\") {\n\t\t\tcheck_op_type(op, \"bool\", left->type);\n\t\t\tcheck_op_type(op, \"bool\", right->type);\n\t\t\treturn ((Bool *)left)->__and__((Bool *)right);\n\t\t}\n\t\telse if (op == \"or\") {\n\t\t\tcheck_op_type(op, \"bool\", left->type);\n\t\t\tcheck_op_type(op, \"bool\", right->type);\n\t\t\treturn ((Bool *)left)->__or__((Bool *)right);\n\t\t}\n\t\telse if (op == \"==\") {\n\t\t\tcheck_op_type(op, left->type, right->type);\n\t\t\treturn left->__eq__(right);\n\t\t}\n\t}\n\telse if (exp.children.size() == 2) {\n\t\top = exp.children[0].token.text;\n\t}\n\tstringstream ss;\n\tss << \"Undefined operator: \" << op << endl;\n\tassert_true(false, ss.str());\n\treturn 0;\n}\n\nVariable * run_exp(Node & exp, Context & context) {\n\tif (exp.type == \"int\") {\n\t\tstringstream ss(exp.token.text);\n\t\tint intValue;\n\t\tss >> intValue;\n\t\treturn new Int(intValue);\n\t}\n\telse if (exp.type == \"str\") {\n\t\treturn new Str(exp.token.text);\n\t}\n\telse if (exp.type == \"True\") {\n\t\treturn new Bool(true);\n\t}\n\telse if (exp.type == \"False\") {\n\t\treturn new Bool(false);\n\t}\n\telse if (exp.type == \"id\") {\n\t\treturn run_id(exp, context);\n\t}\n\telse if (exp.type == \"None\") {\n\t\treturn 0;\n\t}\n\telse if (exp.type == \"function_call\") {\n\t\treturn run_function(exp, context);\n\t}\n\telse if (exp.type == \"expression\") {\n\t\treturn run_expression(exp, context);\n\t}\n\telse {\n\t\tstringstream ss;\n\t\tss << \"Unknow expression type: \" << exp.type << endl << exp << endl;\n\t\tassert_true(false, ss.str());\n\t}\n\treturn 0;\n}\n\nvoid run_yield_statement(Line & line, Context & context) {\n\tVariable * v = run_exp(line.node.children[1], context);\n\tassert_true(v != 0, \"\");\n\tcontext.local_variables.setVariable(\"$ret\", v);\n\t++ context.lines_running[line.level];\n}\n\nvoid run_return_statement(Line & line, Context & context) {\n\tVariable * v = run_exp(line.node.children[1], context);\n\tcontext.local_variables.setVariable(\"$ret\", v);\n\tcontext.lines_running.clear();\n}\n\nvoid run_assign_statement(Line & line, Context & context) {\n\tstring variable_name = line.node.children[0].token.text;\n\tVariable * v = run_exp(line.node.children[2], context);\n\tcontext.setVariable(variable_name, v);\n}\n\nbool is_true(Variable * v) {\n\tif (v == 0) {\n\t\treturn false;\n\t}\n\tif (v->type == \"bool\") {\n\t\treturn ((Bool *)v)->boolValue;\n\t}\n\telse if (v->type == \"int\") {\n\t\treturn ((Int *)v)->intValue != 0;\n\t}\n\tstringstream ss;\n\tss << \"Unknown type for condition: \" << v->type;\n\tassert_true(false, ss.str());\n\treturn false;\n}\n\nvoid run_if_statement(Line & line, Context & context) {\n\tif (context.lines_running.size() > line.level + 1) {\n\t\trun_lines(line.children, context);\n\t\treturn;\n\t}\n\tVariable * v = run_exp(line.node.children[1], context);\n\tstringstream ss;\n\tss << \"$if\" << line.level;\n\tcontext.setVariable(ss.str(), v);\n\tif (is_true(v)) {\n\t\trun_lines(line.children, context);\n\t}\n}\n\nvoid run_else_statement(Line & line, Context & context) {\n\tif (context.lines_running.size() > line.level + 1) {\n\t\trun_lines(line.children, context);\n\t\treturn;\n\t}\n\tstringstream ss;\n\tss << \"$if\" << line.level;\n\tstring condition_name = ss.str();\n\tassert_true(context.local_variables.hasVariable(condition_name), \"Dangling else-statement\");\n\tVariable * v = context.local_variables.getVariable(condition_name);\n\tif (! is_true(v)) {\n\t\trun_lines(line.children, context);\n\t}\n\tcontext.local_variables.delVariable(condition_name);\n}\n\nvoid run_line(Line & line, Context & context) {\n\tif (line.node.type == \"comment\") {\n\t}\n\telse if (line.node.type == \"function_def\") {\n\t\tstring function_name = line.node.children[1].token.text;\n\t\tcontext.local_variables.setVariable(function_name, new Function(line));\n\t}\n\telse if (line.node.type == \"function_call\") {\n\t\trun_function(line.node, context);\n\t}\n\telse if (line.node.type == \"for_statement\") {\n\t\trun_for_statement(line, context);\n\t}\n\telse if (line.node.type == \"yield_statement\") {\n\t\trun_yield_statement(line, context);\n\t}\n\telse if (line.node.type == \"return_statement\") {\n\t\trun_return_statement(line, context);\n\t}\n\telse if (line.node.type == \"assign_statement\") {\n\t\trun_assign_statement(line, context);\n\t}\n\telse if (line.node.type == \"if_statement\") {\n\t\trun_if_statement(line, context);\n\t}\n\telse if (line.node.type == \"else_statement\") {\n\t\trun_else_statement(line, context);\n\t}\n\telse {\n\t\tstringstream ss;\n\t\tss << \"Unknow line type: \" << line.node.type;\n\t\tassert_true(false, ss.str());\n\t}\n}\n\nint get_def_line(Line & line) {\n\tNode * node = &(line.node);\n\twhile (node->children.size() > 0)\n\t\tnode = &(node->children[0]);\n\treturn node->token.line;\n}\n\nvoid run_lines(vector<Line> & lines, Context & context) {\n\tint level = lines[0].level;\n\tstringstream ss;\n\tss << \"Line: \" << get_def_line(lines[0]) <<\" Incorrect level state: \" << context.lines_running.size() << \", requires >= \" << level;\n\tassert_true(context.lines_running.size() >= level, ss.str());\n\tif (context.lines_running.size() == level) {\n\t\tcontext.lines_running.push_back(0);\n\t}\n\tstringstream ss2;\n\tss2 << \"Line: \" << get_def_line(lines[0]) <<\" Incorrect level step: \" << context.lines_running[level];\n\tassert_true(context.lines_running[level] >= 0, ss2.str());\n\twhile (context.lines_running[level] < lines.size()) {\n\t\trun_line(lines[context.lines_running[level]], context);\n\t\tif (context.local_variables.hasVariable(\"$ret\")) break;\n\t\t++ context.lines_running[level];\n\t}\n\tif (context.lines_running[level] == lines.size())\n\t\tcontext.lines_running.pop_back();\n}\n\nvoid run(vector<string> & lib_lines, vector<string> & lines) {\n\t// Variables global_variables;\n\t// Line builtins_tree;\n\t// register_builtins(lib_lines, builtins_tree, global_variables);\n\n\tLine tree;\n\tget_tree(lines, tree);\n\toptim(tree);\n\tprint_nodes(cout, tree);\n\tcout << tree << endl;\n\t// Context global_context(\"__main__\", global_variables, global_variables);\n\t// while (global_context.lines_running.size() <= tree.level)\n\t// \tglobal_context.lines_running.push_back(-100);\n\t// run_lines(tree.children, global_context);\n\t// global_variables.releaseAll();\n}\n\nstring builtins = \"def print(n):\\n\\tpass\\n\\ndef range(n):\\n\\tpass\";\n\nint main() {\n\ttry {\n\t\tvector<string> lib_lines;\n\t\tvector<string> lines;\n\t\tstringstream ss(builtins);\n\t\tread_lines(ss, lib_lines);\n\t\tread_lines(cin, lines);\n\t\trun(lib_lines, lines);\n\t}\n\tcatch (runtime_error & ex) {\n\t\tcout << ex.what() << endl;\n\t}\n}",
            "print('''def test_loop(n):\n\tfor i in range(n):\n\t\tprint(123 + i)\n\ndef test_condition(c):\n\tif c:\n\t\tprint(\"yes\")\n\telse:\n\t\tprint(\"no\")\n\ntest_loop(10)\ntest_condition(True)''')\n\n",
            1585713600,
            1585713600
        ],
        [
            "15.3 (C++)",
            "Please modify the simple Python compiler as follows:\n<ul>\n<li>Combine all CPP file into a single file</li>\n<li>Input from STDIO instead of from a Python file</li>\n<li>Load library from an internal string instead of from \"lib/builtins.py\"</li>\n</ul>\n\n<b>EXAMPLE INPUT</b>\n<pre>\ndef test_loop(n):\n\tfor i in range(n):\n\t\tprint(10 - i)\n\ndef test_condition(c):\n\tif c:\n\t\tprint(\"yes\")\n\telse:\n\t\tprint(\"no\")\n\ntest_loop(10)\ntest_condition(True)\n</pre>\n\n<b>EXAMPLE OUTPUT</b>\n<pre>\n( function_def ( def def )( id test_loop )( -LRB- -LRB- )( id n )( -RRB- -RRB- )( : : ) )\n( for_statement ( for for )( id i )( in in )( function_call ( id range )( -LRB- -LRB- )( id n )( -RRB- -RRB- ) )( : : ) )\n( function_call ( id print )( -LRB- -LRB- )( expression ( int 10 )( - - )( id i ) )( -RRB- -RRB- ) )\n( function_def ( def def )( id test_condition )( -LRB- -LRB- )( id c )( -RRB- -RRB- )( : : ) )\n( if_statement ( if if )( id c )( : : ) )\n( function_call ( id print )( -LRB- -LRB- )( str \"yes\" )( -RRB- -RRB- ) )\n( else_statement ( else else )( : : ) )\n( function_call ( id print )( -LRB- -LRB- )( str \"no\" )( -RRB- -RRB- ) )\n( function_call ( id test_loop )( -LRB- -LRB- )( int 10 )( -RRB- -RRB- ) )\n( function_call ( id test_condition )( -LRB- -LRB- )( True True )( -RRB- -RRB- ) )\n( __main__( function_def( for_statement( function_call _ ) ) )( function_def( if_statement( function_call _ ) )( else_statement( function_call _ ) ) )( function_call _ )( function_call _ ) )\n</pre>",
            "#include \"source.cpp\"",
            "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <stdexcept>\nusing namespace std;\n\n#include <cstring>\n\nint operator % (const string & text, int max) {\n\tint code = 0;\n\tfor (int i = 0; i < text.size(); ++ i) {\n\t\tint code1 = text[i];\n\t\tcode1 = code1 << (i * 8 % 24);\n\t\tcode = code ^ code1;\n\t}\n\treturn code % max;\n}\n\nclass NoSuchKeyException {};\n\ntemplate <typename K, typename V>\nclass HashTable\n{\nprivate:\n\t\t\n\tclass Entry\n\t{\n\tpublic:\n\t\tK key;\n\t\tV value;\n\t\tbool isInUse;\n\t\t\n\t\tEntry() {\n\t\t\tisInUse = false;\n\t\t}\n\t};\n\t\n\tEntry * entries;\n\t\n\tint capacity;\n\tint count;\n\t\n\tvoid initialize(int capacity2) {\n\t\tcount = 0;\n\t\tcapacity = capacity2;\n\t\tentries = new Entry[capacity];\n\t}\n\t\n\tvoid assign(const HashTable & map2) {\n\t\tcount = map2.count;\n\t\tcapacity = map2.capacity;\n\t\tentries = new Entry[capacity];\n\t\tfor (int i = 0; i < capacity; ++ i) {\n\t\t\tentries[i] = map2.entries[i];\n\t\t}\n\t}\n\t\npublic:\n\t\n\tHashTable() {\n\t\tinitialize(2);\n\t}\n\t\n\t~HashTable() {\n\t\tdelete [] entries;\n\t}\n\t\n\tHashTable(const HashTable & map2) {\n\t\tassign(map2);\n\t}\n\t\n\tHashTable & operator = (const HashTable & map2) {\n\t\tdelete [] entries;\n\t\tassign(map2);\n\t\treturn (*this);\n\t}\n\t\n\tvoid clear() {\n\t\tdelete [] entries;\n\t\tinitialize(2);\n\t}\n\t\nprivate:\n\t\n\tint hashIndex(const K & key) const {\n\t\treturn key % capacity;\n\t}\n\t\n\tint find(const K & key) const {\n\t\tint index = hashIndex(key);\n\t\twhile (true) {\n\t\t\tif (! entries[index].isInUse) {\n\t\t\t\treturn index;\n\t\t\t}\n\t\t\tif (entries[index].key == key) {\n\t\t\t\treturn index;\n\t\t\t}\n\t\t\tindex = (index + 1) % capacity;\n\t\t}\n\t}\n\t\n\tvoid resize(int capacity2) {\n\t\tEntry * entries0 = entries;\n\t\tint capacity0 = capacity;\n\t\tinitialize(capacity2);\n\t\tfor (int i = 0; i < capacity0; ++ i) {\n\t\t\tif (entries0[i].isInUse) {\n\t\t\t\tput(entries0[i].key, entries0[i].value);\n\t\t\t}\n\t\t}\n\t\tdelete [] entries0;\n\t}\n\t\npublic:\n\t\n\tvoid put(const K & key, const V & value) {\n\t\tint index = find(key);\n\t\tentries[index].value = value;\n\t\tif (entries[index].isInUse) return;\n\t\t\n\t\tentries[index].isInUse = true;\n\t\tentries[index].key = key;\n\t\t\n\t\t++ count;\n\t\tif (count > capacity / 2) {\n\t\t\tresize(capacity * 2);\n\t\t}\n\t}\n\t\n\tV get(const K & key) const {\n\t\tint index = find(key);\n\t\tif (! entries[index].isInUse) {\n\t\t\tthrow NoSuchKeyException();\n\t\t}\n\t\treturn entries[index].value;\n\t}\n\t\n\tbool remove(const K & key) {\n\t\tint index = find(key);\n\t\tif (! entries[index].isInUse) return false;\n\t\tfillNotInUseEntry(index);\n\t\t\n\t\t-- count;\n\t\tif (count < capacity / 4) {\n\t\t\tresize(capacity / 2);\n\t\t}\n\t\treturn true;\n\t}\n\t\nprivate:\n\t\n\tvoid fillNotInUseEntry(int index) {\n\t\tint next = index;\n\t\twhile (true) {\n\t\t\tnext = (next + 1) % capacity;\n\t\t\tif (! entries[next].isInUse) {\n\t\t\t\tentries[index].isInUse = false;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint index0 = hashIndex(entries[next].key);\n\t\t\tif (index < next) {\n\t\t\t\tif (index0 > index &&\n\t\t\t\t\tindex0 <= next) continue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (index0 > index ||\n\t\t\t\t\tindex0 <= next) continue;\n\t\t\t}\n\t\t\tentries[index] = entries[next];\n\t\t\tindex = next;\n\t\t}\n\t}\n\t\npublic:\n\t\n\tbool containsKey(const K & key) const {\n\t\tint index = find(key);\n\t\treturn (entries[index].isInUse);\n\t}\n\t\n\tint size() const {\n\t\treturn count;\n\t}\n\n\tvector<K> getKeys() const {\n\t\tvector<K> vec;\n\t\tfor (int i = 0; i < capacity; ++ i) {\n\t\t\tif (entries[i].isInUse) {\n\t\t\t\tvec.push_back(entries[i].key);\n\t\t\t}\n\t\t}\n\t\treturn vec;\n\t}\n\t\n};\n\n////////////////////////////////////////////////////////////////////////////////\n\nstruct Token\n{\n\tint line;\n\tint pos;\n\tstring type;\n\tstring text;\n};\n\nint operator % (const Token & t, int base) {\n\treturn (t.line * 12347 + t.pos) % base;\n}\n\nbool operator == (const Token & t1, const Token & t2) {\n\treturn t1.line == t2.line && t1.pos == t2.pos;\n}\n\nostream & operator << (ostream & out, const Token & t) {\n\tout << t.line << '\\t' << t.pos << '\\t' << t.type << \"\\t\\\"\" << t.text << \"\\\"\";\n\treturn out;\n}\n\nvoid read_lines(istream & in, vector<string> & lines) {\n\tstring line;\n\twhile (getline(in, line)) {\n\t\tlines.push_back(line);\n\t}\n}\n\nToken make_token(int line, int pos, int len, const string & source, const string & type) {\n\tToken t;\n\tt.line = line;\n\tt.pos = pos;\n\tt.type = type;\n\tt.text = source.substr(pos, len);\n\treturn t;\n}\n\n////////////////////\n// RULES BEGIN\n\nToken find_indent(int line, const string & source) {\n\tint len = 0;\n\tfor (int i = 0; i < source.size(); ++ i) {\n\t\tif (source[i] == '\\t')\n\t\t\t++ len;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn make_token(line, 0, len, source, \"indent\");\n}\n\nToken find_blank(int line, const string & source, int start) {\n\tint len = 0;\n\tfor (int i = start; i < source.size(); ++ i) {\n\t\tif (source[i] == '\\t' || source[i] == ' ')\n\t\t\t++ len;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn make_token(line, start, len, source, \"blank\");\n}\n\nToken find_string(int line, const string & source, int start) {\n\tint len = 0;\n\tbool was_backslash = false;\n\tfor (int i = start; i < source.size(); ++ i) {\n\t\tchar c = source[i];\n\t\tif (i == start) {\n\t\t\tif (c == '\"') ++ len;\n\t\t\telse break;\n\t\t}\n\t\telse {\n\t\t\tif (was_backslash) {\n\t\t\t\tif (c == '\\\\' || c == 'r' || c == 'n' ||\n\t\t\t\t\tc == 't' || c == '\"')\n\t\t\t\t\t++ len;\n\t\t\t\telse break;\n\t\t\t\twas_backslash = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (c == '\"') {\n\t\t\t\t\t++ len;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t++ len;\n\t\t\t\twas_backslash = (c == '\\\\');\n\t\t\t}\n\t\t} \n\t}\n\treturn make_token(line, start, len, source, \"str\");\t\n}\n\nToken find_int(int line, const string & source, int start) {\n\tif (start < source.size()) {\n\t\tif (source[start] == '0' && (start + 1 == source.size() || (source[start + 1] < '0' || source[start + 1] > '9')))\n\t\t\treturn make_token(line, start, 1, source, \"int\");\n\t}\n\tint len = 0;\n\tfor (int i = start; i < source.size(); ++ i) {\n\t\tif ((i != start && source[i] >= '0' && source[i] <= '9' ) ||\n\t\t\t(source[i] >= '1' && source[i] <= '9'))\n\t\t\t++ len;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn make_token(line, start, len, source, \"int\");\t\n}\n\nToken find_id(int line, const string & source, int start) {\n\tint len = 0;\n\tfor (int i = start; i < source.size(); ++ i) {\n\t\tif ((i != start && source[i] >= '0' && source[i] <= '9') ||\n\t\t\t(source[i] >= 'A' && source[i] <= 'Z') ||\n\t\t\t(source[i] >= 'a' && source[i] <= 'z') ||\n\t\t\tsource[i] == '_')\n\t\t\t++ len;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn make_token(line, start, len, source, \"id\");\n}\n\nconst char *keywords[] = {\n\t\"class\", \"def\", \"if\", \"else\", \"for\", \"in\", \"return\", \"yield\", \"and\", \"or\", \"not\", \"pass\",\n\t\"True\", \"False\", \"None\",\n\t\"(\", \")\", \"[\", \"]\", \"{\", \"}\", \":\", \",\", \".\", \n\t\"==\", \">\", \"<\", \"<=\", \">=\", \"!=\", \"=\", \n\t\"+=\", \"-=\", \"*=\", \"/=\", \"//=\", \"%=\", \"&=\", \"^=\", \"|=\", \n\t\"+\", \"-\", \"**\", \"*\", \"//\", \"/\", \"%\", \"&\", \"^\", \"|\"\n};\n\nToken find_keyword(int line, const string & source, int start) {\n\tint keyword = -1;\n\tfor (int i = 0; i < sizeof(keywords) / sizeof(const char *); ++ i) {\n\t\tif (source.compare(start, strlen(keywords[i]), keywords[i]) == 0) {\n\t\t\tkeyword = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (keyword == -1)\n\t\treturn make_token(line, start, 0, source, \"\");\n\treturn make_token(line, start, strlen(keywords[keyword]), source, keywords[keyword]);\t\n}\n\nToken find_comment(int line, const string & source, int start) {\n\tint len = 0;\n\tfor (int i = start; i < source.size(); ++ i) {\n\t\tif (i != start || source[i] == '#')\n\t\t\t++ len;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn make_token(line, start, len, source, \"comment\");\n}\n\n////////////////////\n// RULES END\n\ntypedef Token (* find_function)(int, const string &, int);\n\nvoid add_tokens(HashTable<Token, Token> & tokens, int lineno, const string & line, find_function find, bool can_conflict) {\n\tint start = 0;\n\twhile (start < line.size()) {\n\t\tToken t = find(lineno, line, start);\n\t\tif (t.text.size() > 0) {\n\t\t\tif (can_conflict) {\n\t\t\t\tif (tokens.containsKey(t)) {\n\t\t\t\t\tToken old_t = tokens.get(t);\n\t\t\t\t\tif (old_t.text.size() < t.text.size())\n\t\t\t\t\t\ttokens.put(t, t);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttokens.put(t, t);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (tokens.containsKey(t)) {\n\t\t\t\t\tToken old_t = tokens.get(t);\n\t\t\t\t\tstringstream ss;\n\t\t\t\t\tss << \"Conflicting tokens:\" << endl;\n\t\t\t\t\tss << old_t << endl;\n\t\t\t\t\tss << t << endl;\n\t\t\t\t\tthrow runtime_error(ss.str());\n\t\t\t\t}\n\t\t\t\ttokens.put(t, t);\n\t\t\t}\n\t\t\tstart += t.text.size();\n\t\t}\n\t\telse\n\t\t\t++ start;\n\t}\n}\n\nvoid get_tokens(vector<string> & lines, vector<vector<Token> > & tokens) {\n\tHashTable<Token, Token> all_tokens;\n\tfor (int i = 0; i < lines.size(); ++ i) {\n\t\tToken indent = find_indent(i, lines[i]);\n\t\tif (indent.text.size() > 0)\n\t\t\tall_tokens.put(indent, indent);\n\t\tadd_tokens(all_tokens, i, lines[i], find_string, false);\n\t\tadd_tokens(all_tokens, i, lines[i], find_int, false);\n\t\tadd_tokens(all_tokens, i, lines[i], find_comment, false);\n\t\tadd_tokens(all_tokens, i, lines[i], find_keyword, false);\n\t\tadd_tokens(all_tokens, i, lines[i], find_id, true);\n\t\tadd_tokens(all_tokens, i, lines[i], find_blank, true);\n\t\t// TODO: add more lexical matching functions\n\t}\n\tToken index;\n\tfor (int i = 0; i < lines.size(); ++ i) {\n\t\ttokens.push_back(vector<Token>());\n\t\tindex.line = i;\n\t\tindex.pos = 0;\n\t\twhile (index.pos < lines[i].size()) {\n\t\t\tif (! all_tokens.containsKey(index)) {\n\t\t\t\tstringstream ss;\n\t\t\t\tss << \"Lexical error at line #\" << (index.line + 1) << \" char #\" << index.pos;\n\t\t\t\tthrow runtime_error(ss.str());\n\t\t\t}\n\t\t\tToken t = all_tokens.get(index);\n\t\t\tif (t.type != \"blank\")\n\t\t\t\ttokens[i].push_back(t);\n\t\t\tindex.pos += t.text.size();\n\t\t}\n\t}\n} \n\n////////////////////////////////////////////////////////////////////////////////\n\nstruct Node\n{\n\tint index;\n\tint span;\n\tstring type;\n\tvector<Node> children; // for non-terminal\n\tToken token; // for terminal, as \"indent\" for non-terminal\n};\n\nbool operator == (const Node & n1, const Node & n2) {\n\treturn n1.index == n2.index && n1.span == n2.span && n1.type == n2.type;\n}\n\nstring to_tree_text(string text) {\n\tfor (int i = 0; i < text.size(); ++ i)\n\t\tif (text[i] == ' ') text[i] = '_';\n\tif (text == \"(\") text = \"-LRB-\";\n\tif (text == \")\") text = \"-RRB-\";\n\treturn text;\n}\n\nvoid print_node(ostream & out, const Node & node, int indent=0) {\n\t// for (int i = 0; i < indent; ++ i) out << '\\\t';\n\tif (node.children.size() == 0) {\n\t\tout << \"( \" << to_tree_text(node.type) << ' ' << to_tree_text(node.token.text) << \" )\";\n\t}\n\telse {\n\t\t// out << node.type << \"\\\tindex=\" << node.index << \"\\\tspan=\" << node.span << endl;\n\t\tout << \"( \" << to_tree_text(node.type) << \" \";\n\t\tfor (int i = 0; i < node.children.size(); ++ i) {\n\t\t\tprint_node(out, node.children[i], indent + 1);\n\t\t}\n\t\tout << \" )\";\n\t}\n}\n\nostream & operator << (ostream & out, const Node & node) {\n\tprint_node(out, node, 0);\n\treturn out;\n}\n\n////////////////////\n// RULES BEGIN\n\nvoid make_node(const vector<Node> & node_list, vector<Node> & matched, const string & type, int len) {\n\tif (node_list.size() != len) return;\n\tNode node;\n\tnode.type = type;\n\tfor (int i = 0; i < len; ++ i)\n\t\tnode.children.push_back(node_list[i]);\n\tmatched.push_back(node);\n}\n\nvoid match_function_def(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() < 5) return;\n\tif (node_list[0].type != \"def\") return;\n\tif (node_list[1].type != \"id\") return;\n\tif (node_list[2].type != \"(\") return;\n\tint index = 3;\n\twhile (node_list[index].type == \"id\") {\n\t\t++ index;\n\t\tif (node_list.size() > index && node_list[index].type == \",\") {\n\t\t\t++ index;\n\t\t\tif (node_list.size() <= index || node_list[index].type != \"id\") return;\n\t\t}\n\t\telse break;\n\t}\n\tif (node_list.size() <= index || node_list[index].type != \")\") return;\n\t++ index;\n\tif (node_list.size() <= index || node_list[index].type != \":\") return;\n\t++ index;\n\tmake_node(node_list, matched, \"function_def\", index);\n}\n\nvoid match_expression(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() == 1) {\n\t\tif (node_list[0].type == \"function_call\" ||\n\t\t\tnode_list[0].type == \"str\" ||\n\t\t\tnode_list[0].type == \"id\" ||\n\t\t\tnode_list[0].type == \"int\" ||\n\t\t\tnode_list[0].type == \"None\" ||\n\t\t\tnode_list[0].type == \"True\" ||\n\t\t\tnode_list[0].type == \"False\")\n\t\t{\n\t\t\tmake_node(node_list, matched, \"expression1\", 1); // term\n\t\t}\n\t\telse if (node_list[0].type == \"expression1\") {\n\t\t\tmake_node(node_list, matched, \"expression2\", 1); // factor\n\t\t}\n\t\telse if (node_list[0].type == \"expression2\") {\n\t\t\tmake_node(node_list, matched, \"expression3\", 1); // exp\n\t\t}\n\t\telse if (node_list[0].type == \"expression3\") {\n\t\t\tmake_node(node_list, matched, \"expression4\", 1); // cmp\n\t\t}\n\t\telse if (node_list[0].type == \"expression4\") {\n\t\t\tmake_node(node_list, matched, \"expression5\", 1); // and\n\t\t}\n\t\telse if (node_list[0].type == \"expression5\") {\n\t\t\tmake_node(node_list, matched, \"expression\", 1); // or\n\t\t}\n\t}\n\tif (node_list.size() == 3) {\n\t\tif (node_list[0].type == \"(\" && node_list[1].type == \"expression\" && node_list[2].type == \")\") {\n\t\t\tmake_node(node_list, matched, \"expression1\", 3); // term\n\t\t}\n\t\telse if ((node_list[0].type == \"expression1\" || node_list[0].type == \"expression2L\") && node_list[1].type == \"operator_mul\" && node_list[2].type == \"expression1\") {\n\t\t\tmake_node(node_list, matched, \"expression2\", 3); // factor\n\t\t\tmake_node(node_list, matched, \"expression2L\", 3);\n\t\t}\n\t\telse if ((node_list[0].type == \"expression2\" || node_list[0].type == \"expression3L\") && node_list[1].type == \"operator_add\" && node_list[2].type == \"expression2\") {\n\t\t\tmake_node(node_list, matched, \"expression3\", 3); // exp\n\t\t\tmake_node(node_list, matched, \"expression3L\", 3);\n\t\t}\n\t\telse if ((node_list[0].type == \"expression3\" || node_list[0].type == \"expression4L\") && node_list[1].type == \"operator_cmp\" && node_list[2].type == \"expression3\") {\n\t\t\tmake_node(node_list, matched, \"expression4\", 3); // cmp\n\t\t\tmake_node(node_list, matched, \"expression4L\", 3);\n\t\t}\n\t\telse if ((node_list[0].type == \"expression4\" || node_list[0].type == \"expression5L\") && node_list[1].type == \"operator_and\" && node_list[2].type == \"expression4\") {\n\t\t\tmake_node(node_list, matched, \"expression5\", 3); // and\n\t\t\tmake_node(node_list, matched, \"expression5L\", 3);\n\t\t}\n\t\telse if ((node_list[0].type == \"expression5\" || node_list[0].type == \"expression6L\") && node_list[1].type == \"operator_or\" && node_list[2].type == \"expression5\") {\n\t\t\tmake_node(node_list, matched, \"expression\", 3); // and\n\t\t\tmake_node(node_list, matched, \"expression6L\", 3);\n\t\t}\n\t}\n}\n\nvoid match_function_call(const vector<Node> & node_list, vector<Node> & matched, int start=0) {\n\tif (node_list.size() < 4) return;\n\tif (node_list[0].type != \"id\") return;\n\tif (node_list[1].type != \"(\") return;\n\tint index = 2;\n\twhile (node_list[index].type == \"expression\") {\n\t\t++ index;\n\t\tif (node_list.size() > index && node_list[index].type == \",\") {\n\t\t\t++ index;\n\t\t\tif (node_list.size() <= index || node_list[index].type != \"expression\") return;\n\t\t}\n\t\telse break;\n\t}\n\tif (node_list.size() <= index || node_list[index].type != \")\") return;\n\t++ index;\n\tmake_node(node_list, matched, \"function_call\", index);\n}\n\nvoid match_for(const vector<Node> & node_list, vector<Node> & matched, int start=0) {\n\tif (node_list.size() != 5) return;\n\tif (node_list[0].type != \"for\") return;\n\tif (node_list[1].type != \"id\") return;\n\tif (node_list[2].type != \"in\") return;\n\tif (node_list[3].type != \"expression\") return;\n\tif (node_list[4].type != \":\") return;\n\tmake_node(node_list, matched, \"for_statement\", 5);\n}\n\nvoid match_if(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() != 3) return;\n\tif (node_list[0].type != \"if\") return;\n\tif (node_list[1].type != \"expression\") return;\n\tif (node_list[2].type != \":\") return;\n\tmake_node(node_list, matched, \"if_statement\", 3);\n}\n\nvoid match_else(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() != 2) return;\n\tif (node_list[0].type != \"else\") return;\n\tif (node_list[1].type != \":\") return;\n\tmake_node(node_list, matched, \"else_statement\", 2);\n}\n\nvoid match_operator(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() != 1) return;\n\tif (node_list[0].type == \"+\" || node_list[0].type == \"-\") {\n\t\tmake_node(node_list, matched, \"operator_add\", 1);\n\t}\n\telse if (node_list[0].type == \"*\" || node_list[0].type == \"/\" || node_list[0].type == \"%\") {\n\t\tmake_node(node_list, matched, \"operator_mul\", 1);\n\t}\n\telse if (node_list[0].type == \"==\" || node_list[0].type == \">\" || node_list[0].type == \"<\" \n\t\t || node_list[0].type == \">=\" || node_list[0].type == \"<=\" || node_list[0].type == \"!=\") {\n\t\tmake_node(node_list, matched, \"operator_cmp\", 1);\n\t}\n\telse if (node_list[0].type == \"and\") {\n\t\tmake_node(node_list, matched, \"operator_and\", 1);\n\t}\n\telse if (node_list[0].type == \"or\") {\n\t\tmake_node(node_list, matched, \"operator_or\", 1);\n\t}\n}\n\nvoid match_assign(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() != 3) return;\n\tif (node_list[0].type != \"id\") return;\n\tif (node_list[1].type != \"=\") return;\n\tif (node_list[2].type != \"expression\") return;\n\tmake_node(node_list, matched, \"assign_statement\", 3);\n}\n\nvoid match_yield(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() != 2) return;\n\tif (node_list[0].type != \"yield\") return;\n\tif (node_list[1].type != \"expression\") return;\n\tmake_node(node_list, matched, \"yield_statement\", 2);\n}\n\nvoid match_return(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() == 1) {\n\t\tif (node_list[0].type != \"return\") return;\n\t\tmake_node(node_list, matched, \"return_statement\", 1);\n\t}\n\telse if (node_list.size() == 2) {\n\t\tif (node_list[0].type != \"return\") return;\n\t\tif (node_list[1].type != \"expression\") return;\n\t\tmake_node(node_list, matched, \"return_statement\", 2);\n\t}\n}\n\nvoid match_pass(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() == 1) {\n\t\tif (node_list[0].type != \"pass\") return;\n\t\tmake_node(node_list, matched, \"pass_statement\", 1);\n\t}\n}\n\n////////////////////\n// RULES END\n\nvector<Node> check_rules(vector<Node> & node_list) {\n\tvector<Node> matched;\n\tmatch_function_def(node_list, matched);\n\tmatch_expression(node_list, matched);\n\tmatch_function_call(node_list, matched);\n\tmatch_for(node_list, matched);\n\tmatch_if(node_list, matched);\n\tmatch_else(node_list, matched);\n\tmatch_assign(node_list, matched);\n\tmatch_yield(node_list, matched);\n\tmatch_return(node_list, matched);\n\tmatch_operator(node_list, matched);\n\tmatch_pass(node_list, matched);\n\treturn matched;\n}\n\nvoid check_sequences(vector<vector<Node> > & nodes, vector<Node> & node_list, \n\tint index, vector<Node> & to_check) \n{\n\tNode last_node = node_list[node_list.size() - 1];\n\tint next_index = index + last_node.span;\n\t// cout << next_index << ' ' << nodes.size() << endl;\n\tif (next_index > nodes.size()) {\n\t\tthrow runtime_error(\"Internal error: incorrect next_index\");\n\t}\n\tvector<Node> matched = check_rules(node_list);\n\tfor (int i = 0; i < matched.size(); ++ i) {\n\t\tmatched[i].index = matched[i].children[0].index;\n\t\tmatched[i].span = 0;\n\t\tfor (int j = 0; j < matched[i].children.size(); ++ j)\n\t\t\tmatched[i].span += matched[i].children[j].span;\n\t\tfor (int j = 0; j < to_check.size(); ++ j) {\n\t\t\tif (to_check[j] == matched[i]) {\n\t\t\t\tstringstream ss;\n\t\t\t\tss << \"Internal error: repeated nodes:\" << endl;\n\t\t\t\tss << to_check[j] << endl;\n\t\t\t\tss << matched[i] << endl;\n\t\t\t\tthrow runtime_error(ss.str());\n\t\t\t}\n\t\t}\n\t\tto_check.push_back(matched[i]);\n\t}\n\t// for (int i = 0; i < matched.size(); ++ i) {\n\t// \tcout << matched[i] << endl;\n\t// }\n\tif (next_index == nodes.size()) return;\n\tfor (int i = 0; i < nodes[next_index].size(); ++ i) {\n\t\tNode node = nodes[next_index][i];\n\t\tnode_list.push_back(node);\n\t\tcheck_sequences(nodes, node_list, next_index, to_check);\n\t\tnode_list.pop_back();\n\t}\n}\n\nbool startswith(const string & text, const string & prefix) {\n\tint size = prefix.size();\n\tif (text.size() < size) return false;\n\tstring prefix2 = text.substr(0, size);\n\treturn prefix2 == prefix;\n}\n\nbool endswith(const string & text, const string & postfix) {\n\tint size = postfix.size();\n\tif (text.size() < size) return false;\n\tstring postfix2 = text.substr(text.size() - size, size);\n\treturn postfix2 == postfix;\n}\n\nNode parse_line(int lineno, vector<Token> & tokens) {\n\tvector<vector<Node> > nodes;\n\tvector<Node> to_check;\n\tint span = tokens.size();\n\tfor (int i = 0; i < tokens.size(); ++ i) {\n\t\tif (tokens[i].type == \"indent\") {\n\t\t\t-- span;\n\t\t\tcontinue;\n\t\t}\n\t\tNode node;\n\t\tnode.type = tokens[i].type;\n\t\tnode.index = nodes.size();\n\t\tnode.span = 1;\n\t\tnode.token = tokens[i];\n\t\tnodes.push_back(vector<Node>());\n\t\tto_check.push_back(node);\n\t}\n\twhile (to_check.size() > 0) {\n\t\tNode first = to_check[to_check.size() - 1];\n\t\t// cout << \"--->\" << '\\\t' << first << endl;\n\t\tto_check.pop_back();\n\t\tvector<Node> node_list;\n\t\tnode_list.push_back(first);\n\t\tnodes[first.index].push_back(first);\n\t\tcheck_sequences(nodes, node_list, first.index, to_check);\n\t}\n\tint result = -1;\n\tfor (int i = 0; i < nodes[0].size(); ++ i) {\n\t\tif (nodes[0][i].span == span) \n\t\t\tresult = i;\n\t}\n\tif (result == -1) {\n\t\tstringstream ss;\n\t\tss << \"Syntax error in line: \" << (lineno + 1);\n\t\tthrow runtime_error(ss.str());\n\t}\n\treturn nodes[0][result];\n}\n\nstruct Line\n{\n\tint level;\n\tNode node;\n\tvector<Line> children;\n};\n\nvoid print_line(ostream & out, const Line & line, int indent=0) {\n\t// for (int i = 0; i < indent; ++ i) out << '\\\t';\n\tif (line.children.size() == 0) {\n\t\t// out << \"( \" << line.node.type << \"@\" << line.level << \" _ )\";\n\t\tout << \"( \" << line.node.type << \" _ )\";\n\t}\n\telse {\n\t\t// out << \"( \" << line.node.type << \"@\" << line.level << \" \";\n\t\tout << \"( \" << line.node.type;\n\t\tfor (int i = 0; i < line.children.size(); ++ i) {\n\t\t\tprint_line(out, line.children[i], indent + 1);\n\t\t}\n\t\tout << \" )\";\n\t}\n}\n\nostream & operator << (ostream & out, const Line & line) {\n\tprint_line(out, line, 0);\n\treturn out;\n}\n\nvoid indent_error(const Token & indent) {\n\tstringstream ss;\n\tss << \"Inconsistent indentation at line: \" << indent.line;\n\tthrow runtime_error(ss.str());\n}\n\nvoid get_tree(vector<string> & lines, Line & tree) {\n\tvector<vector<Token> > tokens;\n\tvector<Node> nodes;\n\tvector<Token> indents;\n\tget_tokens(lines, tokens);\n\tfor (int i = 0; i < tokens.size(); ++ i) {\n\t\tif (tokens[i].size() > 0) {\n\t\t\tif (tokens[i][0].type == \"indent\")\n\t\t\t\tindents.push_back(tokens[i][0]);\n\t\t\telse\n\t\t\t\tindents.push_back(Token());\n\t\t\tnodes.push_back(parse_line(i, tokens[i]));\n\t\t}\n\t}\n\ttree.level = 0;\n\ttree.node.type = \"__main__\";\n\ttree.node.token.text = \"__main__\";\n\ttree.node.index = 0;\n\ttree.node.span = 0;\n\tvector<Line *> stack;\n\tvector<string> indent_stack;\n\tstack.push_back(&tree);\n\tindent_stack.push_back(\"\");\n\tfor (int i = 0; i < nodes.size(); ++ i) {\n\t\tstring last_indent = indent_stack[indent_stack.size() - 1];\n\t\tLine next;\n\t\tnext.node = nodes[i];\n\t\tLine * parent = stack[stack.size() - 1];\n\t\tif (indents[i].text == last_indent) {\n\t\t\tnext.level = parent->level + 1;\n\t\t\tparent->children.push_back(next);\n\t\t}\n\t\telse {\n\t\t\tif (startswith(indents[i].text, last_indent)) {\n\t\t\t\tindent_stack.push_back(indents[i].text);\n\t\t\t\tif (parent->children.size() == 0) indent_error(indents[i]);\n\t\t\t\tparent = &parent->children[parent->children.size() - 1];\n\t\t\t\tstack.push_back(parent);\n\t\t\t\tnext.level = parent->level + 1;\n\t\t\t\tparent->children.push_back(next);\n\t\t\t}\n\t\t\telse {\n\t\t\t\twhile (true) {\n\t\t\t\t\tif (indents[i].text == last_indent) {\n\t\t\t\t\t\tnext.level = parent->level + 1;\n\t\t\t\t\t\tparent->children.push_back(next);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (startswith(last_indent, indents[i].text)) {\n\t\t\t\t\t\tindent_stack.pop_back();\n\t\t\t\t\t\tlast_indent = indent_stack[indent_stack.size() - 1];\n\t\t\t\t\t\tstack.pop_back();\n\t\t\t\t\t\tif (stack.size() == 0) indent_error(indents[i]);\n\t\t\t\t\t\tparent = stack[stack.size() - 1];\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tindent_error(indents[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid print_nodes(ostream & out, const Line & line) {\n\tif (line.node.type != \"__main__\")\n\t\tout << line.node << endl;\n\tif (line.children.size() == 0) return;\n\tfor (int i = 0; i < line.children.size(); ++ i) {\n\t\tprint_nodes(out, line.children[i]);\n\t}\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid optim_exp(Node & node) {\n\tif (node.children.size() == 1) {\n\t\tNode child = node.children[0];\n\t\tnode = child;\n\t}\n\telse if (node.children.size() == 3 && node.children[0].type == \"(\" && node.children[2].type == \")\") {\n\t\tNode child = node.children[1];\n\t\tnode = child;\n\t}\n\tif (startswith(node.type, \"expression\"))\n\t\tnode.type = \"expression\";\n}\n\nvoid optim(Node & node) {\n\tfor (int i = 0; i < node.children.size(); ++ i)\n\t\toptim(node.children[i]);\n\tif (startswith(node.type, \"expression\"))\n\t\toptim_exp(node);\n\tif (startswith(node.type, \"operator_\"))\n\t\tnode = node.children[0];\n}\n\nvoid optim(Line & line) {\n\toptim(line.node);\n\tfor (int i = 0; i < line.children.size(); ++ i) {\n\t\toptim(line.children[i]);\n\t}\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#define foreach(type, item, vec) for (vector<type>::iterator item=vec.begin(); item != vec.end(); ++ item)\n\nvoid assert_true(bool test, const string & err_msg) {\n\tif (! test) throw runtime_error(err_msg);\n}\n\n//////////\n// TYPES\n\nstruct Variable\n{\n\tstring type;\n\tvirtual void print() {\n\t\tcout << type;\n\t}\n\tvirtual Variable * copy() {\n\t\tstringstream ss;\n\t\tss << \"'\" << type << \".copy' is not implemented\";\n\t\tassert_true(false, ss.str());\n\t\treturn 0;\n\t}\n\tvirtual Variable * __eq__(Variable * op) {\n\t\tstringstream ss;\n\t\tss << \"'\" << type << \".__eq__' is not implemented\";\n\t\tassert_true(false, ss.str());\n\t\treturn 0;\n\t}\n};\n\nstruct Int : public Variable\n{\n\tint intValue;\n\tInt(int value) {\n\t\ttype = \"int\";\n\t\tintValue = value;\n\t}\n\tvoid print() {\n\t\tcout << intValue;\n\t}\n\tvirtual Variable * copy() {\n\t\treturn new Int(intValue);\n\t}\n\tVariable * __add__(Int * op) {\n\t\tInt * ret = (Int *)copy();\n\t\tret->intValue += op->intValue;\n\t\treturn ret;\n\t}\n\tVariable * __mul__(Int * op) {\n\t\tInt * ret = (Int *)copy();\n\t\tret->intValue *= op->intValue;\n\t\treturn ret;\n\t}\n\tVariable * __mod__(Int * op) {\n\t\tInt * ret = (Int *)copy();\n\t\tret->intValue = ret->intValue % op->intValue;\n\t\treturn ret;\n\t}\n\tVariable * __eq__(Variable * op) {\n\t\tInt * op2 = (Int *)op;\n\t\treturn new Int(intValue == op2->intValue);\n\t}\n};\n\nstruct Bool : public Variable\n{\n\tbool boolValue;\n\tBool(bool value) {\n\t\ttype = \"bool\";\n\t\tboolValue = value;\n\t}\n\tvoid print() {\n\t\tif (boolValue) cout << \"True\";\n\t\telse cout << \"False\";\n\t}\n\tvirtual Variable * copy() {\n\t\treturn new Bool(boolValue);\n\t}\n\tVariable * __and__(Bool * op) {\n\t\tBool * ret = (Bool *)copy();\n\t\tret->boolValue = ret->boolValue && op->boolValue;\n\t\treturn ret;\n\t}\n\tVariable * __or__(Bool * op) {\n\t\tBool * ret = (Bool *)copy();\n\t\tret->boolValue = ret->boolValue || op->boolValue;\n\t\treturn ret;\n\t}\n\tVariable * __eq__(Variable * op) {\n\t\tBool * op2 = (Bool *)op;\n\t\treturn new Bool(boolValue == op2->boolValue);\n\t}\n};\n\n\nstruct Str : public Variable\n{\n\tstring strValue;\n\tStr(string value) {\n\t\ttype = \"str\";\n\t\tstrValue = value;\n\t}\n\tvoid print() {\n\t\tbool was_backslash = false;\n\t\tfor (int i = 1; i < strValue.size() - 1; ++ i) {\n\t\t\tchar c = strValue[i];\n\t\t\tif (was_backslash) {\n\t\t\t\tstring err_msg = \"Unknown sequence '\\\\?'\";\n\t\t\t\tswitch (c) {\n\t\t\t\t\tcase '\\\\': cout << '\\\\'; break;\n\t\t\t\t\tcase 'r': cout << '\\r'; break;\n\t\t\t\t\tcase 't': cout << '\\t'; break;\n\t\t\t\t\tcase 'n': cout << '\\n'; break;\n\t\t\t\t\tcase '\"': cout << '\"'; break;\n\t\t\t\t\tdefault: err_msg[err_msg.size() - 2] = c; assert_true(false, err_msg);\n\t\t\t\t}\n\t\t\t\twas_backslash = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (c == '\\\\') was_backslash = true;\n\t\t\t\telse cout << c;\n\t\t\t}\n\t\t}\n\t}\n\tvirtual Variable * copy() {\n\t\treturn new Str(strValue);\n\t}\n};\n\nstruct Function : public Variable\n{\n\tLine * line;\n\tFunction(Line & value) {\n\t\ttype = \"function\";\n\t\tline = &value;\n\t}\n\tvoid print() {\n\t\tcout << type << '\\t';\n\t\tprint_node(cout, line->node);\n\t}\n};\n\nstruct Pointer : public Variable\n{\n\tvoid * pointer;\n\tPointer(void * value) {\n\t\ttype = \"pointer\";\n\t\tpointer = value;\n\t}\n};\n\nstruct Variables\n{\n\tHashTable<string, Variable*> map;\n\n\tvoid print() {\n\t\tvector<string> names = map.getKeys();\n\t\tforeach (string, name, names) {\n\t\t\tcout << *name << '\\t';\n\t\t\tmap.get(*name)->print();\n\t\t\tcout << endl;\n\t\t}\n\t}\n\n\tbool hasVariable(const string & name) {\n\t\treturn map.containsKey(name);\n\t}\n\n\tvoid assertVariable(const string & name) {\n\t\tstringstream ss;\n\t\tss << \"Variable '\" << name << \"' is undefined\"; \n\t\tassert_true(map.containsKey(name), ss.str());\t\t\n\t}\n\n\tvoid assertType(const string & name, const string & type) {\n\t\tstringstream ss;\n\t\tss << \"Require '\" << type << \"', got '\" << map.get(name)->type << \"' \"; \n\t\tassert_true(map.get(name)->type == type, ss.str());\t\t\n\t}\n\n\tstring getType(const string & name) {\n\t\tassertVariable(name);\n\t\treturn map.get(name)->type;\n\t}\n\n\tvoid delVariable(const string & name, bool del=true) {\n\t\tassertVariable(name);\n\t\tif (del) delete map.get(name);\n\t\tmap.remove(name);\n\t}\n\n\tvoid setVariable(const string & name, Variable * v) {\n\t\tif (map.containsKey(name))\n\t\t\tdelete map.get(name);\n\t\tmap.put(name, v);\n\t}\n\n\tVariable * getVariable(const string & name) {\n\t\tassertVariable(name);\n\t\treturn map.get(name);\n\t}\n\n\tvoid releaseAll() {\n\t\tvector<string> names = map.getKeys();\n\t\tforeach (string, name, names)\n\t\t\tdelVariable(*name);\n\t}\n\n};\n\nstruct Context\n{\n\tstring owner;\n\tVariables & global_variables;\n\tVariables & local_variables;\n\tHashTable<string, int> global_used;\n\tvector<int> lines_running;\n\n\tContext(const string & owner_, Variables & global_variables_, Variables & local_variables_) : \n\t\towner(owner_), global_variables(global_variables_), local_variables(local_variables_) {}\n\n\tbool is_global(const string & name, bool is_assign) {\n\t\tif (local_variables.hasVariable(name)) return false;\n\t\tif (global_used.containsKey(name)) return true;\n\t\tif (is_assign) return false;\n\t\tglobal_variables.assertVariable(name);\n\t\tglobal_used.put(name, 0);\n\t\treturn true;\n\t}\n\n\tVariable * getVariable(const string & name) {\n\t\tif (is_global(name, false))\n\t\t\treturn global_variables.getVariable(name);\n\t\telse\n\t\t\treturn local_variables.getVariable(name);\n\t}\n\n\tvoid setVariable(const string & name, Variable * v) {\n\t\tif (is_global(name, true))\n\t\t\treturn global_variables.setVariable(name, v);\n\t\telse\n\t\t\treturn local_variables.setVariable(name, v);\n\t}\n\n};\n\n////////////////////\n// FUNCTIONS\n\nvoid run_builtin_range(Context & context) {\n\tVariable * v = context.local_variables.getVariable(\"n\");\n\tassert_true(v->type == \"int\", \"'range' requires a single 'int' argument\");\n\tint n = ((Int *)v)->intValue;\n\tint level = 2;\n\tif (context.lines_running.size() == level)\n\t\tcontext.lines_running.push_back(0);\n\telse\n\t\t++ context.lines_running[level];\n\tif (context.lines_running[level] >= n) return;\n\tcontext.local_variables.setVariable(\"$ret\", new Int(context.lines_running[level]));\n}\n\nint max_print_calls = 1000;\n\nvoid run_builtin_print(Context & context) {\n\tassert_true(-- max_print_calls > 0, \"Exceeds max_print_calls == 100\");\n\tVariable * v = context.local_variables.getVariable(\"n\");\n\tif (v == 0) cout << \"None\";\n\telse v->print();\n\tcout << endl;\n}\n\nvoid run_builtin(const string & function_name, Context & context) {\n\tif (function_name == \"range\") {\n\t\trun_builtin_range(context);\n\t}\n\telse if (function_name == \"print\") {\n\t\trun_builtin_print(context);\n\t}\n\telse {\n\t\tstringstream ss;\n\t\tss << \"Unknow builtin: \" << function_name << endl;\n\t\tassert_true(false, ss.str());\n\t}\n}\n\nvoid register_builtins(vector<string> & lines, Line & tree, Variables & global_variables) {\n\tget_tree(lines, tree);\n\toptim(tree);\n\tforeach (Line, line, tree.children) {\n\t\tstringstream ss;\n\t\tss << \"Invalid line in 'builtins.py: \" << line->node.type << endl;\n\t\tassert_true(line->node.type == \"function_def\", ss.str());\n\t\tline->node.type = \"builtin\";\n\t\tstring function_name = line->node.children[1].token.text;\n\t\tglobal_variables.setVariable(function_name, new Function(*line));\n\t}\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid run_lines(vector<Line> & lines, Context & context);\nvoid run_line(Line & line, Context & context);\nVariable * run_exp(Node & exp, Context & context);\n\nLine & get_function(const string & function_name, Context & context) {\n\tVariable * v = context.getVariable(function_name);\n\tstringstream ss;\n\tss << \"Not a function: \" << function_name;\n\tassert_true(v->type == \"function\" || v->type == \"builtin\", ss.str());\n\tFunction * func_var = (Function *)v;\n\treturn *(func_var->line);\n}\n\nvoid init_function_parameters(Node & func_node, Context & callee_context, Node & call_node, Context & caller_context) {\n\tint num_args = call_node.children.size() - 3;\n\tint num_params = func_node.children.size() - 5;\n\tstringstream ss;\n\tss << \"Function '\" << call_node.children[0].token.text << \"' arguments not agree\" << endl;\n\tss << \"\\tCaller gives \" << num_args << \" at line: \" << (func_node.children[0].token.line + 1) << endl;\n\tss << \"\\tCallee requires \" << num_params << \" at line: \" << (call_node.children[0].token.line + 1) << endl;\n\tassert_true(num_args == num_params, ss.str());\n\tfor (int i = 0; i < num_params; ++ i) {\n\t\tNode & arg_exp = call_node.children[2 + i];\n\t\tVariable * arg_value = run_exp(arg_exp, caller_context);\n\t\tstring parameter_name = func_node.children[3 + i].token.text;\n\t\tcallee_context.local_variables.setVariable(parameter_name, arg_value);\n\t}\t\n}\n\nVariable * run_function(Node & call_node, Context & context) {\n\tstring function_name = call_node.children[0].token.text;\n\tLine & func_line = get_function(function_name, context);\n\tVariables func_local_variables;\n\tContext func_context(function_name, context.global_variables, func_local_variables);\n\tinit_function_parameters(func_line.node, func_context, call_node, context);\n\t// func_local_variables.print();\n\tif (func_line.node.type == \"builtin\" && func_line.children.size() == 1 && func_line.children[0].node.type == \"pass_statement\")\n\t\trun_builtin(function_name, func_context);\n\telse {\n\t\twhile (func_context.lines_running.size() <= func_line.level)\n\t\t\tfunc_context.lines_running.push_back(-100);\n\t\trun_lines(func_line.children, func_context);\n\t}\n\tVariable * ret = 0;\n\tif (func_local_variables.hasVariable(\"$ret\")) {\n\t\tret = func_local_variables.getVariable(\"$ret\");\n\t\tfunc_local_variables.delVariable(\"$ret\", false);\n\t}\n\tfunc_local_variables.releaseAll();\n\treturn ret;\n}\n\nvoid pass_result(Context & from, Context & to, const string & name) {\n\tVariable * ret = from.local_variables.getVariable(\"$ret\");\n\tfrom.local_variables.delVariable(\"$ret\", false);\n\tto.local_variables.setVariable(name, ret);\n}\n\nContext * init_generator_context(Context & context, Line & gen_def_line, Node & gen_call_node) {\n\tVariables * local_variables = new Variables();\n\tstring gen_func_name = gen_call_node.children[0].token.text;\n\tContext * gen_context = new Context(gen_func_name, context.global_variables, *local_variables);\n\tinit_function_parameters(gen_def_line.node, *gen_context, gen_call_node, context);\n\tcontext.local_variables.setVariable(\"$gen\", new Pointer(gen_context));\n\twhile (gen_context->lines_running.size() <= gen_def_line.level)\n\t\tgen_context->lines_running.push_back(-100);\n\treturn gen_context;\n}\n\nvoid release_generator_context(Context & context) {\n\tPointer * v = (Pointer *)context.local_variables.getVariable(\"$gen\");\n\tContext * gen = (Context *)v->pointer;\n\tcontext.local_variables.delVariable(\"$gen\");\n\tgen->local_variables.releaseAll();\n\tdelete &(gen->local_variables);\n\tdelete gen;\n}\n\nvoid print_int_vector(vector<int> & vec) {\n\tfor (int i = 0; i < vec.size(); ++ i) cout << \" \" << vec[i];\n\tcout << endl;\n}\n\nvoid run_for_statement(Line & for_line, Context & context) {\n\tstring loop_variable_name = for_line.node.children[1].token.text;\n\tNode & gen_node = for_line.node.children[3];\n\tif (gen_node.type == \"function_call\") {\n\t\tstring gen_func_name = gen_node.children[0].token.text;\n\t\tLine & gen_def_line = get_function(gen_func_name, context);\n\t\tContext * gen_context = 0;\n\t\tif (context.local_variables.hasVariable(\"$gen\")) {\n\t\t\tPointer * gen = (Pointer *)context.local_variables.getVariable(\"$gen\");\n\t\t\tgen_context = (Context *)(gen->pointer);\n\t\t\tstringstream ss;\n\t\t\tss << \"Inconsistent generator context: required '\" << gen_func_name << \"', got '\" << gen_context->owner << \"'\";\n\t\t\tassert_true(gen_context->owner == gen_func_name, ss.str());\n\t\t}\n\t\telse \n\t\t\tgen_context = init_generator_context(context, gen_def_line, gen_node);\n\t\tbool done = false;\n\t\twhile (true) {\n\t\t\tif (gen_def_line.node.type == \"builtin\" && gen_def_line.children.size() == 1 && gen_def_line.children[0].node.type == \"pass_statement\")\n\t\t\t\trun_builtin(gen_func_name, *gen_context);\n\t\t\telse\n\t\t\t\trun_lines(gen_def_line.children, *gen_context);\n\t\t\tif (! gen_context->local_variables.hasVariable(\"$ret\")) {\n\t\t\t\tdone = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpass_result(*gen_context, context, loop_variable_name);\n\t\t\trun_lines(for_line.children, context);\n\t\t\tif (context.local_variables.hasVariable(\"$ret\")) break;\n\t\t}\n\t\tif (done) release_generator_context(context);\n\t}\n\telse {\n\t\tstringstream ss;\n\t\tss << \"Unknow generator type: \" << gen_node.type;\n\t\tassert_true(false, ss.str());\n\t}\n}\n\nVariable * run_id(Node & exp, Context & context) {\n\tstring name = exp.token.text;\n\tif (context.local_variables.hasVariable(name))\n\t\treturn context.local_variables.getVariable(name)->copy();\n\tif (context.global_variables.hasVariable(name))\n\t\treturn context.global_variables.getVariable(name)->copy();\n\tstringstream ss;\n\tss << \"Undefined variable: \" << name << endl;\n\tassert_true(false, ss.str());\n\treturn 0;\n}\n\nvoid check_op_type(const string & op, const string & required_type, const string & type) {\n\tstringstream ss;\n\tss << \"The operand of \" << op << \" must be '\" << required_type <<\"' instead of '\" << type << \"'\" << endl;\n\tassert_true(required_type == type, ss.str());\n}\n\nVariable * run_expression(Node & exp, Context & context) {\n\tstring op = \"?\";\n\tif (exp.children.size() == 3) {\n\t\top = exp.children[1].token.text;\n\t\tVariable * left = run_exp(exp.children[0], context);\n\t\tVariable * right = run_exp(exp.children[2], context);\n\t\tif (op == \"+\") {\n\t\t\tcheck_op_type(op, \"int\", left->type);\n\t\t\tcheck_op_type(op, \"int\", right->type);\n\t\t\treturn ((Int *)left)->__add__((Int *)right);\n\t\t}\n\t\telse if (op == \"*\") {\n\t\t\tcheck_op_type(op, \"int\", left->type);\n\t\t\tcheck_op_type(op, \"int\", right->type);\n\t\t\treturn ((Int *)left)->__mul__((Int *)right);\n\t\t}\n\t\telse if (op == \"%\") {\n\t\t\tcheck_op_type(op, \"int\", left->type);\n\t\t\tcheck_op_type(op, \"int\", right->type);\n\t\t\treturn ((Int *)left)->__mod__((Int *)right);\n\t\t}\n\t\telse if (op == \"and\") {\n\t\t\tcheck_op_type(op, \"bool\", left->type);\n\t\t\tcheck_op_type(op, \"bool\", right->type);\n\t\t\treturn ((Bool *)left)->__and__((Bool *)right);\n\t\t}\n\t\telse if (op == \"or\") {\n\t\t\tcheck_op_type(op, \"bool\", left->type);\n\t\t\tcheck_op_type(op, \"bool\", right->type);\n\t\t\treturn ((Bool *)left)->__or__((Bool *)right);\n\t\t}\n\t\telse if (op == \"==\") {\n\t\t\tcheck_op_type(op, left->type, right->type);\n\t\t\treturn left->__eq__(right);\n\t\t}\n\t}\n\telse if (exp.children.size() == 2) {\n\t\top = exp.children[0].token.text;\n\t}\n\tstringstream ss;\n\tss << \"Undefined operator: \" << op << endl;\n\tassert_true(false, ss.str());\n\treturn 0;\n}\n\nVariable * run_exp(Node & exp, Context & context) {\n\tif (exp.type == \"int\") {\n\t\tstringstream ss(exp.token.text);\n\t\tint intValue;\n\t\tss >> intValue;\n\t\treturn new Int(intValue);\n\t}\n\telse if (exp.type == \"str\") {\n\t\treturn new Str(exp.token.text);\n\t}\n\telse if (exp.type == \"True\") {\n\t\treturn new Bool(true);\n\t}\n\telse if (exp.type == \"False\") {\n\t\treturn new Bool(false);\n\t}\n\telse if (exp.type == \"id\") {\n\t\treturn run_id(exp, context);\n\t}\n\telse if (exp.type == \"None\") {\n\t\treturn 0;\n\t}\n\telse if (exp.type == \"function_call\") {\n\t\treturn run_function(exp, context);\n\t}\n\telse if (exp.type == \"expression\") {\n\t\treturn run_expression(exp, context);\n\t}\n\telse {\n\t\tstringstream ss;\n\t\tss << \"Unknow expression type: \" << exp.type << endl << exp << endl;\n\t\tassert_true(false, ss.str());\n\t}\n\treturn 0;\n}\n\nvoid run_yield_statement(Line & line, Context & context) {\n\tVariable * v = run_exp(line.node.children[1], context);\n\tassert_true(v != 0, \"\");\n\tcontext.local_variables.setVariable(\"$ret\", v);\n\t++ context.lines_running[line.level];\n}\n\nvoid run_return_statement(Line & line, Context & context) {\n\tVariable * v = run_exp(line.node.children[1], context);\n\tcontext.local_variables.setVariable(\"$ret\", v);\n\tcontext.lines_running.clear();\n}\n\nvoid run_assign_statement(Line & line, Context & context) {\n\tstring variable_name = line.node.children[0].token.text;\n\tVariable * v = run_exp(line.node.children[2], context);\n\tcontext.setVariable(variable_name, v);\n}\n\nbool is_true(Variable * v) {\n\tif (v == 0) {\n\t\treturn false;\n\t}\n\tif (v->type == \"bool\") {\n\t\treturn ((Bool *)v)->boolValue;\n\t}\n\telse if (v->type == \"int\") {\n\t\treturn ((Int *)v)->intValue != 0;\n\t}\n\tstringstream ss;\n\tss << \"Unknown type for condition: \" << v->type;\n\tassert_true(false, ss.str());\n\treturn false;\n}\n\nvoid run_if_statement(Line & line, Context & context) {\n\tif (context.lines_running.size() > line.level + 1) {\n\t\trun_lines(line.children, context);\n\t\treturn;\n\t}\n\tVariable * v = run_exp(line.node.children[1], context);\n\tstringstream ss;\n\tss << \"$if\" << line.level;\n\tcontext.setVariable(ss.str(), v);\n\tif (is_true(v)) {\n\t\trun_lines(line.children, context);\n\t}\n}\n\nvoid run_else_statement(Line & line, Context & context) {\n\tif (context.lines_running.size() > line.level + 1) {\n\t\trun_lines(line.children, context);\n\t\treturn;\n\t}\n\tstringstream ss;\n\tss << \"$if\" << line.level;\n\tstring condition_name = ss.str();\n\tassert_true(context.local_variables.hasVariable(condition_name), \"Dangling else-statement\");\n\tVariable * v = context.local_variables.getVariable(condition_name);\n\tif (! is_true(v)) {\n\t\trun_lines(line.children, context);\n\t}\n\tcontext.local_variables.delVariable(condition_name);\n}\n\nvoid run_line(Line & line, Context & context) {\n\tif (line.node.type == \"comment\") {\n\t}\n\telse if (line.node.type == \"function_def\") {\n\t\tstring function_name = line.node.children[1].token.text;\n\t\tcontext.local_variables.setVariable(function_name, new Function(line));\n\t}\n\telse if (line.node.type == \"function_call\") {\n\t\trun_function(line.node, context);\n\t}\n\telse if (line.node.type == \"for_statement\") {\n\t\trun_for_statement(line, context);\n\t}\n\telse if (line.node.type == \"yield_statement\") {\n\t\trun_yield_statement(line, context);\n\t}\n\telse if (line.node.type == \"return_statement\") {\n\t\trun_return_statement(line, context);\n\t}\n\telse if (line.node.type == \"assign_statement\") {\n\t\trun_assign_statement(line, context);\n\t}\n\telse if (line.node.type == \"if_statement\") {\n\t\trun_if_statement(line, context);\n\t}\n\telse if (line.node.type == \"else_statement\") {\n\t\trun_else_statement(line, context);\n\t}\n\telse {\n\t\tstringstream ss;\n\t\tss << \"Unknow line type: \" << line.node.type;\n\t\tassert_true(false, ss.str());\n\t}\n}\n\nint get_def_line(Line & line) {\n\tNode * node = &(line.node);\n\twhile (node->children.size() > 0)\n\t\tnode = &(node->children[0]);\n\treturn node->token.line;\n}\n\nvoid run_lines(vector<Line> & lines, Context & context) {\n\tint level = lines[0].level;\n\tstringstream ss;\n\tss << \"Line: \" << get_def_line(lines[0]) <<\" Incorrect level state: \" << context.lines_running.size() << \", requires >= \" << level;\n\tassert_true(context.lines_running.size() >= level, ss.str());\n\tif (context.lines_running.size() == level) {\n\t\tcontext.lines_running.push_back(0);\n\t}\n\tstringstream ss2;\n\tss2 << \"Line: \" << get_def_line(lines[0]) <<\" Incorrect level step: \" << context.lines_running[level];\n\tassert_true(context.lines_running[level] >= 0, ss2.str());\n\twhile (context.lines_running[level] < lines.size()) {\n\t\trun_line(lines[context.lines_running[level]], context);\n\t\tif (context.local_variables.hasVariable(\"$ret\")) break;\n\t\t++ context.lines_running[level];\n\t}\n\tif (context.lines_running[level] == lines.size())\n\t\tcontext.lines_running.pop_back();\n}\n\nvoid run(vector<string> & lib_lines, vector<string> & lines) {\n\t// Variables global_variables;\n\t// Line builtins_tree;\n\t// register_builtins(lib_lines, builtins_tree, global_variables);\n\n\tLine tree;\n\tget_tree(lines, tree);\n\toptim(tree);\n\tprint_nodes(cout, tree);\n\tcout << tree << endl;\n\t// Context global_context(\"__main__\", global_variables, global_variables);\n\t// while (global_context.lines_running.size() <= tree.level)\n\t// \tglobal_context.lines_running.push_back(-100);\n\t// run_lines(tree.children, global_context);\n\t// global_variables.releaseAll();\n}\n\nstring builtins = \"def print(n):\\n\\tpass\\n\\ndef range(n):\\n\\tpass\";\n\nint main() {\n\ttry {\n\t\tvector<string> lib_lines;\n\t\tvector<string> lines;\n\t\tstringstream ss(builtins);\n\t\tread_lines(ss, lib_lines);\n\t\tread_lines(cin, lines);\n\t\trun(lib_lines, lines);\n\t}\n\tcatch (runtime_error & ex) {\n\t\tcout << ex.what() << endl;\n\t}\n}",
            "print('''def test_loop(n):\n\tfor i in range(n):\n\t\tprint(123 - i)\n\ndef test_condition(c):\n\tif c:\n\t\tprint(\"yes\")\n\telse:\n\t\tprint(\"no\")\n\ntest_loop(10)\ntest_condition(True)''')",
            1585713600,
            1585713600
        ],
        [
            "15.4 (C++)",
            "Please modify the simple Python compiler as follows:\n<ul>\n<li>Combine all CPP file into a single file</li>\n<li>Input from STDIO instead of from a Python file</li>\n<li>Load library from an internal string instead of from \"lib/builtins.py\"</li>\n</ul>\n\n<b>EXAMPLE INPUT</b>\n<pre>\ndef test_loop(n):\n\tfor i in range(n):\n\t\tprint(1 + i * 2)\n\ndef test_condition(c):\n\tif c:\n\t\tprint(\"yes\")\n\telse:\n\t\tprint(\"no\")\n\ntest_loop(10)\ntest_condition(True)\n</pre>\n\n<b>EXAMPLE OUTPUT</b>\n<pre>\n( function_def ( def def )( id test_loop )( -LRB- -LRB- )( id n )( -RRB- -RRB- )( : : ) )\n( for_statement ( for for )( id i )( in in )( function_call ( id range )( -LRB- -LRB- )( id n )( -RRB- -RRB- ) )( : : ) )\n( function_call ( id print )( -LRB- -LRB- )( expression ( int 1 )( + + )( expression ( id i )( * * )( int 2 ) ) )( -RRB- -RRB- ) )\n( function_def ( def def )( id test_condition )( -LRB- -LRB- )( id c )( -RRB- -RRB- )( : : ) )\n( if_statement ( if if )( id c )( : : ) )\n( function_call ( id print )( -LRB- -LRB- )( str \"yes\" )( -RRB- -RRB- ) )\n( else_statement ( else else )( : : ) )\n( function_call ( id print )( -LRB- -LRB- )( str \"no\" )( -RRB- -RRB- ) )\n( function_call ( id test_loop )( -LRB- -LRB- )( int 10 )( -RRB- -RRB- ) )\n( function_call ( id test_condition )( -LRB- -LRB- )( True True )( -RRB- -RRB- ) )\n( __main__( function_def( for_statement( function_call _ ) ) )( function_def( if_statement( function_call _ ) )( else_statement( function_call _ ) ) )( function_call _ )( function_call _ ) )\n</pre>",
            "#include \"source.cpp\"",
            "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <stdexcept>\nusing namespace std;\n\n#include <cstring>\n\nint operator % (const string & text, int max) {\n\tint code = 0;\n\tfor (int i = 0; i < text.size(); ++ i) {\n\t\tint code1 = text[i];\n\t\tcode1 = code1 << (i * 8 % 24);\n\t\tcode = code ^ code1;\n\t}\n\treturn code % max;\n}\n\nclass NoSuchKeyException {};\n\ntemplate <typename K, typename V>\nclass HashTable\n{\nprivate:\n\t\t\n\tclass Entry\n\t{\n\tpublic:\n\t\tK key;\n\t\tV value;\n\t\tbool isInUse;\n\t\t\n\t\tEntry() {\n\t\t\tisInUse = false;\n\t\t}\n\t};\n\t\n\tEntry * entries;\n\t\n\tint capacity;\n\tint count;\n\t\n\tvoid initialize(int capacity2) {\n\t\tcount = 0;\n\t\tcapacity = capacity2;\n\t\tentries = new Entry[capacity];\n\t}\n\t\n\tvoid assign(const HashTable & map2) {\n\t\tcount = map2.count;\n\t\tcapacity = map2.capacity;\n\t\tentries = new Entry[capacity];\n\t\tfor (int i = 0; i < capacity; ++ i) {\n\t\t\tentries[i] = map2.entries[i];\n\t\t}\n\t}\n\t\npublic:\n\t\n\tHashTable() {\n\t\tinitialize(2);\n\t}\n\t\n\t~HashTable() {\n\t\tdelete [] entries;\n\t}\n\t\n\tHashTable(const HashTable & map2) {\n\t\tassign(map2);\n\t}\n\t\n\tHashTable & operator = (const HashTable & map2) {\n\t\tdelete [] entries;\n\t\tassign(map2);\n\t\treturn (*this);\n\t}\n\t\n\tvoid clear() {\n\t\tdelete [] entries;\n\t\tinitialize(2);\n\t}\n\t\nprivate:\n\t\n\tint hashIndex(const K & key) const {\n\t\treturn key % capacity;\n\t}\n\t\n\tint find(const K & key) const {\n\t\tint index = hashIndex(key);\n\t\twhile (true) {\n\t\t\tif (! entries[index].isInUse) {\n\t\t\t\treturn index;\n\t\t\t}\n\t\t\tif (entries[index].key == key) {\n\t\t\t\treturn index;\n\t\t\t}\n\t\t\tindex = (index + 1) % capacity;\n\t\t}\n\t}\n\t\n\tvoid resize(int capacity2) {\n\t\tEntry * entries0 = entries;\n\t\tint capacity0 = capacity;\n\t\tinitialize(capacity2);\n\t\tfor (int i = 0; i < capacity0; ++ i) {\n\t\t\tif (entries0[i].isInUse) {\n\t\t\t\tput(entries0[i].key, entries0[i].value);\n\t\t\t}\n\t\t}\n\t\tdelete [] entries0;\n\t}\n\t\npublic:\n\t\n\tvoid put(const K & key, const V & value) {\n\t\tint index = find(key);\n\t\tentries[index].value = value;\n\t\tif (entries[index].isInUse) return;\n\t\t\n\t\tentries[index].isInUse = true;\n\t\tentries[index].key = key;\n\t\t\n\t\t++ count;\n\t\tif (count > capacity / 2) {\n\t\t\tresize(capacity * 2);\n\t\t}\n\t}\n\t\n\tV get(const K & key) const {\n\t\tint index = find(key);\n\t\tif (! entries[index].isInUse) {\n\t\t\tthrow NoSuchKeyException();\n\t\t}\n\t\treturn entries[index].value;\n\t}\n\t\n\tbool remove(const K & key) {\n\t\tint index = find(key);\n\t\tif (! entries[index].isInUse) return false;\n\t\tfillNotInUseEntry(index);\n\t\t\n\t\t-- count;\n\t\tif (count < capacity / 4) {\n\t\t\tresize(capacity / 2);\n\t\t}\n\t\treturn true;\n\t}\n\t\nprivate:\n\t\n\tvoid fillNotInUseEntry(int index) {\n\t\tint next = index;\n\t\twhile (true) {\n\t\t\tnext = (next + 1) % capacity;\n\t\t\tif (! entries[next].isInUse) {\n\t\t\t\tentries[index].isInUse = false;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint index0 = hashIndex(entries[next].key);\n\t\t\tif (index < next) {\n\t\t\t\tif (index0 > index &&\n\t\t\t\t\tindex0 <= next) continue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (index0 > index ||\n\t\t\t\t\tindex0 <= next) continue;\n\t\t\t}\n\t\t\tentries[index] = entries[next];\n\t\t\tindex = next;\n\t\t}\n\t}\n\t\npublic:\n\t\n\tbool containsKey(const K & key) const {\n\t\tint index = find(key);\n\t\treturn (entries[index].isInUse);\n\t}\n\t\n\tint size() const {\n\t\treturn count;\n\t}\n\n\tvector<K> getKeys() const {\n\t\tvector<K> vec;\n\t\tfor (int i = 0; i < capacity; ++ i) {\n\t\t\tif (entries[i].isInUse) {\n\t\t\t\tvec.push_back(entries[i].key);\n\t\t\t}\n\t\t}\n\t\treturn vec;\n\t}\n\t\n};\n\n////////////////////////////////////////////////////////////////////////////////\n\nstruct Token\n{\n\tint line;\n\tint pos;\n\tstring type;\n\tstring text;\n};\n\nint operator % (const Token & t, int base) {\n\treturn (t.line * 12347 + t.pos) % base;\n}\n\nbool operator == (const Token & t1, const Token & t2) {\n\treturn t1.line == t2.line && t1.pos == t2.pos;\n}\n\nostream & operator << (ostream & out, const Token & t) {\n\tout << t.line << '\\t' << t.pos << '\\t' << t.type << \"\\t\\\"\" << t.text << \"\\\"\";\n\treturn out;\n}\n\nvoid read_lines(istream & in, vector<string> & lines) {\n\tstring line;\n\twhile (getline(in, line)) {\n\t\tlines.push_back(line);\n\t}\n}\n\nToken make_token(int line, int pos, int len, const string & source, const string & type) {\n\tToken t;\n\tt.line = line;\n\tt.pos = pos;\n\tt.type = type;\n\tt.text = source.substr(pos, len);\n\treturn t;\n}\n\n////////////////////\n// RULES BEGIN\n\nToken find_indent(int line, const string & source) {\n\tint len = 0;\n\tfor (int i = 0; i < source.size(); ++ i) {\n\t\tif (source[i] == '\\t')\n\t\t\t++ len;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn make_token(line, 0, len, source, \"indent\");\n}\n\nToken find_blank(int line, const string & source, int start) {\n\tint len = 0;\n\tfor (int i = start; i < source.size(); ++ i) {\n\t\tif (source[i] == '\\t' || source[i] == ' ')\n\t\t\t++ len;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn make_token(line, start, len, source, \"blank\");\n}\n\nToken find_string(int line, const string & source, int start) {\n\tint len = 0;\n\tbool was_backslash = false;\n\tfor (int i = start; i < source.size(); ++ i) {\n\t\tchar c = source[i];\n\t\tif (i == start) {\n\t\t\tif (c == '\"') ++ len;\n\t\t\telse break;\n\t\t}\n\t\telse {\n\t\t\tif (was_backslash) {\n\t\t\t\tif (c == '\\\\' || c == 'r' || c == 'n' ||\n\t\t\t\t\tc == 't' || c == '\"')\n\t\t\t\t\t++ len;\n\t\t\t\telse break;\n\t\t\t\twas_backslash = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (c == '\"') {\n\t\t\t\t\t++ len;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t++ len;\n\t\t\t\twas_backslash = (c == '\\\\');\n\t\t\t}\n\t\t} \n\t}\n\treturn make_token(line, start, len, source, \"str\");\t\n}\n\nToken find_int(int line, const string & source, int start) {\n\tif (start < source.size()) {\n\t\tif (source[start] == '0' && (start + 1 == source.size() || (source[start + 1] < '0' || source[start + 1] > '9')))\n\t\t\treturn make_token(line, start, 1, source, \"int\");\n\t}\n\tint len = 0;\n\tfor (int i = start; i < source.size(); ++ i) {\n\t\tif ((i != start && source[i] >= '0' && source[i] <= '9' ) ||\n\t\t\t(source[i] >= '1' && source[i] <= '9'))\n\t\t\t++ len;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn make_token(line, start, len, source, \"int\");\t\n}\n\nToken find_id(int line, const string & source, int start) {\n\tint len = 0;\n\tfor (int i = start; i < source.size(); ++ i) {\n\t\tif ((i != start && source[i] >= '0' && source[i] <= '9') ||\n\t\t\t(source[i] >= 'A' && source[i] <= 'Z') ||\n\t\t\t(source[i] >= 'a' && source[i] <= 'z') ||\n\t\t\tsource[i] == '_')\n\t\t\t++ len;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn make_token(line, start, len, source, \"id\");\n}\n\nconst char *keywords[] = {\n\t\"class\", \"def\", \"if\", \"else\", \"for\", \"in\", \"return\", \"yield\", \"and\", \"or\", \"not\", \"pass\",\n\t\"True\", \"False\", \"None\",\n\t\"(\", \")\", \"[\", \"]\", \"{\", \"}\", \":\", \",\", \".\", \n\t\"==\", \">\", \"<\", \"<=\", \">=\", \"!=\", \"=\", \n\t\"+=\", \"-=\", \"*=\", \"/=\", \"//=\", \"%=\", \"&=\", \"^=\", \"|=\", \n\t\"+\", \"-\", \"**\", \"*\", \"//\", \"/\", \"%\", \"&\", \"^\", \"|\"\n};\n\nToken find_keyword(int line, const string & source, int start) {\n\tint keyword = -1;\n\tfor (int i = 0; i < sizeof(keywords) / sizeof(const char *); ++ i) {\n\t\tif (source.compare(start, strlen(keywords[i]), keywords[i]) == 0) {\n\t\t\tkeyword = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (keyword == -1)\n\t\treturn make_token(line, start, 0, source, \"\");\n\treturn make_token(line, start, strlen(keywords[keyword]), source, keywords[keyword]);\t\n}\n\nToken find_comment(int line, const string & source, int start) {\n\tint len = 0;\n\tfor (int i = start; i < source.size(); ++ i) {\n\t\tif (i != start || source[i] == '#')\n\t\t\t++ len;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn make_token(line, start, len, source, \"comment\");\n}\n\n////////////////////\n// RULES END\n\ntypedef Token (* find_function)(int, const string &, int);\n\nvoid add_tokens(HashTable<Token, Token> & tokens, int lineno, const string & line, find_function find, bool can_conflict) {\n\tint start = 0;\n\twhile (start < line.size()) {\n\t\tToken t = find(lineno, line, start);\n\t\tif (t.text.size() > 0) {\n\t\t\tif (can_conflict) {\n\t\t\t\tif (tokens.containsKey(t)) {\n\t\t\t\t\tToken old_t = tokens.get(t);\n\t\t\t\t\tif (old_t.text.size() < t.text.size())\n\t\t\t\t\t\ttokens.put(t, t);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttokens.put(t, t);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (tokens.containsKey(t)) {\n\t\t\t\t\tToken old_t = tokens.get(t);\n\t\t\t\t\tstringstream ss;\n\t\t\t\t\tss << \"Conflicting tokens:\" << endl;\n\t\t\t\t\tss << old_t << endl;\n\t\t\t\t\tss << t << endl;\n\t\t\t\t\tthrow runtime_error(ss.str());\n\t\t\t\t}\n\t\t\t\ttokens.put(t, t);\n\t\t\t}\n\t\t\tstart += t.text.size();\n\t\t}\n\t\telse\n\t\t\t++ start;\n\t}\n}\n\nvoid get_tokens(vector<string> & lines, vector<vector<Token> > & tokens) {\n\tHashTable<Token, Token> all_tokens;\n\tfor (int i = 0; i < lines.size(); ++ i) {\n\t\tToken indent = find_indent(i, lines[i]);\n\t\tif (indent.text.size() > 0)\n\t\t\tall_tokens.put(indent, indent);\n\t\tadd_tokens(all_tokens, i, lines[i], find_string, false);\n\t\tadd_tokens(all_tokens, i, lines[i], find_int, false);\n\t\tadd_tokens(all_tokens, i, lines[i], find_comment, false);\n\t\tadd_tokens(all_tokens, i, lines[i], find_keyword, false);\n\t\tadd_tokens(all_tokens, i, lines[i], find_id, true);\n\t\tadd_tokens(all_tokens, i, lines[i], find_blank, true);\n\t\t// TODO: add more lexical matching functions\n\t}\n\tToken index;\n\tfor (int i = 0; i < lines.size(); ++ i) {\n\t\ttokens.push_back(vector<Token>());\n\t\tindex.line = i;\n\t\tindex.pos = 0;\n\t\twhile (index.pos < lines[i].size()) {\n\t\t\tif (! all_tokens.containsKey(index)) {\n\t\t\t\tstringstream ss;\n\t\t\t\tss << \"Lexical error at line #\" << (index.line + 1) << \" char #\" << index.pos;\n\t\t\t\tthrow runtime_error(ss.str());\n\t\t\t}\n\t\t\tToken t = all_tokens.get(index);\n\t\t\tif (t.type != \"blank\")\n\t\t\t\ttokens[i].push_back(t);\n\t\t\tindex.pos += t.text.size();\n\t\t}\n\t}\n} \n\n////////////////////////////////////////////////////////////////////////////////\n\nstruct Node\n{\n\tint index;\n\tint span;\n\tstring type;\n\tvector<Node> children; // for non-terminal\n\tToken token; // for terminal, as \"indent\" for non-terminal\n};\n\nbool operator == (const Node & n1, const Node & n2) {\n\treturn n1.index == n2.index && n1.span == n2.span && n1.type == n2.type;\n}\n\nstring to_tree_text(string text) {\n\tfor (int i = 0; i < text.size(); ++ i)\n\t\tif (text[i] == ' ') text[i] = '_';\n\tif (text == \"(\") text = \"-LRB-\";\n\tif (text == \")\") text = \"-RRB-\";\n\treturn text;\n}\n\nvoid print_node(ostream & out, const Node & node, int indent=0) {\n\t// for (int i = 0; i < indent; ++ i) out << '\\\t';\n\tif (node.children.size() == 0) {\n\t\tout << \"( \" << to_tree_text(node.type) << ' ' << to_tree_text(node.token.text) << \" )\";\n\t}\n\telse {\n\t\t// out << node.type << \"\\\tindex=\" << node.index << \"\\\tspan=\" << node.span << endl;\n\t\tout << \"( \" << to_tree_text(node.type) << \" \";\n\t\tfor (int i = 0; i < node.children.size(); ++ i) {\n\t\t\tprint_node(out, node.children[i], indent + 1);\n\t\t}\n\t\tout << \" )\";\n\t}\n}\n\nostream & operator << (ostream & out, const Node & node) {\n\tprint_node(out, node, 0);\n\treturn out;\n}\n\n////////////////////\n// RULES BEGIN\n\nvoid make_node(const vector<Node> & node_list, vector<Node> & matched, const string & type, int len) {\n\tif (node_list.size() != len) return;\n\tNode node;\n\tnode.type = type;\n\tfor (int i = 0; i < len; ++ i)\n\t\tnode.children.push_back(node_list[i]);\n\tmatched.push_back(node);\n}\n\nvoid match_function_def(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() < 5) return;\n\tif (node_list[0].type != \"def\") return;\n\tif (node_list[1].type != \"id\") return;\n\tif (node_list[2].type != \"(\") return;\n\tint index = 3;\n\twhile (node_list[index].type == \"id\") {\n\t\t++ index;\n\t\tif (node_list.size() > index && node_list[index].type == \",\") {\n\t\t\t++ index;\n\t\t\tif (node_list.size() <= index || node_list[index].type != \"id\") return;\n\t\t}\n\t\telse break;\n\t}\n\tif (node_list.size() <= index || node_list[index].type != \")\") return;\n\t++ index;\n\tif (node_list.size() <= index || node_list[index].type != \":\") return;\n\t++ index;\n\tmake_node(node_list, matched, \"function_def\", index);\n}\n\nvoid match_expression(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() == 1) {\n\t\tif (node_list[0].type == \"function_call\" ||\n\t\t\tnode_list[0].type == \"str\" ||\n\t\t\tnode_list[0].type == \"id\" ||\n\t\t\tnode_list[0].type == \"int\" ||\n\t\t\tnode_list[0].type == \"None\" ||\n\t\t\tnode_list[0].type == \"True\" ||\n\t\t\tnode_list[0].type == \"False\")\n\t\t{\n\t\t\tmake_node(node_list, matched, \"expression1\", 1); // term\n\t\t}\n\t\telse if (node_list[0].type == \"expression1\") {\n\t\t\tmake_node(node_list, matched, \"expression2\", 1); // factor\n\t\t}\n\t\telse if (node_list[0].type == \"expression2\") {\n\t\t\tmake_node(node_list, matched, \"expression3\", 1); // exp\n\t\t}\n\t\telse if (node_list[0].type == \"expression3\") {\n\t\t\tmake_node(node_list, matched, \"expression4\", 1); // cmp\n\t\t}\n\t\telse if (node_list[0].type == \"expression4\") {\n\t\t\tmake_node(node_list, matched, \"expression5\", 1); // and\n\t\t}\n\t\telse if (node_list[0].type == \"expression5\") {\n\t\t\tmake_node(node_list, matched, \"expression\", 1); // or\n\t\t}\n\t}\n\tif (node_list.size() == 3) {\n\t\tif (node_list[0].type == \"(\" && node_list[1].type == \"expression\" && node_list[2].type == \")\") {\n\t\t\tmake_node(node_list, matched, \"expression1\", 3); // term\n\t\t}\n\t\telse if ((node_list[0].type == \"expression1\" || node_list[0].type == \"expression2L\") && node_list[1].type == \"operator_mul\" && node_list[2].type == \"expression1\") {\n\t\t\tmake_node(node_list, matched, \"expression2\", 3); // factor\n\t\t\tmake_node(node_list, matched, \"expression2L\", 3);\n\t\t}\n\t\telse if ((node_list[0].type == \"expression2\" || node_list[0].type == \"expression3L\") && node_list[1].type == \"operator_add\" && node_list[2].type == \"expression2\") {\n\t\t\tmake_node(node_list, matched, \"expression3\", 3); // exp\n\t\t\tmake_node(node_list, matched, \"expression3L\", 3);\n\t\t}\n\t\telse if ((node_list[0].type == \"expression3\" || node_list[0].type == \"expression4L\") && node_list[1].type == \"operator_cmp\" && node_list[2].type == \"expression3\") {\n\t\t\tmake_node(node_list, matched, \"expression4\", 3); // cmp\n\t\t\tmake_node(node_list, matched, \"expression4L\", 3);\n\t\t}\n\t\telse if ((node_list[0].type == \"expression4\" || node_list[0].type == \"expression5L\") && node_list[1].type == \"operator_and\" && node_list[2].type == \"expression4\") {\n\t\t\tmake_node(node_list, matched, \"expression5\", 3); // and\n\t\t\tmake_node(node_list, matched, \"expression5L\", 3);\n\t\t}\n\t\telse if ((node_list[0].type == \"expression5\" || node_list[0].type == \"expression6L\") && node_list[1].type == \"operator_or\" && node_list[2].type == \"expression5\") {\n\t\t\tmake_node(node_list, matched, \"expression\", 3); // and\n\t\t\tmake_node(node_list, matched, \"expression6L\", 3);\n\t\t}\n\t}\n}\n\nvoid match_function_call(const vector<Node> & node_list, vector<Node> & matched, int start=0) {\n\tif (node_list.size() < 4) return;\n\tif (node_list[0].type != \"id\") return;\n\tif (node_list[1].type != \"(\") return;\n\tint index = 2;\n\twhile (node_list[index].type == \"expression\") {\n\t\t++ index;\n\t\tif (node_list.size() > index && node_list[index].type == \",\") {\n\t\t\t++ index;\n\t\t\tif (node_list.size() <= index || node_list[index].type != \"expression\") return;\n\t\t}\n\t\telse break;\n\t}\n\tif (node_list.size() <= index || node_list[index].type != \")\") return;\n\t++ index;\n\tmake_node(node_list, matched, \"function_call\", index);\n}\n\nvoid match_for(const vector<Node> & node_list, vector<Node> & matched, int start=0) {\n\tif (node_list.size() != 5) return;\n\tif (node_list[0].type != \"for\") return;\n\tif (node_list[1].type != \"id\") return;\n\tif (node_list[2].type != \"in\") return;\n\tif (node_list[3].type != \"expression\") return;\n\tif (node_list[4].type != \":\") return;\n\tmake_node(node_list, matched, \"for_statement\", 5);\n}\n\nvoid match_if(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() != 3) return;\n\tif (node_list[0].type != \"if\") return;\n\tif (node_list[1].type != \"expression\") return;\n\tif (node_list[2].type != \":\") return;\n\tmake_node(node_list, matched, \"if_statement\", 3);\n}\n\nvoid match_else(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() != 2) return;\n\tif (node_list[0].type != \"else\") return;\n\tif (node_list[1].type != \":\") return;\n\tmake_node(node_list, matched, \"else_statement\", 2);\n}\n\nvoid match_operator(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() != 1) return;\n\tif (node_list[0].type == \"+\" || node_list[0].type == \"-\") {\n\t\tmake_node(node_list, matched, \"operator_add\", 1);\n\t}\n\telse if (node_list[0].type == \"*\" || node_list[0].type == \"/\" || node_list[0].type == \"%\") {\n\t\tmake_node(node_list, matched, \"operator_mul\", 1);\n\t}\n\telse if (node_list[0].type == \"==\" || node_list[0].type == \">\" || node_list[0].type == \"<\" \n\t\t || node_list[0].type == \">=\" || node_list[0].type == \"<=\" || node_list[0].type == \"!=\") {\n\t\tmake_node(node_list, matched, \"operator_cmp\", 1);\n\t}\n\telse if (node_list[0].type == \"and\") {\n\t\tmake_node(node_list, matched, \"operator_and\", 1);\n\t}\n\telse if (node_list[0].type == \"or\") {\n\t\tmake_node(node_list, matched, \"operator_or\", 1);\n\t}\n}\n\nvoid match_assign(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() != 3) return;\n\tif (node_list[0].type != \"id\") return;\n\tif (node_list[1].type != \"=\") return;\n\tif (node_list[2].type != \"expression\") return;\n\tmake_node(node_list, matched, \"assign_statement\", 3);\n}\n\nvoid match_yield(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() != 2) return;\n\tif (node_list[0].type != \"yield\") return;\n\tif (node_list[1].type != \"expression\") return;\n\tmake_node(node_list, matched, \"yield_statement\", 2);\n}\n\nvoid match_return(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() == 1) {\n\t\tif (node_list[0].type != \"return\") return;\n\t\tmake_node(node_list, matched, \"return_statement\", 1);\n\t}\n\telse if (node_list.size() == 2) {\n\t\tif (node_list[0].type != \"return\") return;\n\t\tif (node_list[1].type != \"expression\") return;\n\t\tmake_node(node_list, matched, \"return_statement\", 2);\n\t}\n}\n\nvoid match_pass(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() == 1) {\n\t\tif (node_list[0].type != \"pass\") return;\n\t\tmake_node(node_list, matched, \"pass_statement\", 1);\n\t}\n}\n\n////////////////////\n// RULES END\n\nvector<Node> check_rules(vector<Node> & node_list) {\n\tvector<Node> matched;\n\tmatch_function_def(node_list, matched);\n\tmatch_expression(node_list, matched);\n\tmatch_function_call(node_list, matched);\n\tmatch_for(node_list, matched);\n\tmatch_if(node_list, matched);\n\tmatch_else(node_list, matched);\n\tmatch_assign(node_list, matched);\n\tmatch_yield(node_list, matched);\n\tmatch_return(node_list, matched);\n\tmatch_operator(node_list, matched);\n\tmatch_pass(node_list, matched);\n\treturn matched;\n}\n\nvoid check_sequences(vector<vector<Node> > & nodes, vector<Node> & node_list, \n\tint index, vector<Node> & to_check) \n{\n\tNode last_node = node_list[node_list.size() - 1];\n\tint next_index = index + last_node.span;\n\t// cout << next_index << ' ' << nodes.size() << endl;\n\tif (next_index > nodes.size()) {\n\t\tthrow runtime_error(\"Internal error: incorrect next_index\");\n\t}\n\tvector<Node> matched = check_rules(node_list);\n\tfor (int i = 0; i < matched.size(); ++ i) {\n\t\tmatched[i].index = matched[i].children[0].index;\n\t\tmatched[i].span = 0;\n\t\tfor (int j = 0; j < matched[i].children.size(); ++ j)\n\t\t\tmatched[i].span += matched[i].children[j].span;\n\t\tfor (int j = 0; j < to_check.size(); ++ j) {\n\t\t\tif (to_check[j] == matched[i]) {\n\t\t\t\tstringstream ss;\n\t\t\t\tss << \"Internal error: repeated nodes:\" << endl;\n\t\t\t\tss << to_check[j] << endl;\n\t\t\t\tss << matched[i] << endl;\n\t\t\t\tthrow runtime_error(ss.str());\n\t\t\t}\n\t\t}\n\t\tto_check.push_back(matched[i]);\n\t}\n\t// for (int i = 0; i < matched.size(); ++ i) {\n\t// \tcout << matched[i] << endl;\n\t// }\n\tif (next_index == nodes.size()) return;\n\tfor (int i = 0; i < nodes[next_index].size(); ++ i) {\n\t\tNode node = nodes[next_index][i];\n\t\tnode_list.push_back(node);\n\t\tcheck_sequences(nodes, node_list, next_index, to_check);\n\t\tnode_list.pop_back();\n\t}\n}\n\nbool startswith(const string & text, const string & prefix) {\n\tint size = prefix.size();\n\tif (text.size() < size) return false;\n\tstring prefix2 = text.substr(0, size);\n\treturn prefix2 == prefix;\n}\n\nbool endswith(const string & text, const string & postfix) {\n\tint size = postfix.size();\n\tif (text.size() < size) return false;\n\tstring postfix2 = text.substr(text.size() - size, size);\n\treturn postfix2 == postfix;\n}\n\nNode parse_line(int lineno, vector<Token> & tokens) {\n\tvector<vector<Node> > nodes;\n\tvector<Node> to_check;\n\tint span = tokens.size();\n\tfor (int i = 0; i < tokens.size(); ++ i) {\n\t\tif (tokens[i].type == \"indent\") {\n\t\t\t-- span;\n\t\t\tcontinue;\n\t\t}\n\t\tNode node;\n\t\tnode.type = tokens[i].type;\n\t\tnode.index = nodes.size();\n\t\tnode.span = 1;\n\t\tnode.token = tokens[i];\n\t\tnodes.push_back(vector<Node>());\n\t\tto_check.push_back(node);\n\t}\n\twhile (to_check.size() > 0) {\n\t\tNode first = to_check[to_check.size() - 1];\n\t\t// cout << \"--->\" << '\\\t' << first << endl;\n\t\tto_check.pop_back();\n\t\tvector<Node> node_list;\n\t\tnode_list.push_back(first);\n\t\tnodes[first.index].push_back(first);\n\t\tcheck_sequences(nodes, node_list, first.index, to_check);\n\t}\n\tint result = -1;\n\tfor (int i = 0; i < nodes[0].size(); ++ i) {\n\t\tif (nodes[0][i].span == span) \n\t\t\tresult = i;\n\t}\n\tif (result == -1) {\n\t\tstringstream ss;\n\t\tss << \"Syntax error in line: \" << (lineno + 1);\n\t\tthrow runtime_error(ss.str());\n\t}\n\treturn nodes[0][result];\n}\n\nstruct Line\n{\n\tint level;\n\tNode node;\n\tvector<Line> children;\n};\n\nvoid print_line(ostream & out, const Line & line, int indent=0) {\n\t// for (int i = 0; i < indent; ++ i) out << '\\\t';\n\tif (line.children.size() == 0) {\n\t\t// out << \"( \" << line.node.type << \"@\" << line.level << \" _ )\";\n\t\tout << \"( \" << line.node.type << \" _ )\";\n\t}\n\telse {\n\t\t// out << \"( \" << line.node.type << \"@\" << line.level << \" \";\n\t\tout << \"( \" << line.node.type;\n\t\tfor (int i = 0; i < line.children.size(); ++ i) {\n\t\t\tprint_line(out, line.children[i], indent + 1);\n\t\t}\n\t\tout << \" )\";\n\t}\n}\n\nostream & operator << (ostream & out, const Line & line) {\n\tprint_line(out, line, 0);\n\treturn out;\n}\n\nvoid indent_error(const Token & indent) {\n\tstringstream ss;\n\tss << \"Inconsistent indentation at line: \" << indent.line;\n\tthrow runtime_error(ss.str());\n}\n\nvoid get_tree(vector<string> & lines, Line & tree) {\n\tvector<vector<Token> > tokens;\n\tvector<Node> nodes;\n\tvector<Token> indents;\n\tget_tokens(lines, tokens);\n\tfor (int i = 0; i < tokens.size(); ++ i) {\n\t\tif (tokens[i].size() > 0) {\n\t\t\tif (tokens[i][0].type == \"indent\")\n\t\t\t\tindents.push_back(tokens[i][0]);\n\t\t\telse\n\t\t\t\tindents.push_back(Token());\n\t\t\tnodes.push_back(parse_line(i, tokens[i]));\n\t\t}\n\t}\n\ttree.level = 0;\n\ttree.node.type = \"__main__\";\n\ttree.node.token.text = \"__main__\";\n\ttree.node.index = 0;\n\ttree.node.span = 0;\n\tvector<Line *> stack;\n\tvector<string> indent_stack;\n\tstack.push_back(&tree);\n\tindent_stack.push_back(\"\");\n\tfor (int i = 0; i < nodes.size(); ++ i) {\n\t\tstring last_indent = indent_stack[indent_stack.size() - 1];\n\t\tLine next;\n\t\tnext.node = nodes[i];\n\t\tLine * parent = stack[stack.size() - 1];\n\t\tif (indents[i].text == last_indent) {\n\t\t\tnext.level = parent->level + 1;\n\t\t\tparent->children.push_back(next);\n\t\t}\n\t\telse {\n\t\t\tif (startswith(indents[i].text, last_indent)) {\n\t\t\t\tindent_stack.push_back(indents[i].text);\n\t\t\t\tif (parent->children.size() == 0) indent_error(indents[i]);\n\t\t\t\tparent = &parent->children[parent->children.size() - 1];\n\t\t\t\tstack.push_back(parent);\n\t\t\t\tnext.level = parent->level + 1;\n\t\t\t\tparent->children.push_back(next);\n\t\t\t}\n\t\t\telse {\n\t\t\t\twhile (true) {\n\t\t\t\t\tif (indents[i].text == last_indent) {\n\t\t\t\t\t\tnext.level = parent->level + 1;\n\t\t\t\t\t\tparent->children.push_back(next);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (startswith(last_indent, indents[i].text)) {\n\t\t\t\t\t\tindent_stack.pop_back();\n\t\t\t\t\t\tlast_indent = indent_stack[indent_stack.size() - 1];\n\t\t\t\t\t\tstack.pop_back();\n\t\t\t\t\t\tif (stack.size() == 0) indent_error(indents[i]);\n\t\t\t\t\t\tparent = stack[stack.size() - 1];\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tindent_error(indents[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid print_nodes(ostream & out, const Line & line) {\n\tif (line.node.type != \"__main__\")\n\t\tout << line.node << endl;\n\tif (line.children.size() == 0) return;\n\tfor (int i = 0; i < line.children.size(); ++ i) {\n\t\tprint_nodes(out, line.children[i]);\n\t}\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid optim_exp(Node & node) {\n\tif (node.children.size() == 1) {\n\t\tNode child = node.children[0];\n\t\tnode = child;\n\t}\n\telse if (node.children.size() == 3 && node.children[0].type == \"(\" && node.children[2].type == \")\") {\n\t\tNode child = node.children[1];\n\t\tnode = child;\n\t}\n\tif (startswith(node.type, \"expression\"))\n\t\tnode.type = \"expression\";\n}\n\nvoid optim(Node & node) {\n\tfor (int i = 0; i < node.children.size(); ++ i)\n\t\toptim(node.children[i]);\n\tif (startswith(node.type, \"expression\"))\n\t\toptim_exp(node);\n\tif (startswith(node.type, \"operator_\"))\n\t\tnode = node.children[0];\n}\n\nvoid optim(Line & line) {\n\toptim(line.node);\n\tfor (int i = 0; i < line.children.size(); ++ i) {\n\t\toptim(line.children[i]);\n\t}\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#define foreach(type, item, vec) for (vector<type>::iterator item=vec.begin(); item != vec.end(); ++ item)\n\nvoid assert_true(bool test, const string & err_msg) {\n\tif (! test) throw runtime_error(err_msg);\n}\n\n//////////\n// TYPES\n\nstruct Variable\n{\n\tstring type;\n\tvirtual void print() {\n\t\tcout << type;\n\t}\n\tvirtual Variable * copy() {\n\t\tstringstream ss;\n\t\tss << \"'\" << type << \".copy' is not implemented\";\n\t\tassert_true(false, ss.str());\n\t\treturn 0;\n\t}\n\tvirtual Variable * __eq__(Variable * op) {\n\t\tstringstream ss;\n\t\tss << \"'\" << type << \".__eq__' is not implemented\";\n\t\tassert_true(false, ss.str());\n\t\treturn 0;\n\t}\n};\n\nstruct Int : public Variable\n{\n\tint intValue;\n\tInt(int value) {\n\t\ttype = \"int\";\n\t\tintValue = value;\n\t}\n\tvoid print() {\n\t\tcout << intValue;\n\t}\n\tvirtual Variable * copy() {\n\t\treturn new Int(intValue);\n\t}\n\tVariable * __add__(Int * op) {\n\t\tInt * ret = (Int *)copy();\n\t\tret->intValue += op->intValue;\n\t\treturn ret;\n\t}\n\tVariable * __mul__(Int * op) {\n\t\tInt * ret = (Int *)copy();\n\t\tret->intValue *= op->intValue;\n\t\treturn ret;\n\t}\n\tVariable * __mod__(Int * op) {\n\t\tInt * ret = (Int *)copy();\n\t\tret->intValue = ret->intValue % op->intValue;\n\t\treturn ret;\n\t}\n\tVariable * __eq__(Variable * op) {\n\t\tInt * op2 = (Int *)op;\n\t\treturn new Int(intValue == op2->intValue);\n\t}\n};\n\nstruct Bool : public Variable\n{\n\tbool boolValue;\n\tBool(bool value) {\n\t\ttype = \"bool\";\n\t\tboolValue = value;\n\t}\n\tvoid print() {\n\t\tif (boolValue) cout << \"True\";\n\t\telse cout << \"False\";\n\t}\n\tvirtual Variable * copy() {\n\t\treturn new Bool(boolValue);\n\t}\n\tVariable * __and__(Bool * op) {\n\t\tBool * ret = (Bool *)copy();\n\t\tret->boolValue = ret->boolValue && op->boolValue;\n\t\treturn ret;\n\t}\n\tVariable * __or__(Bool * op) {\n\t\tBool * ret = (Bool *)copy();\n\t\tret->boolValue = ret->boolValue || op->boolValue;\n\t\treturn ret;\n\t}\n\tVariable * __eq__(Variable * op) {\n\t\tBool * op2 = (Bool *)op;\n\t\treturn new Bool(boolValue == op2->boolValue);\n\t}\n};\n\n\nstruct Str : public Variable\n{\n\tstring strValue;\n\tStr(string value) {\n\t\ttype = \"str\";\n\t\tstrValue = value;\n\t}\n\tvoid print() {\n\t\tbool was_backslash = false;\n\t\tfor (int i = 1; i < strValue.size() - 1; ++ i) {\n\t\t\tchar c = strValue[i];\n\t\t\tif (was_backslash) {\n\t\t\t\tstring err_msg = \"Unknown sequence '\\\\?'\";\n\t\t\t\tswitch (c) {\n\t\t\t\t\tcase '\\\\': cout << '\\\\'; break;\n\t\t\t\t\tcase 'r': cout << '\\r'; break;\n\t\t\t\t\tcase 't': cout << '\\t'; break;\n\t\t\t\t\tcase 'n': cout << '\\n'; break;\n\t\t\t\t\tcase '\"': cout << '\"'; break;\n\t\t\t\t\tdefault: err_msg[err_msg.size() - 2] = c; assert_true(false, err_msg);\n\t\t\t\t}\n\t\t\t\twas_backslash = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (c == '\\\\') was_backslash = true;\n\t\t\t\telse cout << c;\n\t\t\t}\n\t\t}\n\t}\n\tvirtual Variable * copy() {\n\t\treturn new Str(strValue);\n\t}\n};\n\nstruct Function : public Variable\n{\n\tLine * line;\n\tFunction(Line & value) {\n\t\ttype = \"function\";\n\t\tline = &value;\n\t}\n\tvoid print() {\n\t\tcout << type << '\\t';\n\t\tprint_node(cout, line->node);\n\t}\n};\n\nstruct Pointer : public Variable\n{\n\tvoid * pointer;\n\tPointer(void * value) {\n\t\ttype = \"pointer\";\n\t\tpointer = value;\n\t}\n};\n\nstruct Variables\n{\n\tHashTable<string, Variable*> map;\n\n\tvoid print() {\n\t\tvector<string> names = map.getKeys();\n\t\tforeach (string, name, names) {\n\t\t\tcout << *name << '\\t';\n\t\t\tmap.get(*name)->print();\n\t\t\tcout << endl;\n\t\t}\n\t}\n\n\tbool hasVariable(const string & name) {\n\t\treturn map.containsKey(name);\n\t}\n\n\tvoid assertVariable(const string & name) {\n\t\tstringstream ss;\n\t\tss << \"Variable '\" << name << \"' is undefined\"; \n\t\tassert_true(map.containsKey(name), ss.str());\t\t\n\t}\n\n\tvoid assertType(const string & name, const string & type) {\n\t\tstringstream ss;\n\t\tss << \"Require '\" << type << \"', got '\" << map.get(name)->type << \"' \"; \n\t\tassert_true(map.get(name)->type == type, ss.str());\t\t\n\t}\n\n\tstring getType(const string & name) {\n\t\tassertVariable(name);\n\t\treturn map.get(name)->type;\n\t}\n\n\tvoid delVariable(const string & name, bool del=true) {\n\t\tassertVariable(name);\n\t\tif (del) delete map.get(name);\n\t\tmap.remove(name);\n\t}\n\n\tvoid setVariable(const string & name, Variable * v) {\n\t\tif (map.containsKey(name))\n\t\t\tdelete map.get(name);\n\t\tmap.put(name, v);\n\t}\n\n\tVariable * getVariable(const string & name) {\n\t\tassertVariable(name);\n\t\treturn map.get(name);\n\t}\n\n\tvoid releaseAll() {\n\t\tvector<string> names = map.getKeys();\n\t\tforeach (string, name, names)\n\t\t\tdelVariable(*name);\n\t}\n\n};\n\nstruct Context\n{\n\tstring owner;\n\tVariables & global_variables;\n\tVariables & local_variables;\n\tHashTable<string, int> global_used;\n\tvector<int> lines_running;\n\n\tContext(const string & owner_, Variables & global_variables_, Variables & local_variables_) : \n\t\towner(owner_), global_variables(global_variables_), local_variables(local_variables_) {}\n\n\tbool is_global(const string & name, bool is_assign) {\n\t\tif (local_variables.hasVariable(name)) return false;\n\t\tif (global_used.containsKey(name)) return true;\n\t\tif (is_assign) return false;\n\t\tglobal_variables.assertVariable(name);\n\t\tglobal_used.put(name, 0);\n\t\treturn true;\n\t}\n\n\tVariable * getVariable(const string & name) {\n\t\tif (is_global(name, false))\n\t\t\treturn global_variables.getVariable(name);\n\t\telse\n\t\t\treturn local_variables.getVariable(name);\n\t}\n\n\tvoid setVariable(const string & name, Variable * v) {\n\t\tif (is_global(name, true))\n\t\t\treturn global_variables.setVariable(name, v);\n\t\telse\n\t\t\treturn local_variables.setVariable(name, v);\n\t}\n\n};\n\n////////////////////\n// FUNCTIONS\n\nvoid run_builtin_range(Context & context) {\n\tVariable * v = context.local_variables.getVariable(\"n\");\n\tassert_true(v->type == \"int\", \"'range' requires a single 'int' argument\");\n\tint n = ((Int *)v)->intValue;\n\tint level = 2;\n\tif (context.lines_running.size() == level)\n\t\tcontext.lines_running.push_back(0);\n\telse\n\t\t++ context.lines_running[level];\n\tif (context.lines_running[level] >= n) return;\n\tcontext.local_variables.setVariable(\"$ret\", new Int(context.lines_running[level]));\n}\n\nint max_print_calls = 1000;\n\nvoid run_builtin_print(Context & context) {\n\tassert_true(-- max_print_calls > 0, \"Exceeds max_print_calls == 100\");\n\tVariable * v = context.local_variables.getVariable(\"n\");\n\tif (v == 0) cout << \"None\";\n\telse v->print();\n\tcout << endl;\n}\n\nvoid run_builtin(const string & function_name, Context & context) {\n\tif (function_name == \"range\") {\n\t\trun_builtin_range(context);\n\t}\n\telse if (function_name == \"print\") {\n\t\trun_builtin_print(context);\n\t}\n\telse {\n\t\tstringstream ss;\n\t\tss << \"Unknow builtin: \" << function_name << endl;\n\t\tassert_true(false, ss.str());\n\t}\n}\n\nvoid register_builtins(vector<string> & lines, Line & tree, Variables & global_variables) {\n\tget_tree(lines, tree);\n\toptim(tree);\n\tforeach (Line, line, tree.children) {\n\t\tstringstream ss;\n\t\tss << \"Invalid line in 'builtins.py: \" << line->node.type << endl;\n\t\tassert_true(line->node.type == \"function_def\", ss.str());\n\t\tline->node.type = \"builtin\";\n\t\tstring function_name = line->node.children[1].token.text;\n\t\tglobal_variables.setVariable(function_name, new Function(*line));\n\t}\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid run_lines(vector<Line> & lines, Context & context);\nvoid run_line(Line & line, Context & context);\nVariable * run_exp(Node & exp, Context & context);\n\nLine & get_function(const string & function_name, Context & context) {\n\tVariable * v = context.getVariable(function_name);\n\tstringstream ss;\n\tss << \"Not a function: \" << function_name;\n\tassert_true(v->type == \"function\" || v->type == \"builtin\", ss.str());\n\tFunction * func_var = (Function *)v;\n\treturn *(func_var->line);\n}\n\nvoid init_function_parameters(Node & func_node, Context & callee_context, Node & call_node, Context & caller_context) {\n\tint num_args = call_node.children.size() - 3;\n\tint num_params = func_node.children.size() - 5;\n\tstringstream ss;\n\tss << \"Function '\" << call_node.children[0].token.text << \"' arguments not agree\" << endl;\n\tss << \"\\tCaller gives \" << num_args << \" at line: \" << (func_node.children[0].token.line + 1) << endl;\n\tss << \"\\tCallee requires \" << num_params << \" at line: \" << (call_node.children[0].token.line + 1) << endl;\n\tassert_true(num_args == num_params, ss.str());\n\tfor (int i = 0; i < num_params; ++ i) {\n\t\tNode & arg_exp = call_node.children[2 + i];\n\t\tVariable * arg_value = run_exp(arg_exp, caller_context);\n\t\tstring parameter_name = func_node.children[3 + i].token.text;\n\t\tcallee_context.local_variables.setVariable(parameter_name, arg_value);\n\t}\t\n}\n\nVariable * run_function(Node & call_node, Context & context) {\n\tstring function_name = call_node.children[0].token.text;\n\tLine & func_line = get_function(function_name, context);\n\tVariables func_local_variables;\n\tContext func_context(function_name, context.global_variables, func_local_variables);\n\tinit_function_parameters(func_line.node, func_context, call_node, context);\n\t// func_local_variables.print();\n\tif (func_line.node.type == \"builtin\" && func_line.children.size() == 1 && func_line.children[0].node.type == \"pass_statement\")\n\t\trun_builtin(function_name, func_context);\n\telse {\n\t\twhile (func_context.lines_running.size() <= func_line.level)\n\t\t\tfunc_context.lines_running.push_back(-100);\n\t\trun_lines(func_line.children, func_context);\n\t}\n\tVariable * ret = 0;\n\tif (func_local_variables.hasVariable(\"$ret\")) {\n\t\tret = func_local_variables.getVariable(\"$ret\");\n\t\tfunc_local_variables.delVariable(\"$ret\", false);\n\t}\n\tfunc_local_variables.releaseAll();\n\treturn ret;\n}\n\nvoid pass_result(Context & from, Context & to, const string & name) {\n\tVariable * ret = from.local_variables.getVariable(\"$ret\");\n\tfrom.local_variables.delVariable(\"$ret\", false);\n\tto.local_variables.setVariable(name, ret);\n}\n\nContext * init_generator_context(Context & context, Line & gen_def_line, Node & gen_call_node) {\n\tVariables * local_variables = new Variables();\n\tstring gen_func_name = gen_call_node.children[0].token.text;\n\tContext * gen_context = new Context(gen_func_name, context.global_variables, *local_variables);\n\tinit_function_parameters(gen_def_line.node, *gen_context, gen_call_node, context);\n\tcontext.local_variables.setVariable(\"$gen\", new Pointer(gen_context));\n\twhile (gen_context->lines_running.size() <= gen_def_line.level)\n\t\tgen_context->lines_running.push_back(-100);\n\treturn gen_context;\n}\n\nvoid release_generator_context(Context & context) {\n\tPointer * v = (Pointer *)context.local_variables.getVariable(\"$gen\");\n\tContext * gen = (Context *)v->pointer;\n\tcontext.local_variables.delVariable(\"$gen\");\n\tgen->local_variables.releaseAll();\n\tdelete &(gen->local_variables);\n\tdelete gen;\n}\n\nvoid print_int_vector(vector<int> & vec) {\n\tfor (int i = 0; i < vec.size(); ++ i) cout << \" \" << vec[i];\n\tcout << endl;\n}\n\nvoid run_for_statement(Line & for_line, Context & context) {\n\tstring loop_variable_name = for_line.node.children[1].token.text;\n\tNode & gen_node = for_line.node.children[3];\n\tif (gen_node.type == \"function_call\") {\n\t\tstring gen_func_name = gen_node.children[0].token.text;\n\t\tLine & gen_def_line = get_function(gen_func_name, context);\n\t\tContext * gen_context = 0;\n\t\tif (context.local_variables.hasVariable(\"$gen\")) {\n\t\t\tPointer * gen = (Pointer *)context.local_variables.getVariable(\"$gen\");\n\t\t\tgen_context = (Context *)(gen->pointer);\n\t\t\tstringstream ss;\n\t\t\tss << \"Inconsistent generator context: required '\" << gen_func_name << \"', got '\" << gen_context->owner << \"'\";\n\t\t\tassert_true(gen_context->owner == gen_func_name, ss.str());\n\t\t}\n\t\telse \n\t\t\tgen_context = init_generator_context(context, gen_def_line, gen_node);\n\t\tbool done = false;\n\t\twhile (true) {\n\t\t\tif (gen_def_line.node.type == \"builtin\" && gen_def_line.children.size() == 1 && gen_def_line.children[0].node.type == \"pass_statement\")\n\t\t\t\trun_builtin(gen_func_name, *gen_context);\n\t\t\telse\n\t\t\t\trun_lines(gen_def_line.children, *gen_context);\n\t\t\tif (! gen_context->local_variables.hasVariable(\"$ret\")) {\n\t\t\t\tdone = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpass_result(*gen_context, context, loop_variable_name);\n\t\t\trun_lines(for_line.children, context);\n\t\t\tif (context.local_variables.hasVariable(\"$ret\")) break;\n\t\t}\n\t\tif (done) release_generator_context(context);\n\t}\n\telse {\n\t\tstringstream ss;\n\t\tss << \"Unknow generator type: \" << gen_node.type;\n\t\tassert_true(false, ss.str());\n\t}\n}\n\nVariable * run_id(Node & exp, Context & context) {\n\tstring name = exp.token.text;\n\tif (context.local_variables.hasVariable(name))\n\t\treturn context.local_variables.getVariable(name)->copy();\n\tif (context.global_variables.hasVariable(name))\n\t\treturn context.global_variables.getVariable(name)->copy();\n\tstringstream ss;\n\tss << \"Undefined variable: \" << name << endl;\n\tassert_true(false, ss.str());\n\treturn 0;\n}\n\nvoid check_op_type(const string & op, const string & required_type, const string & type) {\n\tstringstream ss;\n\tss << \"The operand of \" << op << \" must be '\" << required_type <<\"' instead of '\" << type << \"'\" << endl;\n\tassert_true(required_type == type, ss.str());\n}\n\nVariable * run_expression(Node & exp, Context & context) {\n\tstring op = \"?\";\n\tif (exp.children.size() == 3) {\n\t\top = exp.children[1].token.text;\n\t\tVariable * left = run_exp(exp.children[0], context);\n\t\tVariable * right = run_exp(exp.children[2], context);\n\t\tif (op == \"+\") {\n\t\t\tcheck_op_type(op, \"int\", left->type);\n\t\t\tcheck_op_type(op, \"int\", right->type);\n\t\t\treturn ((Int *)left)->__add__((Int *)right);\n\t\t}\n\t\telse if (op == \"*\") {\n\t\t\tcheck_op_type(op, \"int\", left->type);\n\t\t\tcheck_op_type(op, \"int\", right->type);\n\t\t\treturn ((Int *)left)->__mul__((Int *)right);\n\t\t}\n\t\telse if (op == \"%\") {\n\t\t\tcheck_op_type(op, \"int\", left->type);\n\t\t\tcheck_op_type(op, \"int\", right->type);\n\t\t\treturn ((Int *)left)->__mod__((Int *)right);\n\t\t}\n\t\telse if (op == \"and\") {\n\t\t\tcheck_op_type(op, \"bool\", left->type);\n\t\t\tcheck_op_type(op, \"bool\", right->type);\n\t\t\treturn ((Bool *)left)->__and__((Bool *)right);\n\t\t}\n\t\telse if (op == \"or\") {\n\t\t\tcheck_op_type(op, \"bool\", left->type);\n\t\t\tcheck_op_type(op, \"bool\", right->type);\n\t\t\treturn ((Bool *)left)->__or__((Bool *)right);\n\t\t}\n\t\telse if (op == \"==\") {\n\t\t\tcheck_op_type(op, left->type, right->type);\n\t\t\treturn left->__eq__(right);\n\t\t}\n\t}\n\telse if (exp.children.size() == 2) {\n\t\top = exp.children[0].token.text;\n\t}\n\tstringstream ss;\n\tss << \"Undefined operator: \" << op << endl;\n\tassert_true(false, ss.str());\n\treturn 0;\n}\n\nVariable * run_exp(Node & exp, Context & context) {\n\tif (exp.type == \"int\") {\n\t\tstringstream ss(exp.token.text);\n\t\tint intValue;\n\t\tss >> intValue;\n\t\treturn new Int(intValue);\n\t}\n\telse if (exp.type == \"str\") {\n\t\treturn new Str(exp.token.text);\n\t}\n\telse if (exp.type == \"True\") {\n\t\treturn new Bool(true);\n\t}\n\telse if (exp.type == \"False\") {\n\t\treturn new Bool(false);\n\t}\n\telse if (exp.type == \"id\") {\n\t\treturn run_id(exp, context);\n\t}\n\telse if (exp.type == \"None\") {\n\t\treturn 0;\n\t}\n\telse if (exp.type == \"function_call\") {\n\t\treturn run_function(exp, context);\n\t}\n\telse if (exp.type == \"expression\") {\n\t\treturn run_expression(exp, context);\n\t}\n\telse {\n\t\tstringstream ss;\n\t\tss << \"Unknow expression type: \" << exp.type << endl << exp << endl;\n\t\tassert_true(false, ss.str());\n\t}\n\treturn 0;\n}\n\nvoid run_yield_statement(Line & line, Context & context) {\n\tVariable * v = run_exp(line.node.children[1], context);\n\tassert_true(v != 0, \"\");\n\tcontext.local_variables.setVariable(\"$ret\", v);\n\t++ context.lines_running[line.level];\n}\n\nvoid run_return_statement(Line & line, Context & context) {\n\tVariable * v = run_exp(line.node.children[1], context);\n\tcontext.local_variables.setVariable(\"$ret\", v);\n\tcontext.lines_running.clear();\n}\n\nvoid run_assign_statement(Line & line, Context & context) {\n\tstring variable_name = line.node.children[0].token.text;\n\tVariable * v = run_exp(line.node.children[2], context);\n\tcontext.setVariable(variable_name, v);\n}\n\nbool is_true(Variable * v) {\n\tif (v == 0) {\n\t\treturn false;\n\t}\n\tif (v->type == \"bool\") {\n\t\treturn ((Bool *)v)->boolValue;\n\t}\n\telse if (v->type == \"int\") {\n\t\treturn ((Int *)v)->intValue != 0;\n\t}\n\tstringstream ss;\n\tss << \"Unknown type for condition: \" << v->type;\n\tassert_true(false, ss.str());\n\treturn false;\n}\n\nvoid run_if_statement(Line & line, Context & context) {\n\tif (context.lines_running.size() > line.level + 1) {\n\t\trun_lines(line.children, context);\n\t\treturn;\n\t}\n\tVariable * v = run_exp(line.node.children[1], context);\n\tstringstream ss;\n\tss << \"$if\" << line.level;\n\tcontext.setVariable(ss.str(), v);\n\tif (is_true(v)) {\n\t\trun_lines(line.children, context);\n\t}\n}\n\nvoid run_else_statement(Line & line, Context & context) {\n\tif (context.lines_running.size() > line.level + 1) {\n\t\trun_lines(line.children, context);\n\t\treturn;\n\t}\n\tstringstream ss;\n\tss << \"$if\" << line.level;\n\tstring condition_name = ss.str();\n\tassert_true(context.local_variables.hasVariable(condition_name), \"Dangling else-statement\");\n\tVariable * v = context.local_variables.getVariable(condition_name);\n\tif (! is_true(v)) {\n\t\trun_lines(line.children, context);\n\t}\n\tcontext.local_variables.delVariable(condition_name);\n}\n\nvoid run_line(Line & line, Context & context) {\n\tif (line.node.type == \"comment\") {\n\t}\n\telse if (line.node.type == \"function_def\") {\n\t\tstring function_name = line.node.children[1].token.text;\n\t\tcontext.local_variables.setVariable(function_name, new Function(line));\n\t}\n\telse if (line.node.type == \"function_call\") {\n\t\trun_function(line.node, context);\n\t}\n\telse if (line.node.type == \"for_statement\") {\n\t\trun_for_statement(line, context);\n\t}\n\telse if (line.node.type == \"yield_statement\") {\n\t\trun_yield_statement(line, context);\n\t}\n\telse if (line.node.type == \"return_statement\") {\n\t\trun_return_statement(line, context);\n\t}\n\telse if (line.node.type == \"assign_statement\") {\n\t\trun_assign_statement(line, context);\n\t}\n\telse if (line.node.type == \"if_statement\") {\n\t\trun_if_statement(line, context);\n\t}\n\telse if (line.node.type == \"else_statement\") {\n\t\trun_else_statement(line, context);\n\t}\n\telse {\n\t\tstringstream ss;\n\t\tss << \"Unknow line type: \" << line.node.type;\n\t\tassert_true(false, ss.str());\n\t}\n}\n\nint get_def_line(Line & line) {\n\tNode * node = &(line.node);\n\twhile (node->children.size() > 0)\n\t\tnode = &(node->children[0]);\n\treturn node->token.line;\n}\n\nvoid run_lines(vector<Line> & lines, Context & context) {\n\tint level = lines[0].level;\n\tstringstream ss;\n\tss << \"Line: \" << get_def_line(lines[0]) <<\" Incorrect level state: \" << context.lines_running.size() << \", requires >= \" << level;\n\tassert_true(context.lines_running.size() >= level, ss.str());\n\tif (context.lines_running.size() == level) {\n\t\tcontext.lines_running.push_back(0);\n\t}\n\tstringstream ss2;\n\tss2 << \"Line: \" << get_def_line(lines[0]) <<\" Incorrect level step: \" << context.lines_running[level];\n\tassert_true(context.lines_running[level] >= 0, ss2.str());\n\twhile (context.lines_running[level] < lines.size()) {\n\t\trun_line(lines[context.lines_running[level]], context);\n\t\tif (context.local_variables.hasVariable(\"$ret\")) break;\n\t\t++ context.lines_running[level];\n\t}\n\tif (context.lines_running[level] == lines.size())\n\t\tcontext.lines_running.pop_back();\n}\n\nvoid run(vector<string> & lib_lines, vector<string> & lines) {\n\t// Variables global_variables;\n\t// Line builtins_tree;\n\t// register_builtins(lib_lines, builtins_tree, global_variables);\n\n\tLine tree;\n\tget_tree(lines, tree);\n\toptim(tree);\n\tprint_nodes(cout, tree);\n\tcout << tree << endl;\n\t// Context global_context(\"__main__\", global_variables, global_variables);\n\t// while (global_context.lines_running.size() <= tree.level)\n\t// \tglobal_context.lines_running.push_back(-100);\n\t// run_lines(tree.children, global_context);\n\t// global_variables.releaseAll();\n}\n\nstring builtins = \"def print(n):\\n\\tpass\\n\\ndef range(n):\\n\\tpass\";\n\nint main() {\n\ttry {\n\t\tvector<string> lib_lines;\n\t\tvector<string> lines;\n\t\tstringstream ss(builtins);\n\t\tread_lines(ss, lib_lines);\n\t\tread_lines(cin, lines);\n\t\trun(lib_lines, lines);\n\t}\n\tcatch (runtime_error & ex) {\n\t\tcout << ex.what() << endl;\n\t}\n}",
            "print('''def test_loop(n):\n\tfor i in range(n):\n\t\tprint(123 + i * 2)\n\ndef test_condition(c):\n\tif c:\n\t\tprint(\"yes\")\n\telse:\n\t\tprint(\"no\")\n\ntest_loop(10)\ntest_condition(True)''')",
            1585713600,
            1585713600
        ],
        [
            "15.5 (C++)",
            "Please modify the simple Python compiler as follows:\n<ul>\n<li>Combine all CPP file into a single file</li>\n<li>Input from STDIO instead of from a Python file</li>\n<li>Load library from an internal string instead of from \"lib/builtins.py\"</li>\n</ul>\n\n<b>EXAMPLE INPUT</b>\n<pre>\n\ndef test_loop(n):\n\tfor i in range(n):\n\t\tprint(1 + i)\n\ndef test_condition(c):\n\tif c and True:\n\t\tprint(\"yes\")\n\telse:\n\t\tprint(\"no\")\n\ntest_loop(10)\ntest_condition(True)\n</pre>\n\n<b>EXAMPLE OUTPUT</b>\n<pre>\n( function_def ( def def )( id test_loop )( -LRB- -LRB- )( id n )( -RRB- -RRB- )( : : ) )\n( for_statement ( for for )( id i )( in in )( function_call ( id range )( -LRB- -LRB- )( id n )( -RRB- -RRB- ) )( : : ) )\n( function_call ( id print )( -LRB- -LRB- )( expression ( int 1 )( + + )( id i ) )( -RRB- -RRB- ) )\n( function_def ( def def )( id test_condition )( -LRB- -LRB- )( id c )( -RRB- -RRB- )( : : ) )\n( if_statement ( if if )( expression ( id c )( and and )( True True ) )( : : ) )\n( function_call ( id print )( -LRB- -LRB- )( str \"yes\" )( -RRB- -RRB- ) )\n( else_statement ( else else )( : : ) )\n( function_call ( id print )( -LRB- -LRB- )( str \"no\" )( -RRB- -RRB- ) )\n( function_call ( id test_loop )( -LRB- -LRB- )( int 10 )( -RRB- -RRB- ) )\n( function_call ( id test_condition )( -LRB- -LRB- )( True True )( -RRB- -RRB- ) )\n( __main__( function_def( for_statement( function_call _ ) ) )( function_def( if_statement( function_call _ ) )( else_statement( function_call _ ) ) )( function_call _ )( function_call _ ) )\n</pre>",
            "#include \"source.cpp\"",
            "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <stdexcept>\nusing namespace std;\n\n#include <cstring>\n\nint operator % (const string & text, int max) {\n\tint code = 0;\n\tfor (int i = 0; i < text.size(); ++ i) {\n\t\tint code1 = text[i];\n\t\tcode1 = code1 << (i * 8 % 24);\n\t\tcode = code ^ code1;\n\t}\n\treturn code % max;\n}\n\nclass NoSuchKeyException {};\n\ntemplate <typename K, typename V>\nclass HashTable\n{\nprivate:\n\t\t\n\tclass Entry\n\t{\n\tpublic:\n\t\tK key;\n\t\tV value;\n\t\tbool isInUse;\n\t\t\n\t\tEntry() {\n\t\t\tisInUse = false;\n\t\t}\n\t};\n\t\n\tEntry * entries;\n\t\n\tint capacity;\n\tint count;\n\t\n\tvoid initialize(int capacity2) {\n\t\tcount = 0;\n\t\tcapacity = capacity2;\n\t\tentries = new Entry[capacity];\n\t}\n\t\n\tvoid assign(const HashTable & map2) {\n\t\tcount = map2.count;\n\t\tcapacity = map2.capacity;\n\t\tentries = new Entry[capacity];\n\t\tfor (int i = 0; i < capacity; ++ i) {\n\t\t\tentries[i] = map2.entries[i];\n\t\t}\n\t}\n\t\npublic:\n\t\n\tHashTable() {\n\t\tinitialize(2);\n\t}\n\t\n\t~HashTable() {\n\t\tdelete [] entries;\n\t}\n\t\n\tHashTable(const HashTable & map2) {\n\t\tassign(map2);\n\t}\n\t\n\tHashTable & operator = (const HashTable & map2) {\n\t\tdelete [] entries;\n\t\tassign(map2);\n\t\treturn (*this);\n\t}\n\t\n\tvoid clear() {\n\t\tdelete [] entries;\n\t\tinitialize(2);\n\t}\n\t\nprivate:\n\t\n\tint hashIndex(const K & key) const {\n\t\treturn key % capacity;\n\t}\n\t\n\tint find(const K & key) const {\n\t\tint index = hashIndex(key);\n\t\twhile (true) {\n\t\t\tif (! entries[index].isInUse) {\n\t\t\t\treturn index;\n\t\t\t}\n\t\t\tif (entries[index].key == key) {\n\t\t\t\treturn index;\n\t\t\t}\n\t\t\tindex = (index + 1) % capacity;\n\t\t}\n\t}\n\t\n\tvoid resize(int capacity2) {\n\t\tEntry * entries0 = entries;\n\t\tint capacity0 = capacity;\n\t\tinitialize(capacity2);\n\t\tfor (int i = 0; i < capacity0; ++ i) {\n\t\t\tif (entries0[i].isInUse) {\n\t\t\t\tput(entries0[i].key, entries0[i].value);\n\t\t\t}\n\t\t}\n\t\tdelete [] entries0;\n\t}\n\t\npublic:\n\t\n\tvoid put(const K & key, const V & value) {\n\t\tint index = find(key);\n\t\tentries[index].value = value;\n\t\tif (entries[index].isInUse) return;\n\t\t\n\t\tentries[index].isInUse = true;\n\t\tentries[index].key = key;\n\t\t\n\t\t++ count;\n\t\tif (count > capacity / 2) {\n\t\t\tresize(capacity * 2);\n\t\t}\n\t}\n\t\n\tV get(const K & key) const {\n\t\tint index = find(key);\n\t\tif (! entries[index].isInUse) {\n\t\t\tthrow NoSuchKeyException();\n\t\t}\n\t\treturn entries[index].value;\n\t}\n\t\n\tbool remove(const K & key) {\n\t\tint index = find(key);\n\t\tif (! entries[index].isInUse) return false;\n\t\tfillNotInUseEntry(index);\n\t\t\n\t\t-- count;\n\t\tif (count < capacity / 4) {\n\t\t\tresize(capacity / 2);\n\t\t}\n\t\treturn true;\n\t}\n\t\nprivate:\n\t\n\tvoid fillNotInUseEntry(int index) {\n\t\tint next = index;\n\t\twhile (true) {\n\t\t\tnext = (next + 1) % capacity;\n\t\t\tif (! entries[next].isInUse) {\n\t\t\t\tentries[index].isInUse = false;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint index0 = hashIndex(entries[next].key);\n\t\t\tif (index < next) {\n\t\t\t\tif (index0 > index &&\n\t\t\t\t\tindex0 <= next) continue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (index0 > index ||\n\t\t\t\t\tindex0 <= next) continue;\n\t\t\t}\n\t\t\tentries[index] = entries[next];\n\t\t\tindex = next;\n\t\t}\n\t}\n\t\npublic:\n\t\n\tbool containsKey(const K & key) const {\n\t\tint index = find(key);\n\t\treturn (entries[index].isInUse);\n\t}\n\t\n\tint size() const {\n\t\treturn count;\n\t}\n\n\tvector<K> getKeys() const {\n\t\tvector<K> vec;\n\t\tfor (int i = 0; i < capacity; ++ i) {\n\t\t\tif (entries[i].isInUse) {\n\t\t\t\tvec.push_back(entries[i].key);\n\t\t\t}\n\t\t}\n\t\treturn vec;\n\t}\n\t\n};\n\n////////////////////////////////////////////////////////////////////////////////\n\nstruct Token\n{\n\tint line;\n\tint pos;\n\tstring type;\n\tstring text;\n};\n\nint operator % (const Token & t, int base) {\n\treturn (t.line * 12347 + t.pos) % base;\n}\n\nbool operator == (const Token & t1, const Token & t2) {\n\treturn t1.line == t2.line && t1.pos == t2.pos;\n}\n\nostream & operator << (ostream & out, const Token & t) {\n\tout << t.line << '\\t' << t.pos << '\\t' << t.type << \"\\t\\\"\" << t.text << \"\\\"\";\n\treturn out;\n}\n\nvoid read_lines(istream & in, vector<string> & lines) {\n\tstring line;\n\twhile (getline(in, line)) {\n\t\tlines.push_back(line);\n\t}\n}\n\nToken make_token(int line, int pos, int len, const string & source, const string & type) {\n\tToken t;\n\tt.line = line;\n\tt.pos = pos;\n\tt.type = type;\n\tt.text = source.substr(pos, len);\n\treturn t;\n}\n\n////////////////////\n// RULES BEGIN\n\nToken find_indent(int line, const string & source) {\n\tint len = 0;\n\tfor (int i = 0; i < source.size(); ++ i) {\n\t\tif (source[i] == '\\t')\n\t\t\t++ len;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn make_token(line, 0, len, source, \"indent\");\n}\n\nToken find_blank(int line, const string & source, int start) {\n\tint len = 0;\n\tfor (int i = start; i < source.size(); ++ i) {\n\t\tif (source[i] == '\\t' || source[i] == ' ')\n\t\t\t++ len;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn make_token(line, start, len, source, \"blank\");\n}\n\nToken find_string(int line, const string & source, int start) {\n\tint len = 0;\n\tbool was_backslash = false;\n\tfor (int i = start; i < source.size(); ++ i) {\n\t\tchar c = source[i];\n\t\tif (i == start) {\n\t\t\tif (c == '\"') ++ len;\n\t\t\telse break;\n\t\t}\n\t\telse {\n\t\t\tif (was_backslash) {\n\t\t\t\tif (c == '\\\\' || c == 'r' || c == 'n' ||\n\t\t\t\t\tc == 't' || c == '\"')\n\t\t\t\t\t++ len;\n\t\t\t\telse break;\n\t\t\t\twas_backslash = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (c == '\"') {\n\t\t\t\t\t++ len;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t++ len;\n\t\t\t\twas_backslash = (c == '\\\\');\n\t\t\t}\n\t\t} \n\t}\n\treturn make_token(line, start, len, source, \"str\");\t\n}\n\nToken find_int(int line, const string & source, int start) {\n\tif (start < source.size()) {\n\t\tif (source[start] == '0' && (start + 1 == source.size() || (source[start + 1] < '0' || source[start + 1] > '9')))\n\t\t\treturn make_token(line, start, 1, source, \"int\");\n\t}\n\tint len = 0;\n\tfor (int i = start; i < source.size(); ++ i) {\n\t\tif ((i != start && source[i] >= '0' && source[i] <= '9' ) ||\n\t\t\t(source[i] >= '1' && source[i] <= '9'))\n\t\t\t++ len;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn make_token(line, start, len, source, \"int\");\t\n}\n\nToken find_id(int line, const string & source, int start) {\n\tint len = 0;\n\tfor (int i = start; i < source.size(); ++ i) {\n\t\tif ((i != start && source[i] >= '0' && source[i] <= '9') ||\n\t\t\t(source[i] >= 'A' && source[i] <= 'Z') ||\n\t\t\t(source[i] >= 'a' && source[i] <= 'z') ||\n\t\t\tsource[i] == '_')\n\t\t\t++ len;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn make_token(line, start, len, source, \"id\");\n}\n\nconst char *keywords[] = {\n\t\"class\", \"def\", \"if\", \"else\", \"for\", \"in\", \"return\", \"yield\", \"and\", \"or\", \"not\", \"pass\",\n\t\"True\", \"False\", \"None\",\n\t\"(\", \")\", \"[\", \"]\", \"{\", \"}\", \":\", \",\", \".\", \n\t\"==\", \">\", \"<\", \"<=\", \">=\", \"!=\", \"=\", \n\t\"+=\", \"-=\", \"*=\", \"/=\", \"//=\", \"%=\", \"&=\", \"^=\", \"|=\", \n\t\"+\", \"-\", \"**\", \"*\", \"//\", \"/\", \"%\", \"&\", \"^\", \"|\"\n};\n\nToken find_keyword(int line, const string & source, int start) {\n\tint keyword = -1;\n\tfor (int i = 0; i < sizeof(keywords) / sizeof(const char *); ++ i) {\n\t\tif (source.compare(start, strlen(keywords[i]), keywords[i]) == 0) {\n\t\t\tkeyword = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (keyword == -1)\n\t\treturn make_token(line, start, 0, source, \"\");\n\treturn make_token(line, start, strlen(keywords[keyword]), source, keywords[keyword]);\t\n}\n\nToken find_comment(int line, const string & source, int start) {\n\tint len = 0;\n\tfor (int i = start; i < source.size(); ++ i) {\n\t\tif (i != start || source[i] == '#')\n\t\t\t++ len;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn make_token(line, start, len, source, \"comment\");\n}\n\n////////////////////\n// RULES END\n\ntypedef Token (* find_function)(int, const string &, int);\n\nvoid add_tokens(HashTable<Token, Token> & tokens, int lineno, const string & line, find_function find, bool can_conflict) {\n\tint start = 0;\n\twhile (start < line.size()) {\n\t\tToken t = find(lineno, line, start);\n\t\tif (t.text.size() > 0) {\n\t\t\tif (can_conflict) {\n\t\t\t\tif (tokens.containsKey(t)) {\n\t\t\t\t\tToken old_t = tokens.get(t);\n\t\t\t\t\tif (old_t.text.size() < t.text.size())\n\t\t\t\t\t\ttokens.put(t, t);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttokens.put(t, t);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (tokens.containsKey(t)) {\n\t\t\t\t\tToken old_t = tokens.get(t);\n\t\t\t\t\tstringstream ss;\n\t\t\t\t\tss << \"Conflicting tokens:\" << endl;\n\t\t\t\t\tss << old_t << endl;\n\t\t\t\t\tss << t << endl;\n\t\t\t\t\tthrow runtime_error(ss.str());\n\t\t\t\t}\n\t\t\t\ttokens.put(t, t);\n\t\t\t}\n\t\t\tstart += t.text.size();\n\t\t}\n\t\telse\n\t\t\t++ start;\n\t}\n}\n\nvoid get_tokens(vector<string> & lines, vector<vector<Token> > & tokens) {\n\tHashTable<Token, Token> all_tokens;\n\tfor (int i = 0; i < lines.size(); ++ i) {\n\t\tToken indent = find_indent(i, lines[i]);\n\t\tif (indent.text.size() > 0)\n\t\t\tall_tokens.put(indent, indent);\n\t\tadd_tokens(all_tokens, i, lines[i], find_string, false);\n\t\tadd_tokens(all_tokens, i, lines[i], find_int, false);\n\t\tadd_tokens(all_tokens, i, lines[i], find_comment, false);\n\t\tadd_tokens(all_tokens, i, lines[i], find_keyword, false);\n\t\tadd_tokens(all_tokens, i, lines[i], find_id, true);\n\t\tadd_tokens(all_tokens, i, lines[i], find_blank, true);\n\t\t// TODO: add more lexical matching functions\n\t}\n\tToken index;\n\tfor (int i = 0; i < lines.size(); ++ i) {\n\t\ttokens.push_back(vector<Token>());\n\t\tindex.line = i;\n\t\tindex.pos = 0;\n\t\twhile (index.pos < lines[i].size()) {\n\t\t\tif (! all_tokens.containsKey(index)) {\n\t\t\t\tstringstream ss;\n\t\t\t\tss << \"Lexical error at line #\" << (index.line + 1) << \" char #\" << index.pos;\n\t\t\t\tthrow runtime_error(ss.str());\n\t\t\t}\n\t\t\tToken t = all_tokens.get(index);\n\t\t\tif (t.type != \"blank\")\n\t\t\t\ttokens[i].push_back(t);\n\t\t\tindex.pos += t.text.size();\n\t\t}\n\t}\n} \n\n////////////////////////////////////////////////////////////////////////////////\n\nstruct Node\n{\n\tint index;\n\tint span;\n\tstring type;\n\tvector<Node> children; // for non-terminal\n\tToken token; // for terminal, as \"indent\" for non-terminal\n};\n\nbool operator == (const Node & n1, const Node & n2) {\n\treturn n1.index == n2.index && n1.span == n2.span && n1.type == n2.type;\n}\n\nstring to_tree_text(string text) {\n\tfor (int i = 0; i < text.size(); ++ i)\n\t\tif (text[i] == ' ') text[i] = '_';\n\tif (text == \"(\") text = \"-LRB-\";\n\tif (text == \")\") text = \"-RRB-\";\n\treturn text;\n}\n\nvoid print_node(ostream & out, const Node & node, int indent=0) {\n\t// for (int i = 0; i < indent; ++ i) out << '\\\t';\n\tif (node.children.size() == 0) {\n\t\tout << \"( \" << to_tree_text(node.type) << ' ' << to_tree_text(node.token.text) << \" )\";\n\t}\n\telse {\n\t\t// out << node.type << \"\\\tindex=\" << node.index << \"\\\tspan=\" << node.span << endl;\n\t\tout << \"( \" << to_tree_text(node.type) << \" \";\n\t\tfor (int i = 0; i < node.children.size(); ++ i) {\n\t\t\tprint_node(out, node.children[i], indent + 1);\n\t\t}\n\t\tout << \" )\";\n\t}\n}\n\nostream & operator << (ostream & out, const Node & node) {\n\tprint_node(out, node, 0);\n\treturn out;\n}\n\n////////////////////\n// RULES BEGIN\n\nvoid make_node(const vector<Node> & node_list, vector<Node> & matched, const string & type, int len) {\n\tif (node_list.size() != len) return;\n\tNode node;\n\tnode.type = type;\n\tfor (int i = 0; i < len; ++ i)\n\t\tnode.children.push_back(node_list[i]);\n\tmatched.push_back(node);\n}\n\nvoid match_function_def(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() < 5) return;\n\tif (node_list[0].type != \"def\") return;\n\tif (node_list[1].type != \"id\") return;\n\tif (node_list[2].type != \"(\") return;\n\tint index = 3;\n\twhile (node_list[index].type == \"id\") {\n\t\t++ index;\n\t\tif (node_list.size() > index && node_list[index].type == \",\") {\n\t\t\t++ index;\n\t\t\tif (node_list.size() <= index || node_list[index].type != \"id\") return;\n\t\t}\n\t\telse break;\n\t}\n\tif (node_list.size() <= index || node_list[index].type != \")\") return;\n\t++ index;\n\tif (node_list.size() <= index || node_list[index].type != \":\") return;\n\t++ index;\n\tmake_node(node_list, matched, \"function_def\", index);\n}\n\nvoid match_expression(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() == 1) {\n\t\tif (node_list[0].type == \"function_call\" ||\n\t\t\tnode_list[0].type == \"str\" ||\n\t\t\tnode_list[0].type == \"id\" ||\n\t\t\tnode_list[0].type == \"int\" ||\n\t\t\tnode_list[0].type == \"None\" ||\n\t\t\tnode_list[0].type == \"True\" ||\n\t\t\tnode_list[0].type == \"False\")\n\t\t{\n\t\t\tmake_node(node_list, matched, \"expression1\", 1); // term\n\t\t}\n\t\telse if (node_list[0].type == \"expression1\") {\n\t\t\tmake_node(node_list, matched, \"expression2\", 1); // factor\n\t\t}\n\t\telse if (node_list[0].type == \"expression2\") {\n\t\t\tmake_node(node_list, matched, \"expression3\", 1); // exp\n\t\t}\n\t\telse if (node_list[0].type == \"expression3\") {\n\t\t\tmake_node(node_list, matched, \"expression4\", 1); // cmp\n\t\t}\n\t\telse if (node_list[0].type == \"expression4\") {\n\t\t\tmake_node(node_list, matched, \"expression5\", 1); // and\n\t\t}\n\t\telse if (node_list[0].type == \"expression5\") {\n\t\t\tmake_node(node_list, matched, \"expression\", 1); // or\n\t\t}\n\t}\n\tif (node_list.size() == 3) {\n\t\tif (node_list[0].type == \"(\" && node_list[1].type == \"expression\" && node_list[2].type == \")\") {\n\t\t\tmake_node(node_list, matched, \"expression1\", 3); // term\n\t\t}\n\t\telse if ((node_list[0].type == \"expression1\" || node_list[0].type == \"expression2L\") && node_list[1].type == \"operator_mul\" && node_list[2].type == \"expression1\") {\n\t\t\tmake_node(node_list, matched, \"expression2\", 3); // factor\n\t\t\tmake_node(node_list, matched, \"expression2L\", 3);\n\t\t}\n\t\telse if ((node_list[0].type == \"expression2\" || node_list[0].type == \"expression3L\") && node_list[1].type == \"operator_add\" && node_list[2].type == \"expression2\") {\n\t\t\tmake_node(node_list, matched, \"expression3\", 3); // exp\n\t\t\tmake_node(node_list, matched, \"expression3L\", 3);\n\t\t}\n\t\telse if ((node_list[0].type == \"expression3\" || node_list[0].type == \"expression4L\") && node_list[1].type == \"operator_cmp\" && node_list[2].type == \"expression3\") {\n\t\t\tmake_node(node_list, matched, \"expression4\", 3); // cmp\n\t\t\tmake_node(node_list, matched, \"expression4L\", 3);\n\t\t}\n\t\telse if ((node_list[0].type == \"expression4\" || node_list[0].type == \"expression5L\") && node_list[1].type == \"operator_and\" && node_list[2].type == \"expression4\") {\n\t\t\tmake_node(node_list, matched, \"expression5\", 3); // and\n\t\t\tmake_node(node_list, matched, \"expression5L\", 3);\n\t\t}\n\t\telse if ((node_list[0].type == \"expression5\" || node_list[0].type == \"expression6L\") && node_list[1].type == \"operator_or\" && node_list[2].type == \"expression5\") {\n\t\t\tmake_node(node_list, matched, \"expression\", 3); // and\n\t\t\tmake_node(node_list, matched, \"expression6L\", 3);\n\t\t}\n\t}\n}\n\nvoid match_function_call(const vector<Node> & node_list, vector<Node> & matched, int start=0) {\n\tif (node_list.size() < 4) return;\n\tif (node_list[0].type != \"id\") return;\n\tif (node_list[1].type != \"(\") return;\n\tint index = 2;\n\twhile (node_list[index].type == \"expression\") {\n\t\t++ index;\n\t\tif (node_list.size() > index && node_list[index].type == \",\") {\n\t\t\t++ index;\n\t\t\tif (node_list.size() <= index || node_list[index].type != \"expression\") return;\n\t\t}\n\t\telse break;\n\t}\n\tif (node_list.size() <= index || node_list[index].type != \")\") return;\n\t++ index;\n\tmake_node(node_list, matched, \"function_call\", index);\n}\n\nvoid match_for(const vector<Node> & node_list, vector<Node> & matched, int start=0) {\n\tif (node_list.size() != 5) return;\n\tif (node_list[0].type != \"for\") return;\n\tif (node_list[1].type != \"id\") return;\n\tif (node_list[2].type != \"in\") return;\n\tif (node_list[3].type != \"expression\") return;\n\tif (node_list[4].type != \":\") return;\n\tmake_node(node_list, matched, \"for_statement\", 5);\n}\n\nvoid match_if(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() != 3) return;\n\tif (node_list[0].type != \"if\") return;\n\tif (node_list[1].type != \"expression\") return;\n\tif (node_list[2].type != \":\") return;\n\tmake_node(node_list, matched, \"if_statement\", 3);\n}\n\nvoid match_else(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() != 2) return;\n\tif (node_list[0].type != \"else\") return;\n\tif (node_list[1].type != \":\") return;\n\tmake_node(node_list, matched, \"else_statement\", 2);\n}\n\nvoid match_operator(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() != 1) return;\n\tif (node_list[0].type == \"+\" || node_list[0].type == \"-\") {\n\t\tmake_node(node_list, matched, \"operator_add\", 1);\n\t}\n\telse if (node_list[0].type == \"*\" || node_list[0].type == \"/\" || node_list[0].type == \"%\") {\n\t\tmake_node(node_list, matched, \"operator_mul\", 1);\n\t}\n\telse if (node_list[0].type == \"==\" || node_list[0].type == \">\" || node_list[0].type == \"<\" \n\t\t || node_list[0].type == \">=\" || node_list[0].type == \"<=\" || node_list[0].type == \"!=\") {\n\t\tmake_node(node_list, matched, \"operator_cmp\", 1);\n\t}\n\telse if (node_list[0].type == \"and\") {\n\t\tmake_node(node_list, matched, \"operator_and\", 1);\n\t}\n\telse if (node_list[0].type == \"or\") {\n\t\tmake_node(node_list, matched, \"operator_or\", 1);\n\t}\n}\n\nvoid match_assign(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() != 3) return;\n\tif (node_list[0].type != \"id\") return;\n\tif (node_list[1].type != \"=\") return;\n\tif (node_list[2].type != \"expression\") return;\n\tmake_node(node_list, matched, \"assign_statement\", 3);\n}\n\nvoid match_yield(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() != 2) return;\n\tif (node_list[0].type != \"yield\") return;\n\tif (node_list[1].type != \"expression\") return;\n\tmake_node(node_list, matched, \"yield_statement\", 2);\n}\n\nvoid match_return(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() == 1) {\n\t\tif (node_list[0].type != \"return\") return;\n\t\tmake_node(node_list, matched, \"return_statement\", 1);\n\t}\n\telse if (node_list.size() == 2) {\n\t\tif (node_list[0].type != \"return\") return;\n\t\tif (node_list[1].type != \"expression\") return;\n\t\tmake_node(node_list, matched, \"return_statement\", 2);\n\t}\n}\n\nvoid match_pass(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() == 1) {\n\t\tif (node_list[0].type != \"pass\") return;\n\t\tmake_node(node_list, matched, \"pass_statement\", 1);\n\t}\n}\n\n////////////////////\n// RULES END\n\nvector<Node> check_rules(vector<Node> & node_list) {\n\tvector<Node> matched;\n\tmatch_function_def(node_list, matched);\n\tmatch_expression(node_list, matched);\n\tmatch_function_call(node_list, matched);\n\tmatch_for(node_list, matched);\n\tmatch_if(node_list, matched);\n\tmatch_else(node_list, matched);\n\tmatch_assign(node_list, matched);\n\tmatch_yield(node_list, matched);\n\tmatch_return(node_list, matched);\n\tmatch_operator(node_list, matched);\n\tmatch_pass(node_list, matched);\n\treturn matched;\n}\n\nvoid check_sequences(vector<vector<Node> > & nodes, vector<Node> & node_list, \n\tint index, vector<Node> & to_check) \n{\n\tNode last_node = node_list[node_list.size() - 1];\n\tint next_index = index + last_node.span;\n\t// cout << next_index << ' ' << nodes.size() << endl;\n\tif (next_index > nodes.size()) {\n\t\tthrow runtime_error(\"Internal error: incorrect next_index\");\n\t}\n\tvector<Node> matched = check_rules(node_list);\n\tfor (int i = 0; i < matched.size(); ++ i) {\n\t\tmatched[i].index = matched[i].children[0].index;\n\t\tmatched[i].span = 0;\n\t\tfor (int j = 0; j < matched[i].children.size(); ++ j)\n\t\t\tmatched[i].span += matched[i].children[j].span;\n\t\tfor (int j = 0; j < to_check.size(); ++ j) {\n\t\t\tif (to_check[j] == matched[i]) {\n\t\t\t\tstringstream ss;\n\t\t\t\tss << \"Internal error: repeated nodes:\" << endl;\n\t\t\t\tss << to_check[j] << endl;\n\t\t\t\tss << matched[i] << endl;\n\t\t\t\tthrow runtime_error(ss.str());\n\t\t\t}\n\t\t}\n\t\tto_check.push_back(matched[i]);\n\t}\n\t// for (int i = 0; i < matched.size(); ++ i) {\n\t// \tcout << matched[i] << endl;\n\t// }\n\tif (next_index == nodes.size()) return;\n\tfor (int i = 0; i < nodes[next_index].size(); ++ i) {\n\t\tNode node = nodes[next_index][i];\n\t\tnode_list.push_back(node);\n\t\tcheck_sequences(nodes, node_list, next_index, to_check);\n\t\tnode_list.pop_back();\n\t}\n}\n\nbool startswith(const string & text, const string & prefix) {\n\tint size = prefix.size();\n\tif (text.size() < size) return false;\n\tstring prefix2 = text.substr(0, size);\n\treturn prefix2 == prefix;\n}\n\nbool endswith(const string & text, const string & postfix) {\n\tint size = postfix.size();\n\tif (text.size() < size) return false;\n\tstring postfix2 = text.substr(text.size() - size, size);\n\treturn postfix2 == postfix;\n}\n\nNode parse_line(int lineno, vector<Token> & tokens) {\n\tvector<vector<Node> > nodes;\n\tvector<Node> to_check;\n\tint span = tokens.size();\n\tfor (int i = 0; i < tokens.size(); ++ i) {\n\t\tif (tokens[i].type == \"indent\") {\n\t\t\t-- span;\n\t\t\tcontinue;\n\t\t}\n\t\tNode node;\n\t\tnode.type = tokens[i].type;\n\t\tnode.index = nodes.size();\n\t\tnode.span = 1;\n\t\tnode.token = tokens[i];\n\t\tnodes.push_back(vector<Node>());\n\t\tto_check.push_back(node);\n\t}\n\twhile (to_check.size() > 0) {\n\t\tNode first = to_check[to_check.size() - 1];\n\t\t// cout << \"--->\" << '\\\t' << first << endl;\n\t\tto_check.pop_back();\n\t\tvector<Node> node_list;\n\t\tnode_list.push_back(first);\n\t\tnodes[first.index].push_back(first);\n\t\tcheck_sequences(nodes, node_list, first.index, to_check);\n\t}\n\tint result = -1;\n\tfor (int i = 0; i < nodes[0].size(); ++ i) {\n\t\tif (nodes[0][i].span == span) \n\t\t\tresult = i;\n\t}\n\tif (result == -1) {\n\t\tstringstream ss;\n\t\tss << \"Syntax error in line: \" << (lineno + 1);\n\t\tthrow runtime_error(ss.str());\n\t}\n\treturn nodes[0][result];\n}\n\nstruct Line\n{\n\tint level;\n\tNode node;\n\tvector<Line> children;\n};\n\nvoid print_line(ostream & out, const Line & line, int indent=0) {\n\t// for (int i = 0; i < indent; ++ i) out << '\\\t';\n\tif (line.children.size() == 0) {\n\t\t// out << \"( \" << line.node.type << \"@\" << line.level << \" _ )\";\n\t\tout << \"( \" << line.node.type << \" _ )\";\n\t}\n\telse {\n\t\t// out << \"( \" << line.node.type << \"@\" << line.level << \" \";\n\t\tout << \"( \" << line.node.type;\n\t\tfor (int i = 0; i < line.children.size(); ++ i) {\n\t\t\tprint_line(out, line.children[i], indent + 1);\n\t\t}\n\t\tout << \" )\";\n\t}\n}\n\nostream & operator << (ostream & out, const Line & line) {\n\tprint_line(out, line, 0);\n\treturn out;\n}\n\nvoid indent_error(const Token & indent) {\n\tstringstream ss;\n\tss << \"Inconsistent indentation at line: \" << indent.line;\n\tthrow runtime_error(ss.str());\n}\n\nvoid get_tree(vector<string> & lines, Line & tree) {\n\tvector<vector<Token> > tokens;\n\tvector<Node> nodes;\n\tvector<Token> indents;\n\tget_tokens(lines, tokens);\n\tfor (int i = 0; i < tokens.size(); ++ i) {\n\t\tif (tokens[i].size() > 0) {\n\t\t\tif (tokens[i][0].type == \"indent\")\n\t\t\t\tindents.push_back(tokens[i][0]);\n\t\t\telse\n\t\t\t\tindents.push_back(Token());\n\t\t\tnodes.push_back(parse_line(i, tokens[i]));\n\t\t}\n\t}\n\ttree.level = 0;\n\ttree.node.type = \"__main__\";\n\ttree.node.token.text = \"__main__\";\n\ttree.node.index = 0;\n\ttree.node.span = 0;\n\tvector<Line *> stack;\n\tvector<string> indent_stack;\n\tstack.push_back(&tree);\n\tindent_stack.push_back(\"\");\n\tfor (int i = 0; i < nodes.size(); ++ i) {\n\t\tstring last_indent = indent_stack[indent_stack.size() - 1];\n\t\tLine next;\n\t\tnext.node = nodes[i];\n\t\tLine * parent = stack[stack.size() - 1];\n\t\tif (indents[i].text == last_indent) {\n\t\t\tnext.level = parent->level + 1;\n\t\t\tparent->children.push_back(next);\n\t\t}\n\t\telse {\n\t\t\tif (startswith(indents[i].text, last_indent)) {\n\t\t\t\tindent_stack.push_back(indents[i].text);\n\t\t\t\tif (parent->children.size() == 0) indent_error(indents[i]);\n\t\t\t\tparent = &parent->children[parent->children.size() - 1];\n\t\t\t\tstack.push_back(parent);\n\t\t\t\tnext.level = parent->level + 1;\n\t\t\t\tparent->children.push_back(next);\n\t\t\t}\n\t\t\telse {\n\t\t\t\twhile (true) {\n\t\t\t\t\tif (indents[i].text == last_indent) {\n\t\t\t\t\t\tnext.level = parent->level + 1;\n\t\t\t\t\t\tparent->children.push_back(next);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (startswith(last_indent, indents[i].text)) {\n\t\t\t\t\t\tindent_stack.pop_back();\n\t\t\t\t\t\tlast_indent = indent_stack[indent_stack.size() - 1];\n\t\t\t\t\t\tstack.pop_back();\n\t\t\t\t\t\tif (stack.size() == 0) indent_error(indents[i]);\n\t\t\t\t\t\tparent = stack[stack.size() - 1];\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tindent_error(indents[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid print_nodes(ostream & out, const Line & line) {\n\tif (line.node.type != \"__main__\")\n\t\tout << line.node << endl;\n\tif (line.children.size() == 0) return;\n\tfor (int i = 0; i < line.children.size(); ++ i) {\n\t\tprint_nodes(out, line.children[i]);\n\t}\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid optim_exp(Node & node) {\n\tif (node.children.size() == 1) {\n\t\tNode child = node.children[0];\n\t\tnode = child;\n\t}\n\telse if (node.children.size() == 3 && node.children[0].type == \"(\" && node.children[2].type == \")\") {\n\t\tNode child = node.children[1];\n\t\tnode = child;\n\t}\n\tif (startswith(node.type, \"expression\"))\n\t\tnode.type = \"expression\";\n}\n\nvoid optim(Node & node) {\n\tfor (int i = 0; i < node.children.size(); ++ i)\n\t\toptim(node.children[i]);\n\tif (startswith(node.type, \"expression\"))\n\t\toptim_exp(node);\n\tif (startswith(node.type, \"operator_\"))\n\t\tnode = node.children[0];\n}\n\nvoid optim(Line & line) {\n\toptim(line.node);\n\tfor (int i = 0; i < line.children.size(); ++ i) {\n\t\toptim(line.children[i]);\n\t}\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#define foreach(type, item, vec) for (vector<type>::iterator item=vec.begin(); item != vec.end(); ++ item)\n\nvoid assert_true(bool test, const string & err_msg) {\n\tif (! test) throw runtime_error(err_msg);\n}\n\n//////////\n// TYPES\n\nstruct Variable\n{\n\tstring type;\n\tvirtual void print() {\n\t\tcout << type;\n\t}\n\tvirtual Variable * copy() {\n\t\tstringstream ss;\n\t\tss << \"'\" << type << \".copy' is not implemented\";\n\t\tassert_true(false, ss.str());\n\t\treturn 0;\n\t}\n\tvirtual Variable * __eq__(Variable * op) {\n\t\tstringstream ss;\n\t\tss << \"'\" << type << \".__eq__' is not implemented\";\n\t\tassert_true(false, ss.str());\n\t\treturn 0;\n\t}\n};\n\nstruct Int : public Variable\n{\n\tint intValue;\n\tInt(int value) {\n\t\ttype = \"int\";\n\t\tintValue = value;\n\t}\n\tvoid print() {\n\t\tcout << intValue;\n\t}\n\tvirtual Variable * copy() {\n\t\treturn new Int(intValue);\n\t}\n\tVariable * __add__(Int * op) {\n\t\tInt * ret = (Int *)copy();\n\t\tret->intValue += op->intValue;\n\t\treturn ret;\n\t}\n\tVariable * __mul__(Int * op) {\n\t\tInt * ret = (Int *)copy();\n\t\tret->intValue *= op->intValue;\n\t\treturn ret;\n\t}\n\tVariable * __mod__(Int * op) {\n\t\tInt * ret = (Int *)copy();\n\t\tret->intValue = ret->intValue % op->intValue;\n\t\treturn ret;\n\t}\n\tVariable * __eq__(Variable * op) {\n\t\tInt * op2 = (Int *)op;\n\t\treturn new Int(intValue == op2->intValue);\n\t}\n};\n\nstruct Bool : public Variable\n{\n\tbool boolValue;\n\tBool(bool value) {\n\t\ttype = \"bool\";\n\t\tboolValue = value;\n\t}\n\tvoid print() {\n\t\tif (boolValue) cout << \"True\";\n\t\telse cout << \"False\";\n\t}\n\tvirtual Variable * copy() {\n\t\treturn new Bool(boolValue);\n\t}\n\tVariable * __and__(Bool * op) {\n\t\tBool * ret = (Bool *)copy();\n\t\tret->boolValue = ret->boolValue && op->boolValue;\n\t\treturn ret;\n\t}\n\tVariable * __or__(Bool * op) {\n\t\tBool * ret = (Bool *)copy();\n\t\tret->boolValue = ret->boolValue || op->boolValue;\n\t\treturn ret;\n\t}\n\tVariable * __eq__(Variable * op) {\n\t\tBool * op2 = (Bool *)op;\n\t\treturn new Bool(boolValue == op2->boolValue);\n\t}\n};\n\n\nstruct Str : public Variable\n{\n\tstring strValue;\n\tStr(string value) {\n\t\ttype = \"str\";\n\t\tstrValue = value;\n\t}\n\tvoid print() {\n\t\tbool was_backslash = false;\n\t\tfor (int i = 1; i < strValue.size() - 1; ++ i) {\n\t\t\tchar c = strValue[i];\n\t\t\tif (was_backslash) {\n\t\t\t\tstring err_msg = \"Unknown sequence '\\\\?'\";\n\t\t\t\tswitch (c) {\n\t\t\t\t\tcase '\\\\': cout << '\\\\'; break;\n\t\t\t\t\tcase 'r': cout << '\\r'; break;\n\t\t\t\t\tcase 't': cout << '\\t'; break;\n\t\t\t\t\tcase 'n': cout << '\\n'; break;\n\t\t\t\t\tcase '\"': cout << '\"'; break;\n\t\t\t\t\tdefault: err_msg[err_msg.size() - 2] = c; assert_true(false, err_msg);\n\t\t\t\t}\n\t\t\t\twas_backslash = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (c == '\\\\') was_backslash = true;\n\t\t\t\telse cout << c;\n\t\t\t}\n\t\t}\n\t}\n\tvirtual Variable * copy() {\n\t\treturn new Str(strValue);\n\t}\n};\n\nstruct Function : public Variable\n{\n\tLine * line;\n\tFunction(Line & value) {\n\t\ttype = \"function\";\n\t\tline = &value;\n\t}\n\tvoid print() {\n\t\tcout << type << '\\t';\n\t\tprint_node(cout, line->node);\n\t}\n};\n\nstruct Pointer : public Variable\n{\n\tvoid * pointer;\n\tPointer(void * value) {\n\t\ttype = \"pointer\";\n\t\tpointer = value;\n\t}\n};\n\nstruct Variables\n{\n\tHashTable<string, Variable*> map;\n\n\tvoid print() {\n\t\tvector<string> names = map.getKeys();\n\t\tforeach (string, name, names) {\n\t\t\tcout << *name << '\\t';\n\t\t\tmap.get(*name)->print();\n\t\t\tcout << endl;\n\t\t}\n\t}\n\n\tbool hasVariable(const string & name) {\n\t\treturn map.containsKey(name);\n\t}\n\n\tvoid assertVariable(const string & name) {\n\t\tstringstream ss;\n\t\tss << \"Variable '\" << name << \"' is undefined\"; \n\t\tassert_true(map.containsKey(name), ss.str());\t\t\n\t}\n\n\tvoid assertType(const string & name, const string & type) {\n\t\tstringstream ss;\n\t\tss << \"Require '\" << type << \"', got '\" << map.get(name)->type << \"' \"; \n\t\tassert_true(map.get(name)->type == type, ss.str());\t\t\n\t}\n\n\tstring getType(const string & name) {\n\t\tassertVariable(name);\n\t\treturn map.get(name)->type;\n\t}\n\n\tvoid delVariable(const string & name, bool del=true) {\n\t\tassertVariable(name);\n\t\tif (del) delete map.get(name);\n\t\tmap.remove(name);\n\t}\n\n\tvoid setVariable(const string & name, Variable * v) {\n\t\tif (map.containsKey(name))\n\t\t\tdelete map.get(name);\n\t\tmap.put(name, v);\n\t}\n\n\tVariable * getVariable(const string & name) {\n\t\tassertVariable(name);\n\t\treturn map.get(name);\n\t}\n\n\tvoid releaseAll() {\n\t\tvector<string> names = map.getKeys();\n\t\tforeach (string, name, names)\n\t\t\tdelVariable(*name);\n\t}\n\n};\n\nstruct Context\n{\n\tstring owner;\n\tVariables & global_variables;\n\tVariables & local_variables;\n\tHashTable<string, int> global_used;\n\tvector<int> lines_running;\n\n\tContext(const string & owner_, Variables & global_variables_, Variables & local_variables_) : \n\t\towner(owner_), global_variables(global_variables_), local_variables(local_variables_) {}\n\n\tbool is_global(const string & name, bool is_assign) {\n\t\tif (local_variables.hasVariable(name)) return false;\n\t\tif (global_used.containsKey(name)) return true;\n\t\tif (is_assign) return false;\n\t\tglobal_variables.assertVariable(name);\n\t\tglobal_used.put(name, 0);\n\t\treturn true;\n\t}\n\n\tVariable * getVariable(const string & name) {\n\t\tif (is_global(name, false))\n\t\t\treturn global_variables.getVariable(name);\n\t\telse\n\t\t\treturn local_variables.getVariable(name);\n\t}\n\n\tvoid setVariable(const string & name, Variable * v) {\n\t\tif (is_global(name, true))\n\t\t\treturn global_variables.setVariable(name, v);\n\t\telse\n\t\t\treturn local_variables.setVariable(name, v);\n\t}\n\n};\n\n////////////////////\n// FUNCTIONS\n\nvoid run_builtin_range(Context & context) {\n\tVariable * v = context.local_variables.getVariable(\"n\");\n\tassert_true(v->type == \"int\", \"'range' requires a single 'int' argument\");\n\tint n = ((Int *)v)->intValue;\n\tint level = 2;\n\tif (context.lines_running.size() == level)\n\t\tcontext.lines_running.push_back(0);\n\telse\n\t\t++ context.lines_running[level];\n\tif (context.lines_running[level] >= n) return;\n\tcontext.local_variables.setVariable(\"$ret\", new Int(context.lines_running[level]));\n}\n\nint max_print_calls = 1000;\n\nvoid run_builtin_print(Context & context) {\n\tassert_true(-- max_print_calls > 0, \"Exceeds max_print_calls == 100\");\n\tVariable * v = context.local_variables.getVariable(\"n\");\n\tif (v == 0) cout << \"None\";\n\telse v->print();\n\tcout << endl;\n}\n\nvoid run_builtin(const string & function_name, Context & context) {\n\tif (function_name == \"range\") {\n\t\trun_builtin_range(context);\n\t}\n\telse if (function_name == \"print\") {\n\t\trun_builtin_print(context);\n\t}\n\telse {\n\t\tstringstream ss;\n\t\tss << \"Unknow builtin: \" << function_name << endl;\n\t\tassert_true(false, ss.str());\n\t}\n}\n\nvoid register_builtins(vector<string> & lines, Line & tree, Variables & global_variables) {\n\tget_tree(lines, tree);\n\toptim(tree);\n\tforeach (Line, line, tree.children) {\n\t\tstringstream ss;\n\t\tss << \"Invalid line in 'builtins.py: \" << line->node.type << endl;\n\t\tassert_true(line->node.type == \"function_def\", ss.str());\n\t\tline->node.type = \"builtin\";\n\t\tstring function_name = line->node.children[1].token.text;\n\t\tglobal_variables.setVariable(function_name, new Function(*line));\n\t}\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid run_lines(vector<Line> & lines, Context & context);\nvoid run_line(Line & line, Context & context);\nVariable * run_exp(Node & exp, Context & context);\n\nLine & get_function(const string & function_name, Context & context) {\n\tVariable * v = context.getVariable(function_name);\n\tstringstream ss;\n\tss << \"Not a function: \" << function_name;\n\tassert_true(v->type == \"function\" || v->type == \"builtin\", ss.str());\n\tFunction * func_var = (Function *)v;\n\treturn *(func_var->line);\n}\n\nvoid init_function_parameters(Node & func_node, Context & callee_context, Node & call_node, Context & caller_context) {\n\tint num_args = call_node.children.size() - 3;\n\tint num_params = func_node.children.size() - 5;\n\tstringstream ss;\n\tss << \"Function '\" << call_node.children[0].token.text << \"' arguments not agree\" << endl;\n\tss << \"\\tCaller gives \" << num_args << \" at line: \" << (func_node.children[0].token.line + 1) << endl;\n\tss << \"\\tCallee requires \" << num_params << \" at line: \" << (call_node.children[0].token.line + 1) << endl;\n\tassert_true(num_args == num_params, ss.str());\n\tfor (int i = 0; i < num_params; ++ i) {\n\t\tNode & arg_exp = call_node.children[2 + i];\n\t\tVariable * arg_value = run_exp(arg_exp, caller_context);\n\t\tstring parameter_name = func_node.children[3 + i].token.text;\n\t\tcallee_context.local_variables.setVariable(parameter_name, arg_value);\n\t}\t\n}\n\nVariable * run_function(Node & call_node, Context & context) {\n\tstring function_name = call_node.children[0].token.text;\n\tLine & func_line = get_function(function_name, context);\n\tVariables func_local_variables;\n\tContext func_context(function_name, context.global_variables, func_local_variables);\n\tinit_function_parameters(func_line.node, func_context, call_node, context);\n\t// func_local_variables.print();\n\tif (func_line.node.type == \"builtin\" && func_line.children.size() == 1 && func_line.children[0].node.type == \"pass_statement\")\n\t\trun_builtin(function_name, func_context);\n\telse {\n\t\twhile (func_context.lines_running.size() <= func_line.level)\n\t\t\tfunc_context.lines_running.push_back(-100);\n\t\trun_lines(func_line.children, func_context);\n\t}\n\tVariable * ret = 0;\n\tif (func_local_variables.hasVariable(\"$ret\")) {\n\t\tret = func_local_variables.getVariable(\"$ret\");\n\t\tfunc_local_variables.delVariable(\"$ret\", false);\n\t}\n\tfunc_local_variables.releaseAll();\n\treturn ret;\n}\n\nvoid pass_result(Context & from, Context & to, const string & name) {\n\tVariable * ret = from.local_variables.getVariable(\"$ret\");\n\tfrom.local_variables.delVariable(\"$ret\", false);\n\tto.local_variables.setVariable(name, ret);\n}\n\nContext * init_generator_context(Context & context, Line & gen_def_line, Node & gen_call_node) {\n\tVariables * local_variables = new Variables();\n\tstring gen_func_name = gen_call_node.children[0].token.text;\n\tContext * gen_context = new Context(gen_func_name, context.global_variables, *local_variables);\n\tinit_function_parameters(gen_def_line.node, *gen_context, gen_call_node, context);\n\tcontext.local_variables.setVariable(\"$gen\", new Pointer(gen_context));\n\twhile (gen_context->lines_running.size() <= gen_def_line.level)\n\t\tgen_context->lines_running.push_back(-100);\n\treturn gen_context;\n}\n\nvoid release_generator_context(Context & context) {\n\tPointer * v = (Pointer *)context.local_variables.getVariable(\"$gen\");\n\tContext * gen = (Context *)v->pointer;\n\tcontext.local_variables.delVariable(\"$gen\");\n\tgen->local_variables.releaseAll();\n\tdelete &(gen->local_variables);\n\tdelete gen;\n}\n\nvoid print_int_vector(vector<int> & vec) {\n\tfor (int i = 0; i < vec.size(); ++ i) cout << \" \" << vec[i];\n\tcout << endl;\n}\n\nvoid run_for_statement(Line & for_line, Context & context) {\n\tstring loop_variable_name = for_line.node.children[1].token.text;\n\tNode & gen_node = for_line.node.children[3];\n\tif (gen_node.type == \"function_call\") {\n\t\tstring gen_func_name = gen_node.children[0].token.text;\n\t\tLine & gen_def_line = get_function(gen_func_name, context);\n\t\tContext * gen_context = 0;\n\t\tif (context.local_variables.hasVariable(\"$gen\")) {\n\t\t\tPointer * gen = (Pointer *)context.local_variables.getVariable(\"$gen\");\n\t\t\tgen_context = (Context *)(gen->pointer);\n\t\t\tstringstream ss;\n\t\t\tss << \"Inconsistent generator context: required '\" << gen_func_name << \"', got '\" << gen_context->owner << \"'\";\n\t\t\tassert_true(gen_context->owner == gen_func_name, ss.str());\n\t\t}\n\t\telse \n\t\t\tgen_context = init_generator_context(context, gen_def_line, gen_node);\n\t\tbool done = false;\n\t\twhile (true) {\n\t\t\tif (gen_def_line.node.type == \"builtin\" && gen_def_line.children.size() == 1 && gen_def_line.children[0].node.type == \"pass_statement\")\n\t\t\t\trun_builtin(gen_func_name, *gen_context);\n\t\t\telse\n\t\t\t\trun_lines(gen_def_line.children, *gen_context);\n\t\t\tif (! gen_context->local_variables.hasVariable(\"$ret\")) {\n\t\t\t\tdone = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpass_result(*gen_context, context, loop_variable_name);\n\t\t\trun_lines(for_line.children, context);\n\t\t\tif (context.local_variables.hasVariable(\"$ret\")) break;\n\t\t}\n\t\tif (done) release_generator_context(context);\n\t}\n\telse {\n\t\tstringstream ss;\n\t\tss << \"Unknow generator type: \" << gen_node.type;\n\t\tassert_true(false, ss.str());\n\t}\n}\n\nVariable * run_id(Node & exp, Context & context) {\n\tstring name = exp.token.text;\n\tif (context.local_variables.hasVariable(name))\n\t\treturn context.local_variables.getVariable(name)->copy();\n\tif (context.global_variables.hasVariable(name))\n\t\treturn context.global_variables.getVariable(name)->copy();\n\tstringstream ss;\n\tss << \"Undefined variable: \" << name << endl;\n\tassert_true(false, ss.str());\n\treturn 0;\n}\n\nvoid check_op_type(const string & op, const string & required_type, const string & type) {\n\tstringstream ss;\n\tss << \"The operand of \" << op << \" must be '\" << required_type <<\"' instead of '\" << type << \"'\" << endl;\n\tassert_true(required_type == type, ss.str());\n}\n\nVariable * run_expression(Node & exp, Context & context) {\n\tstring op = \"?\";\n\tif (exp.children.size() == 3) {\n\t\top = exp.children[1].token.text;\n\t\tVariable * left = run_exp(exp.children[0], context);\n\t\tVariable * right = run_exp(exp.children[2], context);\n\t\tif (op == \"+\") {\n\t\t\tcheck_op_type(op, \"int\", left->type);\n\t\t\tcheck_op_type(op, \"int\", right->type);\n\t\t\treturn ((Int *)left)->__add__((Int *)right);\n\t\t}\n\t\telse if (op == \"*\") {\n\t\t\tcheck_op_type(op, \"int\", left->type);\n\t\t\tcheck_op_type(op, \"int\", right->type);\n\t\t\treturn ((Int *)left)->__mul__((Int *)right);\n\t\t}\n\t\telse if (op == \"%\") {\n\t\t\tcheck_op_type(op, \"int\", left->type);\n\t\t\tcheck_op_type(op, \"int\", right->type);\n\t\t\treturn ((Int *)left)->__mod__((Int *)right);\n\t\t}\n\t\telse if (op == \"and\") {\n\t\t\tcheck_op_type(op, \"bool\", left->type);\n\t\t\tcheck_op_type(op, \"bool\", right->type);\n\t\t\treturn ((Bool *)left)->__and__((Bool *)right);\n\t\t}\n\t\telse if (op == \"or\") {\n\t\t\tcheck_op_type(op, \"bool\", left->type);\n\t\t\tcheck_op_type(op, \"bool\", right->type);\n\t\t\treturn ((Bool *)left)->__or__((Bool *)right);\n\t\t}\n\t\telse if (op == \"==\") {\n\t\t\tcheck_op_type(op, left->type, right->type);\n\t\t\treturn left->__eq__(right);\n\t\t}\n\t}\n\telse if (exp.children.size() == 2) {\n\t\top = exp.children[0].token.text;\n\t}\n\tstringstream ss;\n\tss << \"Undefined operator: \" << op << endl;\n\tassert_true(false, ss.str());\n\treturn 0;\n}\n\nVariable * run_exp(Node & exp, Context & context) {\n\tif (exp.type == \"int\") {\n\t\tstringstream ss(exp.token.text);\n\t\tint intValue;\n\t\tss >> intValue;\n\t\treturn new Int(intValue);\n\t}\n\telse if (exp.type == \"str\") {\n\t\treturn new Str(exp.token.text);\n\t}\n\telse if (exp.type == \"True\") {\n\t\treturn new Bool(true);\n\t}\n\telse if (exp.type == \"False\") {\n\t\treturn new Bool(false);\n\t}\n\telse if (exp.type == \"id\") {\n\t\treturn run_id(exp, context);\n\t}\n\telse if (exp.type == \"None\") {\n\t\treturn 0;\n\t}\n\telse if (exp.type == \"function_call\") {\n\t\treturn run_function(exp, context);\n\t}\n\telse if (exp.type == \"expression\") {\n\t\treturn run_expression(exp, context);\n\t}\n\telse {\n\t\tstringstream ss;\n\t\tss << \"Unknow expression type: \" << exp.type << endl << exp << endl;\n\t\tassert_true(false, ss.str());\n\t}\n\treturn 0;\n}\n\nvoid run_yield_statement(Line & line, Context & context) {\n\tVariable * v = run_exp(line.node.children[1], context);\n\tassert_true(v != 0, \"\");\n\tcontext.local_variables.setVariable(\"$ret\", v);\n\t++ context.lines_running[line.level];\n}\n\nvoid run_return_statement(Line & line, Context & context) {\n\tVariable * v = run_exp(line.node.children[1], context);\n\tcontext.local_variables.setVariable(\"$ret\", v);\n\tcontext.lines_running.clear();\n}\n\nvoid run_assign_statement(Line & line, Context & context) {\n\tstring variable_name = line.node.children[0].token.text;\n\tVariable * v = run_exp(line.node.children[2], context);\n\tcontext.setVariable(variable_name, v);\n}\n\nbool is_true(Variable * v) {\n\tif (v == 0) {\n\t\treturn false;\n\t}\n\tif (v->type == \"bool\") {\n\t\treturn ((Bool *)v)->boolValue;\n\t}\n\telse if (v->type == \"int\") {\n\t\treturn ((Int *)v)->intValue != 0;\n\t}\n\tstringstream ss;\n\tss << \"Unknown type for condition: \" << v->type;\n\tassert_true(false, ss.str());\n\treturn false;\n}\n\nvoid run_if_statement(Line & line, Context & context) {\n\tif (context.lines_running.size() > line.level + 1) {\n\t\trun_lines(line.children, context);\n\t\treturn;\n\t}\n\tVariable * v = run_exp(line.node.children[1], context);\n\tstringstream ss;\n\tss << \"$if\" << line.level;\n\tcontext.setVariable(ss.str(), v);\n\tif (is_true(v)) {\n\t\trun_lines(line.children, context);\n\t}\n}\n\nvoid run_else_statement(Line & line, Context & context) {\n\tif (context.lines_running.size() > line.level + 1) {\n\t\trun_lines(line.children, context);\n\t\treturn;\n\t}\n\tstringstream ss;\n\tss << \"$if\" << line.level;\n\tstring condition_name = ss.str();\n\tassert_true(context.local_variables.hasVariable(condition_name), \"Dangling else-statement\");\n\tVariable * v = context.local_variables.getVariable(condition_name);\n\tif (! is_true(v)) {\n\t\trun_lines(line.children, context);\n\t}\n\tcontext.local_variables.delVariable(condition_name);\n}\n\nvoid run_line(Line & line, Context & context) {\n\tif (line.node.type == \"comment\") {\n\t}\n\telse if (line.node.type == \"function_def\") {\n\t\tstring function_name = line.node.children[1].token.text;\n\t\tcontext.local_variables.setVariable(function_name, new Function(line));\n\t}\n\telse if (line.node.type == \"function_call\") {\n\t\trun_function(line.node, context);\n\t}\n\telse if (line.node.type == \"for_statement\") {\n\t\trun_for_statement(line, context);\n\t}\n\telse if (line.node.type == \"yield_statement\") {\n\t\trun_yield_statement(line, context);\n\t}\n\telse if (line.node.type == \"return_statement\") {\n\t\trun_return_statement(line, context);\n\t}\n\telse if (line.node.type == \"assign_statement\") {\n\t\trun_assign_statement(line, context);\n\t}\n\telse if (line.node.type == \"if_statement\") {\n\t\trun_if_statement(line, context);\n\t}\n\telse if (line.node.type == \"else_statement\") {\n\t\trun_else_statement(line, context);\n\t}\n\telse {\n\t\tstringstream ss;\n\t\tss << \"Unknow line type: \" << line.node.type;\n\t\tassert_true(false, ss.str());\n\t}\n}\n\nint get_def_line(Line & line) {\n\tNode * node = &(line.node);\n\twhile (node->children.size() > 0)\n\t\tnode = &(node->children[0]);\n\treturn node->token.line;\n}\n\nvoid run_lines(vector<Line> & lines, Context & context) {\n\tint level = lines[0].level;\n\tstringstream ss;\n\tss << \"Line: \" << get_def_line(lines[0]) <<\" Incorrect level state: \" << context.lines_running.size() << \", requires >= \" << level;\n\tassert_true(context.lines_running.size() >= level, ss.str());\n\tif (context.lines_running.size() == level) {\n\t\tcontext.lines_running.push_back(0);\n\t}\n\tstringstream ss2;\n\tss2 << \"Line: \" << get_def_line(lines[0]) <<\" Incorrect level step: \" << context.lines_running[level];\n\tassert_true(context.lines_running[level] >= 0, ss2.str());\n\twhile (context.lines_running[level] < lines.size()) {\n\t\trun_line(lines[context.lines_running[level]], context);\n\t\tif (context.local_variables.hasVariable(\"$ret\")) break;\n\t\t++ context.lines_running[level];\n\t}\n\tif (context.lines_running[level] == lines.size())\n\t\tcontext.lines_running.pop_back();\n}\n\nvoid run(vector<string> & lib_lines, vector<string> & lines) {\n\t// Variables global_variables;\n\t// Line builtins_tree;\n\t// register_builtins(lib_lines, builtins_tree, global_variables);\n\n\tLine tree;\n\tget_tree(lines, tree);\n\toptim(tree);\n\tprint_nodes(cout, tree);\n\tcout << tree << endl;\n\t// Context global_context(\"__main__\", global_variables, global_variables);\n\t// while (global_context.lines_running.size() <= tree.level)\n\t// \tglobal_context.lines_running.push_back(-100);\n\t// run_lines(tree.children, global_context);\n\t// global_variables.releaseAll();\n}\n\nstring builtins = \"def print(n):\\n\\tpass\\n\\ndef range(n):\\n\\tpass\";\n\nint main() {\n\ttry {\n\t\tvector<string> lib_lines;\n\t\tvector<string> lines;\n\t\tstringstream ss(builtins);\n\t\tread_lines(ss, lib_lines);\n\t\tread_lines(cin, lines);\n\t\trun(lib_lines, lines);\n\t}\n\tcatch (runtime_error & ex) {\n\t\tcout << ex.what() << endl;\n\t}\n}",
            "print('''def test_loop(n):\n\tfor i in range(n):\n\t\tprint(123 + i)\n\ndef test_condition(c):\n\tif c and True:\n\t\tprint(\"good\")\n\telse:\n\t\tprint(\"no\")\n\ntest_loop(10)\ntest_condition(True)''')",
            1585713600,
            1585713600
        ],
        [
            "16.1 (C++)",
            "<b>给C++提供类似可变长参数的功能</b>\n<br>\n请实现类Args，自持10个以内参数，使得main函数能运行正确。\n<br>\n<br>\n<b>OUTPUT</b>\n<pre>\n100\n1\n2\n3\n4\n5\n6\n7\n8\n9\nhello\ngood\nmorning\nbye\n</pre>",
            "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#include \"source.cpp\"\n\nvoid test(int arg1, vector<int> args1, string arg2, vector<string> args2) {\n\tcout << arg1 << endl;\n\tfor (int i = 0; i < args1.size(); ++ i) {\n\t\tcout << args1[i] << endl;\n\t}\n\tcout << arg2 << endl;\n\tfor (int i = 0; i < args2.size(); ++ i) {\n\t\tcout << args2[i] << endl;\n\t}\n}\n\nint main() {\n\ttest(100, Args<int>(1,2,3,4,5,6,7,8,9), \"hello\", Args<string>(\"good\", \"morning\", \"bye\"));\n}",
            "template <typename E>\nclass Args\n{\n\tstatic E zero;\n\tvector<E> data;\npublic:\n\tArgs(E a1=zero, E a2=zero, E a3=zero, E a4=zero, E a5=zero, E a6=zero, E a7=zero, E a8=zero, E a9=zero, E a10=zero) {\n\t\tint size = 0;\n\t\tif (a10 != zero) size=10;\n\t\telse if (a9 != zero) size=9;\n\t\telse if (a8 != zero) size=8;\n\t\telse if (a7 != zero) size=7;\n\t\telse if (a6 != zero) size=6;\n\t\telse if (a5 != zero) size=5;\n\t\telse if (a4 != zero) size=4;\n\t\telse if (a3 != zero) size=3;\n\t\telse if (a2 != zero) size=2;\n\t\telse if (a1 != zero) size=1;\n\t\tif (size >= 1) data.push_back(a1);\n\t\tif (size >= 2) data.push_back(a2);\n\t\tif (size >= 3) data.push_back(a3);\n\t\tif (size >= 4) data.push_back(a4);\n\t\tif (size >= 5) data.push_back(a5);\n\t\tif (size >= 6) data.push_back(a6);\n\t\tif (size >= 7) data.push_back(a7);\n\t\tif (size >= 8) data.push_back(a8);\n\t\tif (size >= 9) data.push_back(a9);\n\t\tif (size >= 10) data.push_back(a10);\n\t}\n\t\n\toperator vector<E> () const {\n\t\treturn data;\n\t}\n};\n\ntemplate <typename E>\nE Args<E>::zero;",
            "",
            1585713600,
            1585713600
        ],
        [
            "16.2 (C++)",
            "Please modify the simple Python compiler as follows:\n<ul>\n<li>Combine all CPP file into a single file</li>\n<li>Input from STDIO instead of from a Python file</li>\n<li>Load library from an internal string instead of from \"lib/builtins.py\"</li>\n</ul>\n\n<b>EXAMPLE INPUT</b>\n<pre>\ndef test_loop(n):\n\tfor i in range(n):\n\t\tprint(1 + i)\n\ndef test_condition(c):\n\tif c:\n\t\tprint(\"yes\")\n\telse:\n\t\tprint(\"no\")\n\ntest_loop(10)\ntest_condition(True)\n</pre>\n\n<b>EXAMPLE OUTPUT</b>\n<pre>\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nyes\n</pre>",
            "#include \"source.cpp\"",
            "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <stdexcept>\nusing namespace std;\n\n#include <cstring>\n\nint operator % (const string & text, int max) {\n\tint code = 0;\n\tfor (int i = 0; i < text.size(); ++ i) {\n\t\tint code1 = text[i];\n\t\tcode1 = code1 << (i * 8 % 24);\n\t\tcode = code ^ code1;\n\t}\n\treturn code % max;\n}\n\nclass NoSuchKeyException {};\n\ntemplate <typename K, typename V>\nclass HashTable\n{\nprivate:\n\t\t\n\tclass Entry\n\t{\n\tpublic:\n\t\tK key;\n\t\tV value;\n\t\tbool isInUse;\n\t\t\n\t\tEntry() {\n\t\t\tisInUse = false;\n\t\t}\n\t};\n\t\n\tEntry * entries;\n\t\n\tint capacity;\n\tint count;\n\t\n\tvoid initialize(int capacity2) {\n\t\tcount = 0;\n\t\tcapacity = capacity2;\n\t\tentries = new Entry[capacity];\n\t}\n\t\n\tvoid assign(const HashTable & map2) {\n\t\tcount = map2.count;\n\t\tcapacity = map2.capacity;\n\t\tentries = new Entry[capacity];\n\t\tfor (int i = 0; i < capacity; ++ i) {\n\t\t\tentries[i] = map2.entries[i];\n\t\t}\n\t}\n\t\npublic:\n\t\n\tHashTable() {\n\t\tinitialize(2);\n\t}\n\t\n\t~HashTable() {\n\t\tdelete [] entries;\n\t}\n\t\n\tHashTable(const HashTable & map2) {\n\t\tassign(map2);\n\t}\n\t\n\tHashTable & operator = (const HashTable & map2) {\n\t\tdelete [] entries;\n\t\tassign(map2);\n\t\treturn (*this);\n\t}\n\t\n\tvoid clear() {\n\t\tdelete [] entries;\n\t\tinitialize(2);\n\t}\n\t\nprivate:\n\t\n\tint hashIndex(const K & key) const {\n\t\treturn key % capacity;\n\t}\n\t\n\tint find(const K & key) const {\n\t\tint index = hashIndex(key);\n\t\twhile (true) {\n\t\t\tif (! entries[index].isInUse) {\n\t\t\t\treturn index;\n\t\t\t}\n\t\t\tif (entries[index].key == key) {\n\t\t\t\treturn index;\n\t\t\t}\n\t\t\tindex = (index + 1) % capacity;\n\t\t}\n\t}\n\t\n\tvoid resize(int capacity2) {\n\t\tEntry * entries0 = entries;\n\t\tint capacity0 = capacity;\n\t\tinitialize(capacity2);\n\t\tfor (int i = 0; i < capacity0; ++ i) {\n\t\t\tif (entries0[i].isInUse) {\n\t\t\t\tput(entries0[i].key, entries0[i].value);\n\t\t\t}\n\t\t}\n\t\tdelete [] entries0;\n\t}\n\t\npublic:\n\t\n\tvoid put(const K & key, const V & value) {\n\t\tint index = find(key);\n\t\tentries[index].value = value;\n\t\tif (entries[index].isInUse) return;\n\t\t\n\t\tentries[index].isInUse = true;\n\t\tentries[index].key = key;\n\t\t\n\t\t++ count;\n\t\tif (count > capacity / 2) {\n\t\t\tresize(capacity * 2);\n\t\t}\n\t}\n\t\n\tV get(const K & key) const {\n\t\tint index = find(key);\n\t\tif (! entries[index].isInUse) {\n\t\t\tthrow NoSuchKeyException();\n\t\t}\n\t\treturn entries[index].value;\n\t}\n\t\n\tbool remove(const K & key) {\n\t\tint index = find(key);\n\t\tif (! entries[index].isInUse) return false;\n\t\tfillNotInUseEntry(index);\n\t\t\n\t\t-- count;\n\t\tif (count < capacity / 4) {\n\t\t\tresize(capacity / 2);\n\t\t}\n\t\treturn true;\n\t}\n\t\nprivate:\n\t\n\tvoid fillNotInUseEntry(int index) {\n\t\tint next = index;\n\t\twhile (true) {\n\t\t\tnext = (next + 1) % capacity;\n\t\t\tif (! entries[next].isInUse) {\n\t\t\t\tentries[index].isInUse = false;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint index0 = hashIndex(entries[next].key);\n\t\t\tif (index < next) {\n\t\t\t\tif (index0 > index &&\n\t\t\t\t\tindex0 <= next) continue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (index0 > index ||\n\t\t\t\t\tindex0 <= next) continue;\n\t\t\t}\n\t\t\tentries[index] = entries[next];\n\t\t\tindex = next;\n\t\t}\n\t}\n\t\npublic:\n\t\n\tbool containsKey(const K & key) const {\n\t\tint index = find(key);\n\t\treturn (entries[index].isInUse);\n\t}\n\t\n\tint size() const {\n\t\treturn count;\n\t}\n\n\tvector<K> getKeys() const {\n\t\tvector<K> vec;\n\t\tfor (int i = 0; i < capacity; ++ i) {\n\t\t\tif (entries[i].isInUse) {\n\t\t\t\tvec.push_back(entries[i].key);\n\t\t\t}\n\t\t}\n\t\treturn vec;\n\t}\n\t\n};\n\n////////////////////////////////////////////////////////////////////////////////\n\nstruct Token\n{\n\tint line;\n\tint pos;\n\tstring type;\n\tstring text;\n};\n\nint operator % (const Token & t, int base) {\n\treturn (t.line * 12347 + t.pos) % base;\n}\n\nbool operator == (const Token & t1, const Token & t2) {\n\treturn t1.line == t2.line && t1.pos == t2.pos;\n}\n\nostream & operator << (ostream & out, const Token & t) {\n\tout << t.line << '\\t' << t.pos << '\\t' << t.type << \"\\t\\\"\" << t.text << \"\\\"\";\n\treturn out;\n}\n\nvoid read_lines(istream & in, vector<string> & lines) {\n\tstring line;\n\twhile (getline(in, line)) {\n\t\tlines.push_back(line);\n\t}\n}\n\nToken make_token(int line, int pos, int len, const string & source, const string & type) {\n\tToken t;\n\tt.line = line;\n\tt.pos = pos;\n\tt.type = type;\n\tt.text = source.substr(pos, len);\n\treturn t;\n}\n\n////////////////////\n// RULES BEGIN\n\nToken find_indent(int line, const string & source) {\n\tint len = 0;\n\tfor (int i = 0; i < source.size(); ++ i) {\n\t\tif (source[i] == '\\t')\n\t\t\t++ len;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn make_token(line, 0, len, source, \"indent\");\n}\n\nToken find_blank(int line, const string & source, int start) {\n\tint len = 0;\n\tfor (int i = start; i < source.size(); ++ i) {\n\t\tif (source[i] == '\\t' || source[i] == ' ')\n\t\t\t++ len;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn make_token(line, start, len, source, \"blank\");\n}\n\nToken find_string(int line, const string & source, int start) {\n\tint len = 0;\n\tbool was_backslash = false;\n\tfor (int i = start; i < source.size(); ++ i) {\n\t\tchar c = source[i];\n\t\tif (i == start) {\n\t\t\tif (c == '\"') ++ len;\n\t\t\telse break;\n\t\t}\n\t\telse {\n\t\t\tif (was_backslash) {\n\t\t\t\tif (c == '\\\\' || c == '\\r' || c == '\\n' ||\n\t\t\t\t\tc == '\\t' || c == '\"')\n\t\t\t\t\t++ len;\n\t\t\t\telse break;\n\t\t\t\twas_backslash = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (c == '\"') {\n\t\t\t\t\t++ len;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t++ len;\n\t\t\t\twas_backslash = (c == '\\\\');\n\t\t\t}\n\t\t} \n\t}\n\treturn make_token(line, start, len, source, \"str\");\t\n}\n\nToken find_int(int line, const string & source, int start) {\n\tif (start < source.size()) {\n\t\tif (source[start] == '0' && (start + 1 == source.size() || (source[start + 1] < '0' || source[start + 1] > '9')))\n\t\t\treturn make_token(line, start, 1, source, \"int\");\n\t}\n\tint len = 0;\n\tfor (int i = start; i < source.size(); ++ i) {\n\t\tif ((i != start && source[i] >= '0' && source[i] <= '9' ) ||\n\t\t\t(source[i] >= '1' && source[i] <= '9'))\n\t\t\t++ len;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn make_token(line, start, len, source, \"int\");\t\n}\n\nToken find_id(int line, const string & source, int start) {\n\tint len = 0;\n\tfor (int i = start; i < source.size(); ++ i) {\n\t\tif ((i != start && source[i] >= '0' && source[i] <= '9') ||\n\t\t\t(source[i] >= 'A' && source[i] <= 'Z') ||\n\t\t\t(source[i] >= 'a' && source[i] <= 'z') ||\n\t\t\tsource[i] == '_')\n\t\t\t++ len;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn make_token(line, start, len, source, \"id\");\n}\n\nconst char *keywords[] = {\n\t\"class\", \"def\", \"if\", \"else\", \"for\", \"in\", \"return\", \"yield\", \"and\", \"or\", \"not\", \"pass\",\n\t\"True\", \"False\", \"None\",\n\t\"(\", \")\", \"[\", \"]\", \"{\", \"}\", \":\", \",\", \".\", \n\t\"==\", \">\", \"<\", \"<=\", \">=\", \"!=\", \"=\", \n\t\"+=\", \"-=\", \"*=\", \"/=\", \"//=\", \"%=\", \"&=\", \"^=\", \"|=\", \n\t\"+\", \"-\", \"**\", \"*\", \"//\", \"/\", \"%\", \"&\", \"^\", \"|\"\n};\n\nToken find_keyword(int line, const string & source, int start) {\n\tint keyword = -1;\n\tfor (int i = 0; i < sizeof(keywords) / sizeof(const char *); ++ i) {\n\t\tif (source.compare(start, strlen(keywords[i]), keywords[i]) == 0) {\n\t\t\tkeyword = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (keyword == -1)\n\t\treturn make_token(line, start, 0, source, \"\");\n\treturn make_token(line, start, strlen(keywords[keyword]), source, keywords[keyword]);\t\n}\n\nToken find_comment(int line, const string & source, int start) {\n\tint len = 0;\n\tfor (int i = start; i < source.size(); ++ i) {\n\t\tif (i != start || source[i] == '#')\n\t\t\t++ len;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn make_token(line, start, len, source, \"comment\");\n}\n\n////////////////////\n// RULES END\n\ntypedef Token (* find_function)(int, const string &, int);\n\nvoid add_tokens(HashTable<Token, Token> & tokens, int lineno, const string & line, find_function find, bool can_conflict) {\n\tint start = 0;\n\twhile (start < line.size()) {\n\t\tToken t = find(lineno, line, start);\n\t\tif (t.text.size() > 0) {\n\t\t\tif (can_conflict) {\n\t\t\t\tif (tokens.containsKey(t)) {\n\t\t\t\t\tToken old_t = tokens.get(t);\n\t\t\t\t\tif (old_t.text.size() < t.text.size())\n\t\t\t\t\t\ttokens.put(t, t);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttokens.put(t, t);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (tokens.containsKey(t)) {\n\t\t\t\t\tToken old_t = tokens.get(t);\n\t\t\t\t\tstringstream ss;\n\t\t\t\t\tss << \"Conflicting tokens:\" << endl;\n\t\t\t\t\tss << old_t << endl;\n\t\t\t\t\tss << t << endl;\n\t\t\t\t\tthrow runtime_error(ss.str());\n\t\t\t\t}\n\t\t\t\ttokens.put(t, t);\n\t\t\t}\n\t\t\tstart += t.text.size();\n\t\t}\n\t\telse\n\t\t\t++ start;\n\t}\n}\n\nvoid get_tokens(vector<string> & lines, vector<vector<Token> > & tokens) {\n\tHashTable<Token, Token> all_tokens;\n\tfor (int i = 0; i < lines.size(); ++ i) {\n\t\tToken indent = find_indent(i, lines[i]);\n\t\tif (indent.text.size() > 0)\n\t\t\tall_tokens.put(indent, indent);\n\t\tadd_tokens(all_tokens, i, lines[i], find_string, false);\n\t\tadd_tokens(all_tokens, i, lines[i], find_int, false);\n\t\tadd_tokens(all_tokens, i, lines[i], find_comment, false);\n\t\tadd_tokens(all_tokens, i, lines[i], find_keyword, false);\n\t\tadd_tokens(all_tokens, i, lines[i], find_id, true);\n\t\tadd_tokens(all_tokens, i, lines[i], find_blank, true);\n\t\t// TODO: add more lexical matching functions\n\t}\n\tToken index;\n\tfor (int i = 0; i < lines.size(); ++ i) {\n\t\ttokens.push_back(vector<Token>());\n\t\tindex.line = i;\n\t\tindex.pos = 0;\n\t\twhile (index.pos < lines[i].size()) {\n\t\t\tif (! all_tokens.containsKey(index)) {\n\t\t\t\tstringstream ss;\n\t\t\t\tss << \"Lexical error at line #\" << (index.line + 1) << \" char #\" << index.pos;\n\t\t\t\tthrow runtime_error(ss.str());\n\t\t\t}\n\t\t\tToken t = all_tokens.get(index);\n\t\t\tif (t.type != \"blank\")\n\t\t\t\ttokens[i].push_back(t);\n\t\t\tindex.pos += t.text.size();\n\t\t}\n\t}\n} \n\n////////////////////////////////////////////////////////////////////////////////\n\nstruct Node\n{\n\tint index;\n\tint span;\n\tstring type;\n\tvector<Node> children; // for non-terminal\n\tToken token; // for terminal, as \"indent\" for non-terminal\n};\n\nbool operator == (const Node & n1, const Node & n2) {\n\treturn n1.index == n2.index && n1.span == n2.span && n1.type == n2.type;\n}\n\nstring to_tree_text(string text) {\n\tfor (int i = 0; i < text.size(); ++ i)\n\t\tif (text[i] == ' ') text[i] = '_';\n\tif (text == \"(\") text = \"-LRB-\";\n\tif (text == \")\") text = \"-RRB-\";\n\treturn text;\n}\n\nvoid print_node(ostream & out, const Node & node, int indent=0) {\n\t// for (int i = 0; i < indent; ++ i) out << '\\t';\n\tif (node.children.size() == 0) {\n\t\tout << \"( \" << to_tree_text(node.type) << ' ' << to_tree_text(node.token.text) << \" )\";\n\t}\n\telse {\n\t\t// out << node.type << \"\\tindex=\" << node.index << \"\\tspan=\" << node.span << endl;\n\t\tout << \"( \" << to_tree_text(node.type) << \" \";\n\t\tfor (int i = 0; i < node.children.size(); ++ i) {\n\t\t\tprint_node(out, node.children[i], indent + 1);\n\t\t}\n\t\tout << \" )\";\n\t}\n}\n\nostream & operator << (ostream & out, const Node & node) {\n\tprint_node(out, node, 0);\n\treturn out;\n}\n\n////////////////////\n// RULES BEGIN\n\nvoid make_node(const vector<Node> & node_list, vector<Node> & matched, const string & type, int len) {\n\tif (node_list.size() != len) return;\n\tNode node;\n\tnode.type = type;\n\tfor (int i = 0; i < len; ++ i)\n\t\tnode.children.push_back(node_list[i]);\n\tmatched.push_back(node);\n}\n\nvoid match_function_def(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() < 5) return;\n\tif (node_list[0].type != \"def\") return;\n\tif (node_list[1].type != \"id\") return;\n\tif (node_list[2].type != \"(\") return;\n\tint index = 3;\n\twhile (node_list[index].type == \"id\") {\n\t\t++ index;\n\t\tif (node_list.size() > index && node_list[index].type == \",\") {\n\t\t\t++ index;\n\t\t\tif (node_list.size() <= index || node_list[index].type != \"id\") return;\n\t\t}\n\t\telse break;\n\t}\n\tif (node_list.size() <= index || node_list[index].type != \")\") return;\n\t++ index;\n\tif (node_list.size() <= index || node_list[index].type != \":\") return;\n\t++ index;\n\tmake_node(node_list, matched, \"function_def\", index);\n}\n\nvoid match_expression(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() == 1) {\n\t\tif (node_list[0].type == \"function_call\" ||\n\t\t\tnode_list[0].type == \"str\" ||\n\t\t\tnode_list[0].type == \"id\" ||\n\t\t\tnode_list[0].type == \"int\" ||\n\t\t\tnode_list[0].type == \"None\" ||\n\t\t\tnode_list[0].type == \"True\" ||\n\t\t\tnode_list[0].type == \"False\")\n\t\t{\n\t\t\tmake_node(node_list, matched, \"expression1\", 1); // term\n\t\t}\n\t\telse if (node_list[0].type == \"expression1\") {\n\t\t\tmake_node(node_list, matched, \"expression2\", 1); // factor\n\t\t}\n\t\telse if (node_list[0].type == \"expression2\") {\n\t\t\tmake_node(node_list, matched, \"expression3\", 1); // exp\n\t\t}\n\t\telse if (node_list[0].type == \"expression3\") {\n\t\t\tmake_node(node_list, matched, \"expression4\", 1); // cmp\n\t\t}\n\t\telse if (node_list[0].type == \"expression4\") {\n\t\t\tmake_node(node_list, matched, \"expression5\", 1); // and\n\t\t}\n\t\telse if (node_list[0].type == \"expression5\") {\n\t\t\tmake_node(node_list, matched, \"expression\", 1); // or\n\t\t}\n\t}\n\tif (node_list.size() == 3) {\n\t\tif (node_list[0].type == \"(\" && node_list[1].type == \"expression\" && node_list[2].type == \")\") {\n\t\t\tmake_node(node_list, matched, \"expression1\", 3); // term\n\t\t}\n\t\telse if ((node_list[0].type == \"expression1\" || node_list[0].type == \"expression2L\") && node_list[1].type == \"operator_mul\" && node_list[2].type == \"expression1\") {\n\t\t\tmake_node(node_list, matched, \"expression2\", 3); // factor\n\t\t\tmake_node(node_list, matched, \"expression2L\", 3);\n\t\t}\n\t\telse if ((node_list[0].type == \"expression2\" || node_list[0].type == \"expression3L\") && node_list[1].type == \"operator_add\" && node_list[2].type == \"expression2\") {\n\t\t\tmake_node(node_list, matched, \"expression3\", 3); // exp\n\t\t\tmake_node(node_list, matched, \"expression3L\", 3);\n\t\t}\n\t\telse if ((node_list[0].type == \"expression3\" || node_list[0].type == \"expression4L\") && node_list[1].type == \"operator_cmp\" && node_list[2].type == \"expression3\") {\n\t\t\tmake_node(node_list, matched, \"expression4\", 3); // cmp\n\t\t\tmake_node(node_list, matched, \"expression4L\", 3);\n\t\t}\n\t\telse if ((node_list[0].type == \"expression4\" || node_list[0].type == \"expression5L\") && node_list[1].type == \"operator_and\" && node_list[2].type == \"expression4\") {\n\t\t\tmake_node(node_list, matched, \"expression5\", 3); // and\n\t\t\tmake_node(node_list, matched, \"expression5L\", 3);\n\t\t}\n\t\telse if ((node_list[0].type == \"expression5\" || node_list[0].type == \"expression6L\") && node_list[1].type == \"operator_or\" && node_list[2].type == \"expression5\") {\n\t\t\tmake_node(node_list, matched, \"expression\", 3); // and\n\t\t\tmake_node(node_list, matched, \"expression6L\", 3);\n\t\t}\n\t}\n}\n\nvoid match_function_call(const vector<Node> & node_list, vector<Node> & matched, int start=0) {\n\tif (node_list.size() < 4) return;\n\tif (node_list[0].type != \"id\") return;\n\tif (node_list[1].type != \"(\") return;\n\tint index = 2;\n\twhile (node_list[index].type == \"expression\") {\n\t\t++ index;\n\t\tif (node_list.size() > index && node_list[index].type == \",\") {\n\t\t\t++ index;\n\t\t\tif (node_list.size() <= index || node_list[index].type != \"expression\") return;\n\t\t}\n\t\telse break;\n\t}\n\tif (node_list.size() <= index || node_list[index].type != \")\") return;\n\t++ index;\n\tmake_node(node_list, matched, \"function_call\", index);\n}\n\nvoid match_for(const vector<Node> & node_list, vector<Node> & matched, int start=0) {\n\tif (node_list.size() != 5) return;\n\tif (node_list[0].type != \"for\") return;\n\tif (node_list[1].type != \"id\") return;\n\tif (node_list[2].type != \"in\") return;\n\tif (node_list[3].type != \"expression\") return;\n\tif (node_list[4].type != \":\") return;\n\tmake_node(node_list, matched, \"for_statement\", 5);\n}\n\nvoid match_if(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() != 3) return;\n\tif (node_list[0].type != \"if\") return;\n\tif (node_list[1].type != \"expression\") return;\n\tif (node_list[2].type != \":\") return;\n\tmake_node(node_list, matched, \"if_statement\", 3);\n}\n\nvoid match_else(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() != 2) return;\n\tif (node_list[0].type != \"else\") return;\n\tif (node_list[1].type != \":\") return;\n\tmake_node(node_list, matched, \"else_statement\", 2);\n}\n\nvoid match_operator(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() != 1) return;\n\tif (node_list[0].type == \"+\" || node_list[0].type == \"-\") {\n\t\tmake_node(node_list, matched, \"operator_add\", 1);\n\t}\n\telse if (node_list[0].type == \"*\" || node_list[0].type == \"/\" || node_list[0].type == \"%\") {\n\t\tmake_node(node_list, matched, \"operator_mul\", 1);\n\t}\n\telse if (node_list[0].type == \"==\" || node_list[0].type == \">\" || node_list[0].type == \"<\" \n\t\t || node_list[0].type == \">=\" || node_list[0].type == \"<=\" || node_list[0].type == \"!=\") {\n\t\tmake_node(node_list, matched, \"operator_cmp\", 1);\n\t}\n\telse if (node_list[0].type == \"and\") {\n\t\tmake_node(node_list, matched, \"operator_and\", 1);\n\t}\n\telse if (node_list[0].type == \"or\") {\n\t\tmake_node(node_list, matched, \"operator_or\", 1);\n\t}\n}\n\nvoid match_assign(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() != 3) return;\n\tif (node_list[0].type != \"id\") return;\n\tif (node_list[1].type != \"=\") return;\n\tif (node_list[2].type != \"expression\") return;\n\tmake_node(node_list, matched, \"assign_statement\", 3);\n}\n\nvoid match_yield(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() != 2) return;\n\tif (node_list[0].type != \"yield\") return;\n\tif (node_list[1].type != \"expression\") return;\n\tmake_node(node_list, matched, \"yield_statement\", 2);\n}\n\nvoid match_return(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() == 1) {\n\t\tif (node_list[0].type != \"return\") return;\n\t\tmake_node(node_list, matched, \"return_statement\", 1);\n\t}\n\telse if (node_list.size() == 2) {\n\t\tif (node_list[0].type != \"return\") return;\n\t\tif (node_list[1].type != \"expression\") return;\n\t\tmake_node(node_list, matched, \"return_statement\", 2);\n\t}\n}\n\nvoid match_pass(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() == 1) {\n\t\tif (node_list[0].type != \"pass\") return;\n\t\tmake_node(node_list, matched, \"pass_statement\", 1);\n\t}\n}\n\n////////////////////\n// RULES END\n\nvector<Node> check_rules(vector<Node> & node_list) {\n\tvector<Node> matched;\n\tmatch_function_def(node_list, matched);\n\tmatch_expression(node_list, matched);\n\tmatch_function_call(node_list, matched);\n\tmatch_for(node_list, matched);\n\tmatch_if(node_list, matched);\n\tmatch_else(node_list, matched);\n\tmatch_assign(node_list, matched);\n\tmatch_yield(node_list, matched);\n\tmatch_return(node_list, matched);\n\tmatch_operator(node_list, matched);\n\tmatch_pass(node_list, matched);\n\treturn matched;\n}\n\nvoid check_sequences(vector<vector<Node> > & nodes, vector<Node> & node_list, \n\tint index, vector<Node> & to_check) \n{\n\tNode last_node = node_list[node_list.size() - 1];\n\tint next_index = index + last_node.span;\n\t// cout << next_index << ' ' << nodes.size() << endl;\n\tif (next_index > nodes.size()) {\n\t\tthrow runtime_error(\"Internal error: incorrect next_index\");\n\t}\n\tvector<Node> matched = check_rules(node_list);\n\tfor (int i = 0; i < matched.size(); ++ i) {\n\t\tmatched[i].index = matched[i].children[0].index;\n\t\tmatched[i].span = 0;\n\t\tfor (int j = 0; j < matched[i].children.size(); ++ j)\n\t\t\tmatched[i].span += matched[i].children[j].span;\n\t\tfor (int j = 0; j < to_check.size(); ++ j) {\n\t\t\tif (to_check[j] == matched[i]) {\n\t\t\t\tstringstream ss;\n\t\t\t\tss << \"Internal error: repeated nodes:\" << endl;\n\t\t\t\tss << to_check[j] << endl;\n\t\t\t\tss << matched[i] << endl;\n\t\t\t\tthrow runtime_error(ss.str());\n\t\t\t}\n\t\t}\n\t\tto_check.push_back(matched[i]);\n\t}\n\t// for (int i = 0; i < matched.size(); ++ i) {\n\t// \tcout << matched[i] << endl;\n\t// }\n\tif (next_index == nodes.size()) return;\n\tfor (int i = 0; i < nodes[next_index].size(); ++ i) {\n\t\tNode node = nodes[next_index][i];\n\t\tnode_list.push_back(node);\n\t\tcheck_sequences(nodes, node_list, next_index, to_check);\n\t\tnode_list.pop_back();\n\t}\n}\n\nbool startswith(const string & text, const string & prefix) {\n\tint size = prefix.size();\n\tif (text.size() < size) return false;\n\tstring prefix2 = text.substr(0, size);\n\treturn prefix2 == prefix;\n}\n\nbool endswith(const string & text, const string & postfix) {\n\tint size = postfix.size();\n\tif (text.size() < size) return false;\n\tstring postfix2 = text.substr(text.size() - size, size);\n\treturn postfix2 == postfix;\n}\n\nNode parse_line(int lineno, vector<Token> & tokens) {\n\tvector<vector<Node> > nodes;\n\tvector<Node> to_check;\n\tint span = tokens.size();\n\tfor (int i = 0; i < tokens.size(); ++ i) {\n\t\tif (tokens[i].type == \"indent\") {\n\t\t\t-- span;\n\t\t\tcontinue;\n\t\t}\n\t\tNode node;\n\t\tnode.type = tokens[i].type;\n\t\tnode.index = nodes.size();\n\t\tnode.span = 1;\n\t\tnode.token = tokens[i];\n\t\tnodes.push_back(vector<Node>());\n\t\tto_check.push_back(node);\n\t}\n\twhile (to_check.size() > 0) {\n\t\tNode first = to_check[to_check.size() - 1];\n\t\t// cout << \"--->\" << '\\t' << first << endl;\n\t\tto_check.pop_back();\n\t\tvector<Node> node_list;\n\t\tnode_list.push_back(first);\n\t\tnodes[first.index].push_back(first);\n\t\tcheck_sequences(nodes, node_list, first.index, to_check);\n\t}\n\tint result = -1;\n\tfor (int i = 0; i < nodes[0].size(); ++ i) {\n\t\tif (nodes[0][i].span == span) \n\t\t\tresult = i;\n\t}\n\tif (result == -1) {\n\t\tstringstream ss;\n\t\tss << \"Syntax error in line: \" << (lineno + 1);\n\t\tthrow runtime_error(ss.str());\n\t}\n\treturn nodes[0][result];\n}\n\nstruct Line\n{\n\tint level;\n\tNode node;\n\tvector<Line> children;\n};\n\nvoid print_line(ostream & out, const Line & line, int indent=0) {\n\t// for (int i = 0; i < indent; ++ i) out << '\\t';\n\tif (line.children.size() == 0) {\n\t\t// out << line.node.type << '\\t' << line.node.token.text << endl;\n\t\tout << \"( \" << line.node.type << \"@\" << line.level << \" _ )\";\n\t}\n\telse {\n\t\tout << \"( \" << line.node.type << \"@\" << line.level << \" \";\n\t\tfor (int i = 0; i < line.children.size(); ++ i) {\n\t\t\tprint_line(out, line.children[i], indent + 1);\n\t\t}\n\t\tout << \" )\";\n\t}\n}\n\nostream & operator << (ostream & out, const Line & line) {\n\tprint_line(out, line, 0);\n\treturn out;\n}\n\nvoid indent_error(const Token & indent) {\n\tstringstream ss;\n\tss << \"Inconsistent indentation at line: \" << indent.line;\n\tthrow runtime_error(ss.str());\n}\n\nvoid get_tree(vector<string> & lines, Line & tree) {\n\tvector<vector<Token> > tokens;\n\tvector<Node> nodes;\n\tvector<Token> indents;\n\tget_tokens(lines, tokens);\n\tfor (int i = 0; i < tokens.size(); ++ i) {\n\t\tif (tokens[i].size() > 0) {\n\t\t\tif (tokens[i][0].type == \"indent\")\n\t\t\t\tindents.push_back(tokens[i][0]);\n\t\t\telse\n\t\t\t\tindents.push_back(Token());\n\t\t\tnodes.push_back(parse_line(i, tokens[i]));\n\t\t}\n\t}\n\ttree.level = 0;\n\ttree.node.type = \"__main__\";\n\ttree.node.token.text = \"__main__\";\n\ttree.node.index = 0;\n\ttree.node.span = 0;\n\tvector<Line *> stack;\n\tvector<string> indent_stack;\n\tstack.push_back(&tree);\n\tindent_stack.push_back(\"\");\n\tfor (int i = 0; i < nodes.size(); ++ i) {\n\t\tstring last_indent = indent_stack[indent_stack.size() - 1];\n\t\tLine next;\n\t\tnext.node = nodes[i];\n\t\tLine * parent = stack[stack.size() - 1];\n\t\tif (indents[i].text == last_indent) {\n\t\t\tnext.level = parent->level + 1;\n\t\t\tparent->children.push_back(next);\n\t\t}\n\t\telse {\n\t\t\tif (startswith(indents[i].text, last_indent)) {\n\t\t\t\tindent_stack.push_back(indents[i].text);\n\t\t\t\tif (parent->children.size() == 0) indent_error(indents[i]);\n\t\t\t\tparent = &parent->children[parent->children.size() - 1];\n\t\t\t\tstack.push_back(parent);\n\t\t\t\tnext.level = parent->level + 1;\n\t\t\t\tparent->children.push_back(next);\n\t\t\t}\n\t\t\telse {\n\t\t\t\twhile (true) {\n\t\t\t\t\tif (indents[i].text == last_indent) {\n\t\t\t\t\t\tnext.level = parent->level + 1;\n\t\t\t\t\t\tparent->children.push_back(next);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (startswith(last_indent, indents[i].text)) {\n\t\t\t\t\t\tindent_stack.pop_back();\n\t\t\t\t\t\tlast_indent = indent_stack[indent_stack.size() - 1];\n\t\t\t\t\t\tstack.pop_back();\n\t\t\t\t\t\tif (stack.size() == 0) indent_error(indents[i]);\n\t\t\t\t\t\tparent = stack[stack.size() - 1];\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tindent_error(indents[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid print_nodes(ostream & out, const Line & line) {\n\tout << line.node << endl;\n\tif (line.children.size() == 0) return;\n\tfor (int i = 0; i < line.children.size(); ++ i) {\n\t\tprint_nodes(out, line.children[i]);\n\t}\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid optim_exp(Node & node) {\n\tif (node.children.size() == 1) {\n\t\tNode child = node.children[0];\n\t\tnode = child;\n\t}\n\telse if (node.children.size() == 3 && node.children[0].type == \"(\" && node.children[2].type == \")\") {\n\t\tNode child = node.children[1];\n\t\tnode = child;\n\t}\n\tif (startswith(node.type, \"expression\"))\n\t\tnode.type = \"expression\";\n}\n\nvoid optim(Node & node) {\n\tfor (int i = 0; i < node.children.size(); ++ i)\n\t\toptim(node.children[i]);\n\tif (startswith(node.type, \"expression\"))\n\t\toptim_exp(node);\n\tif (startswith(node.type, \"operator_\"))\n\t\tnode = node.children[0];\n}\n\nvoid optim(Line & line) {\n\toptim(line.node);\n\tfor (int i = 0; i < line.children.size(); ++ i) {\n\t\toptim(line.children[i]);\n\t}\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#define foreach(type, item, vec) for (vector<type>::iterator item=vec.begin(); item != vec.end(); ++ item)\n\nvoid assert_true(bool test, const string & err_msg) {\n\tif (! test) throw runtime_error(err_msg);\n}\n\n//////////\n// TYPES\n\nstruct Variable\n{\n\tstring type;\n\tvirtual void print() {\n\t\tcout << type;\n\t}\n\tvirtual Variable * copy() {\n\t\tstringstream ss;\n\t\tss << \"'\" << type << \".copy' is not implemented\";\n\t\tassert_true(false, ss.str());\n\t\treturn 0;\n\t}\n\tvirtual Variable * __eq__(Variable * op) {\n\t\tstringstream ss;\n\t\tss << \"'\" << type << \".__eq__' is not implemented\";\n\t\tassert_true(false, ss.str());\n\t\treturn 0;\n\t}\n};\n\nstruct Int : public Variable\n{\n\tint intValue;\n\tInt(int value) {\n\t\ttype = \"int\";\n\t\tintValue = value;\n\t}\n\tvoid print() {\n\t\tcout << intValue;\n\t}\n\tvirtual Variable * copy() {\n\t\treturn new Int(intValue);\n\t}\n\tVariable * __add__(Int * op) {\n\t\tInt * ret = (Int *)copy();\n\t\tret->intValue += op->intValue;\n\t\treturn ret;\n\t}\n\tVariable * __sub__(Int * op) {\n\t\tInt * ret = (Int *)copy();\n\t\tret->intValue -= op->intValue;\n\t\treturn ret;\n\t}\n\tVariable * __mul__(Int * op) {\n\t\tInt * ret = (Int *)copy();\n\t\tret->intValue *= op->intValue;\n\t\treturn ret;\n\t}\n\tVariable * __mod__(Int * op) {\n\t\tInt * ret = (Int *)copy();\n\t\tret->intValue = ret->intValue % op->intValue;\n\t\treturn ret;\n\t}\n\tVariable * __eq__(Variable * op) {\n\t\tInt * op2 = (Int *)op;\n\t\treturn new Int(intValue == op2->intValue);\n\t}\n};\n\nstruct Bool : public Variable\n{\n\tbool boolValue;\n\tBool(bool value) {\n\t\ttype = \"bool\";\n\t\tboolValue = value;\n\t}\n\tvoid print() {\n\t\tif (boolValue) cout << \"True\";\n\t\telse cout << \"False\";\n\t}\n\tvirtual Variable * copy() {\n\t\treturn new Bool(boolValue);\n\t}\n\tVariable * __and__(Bool * op) {\n\t\tBool * ret = (Bool *)copy();\n\t\tret->boolValue = ret->boolValue && op->boolValue;\n\t\treturn ret;\n\t}\n\tVariable * __or__(Bool * op) {\n\t\tBool * ret = (Bool *)copy();\n\t\tret->boolValue = ret->boolValue || op->boolValue;\n\t\treturn ret;\n\t}\n\tVariable * __eq__(Variable * op) {\n\t\tBool * op2 = (Bool *)op;\n\t\treturn new Bool(boolValue == op2->boolValue);\n\t}\n};\n\n\nstruct Str : public Variable\n{\n\tstring strValue;\n\tStr(string value) {\n\t\ttype = \"str\";\n\t\tstrValue = value;\n\t}\n\tvoid print() {\n\t\tbool was_backslash = false;\n\t\tfor (int i = 1; i < strValue.size() - 1; ++ i) {\n\t\t\tchar c = strValue[i];\n\t\t\tif (was_backslash) {\n\t\t\t\tstring err_msg = \"Unknown sequence '\\\\?'\";\n\t\t\t\tswitch (c) {\n\t\t\t\t\tcase '\\\\': cout << '\\\\'; break;\n\t\t\t\t\tcase '\\r': cout << '\\r'; break;\n\t\t\t\t\tcase '\\t': cout << '\\t'; break;\n\t\t\t\t\tcase '\\n': cout << '\\n'; break;\n\t\t\t\t\tcase '\"': cout << '\"'; break;\n\t\t\t\t\tdefault: err_msg[err_msg.size() - 2] = c; assert_true(false, err_msg);\n\t\t\t\t}\n\t\t\t\twas_backslash = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (c == '\\\\') was_backslash = true;\n\t\t\t\telse cout << c;\n\t\t\t}\n\t\t}\n\t}\n\tvirtual Variable * copy() {\n\t\treturn new Str(strValue);\n\t}\n};\n\nstruct Function : public Variable\n{\n\tLine * line;\n\tFunction(Line & value) {\n\t\ttype = \"function\";\n\t\tline = &value;\n\t}\n\tvoid print() {\n\t\tcout << type << '\\t';\n\t\tprint_node(cout, line->node);\n\t}\n};\n\nstruct Pointer : public Variable\n{\n\tvoid * pointer;\n\tPointer(void * value) {\n\t\ttype = \"pointer\";\n\t\tpointer = value;\n\t}\n};\n\nstruct Variables\n{\n\tHashTable<string, Variable*> map;\n\n\tvoid print() {\n\t\tvector<string> names = map.getKeys();\n\t\tforeach (string, name, names) {\n\t\t\tcout << *name << '\\t';\n\t\t\tmap.get(*name)->print();\n\t\t\tcout << endl;\n\t\t}\n\t}\n\n\tbool hasVariable(const string & name) {\n\t\treturn map.containsKey(name);\n\t}\n\n\tvoid assertVariable(const string & name) {\n\t\tstringstream ss;\n\t\tss << \"Variable '\" << name << \"' is undefined\"; \n\t\tassert_true(map.containsKey(name), ss.str());\t\t\n\t}\n\n\tvoid assertType(const string & name, const string & type) {\n\t\tstringstream ss;\n\t\tss << \"Require '\" << type << \"', got '\" << map.get(name)->type << \"' \"; \n\t\tassert_true(map.get(name)->type == type, ss.str());\t\t\n\t}\n\n\tstring getType(const string & name) {\n\t\tassertVariable(name);\n\t\treturn map.get(name)->type;\n\t}\n\n\tvoid delVariable(const string & name, bool del=true) {\n\t\tassertVariable(name);\n\t\tif (del) delete map.get(name);\n\t\tmap.remove(name);\n\t}\n\n\tvoid setVariable(const string & name, Variable * v) {\n\t\tif (map.containsKey(name))\n\t\t\tdelete map.get(name);\n\t\tmap.put(name, v);\n\t}\n\n\tVariable * getVariable(const string & name) {\n\t\tassertVariable(name);\n\t\treturn map.get(name);\n\t}\n\n\tvoid releaseAll() {\n\t\tvector<string> names = map.getKeys();\n\t\tforeach (string, name, names)\n\t\t\tdelVariable(*name);\n\t}\n\n};\n\nstruct Context\n{\n\tstring owner;\n\tVariables & global_variables;\n\tVariables & local_variables;\n\tHashTable<string, int> global_used;\n\tvector<int> lines_running;\n\n\tContext(const string & owner_, Variables & global_variables_, Variables & local_variables_) : \n\t\towner(owner_), global_variables(global_variables_), local_variables(local_variables_) {}\n\n\tbool is_global(const string & name, bool is_assign) {\n\t\tif (local_variables.hasVariable(name)) return false;\n\t\tif (global_used.containsKey(name)) return true;\n\t\tif (is_assign) return false;\n\t\tglobal_variables.assertVariable(name);\n\t\tglobal_used.put(name, 0);\n\t\treturn true;\n\t}\n\n\tVariable * getVariable(const string & name) {\n\t\tif (is_global(name, false))\n\t\t\treturn global_variables.getVariable(name);\n\t\telse\n\t\t\treturn local_variables.getVariable(name);\n\t}\n\n\tvoid setVariable(const string & name, Variable * v) {\n\t\tif (is_global(name, true))\n\t\t\treturn global_variables.setVariable(name, v);\n\t\telse\n\t\t\treturn local_variables.setVariable(name, v);\n\t}\n\n};\n\n////////////////////\n// FUNCTIONS\n\nvoid run_builtin_range(Context & context) {\n\tVariable * v = context.local_variables.getVariable(\"n\");\n\tassert_true(v->type == \"int\", \"'range' requires a single 'int' argument\");\n\tint n = ((Int *)v)->intValue;\n\tint level = 2;\n\tif (context.lines_running.size() == level)\n\t\tcontext.lines_running.push_back(0);\n\telse\n\t\t++ context.lines_running[level];\n\tif (context.lines_running[level] >= n) return;\n\tcontext.local_variables.setVariable(\"$ret\", new Int(context.lines_running[level]));\n}\n\nint max_print_calls = 1000;\n\nvoid run_builtin_print(Context & context) {\n\tassert_true(-- max_print_calls > 0, \"Exceeds max_print_calls == 100\");\n\tVariable * v = context.local_variables.getVariable(\"n\");\n\tif (v == 0) cout << \"None\";\n\telse v->print();\n\tcout << endl;\n}\n\nvoid run_builtin(const string & function_name, Context & context) {\n\tif (function_name == \"range\") {\n\t\trun_builtin_range(context);\n\t}\n\telse if (function_name == \"print\") {\n\t\trun_builtin_print(context);\n\t}\n\telse {\n\t\tstringstream ss;\n\t\tss << \"Unknow builtin: \" << function_name << endl;\n\t\tassert_true(false, ss.str());\n\t}\n}\n\nvoid register_builtins(vector<string> & lines, Line & tree, Variables & global_variables) {\n\tget_tree(lines, tree);\n\toptim(tree);\n\tforeach (Line, line, tree.children) {\n\t\tstringstream ss;\n\t\tss << \"Invalid line in 'builtins.py: \" << line->node.type << endl;\n\t\tassert_true(line->node.type == \"function_def\", ss.str());\n\t\tline->node.type = \"builtin\";\n\t\tstring function_name = line->node.children[1].token.text;\n\t\tglobal_variables.setVariable(function_name, new Function(*line));\n\t}\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid run_lines(vector<Line> & lines, Context & context);\nvoid run_line(Line & line, Context & context);\nVariable * run_exp(Node & exp, Context & context);\n\nLine & get_function(const string & function_name, Context & context) {\n\tVariable * v = context.getVariable(function_name);\n\tstringstream ss;\n\tss << \"Not a function: \" << function_name;\n\tassert_true(v->type == \"function\" || v->type == \"builtin\", ss.str());\n\tFunction * func_var = (Function *)v;\n\treturn *(func_var->line);\n}\n\nvoid init_function_parameters(Node & func_node, Context & callee_context, Node & call_node, Context & caller_context) {\n\tint num_args = call_node.children.size() - 3;\n\tint num_params = func_node.children.size() - 5;\n\tstringstream ss;\n\tss << \"Function '\" << call_node.children[0].token.text << \"' arguments not agree\" << endl;\n\tss << \"\\tCaller gives \" << num_args << \" at line: \" << (func_node.children[0].token.line + 1) << endl;\n\tss << \"\\tCallee requires \" << num_params << \" at line: \" << (call_node.children[0].token.line + 1) << endl;\n\tassert_true(num_args == num_params, ss.str());\n\tfor (int i = 0; i < num_params; ++ i) {\n\t\tNode & arg_exp = call_node.children[2 + i];\n\t\tVariable * arg_value = run_exp(arg_exp, caller_context);\n\t\tstring parameter_name = func_node.children[3 + i].token.text;\n\t\tcallee_context.local_variables.setVariable(parameter_name, arg_value);\n\t}\t\n}\n\nVariable * run_function(Node & call_node, Context & context) {\n\tstring function_name = call_node.children[0].token.text;\n\tLine & func_line = get_function(function_name, context);\n\tVariables func_local_variables;\n\tContext func_context(function_name, context.global_variables, func_local_variables);\n\tinit_function_parameters(func_line.node, func_context, call_node, context);\n\t// func_local_variables.print();\n\tif (func_line.node.type == \"builtin\" && func_line.children.size() == 1 && func_line.children[0].node.type == \"pass_statement\")\n\t\trun_builtin(function_name, func_context);\n\telse {\n\t\twhile (func_context.lines_running.size() <= func_line.level)\n\t\t\tfunc_context.lines_running.push_back(-100);\n\t\trun_lines(func_line.children, func_context);\n\t}\n\tVariable * ret = 0;\n\tif (func_local_variables.hasVariable(\"$ret\")) {\n\t\tret = func_local_variables.getVariable(\"$ret\");\n\t\tfunc_local_variables.delVariable(\"$ret\", false);\n\t}\n\tfunc_local_variables.releaseAll();\n\treturn ret;\n}\n\nvoid pass_result(Context & from, Context & to, const string & name) {\n\tVariable * ret = from.local_variables.getVariable(\"$ret\");\n\tfrom.local_variables.delVariable(\"$ret\", false);\n\tto.local_variables.setVariable(name, ret);\n}\n\nContext * init_generator_context(Context & context, Line & gen_def_line, Node & gen_call_node) {\n\tVariables * local_variables = new Variables();\n\tstring gen_func_name = gen_call_node.children[0].token.text;\n\tContext * gen_context = new Context(gen_func_name, context.global_variables, *local_variables);\n\tinit_function_parameters(gen_def_line.node, *gen_context, gen_call_node, context);\n\tcontext.local_variables.setVariable(\"$gen\", new Pointer(gen_context));\n\twhile (gen_context->lines_running.size() <= gen_def_line.level)\n\t\tgen_context->lines_running.push_back(-100);\n\treturn gen_context;\n}\n\nvoid release_generator_context(Context & context) {\n\tPointer * v = (Pointer *)context.local_variables.getVariable(\"$gen\");\n\tContext * gen = (Context *)v->pointer;\n\tcontext.local_variables.delVariable(\"$gen\");\n\tgen->local_variables.releaseAll();\n\tdelete &(gen->local_variables);\n\tdelete gen;\n}\n\nvoid print_int_vector(vector<int> & vec) {\n\tfor (int i = 0; i < vec.size(); ++ i) cout << \" \" << vec[i];\n\tcout << endl;\n}\n\nvoid run_for_statement(Line & for_line, Context & context) {\n\tstring loop_variable_name = for_line.node.children[1].token.text;\n\tNode & gen_node = for_line.node.children[3];\n\tif (gen_node.type == \"function_call\") {\n\t\tstring gen_func_name = gen_node.children[0].token.text;\n\t\tLine & gen_def_line = get_function(gen_func_name, context);\n\t\tContext * gen_context = 0;\n\t\tif (context.local_variables.hasVariable(\"$gen\")) {\n\t\t\tPointer * gen = (Pointer *)context.local_variables.getVariable(\"$gen\");\n\t\t\tgen_context = (Context *)(gen->pointer);\n\t\t\tstringstream ss;\n\t\t\tss << \"Inconsistent generator context: required '\" << gen_func_name << \"', got '\" << gen_context->owner << \"'\";\n\t\t\tassert_true(gen_context->owner == gen_func_name, ss.str());\n\t\t}\n\t\telse \n\t\t\tgen_context = init_generator_context(context, gen_def_line, gen_node);\n\t\tbool done = false;\n\t\twhile (true) {\n\t\t\tif (gen_def_line.node.type == \"builtin\" && gen_def_line.children.size() == 1 && gen_def_line.children[0].node.type == \"pass_statement\")\n\t\t\t\trun_builtin(gen_func_name, *gen_context);\n\t\t\telse\n\t\t\t\trun_lines(gen_def_line.children, *gen_context);\n\t\t\tif (! gen_context->local_variables.hasVariable(\"$ret\")) {\n\t\t\t\tdone = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpass_result(*gen_context, context, loop_variable_name);\n\t\t\trun_lines(for_line.children, context);\n\t\t\tif (context.local_variables.hasVariable(\"$ret\")) break;\n\t\t}\n\t\tif (done) release_generator_context(context);\n\t}\n\telse {\n\t\tstringstream ss;\n\t\tss << \"Unknow generator type: \" << gen_node.type;\n\t\tassert_true(false, ss.str());\n\t}\n}\n\nVariable * run_id(Node & exp, Context & context) {\n\tstring name = exp.token.text;\n\tif (context.local_variables.hasVariable(name))\n\t\treturn context.local_variables.getVariable(name)->copy();\n\tif (context.global_variables.hasVariable(name))\n\t\treturn context.global_variables.getVariable(name)->copy();\n\tstringstream ss;\n\tss << \"Undefined variable: \" << name << endl;\n\tassert_true(false, ss.str());\n\treturn 0;\n}\n\nvoid check_op_type(const string & op, const string & required_type, const string & type) {\n\tstringstream ss;\n\tss << \"The operand of \" << op << \" must be '\" << required_type <<\"' instead of '\" << type << \"'\" << endl;\n\tassert_true(required_type == type, ss.str());\n}\n\nVariable * run_expression(Node & exp, Context & context) {\n\tstring op = \"?\";\n\tif (exp.children.size() == 3) {\n\t\top = exp.children[1].token.text;\n\t\tVariable * left = run_exp(exp.children[0], context);\n\t\tVariable * right = run_exp(exp.children[2], context);\n\t\tif (op == \"+\") {\n\t\t\tcheck_op_type(op, \"int\", left->type);\n\t\t\tcheck_op_type(op, \"int\", right->type);\n\t\t\treturn ((Int *)left)->__add__((Int *)right);\n\t\t}\n\t\telse if (op == \"-\") {\n\t\t\tcheck_op_type(op, \"int\", left->type);\n\t\t\tcheck_op_type(op, \"int\", right->type);\n\t\t\treturn ((Int *)left)->__sub__((Int *)right);\n\t\t}\n\t\telse if (op == \"*\") {\n\t\t\tcheck_op_type(op, \"int\", left->type);\n\t\t\tcheck_op_type(op, \"int\", right->type);\n\t\t\treturn ((Int *)left)->__mul__((Int *)right);\n\t\t}\n\t\telse if (op == \"%\") {\n\t\t\tcheck_op_type(op, \"int\", left->type);\n\t\t\tcheck_op_type(op, \"int\", right->type);\n\t\t\treturn ((Int *)left)->__mod__((Int *)right);\n\t\t}\n\t\telse if (op == \"and\") {\n\t\t\tcheck_op_type(op, \"bool\", left->type);\n\t\t\tcheck_op_type(op, \"bool\", right->type);\n\t\t\treturn ((Bool *)left)->__and__((Bool *)right);\n\t\t}\n\t\telse if (op == \"or\") {\n\t\t\tcheck_op_type(op, \"bool\", left->type);\n\t\t\tcheck_op_type(op, \"bool\", right->type);\n\t\t\treturn ((Bool *)left)->__or__((Bool *)right);\n\t\t}\n\t\telse if (op == \"==\") {\n\t\t\tcheck_op_type(op, left->type, right->type);\n\t\t\treturn left->__eq__(right);\n\t\t}\n\t}\n\telse if (exp.children.size() == 2) {\n\t\top = exp.children[0].token.text;\n\t}\n\tstringstream ss;\n\tss << \"Undefined operator: \" << op << endl;\n\tassert_true(false, ss.str());\n\treturn 0;\n}\n\nVariable * run_exp(Node & exp, Context & context) {\n\tif (exp.type == \"int\") {\n\t\tstringstream ss(exp.token.text);\n\t\tint intValue;\n\t\tss >> intValue;\n\t\treturn new Int(intValue);\n\t}\n\telse if (exp.type == \"str\") {\n\t\treturn new Str(exp.token.text);\n\t}\n\telse if (exp.type == \"True\") {\n\t\treturn new Bool(true);\n\t}\n\telse if (exp.type == \"False\") {\n\t\treturn new Bool(false);\n\t}\n\telse if (exp.type == \"id\") {\n\t\treturn run_id(exp, context);\n\t}\n\telse if (exp.type == \"None\") {\n\t\treturn 0;\n\t}\n\telse if (exp.type == \"function_call\") {\n\t\treturn run_function(exp, context);\n\t}\n\telse if (exp.type == \"expression\") {\n\t\treturn run_expression(exp, context);\n\t}\n\telse {\n\t\tstringstream ss;\n\t\tss << \"Unknow expression type: \" << exp.type << endl << exp << endl;\n\t\tassert_true(false, ss.str());\n\t}\n\treturn 0;\n}\n\nvoid run_yield_statement(Line & line, Context & context) {\n\tVariable * v = run_exp(line.node.children[1], context);\n\tassert_true(v != 0, \"\");\n\tcontext.local_variables.setVariable(\"$ret\", v);\n\t++ context.lines_running[line.level];\n}\n\nvoid run_return_statement(Line & line, Context & context) {\n\tVariable * v = run_exp(line.node.children[1], context);\n\tcontext.local_variables.setVariable(\"$ret\", v);\n\tcontext.lines_running.clear();\n}\n\nvoid run_assign_statement(Line & line, Context & context) {\n\tstring variable_name = line.node.children[0].token.text;\n\tVariable * v = run_exp(line.node.children[2], context);\n\tcontext.setVariable(variable_name, v);\n}\n\nbool is_true(Variable * v) {\n\tif (v == 0) {\n\t\treturn false;\n\t}\n\tif (v->type == \"bool\") {\n\t\treturn ((Bool *)v)->boolValue;\n\t}\n\telse if (v->type == \"int\") {\n\t\treturn ((Int *)v)->intValue != 0;\n\t}\n\tstringstream ss;\n\tss << \"Unknown type for condition: \" << v->type;\n\tassert_true(false, ss.str());\n\treturn false;\n}\n\nvoid run_if_statement(Line & line, Context & context) {\n\tif (context.lines_running.size() > line.level + 1) {\n\t\trun_lines(line.children, context);\n\t\treturn;\n\t}\n\tVariable * v = run_exp(line.node.children[1], context);\n\tstringstream ss;\n\tss << \"$if\" << line.level;\n\tcontext.setVariable(ss.str(), v);\n\tif (is_true(v)) {\n\t\trun_lines(line.children, context);\n\t}\n}\n\nvoid run_else_statement(Line & line, Context & context) {\n\tif (context.lines_running.size() > line.level + 1) {\n\t\trun_lines(line.children, context);\n\t\treturn;\n\t}\n\tstringstream ss;\n\tss << \"$if\" << line.level;\n\tstring condition_name = ss.str();\n\tassert_true(context.local_variables.hasVariable(condition_name), \"Dangling else-statement\");\n\tVariable * v = context.local_variables.getVariable(condition_name);\n\tif (! is_true(v)) {\n\t\trun_lines(line.children, context);\n\t}\n\tcontext.local_variables.delVariable(condition_name);\n}\n\nvoid run_line(Line & line, Context & context) {\n\tif (line.node.type == \"comment\") {\n\t}\n\telse if (line.node.type == \"function_def\") {\n\t\tstring function_name = line.node.children[1].token.text;\n\t\tcontext.local_variables.setVariable(function_name, new Function(line));\n\t}\n\telse if (line.node.type == \"function_call\") {\n\t\trun_function(line.node, context);\n\t}\n\telse if (line.node.type == \"for_statement\") {\n\t\trun_for_statement(line, context);\n\t}\n\telse if (line.node.type == \"yield_statement\") {\n\t\trun_yield_statement(line, context);\n\t}\n\telse if (line.node.type == \"return_statement\") {\n\t\trun_return_statement(line, context);\n\t}\n\telse if (line.node.type == \"assign_statement\") {\n\t\trun_assign_statement(line, context);\n\t}\n\telse if (line.node.type == \"if_statement\") {\n\t\trun_if_statement(line, context);\n\t}\n\telse if (line.node.type == \"else_statement\") {\n\t\trun_else_statement(line, context);\n\t}\n\telse {\n\t\tstringstream ss;\n\t\tss << \"Unknow line type: \" << line.node.type;\n\t\tassert_true(false, ss.str());\n\t}\n}\n\nint get_def_line(Line & line) {\n\tNode * node = &(line.node);\n\twhile (node->children.size() > 0)\n\t\tnode = &(node->children[0]);\n\treturn node->token.line;\n}\n\nvoid run_lines(vector<Line> & lines, Context & context) {\n\tint level = lines[0].level;\n\tstringstream ss;\n\tss << \"Line: \" << get_def_line(lines[0]) <<\" Incorrect level state: \" << context.lines_running.size() << \", requires >= \" << level;\n\tassert_true(context.lines_running.size() >= level, ss.str());\n\tif (context.lines_running.size() == level) {\n\t\tcontext.lines_running.push_back(0);\n\t}\n\tstringstream ss2;\n\tss2 << \"Line: \" << get_def_line(lines[0]) <<\" Incorrect level step: \" << context.lines_running[level];\n\tassert_true(context.lines_running[level] >= 0, ss2.str());\n\twhile (context.lines_running[level] < lines.size()) {\n\t\trun_line(lines[context.lines_running[level]], context);\n\t\tif (context.local_variables.hasVariable(\"$ret\")) break;\n\t\t++ context.lines_running[level];\n\t}\n\tif (context.lines_running[level] == lines.size())\n\t\tcontext.lines_running.pop_back();\n}\n\nvoid run(vector<string> & lib_lines, vector<string> & lines) {\n\tVariables global_variables;\n\tLine builtins_tree;\n\tregister_builtins(lib_lines, builtins_tree, global_variables);\n\n\tLine tree;\n\tget_tree(lines, tree);\n\toptim(tree);\n\tContext global_context(\"__main__\", global_variables, global_variables);\n\twhile (global_context.lines_running.size() <= tree.level)\n\t\tglobal_context.lines_running.push_back(-100);\n\trun_lines(tree.children, global_context);\n\tglobal_variables.releaseAll();\n}\n\nstring builtins = \"def print(n):\\n\\n\tpass\\n\\n\\n\\ndef range(n):\\n\\n\tpass\";\n\nint main() {\n\ttry {\n\t\tvector<string> lib_lines;\n\t\tvector<string> lines;\n\t\tstringstream ss(builtins);\n\t\tread_lines(ss, lib_lines);\n\t\tread_lines(cin, lines);\n\t\trun(lib_lines, lines);\n\t}\n\tcatch (runtime_error & ex) {\n\t\tcout << ex.what() << endl;\n\t}\n}",
            "print('''def test_loop(n):\n\tfor i in range(n):\n\t\tprint(131 + i)\n\ndef test_condition(c):\n\tif c:\n\t\tprint(\"right\")\n\telse:\n\t\tprint(\"no\")\n\ntest_loop(10)\ntest_condition(True)''')",
            1585713600,
            1585713600
        ],
        [
            "16.3 (C++)",
            "Please modify the simple Python compiler as follows:\n<ul>\n<li>Combine all CPP file into a single file</li>\n<li>Input from STDIO instead of from a Python file</li>\n<li>Load library from an internal string instead of from \"lib/builtins.py\"</li>\n</ul>\n\n<b>EXAMPLE INPUT</b>\n<pre>\ndef test_loop(n):\n\tfor i in range(n):\n\t\tprint(10 - i)\n\ndef test_condition(c):\n\tif c:\n\t\tprint(\"yes\")\n\telse:\n\t\tprint(\"no\")\n\ntest_loop(10)\ntest_condition(True)\n</pre>\n\n<b>EXAMPLE OUTPUT</b>\n<pre>\n10\n9\n8\n7\n6\n5\n4\n3\n2\n1\nyes\n</pre>",
            "#include \"source.cpp\"",
            "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <stdexcept>\nusing namespace std;\n\n#include <cstring>\n\nint operator % (const string & text, int max) {\n\tint code = 0;\n\tfor (int i = 0; i < text.size(); ++ i) {\n\t\tint code1 = text[i];\n\t\tcode1 = code1 << (i * 8 % 24);\n\t\tcode = code ^ code1;\n\t}\n\treturn code % max;\n}\n\nclass NoSuchKeyException {};\n\ntemplate <typename K, typename V>\nclass HashTable\n{\nprivate:\n\t\t\n\tclass Entry\n\t{\n\tpublic:\n\t\tK key;\n\t\tV value;\n\t\tbool isInUse;\n\t\t\n\t\tEntry() {\n\t\t\tisInUse = false;\n\t\t}\n\t};\n\t\n\tEntry * entries;\n\t\n\tint capacity;\n\tint count;\n\t\n\tvoid initialize(int capacity2) {\n\t\tcount = 0;\n\t\tcapacity = capacity2;\n\t\tentries = new Entry[capacity];\n\t}\n\t\n\tvoid assign(const HashTable & map2) {\n\t\tcount = map2.count;\n\t\tcapacity = map2.capacity;\n\t\tentries = new Entry[capacity];\n\t\tfor (int i = 0; i < capacity; ++ i) {\n\t\t\tentries[i] = map2.entries[i];\n\t\t}\n\t}\n\t\npublic:\n\t\n\tHashTable() {\n\t\tinitialize(2);\n\t}\n\t\n\t~HashTable() {\n\t\tdelete [] entries;\n\t}\n\t\n\tHashTable(const HashTable & map2) {\n\t\tassign(map2);\n\t}\n\t\n\tHashTable & operator = (const HashTable & map2) {\n\t\tdelete [] entries;\n\t\tassign(map2);\n\t\treturn (*this);\n\t}\n\t\n\tvoid clear() {\n\t\tdelete [] entries;\n\t\tinitialize(2);\n\t}\n\t\nprivate:\n\t\n\tint hashIndex(const K & key) const {\n\t\treturn key % capacity;\n\t}\n\t\n\tint find(const K & key) const {\n\t\tint index = hashIndex(key);\n\t\twhile (true) {\n\t\t\tif (! entries[index].isInUse) {\n\t\t\t\treturn index;\n\t\t\t}\n\t\t\tif (entries[index].key == key) {\n\t\t\t\treturn index;\n\t\t\t}\n\t\t\tindex = (index + 1) % capacity;\n\t\t}\n\t}\n\t\n\tvoid resize(int capacity2) {\n\t\tEntry * entries0 = entries;\n\t\tint capacity0 = capacity;\n\t\tinitialize(capacity2);\n\t\tfor (int i = 0; i < capacity0; ++ i) {\n\t\t\tif (entries0[i].isInUse) {\n\t\t\t\tput(entries0[i].key, entries0[i].value);\n\t\t\t}\n\t\t}\n\t\tdelete [] entries0;\n\t}\n\t\npublic:\n\t\n\tvoid put(const K & key, const V & value) {\n\t\tint index = find(key);\n\t\tentries[index].value = value;\n\t\tif (entries[index].isInUse) return;\n\t\t\n\t\tentries[index].isInUse = true;\n\t\tentries[index].key = key;\n\t\t\n\t\t++ count;\n\t\tif (count > capacity / 2) {\n\t\t\tresize(capacity * 2);\n\t\t}\n\t}\n\t\n\tV get(const K & key) const {\n\t\tint index = find(key);\n\t\tif (! entries[index].isInUse) {\n\t\t\tthrow NoSuchKeyException();\n\t\t}\n\t\treturn entries[index].value;\n\t}\n\t\n\tbool remove(const K & key) {\n\t\tint index = find(key);\n\t\tif (! entries[index].isInUse) return false;\n\t\tfillNotInUseEntry(index);\n\t\t\n\t\t-- count;\n\t\tif (count < capacity / 4) {\n\t\t\tresize(capacity / 2);\n\t\t}\n\t\treturn true;\n\t}\n\t\nprivate:\n\t\n\tvoid fillNotInUseEntry(int index) {\n\t\tint next = index;\n\t\twhile (true) {\n\t\t\tnext = (next + 1) % capacity;\n\t\t\tif (! entries[next].isInUse) {\n\t\t\t\tentries[index].isInUse = false;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint index0 = hashIndex(entries[next].key);\n\t\t\tif (index < next) {\n\t\t\t\tif (index0 > index &&\n\t\t\t\t\tindex0 <= next) continue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (index0 > index ||\n\t\t\t\t\tindex0 <= next) continue;\n\t\t\t}\n\t\t\tentries[index] = entries[next];\n\t\t\tindex = next;\n\t\t}\n\t}\n\t\npublic:\n\t\n\tbool containsKey(const K & key) const {\n\t\tint index = find(key);\n\t\treturn (entries[index].isInUse);\n\t}\n\t\n\tint size() const {\n\t\treturn count;\n\t}\n\n\tvector<K> getKeys() const {\n\t\tvector<K> vec;\n\t\tfor (int i = 0; i < capacity; ++ i) {\n\t\t\tif (entries[i].isInUse) {\n\t\t\t\tvec.push_back(entries[i].key);\n\t\t\t}\n\t\t}\n\t\treturn vec;\n\t}\n\t\n};\n\n////////////////////////////////////////////////////////////////////////////////\n\nstruct Token\n{\n\tint line;\n\tint pos;\n\tstring type;\n\tstring text;\n};\n\nint operator % (const Token & t, int base) {\n\treturn (t.line * 12347 + t.pos) % base;\n}\n\nbool operator == (const Token & t1, const Token & t2) {\n\treturn t1.line == t2.line && t1.pos == t2.pos;\n}\n\nostream & operator << (ostream & out, const Token & t) {\n\tout << t.line << '\\t' << t.pos << '\\t' << t.type << \"\\t\\\"\" << t.text << \"\\\"\";\n\treturn out;\n}\n\nvoid read_lines(istream & in, vector<string> & lines) {\n\tstring line;\n\twhile (getline(in, line)) {\n\t\tlines.push_back(line);\n\t}\n}\n\nToken make_token(int line, int pos, int len, const string & source, const string & type) {\n\tToken t;\n\tt.line = line;\n\tt.pos = pos;\n\tt.type = type;\n\tt.text = source.substr(pos, len);\n\treturn t;\n}\n\n////////////////////\n// RULES BEGIN\n\nToken find_indent(int line, const string & source) {\n\tint len = 0;\n\tfor (int i = 0; i < source.size(); ++ i) {\n\t\tif (source[i] == '\\t')\n\t\t\t++ len;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn make_token(line, 0, len, source, \"indent\");\n}\n\nToken find_blank(int line, const string & source, int start) {\n\tint len = 0;\n\tfor (int i = start; i < source.size(); ++ i) {\n\t\tif (source[i] == '\\t' || source[i] == ' ')\n\t\t\t++ len;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn make_token(line, start, len, source, \"blank\");\n}\n\nToken find_string(int line, const string & source, int start) {\n\tint len = 0;\n\tbool was_backslash = false;\n\tfor (int i = start; i < source.size(); ++ i) {\n\t\tchar c = source[i];\n\t\tif (i == start) {\n\t\t\tif (c == '\"') ++ len;\n\t\t\telse break;\n\t\t}\n\t\telse {\n\t\t\tif (was_backslash) {\n\t\t\t\tif (c == '\\\\' || c == '\\r' || c == '\\n' ||\n\t\t\t\t\tc == '\\t' || c == '\"')\n\t\t\t\t\t++ len;\n\t\t\t\telse break;\n\t\t\t\twas_backslash = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (c == '\"') {\n\t\t\t\t\t++ len;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t++ len;\n\t\t\t\twas_backslash = (c == '\\\\');\n\t\t\t}\n\t\t} \n\t}\n\treturn make_token(line, start, len, source, \"str\");\t\n}\n\nToken find_int(int line, const string & source, int start) {\n\tif (start < source.size()) {\n\t\tif (source[start] == '0' && (start + 1 == source.size() || (source[start + 1] < '0' || source[start + 1] > '9')))\n\t\t\treturn make_token(line, start, 1, source, \"int\");\n\t}\n\tint len = 0;\n\tfor (int i = start; i < source.size(); ++ i) {\n\t\tif ((i != start && source[i] >= '0' && source[i] <= '9' ) ||\n\t\t\t(source[i] >= '1' && source[i] <= '9'))\n\t\t\t++ len;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn make_token(line, start, len, source, \"int\");\t\n}\n\nToken find_id(int line, const string & source, int start) {\n\tint len = 0;\n\tfor (int i = start; i < source.size(); ++ i) {\n\t\tif ((i != start && source[i] >= '0' && source[i] <= '9') ||\n\t\t\t(source[i] >= 'A' && source[i] <= 'Z') ||\n\t\t\t(source[i] >= 'a' && source[i] <= 'z') ||\n\t\t\tsource[i] == '_')\n\t\t\t++ len;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn make_token(line, start, len, source, \"id\");\n}\n\nconst char *keywords[] = {\n\t\"class\", \"def\", \"if\", \"else\", \"for\", \"in\", \"return\", \"yield\", \"and\", \"or\", \"not\", \"pass\",\n\t\"True\", \"False\", \"None\",\n\t\"(\", \")\", \"[\", \"]\", \"{\", \"}\", \":\", \",\", \".\", \n\t\"==\", \">\", \"<\", \"<=\", \">=\", \"!=\", \"=\", \n\t\"+=\", \"-=\", \"*=\", \"/=\", \"//=\", \"%=\", \"&=\", \"^=\", \"|=\", \n\t\"+\", \"-\", \"**\", \"*\", \"//\", \"/\", \"%\", \"&\", \"^\", \"|\"\n};\n\nToken find_keyword(int line, const string & source, int start) {\n\tint keyword = -1;\n\tfor (int i = 0; i < sizeof(keywords) / sizeof(const char *); ++ i) {\n\t\tif (source.compare(start, strlen(keywords[i]), keywords[i]) == 0) {\n\t\t\tkeyword = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (keyword == -1)\n\t\treturn make_token(line, start, 0, source, \"\");\n\treturn make_token(line, start, strlen(keywords[keyword]), source, keywords[keyword]);\t\n}\n\nToken find_comment(int line, const string & source, int start) {\n\tint len = 0;\n\tfor (int i = start; i < source.size(); ++ i) {\n\t\tif (i != start || source[i] == '#')\n\t\t\t++ len;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn make_token(line, start, len, source, \"comment\");\n}\n\n////////////////////\n// RULES END\n\ntypedef Token (* find_function)(int, const string &, int);\n\nvoid add_tokens(HashTable<Token, Token> & tokens, int lineno, const string & line, find_function find, bool can_conflict) {\n\tint start = 0;\n\twhile (start < line.size()) {\n\t\tToken t = find(lineno, line, start);\n\t\tif (t.text.size() > 0) {\n\t\t\tif (can_conflict) {\n\t\t\t\tif (tokens.containsKey(t)) {\n\t\t\t\t\tToken old_t = tokens.get(t);\n\t\t\t\t\tif (old_t.text.size() < t.text.size())\n\t\t\t\t\t\ttokens.put(t, t);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttokens.put(t, t);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (tokens.containsKey(t)) {\n\t\t\t\t\tToken old_t = tokens.get(t);\n\t\t\t\t\tstringstream ss;\n\t\t\t\t\tss << \"Conflicting tokens:\" << endl;\n\t\t\t\t\tss << old_t << endl;\n\t\t\t\t\tss << t << endl;\n\t\t\t\t\tthrow runtime_error(ss.str());\n\t\t\t\t}\n\t\t\t\ttokens.put(t, t);\n\t\t\t}\n\t\t\tstart += t.text.size();\n\t\t}\n\t\telse\n\t\t\t++ start;\n\t}\n}\n\nvoid get_tokens(vector<string> & lines, vector<vector<Token> > & tokens) {\n\tHashTable<Token, Token> all_tokens;\n\tfor (int i = 0; i < lines.size(); ++ i) {\n\t\tToken indent = find_indent(i, lines[i]);\n\t\tif (indent.text.size() > 0)\n\t\t\tall_tokens.put(indent, indent);\n\t\tadd_tokens(all_tokens, i, lines[i], find_string, false);\n\t\tadd_tokens(all_tokens, i, lines[i], find_int, false);\n\t\tadd_tokens(all_tokens, i, lines[i], find_comment, false);\n\t\tadd_tokens(all_tokens, i, lines[i], find_keyword, false);\n\t\tadd_tokens(all_tokens, i, lines[i], find_id, true);\n\t\tadd_tokens(all_tokens, i, lines[i], find_blank, true);\n\t\t// TODO: add more lexical matching functions\n\t}\n\tToken index;\n\tfor (int i = 0; i < lines.size(); ++ i) {\n\t\ttokens.push_back(vector<Token>());\n\t\tindex.line = i;\n\t\tindex.pos = 0;\n\t\twhile (index.pos < lines[i].size()) {\n\t\t\tif (! all_tokens.containsKey(index)) {\n\t\t\t\tstringstream ss;\n\t\t\t\tss << \"Lexical error at line #\" << (index.line + 1) << \" char #\" << index.pos;\n\t\t\t\tthrow runtime_error(ss.str());\n\t\t\t}\n\t\t\tToken t = all_tokens.get(index);\n\t\t\tif (t.type != \"blank\")\n\t\t\t\ttokens[i].push_back(t);\n\t\t\tindex.pos += t.text.size();\n\t\t}\n\t}\n} \n\n////////////////////////////////////////////////////////////////////////////////\n\nstruct Node\n{\n\tint index;\n\tint span;\n\tstring type;\n\tvector<Node> children; // for non-terminal\n\tToken token; // for terminal, as \"indent\" for non-terminal\n};\n\nbool operator == (const Node & n1, const Node & n2) {\n\treturn n1.index == n2.index && n1.span == n2.span && n1.type == n2.type;\n}\n\nstring to_tree_text(string text) {\n\tfor (int i = 0; i < text.size(); ++ i)\n\t\tif (text[i] == ' ') text[i] = '_';\n\tif (text == \"(\") text = \"-LRB-\";\n\tif (text == \")\") text = \"-RRB-\";\n\treturn text;\n}\n\nvoid print_node(ostream & out, const Node & node, int indent=0) {\n\t// for (int i = 0; i < indent; ++ i) out << '\\t';\n\tif (node.children.size() == 0) {\n\t\tout << \"( \" << to_tree_text(node.type) << ' ' << to_tree_text(node.token.text) << \" )\";\n\t}\n\telse {\n\t\t// out << node.type << \"\\tindex=\" << node.index << \"\\tspan=\" << node.span << endl;\n\t\tout << \"( \" << to_tree_text(node.type) << \" \";\n\t\tfor (int i = 0; i < node.children.size(); ++ i) {\n\t\t\tprint_node(out, node.children[i], indent + 1);\n\t\t}\n\t\tout << \" )\";\n\t}\n}\n\nostream & operator << (ostream & out, const Node & node) {\n\tprint_node(out, node, 0);\n\treturn out;\n}\n\n////////////////////\n// RULES BEGIN\n\nvoid make_node(const vector<Node> & node_list, vector<Node> & matched, const string & type, int len) {\n\tif (node_list.size() != len) return;\n\tNode node;\n\tnode.type = type;\n\tfor (int i = 0; i < len; ++ i)\n\t\tnode.children.push_back(node_list[i]);\n\tmatched.push_back(node);\n}\n\nvoid match_function_def(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() < 5) return;\n\tif (node_list[0].type != \"def\") return;\n\tif (node_list[1].type != \"id\") return;\n\tif (node_list[2].type != \"(\") return;\n\tint index = 3;\n\twhile (node_list[index].type == \"id\") {\n\t\t++ index;\n\t\tif (node_list.size() > index && node_list[index].type == \",\") {\n\t\t\t++ index;\n\t\t\tif (node_list.size() <= index || node_list[index].type != \"id\") return;\n\t\t}\n\t\telse break;\n\t}\n\tif (node_list.size() <= index || node_list[index].type != \")\") return;\n\t++ index;\n\tif (node_list.size() <= index || node_list[index].type != \":\") return;\n\t++ index;\n\tmake_node(node_list, matched, \"function_def\", index);\n}\n\nvoid match_expression(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() == 1) {\n\t\tif (node_list[0].type == \"function_call\" ||\n\t\t\tnode_list[0].type == \"str\" ||\n\t\t\tnode_list[0].type == \"id\" ||\n\t\t\tnode_list[0].type == \"int\" ||\n\t\t\tnode_list[0].type == \"None\" ||\n\t\t\tnode_list[0].type == \"True\" ||\n\t\t\tnode_list[0].type == \"False\")\n\t\t{\n\t\t\tmake_node(node_list, matched, \"expression1\", 1); // term\n\t\t}\n\t\telse if (node_list[0].type == \"expression1\") {\n\t\t\tmake_node(node_list, matched, \"expression2\", 1); // factor\n\t\t}\n\t\telse if (node_list[0].type == \"expression2\") {\n\t\t\tmake_node(node_list, matched, \"expression3\", 1); // exp\n\t\t}\n\t\telse if (node_list[0].type == \"expression3\") {\n\t\t\tmake_node(node_list, matched, \"expression4\", 1); // cmp\n\t\t}\n\t\telse if (node_list[0].type == \"expression4\") {\n\t\t\tmake_node(node_list, matched, \"expression5\", 1); // and\n\t\t}\n\t\telse if (node_list[0].type == \"expression5\") {\n\t\t\tmake_node(node_list, matched, \"expression\", 1); // or\n\t\t}\n\t}\n\tif (node_list.size() == 3) {\n\t\tif (node_list[0].type == \"(\" && node_list[1].type == \"expression\" && node_list[2].type == \")\") {\n\t\t\tmake_node(node_list, matched, \"expression1\", 3); // term\n\t\t}\n\t\telse if ((node_list[0].type == \"expression1\" || node_list[0].type == \"expression2L\") && node_list[1].type == \"operator_mul\" && node_list[2].type == \"expression1\") {\n\t\t\tmake_node(node_list, matched, \"expression2\", 3); // factor\n\t\t\tmake_node(node_list, matched, \"expression2L\", 3);\n\t\t}\n\t\telse if ((node_list[0].type == \"expression2\" || node_list[0].type == \"expression3L\") && node_list[1].type == \"operator_add\" && node_list[2].type == \"expression2\") {\n\t\t\tmake_node(node_list, matched, \"expression3\", 3); // exp\n\t\t\tmake_node(node_list, matched, \"expression3L\", 3);\n\t\t}\n\t\telse if ((node_list[0].type == \"expression3\" || node_list[0].type == \"expression4L\") && node_list[1].type == \"operator_cmp\" && node_list[2].type == \"expression3\") {\n\t\t\tmake_node(node_list, matched, \"expression4\", 3); // cmp\n\t\t\tmake_node(node_list, matched, \"expression4L\", 3);\n\t\t}\n\t\telse if ((node_list[0].type == \"expression4\" || node_list[0].type == \"expression5L\") && node_list[1].type == \"operator_and\" && node_list[2].type == \"expression4\") {\n\t\t\tmake_node(node_list, matched, \"expression5\", 3); // and\n\t\t\tmake_node(node_list, matched, \"expression5L\", 3);\n\t\t}\n\t\telse if ((node_list[0].type == \"expression5\" || node_list[0].type == \"expression6L\") && node_list[1].type == \"operator_or\" && node_list[2].type == \"expression5\") {\n\t\t\tmake_node(node_list, matched, \"expression\", 3); // and\n\t\t\tmake_node(node_list, matched, \"expression6L\", 3);\n\t\t}\n\t}\n}\n\nvoid match_function_call(const vector<Node> & node_list, vector<Node> & matched, int start=0) {\n\tif (node_list.size() < 4) return;\n\tif (node_list[0].type != \"id\") return;\n\tif (node_list[1].type != \"(\") return;\n\tint index = 2;\n\twhile (node_list[index].type == \"expression\") {\n\t\t++ index;\n\t\tif (node_list.size() > index && node_list[index].type == \",\") {\n\t\t\t++ index;\n\t\t\tif (node_list.size() <= index || node_list[index].type != \"expression\") return;\n\t\t}\n\t\telse break;\n\t}\n\tif (node_list.size() <= index || node_list[index].type != \")\") return;\n\t++ index;\n\tmake_node(node_list, matched, \"function_call\", index);\n}\n\nvoid match_for(const vector<Node> & node_list, vector<Node> & matched, int start=0) {\n\tif (node_list.size() != 5) return;\n\tif (node_list[0].type != \"for\") return;\n\tif (node_list[1].type != \"id\") return;\n\tif (node_list[2].type != \"in\") return;\n\tif (node_list[3].type != \"expression\") return;\n\tif (node_list[4].type != \":\") return;\n\tmake_node(node_list, matched, \"for_statement\", 5);\n}\n\nvoid match_if(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() != 3) return;\n\tif (node_list[0].type != \"if\") return;\n\tif (node_list[1].type != \"expression\") return;\n\tif (node_list[2].type != \":\") return;\n\tmake_node(node_list, matched, \"if_statement\", 3);\n}\n\nvoid match_else(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() != 2) return;\n\tif (node_list[0].type != \"else\") return;\n\tif (node_list[1].type != \":\") return;\n\tmake_node(node_list, matched, \"else_statement\", 2);\n}\n\nvoid match_operator(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() != 1) return;\n\tif (node_list[0].type == \"+\" || node_list[0].type == \"-\") {\n\t\tmake_node(node_list, matched, \"operator_add\", 1);\n\t}\n\telse if (node_list[0].type == \"*\" || node_list[0].type == \"/\" || node_list[0].type == \"%\") {\n\t\tmake_node(node_list, matched, \"operator_mul\", 1);\n\t}\n\telse if (node_list[0].type == \"==\" || node_list[0].type == \">\" || node_list[0].type == \"<\" \n\t\t || node_list[0].type == \">=\" || node_list[0].type == \"<=\" || node_list[0].type == \"!=\") {\n\t\tmake_node(node_list, matched, \"operator_cmp\", 1);\n\t}\n\telse if (node_list[0].type == \"and\") {\n\t\tmake_node(node_list, matched, \"operator_and\", 1);\n\t}\n\telse if (node_list[0].type == \"or\") {\n\t\tmake_node(node_list, matched, \"operator_or\", 1);\n\t}\n}\n\nvoid match_assign(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() != 3) return;\n\tif (node_list[0].type != \"id\") return;\n\tif (node_list[1].type != \"=\") return;\n\tif (node_list[2].type != \"expression\") return;\n\tmake_node(node_list, matched, \"assign_statement\", 3);\n}\n\nvoid match_yield(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() != 2) return;\n\tif (node_list[0].type != \"yield\") return;\n\tif (node_list[1].type != \"expression\") return;\n\tmake_node(node_list, matched, \"yield_statement\", 2);\n}\n\nvoid match_return(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() == 1) {\n\t\tif (node_list[0].type != \"return\") return;\n\t\tmake_node(node_list, matched, \"return_statement\", 1);\n\t}\n\telse if (node_list.size() == 2) {\n\t\tif (node_list[0].type != \"return\") return;\n\t\tif (node_list[1].type != \"expression\") return;\n\t\tmake_node(node_list, matched, \"return_statement\", 2);\n\t}\n}\n\nvoid match_pass(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() == 1) {\n\t\tif (node_list[0].type != \"pass\") return;\n\t\tmake_node(node_list, matched, \"pass_statement\", 1);\n\t}\n}\n\n////////////////////\n// RULES END\n\nvector<Node> check_rules(vector<Node> & node_list) {\n\tvector<Node> matched;\n\tmatch_function_def(node_list, matched);\n\tmatch_expression(node_list, matched);\n\tmatch_function_call(node_list, matched);\n\tmatch_for(node_list, matched);\n\tmatch_if(node_list, matched);\n\tmatch_else(node_list, matched);\n\tmatch_assign(node_list, matched);\n\tmatch_yield(node_list, matched);\n\tmatch_return(node_list, matched);\n\tmatch_operator(node_list, matched);\n\tmatch_pass(node_list, matched);\n\treturn matched;\n}\n\nvoid check_sequences(vector<vector<Node> > & nodes, vector<Node> & node_list, \n\tint index, vector<Node> & to_check) \n{\n\tNode last_node = node_list[node_list.size() - 1];\n\tint next_index = index + last_node.span;\n\t// cout << next_index << ' ' << nodes.size() << endl;\n\tif (next_index > nodes.size()) {\n\t\tthrow runtime_error(\"Internal error: incorrect next_index\");\n\t}\n\tvector<Node> matched = check_rules(node_list);\n\tfor (int i = 0; i < matched.size(); ++ i) {\n\t\tmatched[i].index = matched[i].children[0].index;\n\t\tmatched[i].span = 0;\n\t\tfor (int j = 0; j < matched[i].children.size(); ++ j)\n\t\t\tmatched[i].span += matched[i].children[j].span;\n\t\tfor (int j = 0; j < to_check.size(); ++ j) {\n\t\t\tif (to_check[j] == matched[i]) {\n\t\t\t\tstringstream ss;\n\t\t\t\tss << \"Internal error: repeated nodes:\" << endl;\n\t\t\t\tss << to_check[j] << endl;\n\t\t\t\tss << matched[i] << endl;\n\t\t\t\tthrow runtime_error(ss.str());\n\t\t\t}\n\t\t}\n\t\tto_check.push_back(matched[i]);\n\t}\n\t// for (int i = 0; i < matched.size(); ++ i) {\n\t// \tcout << matched[i] << endl;\n\t// }\n\tif (next_index == nodes.size()) return;\n\tfor (int i = 0; i < nodes[next_index].size(); ++ i) {\n\t\tNode node = nodes[next_index][i];\n\t\tnode_list.push_back(node);\n\t\tcheck_sequences(nodes, node_list, next_index, to_check);\n\t\tnode_list.pop_back();\n\t}\n}\n\nbool startswith(const string & text, const string & prefix) {\n\tint size = prefix.size();\n\tif (text.size() < size) return false;\n\tstring prefix2 = text.substr(0, size);\n\treturn prefix2 == prefix;\n}\n\nbool endswith(const string & text, const string & postfix) {\n\tint size = postfix.size();\n\tif (text.size() < size) return false;\n\tstring postfix2 = text.substr(text.size() - size, size);\n\treturn postfix2 == postfix;\n}\n\nNode parse_line(int lineno, vector<Token> & tokens) {\n\tvector<vector<Node> > nodes;\n\tvector<Node> to_check;\n\tint span = tokens.size();\n\tfor (int i = 0; i < tokens.size(); ++ i) {\n\t\tif (tokens[i].type == \"indent\") {\n\t\t\t-- span;\n\t\t\tcontinue;\n\t\t}\n\t\tNode node;\n\t\tnode.type = tokens[i].type;\n\t\tnode.index = nodes.size();\n\t\tnode.span = 1;\n\t\tnode.token = tokens[i];\n\t\tnodes.push_back(vector<Node>());\n\t\tto_check.push_back(node);\n\t}\n\twhile (to_check.size() > 0) {\n\t\tNode first = to_check[to_check.size() - 1];\n\t\t// cout << \"--->\" << '\\t' << first << endl;\n\t\tto_check.pop_back();\n\t\tvector<Node> node_list;\n\t\tnode_list.push_back(first);\n\t\tnodes[first.index].push_back(first);\n\t\tcheck_sequences(nodes, node_list, first.index, to_check);\n\t}\n\tint result = -1;\n\tfor (int i = 0; i < nodes[0].size(); ++ i) {\n\t\tif (nodes[0][i].span == span) \n\t\t\tresult = i;\n\t}\n\tif (result == -1) {\n\t\tstringstream ss;\n\t\tss << \"Syntax error in line: \" << (lineno + 1);\n\t\tthrow runtime_error(ss.str());\n\t}\n\treturn nodes[0][result];\n}\n\nstruct Line\n{\n\tint level;\n\tNode node;\n\tvector<Line> children;\n};\n\nvoid print_line(ostream & out, const Line & line, int indent=0) {\n\t// for (int i = 0; i < indent; ++ i) out << '\\t';\n\tif (line.children.size() == 0) {\n\t\t// out << line.node.type << '\\t' << line.node.token.text << endl;\n\t\tout << \"( \" << line.node.type << \"@\" << line.level << \" _ )\";\n\t}\n\telse {\n\t\tout << \"( \" << line.node.type << \"@\" << line.level << \" \";\n\t\tfor (int i = 0; i < line.children.size(); ++ i) {\n\t\t\tprint_line(out, line.children[i], indent + 1);\n\t\t}\n\t\tout << \" )\";\n\t}\n}\n\nostream & operator << (ostream & out, const Line & line) {\n\tprint_line(out, line, 0);\n\treturn out;\n}\n\nvoid indent_error(const Token & indent) {\n\tstringstream ss;\n\tss << \"Inconsistent indentation at line: \" << indent.line;\n\tthrow runtime_error(ss.str());\n}\n\nvoid get_tree(vector<string> & lines, Line & tree) {\n\tvector<vector<Token> > tokens;\n\tvector<Node> nodes;\n\tvector<Token> indents;\n\tget_tokens(lines, tokens);\n\tfor (int i = 0; i < tokens.size(); ++ i) {\n\t\tif (tokens[i].size() > 0) {\n\t\t\tif (tokens[i][0].type == \"indent\")\n\t\t\t\tindents.push_back(tokens[i][0]);\n\t\t\telse\n\t\t\t\tindents.push_back(Token());\n\t\t\tnodes.push_back(parse_line(i, tokens[i]));\n\t\t}\n\t}\n\ttree.level = 0;\n\ttree.node.type = \"__main__\";\n\ttree.node.token.text = \"__main__\";\n\ttree.node.index = 0;\n\ttree.node.span = 0;\n\tvector<Line *> stack;\n\tvector<string> indent_stack;\n\tstack.push_back(&tree);\n\tindent_stack.push_back(\"\");\n\tfor (int i = 0; i < nodes.size(); ++ i) {\n\t\tstring last_indent = indent_stack[indent_stack.size() - 1];\n\t\tLine next;\n\t\tnext.node = nodes[i];\n\t\tLine * parent = stack[stack.size() - 1];\n\t\tif (indents[i].text == last_indent) {\n\t\t\tnext.level = parent->level + 1;\n\t\t\tparent->children.push_back(next);\n\t\t}\n\t\telse {\n\t\t\tif (startswith(indents[i].text, last_indent)) {\n\t\t\t\tindent_stack.push_back(indents[i].text);\n\t\t\t\tif (parent->children.size() == 0) indent_error(indents[i]);\n\t\t\t\tparent = &parent->children[parent->children.size() - 1];\n\t\t\t\tstack.push_back(parent);\n\t\t\t\tnext.level = parent->level + 1;\n\t\t\t\tparent->children.push_back(next);\n\t\t\t}\n\t\t\telse {\n\t\t\t\twhile (true) {\n\t\t\t\t\tif (indents[i].text == last_indent) {\n\t\t\t\t\t\tnext.level = parent->level + 1;\n\t\t\t\t\t\tparent->children.push_back(next);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (startswith(last_indent, indents[i].text)) {\n\t\t\t\t\t\tindent_stack.pop_back();\n\t\t\t\t\t\tlast_indent = indent_stack[indent_stack.size() - 1];\n\t\t\t\t\t\tstack.pop_back();\n\t\t\t\t\t\tif (stack.size() == 0) indent_error(indents[i]);\n\t\t\t\t\t\tparent = stack[stack.size() - 1];\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tindent_error(indents[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid print_nodes(ostream & out, const Line & line) {\n\tout << line.node << endl;\n\tif (line.children.size() == 0) return;\n\tfor (int i = 0; i < line.children.size(); ++ i) {\n\t\tprint_nodes(out, line.children[i]);\n\t}\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid optim_exp(Node & node) {\n\tif (node.children.size() == 1) {\n\t\tNode child = node.children[0];\n\t\tnode = child;\n\t}\n\telse if (node.children.size() == 3 && node.children[0].type == \"(\" && node.children[2].type == \")\") {\n\t\tNode child = node.children[1];\n\t\tnode = child;\n\t}\n\tif (startswith(node.type, \"expression\"))\n\t\tnode.type = \"expression\";\n}\n\nvoid optim(Node & node) {\n\tfor (int i = 0; i < node.children.size(); ++ i)\n\t\toptim(node.children[i]);\n\tif (startswith(node.type, \"expression\"))\n\t\toptim_exp(node);\n\tif (startswith(node.type, \"operator_\"))\n\t\tnode = node.children[0];\n}\n\nvoid optim(Line & line) {\n\toptim(line.node);\n\tfor (int i = 0; i < line.children.size(); ++ i) {\n\t\toptim(line.children[i]);\n\t}\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#define foreach(type, item, vec) for (vector<type>::iterator item=vec.begin(); item != vec.end(); ++ item)\n\nvoid assert_true(bool test, const string & err_msg) {\n\tif (! test) throw runtime_error(err_msg);\n}\n\n//////////\n// TYPES\n\nstruct Variable\n{\n\tstring type;\n\tvirtual void print() {\n\t\tcout << type;\n\t}\n\tvirtual Variable * copy() {\n\t\tstringstream ss;\n\t\tss << \"'\" << type << \".copy' is not implemented\";\n\t\tassert_true(false, ss.str());\n\t\treturn 0;\n\t}\n\tvirtual Variable * __eq__(Variable * op) {\n\t\tstringstream ss;\n\t\tss << \"'\" << type << \".__eq__' is not implemented\";\n\t\tassert_true(false, ss.str());\n\t\treturn 0;\n\t}\n};\n\nstruct Int : public Variable\n{\n\tint intValue;\n\tInt(int value) {\n\t\ttype = \"int\";\n\t\tintValue = value;\n\t}\n\tvoid print() {\n\t\tcout << intValue;\n\t}\n\tvirtual Variable * copy() {\n\t\treturn new Int(intValue);\n\t}\n\tVariable * __add__(Int * op) {\n\t\tInt * ret = (Int *)copy();\n\t\tret->intValue += op->intValue;\n\t\treturn ret;\n\t}\n\tVariable * __sub__(Int * op) {\n\t\tInt * ret = (Int *)copy();\n\t\tret->intValue -= op->intValue;\n\t\treturn ret;\n\t}\n\tVariable * __mul__(Int * op) {\n\t\tInt * ret = (Int *)copy();\n\t\tret->intValue *= op->intValue;\n\t\treturn ret;\n\t}\n\tVariable * __mod__(Int * op) {\n\t\tInt * ret = (Int *)copy();\n\t\tret->intValue = ret->intValue % op->intValue;\n\t\treturn ret;\n\t}\n\tVariable * __eq__(Variable * op) {\n\t\tInt * op2 = (Int *)op;\n\t\treturn new Int(intValue == op2->intValue);\n\t}\n};\n\nstruct Bool : public Variable\n{\n\tbool boolValue;\n\tBool(bool value) {\n\t\ttype = \"bool\";\n\t\tboolValue = value;\n\t}\n\tvoid print() {\n\t\tif (boolValue) cout << \"True\";\n\t\telse cout << \"False\";\n\t}\n\tvirtual Variable * copy() {\n\t\treturn new Bool(boolValue);\n\t}\n\tVariable * __and__(Bool * op) {\n\t\tBool * ret = (Bool *)copy();\n\t\tret->boolValue = ret->boolValue && op->boolValue;\n\t\treturn ret;\n\t}\n\tVariable * __or__(Bool * op) {\n\t\tBool * ret = (Bool *)copy();\n\t\tret->boolValue = ret->boolValue || op->boolValue;\n\t\treturn ret;\n\t}\n\tVariable * __eq__(Variable * op) {\n\t\tBool * op2 = (Bool *)op;\n\t\treturn new Bool(boolValue == op2->boolValue);\n\t}\n};\n\n\nstruct Str : public Variable\n{\n\tstring strValue;\n\tStr(string value) {\n\t\ttype = \"str\";\n\t\tstrValue = value;\n\t}\n\tvoid print() {\n\t\tbool was_backslash = false;\n\t\tfor (int i = 1; i < strValue.size() - 1; ++ i) {\n\t\t\tchar c = strValue[i];\n\t\t\tif (was_backslash) {\n\t\t\t\tstring err_msg = \"Unknown sequence '\\\\?'\";\n\t\t\t\tswitch (c) {\n\t\t\t\t\tcase '\\\\': cout << '\\\\'; break;\n\t\t\t\t\tcase '\\r': cout << '\\r'; break;\n\t\t\t\t\tcase '\\t': cout << '\\t'; break;\n\t\t\t\t\tcase '\\n': cout << '\\n'; break;\n\t\t\t\t\tcase '\"': cout << '\"'; break;\n\t\t\t\t\tdefault: err_msg[err_msg.size() - 2] = c; assert_true(false, err_msg);\n\t\t\t\t}\n\t\t\t\twas_backslash = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (c == '\\\\') was_backslash = true;\n\t\t\t\telse cout << c;\n\t\t\t}\n\t\t}\n\t}\n\tvirtual Variable * copy() {\n\t\treturn new Str(strValue);\n\t}\n};\n\nstruct Function : public Variable\n{\n\tLine * line;\n\tFunction(Line & value) {\n\t\ttype = \"function\";\n\t\tline = &value;\n\t}\n\tvoid print() {\n\t\tcout << type << '\\t';\n\t\tprint_node(cout, line->node);\n\t}\n};\n\nstruct Pointer : public Variable\n{\n\tvoid * pointer;\n\tPointer(void * value) {\n\t\ttype = \"pointer\";\n\t\tpointer = value;\n\t}\n};\n\nstruct Variables\n{\n\tHashTable<string, Variable*> map;\n\n\tvoid print() {\n\t\tvector<string> names = map.getKeys();\n\t\tforeach (string, name, names) {\n\t\t\tcout << *name << '\\t';\n\t\t\tmap.get(*name)->print();\n\t\t\tcout << endl;\n\t\t}\n\t}\n\n\tbool hasVariable(const string & name) {\n\t\treturn map.containsKey(name);\n\t}\n\n\tvoid assertVariable(const string & name) {\n\t\tstringstream ss;\n\t\tss << \"Variable '\" << name << \"' is undefined\"; \n\t\tassert_true(map.containsKey(name), ss.str());\t\t\n\t}\n\n\tvoid assertType(const string & name, const string & type) {\n\t\tstringstream ss;\n\t\tss << \"Require '\" << type << \"', got '\" << map.get(name)->type << \"' \"; \n\t\tassert_true(map.get(name)->type == type, ss.str());\t\t\n\t}\n\n\tstring getType(const string & name) {\n\t\tassertVariable(name);\n\t\treturn map.get(name)->type;\n\t}\n\n\tvoid delVariable(const string & name, bool del=true) {\n\t\tassertVariable(name);\n\t\tif (del) delete map.get(name);\n\t\tmap.remove(name);\n\t}\n\n\tvoid setVariable(const string & name, Variable * v) {\n\t\tif (map.containsKey(name))\n\t\t\tdelete map.get(name);\n\t\tmap.put(name, v);\n\t}\n\n\tVariable * getVariable(const string & name) {\n\t\tassertVariable(name);\n\t\treturn map.get(name);\n\t}\n\n\tvoid releaseAll() {\n\t\tvector<string> names = map.getKeys();\n\t\tforeach (string, name, names)\n\t\t\tdelVariable(*name);\n\t}\n\n};\n\nstruct Context\n{\n\tstring owner;\n\tVariables & global_variables;\n\tVariables & local_variables;\n\tHashTable<string, int> global_used;\n\tvector<int> lines_running;\n\n\tContext(const string & owner_, Variables & global_variables_, Variables & local_variables_) : \n\t\towner(owner_), global_variables(global_variables_), local_variables(local_variables_) {}\n\n\tbool is_global(const string & name, bool is_assign) {\n\t\tif (local_variables.hasVariable(name)) return false;\n\t\tif (global_used.containsKey(name)) return true;\n\t\tif (is_assign) return false;\n\t\tglobal_variables.assertVariable(name);\n\t\tglobal_used.put(name, 0);\n\t\treturn true;\n\t}\n\n\tVariable * getVariable(const string & name) {\n\t\tif (is_global(name, false))\n\t\t\treturn global_variables.getVariable(name);\n\t\telse\n\t\t\treturn local_variables.getVariable(name);\n\t}\n\n\tvoid setVariable(const string & name, Variable * v) {\n\t\tif (is_global(name, true))\n\t\t\treturn global_variables.setVariable(name, v);\n\t\telse\n\t\t\treturn local_variables.setVariable(name, v);\n\t}\n\n};\n\n////////////////////\n// FUNCTIONS\n\nvoid run_builtin_range(Context & context) {\n\tVariable * v = context.local_variables.getVariable(\"n\");\n\tassert_true(v->type == \"int\", \"'range' requires a single 'int' argument\");\n\tint n = ((Int *)v)->intValue;\n\tint level = 2;\n\tif (context.lines_running.size() == level)\n\t\tcontext.lines_running.push_back(0);\n\telse\n\t\t++ context.lines_running[level];\n\tif (context.lines_running[level] >= n) return;\n\tcontext.local_variables.setVariable(\"$ret\", new Int(context.lines_running[level]));\n}\n\nint max_print_calls = 1000;\n\nvoid run_builtin_print(Context & context) {\n\tassert_true(-- max_print_calls > 0, \"Exceeds max_print_calls == 100\");\n\tVariable * v = context.local_variables.getVariable(\"n\");\n\tif (v == 0) cout << \"None\";\n\telse v->print();\n\tcout << endl;\n}\n\nvoid run_builtin(const string & function_name, Context & context) {\n\tif (function_name == \"range\") {\n\t\trun_builtin_range(context);\n\t}\n\telse if (function_name == \"print\") {\n\t\trun_builtin_print(context);\n\t}\n\telse {\n\t\tstringstream ss;\n\t\tss << \"Unknow builtin: \" << function_name << endl;\n\t\tassert_true(false, ss.str());\n\t}\n}\n\nvoid register_builtins(vector<string> & lines, Line & tree, Variables & global_variables) {\n\tget_tree(lines, tree);\n\toptim(tree);\n\tforeach (Line, line, tree.children) {\n\t\tstringstream ss;\n\t\tss << \"Invalid line in 'builtins.py: \" << line->node.type << endl;\n\t\tassert_true(line->node.type == \"function_def\", ss.str());\n\t\tline->node.type = \"builtin\";\n\t\tstring function_name = line->node.children[1].token.text;\n\t\tglobal_variables.setVariable(function_name, new Function(*line));\n\t}\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid run_lines(vector<Line> & lines, Context & context);\nvoid run_line(Line & line, Context & context);\nVariable * run_exp(Node & exp, Context & context);\n\nLine & get_function(const string & function_name, Context & context) {\n\tVariable * v = context.getVariable(function_name);\n\tstringstream ss;\n\tss << \"Not a function: \" << function_name;\n\tassert_true(v->type == \"function\" || v->type == \"builtin\", ss.str());\n\tFunction * func_var = (Function *)v;\n\treturn *(func_var->line);\n}\n\nvoid init_function_parameters(Node & func_node, Context & callee_context, Node & call_node, Context & caller_context) {\n\tint num_args = call_node.children.size() - 3;\n\tint num_params = func_node.children.size() - 5;\n\tstringstream ss;\n\tss << \"Function '\" << call_node.children[0].token.text << \"' arguments not agree\" << endl;\n\tss << \"\\tCaller gives \" << num_args << \" at line: \" << (func_node.children[0].token.line + 1) << endl;\n\tss << \"\\tCallee requires \" << num_params << \" at line: \" << (call_node.children[0].token.line + 1) << endl;\n\tassert_true(num_args == num_params, ss.str());\n\tfor (int i = 0; i < num_params; ++ i) {\n\t\tNode & arg_exp = call_node.children[2 + i];\n\t\tVariable * arg_value = run_exp(arg_exp, caller_context);\n\t\tstring parameter_name = func_node.children[3 + i].token.text;\n\t\tcallee_context.local_variables.setVariable(parameter_name, arg_value);\n\t}\t\n}\n\nVariable * run_function(Node & call_node, Context & context) {\n\tstring function_name = call_node.children[0].token.text;\n\tLine & func_line = get_function(function_name, context);\n\tVariables func_local_variables;\n\tContext func_context(function_name, context.global_variables, func_local_variables);\n\tinit_function_parameters(func_line.node, func_context, call_node, context);\n\t// func_local_variables.print();\n\tif (func_line.node.type == \"builtin\" && func_line.children.size() == 1 && func_line.children[0].node.type == \"pass_statement\")\n\t\trun_builtin(function_name, func_context);\n\telse {\n\t\twhile (func_context.lines_running.size() <= func_line.level)\n\t\t\tfunc_context.lines_running.push_back(-100);\n\t\trun_lines(func_line.children, func_context);\n\t}\n\tVariable * ret = 0;\n\tif (func_local_variables.hasVariable(\"$ret\")) {\n\t\tret = func_local_variables.getVariable(\"$ret\");\n\t\tfunc_local_variables.delVariable(\"$ret\", false);\n\t}\n\tfunc_local_variables.releaseAll();\n\treturn ret;\n}\n\nvoid pass_result(Context & from, Context & to, const string & name) {\n\tVariable * ret = from.local_variables.getVariable(\"$ret\");\n\tfrom.local_variables.delVariable(\"$ret\", false);\n\tto.local_variables.setVariable(name, ret);\n}\n\nContext * init_generator_context(Context & context, Line & gen_def_line, Node & gen_call_node) {\n\tVariables * local_variables = new Variables();\n\tstring gen_func_name = gen_call_node.children[0].token.text;\n\tContext * gen_context = new Context(gen_func_name, context.global_variables, *local_variables);\n\tinit_function_parameters(gen_def_line.node, *gen_context, gen_call_node, context);\n\tcontext.local_variables.setVariable(\"$gen\", new Pointer(gen_context));\n\twhile (gen_context->lines_running.size() <= gen_def_line.level)\n\t\tgen_context->lines_running.push_back(-100);\n\treturn gen_context;\n}\n\nvoid release_generator_context(Context & context) {\n\tPointer * v = (Pointer *)context.local_variables.getVariable(\"$gen\");\n\tContext * gen = (Context *)v->pointer;\n\tcontext.local_variables.delVariable(\"$gen\");\n\tgen->local_variables.releaseAll();\n\tdelete &(gen->local_variables);\n\tdelete gen;\n}\n\nvoid print_int_vector(vector<int> & vec) {\n\tfor (int i = 0; i < vec.size(); ++ i) cout << \" \" << vec[i];\n\tcout << endl;\n}\n\nvoid run_for_statement(Line & for_line, Context & context) {\n\tstring loop_variable_name = for_line.node.children[1].token.text;\n\tNode & gen_node = for_line.node.children[3];\n\tif (gen_node.type == \"function_call\") {\n\t\tstring gen_func_name = gen_node.children[0].token.text;\n\t\tLine & gen_def_line = get_function(gen_func_name, context);\n\t\tContext * gen_context = 0;\n\t\tif (context.local_variables.hasVariable(\"$gen\")) {\n\t\t\tPointer * gen = (Pointer *)context.local_variables.getVariable(\"$gen\");\n\t\t\tgen_context = (Context *)(gen->pointer);\n\t\t\tstringstream ss;\n\t\t\tss << \"Inconsistent generator context: required '\" << gen_func_name << \"', got '\" << gen_context->owner << \"'\";\n\t\t\tassert_true(gen_context->owner == gen_func_name, ss.str());\n\t\t}\n\t\telse \n\t\t\tgen_context = init_generator_context(context, gen_def_line, gen_node);\n\t\tbool done = false;\n\t\twhile (true) {\n\t\t\tif (gen_def_line.node.type == \"builtin\" && gen_def_line.children.size() == 1 && gen_def_line.children[0].node.type == \"pass_statement\")\n\t\t\t\trun_builtin(gen_func_name, *gen_context);\n\t\t\telse\n\t\t\t\trun_lines(gen_def_line.children, *gen_context);\n\t\t\tif (! gen_context->local_variables.hasVariable(\"$ret\")) {\n\t\t\t\tdone = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpass_result(*gen_context, context, loop_variable_name);\n\t\t\trun_lines(for_line.children, context);\n\t\t\tif (context.local_variables.hasVariable(\"$ret\")) break;\n\t\t}\n\t\tif (done) release_generator_context(context);\n\t}\n\telse {\n\t\tstringstream ss;\n\t\tss << \"Unknow generator type: \" << gen_node.type;\n\t\tassert_true(false, ss.str());\n\t}\n}\n\nVariable * run_id(Node & exp, Context & context) {\n\tstring name = exp.token.text;\n\tif (context.local_variables.hasVariable(name))\n\t\treturn context.local_variables.getVariable(name)->copy();\n\tif (context.global_variables.hasVariable(name))\n\t\treturn context.global_variables.getVariable(name)->copy();\n\tstringstream ss;\n\tss << \"Undefined variable: \" << name << endl;\n\tassert_true(false, ss.str());\n\treturn 0;\n}\n\nvoid check_op_type(const string & op, const string & required_type, const string & type) {\n\tstringstream ss;\n\tss << \"The operand of \" << op << \" must be '\" << required_type <<\"' instead of '\" << type << \"'\" << endl;\n\tassert_true(required_type == type, ss.str());\n}\n\nVariable * run_expression(Node & exp, Context & context) {\n\tstring op = \"?\";\n\tif (exp.children.size() == 3) {\n\t\top = exp.children[1].token.text;\n\t\tVariable * left = run_exp(exp.children[0], context);\n\t\tVariable * right = run_exp(exp.children[2], context);\n\t\tif (op == \"+\") {\n\t\t\tcheck_op_type(op, \"int\", left->type);\n\t\t\tcheck_op_type(op, \"int\", right->type);\n\t\t\treturn ((Int *)left)->__add__((Int *)right);\n\t\t}\n\t\telse if (op == \"-\") {\n\t\t\tcheck_op_type(op, \"int\", left->type);\n\t\t\tcheck_op_type(op, \"int\", right->type);\n\t\t\treturn ((Int *)left)->__sub__((Int *)right);\n\t\t}\n\t\telse if (op == \"*\") {\n\t\t\tcheck_op_type(op, \"int\", left->type);\n\t\t\tcheck_op_type(op, \"int\", right->type);\n\t\t\treturn ((Int *)left)->__mul__((Int *)right);\n\t\t}\n\t\telse if (op == \"%\") {\n\t\t\tcheck_op_type(op, \"int\", left->type);\n\t\t\tcheck_op_type(op, \"int\", right->type);\n\t\t\treturn ((Int *)left)->__mod__((Int *)right);\n\t\t}\n\t\telse if (op == \"and\") {\n\t\t\tcheck_op_type(op, \"bool\", left->type);\n\t\t\tcheck_op_type(op, \"bool\", right->type);\n\t\t\treturn ((Bool *)left)->__and__((Bool *)right);\n\t\t}\n\t\telse if (op == \"or\") {\n\t\t\tcheck_op_type(op, \"bool\", left->type);\n\t\t\tcheck_op_type(op, \"bool\", right->type);\n\t\t\treturn ((Bool *)left)->__or__((Bool *)right);\n\t\t}\n\t\telse if (op == \"==\") {\n\t\t\tcheck_op_type(op, left->type, right->type);\n\t\t\treturn left->__eq__(right);\n\t\t}\n\t}\n\telse if (exp.children.size() == 2) {\n\t\top = exp.children[0].token.text;\n\t}\n\tstringstream ss;\n\tss << \"Undefined operator: \" << op << endl;\n\tassert_true(false, ss.str());\n\treturn 0;\n}\n\nVariable * run_exp(Node & exp, Context & context) {\n\tif (exp.type == \"int\") {\n\t\tstringstream ss(exp.token.text);\n\t\tint intValue;\n\t\tss >> intValue;\n\t\treturn new Int(intValue);\n\t}\n\telse if (exp.type == \"str\") {\n\t\treturn new Str(exp.token.text);\n\t}\n\telse if (exp.type == \"True\") {\n\t\treturn new Bool(true);\n\t}\n\telse if (exp.type == \"False\") {\n\t\treturn new Bool(false);\n\t}\n\telse if (exp.type == \"id\") {\n\t\treturn run_id(exp, context);\n\t}\n\telse if (exp.type == \"None\") {\n\t\treturn 0;\n\t}\n\telse if (exp.type == \"function_call\") {\n\t\treturn run_function(exp, context);\n\t}\n\telse if (exp.type == \"expression\") {\n\t\treturn run_expression(exp, context);\n\t}\n\telse {\n\t\tstringstream ss;\n\t\tss << \"Unknow expression type: \" << exp.type << endl << exp << endl;\n\t\tassert_true(false, ss.str());\n\t}\n\treturn 0;\n}\n\nvoid run_yield_statement(Line & line, Context & context) {\n\tVariable * v = run_exp(line.node.children[1], context);\n\tassert_true(v != 0, \"\");\n\tcontext.local_variables.setVariable(\"$ret\", v);\n\t++ context.lines_running[line.level];\n}\n\nvoid run_return_statement(Line & line, Context & context) {\n\tVariable * v = run_exp(line.node.children[1], context);\n\tcontext.local_variables.setVariable(\"$ret\", v);\n\tcontext.lines_running.clear();\n}\n\nvoid run_assign_statement(Line & line, Context & context) {\n\tstring variable_name = line.node.children[0].token.text;\n\tVariable * v = run_exp(line.node.children[2], context);\n\tcontext.setVariable(variable_name, v);\n}\n\nbool is_true(Variable * v) {\n\tif (v == 0) {\n\t\treturn false;\n\t}\n\tif (v->type == \"bool\") {\n\t\treturn ((Bool *)v)->boolValue;\n\t}\n\telse if (v->type == \"int\") {\n\t\treturn ((Int *)v)->intValue != 0;\n\t}\n\tstringstream ss;\n\tss << \"Unknown type for condition: \" << v->type;\n\tassert_true(false, ss.str());\n\treturn false;\n}\n\nvoid run_if_statement(Line & line, Context & context) {\n\tif (context.lines_running.size() > line.level + 1) {\n\t\trun_lines(line.children, context);\n\t\treturn;\n\t}\n\tVariable * v = run_exp(line.node.children[1], context);\n\tstringstream ss;\n\tss << \"$if\" << line.level;\n\tcontext.setVariable(ss.str(), v);\n\tif (is_true(v)) {\n\t\trun_lines(line.children, context);\n\t}\n}\n\nvoid run_else_statement(Line & line, Context & context) {\n\tif (context.lines_running.size() > line.level + 1) {\n\t\trun_lines(line.children, context);\n\t\treturn;\n\t}\n\tstringstream ss;\n\tss << \"$if\" << line.level;\n\tstring condition_name = ss.str();\n\tassert_true(context.local_variables.hasVariable(condition_name), \"Dangling else-statement\");\n\tVariable * v = context.local_variables.getVariable(condition_name);\n\tif (! is_true(v)) {\n\t\trun_lines(line.children, context);\n\t}\n\tcontext.local_variables.delVariable(condition_name);\n}\n\nvoid run_line(Line & line, Context & context) {\n\tif (line.node.type == \"comment\") {\n\t}\n\telse if (line.node.type == \"function_def\") {\n\t\tstring function_name = line.node.children[1].token.text;\n\t\tcontext.local_variables.setVariable(function_name, new Function(line));\n\t}\n\telse if (line.node.type == \"function_call\") {\n\t\trun_function(line.node, context);\n\t}\n\telse if (line.node.type == \"for_statement\") {\n\t\trun_for_statement(line, context);\n\t}\n\telse if (line.node.type == \"yield_statement\") {\n\t\trun_yield_statement(line, context);\n\t}\n\telse if (line.node.type == \"return_statement\") {\n\t\trun_return_statement(line, context);\n\t}\n\telse if (line.node.type == \"assign_statement\") {\n\t\trun_assign_statement(line, context);\n\t}\n\telse if (line.node.type == \"if_statement\") {\n\t\trun_if_statement(line, context);\n\t}\n\telse if (line.node.type == \"else_statement\") {\n\t\trun_else_statement(line, context);\n\t}\n\telse {\n\t\tstringstream ss;\n\t\tss << \"Unknow line type: \" << line.node.type;\n\t\tassert_true(false, ss.str());\n\t}\n}\n\nint get_def_line(Line & line) {\n\tNode * node = &(line.node);\n\twhile (node->children.size() > 0)\n\t\tnode = &(node->children[0]);\n\treturn node->token.line;\n}\n\nvoid run_lines(vector<Line> & lines, Context & context) {\n\tint level = lines[0].level;\n\tstringstream ss;\n\tss << \"Line: \" << get_def_line(lines[0]) <<\" Incorrect level state: \" << context.lines_running.size() << \", requires >= \" << level;\n\tassert_true(context.lines_running.size() >= level, ss.str());\n\tif (context.lines_running.size() == level) {\n\t\tcontext.lines_running.push_back(0);\n\t}\n\tstringstream ss2;\n\tss2 << \"Line: \" << get_def_line(lines[0]) <<\" Incorrect level step: \" << context.lines_running[level];\n\tassert_true(context.lines_running[level] >= 0, ss2.str());\n\twhile (context.lines_running[level] < lines.size()) {\n\t\trun_line(lines[context.lines_running[level]], context);\n\t\tif (context.local_variables.hasVariable(\"$ret\")) break;\n\t\t++ context.lines_running[level];\n\t}\n\tif (context.lines_running[level] == lines.size())\n\t\tcontext.lines_running.pop_back();\n}\n\nvoid run(vector<string> & lib_lines, vector<string> & lines) {\n\tVariables global_variables;\n\tLine builtins_tree;\n\tregister_builtins(lib_lines, builtins_tree, global_variables);\n\n\tLine tree;\n\tget_tree(lines, tree);\n\toptim(tree);\n\tContext global_context(\"__main__\", global_variables, global_variables);\n\twhile (global_context.lines_running.size() <= tree.level)\n\t\tglobal_context.lines_running.push_back(-100);\n\trun_lines(tree.children, global_context);\n\tglobal_variables.releaseAll();\n}\n\nstring builtins = \"def print(n):\\n\\n\tpass\\n\\n\\n\\ndef range(n):\\n\\n\tpass\";\n\nint main() {\n\ttry {\n\t\tvector<string> lib_lines;\n\t\tvector<string> lines;\n\t\tstringstream ss(builtins);\n\t\tread_lines(ss, lib_lines);\n\t\tread_lines(cin, lines);\n\t\trun(lib_lines, lines);\n\t}\n\tcatch (runtime_error & ex) {\n\t\tcout << ex.what() << endl;\n\t}\n}",
            "print('''def test_loop(n):\n\tfor i in range(n):\n\t\tprint(131 - i)\n\ndef test_condition(c):\n\tif c:\n\t\tprint(\"right\")\n\telse:\n\t\tprint(\"no\")\n\ntest_loop(10)\ntest_condition(True)''')",
            1585713600,
            1585713600
        ],
        [
            "16.4 (C++)",
            "Please modify the simple Python compiler as follows:\n<ul>\n<li>Combine all CPP file into a single file</li>\n<li>Input from STDIO instead of from a Python file</li>\n<li>Load library from an internal string instead of from \"lib/builtins.py\"</li>\n</ul>\n\n<b>EXAMPLE INPUT</b>\n<pre>\ndef test_loop(n):\n\tfor i in range(n):\n\t\tprint(1 + i * 2)\n\ndef test_condition(c):\n\tif c:\n\t\tprint(\"yes\")\n\telse:\n\t\tprint(\"no\")\n\ntest_loop(10)\ntest_condition(True)\n</pre>\n\n<b>EXAMPLE OUTPUT</b>\n<pre>\n1\n3\n5\n7\n9\n11\n13\n15\n17\n19\nyes\n</pre>",
            "#include \"source.cpp\"",
            "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <stdexcept>\nusing namespace std;\n\n#include <cstring>\n\nint operator % (const string & text, int max) {\n\tint code = 0;\n\tfor (int i = 0; i < text.size(); ++ i) {\n\t\tint code1 = text[i];\n\t\tcode1 = code1 << (i * 8 % 24);\n\t\tcode = code ^ code1;\n\t}\n\treturn code % max;\n}\n\nclass NoSuchKeyException {};\n\ntemplate <typename K, typename V>\nclass HashTable\n{\nprivate:\n\t\t\n\tclass Entry\n\t{\n\tpublic:\n\t\tK key;\n\t\tV value;\n\t\tbool isInUse;\n\t\t\n\t\tEntry() {\n\t\t\tisInUse = false;\n\t\t}\n\t};\n\t\n\tEntry * entries;\n\t\n\tint capacity;\n\tint count;\n\t\n\tvoid initialize(int capacity2) {\n\t\tcount = 0;\n\t\tcapacity = capacity2;\n\t\tentries = new Entry[capacity];\n\t}\n\t\n\tvoid assign(const HashTable & map2) {\n\t\tcount = map2.count;\n\t\tcapacity = map2.capacity;\n\t\tentries = new Entry[capacity];\n\t\tfor (int i = 0; i < capacity; ++ i) {\n\t\t\tentries[i] = map2.entries[i];\n\t\t}\n\t}\n\t\npublic:\n\t\n\tHashTable() {\n\t\tinitialize(2);\n\t}\n\t\n\t~HashTable() {\n\t\tdelete [] entries;\n\t}\n\t\n\tHashTable(const HashTable & map2) {\n\t\tassign(map2);\n\t}\n\t\n\tHashTable & operator = (const HashTable & map2) {\n\t\tdelete [] entries;\n\t\tassign(map2);\n\t\treturn (*this);\n\t}\n\t\n\tvoid clear() {\n\t\tdelete [] entries;\n\t\tinitialize(2);\n\t}\n\t\nprivate:\n\t\n\tint hashIndex(const K & key) const {\n\t\treturn key % capacity;\n\t}\n\t\n\tint find(const K & key) const {\n\t\tint index = hashIndex(key);\n\t\twhile (true) {\n\t\t\tif (! entries[index].isInUse) {\n\t\t\t\treturn index;\n\t\t\t}\n\t\t\tif (entries[index].key == key) {\n\t\t\t\treturn index;\n\t\t\t}\n\t\t\tindex = (index + 1) % capacity;\n\t\t}\n\t}\n\t\n\tvoid resize(int capacity2) {\n\t\tEntry * entries0 = entries;\n\t\tint capacity0 = capacity;\n\t\tinitialize(capacity2);\n\t\tfor (int i = 0; i < capacity0; ++ i) {\n\t\t\tif (entries0[i].isInUse) {\n\t\t\t\tput(entries0[i].key, entries0[i].value);\n\t\t\t}\n\t\t}\n\t\tdelete [] entries0;\n\t}\n\t\npublic:\n\t\n\tvoid put(const K & key, const V & value) {\n\t\tint index = find(key);\n\t\tentries[index].value = value;\n\t\tif (entries[index].isInUse) return;\n\t\t\n\t\tentries[index].isInUse = true;\n\t\tentries[index].key = key;\n\t\t\n\t\t++ count;\n\t\tif (count > capacity / 2) {\n\t\t\tresize(capacity * 2);\n\t\t}\n\t}\n\t\n\tV get(const K & key) const {\n\t\tint index = find(key);\n\t\tif (! entries[index].isInUse) {\n\t\t\tthrow NoSuchKeyException();\n\t\t}\n\t\treturn entries[index].value;\n\t}\n\t\n\tbool remove(const K & key) {\n\t\tint index = find(key);\n\t\tif (! entries[index].isInUse) return false;\n\t\tfillNotInUseEntry(index);\n\t\t\n\t\t-- count;\n\t\tif (count < capacity / 4) {\n\t\t\tresize(capacity / 2);\n\t\t}\n\t\treturn true;\n\t}\n\t\nprivate:\n\t\n\tvoid fillNotInUseEntry(int index) {\n\t\tint next = index;\n\t\twhile (true) {\n\t\t\tnext = (next + 1) % capacity;\n\t\t\tif (! entries[next].isInUse) {\n\t\t\t\tentries[index].isInUse = false;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint index0 = hashIndex(entries[next].key);\n\t\t\tif (index < next) {\n\t\t\t\tif (index0 > index &&\n\t\t\t\t\tindex0 <= next) continue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (index0 > index ||\n\t\t\t\t\tindex0 <= next) continue;\n\t\t\t}\n\t\t\tentries[index] = entries[next];\n\t\t\tindex = next;\n\t\t}\n\t}\n\t\npublic:\n\t\n\tbool containsKey(const K & key) const {\n\t\tint index = find(key);\n\t\treturn (entries[index].isInUse);\n\t}\n\t\n\tint size() const {\n\t\treturn count;\n\t}\n\n\tvector<K> getKeys() const {\n\t\tvector<K> vec;\n\t\tfor (int i = 0; i < capacity; ++ i) {\n\t\t\tif (entries[i].isInUse) {\n\t\t\t\tvec.push_back(entries[i].key);\n\t\t\t}\n\t\t}\n\t\treturn vec;\n\t}\n\t\n};\n\n////////////////////////////////////////////////////////////////////////////////\n\nstruct Token\n{\n\tint line;\n\tint pos;\n\tstring type;\n\tstring text;\n};\n\nint operator % (const Token & t, int base) {\n\treturn (t.line * 12347 + t.pos) % base;\n}\n\nbool operator == (const Token & t1, const Token & t2) {\n\treturn t1.line == t2.line && t1.pos == t2.pos;\n}\n\nostream & operator << (ostream & out, const Token & t) {\n\tout << t.line << '\\t' << t.pos << '\\t' << t.type << \"\\t\\\"\" << t.text << \"\\\"\";\n\treturn out;\n}\n\nvoid read_lines(istream & in, vector<string> & lines) {\n\tstring line;\n\twhile (getline(in, line)) {\n\t\tlines.push_back(line);\n\t}\n}\n\nToken make_token(int line, int pos, int len, const string & source, const string & type) {\n\tToken t;\n\tt.line = line;\n\tt.pos = pos;\n\tt.type = type;\n\tt.text = source.substr(pos, len);\n\treturn t;\n}\n\n////////////////////\n// RULES BEGIN\n\nToken find_indent(int line, const string & source) {\n\tint len = 0;\n\tfor (int i = 0; i < source.size(); ++ i) {\n\t\tif (source[i] == '\\t')\n\t\t\t++ len;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn make_token(line, 0, len, source, \"indent\");\n}\n\nToken find_blank(int line, const string & source, int start) {\n\tint len = 0;\n\tfor (int i = start; i < source.size(); ++ i) {\n\t\tif (source[i] == '\\t' || source[i] == ' ')\n\t\t\t++ len;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn make_token(line, start, len, source, \"blank\");\n}\n\nToken find_string(int line, const string & source, int start) {\n\tint len = 0;\n\tbool was_backslash = false;\n\tfor (int i = start; i < source.size(); ++ i) {\n\t\tchar c = source[i];\n\t\tif (i == start) {\n\t\t\tif (c == '\"') ++ len;\n\t\t\telse break;\n\t\t}\n\t\telse {\n\t\t\tif (was_backslash) {\n\t\t\t\tif (c == '\\\\' || c == '\\r' || c == '\\n' ||\n\t\t\t\t\tc == '\\t' || c == '\"')\n\t\t\t\t\t++ len;\n\t\t\t\telse break;\n\t\t\t\twas_backslash = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (c == '\"') {\n\t\t\t\t\t++ len;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t++ len;\n\t\t\t\twas_backslash = (c == '\\\\');\n\t\t\t}\n\t\t} \n\t}\n\treturn make_token(line, start, len, source, \"str\");\t\n}\n\nToken find_int(int line, const string & source, int start) {\n\tif (start < source.size()) {\n\t\tif (source[start] == '0' && (start + 1 == source.size() || (source[start + 1] < '0' || source[start + 1] > '9')))\n\t\t\treturn make_token(line, start, 1, source, \"int\");\n\t}\n\tint len = 0;\n\tfor (int i = start; i < source.size(); ++ i) {\n\t\tif ((i != start && source[i] >= '0' && source[i] <= '9' ) ||\n\t\t\t(source[i] >= '1' && source[i] <= '9'))\n\t\t\t++ len;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn make_token(line, start, len, source, \"int\");\t\n}\n\nToken find_id(int line, const string & source, int start) {\n\tint len = 0;\n\tfor (int i = start; i < source.size(); ++ i) {\n\t\tif ((i != start && source[i] >= '0' && source[i] <= '9') ||\n\t\t\t(source[i] >= 'A' && source[i] <= 'Z') ||\n\t\t\t(source[i] >= 'a' && source[i] <= 'z') ||\n\t\t\tsource[i] == '_')\n\t\t\t++ len;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn make_token(line, start, len, source, \"id\");\n}\n\nconst char *keywords[] = {\n\t\"class\", \"def\", \"if\", \"else\", \"for\", \"in\", \"return\", \"yield\", \"and\", \"or\", \"not\", \"pass\",\n\t\"True\", \"False\", \"None\",\n\t\"(\", \")\", \"[\", \"]\", \"{\", \"}\", \":\", \",\", \".\", \n\t\"==\", \">\", \"<\", \"<=\", \">=\", \"!=\", \"=\", \n\t\"+=\", \"-=\", \"*=\", \"/=\", \"//=\", \"%=\", \"&=\", \"^=\", \"|=\", \n\t\"+\", \"-\", \"**\", \"*\", \"//\", \"/\", \"%\", \"&\", \"^\", \"|\"\n};\n\nToken find_keyword(int line, const string & source, int start) {\n\tint keyword = -1;\n\tfor (int i = 0; i < sizeof(keywords) / sizeof(const char *); ++ i) {\n\t\tif (source.compare(start, strlen(keywords[i]), keywords[i]) == 0) {\n\t\t\tkeyword = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (keyword == -1)\n\t\treturn make_token(line, start, 0, source, \"\");\n\treturn make_token(line, start, strlen(keywords[keyword]), source, keywords[keyword]);\t\n}\n\nToken find_comment(int line, const string & source, int start) {\n\tint len = 0;\n\tfor (int i = start; i < source.size(); ++ i) {\n\t\tif (i != start || source[i] == '#')\n\t\t\t++ len;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn make_token(line, start, len, source, \"comment\");\n}\n\n////////////////////\n// RULES END\n\ntypedef Token (* find_function)(int, const string &, int);\n\nvoid add_tokens(HashTable<Token, Token> & tokens, int lineno, const string & line, find_function find, bool can_conflict) {\n\tint start = 0;\n\twhile (start < line.size()) {\n\t\tToken t = find(lineno, line, start);\n\t\tif (t.text.size() > 0) {\n\t\t\tif (can_conflict) {\n\t\t\t\tif (tokens.containsKey(t)) {\n\t\t\t\t\tToken old_t = tokens.get(t);\n\t\t\t\t\tif (old_t.text.size() < t.text.size())\n\t\t\t\t\t\ttokens.put(t, t);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttokens.put(t, t);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (tokens.containsKey(t)) {\n\t\t\t\t\tToken old_t = tokens.get(t);\n\t\t\t\t\tstringstream ss;\n\t\t\t\t\tss << \"Conflicting tokens:\" << endl;\n\t\t\t\t\tss << old_t << endl;\n\t\t\t\t\tss << t << endl;\n\t\t\t\t\tthrow runtime_error(ss.str());\n\t\t\t\t}\n\t\t\t\ttokens.put(t, t);\n\t\t\t}\n\t\t\tstart += t.text.size();\n\t\t}\n\t\telse\n\t\t\t++ start;\n\t}\n}\n\nvoid get_tokens(vector<string> & lines, vector<vector<Token> > & tokens) {\n\tHashTable<Token, Token> all_tokens;\n\tfor (int i = 0; i < lines.size(); ++ i) {\n\t\tToken indent = find_indent(i, lines[i]);\n\t\tif (indent.text.size() > 0)\n\t\t\tall_tokens.put(indent, indent);\n\t\tadd_tokens(all_tokens, i, lines[i], find_string, false);\n\t\tadd_tokens(all_tokens, i, lines[i], find_int, false);\n\t\tadd_tokens(all_tokens, i, lines[i], find_comment, false);\n\t\tadd_tokens(all_tokens, i, lines[i], find_keyword, false);\n\t\tadd_tokens(all_tokens, i, lines[i], find_id, true);\n\t\tadd_tokens(all_tokens, i, lines[i], find_blank, true);\n\t\t// TODO: add more lexical matching functions\n\t}\n\tToken index;\n\tfor (int i = 0; i < lines.size(); ++ i) {\n\t\ttokens.push_back(vector<Token>());\n\t\tindex.line = i;\n\t\tindex.pos = 0;\n\t\twhile (index.pos < lines[i].size()) {\n\t\t\tif (! all_tokens.containsKey(index)) {\n\t\t\t\tstringstream ss;\n\t\t\t\tss << \"Lexical error at line #\" << (index.line + 1) << \" char #\" << index.pos;\n\t\t\t\tthrow runtime_error(ss.str());\n\t\t\t}\n\t\t\tToken t = all_tokens.get(index);\n\t\t\tif (t.type != \"blank\")\n\t\t\t\ttokens[i].push_back(t);\n\t\t\tindex.pos += t.text.size();\n\t\t}\n\t}\n} \n\n////////////////////////////////////////////////////////////////////////////////\n\nstruct Node\n{\n\tint index;\n\tint span;\n\tstring type;\n\tvector<Node> children; // for non-terminal\n\tToken token; // for terminal, as \"indent\" for non-terminal\n};\n\nbool operator == (const Node & n1, const Node & n2) {\n\treturn n1.index == n2.index && n1.span == n2.span && n1.type == n2.type;\n}\n\nstring to_tree_text(string text) {\n\tfor (int i = 0; i < text.size(); ++ i)\n\t\tif (text[i] == ' ') text[i] = '_';\n\tif (text == \"(\") text = \"-LRB-\";\n\tif (text == \")\") text = \"-RRB-\";\n\treturn text;\n}\n\nvoid print_node(ostream & out, const Node & node, int indent=0) {\n\t// for (int i = 0; i < indent; ++ i) out << '\\t';\n\tif (node.children.size() == 0) {\n\t\tout << \"( \" << to_tree_text(node.type) << ' ' << to_tree_text(node.token.text) << \" )\";\n\t}\n\telse {\n\t\t// out << node.type << \"\\tindex=\" << node.index << \"\\tspan=\" << node.span << endl;\n\t\tout << \"( \" << to_tree_text(node.type) << \" \";\n\t\tfor (int i = 0; i < node.children.size(); ++ i) {\n\t\t\tprint_node(out, node.children[i], indent + 1);\n\t\t}\n\t\tout << \" )\";\n\t}\n}\n\nostream & operator << (ostream & out, const Node & node) {\n\tprint_node(out, node, 0);\n\treturn out;\n}\n\n////////////////////\n// RULES BEGIN\n\nvoid make_node(const vector<Node> & node_list, vector<Node> & matched, const string & type, int len) {\n\tif (node_list.size() != len) return;\n\tNode node;\n\tnode.type = type;\n\tfor (int i = 0; i < len; ++ i)\n\t\tnode.children.push_back(node_list[i]);\n\tmatched.push_back(node);\n}\n\nvoid match_function_def(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() < 5) return;\n\tif (node_list[0].type != \"def\") return;\n\tif (node_list[1].type != \"id\") return;\n\tif (node_list[2].type != \"(\") return;\n\tint index = 3;\n\twhile (node_list[index].type == \"id\") {\n\t\t++ index;\n\t\tif (node_list.size() > index && node_list[index].type == \",\") {\n\t\t\t++ index;\n\t\t\tif (node_list.size() <= index || node_list[index].type != \"id\") return;\n\t\t}\n\t\telse break;\n\t}\n\tif (node_list.size() <= index || node_list[index].type != \")\") return;\n\t++ index;\n\tif (node_list.size() <= index || node_list[index].type != \":\") return;\n\t++ index;\n\tmake_node(node_list, matched, \"function_def\", index);\n}\n\nvoid match_expression(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() == 1) {\n\t\tif (node_list[0].type == \"function_call\" ||\n\t\t\tnode_list[0].type == \"str\" ||\n\t\t\tnode_list[0].type == \"id\" ||\n\t\t\tnode_list[0].type == \"int\" ||\n\t\t\tnode_list[0].type == \"None\" ||\n\t\t\tnode_list[0].type == \"True\" ||\n\t\t\tnode_list[0].type == \"False\")\n\t\t{\n\t\t\tmake_node(node_list, matched, \"expression1\", 1); // term\n\t\t}\n\t\telse if (node_list[0].type == \"expression1\") {\n\t\t\tmake_node(node_list, matched, \"expression2\", 1); // factor\n\t\t}\n\t\telse if (node_list[0].type == \"expression2\") {\n\t\t\tmake_node(node_list, matched, \"expression3\", 1); // exp\n\t\t}\n\t\telse if (node_list[0].type == \"expression3\") {\n\t\t\tmake_node(node_list, matched, \"expression4\", 1); // cmp\n\t\t}\n\t\telse if (node_list[0].type == \"expression4\") {\n\t\t\tmake_node(node_list, matched, \"expression5\", 1); // and\n\t\t}\n\t\telse if (node_list[0].type == \"expression5\") {\n\t\t\tmake_node(node_list, matched, \"expression\", 1); // or\n\t\t}\n\t}\n\tif (node_list.size() == 3) {\n\t\tif (node_list[0].type == \"(\" && node_list[1].type == \"expression\" && node_list[2].type == \")\") {\n\t\t\tmake_node(node_list, matched, \"expression1\", 3); // term\n\t\t}\n\t\telse if ((node_list[0].type == \"expression1\" || node_list[0].type == \"expression2L\") && node_list[1].type == \"operator_mul\" && node_list[2].type == \"expression1\") {\n\t\t\tmake_node(node_list, matched, \"expression2\", 3); // factor\n\t\t\tmake_node(node_list, matched, \"expression2L\", 3);\n\t\t}\n\t\telse if ((node_list[0].type == \"expression2\" || node_list[0].type == \"expression3L\") && node_list[1].type == \"operator_add\" && node_list[2].type == \"expression2\") {\n\t\t\tmake_node(node_list, matched, \"expression3\", 3); // exp\n\t\t\tmake_node(node_list, matched, \"expression3L\", 3);\n\t\t}\n\t\telse if ((node_list[0].type == \"expression3\" || node_list[0].type == \"expression4L\") && node_list[1].type == \"operator_cmp\" && node_list[2].type == \"expression3\") {\n\t\t\tmake_node(node_list, matched, \"expression4\", 3); // cmp\n\t\t\tmake_node(node_list, matched, \"expression4L\", 3);\n\t\t}\n\t\telse if ((node_list[0].type == \"expression4\" || node_list[0].type == \"expression5L\") && node_list[1].type == \"operator_and\" && node_list[2].type == \"expression4\") {\n\t\t\tmake_node(node_list, matched, \"expression5\", 3); // and\n\t\t\tmake_node(node_list, matched, \"expression5L\", 3);\n\t\t}\n\t\telse if ((node_list[0].type == \"expression5\" || node_list[0].type == \"expression6L\") && node_list[1].type == \"operator_or\" && node_list[2].type == \"expression5\") {\n\t\t\tmake_node(node_list, matched, \"expression\", 3); // and\n\t\t\tmake_node(node_list, matched, \"expression6L\", 3);\n\t\t}\n\t}\n}\n\nvoid match_function_call(const vector<Node> & node_list, vector<Node> & matched, int start=0) {\n\tif (node_list.size() < 4) return;\n\tif (node_list[0].type != \"id\") return;\n\tif (node_list[1].type != \"(\") return;\n\tint index = 2;\n\twhile (node_list[index].type == \"expression\") {\n\t\t++ index;\n\t\tif (node_list.size() > index && node_list[index].type == \",\") {\n\t\t\t++ index;\n\t\t\tif (node_list.size() <= index || node_list[index].type != \"expression\") return;\n\t\t}\n\t\telse break;\n\t}\n\tif (node_list.size() <= index || node_list[index].type != \")\") return;\n\t++ index;\n\tmake_node(node_list, matched, \"function_call\", index);\n}\n\nvoid match_for(const vector<Node> & node_list, vector<Node> & matched, int start=0) {\n\tif (node_list.size() != 5) return;\n\tif (node_list[0].type != \"for\") return;\n\tif (node_list[1].type != \"id\") return;\n\tif (node_list[2].type != \"in\") return;\n\tif (node_list[3].type != \"expression\") return;\n\tif (node_list[4].type != \":\") return;\n\tmake_node(node_list, matched, \"for_statement\", 5);\n}\n\nvoid match_if(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() != 3) return;\n\tif (node_list[0].type != \"if\") return;\n\tif (node_list[1].type != \"expression\") return;\n\tif (node_list[2].type != \":\") return;\n\tmake_node(node_list, matched, \"if_statement\", 3);\n}\n\nvoid match_else(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() != 2) return;\n\tif (node_list[0].type != \"else\") return;\n\tif (node_list[1].type != \":\") return;\n\tmake_node(node_list, matched, \"else_statement\", 2);\n}\n\nvoid match_operator(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() != 1) return;\n\tif (node_list[0].type == \"+\" || node_list[0].type == \"-\") {\n\t\tmake_node(node_list, matched, \"operator_add\", 1);\n\t}\n\telse if (node_list[0].type == \"*\" || node_list[0].type == \"/\" || node_list[0].type == \"%\") {\n\t\tmake_node(node_list, matched, \"operator_mul\", 1);\n\t}\n\telse if (node_list[0].type == \"==\" || node_list[0].type == \">\" || node_list[0].type == \"<\" \n\t\t || node_list[0].type == \">=\" || node_list[0].type == \"<=\" || node_list[0].type == \"!=\") {\n\t\tmake_node(node_list, matched, \"operator_cmp\", 1);\n\t}\n\telse if (node_list[0].type == \"and\") {\n\t\tmake_node(node_list, matched, \"operator_and\", 1);\n\t}\n\telse if (node_list[0].type == \"or\") {\n\t\tmake_node(node_list, matched, \"operator_or\", 1);\n\t}\n}\n\nvoid match_assign(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() != 3) return;\n\tif (node_list[0].type != \"id\") return;\n\tif (node_list[1].type != \"=\") return;\n\tif (node_list[2].type != \"expression\") return;\n\tmake_node(node_list, matched, \"assign_statement\", 3);\n}\n\nvoid match_yield(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() != 2) return;\n\tif (node_list[0].type != \"yield\") return;\n\tif (node_list[1].type != \"expression\") return;\n\tmake_node(node_list, matched, \"yield_statement\", 2);\n}\n\nvoid match_return(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() == 1) {\n\t\tif (node_list[0].type != \"return\") return;\n\t\tmake_node(node_list, matched, \"return_statement\", 1);\n\t}\n\telse if (node_list.size() == 2) {\n\t\tif (node_list[0].type != \"return\") return;\n\t\tif (node_list[1].type != \"expression\") return;\n\t\tmake_node(node_list, matched, \"return_statement\", 2);\n\t}\n}\n\nvoid match_pass(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() == 1) {\n\t\tif (node_list[0].type != \"pass\") return;\n\t\tmake_node(node_list, matched, \"pass_statement\", 1);\n\t}\n}\n\n////////////////////\n// RULES END\n\nvector<Node> check_rules(vector<Node> & node_list) {\n\tvector<Node> matched;\n\tmatch_function_def(node_list, matched);\n\tmatch_expression(node_list, matched);\n\tmatch_function_call(node_list, matched);\n\tmatch_for(node_list, matched);\n\tmatch_if(node_list, matched);\n\tmatch_else(node_list, matched);\n\tmatch_assign(node_list, matched);\n\tmatch_yield(node_list, matched);\n\tmatch_return(node_list, matched);\n\tmatch_operator(node_list, matched);\n\tmatch_pass(node_list, matched);\n\treturn matched;\n}\n\nvoid check_sequences(vector<vector<Node> > & nodes, vector<Node> & node_list, \n\tint index, vector<Node> & to_check) \n{\n\tNode last_node = node_list[node_list.size() - 1];\n\tint next_index = index + last_node.span;\n\t// cout << next_index << ' ' << nodes.size() << endl;\n\tif (next_index > nodes.size()) {\n\t\tthrow runtime_error(\"Internal error: incorrect next_index\");\n\t}\n\tvector<Node> matched = check_rules(node_list);\n\tfor (int i = 0; i < matched.size(); ++ i) {\n\t\tmatched[i].index = matched[i].children[0].index;\n\t\tmatched[i].span = 0;\n\t\tfor (int j = 0; j < matched[i].children.size(); ++ j)\n\t\t\tmatched[i].span += matched[i].children[j].span;\n\t\tfor (int j = 0; j < to_check.size(); ++ j) {\n\t\t\tif (to_check[j] == matched[i]) {\n\t\t\t\tstringstream ss;\n\t\t\t\tss << \"Internal error: repeated nodes:\" << endl;\n\t\t\t\tss << to_check[j] << endl;\n\t\t\t\tss << matched[i] << endl;\n\t\t\t\tthrow runtime_error(ss.str());\n\t\t\t}\n\t\t}\n\t\tto_check.push_back(matched[i]);\n\t}\n\t// for (int i = 0; i < matched.size(); ++ i) {\n\t// \tcout << matched[i] << endl;\n\t// }\n\tif (next_index == nodes.size()) return;\n\tfor (int i = 0; i < nodes[next_index].size(); ++ i) {\n\t\tNode node = nodes[next_index][i];\n\t\tnode_list.push_back(node);\n\t\tcheck_sequences(nodes, node_list, next_index, to_check);\n\t\tnode_list.pop_back();\n\t}\n}\n\nbool startswith(const string & text, const string & prefix) {\n\tint size = prefix.size();\n\tif (text.size() < size) return false;\n\tstring prefix2 = text.substr(0, size);\n\treturn prefix2 == prefix;\n}\n\nbool endswith(const string & text, const string & postfix) {\n\tint size = postfix.size();\n\tif (text.size() < size) return false;\n\tstring postfix2 = text.substr(text.size() - size, size);\n\treturn postfix2 == postfix;\n}\n\nNode parse_line(int lineno, vector<Token> & tokens) {\n\tvector<vector<Node> > nodes;\n\tvector<Node> to_check;\n\tint span = tokens.size();\n\tfor (int i = 0; i < tokens.size(); ++ i) {\n\t\tif (tokens[i].type == \"indent\") {\n\t\t\t-- span;\n\t\t\tcontinue;\n\t\t}\n\t\tNode node;\n\t\tnode.type = tokens[i].type;\n\t\tnode.index = nodes.size();\n\t\tnode.span = 1;\n\t\tnode.token = tokens[i];\n\t\tnodes.push_back(vector<Node>());\n\t\tto_check.push_back(node);\n\t}\n\twhile (to_check.size() > 0) {\n\t\tNode first = to_check[to_check.size() - 1];\n\t\t// cout << \"--->\" << '\\t' << first << endl;\n\t\tto_check.pop_back();\n\t\tvector<Node> node_list;\n\t\tnode_list.push_back(first);\n\t\tnodes[first.index].push_back(first);\n\t\tcheck_sequences(nodes, node_list, first.index, to_check);\n\t}\n\tint result = -1;\n\tfor (int i = 0; i < nodes[0].size(); ++ i) {\n\t\tif (nodes[0][i].span == span) \n\t\t\tresult = i;\n\t}\n\tif (result == -1) {\n\t\tstringstream ss;\n\t\tss << \"Syntax error in line: \" << (lineno + 1);\n\t\tthrow runtime_error(ss.str());\n\t}\n\treturn nodes[0][result];\n}\n\nstruct Line\n{\n\tint level;\n\tNode node;\n\tvector<Line> children;\n};\n\nvoid print_line(ostream & out, const Line & line, int indent=0) {\n\t// for (int i = 0; i < indent; ++ i) out << '\\t';\n\tif (line.children.size() == 0) {\n\t\t// out << line.node.type << '\\t' << line.node.token.text << endl;\n\t\tout << \"( \" << line.node.type << \"@\" << line.level << \" _ )\";\n\t}\n\telse {\n\t\tout << \"( \" << line.node.type << \"@\" << line.level << \" \";\n\t\tfor (int i = 0; i < line.children.size(); ++ i) {\n\t\t\tprint_line(out, line.children[i], indent + 1);\n\t\t}\n\t\tout << \" )\";\n\t}\n}\n\nostream & operator << (ostream & out, const Line & line) {\n\tprint_line(out, line, 0);\n\treturn out;\n}\n\nvoid indent_error(const Token & indent) {\n\tstringstream ss;\n\tss << \"Inconsistent indentation at line: \" << indent.line;\n\tthrow runtime_error(ss.str());\n}\n\nvoid get_tree(vector<string> & lines, Line & tree) {\n\tvector<vector<Token> > tokens;\n\tvector<Node> nodes;\n\tvector<Token> indents;\n\tget_tokens(lines, tokens);\n\tfor (int i = 0; i < tokens.size(); ++ i) {\n\t\tif (tokens[i].size() > 0) {\n\t\t\tif (tokens[i][0].type == \"indent\")\n\t\t\t\tindents.push_back(tokens[i][0]);\n\t\t\telse\n\t\t\t\tindents.push_back(Token());\n\t\t\tnodes.push_back(parse_line(i, tokens[i]));\n\t\t}\n\t}\n\ttree.level = 0;\n\ttree.node.type = \"__main__\";\n\ttree.node.token.text = \"__main__\";\n\ttree.node.index = 0;\n\ttree.node.span = 0;\n\tvector<Line *> stack;\n\tvector<string> indent_stack;\n\tstack.push_back(&tree);\n\tindent_stack.push_back(\"\");\n\tfor (int i = 0; i < nodes.size(); ++ i) {\n\t\tstring last_indent = indent_stack[indent_stack.size() - 1];\n\t\tLine next;\n\t\tnext.node = nodes[i];\n\t\tLine * parent = stack[stack.size() - 1];\n\t\tif (indents[i].text == last_indent) {\n\t\t\tnext.level = parent->level + 1;\n\t\t\tparent->children.push_back(next);\n\t\t}\n\t\telse {\n\t\t\tif (startswith(indents[i].text, last_indent)) {\n\t\t\t\tindent_stack.push_back(indents[i].text);\n\t\t\t\tif (parent->children.size() == 0) indent_error(indents[i]);\n\t\t\t\tparent = &parent->children[parent->children.size() - 1];\n\t\t\t\tstack.push_back(parent);\n\t\t\t\tnext.level = parent->level + 1;\n\t\t\t\tparent->children.push_back(next);\n\t\t\t}\n\t\t\telse {\n\t\t\t\twhile (true) {\n\t\t\t\t\tif (indents[i].text == last_indent) {\n\t\t\t\t\t\tnext.level = parent->level + 1;\n\t\t\t\t\t\tparent->children.push_back(next);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (startswith(last_indent, indents[i].text)) {\n\t\t\t\t\t\tindent_stack.pop_back();\n\t\t\t\t\t\tlast_indent = indent_stack[indent_stack.size() - 1];\n\t\t\t\t\t\tstack.pop_back();\n\t\t\t\t\t\tif (stack.size() == 0) indent_error(indents[i]);\n\t\t\t\t\t\tparent = stack[stack.size() - 1];\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tindent_error(indents[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid print_nodes(ostream & out, const Line & line) {\n\tout << line.node << endl;\n\tif (line.children.size() == 0) return;\n\tfor (int i = 0; i < line.children.size(); ++ i) {\n\t\tprint_nodes(out, line.children[i]);\n\t}\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid optim_exp(Node & node) {\n\tif (node.children.size() == 1) {\n\t\tNode child = node.children[0];\n\t\tnode = child;\n\t}\n\telse if (node.children.size() == 3 && node.children[0].type == \"(\" && node.children[2].type == \")\") {\n\t\tNode child = node.children[1];\n\t\tnode = child;\n\t}\n\tif (startswith(node.type, \"expression\"))\n\t\tnode.type = \"expression\";\n}\n\nvoid optim(Node & node) {\n\tfor (int i = 0; i < node.children.size(); ++ i)\n\t\toptim(node.children[i]);\n\tif (startswith(node.type, \"expression\"))\n\t\toptim_exp(node);\n\tif (startswith(node.type, \"operator_\"))\n\t\tnode = node.children[0];\n}\n\nvoid optim(Line & line) {\n\toptim(line.node);\n\tfor (int i = 0; i < line.children.size(); ++ i) {\n\t\toptim(line.children[i]);\n\t}\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#define foreach(type, item, vec) for (vector<type>::iterator item=vec.begin(); item != vec.end(); ++ item)\n\nvoid assert_true(bool test, const string & err_msg) {\n\tif (! test) throw runtime_error(err_msg);\n}\n\n//////////\n// TYPES\n\nstruct Variable\n{\n\tstring type;\n\tvirtual void print() {\n\t\tcout << type;\n\t}\n\tvirtual Variable * copy() {\n\t\tstringstream ss;\n\t\tss << \"'\" << type << \".copy' is not implemented\";\n\t\tassert_true(false, ss.str());\n\t\treturn 0;\n\t}\n\tvirtual Variable * __eq__(Variable * op) {\n\t\tstringstream ss;\n\t\tss << \"'\" << type << \".__eq__' is not implemented\";\n\t\tassert_true(false, ss.str());\n\t\treturn 0;\n\t}\n};\n\nstruct Int : public Variable\n{\n\tint intValue;\n\tInt(int value) {\n\t\ttype = \"int\";\n\t\tintValue = value;\n\t}\n\tvoid print() {\n\t\tcout << intValue;\n\t}\n\tvirtual Variable * copy() {\n\t\treturn new Int(intValue);\n\t}\n\tVariable * __add__(Int * op) {\n\t\tInt * ret = (Int *)copy();\n\t\tret->intValue += op->intValue;\n\t\treturn ret;\n\t}\n\tVariable * __sub__(Int * op) {\n\t\tInt * ret = (Int *)copy();\n\t\tret->intValue -= op->intValue;\n\t\treturn ret;\n\t}\n\tVariable * __mul__(Int * op) {\n\t\tInt * ret = (Int *)copy();\n\t\tret->intValue *= op->intValue;\n\t\treturn ret;\n\t}\n\tVariable * __mod__(Int * op) {\n\t\tInt * ret = (Int *)copy();\n\t\tret->intValue = ret->intValue % op->intValue;\n\t\treturn ret;\n\t}\n\tVariable * __eq__(Variable * op) {\n\t\tInt * op2 = (Int *)op;\n\t\treturn new Int(intValue == op2->intValue);\n\t}\n};\n\nstruct Bool : public Variable\n{\n\tbool boolValue;\n\tBool(bool value) {\n\t\ttype = \"bool\";\n\t\tboolValue = value;\n\t}\n\tvoid print() {\n\t\tif (boolValue) cout << \"True\";\n\t\telse cout << \"False\";\n\t}\n\tvirtual Variable * copy() {\n\t\treturn new Bool(boolValue);\n\t}\n\tVariable * __and__(Bool * op) {\n\t\tBool * ret = (Bool *)copy();\n\t\tret->boolValue = ret->boolValue && op->boolValue;\n\t\treturn ret;\n\t}\n\tVariable * __or__(Bool * op) {\n\t\tBool * ret = (Bool *)copy();\n\t\tret->boolValue = ret->boolValue || op->boolValue;\n\t\treturn ret;\n\t}\n\tVariable * __eq__(Variable * op) {\n\t\tBool * op2 = (Bool *)op;\n\t\treturn new Bool(boolValue == op2->boolValue);\n\t}\n};\n\n\nstruct Str : public Variable\n{\n\tstring strValue;\n\tStr(string value) {\n\t\ttype = \"str\";\n\t\tstrValue = value;\n\t}\n\tvoid print() {\n\t\tbool was_backslash = false;\n\t\tfor (int i = 1; i < strValue.size() - 1; ++ i) {\n\t\t\tchar c = strValue[i];\n\t\t\tif (was_backslash) {\n\t\t\t\tstring err_msg = \"Unknown sequence '\\\\?'\";\n\t\t\t\tswitch (c) {\n\t\t\t\t\tcase '\\\\': cout << '\\\\'; break;\n\t\t\t\t\tcase '\\r': cout << '\\r'; break;\n\t\t\t\t\tcase '\\t': cout << '\\t'; break;\n\t\t\t\t\tcase '\\n': cout << '\\n'; break;\n\t\t\t\t\tcase '\"': cout << '\"'; break;\n\t\t\t\t\tdefault: err_msg[err_msg.size() - 2] = c; assert_true(false, err_msg);\n\t\t\t\t}\n\t\t\t\twas_backslash = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (c == '\\\\') was_backslash = true;\n\t\t\t\telse cout << c;\n\t\t\t}\n\t\t}\n\t}\n\tvirtual Variable * copy() {\n\t\treturn new Str(strValue);\n\t}\n};\n\nstruct Function : public Variable\n{\n\tLine * line;\n\tFunction(Line & value) {\n\t\ttype = \"function\";\n\t\tline = &value;\n\t}\n\tvoid print() {\n\t\tcout << type << '\\t';\n\t\tprint_node(cout, line->node);\n\t}\n};\n\nstruct Pointer : public Variable\n{\n\tvoid * pointer;\n\tPointer(void * value) {\n\t\ttype = \"pointer\";\n\t\tpointer = value;\n\t}\n};\n\nstruct Variables\n{\n\tHashTable<string, Variable*> map;\n\n\tvoid print() {\n\t\tvector<string> names = map.getKeys();\n\t\tforeach (string, name, names) {\n\t\t\tcout << *name << '\\t';\n\t\t\tmap.get(*name)->print();\n\t\t\tcout << endl;\n\t\t}\n\t}\n\n\tbool hasVariable(const string & name) {\n\t\treturn map.containsKey(name);\n\t}\n\n\tvoid assertVariable(const string & name) {\n\t\tstringstream ss;\n\t\tss << \"Variable '\" << name << \"' is undefined\"; \n\t\tassert_true(map.containsKey(name), ss.str());\t\t\n\t}\n\n\tvoid assertType(const string & name, const string & type) {\n\t\tstringstream ss;\n\t\tss << \"Require '\" << type << \"', got '\" << map.get(name)->type << \"' \"; \n\t\tassert_true(map.get(name)->type == type, ss.str());\t\t\n\t}\n\n\tstring getType(const string & name) {\n\t\tassertVariable(name);\n\t\treturn map.get(name)->type;\n\t}\n\n\tvoid delVariable(const string & name, bool del=true) {\n\t\tassertVariable(name);\n\t\tif (del) delete map.get(name);\n\t\tmap.remove(name);\n\t}\n\n\tvoid setVariable(const string & name, Variable * v) {\n\t\tif (map.containsKey(name))\n\t\t\tdelete map.get(name);\n\t\tmap.put(name, v);\n\t}\n\n\tVariable * getVariable(const string & name) {\n\t\tassertVariable(name);\n\t\treturn map.get(name);\n\t}\n\n\tvoid releaseAll() {\n\t\tvector<string> names = map.getKeys();\n\t\tforeach (string, name, names)\n\t\t\tdelVariable(*name);\n\t}\n\n};\n\nstruct Context\n{\n\tstring owner;\n\tVariables & global_variables;\n\tVariables & local_variables;\n\tHashTable<string, int> global_used;\n\tvector<int> lines_running;\n\n\tContext(const string & owner_, Variables & global_variables_, Variables & local_variables_) : \n\t\towner(owner_), global_variables(global_variables_), local_variables(local_variables_) {}\n\n\tbool is_global(const string & name, bool is_assign) {\n\t\tif (local_variables.hasVariable(name)) return false;\n\t\tif (global_used.containsKey(name)) return true;\n\t\tif (is_assign) return false;\n\t\tglobal_variables.assertVariable(name);\n\t\tglobal_used.put(name, 0);\n\t\treturn true;\n\t}\n\n\tVariable * getVariable(const string & name) {\n\t\tif (is_global(name, false))\n\t\t\treturn global_variables.getVariable(name);\n\t\telse\n\t\t\treturn local_variables.getVariable(name);\n\t}\n\n\tvoid setVariable(const string & name, Variable * v) {\n\t\tif (is_global(name, true))\n\t\t\treturn global_variables.setVariable(name, v);\n\t\telse\n\t\t\treturn local_variables.setVariable(name, v);\n\t}\n\n};\n\n////////////////////\n// FUNCTIONS\n\nvoid run_builtin_range(Context & context) {\n\tVariable * v = context.local_variables.getVariable(\"n\");\n\tassert_true(v->type == \"int\", \"'range' requires a single 'int' argument\");\n\tint n = ((Int *)v)->intValue;\n\tint level = 2;\n\tif (context.lines_running.size() == level)\n\t\tcontext.lines_running.push_back(0);\n\telse\n\t\t++ context.lines_running[level];\n\tif (context.lines_running[level] >= n) return;\n\tcontext.local_variables.setVariable(\"$ret\", new Int(context.lines_running[level]));\n}\n\nint max_print_calls = 1000;\n\nvoid run_builtin_print(Context & context) {\n\tassert_true(-- max_print_calls > 0, \"Exceeds max_print_calls == 100\");\n\tVariable * v = context.local_variables.getVariable(\"n\");\n\tif (v == 0) cout << \"None\";\n\telse v->print();\n\tcout << endl;\n}\n\nvoid run_builtin(const string & function_name, Context & context) {\n\tif (function_name == \"range\") {\n\t\trun_builtin_range(context);\n\t}\n\telse if (function_name == \"print\") {\n\t\trun_builtin_print(context);\n\t}\n\telse {\n\t\tstringstream ss;\n\t\tss << \"Unknow builtin: \" << function_name << endl;\n\t\tassert_true(false, ss.str());\n\t}\n}\n\nvoid register_builtins(vector<string> & lines, Line & tree, Variables & global_variables) {\n\tget_tree(lines, tree);\n\toptim(tree);\n\tforeach (Line, line, tree.children) {\n\t\tstringstream ss;\n\t\tss << \"Invalid line in 'builtins.py: \" << line->node.type << endl;\n\t\tassert_true(line->node.type == \"function_def\", ss.str());\n\t\tline->node.type = \"builtin\";\n\t\tstring function_name = line->node.children[1].token.text;\n\t\tglobal_variables.setVariable(function_name, new Function(*line));\n\t}\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid run_lines(vector<Line> & lines, Context & context);\nvoid run_line(Line & line, Context & context);\nVariable * run_exp(Node & exp, Context & context);\n\nLine & get_function(const string & function_name, Context & context) {\n\tVariable * v = context.getVariable(function_name);\n\tstringstream ss;\n\tss << \"Not a function: \" << function_name;\n\tassert_true(v->type == \"function\" || v->type == \"builtin\", ss.str());\n\tFunction * func_var = (Function *)v;\n\treturn *(func_var->line);\n}\n\nvoid init_function_parameters(Node & func_node, Context & callee_context, Node & call_node, Context & caller_context) {\n\tint num_args = call_node.children.size() - 3;\n\tint num_params = func_node.children.size() - 5;\n\tstringstream ss;\n\tss << \"Function '\" << call_node.children[0].token.text << \"' arguments not agree\" << endl;\n\tss << \"\\tCaller gives \" << num_args << \" at line: \" << (func_node.children[0].token.line + 1) << endl;\n\tss << \"\\tCallee requires \" << num_params << \" at line: \" << (call_node.children[0].token.line + 1) << endl;\n\tassert_true(num_args == num_params, ss.str());\n\tfor (int i = 0; i < num_params; ++ i) {\n\t\tNode & arg_exp = call_node.children[2 + i];\n\t\tVariable * arg_value = run_exp(arg_exp, caller_context);\n\t\tstring parameter_name = func_node.children[3 + i].token.text;\n\t\tcallee_context.local_variables.setVariable(parameter_name, arg_value);\n\t}\t\n}\n\nVariable * run_function(Node & call_node, Context & context) {\n\tstring function_name = call_node.children[0].token.text;\n\tLine & func_line = get_function(function_name, context);\n\tVariables func_local_variables;\n\tContext func_context(function_name, context.global_variables, func_local_variables);\n\tinit_function_parameters(func_line.node, func_context, call_node, context);\n\t// func_local_variables.print();\n\tif (func_line.node.type == \"builtin\" && func_line.children.size() == 1 && func_line.children[0].node.type == \"pass_statement\")\n\t\trun_builtin(function_name, func_context);\n\telse {\n\t\twhile (func_context.lines_running.size() <= func_line.level)\n\t\t\tfunc_context.lines_running.push_back(-100);\n\t\trun_lines(func_line.children, func_context);\n\t}\n\tVariable * ret = 0;\n\tif (func_local_variables.hasVariable(\"$ret\")) {\n\t\tret = func_local_variables.getVariable(\"$ret\");\n\t\tfunc_local_variables.delVariable(\"$ret\", false);\n\t}\n\tfunc_local_variables.releaseAll();\n\treturn ret;\n}\n\nvoid pass_result(Context & from, Context & to, const string & name) {\n\tVariable * ret = from.local_variables.getVariable(\"$ret\");\n\tfrom.local_variables.delVariable(\"$ret\", false);\n\tto.local_variables.setVariable(name, ret);\n}\n\nContext * init_generator_context(Context & context, Line & gen_def_line, Node & gen_call_node) {\n\tVariables * local_variables = new Variables();\n\tstring gen_func_name = gen_call_node.children[0].token.text;\n\tContext * gen_context = new Context(gen_func_name, context.global_variables, *local_variables);\n\tinit_function_parameters(gen_def_line.node, *gen_context, gen_call_node, context);\n\tcontext.local_variables.setVariable(\"$gen\", new Pointer(gen_context));\n\twhile (gen_context->lines_running.size() <= gen_def_line.level)\n\t\tgen_context->lines_running.push_back(-100);\n\treturn gen_context;\n}\n\nvoid release_generator_context(Context & context) {\n\tPointer * v = (Pointer *)context.local_variables.getVariable(\"$gen\");\n\tContext * gen = (Context *)v->pointer;\n\tcontext.local_variables.delVariable(\"$gen\");\n\tgen->local_variables.releaseAll();\n\tdelete &(gen->local_variables);\n\tdelete gen;\n}\n\nvoid print_int_vector(vector<int> & vec) {\n\tfor (int i = 0; i < vec.size(); ++ i) cout << \" \" << vec[i];\n\tcout << endl;\n}\n\nvoid run_for_statement(Line & for_line, Context & context) {\n\tstring loop_variable_name = for_line.node.children[1].token.text;\n\tNode & gen_node = for_line.node.children[3];\n\tif (gen_node.type == \"function_call\") {\n\t\tstring gen_func_name = gen_node.children[0].token.text;\n\t\tLine & gen_def_line = get_function(gen_func_name, context);\n\t\tContext * gen_context = 0;\n\t\tif (context.local_variables.hasVariable(\"$gen\")) {\n\t\t\tPointer * gen = (Pointer *)context.local_variables.getVariable(\"$gen\");\n\t\t\tgen_context = (Context *)(gen->pointer);\n\t\t\tstringstream ss;\n\t\t\tss << \"Inconsistent generator context: required '\" << gen_func_name << \"', got '\" << gen_context->owner << \"'\";\n\t\t\tassert_true(gen_context->owner == gen_func_name, ss.str());\n\t\t}\n\t\telse \n\t\t\tgen_context = init_generator_context(context, gen_def_line, gen_node);\n\t\tbool done = false;\n\t\twhile (true) {\n\t\t\tif (gen_def_line.node.type == \"builtin\" && gen_def_line.children.size() == 1 && gen_def_line.children[0].node.type == \"pass_statement\")\n\t\t\t\trun_builtin(gen_func_name, *gen_context);\n\t\t\telse\n\t\t\t\trun_lines(gen_def_line.children, *gen_context);\n\t\t\tif (! gen_context->local_variables.hasVariable(\"$ret\")) {\n\t\t\t\tdone = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpass_result(*gen_context, context, loop_variable_name);\n\t\t\trun_lines(for_line.children, context);\n\t\t\tif (context.local_variables.hasVariable(\"$ret\")) break;\n\t\t}\n\t\tif (done) release_generator_context(context);\n\t}\n\telse {\n\t\tstringstream ss;\n\t\tss << \"Unknow generator type: \" << gen_node.type;\n\t\tassert_true(false, ss.str());\n\t}\n}\n\nVariable * run_id(Node & exp, Context & context) {\n\tstring name = exp.token.text;\n\tif (context.local_variables.hasVariable(name))\n\t\treturn context.local_variables.getVariable(name)->copy();\n\tif (context.global_variables.hasVariable(name))\n\t\treturn context.global_variables.getVariable(name)->copy();\n\tstringstream ss;\n\tss << \"Undefined variable: \" << name << endl;\n\tassert_true(false, ss.str());\n\treturn 0;\n}\n\nvoid check_op_type(const string & op, const string & required_type, const string & type) {\n\tstringstream ss;\n\tss << \"The operand of \" << op << \" must be '\" << required_type <<\"' instead of '\" << type << \"'\" << endl;\n\tassert_true(required_type == type, ss.str());\n}\n\nVariable * run_expression(Node & exp, Context & context) {\n\tstring op = \"?\";\n\tif (exp.children.size() == 3) {\n\t\top = exp.children[1].token.text;\n\t\tVariable * left = run_exp(exp.children[0], context);\n\t\tVariable * right = run_exp(exp.children[2], context);\n\t\tif (op == \"+\") {\n\t\t\tcheck_op_type(op, \"int\", left->type);\n\t\t\tcheck_op_type(op, \"int\", right->type);\n\t\t\treturn ((Int *)left)->__add__((Int *)right);\n\t\t}\n\t\telse if (op == \"-\") {\n\t\t\tcheck_op_type(op, \"int\", left->type);\n\t\t\tcheck_op_type(op, \"int\", right->type);\n\t\t\treturn ((Int *)left)->__sub__((Int *)right);\n\t\t}\n\t\telse if (op == \"*\") {\n\t\t\tcheck_op_type(op, \"int\", left->type);\n\t\t\tcheck_op_type(op, \"int\", right->type);\n\t\t\treturn ((Int *)left)->__mul__((Int *)right);\n\t\t}\n\t\telse if (op == \"%\") {\n\t\t\tcheck_op_type(op, \"int\", left->type);\n\t\t\tcheck_op_type(op, \"int\", right->type);\n\t\t\treturn ((Int *)left)->__mod__((Int *)right);\n\t\t}\n\t\telse if (op == \"and\") {\n\t\t\tcheck_op_type(op, \"bool\", left->type);\n\t\t\tcheck_op_type(op, \"bool\", right->type);\n\t\t\treturn ((Bool *)left)->__and__((Bool *)right);\n\t\t}\n\t\telse if (op == \"or\") {\n\t\t\tcheck_op_type(op, \"bool\", left->type);\n\t\t\tcheck_op_type(op, \"bool\", right->type);\n\t\t\treturn ((Bool *)left)->__or__((Bool *)right);\n\t\t}\n\t\telse if (op == \"==\") {\n\t\t\tcheck_op_type(op, left->type, right->type);\n\t\t\treturn left->__eq__(right);\n\t\t}\n\t}\n\telse if (exp.children.size() == 2) {\n\t\top = exp.children[0].token.text;\n\t}\n\tstringstream ss;\n\tss << \"Undefined operator: \" << op << endl;\n\tassert_true(false, ss.str());\n\treturn 0;\n}\n\nVariable * run_exp(Node & exp, Context & context) {\n\tif (exp.type == \"int\") {\n\t\tstringstream ss(exp.token.text);\n\t\tint intValue;\n\t\tss >> intValue;\n\t\treturn new Int(intValue);\n\t}\n\telse if (exp.type == \"str\") {\n\t\treturn new Str(exp.token.text);\n\t}\n\telse if (exp.type == \"True\") {\n\t\treturn new Bool(true);\n\t}\n\telse if (exp.type == \"False\") {\n\t\treturn new Bool(false);\n\t}\n\telse if (exp.type == \"id\") {\n\t\treturn run_id(exp, context);\n\t}\n\telse if (exp.type == \"None\") {\n\t\treturn 0;\n\t}\n\telse if (exp.type == \"function_call\") {\n\t\treturn run_function(exp, context);\n\t}\n\telse if (exp.type == \"expression\") {\n\t\treturn run_expression(exp, context);\n\t}\n\telse {\n\t\tstringstream ss;\n\t\tss << \"Unknow expression type: \" << exp.type << endl << exp << endl;\n\t\tassert_true(false, ss.str());\n\t}\n\treturn 0;\n}\n\nvoid run_yield_statement(Line & line, Context & context) {\n\tVariable * v = run_exp(line.node.children[1], context);\n\tassert_true(v != 0, \"\");\n\tcontext.local_variables.setVariable(\"$ret\", v);\n\t++ context.lines_running[line.level];\n}\n\nvoid run_return_statement(Line & line, Context & context) {\n\tVariable * v = run_exp(line.node.children[1], context);\n\tcontext.local_variables.setVariable(\"$ret\", v);\n\tcontext.lines_running.clear();\n}\n\nvoid run_assign_statement(Line & line, Context & context) {\n\tstring variable_name = line.node.children[0].token.text;\n\tVariable * v = run_exp(line.node.children[2], context);\n\tcontext.setVariable(variable_name, v);\n}\n\nbool is_true(Variable * v) {\n\tif (v == 0) {\n\t\treturn false;\n\t}\n\tif (v->type == \"bool\") {\n\t\treturn ((Bool *)v)->boolValue;\n\t}\n\telse if (v->type == \"int\") {\n\t\treturn ((Int *)v)->intValue != 0;\n\t}\n\tstringstream ss;\n\tss << \"Unknown type for condition: \" << v->type;\n\tassert_true(false, ss.str());\n\treturn false;\n}\n\nvoid run_if_statement(Line & line, Context & context) {\n\tif (context.lines_running.size() > line.level + 1) {\n\t\trun_lines(line.children, context);\n\t\treturn;\n\t}\n\tVariable * v = run_exp(line.node.children[1], context);\n\tstringstream ss;\n\tss << \"$if\" << line.level;\n\tcontext.setVariable(ss.str(), v);\n\tif (is_true(v)) {\n\t\trun_lines(line.children, context);\n\t}\n}\n\nvoid run_else_statement(Line & line, Context & context) {\n\tif (context.lines_running.size() > line.level + 1) {\n\t\trun_lines(line.children, context);\n\t\treturn;\n\t}\n\tstringstream ss;\n\tss << \"$if\" << line.level;\n\tstring condition_name = ss.str();\n\tassert_true(context.local_variables.hasVariable(condition_name), \"Dangling else-statement\");\n\tVariable * v = context.local_variables.getVariable(condition_name);\n\tif (! is_true(v)) {\n\t\trun_lines(line.children, context);\n\t}\n\tcontext.local_variables.delVariable(condition_name);\n}\n\nvoid run_line(Line & line, Context & context) {\n\tif (line.node.type == \"comment\") {\n\t}\n\telse if (line.node.type == \"function_def\") {\n\t\tstring function_name = line.node.children[1].token.text;\n\t\tcontext.local_variables.setVariable(function_name, new Function(line));\n\t}\n\telse if (line.node.type == \"function_call\") {\n\t\trun_function(line.node, context);\n\t}\n\telse if (line.node.type == \"for_statement\") {\n\t\trun_for_statement(line, context);\n\t}\n\telse if (line.node.type == \"yield_statement\") {\n\t\trun_yield_statement(line, context);\n\t}\n\telse if (line.node.type == \"return_statement\") {\n\t\trun_return_statement(line, context);\n\t}\n\telse if (line.node.type == \"assign_statement\") {\n\t\trun_assign_statement(line, context);\n\t}\n\telse if (line.node.type == \"if_statement\") {\n\t\trun_if_statement(line, context);\n\t}\n\telse if (line.node.type == \"else_statement\") {\n\t\trun_else_statement(line, context);\n\t}\n\telse {\n\t\tstringstream ss;\n\t\tss << \"Unknow line type: \" << line.node.type;\n\t\tassert_true(false, ss.str());\n\t}\n}\n\nint get_def_line(Line & line) {\n\tNode * node = &(line.node);\n\twhile (node->children.size() > 0)\n\t\tnode = &(node->children[0]);\n\treturn node->token.line;\n}\n\nvoid run_lines(vector<Line> & lines, Context & context) {\n\tint level = lines[0].level;\n\tstringstream ss;\n\tss << \"Line: \" << get_def_line(lines[0]) <<\" Incorrect level state: \" << context.lines_running.size() << \", requires >= \" << level;\n\tassert_true(context.lines_running.size() >= level, ss.str());\n\tif (context.lines_running.size() == level) {\n\t\tcontext.lines_running.push_back(0);\n\t}\n\tstringstream ss2;\n\tss2 << \"Line: \" << get_def_line(lines[0]) <<\" Incorrect level step: \" << context.lines_running[level];\n\tassert_true(context.lines_running[level] >= 0, ss2.str());\n\twhile (context.lines_running[level] < lines.size()) {\n\t\trun_line(lines[context.lines_running[level]], context);\n\t\tif (context.local_variables.hasVariable(\"$ret\")) break;\n\t\t++ context.lines_running[level];\n\t}\n\tif (context.lines_running[level] == lines.size())\n\t\tcontext.lines_running.pop_back();\n}\n\nvoid run(vector<string> & lib_lines, vector<string> & lines) {\n\tVariables global_variables;\n\tLine builtins_tree;\n\tregister_builtins(lib_lines, builtins_tree, global_variables);\n\n\tLine tree;\n\tget_tree(lines, tree);\n\toptim(tree);\n\tContext global_context(\"__main__\", global_variables, global_variables);\n\twhile (global_context.lines_running.size() <= tree.level)\n\t\tglobal_context.lines_running.push_back(-100);\n\trun_lines(tree.children, global_context);\n\tglobal_variables.releaseAll();\n}\n\nstring builtins = \"def print(n):\\n\\n\tpass\\n\\n\\n\\ndef range(n):\\n\\n\tpass\";\n\nint main() {\n\ttry {\n\t\tvector<string> lib_lines;\n\t\tvector<string> lines;\n\t\tstringstream ss(builtins);\n\t\tread_lines(ss, lib_lines);\n\t\tread_lines(cin, lines);\n\t\trun(lib_lines, lines);\n\t}\n\tcatch (runtime_error & ex) {\n\t\tcout << ex.what() << endl;\n\t}\n}",
            "print('''def test_loop(n):\n\tfor i in range(n):\n\t\tprint(131 + i * 2)\n\ndef test_condition(c):\n\tif c:\n\t\tprint(\"right\")\n\telse:\n\t\tprint(\"no\")\n\ntest_loop(10)\ntest_condition(True)''')",
            1585713600,
            1585713600
        ],
        [
            "16.5 (C++)",
            "Please modify the simple Python compiler as follows:\n<ul>\n<li>Combine all CPP file into a single file</li>\n<li>Input from STDIO instead of from a Python file</li>\n<li>Load library from an internal string instead of from \"lib/builtins.py\"</li>\n</ul>\n\n<b>EXAMPLE INPUT</b>\n<pre>\ndef test_loop(n):\n\tfor i in range(n):\n\t\tprint(1 + i)\n\ndef test_condition(c):\n\tif c and True:\n\t\tprint(\"yes\")\n\telse:\n\t\tprint(\"no\")\n\ntest_loop(10)\ntest_condition(True)\n</pre>\n\n<b>EXAMPLE OUTPUT</b>\n<pre>\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nyes\n</pre>",
            "#include \"source.cpp\"",
            "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <stdexcept>\nusing namespace std;\n\n#include <cstring>\n\nint operator % (const string & text, int max) {\n\tint code = 0;\n\tfor (int i = 0; i < text.size(); ++ i) {\n\t\tint code1 = text[i];\n\t\tcode1 = code1 << (i * 8 % 24);\n\t\tcode = code ^ code1;\n\t}\n\treturn code % max;\n}\n\nclass NoSuchKeyException {};\n\ntemplate <typename K, typename V>\nclass HashTable\n{\nprivate:\n\t\t\n\tclass Entry\n\t{\n\tpublic:\n\t\tK key;\n\t\tV value;\n\t\tbool isInUse;\n\t\t\n\t\tEntry() {\n\t\t\tisInUse = false;\n\t\t}\n\t};\n\t\n\tEntry * entries;\n\t\n\tint capacity;\n\tint count;\n\t\n\tvoid initialize(int capacity2) {\n\t\tcount = 0;\n\t\tcapacity = capacity2;\n\t\tentries = new Entry[capacity];\n\t}\n\t\n\tvoid assign(const HashTable & map2) {\n\t\tcount = map2.count;\n\t\tcapacity = map2.capacity;\n\t\tentries = new Entry[capacity];\n\t\tfor (int i = 0; i < capacity; ++ i) {\n\t\t\tentries[i] = map2.entries[i];\n\t\t}\n\t}\n\t\npublic:\n\t\n\tHashTable() {\n\t\tinitialize(2);\n\t}\n\t\n\t~HashTable() {\n\t\tdelete [] entries;\n\t}\n\t\n\tHashTable(const HashTable & map2) {\n\t\tassign(map2);\n\t}\n\t\n\tHashTable & operator = (const HashTable & map2) {\n\t\tdelete [] entries;\n\t\tassign(map2);\n\t\treturn (*this);\n\t}\n\t\n\tvoid clear() {\n\t\tdelete [] entries;\n\t\tinitialize(2);\n\t}\n\t\nprivate:\n\t\n\tint hashIndex(const K & key) const {\n\t\treturn key % capacity;\n\t}\n\t\n\tint find(const K & key) const {\n\t\tint index = hashIndex(key);\n\t\twhile (true) {\n\t\t\tif (! entries[index].isInUse) {\n\t\t\t\treturn index;\n\t\t\t}\n\t\t\tif (entries[index].key == key) {\n\t\t\t\treturn index;\n\t\t\t}\n\t\t\tindex = (index + 1) % capacity;\n\t\t}\n\t}\n\t\n\tvoid resize(int capacity2) {\n\t\tEntry * entries0 = entries;\n\t\tint capacity0 = capacity;\n\t\tinitialize(capacity2);\n\t\tfor (int i = 0; i < capacity0; ++ i) {\n\t\t\tif (entries0[i].isInUse) {\n\t\t\t\tput(entries0[i].key, entries0[i].value);\n\t\t\t}\n\t\t}\n\t\tdelete [] entries0;\n\t}\n\t\npublic:\n\t\n\tvoid put(const K & key, const V & value) {\n\t\tint index = find(key);\n\t\tentries[index].value = value;\n\t\tif (entries[index].isInUse) return;\n\t\t\n\t\tentries[index].isInUse = true;\n\t\tentries[index].key = key;\n\t\t\n\t\t++ count;\n\t\tif (count > capacity / 2) {\n\t\t\tresize(capacity * 2);\n\t\t}\n\t}\n\t\n\tV get(const K & key) const {\n\t\tint index = find(key);\n\t\tif (! entries[index].isInUse) {\n\t\t\tthrow NoSuchKeyException();\n\t\t}\n\t\treturn entries[index].value;\n\t}\n\t\n\tbool remove(const K & key) {\n\t\tint index = find(key);\n\t\tif (! entries[index].isInUse) return false;\n\t\tfillNotInUseEntry(index);\n\t\t\n\t\t-- count;\n\t\tif (count < capacity / 4) {\n\t\t\tresize(capacity / 2);\n\t\t}\n\t\treturn true;\n\t}\n\t\nprivate:\n\t\n\tvoid fillNotInUseEntry(int index) {\n\t\tint next = index;\n\t\twhile (true) {\n\t\t\tnext = (next + 1) % capacity;\n\t\t\tif (! entries[next].isInUse) {\n\t\t\t\tentries[index].isInUse = false;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint index0 = hashIndex(entries[next].key);\n\t\t\tif (index < next) {\n\t\t\t\tif (index0 > index &&\n\t\t\t\t\tindex0 <= next) continue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (index0 > index ||\n\t\t\t\t\tindex0 <= next) continue;\n\t\t\t}\n\t\t\tentries[index] = entries[next];\n\t\t\tindex = next;\n\t\t}\n\t}\n\t\npublic:\n\t\n\tbool containsKey(const K & key) const {\n\t\tint index = find(key);\n\t\treturn (entries[index].isInUse);\n\t}\n\t\n\tint size() const {\n\t\treturn count;\n\t}\n\n\tvector<K> getKeys() const {\n\t\tvector<K> vec;\n\t\tfor (int i = 0; i < capacity; ++ i) {\n\t\t\tif (entries[i].isInUse) {\n\t\t\t\tvec.push_back(entries[i].key);\n\t\t\t}\n\t\t}\n\t\treturn vec;\n\t}\n\t\n};\n\n////////////////////////////////////////////////////////////////////////////////\n\nstruct Token\n{\n\tint line;\n\tint pos;\n\tstring type;\n\tstring text;\n};\n\nint operator % (const Token & t, int base) {\n\treturn (t.line * 12347 + t.pos) % base;\n}\n\nbool operator == (const Token & t1, const Token & t2) {\n\treturn t1.line == t2.line && t1.pos == t2.pos;\n}\n\nostream & operator << (ostream & out, const Token & t) {\n\tout << t.line << '\\t' << t.pos << '\\t' << t.type << \"\\t\\\"\" << t.text << \"\\\"\";\n\treturn out;\n}\n\nvoid read_lines(istream & in, vector<string> & lines) {\n\tstring line;\n\twhile (getline(in, line)) {\n\t\tlines.push_back(line);\n\t}\n}\n\nToken make_token(int line, int pos, int len, const string & source, const string & type) {\n\tToken t;\n\tt.line = line;\n\tt.pos = pos;\n\tt.type = type;\n\tt.text = source.substr(pos, len);\n\treturn t;\n}\n\n////////////////////\n// RULES BEGIN\n\nToken find_indent(int line, const string & source) {\n\tint len = 0;\n\tfor (int i = 0; i < source.size(); ++ i) {\n\t\tif (source[i] == '\\t')\n\t\t\t++ len;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn make_token(line, 0, len, source, \"indent\");\n}\n\nToken find_blank(int line, const string & source, int start) {\n\tint len = 0;\n\tfor (int i = start; i < source.size(); ++ i) {\n\t\tif (source[i] == '\\t' || source[i] == ' ')\n\t\t\t++ len;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn make_token(line, start, len, source, \"blank\");\n}\n\nToken find_string(int line, const string & source, int start) {\n\tint len = 0;\n\tbool was_backslash = false;\n\tfor (int i = start; i < source.size(); ++ i) {\n\t\tchar c = source[i];\n\t\tif (i == start) {\n\t\t\tif (c == '\"') ++ len;\n\t\t\telse break;\n\t\t}\n\t\telse {\n\t\t\tif (was_backslash) {\n\t\t\t\tif (c == '\\\\' || c == '\\r' || c == '\\n' ||\n\t\t\t\t\tc == '\\t' || c == '\"')\n\t\t\t\t\t++ len;\n\t\t\t\telse break;\n\t\t\t\twas_backslash = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (c == '\"') {\n\t\t\t\t\t++ len;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t++ len;\n\t\t\t\twas_backslash = (c == '\\\\');\n\t\t\t}\n\t\t} \n\t}\n\treturn make_token(line, start, len, source, \"str\");\t\n}\n\nToken find_int(int line, const string & source, int start) {\n\tif (start < source.size()) {\n\t\tif (source[start] == '0' && (start + 1 == source.size() || (source[start + 1] < '0' || source[start + 1] > '9')))\n\t\t\treturn make_token(line, start, 1, source, \"int\");\n\t}\n\tint len = 0;\n\tfor (int i = start; i < source.size(); ++ i) {\n\t\tif ((i != start && source[i] >= '0' && source[i] <= '9' ) ||\n\t\t\t(source[i] >= '1' && source[i] <= '9'))\n\t\t\t++ len;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn make_token(line, start, len, source, \"int\");\t\n}\n\nToken find_id(int line, const string & source, int start) {\n\tint len = 0;\n\tfor (int i = start; i < source.size(); ++ i) {\n\t\tif ((i != start && source[i] >= '0' && source[i] <= '9') ||\n\t\t\t(source[i] >= 'A' && source[i] <= 'Z') ||\n\t\t\t(source[i] >= 'a' && source[i] <= 'z') ||\n\t\t\tsource[i] == '_')\n\t\t\t++ len;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn make_token(line, start, len, source, \"id\");\n}\n\nconst char *keywords[] = {\n\t\"class\", \"def\", \"if\", \"else\", \"for\", \"in\", \"return\", \"yield\", \"and\", \"or\", \"not\", \"pass\",\n\t\"True\", \"False\", \"None\",\n\t\"(\", \")\", \"[\", \"]\", \"{\", \"}\", \":\", \",\", \".\", \n\t\"==\", \">\", \"<\", \"<=\", \">=\", \"!=\", \"=\", \n\t\"+=\", \"-=\", \"*=\", \"/=\", \"//=\", \"%=\", \"&=\", \"^=\", \"|=\", \n\t\"+\", \"-\", \"**\", \"*\", \"//\", \"/\", \"%\", \"&\", \"^\", \"|\"\n};\n\nToken find_keyword(int line, const string & source, int start) {\n\tint keyword = -1;\n\tfor (int i = 0; i < sizeof(keywords) / sizeof(const char *); ++ i) {\n\t\tif (source.compare(start, strlen(keywords[i]), keywords[i]) == 0) {\n\t\t\tkeyword = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (keyword == -1)\n\t\treturn make_token(line, start, 0, source, \"\");\n\treturn make_token(line, start, strlen(keywords[keyword]), source, keywords[keyword]);\t\n}\n\nToken find_comment(int line, const string & source, int start) {\n\tint len = 0;\n\tfor (int i = start; i < source.size(); ++ i) {\n\t\tif (i != start || source[i] == '#')\n\t\t\t++ len;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn make_token(line, start, len, source, \"comment\");\n}\n\n////////////////////\n// RULES END\n\ntypedef Token (* find_function)(int, const string &, int);\n\nvoid add_tokens(HashTable<Token, Token> & tokens, int lineno, const string & line, find_function find, bool can_conflict) {\n\tint start = 0;\n\twhile (start < line.size()) {\n\t\tToken t = find(lineno, line, start);\n\t\tif (t.text.size() > 0) {\n\t\t\tif (can_conflict) {\n\t\t\t\tif (tokens.containsKey(t)) {\n\t\t\t\t\tToken old_t = tokens.get(t);\n\t\t\t\t\tif (old_t.text.size() < t.text.size())\n\t\t\t\t\t\ttokens.put(t, t);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttokens.put(t, t);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (tokens.containsKey(t)) {\n\t\t\t\t\tToken old_t = tokens.get(t);\n\t\t\t\t\tstringstream ss;\n\t\t\t\t\tss << \"Conflicting tokens:\" << endl;\n\t\t\t\t\tss << old_t << endl;\n\t\t\t\t\tss << t << endl;\n\t\t\t\t\tthrow runtime_error(ss.str());\n\t\t\t\t}\n\t\t\t\ttokens.put(t, t);\n\t\t\t}\n\t\t\tstart += t.text.size();\n\t\t}\n\t\telse\n\t\t\t++ start;\n\t}\n}\n\nvoid get_tokens(vector<string> & lines, vector<vector<Token> > & tokens) {\n\tHashTable<Token, Token> all_tokens;\n\tfor (int i = 0; i < lines.size(); ++ i) {\n\t\tToken indent = find_indent(i, lines[i]);\n\t\tif (indent.text.size() > 0)\n\t\t\tall_tokens.put(indent, indent);\n\t\tadd_tokens(all_tokens, i, lines[i], find_string, false);\n\t\tadd_tokens(all_tokens, i, lines[i], find_int, false);\n\t\tadd_tokens(all_tokens, i, lines[i], find_comment, false);\n\t\tadd_tokens(all_tokens, i, lines[i], find_keyword, false);\n\t\tadd_tokens(all_tokens, i, lines[i], find_id, true);\n\t\tadd_tokens(all_tokens, i, lines[i], find_blank, true);\n\t\t// TODO: add more lexical matching functions\n\t}\n\tToken index;\n\tfor (int i = 0; i < lines.size(); ++ i) {\n\t\ttokens.push_back(vector<Token>());\n\t\tindex.line = i;\n\t\tindex.pos = 0;\n\t\twhile (index.pos < lines[i].size()) {\n\t\t\tif (! all_tokens.containsKey(index)) {\n\t\t\t\tstringstream ss;\n\t\t\t\tss << \"Lexical error at line #\" << (index.line + 1) << \" char #\" << index.pos;\n\t\t\t\tthrow runtime_error(ss.str());\n\t\t\t}\n\t\t\tToken t = all_tokens.get(index);\n\t\t\tif (t.type != \"blank\")\n\t\t\t\ttokens[i].push_back(t);\n\t\t\tindex.pos += t.text.size();\n\t\t}\n\t}\n} \n\n////////////////////////////////////////////////////////////////////////////////\n\nstruct Node\n{\n\tint index;\n\tint span;\n\tstring type;\n\tvector<Node> children; // for non-terminal\n\tToken token; // for terminal, as \"indent\" for non-terminal\n};\n\nbool operator == (const Node & n1, const Node & n2) {\n\treturn n1.index == n2.index && n1.span == n2.span && n1.type == n2.type;\n}\n\nstring to_tree_text(string text) {\n\tfor (int i = 0; i < text.size(); ++ i)\n\t\tif (text[i] == ' ') text[i] = '_';\n\tif (text == \"(\") text = \"-LRB-\";\n\tif (text == \")\") text = \"-RRB-\";\n\treturn text;\n}\n\nvoid print_node(ostream & out, const Node & node, int indent=0) {\n\t// for (int i = 0; i < indent; ++ i) out << '\\t';\n\tif (node.children.size() == 0) {\n\t\tout << \"( \" << to_tree_text(node.type) << ' ' << to_tree_text(node.token.text) << \" )\";\n\t}\n\telse {\n\t\t// out << node.type << \"\\tindex=\" << node.index << \"\\tspan=\" << node.span << endl;\n\t\tout << \"( \" << to_tree_text(node.type) << \" \";\n\t\tfor (int i = 0; i < node.children.size(); ++ i) {\n\t\t\tprint_node(out, node.children[i], indent + 1);\n\t\t}\n\t\tout << \" )\";\n\t}\n}\n\nostream & operator << (ostream & out, const Node & node) {\n\tprint_node(out, node, 0);\n\treturn out;\n}\n\n////////////////////\n// RULES BEGIN\n\nvoid make_node(const vector<Node> & node_list, vector<Node> & matched, const string & type, int len) {\n\tif (node_list.size() != len) return;\n\tNode node;\n\tnode.type = type;\n\tfor (int i = 0; i < len; ++ i)\n\t\tnode.children.push_back(node_list[i]);\n\tmatched.push_back(node);\n}\n\nvoid match_function_def(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() < 5) return;\n\tif (node_list[0].type != \"def\") return;\n\tif (node_list[1].type != \"id\") return;\n\tif (node_list[2].type != \"(\") return;\n\tint index = 3;\n\twhile (node_list[index].type == \"id\") {\n\t\t++ index;\n\t\tif (node_list.size() > index && node_list[index].type == \",\") {\n\t\t\t++ index;\n\t\t\tif (node_list.size() <= index || node_list[index].type != \"id\") return;\n\t\t}\n\t\telse break;\n\t}\n\tif (node_list.size() <= index || node_list[index].type != \")\") return;\n\t++ index;\n\tif (node_list.size() <= index || node_list[index].type != \":\") return;\n\t++ index;\n\tmake_node(node_list, matched, \"function_def\", index);\n}\n\nvoid match_expression(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() == 1) {\n\t\tif (node_list[0].type == \"function_call\" ||\n\t\t\tnode_list[0].type == \"str\" ||\n\t\t\tnode_list[0].type == \"id\" ||\n\t\t\tnode_list[0].type == \"int\" ||\n\t\t\tnode_list[0].type == \"None\" ||\n\t\t\tnode_list[0].type == \"True\" ||\n\t\t\tnode_list[0].type == \"False\")\n\t\t{\n\t\t\tmake_node(node_list, matched, \"expression1\", 1); // term\n\t\t}\n\t\telse if (node_list[0].type == \"expression1\") {\n\t\t\tmake_node(node_list, matched, \"expression2\", 1); // factor\n\t\t}\n\t\telse if (node_list[0].type == \"expression2\") {\n\t\t\tmake_node(node_list, matched, \"expression3\", 1); // exp\n\t\t}\n\t\telse if (node_list[0].type == \"expression3\") {\n\t\t\tmake_node(node_list, matched, \"expression4\", 1); // cmp\n\t\t}\n\t\telse if (node_list[0].type == \"expression4\") {\n\t\t\tmake_node(node_list, matched, \"expression5\", 1); // and\n\t\t}\n\t\telse if (node_list[0].type == \"expression5\") {\n\t\t\tmake_node(node_list, matched, \"expression\", 1); // or\n\t\t}\n\t}\n\tif (node_list.size() == 3) {\n\t\tif (node_list[0].type == \"(\" && node_list[1].type == \"expression\" && node_list[2].type == \")\") {\n\t\t\tmake_node(node_list, matched, \"expression1\", 3); // term\n\t\t}\n\t\telse if ((node_list[0].type == \"expression1\" || node_list[0].type == \"expression2L\") && node_list[1].type == \"operator_mul\" && node_list[2].type == \"expression1\") {\n\t\t\tmake_node(node_list, matched, \"expression2\", 3); // factor\n\t\t\tmake_node(node_list, matched, \"expression2L\", 3);\n\t\t}\n\t\telse if ((node_list[0].type == \"expression2\" || node_list[0].type == \"expression3L\") && node_list[1].type == \"operator_add\" && node_list[2].type == \"expression2\") {\n\t\t\tmake_node(node_list, matched, \"expression3\", 3); // exp\n\t\t\tmake_node(node_list, matched, \"expression3L\", 3);\n\t\t}\n\t\telse if ((node_list[0].type == \"expression3\" || node_list[0].type == \"expression4L\") && node_list[1].type == \"operator_cmp\" && node_list[2].type == \"expression3\") {\n\t\t\tmake_node(node_list, matched, \"expression4\", 3); // cmp\n\t\t\tmake_node(node_list, matched, \"expression4L\", 3);\n\t\t}\n\t\telse if ((node_list[0].type == \"expression4\" || node_list[0].type == \"expression5L\") && node_list[1].type == \"operator_and\" && node_list[2].type == \"expression4\") {\n\t\t\tmake_node(node_list, matched, \"expression5\", 3); // and\n\t\t\tmake_node(node_list, matched, \"expression5L\", 3);\n\t\t}\n\t\telse if ((node_list[0].type == \"expression5\" || node_list[0].type == \"expression6L\") && node_list[1].type == \"operator_or\" && node_list[2].type == \"expression5\") {\n\t\t\tmake_node(node_list, matched, \"expression\", 3); // and\n\t\t\tmake_node(node_list, matched, \"expression6L\", 3);\n\t\t}\n\t}\n}\n\nvoid match_function_call(const vector<Node> & node_list, vector<Node> & matched, int start=0) {\n\tif (node_list.size() < 4) return;\n\tif (node_list[0].type != \"id\") return;\n\tif (node_list[1].type != \"(\") return;\n\tint index = 2;\n\twhile (node_list[index].type == \"expression\") {\n\t\t++ index;\n\t\tif (node_list.size() > index && node_list[index].type == \",\") {\n\t\t\t++ index;\n\t\t\tif (node_list.size() <= index || node_list[index].type != \"expression\") return;\n\t\t}\n\t\telse break;\n\t}\n\tif (node_list.size() <= index || node_list[index].type != \")\") return;\n\t++ index;\n\tmake_node(node_list, matched, \"function_call\", index);\n}\n\nvoid match_for(const vector<Node> & node_list, vector<Node> & matched, int start=0) {\n\tif (node_list.size() != 5) return;\n\tif (node_list[0].type != \"for\") return;\n\tif (node_list[1].type != \"id\") return;\n\tif (node_list[2].type != \"in\") return;\n\tif (node_list[3].type != \"expression\") return;\n\tif (node_list[4].type != \":\") return;\n\tmake_node(node_list, matched, \"for_statement\", 5);\n}\n\nvoid match_if(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() != 3) return;\n\tif (node_list[0].type != \"if\") return;\n\tif (node_list[1].type != \"expression\") return;\n\tif (node_list[2].type != \":\") return;\n\tmake_node(node_list, matched, \"if_statement\", 3);\n}\n\nvoid match_else(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() != 2) return;\n\tif (node_list[0].type != \"else\") return;\n\tif (node_list[1].type != \":\") return;\n\tmake_node(node_list, matched, \"else_statement\", 2);\n}\n\nvoid match_operator(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() != 1) return;\n\tif (node_list[0].type == \"+\" || node_list[0].type == \"-\") {\n\t\tmake_node(node_list, matched, \"operator_add\", 1);\n\t}\n\telse if (node_list[0].type == \"*\" || node_list[0].type == \"/\" || node_list[0].type == \"%\") {\n\t\tmake_node(node_list, matched, \"operator_mul\", 1);\n\t}\n\telse if (node_list[0].type == \"==\" || node_list[0].type == \">\" || node_list[0].type == \"<\" \n\t\t || node_list[0].type == \">=\" || node_list[0].type == \"<=\" || node_list[0].type == \"!=\") {\n\t\tmake_node(node_list, matched, \"operator_cmp\", 1);\n\t}\n\telse if (node_list[0].type == \"and\") {\n\t\tmake_node(node_list, matched, \"operator_and\", 1);\n\t}\n\telse if (node_list[0].type == \"or\") {\n\t\tmake_node(node_list, matched, \"operator_or\", 1);\n\t}\n}\n\nvoid match_assign(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() != 3) return;\n\tif (node_list[0].type != \"id\") return;\n\tif (node_list[1].type != \"=\") return;\n\tif (node_list[2].type != \"expression\") return;\n\tmake_node(node_list, matched, \"assign_statement\", 3);\n}\n\nvoid match_yield(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() != 2) return;\n\tif (node_list[0].type != \"yield\") return;\n\tif (node_list[1].type != \"expression\") return;\n\tmake_node(node_list, matched, \"yield_statement\", 2);\n}\n\nvoid match_return(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() == 1) {\n\t\tif (node_list[0].type != \"return\") return;\n\t\tmake_node(node_list, matched, \"return_statement\", 1);\n\t}\n\telse if (node_list.size() == 2) {\n\t\tif (node_list[0].type != \"return\") return;\n\t\tif (node_list[1].type != \"expression\") return;\n\t\tmake_node(node_list, matched, \"return_statement\", 2);\n\t}\n}\n\nvoid match_pass(const vector<Node> & node_list, vector<Node> & matched) {\n\tif (node_list.size() == 1) {\n\t\tif (node_list[0].type != \"pass\") return;\n\t\tmake_node(node_list, matched, \"pass_statement\", 1);\n\t}\n}\n\n////////////////////\n// RULES END\n\nvector<Node> check_rules(vector<Node> & node_list) {\n\tvector<Node> matched;\n\tmatch_function_def(node_list, matched);\n\tmatch_expression(node_list, matched);\n\tmatch_function_call(node_list, matched);\n\tmatch_for(node_list, matched);\n\tmatch_if(node_list, matched);\n\tmatch_else(node_list, matched);\n\tmatch_assign(node_list, matched);\n\tmatch_yield(node_list, matched);\n\tmatch_return(node_list, matched);\n\tmatch_operator(node_list, matched);\n\tmatch_pass(node_list, matched);\n\treturn matched;\n}\n\nvoid check_sequences(vector<vector<Node> > & nodes, vector<Node> & node_list, \n\tint index, vector<Node> & to_check) \n{\n\tNode last_node = node_list[node_list.size() - 1];\n\tint next_index = index + last_node.span;\n\t// cout << next_index << ' ' << nodes.size() << endl;\n\tif (next_index > nodes.size()) {\n\t\tthrow runtime_error(\"Internal error: incorrect next_index\");\n\t}\n\tvector<Node> matched = check_rules(node_list);\n\tfor (int i = 0; i < matched.size(); ++ i) {\n\t\tmatched[i].index = matched[i].children[0].index;\n\t\tmatched[i].span = 0;\n\t\tfor (int j = 0; j < matched[i].children.size(); ++ j)\n\t\t\tmatched[i].span += matched[i].children[j].span;\n\t\tfor (int j = 0; j < to_check.size(); ++ j) {\n\t\t\tif (to_check[j] == matched[i]) {\n\t\t\t\tstringstream ss;\n\t\t\t\tss << \"Internal error: repeated nodes:\" << endl;\n\t\t\t\tss << to_check[j] << endl;\n\t\t\t\tss << matched[i] << endl;\n\t\t\t\tthrow runtime_error(ss.str());\n\t\t\t}\n\t\t}\n\t\tto_check.push_back(matched[i]);\n\t}\n\t// for (int i = 0; i < matched.size(); ++ i) {\n\t// \tcout << matched[i] << endl;\n\t// }\n\tif (next_index == nodes.size()) return;\n\tfor (int i = 0; i < nodes[next_index].size(); ++ i) {\n\t\tNode node = nodes[next_index][i];\n\t\tnode_list.push_back(node);\n\t\tcheck_sequences(nodes, node_list, next_index, to_check);\n\t\tnode_list.pop_back();\n\t}\n}\n\nbool startswith(const string & text, const string & prefix) {\n\tint size = prefix.size();\n\tif (text.size() < size) return false;\n\tstring prefix2 = text.substr(0, size);\n\treturn prefix2 == prefix;\n}\n\nbool endswith(const string & text, const string & postfix) {\n\tint size = postfix.size();\n\tif (text.size() < size) return false;\n\tstring postfix2 = text.substr(text.size() - size, size);\n\treturn postfix2 == postfix;\n}\n\nNode parse_line(int lineno, vector<Token> & tokens) {\n\tvector<vector<Node> > nodes;\n\tvector<Node> to_check;\n\tint span = tokens.size();\n\tfor (int i = 0; i < tokens.size(); ++ i) {\n\t\tif (tokens[i].type == \"indent\") {\n\t\t\t-- span;\n\t\t\tcontinue;\n\t\t}\n\t\tNode node;\n\t\tnode.type = tokens[i].type;\n\t\tnode.index = nodes.size();\n\t\tnode.span = 1;\n\t\tnode.token = tokens[i];\n\t\tnodes.push_back(vector<Node>());\n\t\tto_check.push_back(node);\n\t}\n\twhile (to_check.size() > 0) {\n\t\tNode first = to_check[to_check.size() - 1];\n\t\t// cout << \"--->\" << '\\t' << first << endl;\n\t\tto_check.pop_back();\n\t\tvector<Node> node_list;\n\t\tnode_list.push_back(first);\n\t\tnodes[first.index].push_back(first);\n\t\tcheck_sequences(nodes, node_list, first.index, to_check);\n\t}\n\tint result = -1;\n\tfor (int i = 0; i < nodes[0].size(); ++ i) {\n\t\tif (nodes[0][i].span == span) \n\t\t\tresult = i;\n\t}\n\tif (result == -1) {\n\t\tstringstream ss;\n\t\tss << \"Syntax error in line: \" << (lineno + 1);\n\t\tthrow runtime_error(ss.str());\n\t}\n\treturn nodes[0][result];\n}\n\nstruct Line\n{\n\tint level;\n\tNode node;\n\tvector<Line> children;\n};\n\nvoid print_line(ostream & out, const Line & line, int indent=0) {\n\t// for (int i = 0; i < indent; ++ i) out << '\\t';\n\tif (line.children.size() == 0) {\n\t\t// out << line.node.type << '\\t' << line.node.token.text << endl;\n\t\tout << \"( \" << line.node.type << \"@\" << line.level << \" _ )\";\n\t}\n\telse {\n\t\tout << \"( \" << line.node.type << \"@\" << line.level << \" \";\n\t\tfor (int i = 0; i < line.children.size(); ++ i) {\n\t\t\tprint_line(out, line.children[i], indent + 1);\n\t\t}\n\t\tout << \" )\";\n\t}\n}\n\nostream & operator << (ostream & out, const Line & line) {\n\tprint_line(out, line, 0);\n\treturn out;\n}\n\nvoid indent_error(const Token & indent) {\n\tstringstream ss;\n\tss << \"Inconsistent indentation at line: \" << indent.line;\n\tthrow runtime_error(ss.str());\n}\n\nvoid get_tree(vector<string> & lines, Line & tree) {\n\tvector<vector<Token> > tokens;\n\tvector<Node> nodes;\n\tvector<Token> indents;\n\tget_tokens(lines, tokens);\n\tfor (int i = 0; i < tokens.size(); ++ i) {\n\t\tif (tokens[i].size() > 0) {\n\t\t\tif (tokens[i][0].type == \"indent\")\n\t\t\t\tindents.push_back(tokens[i][0]);\n\t\t\telse\n\t\t\t\tindents.push_back(Token());\n\t\t\tnodes.push_back(parse_line(i, tokens[i]));\n\t\t}\n\t}\n\ttree.level = 0;\n\ttree.node.type = \"__main__\";\n\ttree.node.token.text = \"__main__\";\n\ttree.node.index = 0;\n\ttree.node.span = 0;\n\tvector<Line *> stack;\n\tvector<string> indent_stack;\n\tstack.push_back(&tree);\n\tindent_stack.push_back(\"\");\n\tfor (int i = 0; i < nodes.size(); ++ i) {\n\t\tstring last_indent = indent_stack[indent_stack.size() - 1];\n\t\tLine next;\n\t\tnext.node = nodes[i];\n\t\tLine * parent = stack[stack.size() - 1];\n\t\tif (indents[i].text == last_indent) {\n\t\t\tnext.level = parent->level + 1;\n\t\t\tparent->children.push_back(next);\n\t\t}\n\t\telse {\n\t\t\tif (startswith(indents[i].text, last_indent)) {\n\t\t\t\tindent_stack.push_back(indents[i].text);\n\t\t\t\tif (parent->children.size() == 0) indent_error(indents[i]);\n\t\t\t\tparent = &parent->children[parent->children.size() - 1];\n\t\t\t\tstack.push_back(parent);\n\t\t\t\tnext.level = parent->level + 1;\n\t\t\t\tparent->children.push_back(next);\n\t\t\t}\n\t\t\telse {\n\t\t\t\twhile (true) {\n\t\t\t\t\tif (indents[i].text == last_indent) {\n\t\t\t\t\t\tnext.level = parent->level + 1;\n\t\t\t\t\t\tparent->children.push_back(next);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (startswith(last_indent, indents[i].text)) {\n\t\t\t\t\t\tindent_stack.pop_back();\n\t\t\t\t\t\tlast_indent = indent_stack[indent_stack.size() - 1];\n\t\t\t\t\t\tstack.pop_back();\n\t\t\t\t\t\tif (stack.size() == 0) indent_error(indents[i]);\n\t\t\t\t\t\tparent = stack[stack.size() - 1];\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tindent_error(indents[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid print_nodes(ostream & out, const Line & line) {\n\tout << line.node << endl;\n\tif (line.children.size() == 0) return;\n\tfor (int i = 0; i < line.children.size(); ++ i) {\n\t\tprint_nodes(out, line.children[i]);\n\t}\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid optim_exp(Node & node) {\n\tif (node.children.size() == 1) {\n\t\tNode child = node.children[0];\n\t\tnode = child;\n\t}\n\telse if (node.children.size() == 3 && node.children[0].type == \"(\" && node.children[2].type == \")\") {\n\t\tNode child = node.children[1];\n\t\tnode = child;\n\t}\n\tif (startswith(node.type, \"expression\"))\n\t\tnode.type = \"expression\";\n}\n\nvoid optim(Node & node) {\n\tfor (int i = 0; i < node.children.size(); ++ i)\n\t\toptim(node.children[i]);\n\tif (startswith(node.type, \"expression\"))\n\t\toptim_exp(node);\n\tif (startswith(node.type, \"operator_\"))\n\t\tnode = node.children[0];\n}\n\nvoid optim(Line & line) {\n\toptim(line.node);\n\tfor (int i = 0; i < line.children.size(); ++ i) {\n\t\toptim(line.children[i]);\n\t}\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#define foreach(type, item, vec) for (vector<type>::iterator item=vec.begin(); item != vec.end(); ++ item)\n\nvoid assert_true(bool test, const string & err_msg) {\n\tif (! test) throw runtime_error(err_msg);\n}\n\n//////////\n// TYPES\n\nstruct Variable\n{\n\tstring type;\n\tvirtual void print() {\n\t\tcout << type;\n\t}\n\tvirtual Variable * copy() {\n\t\tstringstream ss;\n\t\tss << \"'\" << type << \".copy' is not implemented\";\n\t\tassert_true(false, ss.str());\n\t\treturn 0;\n\t}\n\tvirtual Variable * __eq__(Variable * op) {\n\t\tstringstream ss;\n\t\tss << \"'\" << type << \".__eq__' is not implemented\";\n\t\tassert_true(false, ss.str());\n\t\treturn 0;\n\t}\n};\n\nstruct Int : public Variable\n{\n\tint intValue;\n\tInt(int value) {\n\t\ttype = \"int\";\n\t\tintValue = value;\n\t}\n\tvoid print() {\n\t\tcout << intValue;\n\t}\n\tvirtual Variable * copy() {\n\t\treturn new Int(intValue);\n\t}\n\tVariable * __add__(Int * op) {\n\t\tInt * ret = (Int *)copy();\n\t\tret->intValue += op->intValue;\n\t\treturn ret;\n\t}\n\tVariable * __sub__(Int * op) {\n\t\tInt * ret = (Int *)copy();\n\t\tret->intValue -= op->intValue;\n\t\treturn ret;\n\t}\n\tVariable * __mul__(Int * op) {\n\t\tInt * ret = (Int *)copy();\n\t\tret->intValue *= op->intValue;\n\t\treturn ret;\n\t}\n\tVariable * __mod__(Int * op) {\n\t\tInt * ret = (Int *)copy();\n\t\tret->intValue = ret->intValue % op->intValue;\n\t\treturn ret;\n\t}\n\tVariable * __eq__(Variable * op) {\n\t\tInt * op2 = (Int *)op;\n\t\treturn new Int(intValue == op2->intValue);\n\t}\n};\n\nstruct Bool : public Variable\n{\n\tbool boolValue;\n\tBool(bool value) {\n\t\ttype = \"bool\";\n\t\tboolValue = value;\n\t}\n\tvoid print() {\n\t\tif (boolValue) cout << \"True\";\n\t\telse cout << \"False\";\n\t}\n\tvirtual Variable * copy() {\n\t\treturn new Bool(boolValue);\n\t}\n\tVariable * __and__(Bool * op) {\n\t\tBool * ret = (Bool *)copy();\n\t\tret->boolValue = ret->boolValue && op->boolValue;\n\t\treturn ret;\n\t}\n\tVariable * __or__(Bool * op) {\n\t\tBool * ret = (Bool *)copy();\n\t\tret->boolValue = ret->boolValue || op->boolValue;\n\t\treturn ret;\n\t}\n\tVariable * __eq__(Variable * op) {\n\t\tBool * op2 = (Bool *)op;\n\t\treturn new Bool(boolValue == op2->boolValue);\n\t}\n};\n\n\nstruct Str : public Variable\n{\n\tstring strValue;\n\tStr(string value) {\n\t\ttype = \"str\";\n\t\tstrValue = value;\n\t}\n\tvoid print() {\n\t\tbool was_backslash = false;\n\t\tfor (int i = 1; i < strValue.size() - 1; ++ i) {\n\t\t\tchar c = strValue[i];\n\t\t\tif (was_backslash) {\n\t\t\t\tstring err_msg = \"Unknown sequence '\\\\?'\";\n\t\t\t\tswitch (c) {\n\t\t\t\t\tcase '\\\\': cout << '\\\\'; break;\n\t\t\t\t\tcase '\\r': cout << '\\r'; break;\n\t\t\t\t\tcase '\\t': cout << '\\t'; break;\n\t\t\t\t\tcase '\\n': cout << '\\n'; break;\n\t\t\t\t\tcase '\"': cout << '\"'; break;\n\t\t\t\t\tdefault: err_msg[err_msg.size() - 2] = c; assert_true(false, err_msg);\n\t\t\t\t}\n\t\t\t\twas_backslash = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (c == '\\\\') was_backslash = true;\n\t\t\t\telse cout << c;\n\t\t\t}\n\t\t}\n\t}\n\tvirtual Variable * copy() {\n\t\treturn new Str(strValue);\n\t}\n};\n\nstruct Function : public Variable\n{\n\tLine * line;\n\tFunction(Line & value) {\n\t\ttype = \"function\";\n\t\tline = &value;\n\t}\n\tvoid print() {\n\t\tcout << type << '\\t';\n\t\tprint_node(cout, line->node);\n\t}\n};\n\nstruct Pointer : public Variable\n{\n\tvoid * pointer;\n\tPointer(void * value) {\n\t\ttype = \"pointer\";\n\t\tpointer = value;\n\t}\n};\n\nstruct Variables\n{\n\tHashTable<string, Variable*> map;\n\n\tvoid print() {\n\t\tvector<string> names = map.getKeys();\n\t\tforeach (string, name, names) {\n\t\t\tcout << *name << '\\t';\n\t\t\tmap.get(*name)->print();\n\t\t\tcout << endl;\n\t\t}\n\t}\n\n\tbool hasVariable(const string & name) {\n\t\treturn map.containsKey(name);\n\t}\n\n\tvoid assertVariable(const string & name) {\n\t\tstringstream ss;\n\t\tss << \"Variable '\" << name << \"' is undefined\"; \n\t\tassert_true(map.containsKey(name), ss.str());\t\t\n\t}\n\n\tvoid assertType(const string & name, const string & type) {\n\t\tstringstream ss;\n\t\tss << \"Require '\" << type << \"', got '\" << map.get(name)->type << \"' \"; \n\t\tassert_true(map.get(name)->type == type, ss.str());\t\t\n\t}\n\n\tstring getType(const string & name) {\n\t\tassertVariable(name);\n\t\treturn map.get(name)->type;\n\t}\n\n\tvoid delVariable(const string & name, bool del=true) {\n\t\tassertVariable(name);\n\t\tif (del) delete map.get(name);\n\t\tmap.remove(name);\n\t}\n\n\tvoid setVariable(const string & name, Variable * v) {\n\t\tif (map.containsKey(name))\n\t\t\tdelete map.get(name);\n\t\tmap.put(name, v);\n\t}\n\n\tVariable * getVariable(const string & name) {\n\t\tassertVariable(name);\n\t\treturn map.get(name);\n\t}\n\n\tvoid releaseAll() {\n\t\tvector<string> names = map.getKeys();\n\t\tforeach (string, name, names)\n\t\t\tdelVariable(*name);\n\t}\n\n};\n\nstruct Context\n{\n\tstring owner;\n\tVariables & global_variables;\n\tVariables & local_variables;\n\tHashTable<string, int> global_used;\n\tvector<int> lines_running;\n\n\tContext(const string & owner_, Variables & global_variables_, Variables & local_variables_) : \n\t\towner(owner_), global_variables(global_variables_), local_variables(local_variables_) {}\n\n\tbool is_global(const string & name, bool is_assign) {\n\t\tif (local_variables.hasVariable(name)) return false;\n\t\tif (global_used.containsKey(name)) return true;\n\t\tif (is_assign) return false;\n\t\tglobal_variables.assertVariable(name);\n\t\tglobal_used.put(name, 0);\n\t\treturn true;\n\t}\n\n\tVariable * getVariable(const string & name) {\n\t\tif (is_global(name, false))\n\t\t\treturn global_variables.getVariable(name);\n\t\telse\n\t\t\treturn local_variables.getVariable(name);\n\t}\n\n\tvoid setVariable(const string & name, Variable * v) {\n\t\tif (is_global(name, true))\n\t\t\treturn global_variables.setVariable(name, v);\n\t\telse\n\t\t\treturn local_variables.setVariable(name, v);\n\t}\n\n};\n\n////////////////////\n// FUNCTIONS\n\nvoid run_builtin_range(Context & context) {\n\tVariable * v = context.local_variables.getVariable(\"n\");\n\tassert_true(v->type == \"int\", \"'range' requires a single 'int' argument\");\n\tint n = ((Int *)v)->intValue;\n\tint level = 2;\n\tif (context.lines_running.size() == level)\n\t\tcontext.lines_running.push_back(0);\n\telse\n\t\t++ context.lines_running[level];\n\tif (context.lines_running[level] >= n) return;\n\tcontext.local_variables.setVariable(\"$ret\", new Int(context.lines_running[level]));\n}\n\nint max_print_calls = 1000;\n\nvoid run_builtin_print(Context & context) {\n\tassert_true(-- max_print_calls > 0, \"Exceeds max_print_calls == 100\");\n\tVariable * v = context.local_variables.getVariable(\"n\");\n\tif (v == 0) cout << \"None\";\n\telse v->print();\n\tcout << endl;\n}\n\nvoid run_builtin(const string & function_name, Context & context) {\n\tif (function_name == \"range\") {\n\t\trun_builtin_range(context);\n\t}\n\telse if (function_name == \"print\") {\n\t\trun_builtin_print(context);\n\t}\n\telse {\n\t\tstringstream ss;\n\t\tss << \"Unknow builtin: \" << function_name << endl;\n\t\tassert_true(false, ss.str());\n\t}\n}\n\nvoid register_builtins(vector<string> & lines, Line & tree, Variables & global_variables) {\n\tget_tree(lines, tree);\n\toptim(tree);\n\tforeach (Line, line, tree.children) {\n\t\tstringstream ss;\n\t\tss << \"Invalid line in 'builtins.py: \" << line->node.type << endl;\n\t\tassert_true(line->node.type == \"function_def\", ss.str());\n\t\tline->node.type = \"builtin\";\n\t\tstring function_name = line->node.children[1].token.text;\n\t\tglobal_variables.setVariable(function_name, new Function(*line));\n\t}\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid run_lines(vector<Line> & lines, Context & context);\nvoid run_line(Line & line, Context & context);\nVariable * run_exp(Node & exp, Context & context);\n\nLine & get_function(const string & function_name, Context & context) {\n\tVariable * v = context.getVariable(function_name);\n\tstringstream ss;\n\tss << \"Not a function: \" << function_name;\n\tassert_true(v->type == \"function\" || v->type == \"builtin\", ss.str());\n\tFunction * func_var = (Function *)v;\n\treturn *(func_var->line);\n}\n\nvoid init_function_parameters(Node & func_node, Context & callee_context, Node & call_node, Context & caller_context) {\n\tint num_args = call_node.children.size() - 3;\n\tint num_params = func_node.children.size() - 5;\n\tstringstream ss;\n\tss << \"Function '\" << call_node.children[0].token.text << \"' arguments not agree\" << endl;\n\tss << \"\\tCaller gives \" << num_args << \" at line: \" << (func_node.children[0].token.line + 1) << endl;\n\tss << \"\\tCallee requires \" << num_params << \" at line: \" << (call_node.children[0].token.line + 1) << endl;\n\tassert_true(num_args == num_params, ss.str());\n\tfor (int i = 0; i < num_params; ++ i) {\n\t\tNode & arg_exp = call_node.children[2 + i];\n\t\tVariable * arg_value = run_exp(arg_exp, caller_context);\n\t\tstring parameter_name = func_node.children[3 + i].token.text;\n\t\tcallee_context.local_variables.setVariable(parameter_name, arg_value);\n\t}\t\n}\n\nVariable * run_function(Node & call_node, Context & context) {\n\tstring function_name = call_node.children[0].token.text;\n\tLine & func_line = get_function(function_name, context);\n\tVariables func_local_variables;\n\tContext func_context(function_name, context.global_variables, func_local_variables);\n\tinit_function_parameters(func_line.node, func_context, call_node, context);\n\t// func_local_variables.print();\n\tif (func_line.node.type == \"builtin\" && func_line.children.size() == 1 && func_line.children[0].node.type == \"pass_statement\")\n\t\trun_builtin(function_name, func_context);\n\telse {\n\t\twhile (func_context.lines_running.size() <= func_line.level)\n\t\t\tfunc_context.lines_running.push_back(-100);\n\t\trun_lines(func_line.children, func_context);\n\t}\n\tVariable * ret = 0;\n\tif (func_local_variables.hasVariable(\"$ret\")) {\n\t\tret = func_local_variables.getVariable(\"$ret\");\n\t\tfunc_local_variables.delVariable(\"$ret\", false);\n\t}\n\tfunc_local_variables.releaseAll();\n\treturn ret;\n}\n\nvoid pass_result(Context & from, Context & to, const string & name) {\n\tVariable * ret = from.local_variables.getVariable(\"$ret\");\n\tfrom.local_variables.delVariable(\"$ret\", false);\n\tto.local_variables.setVariable(name, ret);\n}\n\nContext * init_generator_context(Context & context, Line & gen_def_line, Node & gen_call_node) {\n\tVariables * local_variables = new Variables();\n\tstring gen_func_name = gen_call_node.children[0].token.text;\n\tContext * gen_context = new Context(gen_func_name, context.global_variables, *local_variables);\n\tinit_function_parameters(gen_def_line.node, *gen_context, gen_call_node, context);\n\tcontext.local_variables.setVariable(\"$gen\", new Pointer(gen_context));\n\twhile (gen_context->lines_running.size() <= gen_def_line.level)\n\t\tgen_context->lines_running.push_back(-100);\n\treturn gen_context;\n}\n\nvoid release_generator_context(Context & context) {\n\tPointer * v = (Pointer *)context.local_variables.getVariable(\"$gen\");\n\tContext * gen = (Context *)v->pointer;\n\tcontext.local_variables.delVariable(\"$gen\");\n\tgen->local_variables.releaseAll();\n\tdelete &(gen->local_variables);\n\tdelete gen;\n}\n\nvoid print_int_vector(vector<int> & vec) {\n\tfor (int i = 0; i < vec.size(); ++ i) cout << \" \" << vec[i];\n\tcout << endl;\n}\n\nvoid run_for_statement(Line & for_line, Context & context) {\n\tstring loop_variable_name = for_line.node.children[1].token.text;\n\tNode & gen_node = for_line.node.children[3];\n\tif (gen_node.type == \"function_call\") {\n\t\tstring gen_func_name = gen_node.children[0].token.text;\n\t\tLine & gen_def_line = get_function(gen_func_name, context);\n\t\tContext * gen_context = 0;\n\t\tif (context.local_variables.hasVariable(\"$gen\")) {\n\t\t\tPointer * gen = (Pointer *)context.local_variables.getVariable(\"$gen\");\n\t\t\tgen_context = (Context *)(gen->pointer);\n\t\t\tstringstream ss;\n\t\t\tss << \"Inconsistent generator context: required '\" << gen_func_name << \"', got '\" << gen_context->owner << \"'\";\n\t\t\tassert_true(gen_context->owner == gen_func_name, ss.str());\n\t\t}\n\t\telse \n\t\t\tgen_context = init_generator_context(context, gen_def_line, gen_node);\n\t\tbool done = false;\n\t\twhile (true) {\n\t\t\tif (gen_def_line.node.type == \"builtin\" && gen_def_line.children.size() == 1 && gen_def_line.children[0].node.type == \"pass_statement\")\n\t\t\t\trun_builtin(gen_func_name, *gen_context);\n\t\t\telse\n\t\t\t\trun_lines(gen_def_line.children, *gen_context);\n\t\t\tif (! gen_context->local_variables.hasVariable(\"$ret\")) {\n\t\t\t\tdone = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpass_result(*gen_context, context, loop_variable_name);\n\t\t\trun_lines(for_line.children, context);\n\t\t\tif (context.local_variables.hasVariable(\"$ret\")) break;\n\t\t}\n\t\tif (done) release_generator_context(context);\n\t}\n\telse {\n\t\tstringstream ss;\n\t\tss << \"Unknow generator type: \" << gen_node.type;\n\t\tassert_true(false, ss.str());\n\t}\n}\n\nVariable * run_id(Node & exp, Context & context) {\n\tstring name = exp.token.text;\n\tif (context.local_variables.hasVariable(name))\n\t\treturn context.local_variables.getVariable(name)->copy();\n\tif (context.global_variables.hasVariable(name))\n\t\treturn context.global_variables.getVariable(name)->copy();\n\tstringstream ss;\n\tss << \"Undefined variable: \" << name << endl;\n\tassert_true(false, ss.str());\n\treturn 0;\n}\n\nvoid check_op_type(const string & op, const string & required_type, const string & type) {\n\tstringstream ss;\n\tss << \"The operand of \" << op << \" must be '\" << required_type <<\"' instead of '\" << type << \"'\" << endl;\n\tassert_true(required_type == type, ss.str());\n}\n\nVariable * run_expression(Node & exp, Context & context) {\n\tstring op = \"?\";\n\tif (exp.children.size() == 3) {\n\t\top = exp.children[1].token.text;\n\t\tVariable * left = run_exp(exp.children[0], context);\n\t\tVariable * right = run_exp(exp.children[2], context);\n\t\tif (op == \"+\") {\n\t\t\tcheck_op_type(op, \"int\", left->type);\n\t\t\tcheck_op_type(op, \"int\", right->type);\n\t\t\treturn ((Int *)left)->__add__((Int *)right);\n\t\t}\n\t\telse if (op == \"-\") {\n\t\t\tcheck_op_type(op, \"int\", left->type);\n\t\t\tcheck_op_type(op, \"int\", right->type);\n\t\t\treturn ((Int *)left)->__sub__((Int *)right);\n\t\t}\n\t\telse if (op == \"*\") {\n\t\t\tcheck_op_type(op, \"int\", left->type);\n\t\t\tcheck_op_type(op, \"int\", right->type);\n\t\t\treturn ((Int *)left)->__mul__((Int *)right);\n\t\t}\n\t\telse if (op == \"%\") {\n\t\t\tcheck_op_type(op, \"int\", left->type);\n\t\t\tcheck_op_type(op, \"int\", right->type);\n\t\t\treturn ((Int *)left)->__mod__((Int *)right);\n\t\t}\n\t\telse if (op == \"and\") {\n\t\t\tcheck_op_type(op, \"bool\", left->type);\n\t\t\tcheck_op_type(op, \"bool\", right->type);\n\t\t\treturn ((Bool *)left)->__and__((Bool *)right);\n\t\t}\n\t\telse if (op == \"or\") {\n\t\t\tcheck_op_type(op, \"bool\", left->type);\n\t\t\tcheck_op_type(op, \"bool\", right->type);\n\t\t\treturn ((Bool *)left)->__or__((Bool *)right);\n\t\t}\n\t\telse if (op == \"==\") {\n\t\t\tcheck_op_type(op, left->type, right->type);\n\t\t\treturn left->__eq__(right);\n\t\t}\n\t}\n\telse if (exp.children.size() == 2) {\n\t\top = exp.children[0].token.text;\n\t}\n\tstringstream ss;\n\tss << \"Undefined operator: \" << op << endl;\n\tassert_true(false, ss.str());\n\treturn 0;\n}\n\nVariable * run_exp(Node & exp, Context & context) {\n\tif (exp.type == \"int\") {\n\t\tstringstream ss(exp.token.text);\n\t\tint intValue;\n\t\tss >> intValue;\n\t\treturn new Int(intValue);\n\t}\n\telse if (exp.type == \"str\") {\n\t\treturn new Str(exp.token.text);\n\t}\n\telse if (exp.type == \"True\") {\n\t\treturn new Bool(true);\n\t}\n\telse if (exp.type == \"False\") {\n\t\treturn new Bool(false);\n\t}\n\telse if (exp.type == \"id\") {\n\t\treturn run_id(exp, context);\n\t}\n\telse if (exp.type == \"None\") {\n\t\treturn 0;\n\t}\n\telse if (exp.type == \"function_call\") {\n\t\treturn run_function(exp, context);\n\t}\n\telse if (exp.type == \"expression\") {\n\t\treturn run_expression(exp, context);\n\t}\n\telse {\n\t\tstringstream ss;\n\t\tss << \"Unknow expression type: \" << exp.type << endl << exp << endl;\n\t\tassert_true(false, ss.str());\n\t}\n\treturn 0;\n}\n\nvoid run_yield_statement(Line & line, Context & context) {\n\tVariable * v = run_exp(line.node.children[1], context);\n\tassert_true(v != 0, \"\");\n\tcontext.local_variables.setVariable(\"$ret\", v);\n\t++ context.lines_running[line.level];\n}\n\nvoid run_return_statement(Line & line, Context & context) {\n\tVariable * v = run_exp(line.node.children[1], context);\n\tcontext.local_variables.setVariable(\"$ret\", v);\n\tcontext.lines_running.clear();\n}\n\nvoid run_assign_statement(Line & line, Context & context) {\n\tstring variable_name = line.node.children[0].token.text;\n\tVariable * v = run_exp(line.node.children[2], context);\n\tcontext.setVariable(variable_name, v);\n}\n\nbool is_true(Variable * v) {\n\tif (v == 0) {\n\t\treturn false;\n\t}\n\tif (v->type == \"bool\") {\n\t\treturn ((Bool *)v)->boolValue;\n\t}\n\telse if (v->type == \"int\") {\n\t\treturn ((Int *)v)->intValue != 0;\n\t}\n\tstringstream ss;\n\tss << \"Unknown type for condition: \" << v->type;\n\tassert_true(false, ss.str());\n\treturn false;\n}\n\nvoid run_if_statement(Line & line, Context & context) {\n\tif (context.lines_running.size() > line.level + 1) {\n\t\trun_lines(line.children, context);\n\t\treturn;\n\t}\n\tVariable * v = run_exp(line.node.children[1], context);\n\tstringstream ss;\n\tss << \"$if\" << line.level;\n\tcontext.setVariable(ss.str(), v);\n\tif (is_true(v)) {\n\t\trun_lines(line.children, context);\n\t}\n}\n\nvoid run_else_statement(Line & line, Context & context) {\n\tif (context.lines_running.size() > line.level + 1) {\n\t\trun_lines(line.children, context);\n\t\treturn;\n\t}\n\tstringstream ss;\n\tss << \"$if\" << line.level;\n\tstring condition_name = ss.str();\n\tassert_true(context.local_variables.hasVariable(condition_name), \"Dangling else-statement\");\n\tVariable * v = context.local_variables.getVariable(condition_name);\n\tif (! is_true(v)) {\n\t\trun_lines(line.children, context);\n\t}\n\tcontext.local_variables.delVariable(condition_name);\n}\n\nvoid run_line(Line & line, Context & context) {\n\tif (line.node.type == \"comment\") {\n\t}\n\telse if (line.node.type == \"function_def\") {\n\t\tstring function_name = line.node.children[1].token.text;\n\t\tcontext.local_variables.setVariable(function_name, new Function(line));\n\t}\n\telse if (line.node.type == \"function_call\") {\n\t\trun_function(line.node, context);\n\t}\n\telse if (line.node.type == \"for_statement\") {\n\t\trun_for_statement(line, context);\n\t}\n\telse if (line.node.type == \"yield_statement\") {\n\t\trun_yield_statement(line, context);\n\t}\n\telse if (line.node.type == \"return_statement\") {\n\t\trun_return_statement(line, context);\n\t}\n\telse if (line.node.type == \"assign_statement\") {\n\t\trun_assign_statement(line, context);\n\t}\n\telse if (line.node.type == \"if_statement\") {\n\t\trun_if_statement(line, context);\n\t}\n\telse if (line.node.type == \"else_statement\") {\n\t\trun_else_statement(line, context);\n\t}\n\telse {\n\t\tstringstream ss;\n\t\tss << \"Unknow line type: \" << line.node.type;\n\t\tassert_true(false, ss.str());\n\t}\n}\n\nint get_def_line(Line & line) {\n\tNode * node = &(line.node);\n\twhile (node->children.size() > 0)\n\t\tnode = &(node->children[0]);\n\treturn node->token.line;\n}\n\nvoid run_lines(vector<Line> & lines, Context & context) {\n\tint level = lines[0].level;\n\tstringstream ss;\n\tss << \"Line: \" << get_def_line(lines[0]) <<\" Incorrect level state: \" << context.lines_running.size() << \", requires >= \" << level;\n\tassert_true(context.lines_running.size() >= level, ss.str());\n\tif (context.lines_running.size() == level) {\n\t\tcontext.lines_running.push_back(0);\n\t}\n\tstringstream ss2;\n\tss2 << \"Line: \" << get_def_line(lines[0]) <<\" Incorrect level step: \" << context.lines_running[level];\n\tassert_true(context.lines_running[level] >= 0, ss2.str());\n\twhile (context.lines_running[level] < lines.size()) {\n\t\trun_line(lines[context.lines_running[level]], context);\n\t\tif (context.local_variables.hasVariable(\"$ret\")) break;\n\t\t++ context.lines_running[level];\n\t}\n\tif (context.lines_running[level] == lines.size())\n\t\tcontext.lines_running.pop_back();\n}\n\nvoid run(vector<string> & lib_lines, vector<string> & lines) {\n\tVariables global_variables;\n\tLine builtins_tree;\n\tregister_builtins(lib_lines, builtins_tree, global_variables);\n\n\tLine tree;\n\tget_tree(lines, tree);\n\toptim(tree);\n\tContext global_context(\"__main__\", global_variables, global_variables);\n\twhile (global_context.lines_running.size() <= tree.level)\n\t\tglobal_context.lines_running.push_back(-100);\n\trun_lines(tree.children, global_context);\n\tglobal_variables.releaseAll();\n}\n\nstring builtins = \"def print(n):\\n\\n\tpass\\n\\n\\n\\ndef range(n):\\n\\n\tpass\";\n\nint main() {\n\ttry {\n\t\tvector<string> lib_lines;\n\t\tvector<string> lines;\n\t\tstringstream ss(builtins);\n\t\tread_lines(ss, lib_lines);\n\t\tread_lines(cin, lines);\n\t\trun(lib_lines, lines);\n\t}\n\tcatch (runtime_error & ex) {\n\t\tcout << ex.what() << endl;\n\t}\n}",
            "print('''def test_loop(n):\n\tfor i in range(n):\n\t\tprint(131 + i)\n\ndef test_condition(c):\n\tif c and True:\n\t\tprint(\"right\")\n\telse:\n\t\tprint(\"no\")\n\ntest_loop(10)\ntest_condition(True)''')",
            1585713600,
            1585713600
        ],
        [
            "17.1 (C++)",
            "考试模拟题（在考试中属于较难题目）<br>\n请写程序，使得主程序能得到正确的输出<br>\n<br>\n<b>EXAMPLE INPUT</b>\n<pre>\n1000 2000\n</pre>\n<b>EXAMPLE OUTPUT</b>\n<pre>\n1000 2000\n900 1900\n1800 2800\n</pre>",
            "#include \"source.cpp\"\n\nint main() {\n\tInteger a, b;\n\tcin >> a >> b;\n\tcout << a << \" \" << b << endl;\n\tlink(a, b);\n\ta -= 100;\n\tcout << a << \" \" << b << endl;\n\tb += a;\n\tcout << a << \" \" << b << endl;\n}",
            "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Integer\n{\npublic:\n\tint value;\n\tvector<Integer *> linked;\n\t\n\tInteger() {\n\t\tvalue = 0;\n\t}\n\t\n\tInteger(int value_) {\n\t\tvalue = value_;\n\t}\n\t\n\tInteger & operator += (int value_) {\n\t\tvalue += value_;\n\t\tfor (int i = 0; i < linked.size(); ++ i) {\n\t\t\tlinked[i]->value += value_;\n\t\t}\n\t\treturn *this;\n\t}\n\t\n\tInteger & operator += (const Integer & other) {\n\t\treturn (*this) += (other.value);\n\t}\n\t\n\tInteger & operator -= (const Integer & other) {\n\t\treturn (*this) += (-other.value);\n\t}\n};\n\nvoid link(Integer & int1, Integer & int2) {\n\tint1.linked.push_back(&int2);\n\tint2.linked.push_back(&int1);\n}\n\nostream & operator << (ostream & out, const Integer & int1) {\n\tout << int1.value;\n\treturn out;\n}\n\nistream & operator >> (istream & in, Integer & int1) {\n\tin >> int1.value;\n\treturn in;\n}",
            "from random import randint\nprint(randint(1,999),randint(1,999))",
            1585713600,
            1585713600
        ],
        [
            "17.1 LAB (C++)",
            "Modify class <i>Table</i> to enable <i>double</i> elements.\n<br><b>\nEXAMPLE OUTPUT\n</b><pre>1-1\n11\n</pre>",
            "#include \"source.cpp\"\n\n#include <iostream>\nusing namespace std;\n\nostream & operator << (ostream & out, const Table & table) {\n\tout << table.json();\n\treturn out;\n}\n\nint main() {\n\ttry {\n\t\tTable a;\n\t\ta.appendCol(\"A\");\n\t\ta.appendCol(\"B\");\n\t\ta.appendCol(\"C\");\n\t\ta.appendRow();\n\t\t// cout << a << endl;\n\t\ta[0] = List(\"1-1\", \"1-2\", \"1-3\");\n\t\ta[1] = List(11, 12, 13);\n\t\tstring value1 = a[0][\"A\"];\n\t\tdouble value2 = a[1][\"A\"];\n\t\tcout << value1 << endl;\n\t\tcout << value2 << endl;\n\t}\n\tcatch (runtime_error & ex) {\n\t\tcout << ex.what() << endl;\n\t}\n}",
            "#ifndef ECW_TABLE\n#define ECW_TABLE\n\n#include <string>\n#include <vector>\n#include <stdexcept>\n#include <sstream>\nusing namespace std;\n\nclass IndexOutOfBoundsException : public runtime_error {\npublic:\n\tIndexOutOfBoundsException() : runtime_error(\"Index out of bounds\") {}\n};\n\nclass NoSuchColumnException : public runtime_error {\npublic:\n\tNoSuchColumnException() : runtime_error(\"NoSuchColumnException\") {}\n};\n\nclass SizeMisMatchException : public runtime_error {\npublic:\n\tSizeMisMatchException() : runtime_error(\"SizeMisMatchException\") {}\n};\n\nint positiveIndex(int index, int size) {\n\tif (index < 0) index += size;\n\tif (index < 0 or index >= size) throw IndexOutOfBoundsException();\n\treturn index;\n}\n\ntemplate <typename T>\nint index(const vector<T> & list, const T & elem) {\n\tfor (int i = 0; i < list.size(); ++ i)\n\t\tif (list[i] == elem) return i;\n\treturn -1;\n}\n\ntemplate <typename T>\nvoid insert(vector<T> & list, const T & elem, int index) {\n\tint size_ = list.size();\n\tif (index == size_) {\n\t\tlist.push_back(elem);\n\t\treturn;\n\t}\n\tindex = positiveIndex(index, size_);\n\tlist.push_back(elem);\n\tfor (int i = size_; i >= index; -- i) {\n\t\tlist[i + 1] = list[i];\n\t}\n\tlist[index] = elem;\n}\n\t\ntemplate <typename T>\nvoid remove(vector<T> & list, int index) {\n\tint size_ = list.size();\n\tindex = positiveIndex(index, size_);\n\tfor (int i = index + 1; i < size_; ++ i) {\n\t\tlist[i - 1] = list[i];\n\t}\n\tlist.pop_back();\n}\n\ntemplate <typename T>\nint max(vector<T> & list, int size_) {\n\tint index = 0;\n\tfor (int i = 1; i < size_; ++ i) {\n\t\tif (list[index] < list[i]) index = i;\n\t}\n\treturn index;\n}\n\ntemplate <typename T>\nint min(vector<T> & list, int size_) {\n\tint index = 0;\n\tfor (int i = 1; i < size_; ++ i) {\n\t\tif (list[index] > list[i]) index = i;\n\t}\n\treturn index;\n}\n\ntemplate <typename T>\nvoid sort(vector<T> & list, bool reverse) {\n\tint size_ = list.size();\n\tfor (int s = size_; s > 1; -- s) {\n\t\tint index = reverse ? min(list, s) : max(list, s);\n\t\tswap(list[s - 1], list[index]);\n\t}\n}\n\ntemplate <typename T>\nbool equals(const vector<T> & list1, const vector<T> & list2) {\n\tint size_ = list1.size();\n\tif (size_ != list2.size()) return false;\n\tfor (int i = 0; i < size_; ++ i) {\n\t\tif (list1[i] != list2[i]) return false;\n\t}\n\treturn true;\n}\n\nstring f2s(double i) {\n\tstringstream ss;\n\tss << i;\n\treturn ss.str();\t\n}\n\nclass List\n{\nprivate:\n\tvector<string> data;\npublic:\n\tList(string elem1=\"\",\n\t\t string elem2=\"\", \n\t\t string elem3=\"\", \n\t\t string elem4=\"\", \n\t\t string elem5=\"\") {\n\t\tint size = 0;\n\t\tif (elem5.length() > 0) size = 5;\n\t\telse if (elem4.length() > 0) size = 4;\n\t\telse if (elem3.length() > 0) size = 3;\n\t\telse if (elem2.length() > 0) size = 2;\n\t\telse if (elem1.length() > 0) size = 1;\n\t\tif (size >= 1) data.push_back(elem1); else return;\n\t\tif (size >= 2) data.push_back(elem2); else return;\n\t\tif (size >= 3) data.push_back(elem3); else return;\n\t\tif (size >= 4) data.push_back(elem4); else return;\n\t\tif (size >= 5) data.push_back(elem5); else return;\n\t}\n\tList(double elem1,\n\t\t double elem2,\n\t\t double elem3,\n\t\t double elem4,\n\t\t double elem5) {\n\t\tdata.push_back(f2s(elem1));\n\t\tdata.push_back(f2s(elem2));\n\t\tdata.push_back(f2s(elem3));\n\t\tdata.push_back(f2s(elem4));\n\t\tdata.push_back(f2s(elem5));\n\t}\n\tList(double elem1,\n\t\t double elem2,\n\t\t double elem3,\n\t\t double elem4) {\n\t\tdata.push_back(f2s(elem1));\n\t\tdata.push_back(f2s(elem2));\n\t\tdata.push_back(f2s(elem3));\n\t\tdata.push_back(f2s(elem4));\n\t}\n\tList(double elem1,\n\t\t double elem2,\n\t\t double elem3) {\n\t\tdata.push_back(f2s(elem1));\n\t\tdata.push_back(f2s(elem2));\n\t\tdata.push_back(f2s(elem3));\n\t}\n\tList(double elem1,\n\t\t double elem2) {\n\t\tdata.push_back(f2s(elem1));\n\t\tdata.push_back(f2s(elem2));\n\t}\n\tList(double elem1) {\n\t\tdata.push_back(f2s(elem1));\n\t}\n\toperator vector<string> () const {\n\t\treturn data;\n\t}\n\n\tbool isEmpty() {\n\t\treturn data.size() == 0;\n\t}\n\n};\n\nclass Range\n{\nprivate:\n\tint start;\n\tint end;\n\npublic:\n\tRange(int start_, int end_) : start(start_), end(end_) {\n\t}\n\n\tvector<int> indexes(int size) const {\n\t\tvector<int> indexes_;\n\t\tint start_ = start;\n\t\tif (start_ != size)\n\t\t\tstart_ = positiveIndex(start_, size);\n\t\tint end_ = end;\n\t\tif (end_ != size)\n\t\t\tend_ = positiveIndex(end_, size);\n\t\tif (start_ < end_) {\n\t\t\tfor (int i = start_; i < end_; ++ i) indexes_.push_back(i);\n\t\t}\n\t\telse {\n\t\t\tfor (int i = start_; i > end_; -- i) indexes_.push_back(i);\n\t\t}\n\t\treturn indexes_;\n\t}\n\n};\n\nclass Table\n{\nprivate:\n\tvector<string> headers;\n\tvector<vector<string > > rows;\n \n\tTable & _addCol(const string & colName, int index) {\t\t\n\t\tinsert(headers, colName, index);\n\t\tfor (int i = 0; i < rows.size(); ++ i) {\n\t\t\tinsert(rows[i], string(), index);\n\t\t}\n\t\treturn *this;\n\t}\n\n\tTable & _addRow(int index, vector<string> new_row) {\n\t\tinsert(rows, new_row, index);\n\t\treturn *this;\n\t}\n\n\tTable & _addRow(int index) {\n\t\tvector<string> new_row;\n\t\tfor (int i = 0; i < headers.size(); ++ i) new_row.push_back(\"\");\n\t\treturn _addRow(index, new_row);\n\t}\n\n\tint _headerIndex(const string & colName) const {\n\t\tint index_ = index(headers, colName);\n\t\tif (index_ == -1) throw NoSuchColumnException();\n\t\treturn index_;\n\t}\n\n\tclass _TableRef;\n\n\t_TableRef _toRef() {\n\t\treturn _TableRef(*this, headers, Range(0, rows.size()));\n\t}\n\n\tconst _TableRef _toRef() const {\n\t\treturn _TableRef((Table &)*this, headers, Range(0, rows.size()));\n\t}\n\npublic:\n\n\tTable() {}\n\n\tTable(const vector<string> & headers_) : headers(headers_) {}\n\n\tint rowCount() const {\n\t\treturn rows.size();\n\t}\n\n\tint colCount() const {\n\t\treturn headers.size();\n\t}\n\n\tconst vector<string> & getHeaders() const {\n\t\treturn headers;\n\t}\n\n\tTable & addCol(const string & colName, int index) {\n\t\tindex = positiveIndex(index, headers.size());\n\t\treturn _addCol(colName, index);\n\t}\n\n\tTable & addRow(int index) {\n\t\tindex = positiveIndex(index, rows.size());\n\t\treturn _addRow(index);\n\t}\n\t\n\tTable & appendCol(const string & colName) {\n\t\treturn _addCol(colName, headers.size());\n\t}\n\n\tTable & appendCols(const vector<string> & colNames) {\n\t\tfor (int i = 0; i < colNames.size(); ++ i)\n\t\t\t_addCol(colNames[i], headers.size());\n\t\treturn *this;\n\t}\n\n\tTable & appendRow() {\n\t\treturn _addRow(rows.size());\n\t}\n\n\tTable & appendRow(vector<string> row) {\n\t\treturn _addRow(rows.size(), row);\n\t}\n\n\tTable & appendRows(int rows_) {\n\t\tfor (int i = 0; i < rows_; ++ i) \n\t\t\t_addRow(rows.size());\n\t\treturn *this;\n\t}\n\n\tbool hasCol(const string & colName) const {\n\t\treturn index(headers, colName) != -1;\n\t}\n\n\tbool hasRow(int index) const {\n\t\ttry {\n\t\t\tpositiveIndex(index, rows.size());\n\t\t\treturn true;\n\t\t}\n\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tTable & delCol(const string & colName) {\n\t\tint colIndex = _headerIndex(colName);\n\t\tremove(headers, colIndex);\n\t\tfor (int i = 0; i < rows.size(); ++ i)\n\t\t\tremove(rows[i], colIndex);\n\t\treturn *this;\n\t}\n\n\tTable & delRow(int rowIndex) {\n\t\trowIndex = positiveIndex(rowIndex, rows.size());\n\t\tremove(rows, rowIndex);\n\t\treturn *this;\n\t}\n\n\tTable & delCol(const vector<string> & cols) {\n\t\tfor (int i = 0; i < cols.size(); ++ i)\n\t\t\tdelCol(cols[i]);\n\t\treturn *this;\n\t}\n\n\tTable & delRow(const Range & rowRange) {\n\t\tvector<int> rowIndexes = rowRange.indexes(rows.size());\n\t\tsort(rowIndexes, true);\n\t\tfor (int i = 0; i < rowIndexes.size(); ++ i)\n\t\t\tdelRow(rowIndexes[i]);\n\t\treturn *this;\n\t}\n\t\n\t_TableRef operator [] (int rowIndex) {\n\t\tif (rowIndex == rows.size()) appendRow();\n\t\treturn _toRef()[rowIndex];\n\t}\n\n\t_TableRef operator [] (const string & colName) {\n\t\treturn _toRef()[colName];\n\t}\n\t\n\t_TableRef operator [] (const Range & range) {\n\t\treturn _toRef()[range];\n\t}\n\n\t_TableRef operator [] (const vector<string> & list) {\n\t\treturn _toRef()[list];\n\t}\n\n\tconst _TableRef operator [] (int rowIndex) const {\n\t\treturn _toRef()[rowIndex];\n\t}\n\n\tconst _TableRef operator [] (const string & colName) const {\n\t\treturn _toRef()[colName];\n\t}\n\t\n\tconst _TableRef operator [] (const Range & range) const {\n\t\treturn _toRef()[range];\n\t}\n\n\tconst _TableRef operator [] (const vector<string> & list) const {\n\t\treturn _toRef()[list];\n\t}\n\t\n\tstring json() const {\n\t\tstringstream ss;\n\t\tss << \"{\\n\\t\\\"headers\\\": [ \";\n\t\tfor (int i = 0; i < headers.size(); ++ i) {\n\t\t\tss << \"\\\"\" << headers[i] << \"\\\"\";\n\t\t\tif (i != headers.size() - 1) ss << \", \";\n\t\t}\n\t\tss << \"],\\n\\t\\\"rows\\\": [\";\n\t\tfor (int i = 0; i < rows.size(); ++ i) {\n\t\t\tss << \"\\n\\t\\t[ \";\n\t\t\tfor (int j = 0; j < rows[i].size(); ++ j) {\n\t\t\t\tss << \"\\\"\" << rows[i][j] << \"\\\"\";\n\t\t\t\tif (j != rows[i].size() - 1) ss << \", \";\n\t\t\t}\n\t\t\tss << \"]\";\n\t\t\tif (i != rows.size() - 1) ss << \",\";\n\t\t}\n\t\tss << \"\\n\\t]\\n}\";\n\t\treturn ss.str();\n\t}\n\n\tTable & operator += (const Table & other) {\n\t\tif (headers == other.headers) {\n\t\t\tfor (int i = 0; i < other.rows.size(); ++ i)\n\t\t\t\trows.push_back(other.rows[i]);\n\t\t\treturn *this;\n\t\t}\n\t\telse if (rows.size() == other.rows.size()) {\n\t\t\tfor (int c = 0; c < other.headers.size(); ++ c) {\n\t\t\t\theaders.push_back(other.headers[c]);\n\t\t\t\tfor (int r = 0; r < rows.size(); ++ r)\n\t\t\t\t\trows[r].push_back(other.rows[r][c]);\n\t\t\t}\n\t\t\treturn *this;\n\t\t}\n\t\tthrow SizeMisMatchException();\n\t}\n\n\tTable operator + (const Table & other) const {\n\t\tTable result(*this);\n\t\tresult += other;\n\t\treturn result;\n\t}\n\n\tTable & operator = (const vector<string> & vec) {\n\t\t_toRef() = vec;\n\t\treturn *this;\n\t}\n\n\tTable & operator = (const string & val) {\n\t\t_toRef() = val;\n\t\treturn *this;\n\t}\n\n\tTable & operator = (const _TableRef & ref) {\n\t\treturn (*this) = ref.toTable();\n\t}\n\nprivate:\n\n\tclass _TableRef\n\t{\n\tprivate:\n\t\tTable & table;\n\t\tvector<string> headers;\n\t\tvector<int> rowIndexes;\n\n\t\tvector<int> _headerIndexes() const {\n\t\t\tvector<int> indexes;\n\t\t\tfor (int i = 0; i < headers.size(); ++ i) {\n\t\t\t\tindexes.push_back(table._headerIndex(headers[i]));\n\t\t\t}\n\t\t\treturn indexes;\n\t\t}\n\n\tpublic:\n\t\t_TableRef(Table & t, const vector<string> & h, const Range & rowRange) : table(t), headers(h) {\n\t\t\trowIndexes = rowRange.indexes(table.rows.size());\n\t\t}\n\n\t\toperator string() const {\n\t\t\tif (headers.size() * rowIndexes.size() != 1) throw SizeMisMatchException();\n\t\t\tvector<int> colIndexes = _headerIndexes();\n\t\t\treturn table.rows[rowIndexes[0]][colIndexes[0]];\n\t\t}\n\t\toperator double() const {\n\t\t\tstring s = (string)(*this);\n\t\t\tstringstream ss(s);\n\t\t\tdouble value;\n\t\t\tss >> value;\n\t\t\treturn value;\n\t\t}\n\n\t\toperator vector<string>() const {\n\t\t\tvector<string> vec;\n\t\t\tvector<int> colIndexes = _headerIndexes();\n\t\t\tfor (int c = 0; c < colIndexes.size(); ++ c) {\n\t\t\t\tfor (int r = 0; r < rowIndexes.size(); ++ r) {\n\t\t\t\t\tvec.push_back(table.rows[rowIndexes[r]][colIndexes[c]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn vec;\n\t\t}\n\n\t\toperator Table() const {\n\t\t\treturn toTable();\n\t\t}\n\n\t\tTable toTable() const {\n\t\t\tTable t;\n\t\t\tt.headers = headers;\n\t\t\tvector<int> colIndexes = _headerIndexes();\n\t\t\tfor (int r = 0; r < rowIndexes.size(); ++ r) {\n\t\t\t\tt.appendRow();\n\t\t\t\tfor (int c = 0; c < colIndexes.size(); ++ c) {\n\t\t\t\t\tt.rows[r][c] = table.rows[rowIndexes[r]][colIndexes[c]];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn t;\n\t\t}\n\n\t\t_TableRef & operator = (const vector<string> & vec) {\n\t\t\tvector<int> colIndexes = _headerIndexes();\n\t\t\tif (colIndexes.size() * rowIndexes.size() != vec.size()) throw SizeMisMatchException();\n\t\t\tint count = 0;\n\t\t\tfor (int r = 0; r < rowIndexes.size(); ++ r) {\n\t\t\t\tfor (int c = 0; c < colIndexes.size(); ++ c) {\n\t\t\t\t\ttable.rows[rowIndexes[r]][colIndexes[c]] = vec[count];\n\t\t\t\t\t++ count;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn *this;\n\t\t}\n\n\t\t_TableRef operator = (const char text[]) {\n\t\t\treturn (*this) = string(text);\n\t\t}\n\t\t_TableRef & operator = (const string & value) {\n\t\t\tvector<int> colIndexes = _headerIndexes();\n\t\t\tif (colIndexes.size() * rowIndexes.size() != 1) throw SizeMisMatchException();\n\t\t\ttable.rows[rowIndexes[0]][colIndexes[0]] = value;\n\t\t\treturn *this;\n\t\t}\n\n\t\t_TableRef operator [] (const char text[]) const {\n\t\t\treturn (*this)[string(text)];\n\t\t}\n\t\t_TableRef operator [] (const Range & rowRange) const {\n\t\t\t_TableRef ref(*this);\n\t\t\tref.rowIndexes = rowRange.indexes(rowIndexes.size());\n\t\t\tfor (int i = 0; i < ref.rowIndexes.size(); ++ i) {\n\t\t\t\tref.rowIndexes[i] = rowIndexes[ref.rowIndexes[i]];\n\t\t\t}\n\t\t\treturn ref;\n\t\t}\n\t\t_TableRef operator [] (const vector<string> & list) const {\n\t\t\t_TableRef ref(*this);\n\t\t\tfor (int i = 0; i < list.size(); ++ i) {\n\t\t\t\tif (index(headers, list[i]) == -1) throw NoSuchColumnException();\n\t\t\t}\n\t\t\tref.headers = list;\n\t\t\treturn ref;\n\t\t}\t\t\n\t\t_TableRef operator [] (int rowIndex) const {\n\t\t\trowIndex = positiveIndex(rowIndex, rowIndexes.size());\n\t\t\treturn (*this)[Range(rowIndex, rowIndex + 1)];\n\t\t}\n\n\t\t_TableRef operator [] (const string & colName) const {\n\t\t\treturn this->operator[](List(colName));\n\t\t}\n\n\t\t_TableRef & operator =(const _TableRef & ref2) {\n\t\t\tif ((! equals(headers, ref2.headers)) or rowIndexes.size() != ref2.rowIndexes.size())\n\t\t\t\tthrow SizeMisMatchException();\n\t\t\tvector<int> colIndexes = _headerIndexes();\n\t\t\tvector<int> colIndexes2 = ref2._headerIndexes();\n\t\t\tfor (int c = 0; c < headers.size(); ++ c) {\t\n\t\t\t\tint c2 = index(ref2.headers, headers[c]);\n\t\t\t\tfor (int r = 0; r < rowIndexes.size(); ++ r) {\n\t\t\t\t\ttable.rows[rowIndexes[r]][colIndexes[c]] = \n\t\t\t\t\t\tref2.table.rows[ref2.rowIndexes[r]][colIndexes2[c2]];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn *this;\n\t\t}\n\n\t\t_TableRef & operator =(const Table & t) {\n\t\t\treturn (*this) = t._toRef();\n\t\t}\n\n\t\t_TableRef & selectivelyCopy(const _TableRef & ref2) {\n\t\t\tvector<int> colIndexes = _headerIndexes();\n\t\t\tvector<int> colIndexes2 = ref2._headerIndexes();\n\t\t\tfor (int c = 0; c < headers.size(); ++ c) {\t\n\t\t\t\tint c2 = index(ref2.headers, headers[c]);\n\t\t\t\tif (c2 == -1) continue;\n\t\t\t\tfor (int r = 0; r < rowIndexes.size(); ++ r) {\n\t\t\t\t\tif (r >= ref2.rowIndexes.size()) break;\n\t\t\t\t\ttable.rows[rowIndexes[r]][colIndexes[c]] = \n\t\t\t\t\t\tref2.table.rows[ref2.rowIndexes[r]][colIndexes2[c2]];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn *this;\n\t\t}\n\n\t\t_TableRef & selectivelyCopy(const Table & t) {\n\t\t\treturn selectivelyCopy(t._toRef());\n\t\t}\n\n\t\tTable operator + (const _TableRef & ref2) const {\n\t\t\treturn toTable() + ref2.toTable();\n\t\t}\n\n\t\tTable operator + (const Table & t) const {\n\t\t\treturn toTable() + t;\n\t\t}\n\n\t};\n\n};\n\n#endif",
            "",
            1585713600,
            1585713600
        ],
        [
            "18.1 (C++)",
            "请写程序使得main函数得到正确的输出<br>\n<br>\n<b>EXAMPLE INPUT</b>\n<pre>\nXiaoMing\nXiaoHong\n</pre>\n\n<b>EXAMPLE OUTPUT</b>\n<pre>\nXiaoMing\nXiaoHong\nXiaoMing\n</pre>",
            "#include \"source.cpp\"\n\nint main() {\n\tstring name1, name2;\n\tcin >> name1 >> name2; // XiaoMing XiaoHong\n\tMaster somebody(name1);\n\tDog snoopy(somebody.getName());\n\tCat helloKitty = snoopy.getPeer();\n\tcout << helloKitty.getMaster() << endl; // XiaoMing\n\tsnoopy.changeMaster(name2);\n\tcout << helloKitty.getMaster() << endl; // XiaoHong\n\thelloKitty.changeMaster(name1);\n\tcout << snoopy.getMaster() << endl; // XiaoMing\n}",
            "#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Master\n{\npublic:\n\tstring name;\n\tMaster(string name_): name(name_) {\n\t}\n\t\n\tstring getName() { return name; }\n};\n\nstring master;\n\nclass Dog\n{\npublic:\n\tDog(string m) {\n\t\tmaster = m;\n\t}\n\tvoid changeMaster(string m) {\n\t\tmaster = m;\n\t}\n\tstring getMaster() {\n\t\treturn master;\n\t}\n\tDog getPeer() { return *this; }\n};\n\n#define Cat Dog",
            "from random import randint\n\ndef random_str(k):\n\tchars = 'abcdefghijklmnopqrstuvwxyz'.upper()\n\ttext = ''\n\tfor i in range(k):\n\t\ttext += chars[randint(0,len(chars)-1)]\n\treturn text\n\nprint(random_str(randint(3,9)))\nprint(random_str(randint(3,9)))",
            1585713600,
            1585713600
        ],
        [
            "18.1 LAB (C++)",
            "<p>考试模拟题</p><p><b>Example Input<br></b><span style=\"color: rgb(34, 34, 34); font-family: SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; font-size: 14px;\">100</span></p>\n\n<example output=\"\">\n<p><b>Example Output<br></b><span style=\"color: rgb(34, 34, 34); font-family: SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; font-size: 14px;\">No. 100 yellow bus.<br></span><span style=\"color: rgb(34, 34, 34); font-family: SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; font-size: 14px;\">No. 100 bus.</span></p></example><p></p>",
            "#include \"source.cpp\"\n\nclass YellowBus : public Bus\n{\npublic:\n\tYellowBus(int number) {\n\t\tsetNumber(number);\n\t}\n\tvoid print() const {\n\t\tcout << \"No. \" << getNumber() << \" yellow bus.\" << endl;\n\t}\n};\n\nvoid print1(const Bus & bus) {\n\tbus.print();\n}\n\nvoid print2(const Bus bus) {\n\tbus.print();\n}\n\nint main() {\n\tint number;\n\tcin >> number;\n\tYellowBus yellow(number);\n\tprint1(yellow);\n\tprint2(yellow);\n}",
            "#include <iostream>\nusing namespace std;\n\nclass Bus\n{\n\tint number;\npublic:\n\tvirtual void print() const {\n\t\tcout << \"No. \" << number << \" bus.\" << endl;\n\t}\n\tvoid setNumber(int number) {\n\t\tthis->number = number;\n\t}\n\tint getNumber() const {\n\t\treturn number;\n\t}\n\n};",
            "from random import randint\nprint(randint(100,200))",
            1585713600,
            1585713600
        ],
        [
            "18.2 LAB (C++)",
            "考试模拟题<br>\n<example input=\"\">\n<pre><b>Example Input</b>\n100</pre>\n\n<example output=\"\">\n<pre style=\"font-size: 14px;\"><span style=\"font-weight: bolder;\">Example Output\n</span>No. 100 bus.\nNo. 100 yellow bus.</pre></example></example>",
            "#include <iostream>\nusing namespace std;\n\nclass Bus\n{\n\tint number;\nprotected:\n\tint getNumber() const {\n\t\treturn number;\n\t}\npublic:\n\tBus(int number) {\n\t\tthis->number = number;\n\t}\n\tvoid print() const {\n\t\tcout << \"No. \" << number << \" bus.\" << endl;\n\t}\n};\n\n#include \"source.cpp\"\n\nint main() {\n\tint number; \n\tcin >> number;\n\tBus bus(number);\n\tbus.print();\n\n\tYellowBus yellow(number);\n\tyellow.print();\n}",
            "class YellowBus : public Bus\n{\npublic:\n\tYellowBus(int number) : Bus(number) {}\n\tvoid print() const {\n\t\tcout << \"No. \" << getNumber() << \" yellow bus.\" << endl;\n\t}\n};",
            "from random import randint\nprint(randint(100,200))",
            1585713600,
            1585713600
        ],
        [
            "测试1",
            "<p><span style=\"font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, &quot;Noto Sans&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 1rem;\">本题要求用C++输入并倒叙输出3个单词</span></p><p><span style=\"font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, &quot;Noto Sans&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 1rem;\"><span style=\"font-weight: bolder;\">Example Input</span><br></span>word1 word2 word3</p><p><span style=\"font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, &quot;Noto Sans&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 1rem;\"><b>Example Output</b><br></span><span style=\"font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, &quot;Noto Sans&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 1rem;\">word3 word2 word1</span><br></p><p><b>本学期评</b><span style=\"font-weight: bolder; font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, &quot;Noto Sans&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 1rem;\">作业的评</span><span style=\"font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, &quot;Noto Sans&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 1rem;\"><b>分方式<br></b></span><span style=\"font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, &quot;Noto Sans&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 1rem;\">实验课作业在课件完成，理论课作业在周内指定时间段内完成<br>某些题目将会有随机的输入<br></span><span style=\"font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, &quot;Noto Sans&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 1rem;\">如果你的输出与标注答案的输出部分相同将会有部分的分数(总分100)<br></span><span style=\"font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, &quot;Noto Sans&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 1rem;\">每题可以提交无限次，最高的分数作为最后的分数</span></p>",
            "#include \"source.cpp\"",
            "#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n\tstring word1, word2, word3;\n\tcin >> word1 >> word2 >> word3;\n\tcout << word3 << \" \" << word2 << \" \" << word1;\n}",
            "from random import randint\n\ndef random_str(k, cc='ABCDEFGHIJKLMNOPQRSTUVWXYZ'):\n\treturn ''.join([cc[randint(0,len(cc)-1)] for i in range(k)])\n\nprint(random_str(5), random_str(5), random_str(5), end='')",
            -2209017943,
            1577808000
        ],
        [
            "测试2",
            "<p>请读入10个单词，并排序输出</p><p><span style=\"font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, &quot;Noto Sans&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 1rem;\"><span style=\"font-weight: bolder;\">Example Input</span><br></span>IFURK TUOTS IFUTL PIMXX KLISE GWPKG MGTIY LPIGO GOQLW RFEDG</p><p><span style=\"font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, &quot;Noto Sans&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 1rem;\"><span style=\"font-weight: bolder;\">Example Output</span><br></span>GOQLW GWPKG IFURK IFUTL KLISE LPIGO MGTIY PIMXX RFEDG TUOTS<br></p>",
            "#include \"source.cpp\"",
            "#include <iostream>\nusing namespace std;\n\nvoid sort(string text[], int size) {\n\tfor (int i = size - 1; i >= 0; -- i) {\n\t\tfor (int j = 0; j < i; ++ j) {\n\t\t\tif (text[j] > text[j+1]) {\n\t\t\t\tstring tmp = text[j];\n\t\t\t\ttext[j] = text[j + 1];\n\t\t\t\ttext[j + 1] = tmp;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tstring text[10];\n\tfor (int i = 0; i < 10; ++ i) cin >> text[i];\n\tsort(text, 10);\n\tfor (int i = 0; i < 10; ++ i) cout << text[i] << ' ';\n}",
            "from random import randint\n\ndef random_str(k):\n\tchars = 'abcdefghijklmnopqrstuvwxyz'.upper()\n\ttext = ''\n\tfor i in range(k):\n\t\ttext += chars[randint(0,len(chars)-1)]\n\treturn text\n\nfor i in range(10):\n\tprint(random_str(5), end=' ')",
            1587607200,
            1587613200
        ],
        [
            "2020/05/08",
            "<p>实现一个任意1-4维的矩阵类 <i>Tensor</i></p><p>完成这个实验课题目能让我们懂得高维到1维展开的一般方法，和帮助我们更好地理解和完成本周的理论课作业。</p><p>请先阅读主程序，然后实现函数：</p><p>double &amp; Tensor_get(int dimensions, const int sizes[], const double data[], int x0, int x1, int x2, int x3)</p><p><b>注意</b></p><ul><li>这个类的对象的构造函数指定了tensor的维数和每维的大小</li><li>成员函数get的前4行保证给定的每维的维度和大小都不越界</li></ul><p><b>EXAMPLE INPUT</b></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\">0 0</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\">2 1</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\">0 2</span></p><p class=\"p2\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183); min-height: 18px;\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\"></span><br></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\">2 3 4</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\">2 3 0</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\">1 1 2</span></p><p class=\"p2\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183); min-height: 18px;\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\"></span><br></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\">1 1 3 1</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\">1 3 3 0</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\">1 3 4 40</span></p><p><span style=\"font-weight: bolder;\"><br>EXAMPLE OUTPUT</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\">0</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\">21</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\">2</span></p><p class=\"p2\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183); min-height: 18px;\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\"></span><br></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\">234</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\">230</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\">112</span></p><p class=\"p2\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183); min-height: 18px;\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\"></span><br></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\">1131</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\">1330</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\">1344</span></p>",
            "#include \"source.cpp\"\n\n#include <iostream>\nusing namespace std;\n\nvoid _assert(bool valid, const char err_msg[]) {\n\tif (valid) return;\n\tcout << err_msg << endl;\n\texit(1);\n}\n\nclass Tensor\n{\nprivate:\n\tdouble * data;\n\tint sizes[4];\n\tint dimensions;\n\npublic:\n\tTensor(int size0, int size1=-1, int size2=-1, int size3=-1) {\n\t\t_assert(size0 > 0, \"第0维大小必须大于0\");\n\t\tif (size1 != -1) _assert(size1 > 0, \"第1维大小必须大于0\");\n\t\tif (size2 != -1) _assert(size2 > 0, \"第2维大小必须大于0\");\n\t\tif (size3 != -1) _assert(size3 > 0, \"第3维大小必须大于0\");\n\n\t\tthis->dimensions = 1;\n\t\tthis->sizes[0] = size0;\n\t\tthis->sizes[1] = this->sizes[2] = this->sizes[3] = 1;\n\t\tif (size1 != -1) {\n\t\t\tthis->dimensions = 2;\n\t\t\tthis->sizes[1] = size1;\n\t\t}\n\t\tif (size2 != -1) {\n\t\t\tthis->dimensions = 3;\n\t\t\tthis->sizes[2] = size2;\n\t\t}\n\t\tif (size3 != -1) {\n\t\t\tthis->dimensions = 4;\n\t\t\tthis->sizes[3] = size3;\n\t\t}\n\n\t\tint totel_size = this->numel();\n\t\tthis->data = new double[totel_size];\n\t\tfor (int i = 0; i < totel_size; ++ i)\n\t\t\tthis->data[i] = 0;\n\t}\n\n\tint numel() { // number of elements\n\t\treturn this->sizes[0] * this->sizes[1] * this->sizes[2] * this->sizes[3];\n\t}\n\n\tvoid fill(double value) {\n\t\tfor (int i = 0; i < this->numel(); ++ i)\n\t\t\tthis->data[i] = value;\n\t}\n\n\t~Tensor() {\n\t\tdelete [] this->data;\n\t}\n\n\tdouble & get(int x0, int x1=-1, int x2=-1, int x3=-1) {\n\t\t// 检查有否越界\n\t\t_assert(x0 >= 0 && x0 < this->sizes[0], \"第0维越界\");\n\t\t_assert((this->dimensions < 2 && x1 == -1) || (x1 >= 0 && x1 < this->sizes[1]), \"第1维越界\");\n\t\t_assert((this->dimensions < 3 && x2 == -1) || (x2 >= 0 && x2 < this->sizes[2]), \"第2维越界\");\n\t\t_assert((this->dimensions < 4 && x3 == -1) || (x3 >= 0 && x3 < this->sizes[3]), \"第3维越界\");\n\n\t\treturn Tensor_get(this->dimensions, this->sizes, this->data, x0, x1, x2, x3);\n\t}\n\n};\n\nint main() {\n\t// 测试1\n\tTensor t1(3, 4);\n\tfor (int i = 0; i < 3; ++ i) {\n\t\tfor (int j = 0; j < 4; ++ j) {\n\t\t\tt1.get(i, j) = i * 10 + j;\n\t\t}\n\t}\n\tfor (int i = 0; i < 3; ++ i) {\n\t\tint x0, x1;\n\t\tcin >> x0 >> x1;\n\t\tcout << t1.get(x0, x1) << endl;\n\t}\n\tcout << endl;\n\n\t// 测试2\n\tTensor t2(3, 4, 5);\n\tfor (int i = 0; i < 3; ++ i) {\n\t\tfor (int j = 0; j < 4; ++ j) {\n\t\t\tfor (int k = 0; k < 5; ++ k) {\n\t\t\t\tt2.get(i, j, k) = i * 100 + j * 10 + k;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < 3; ++ i) {\n\t\tint x0, x1, x2;\n\t\tcin >> x0 >> x1 >> x2;\n\t\tcout << t2.get(x0, x1, x2) << endl;\n\t}\n\tcout << endl;\n\t\n\t// 测试3\n\tTensor t3(3, 4, 5, 6);\n\tfor (int i = 0; i < 3; ++ i) {\n\t\tfor (int j = 0; j < 4; ++ j) {\n\t\t\tfor (int k = 0; k < 5; ++ k) {\n\t\t\t\tfor (int l = 0; l < 6; ++ l) {\n\t\t\t\t\tt3.get(i, j, k, l) = i * 1000 + j * 100 + k * 10 + l;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < 3; ++ i) {\n\t\tint x0, x1, x2, x3;\n\t\tcin >> x0 >> x1 >> x2 >> x3;\n\t\tcout << t3.get(x0, x1, x2, x3) << endl;\n\t}\n}",
            "double & Tensor_get(int dimensions, int sizes[], double * data, \n\t\t\t\t\tint x0, int x1, int x2, int x3)\n{\n\tint index = x0;\n\tif (dimensions > 1) index = index * sizes[1] + x1;\n\tif (dimensions > 2) index = index * sizes[2] + x2;\n\tif (dimensions > 3) index = index * sizes[3] + x3;\n\treturn data[index]; \n}",
            "from random import randint\n\ndef random_str(k,cc='abcdefghijklmnopqrstuvwxyz'):\n\treturn ''.join([cc[randint(0,len(cc)-1)] for i in range(k)]).upper()\n\ndef random_ops(k):\n\treturn random_str(k,'+-*/')\n\nprint(randint(0,2), randint(0,3))\nprint(randint(0,2), randint(0,3))\nprint(randint(0,2), randint(0,3))\nprint()\nprint(randint(0,2), randint(0,3), randint(0,4))\nprint(randint(0,2), randint(0,3), randint(0,4))\nprint(randint(0,2), randint(0,3), randint(0,4))\nprint()\nprint(randint(0,2), randint(0,3), randint(0,4), randint(0,5))\nprint(randint(0,2), randint(0,3), randint(0,4), randint(0,5))\nprint(randint(0,2), randint(0,3), randint(0,4), randint(0,5))\nprint()\n",
            1588903200,
            1588909200
        ],
        [
            "2020/05/14",
            "<p>实现一个任意1-4维的矩阵类&nbsp;<i>Tensor</i></p><p><span style=\"font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, &quot;Noto Sans&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 1rem;\">请先阅读主程序，然后实现打印</span><span style=\"font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, &quot;Noto Sans&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 1rem;\">矩阵的</span><span style=\"font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, &quot;Noto Sans&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 1rem;\">函数：</span></p><p>void Tensor_print(int dimensions, const int sizes[], const double data[])</p><p>注意</p><ul><li>由于只能打印出1维和2维的矩阵，当矩阵大于2维时需要按顺序打出高维矩阵中的各个2维矩阵</li></ul><p><span style=\"font-weight: bolder;\">EXAMPLE INPUT</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\">1.3</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\">5.1</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\">2.8</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\">6.3</span></p><p><span style=\"font-weight: bolder;\"><br></span></p><p><span style=\"font-weight: bolder;\">EXAMPLE OUTPUT</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\">Tensor of 5</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\">1.3</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\">1.3</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\">1.3</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\">1.3</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\">1.3</span></p><p class=\"p2\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183); min-height: 18px;\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\"></span><br></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\">Tensor of 3x4</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\"><span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>5.1<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>5.1<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>5.1<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>5.1</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\"><span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>5.1<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>5.1<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>5.1<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>5.1</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\"><span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>5.1<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>5.1<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>5.1<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>5.1</span></p><p class=\"p2\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183); min-height: 18px;\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\"></span><br></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\">Tensor of 3x4x5</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\">data[0]</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\"><span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\"><span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\"><span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\"><span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\">data[1]</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\"><span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\"><span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\"><span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\"><span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\">data[2]</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\"><span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\"><span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\"><span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\"><span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>2.8</span></p><p class=\"p2\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183); min-height: 18px;\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\"></span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\">Tensor of 2x3x4x5</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\">data[0][0]</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\"><span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\"><span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\"><span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\"><span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\">data[0][1]</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\"><span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\"><span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\"><span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\"><span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\">data[0][2]</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\"><span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\"><span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\"><span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\"><span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\">data[1][0]</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\"><span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\"><span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\"><span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\"><span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\">data[1][1]</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\"><span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\"><span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\"><span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\"><span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\">data[1][2]</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\"><span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\"><span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\"><span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 15px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\"><span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3<span class=\"Apple-converted-space\">&nbsp; &nbsp; </span>6.3</span></p>",
            "#include \"source.cpp\"\n\n#include <iostream>\nusing namespace std;\n\nvoid _assert(bool valid, const char err_msg[]) {\n\tif (valid) return;\n\tcout << err_msg << endl;\n\texit(1);\n}\n\nclass Tensor\n{\nprivate:\n\tdouble * data;\n\tint sizes[4];\n\tint dimensions;\n\npublic:\n\tTensor(int size0, int size1=-1, int size2=-1, int size3=-1) {\n\t\t_assert(size0 > 0, \"第0维大小必须大于0\");\n\t\tif (size1 != -1) _assert(size1 > 0, \"第1维大小必须大于0\");\n\t\tif (size2 != -1) _assert(size2 > 0, \"第2维大小必须大于0\");\n\t\tif (size3 != -1) _assert(size3 > 0, \"第3维大小必须大于0\");\n\n\t\tthis->dimensions = 1;\n\t\tthis->sizes[0] = size0;\n\t\tthis->sizes[1] = this->sizes[2] = this->sizes[3] = 1;\n\t\tif (size1 != -1) {\n\t\t\tthis->dimensions = 2;\n\t\t\tthis->sizes[1] = size1;\n\t\t}\n\t\tif (size2 != -1) {\n\t\t\tthis->dimensions = 3;\n\t\t\tthis->sizes[2] = size2;\n\t\t}\n\t\tif (size3 != -1) {\n\t\t\tthis->dimensions = 4;\n\t\t\tthis->sizes[3] = size3;\n\t\t}\n\n\t\tint totel_size = this->numel();\n\t\tthis->data = new double[totel_size];\n\t\tfor (int i = 0; i < totel_size; ++ i)\n\t\t\tthis->data[i] = 0;\n\t}\n\n\tint numel() { // number of elements\n\t\treturn this->sizes[0] * this->sizes[1] * this->sizes[2] * this->sizes[3];\n\t}\n\n\tvoid fill(double value) {\n\t\tfor (int i = 0; i < this->numel(); ++ i)\n\t\t\tthis->data[i] = value;\n\t}\n\n\t~Tensor() {\n\t\tdelete [] this->data;\n\t}\n\n\tdouble & get(int x0, int x1=-1, int x2=-1, int x3=-1) {\n\t\t// 检查有否越界\n\t\t_assert(x0 >= 0 && x0 < this->sizes[0], \"第0维越界\");\n\t\t_assert((this->dimensions < 2 && x1 == -1) || (x1 >= 0 && x1 < this->sizes[1]), \"第1维越界\");\n\t\t_assert((this->dimensions < 3 && x2 == -1) || (x2 >= 0 && x2 < this->sizes[2]), \"第2维越界\");\n\t\t_assert((this->dimensions < 4 && x3 == -1) || (x3 >= 0 && x3 < this->sizes[3]), \"第3维越界\");\n\n\t\tint index = x0;\n\t\tif (this->dimensions > 1) index = index * this->sizes[1] + x1;\n\t\tif (this->dimensions > 2) index = index * this->sizes[2] + x2;\n\t\tif (this->dimensions > 3) index = index * this->sizes[3] + x3;\n\t\treturn this->data[index];\n\t}\n\n\tvoid print() const {\n\t\treturn Tensor_print(this->dimensions, this->sizes, this->data);\t\t\n\t}\n\n};\n\nint main() {\n\tdouble value;\n\t// 测试1\n\tTensor t1(5);\n\tcin >> value;\n\tt1.fill(value);\n\tt1.print();\n\tcout << endl;\n\t\n\t// 测试2\n\tTensor t2(3, 4);\n\tcin >> value;\n\tt2.fill(value);\n\tt2.print();\n\tcout << endl;\n\n\t// 测试3\n\tTensor t3(3, 4, 5);\n\tcin >> value;\n\tt3.fill(value);\n\tt3.print();\n\tcout << endl;\n\n\t// 测试4\n\tTensor t4(2, 3, 4, 5);\n\tcin >> value;\n\tt4.fill(value);\n\tt4.print();\n}",
            "#include <iostream>\nusing namespace std;\n\nvoid _print(int rows, int cols, const double data[]) {\n\tfor (int i = 0; i < rows; ++ i) {\n\t\tfor (int j = 0; j < cols; ++ j)\n\t\t\tcout << \"    \" << data[i];\n\t\tcout << endl;\n\t}\n}\n\nvoid Tensor_print(int dimensions, const int sizes[], const double data[]) {\n\tcout << \"Tensor of \";\n\tfor (int i = 0; i < dimensions; ++ i) {\n\t\tif (i != 0) cout << 'x';\n\t\tcout << sizes[i];\n\t}\n\tcout << endl;\n\tif (dimensions == 1) {\n\t\tfor (int i = 0; i < sizes[0]; ++ i)\n\t\t\tcout << data[i] << endl;\n\t}\n\telse if (dimensions == 2) {\n\t\t_print(sizes[0], sizes[1], data);\n\t}\n\telse if (dimensions == 3) {\n\t\tfor (int i = 0; i < sizes[0]; ++ i) {\n\t\t\tcout << \"data[\" << i << \"]\" << endl;\n\t\t\t_print(sizes[1], sizes[2], data + i * sizes[1] * sizes[2]);\n\t\t}\n\t}\n\telse if (dimensions == 4) {\n\t\tfor (int i = 0; i < sizes[0]; ++ i) {\n\t\t\tfor (int j = 0; j < sizes[1]; ++ j) {\n\t\t\t\tcout << \"data[\" << i << \"][\" << j << \"]\" << endl;\n\t\t\t\t_print(sizes[2], sizes[3], data + (i * sizes[1] + j) * sizes[2] * sizes[3]);\n\t\t\t}\n\t\t}\n\t}\n}\t",
            "from random import randint\nprint(randint(10,99)/10)\nprint(randint(10,99)/10)\nprint(randint(10,99)/10)\nprint(randint(10,99)/10)",
            1589421600,
            1589427600
        ],
        [
            "7.3 (C++)",
            "<p>请参照map添加两个模版函数map2 。</p><p><span style=\"font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, &quot;Noto Sans&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 1rem;\"><b>EXAMPLE OUTPUT</b><br></span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 17px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\">135</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 17px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\">501</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 17px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\">867</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 17px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\">1123</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 17px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\">1456</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 17px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\">1789</span></p>",
            "#include <string>\n#include <vector>\n#include <iostream>\nusing namespace std;\n\ntemplate <typename A, typename R>\nvector<R> map(const vector<A> & x, R (*map_func)(const A &)) {\n\tvector<R> res;\n\tfor (int i = 0; i < x.size(); ++ i)\n\t\tres.push_back(map_func(x[i]));\n\treturn res;\n}\n\n#include \"source.cpp\"\n\n#include <sstream>\n// using namespace std;\nint to_int(const string & text) {\n\tstringstream ss(text);\n\tint val;\n\tss >> val;\n\treturn val;\n}\n\nvector<string> split(const string & line, \n\t\t\t\t\tconst string & delimiter=\" \") {\n\tvector<string> words;\n\tint st = 0;\n\twhile (st < line.size()) {\n\t\tint end = line.find(delimiter, st);\n\t\tif (end == st) st += delimiter.size();\n\t\telse {\n\t\t\tif (end == -1) {\n\t\t\t\twords.push_back(line.substr(st));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twords.push_back(line.substr(st, end-st));\n\t\t\tst = end + delimiter.size();\n\t\t}\n\t}\n\treturn words;\n}\n\ntemplate <typename E>\nvoid print_vector(const vector<E> & c) {\n\tfor (int i = 0; i < c.size(); ++ i) {\n\t\tcout << c[i] << endl;\n\t}\n}\n\nint add(const int & x, const int & y) {\n\treturn x + y;\n}\n\nint main() {\n\tstring line1 = \"123 456 789\";\n\tstring line2 = \"12 45 78\";\n\tvector<string> words = split(line1);\n\tvector<int> data1 = map(words, to_int);\n\twords = split(line2);\n\tvector<int> data2 = map(words, to_int);\n\tvector<int> sum1 = map2(data1, data2, add);\n\tprint_vector(sum1);\n\tvector<int> sum2 = map2(data1, 1000, add);\n\tprint_vector(sum2);\n}",
            "template <typename A1, typename A2, typename R>\nvector<R> map2(const vector<A1> & x1, const vector<A2> & x2, R (*map_func)(const A1 &, const A2 &)) {\n\tvector<R> res;\n\tfor (int i = 0; i < x1.size(); ++ i)\n\t\tres.push_back(map_func(x1[i], x2[i]));\n\treturn res;\n}\n\ntemplate <typename A1, typename A2, typename R>\nvector<R> map2(const vector<A1> & x1, const A2 & x2, R (*map_func)(const A1 &, const A2 &)) {\n\tvector<R> res;\n\tfor (int i = 0; i < x1.size(); ++ i)\n\t\tres.push_back(map_func(x1[i], x2));\n\treturn res;\n}",
            "",
            1590717600,
            1591275600
        ],
        [
            "8.6 (C++)",
            "<p>Please write a class <b>MyTensor</b>, which implements the interface <b>Tensor&lt;E&gt;</b></p><p><b>Example input</b></p><pre style=\"font-size: 14px;\">100\n10000\n</pre><p><b>Example output</b></p><pre style=\"font-size: 14px;\">100\n10000</pre>",
            "#include <vector>\nusing namespace std;\n\ntemplate <typename E>\nclass Tensor\n{\nprotected:\n\tvector<int> sizes;\npublic:\n\tTensor(vector<int> sizes) : sizes(sizes) {}\n\tvirtual E & get(const vector<int> & indexes) = 0;\n};\n\n#include \"source.cpp\"\n\nvector<int> I(int i1=-1, int i2=-1, int i3=-1, int i4=-1)\n{\n\tvector<int> indexes;\n\tif (i1 != -1) indexes.push_back(i1);\n\tif (i2 != -1) indexes.push_back(i2);\n\tif (i3 != -1) indexes.push_back(i3);\n\tif (i4 != -1) indexes.push_back(i4);\n\treturn indexes;\n};\n\nint main() {\n\tMyTensor mt1(I(3,4,5));\n\tTensor<double> & t1 = mt1;\n\tcin >> t1.get(I(0,0,3));\n\tcout << t1.get(I(0,0,3)) << endl;\n\t\n\tMyTensor mt2(I(2,3,4,5));\n\tTensor<double> & t2 = mt2;\n\tcin >> t2.get(I(1,2,3,4));\n\tcout << t2.get(I(1,2,3,4)) << endl;\n}",
            "#include <vector>\n#include <iostream>\nusing namespace std;\n\nclass MyTensor : public Tensor<double> \n{\n\tvector<double> values;\n\t\n\tint _index(const vector<int> & indexes) const {\n\t\tint index = 0;\n\t\tfor (int i = 0; i < this->sizes.size(); ++ i)\n\t\t\t(index *= sizes[i]) += indexes[i];\n\t\treturn index;\n\t}\n\t\npublic:\n\tint numel() const {\n\t\tif (this->sizes.size() == 0) return 0;\n\t\tint size = 1;\n\t\tfor (int i = 0; i < this->sizes.size(); ++ i) size *= sizes[i];\n\t\treturn size;\n\t}\n\t\n\tMyTensor(vector<int> sizes) : Tensor<double>(sizes) {\n\t\tthis->values.resize(this->numel());\n\t\tfor (int i = 0; i < this->numel(); ++ i) this->values[i] = 0;\n\t}\n\t\n\tvirtual double & get(const vector<int> & indexes) {\n\t\treturn values[this->_index(indexes)];\n\t}\n};",
            "from random import randint\nprint(randint(1000,9999)/100)\nprint(randint(1000,9999)/100)",
            1592445600,
            1592451600
        ],
        [
            "9.3 (C++)",
            "<p>Define the Complex class.</p><p><span style=\"color: rgb(34, 34, 34); font-family: SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; font-size: 14px;\"># 输出</span><br></p><pre>c7 = 35 + 55i\nc8 = 15 + 15i\nc9 = -450 + 850i\nc10 = 1.9 + -0.3i\nc11 = 20 + 20i\nc12 = -10 + 20i\nc3 = 26 + 37i\nc4 = -6 + -11i\nc5 = 220 + 740i\nc6 = 5.2 + -1.4i\nc1 != c2\n</pre>",
            "#include <iostream>\n#include <cmath>\nusing namespace std;\n\n#include \"source.cpp\"\n\nint main(){\n    Complex c1(25, 35);\n    Complex c2(10, 20);\n    Complex c3(1, 2);\n    Complex c4(4, 9);\n    Complex c5(34, 6);\n    Complex c6(80, 90);\n   \n    Complex c7 = c1 + c2;\n    Complex c8 = c1 - c2;\n    Complex c9 = c1 * c2;\n    Complex c10 = c1 / c2;\n    Complex c11 = 10 + c2;\n    Complex c12 = c2 - 20;\n    cout << \"c7 = \" << c7.real() << \" + \" << c7.imag() << \"i\" << endl;\n    cout << \"c8 = \" << c8.real() << \" + \" << c8.imag() << \"i\" << endl;\n    cout << \"c9 = \" << c9.real() << \" + \" << c9.imag() << \"i\" << endl;\n    cout << \"c10 = \" << c10.real() << \" + \" << c10.imag() << \"i\" << endl;\n    cout << \"c11 = \" << c11.real() << \" + \" << c11.imag() << \"i\" << endl;\n    cout << \"c12 = \" << c12.real() << \" + \" << c12.imag() << \"i\" << endl;\n   \n    c3 += c1;\n    c4 -= c2;\n    c5 *= c2;\n    c6 /= c2;\n    cout << \"c3 = \" << c3.real() << \" + \" << c3.imag() << \"i\" << endl;\n    cout << \"c4 = \" << c4.real() << \" + \" << c4.imag() << \"i\" << endl;\n    cout << \"c5 = \" << c5.real() << \" + \" << c5.imag() << \"i\" << endl;\n    cout << \"c6 = \" << c6.real() << \" + \" << c6.imag() << \"i\" << endl;\n   \n    if(c1 == c2){\n        cout << \"c1 == c2\" << endl;\n    }\n    if(c1 != c2){\n        cout << \"c1 != c2\" << endl;\n    }\n}",
            "#include <cmath>\n\n//复数类\nclass Complex{\npublic:  //构造函数\n    Complex(double real = 0.0, double imag = 0.0): m_real(real), m_imag(imag){ }\npublic:  //运算符重载\n    //以成员函数的形式重载\n    Complex & operator+=(const Complex &c);\n    Complex & operator-=(const Complex &c);\n    Complex & operator*=(const Complex &c);\n    Complex & operator/=(const Complex &c);\npublic:  //成员函数\n    double real() const{ return m_real; }\n    double imag() const{ return m_imag; }\n    double m_real;  //实部\n    double m_imag;  //虚部\n};\n//重载+运算符\nComplex operator+(const Complex &c1, const Complex &c2){\n    Complex c;\n    c.m_real = c1.m_real + c2.m_real;\n    c.m_imag = c1.m_imag + c2.m_imag;\n    return c;\n}\n//重载-运算符\nComplex operator-(const Complex &c1, const Complex &c2){\n    Complex c;\n    c.m_real = c1.m_real - c2.m_real;\n    c.m_imag = c1.m_imag - c2.m_imag;\n    return c;\n}\n//重载*运算符  (a+bi) * (c+di) = (ac-bd) + (bc+ad)i\nComplex operator*(const Complex &c1, const Complex &c2){\n    Complex c;\n    c.m_real = c1.m_real * c2.m_real - c1.m_imag * c2.m_imag;\n    c.m_imag = c1.m_imag * c2.m_real + c1.m_real * c2.m_imag;\n    return c;\n}\n//重载/运算符  (a+bi) / (c+di) = [(ac+bd) / (c²+d²)] + [(bc-ad) / (c²+d²)]i\nComplex operator/(const Complex &c1, const Complex &c2){\n    Complex c;\n    c.m_real = (c1.m_real*c2.m_real + c1.m_imag*c2.m_imag) / (pow(c2.m_real, 2) + pow(c2.m_imag, 2));\n    c.m_imag = (c1.m_imag*c2.m_real - c1.m_real*c2.m_imag) / (pow(c2.m_real, 2) + pow(c2.m_imag, 2));\n    return c;\n}\n//重载==运算符\nbool operator==(const Complex &c1, const Complex &c2){\n    if( c1.m_real == c2.m_real && c1.m_imag == c2.m_imag ){\n        return true;\n    }else{\n        return false;\n    }\n}\n//重载!=运算符\nbool operator!=(const Complex &c1, const Complex &c2){\n    if( c1.m_real != c2.m_real || c1.m_imag != c2.m_imag ){\n        return true;\n    }else{\n        return false;\n    }\n}\n//重载+=运算符\nComplex & Complex::operator+=(const Complex &c){\n \tComplex x = *this + c;\n\t*this = x;\n    return *this;\n}\n//重载-=运算符\nComplex & Complex::operator-=(const Complex &c){\n\tComplex x = *this - c;\n\t*this = x;\n    return *this;\n}\n//重载*=运算符\nComplex & Complex::operator*=(const Complex &c){\n\tComplex x = *this * c;\n\t*this = x;\n    return *this;\n}\n//重载/=运算符\nComplex & Complex::operator/=(const Complex &c){\n\tComplex x = *this / c;\n\t*this = x;\n    return *this;\n}\n//重载输入运算符\nistream & operator>>(istream & in, Complex & A){\n    in >> A.m_real >> A.m_imag;\n    return in;\n}\n//重载输出运算符\nostream & operator<<(ostream & out, Complex & A){\n    out << A.m_real <<\" + \"<< A.m_imag <<\" i \";;\n    return out;\n}",
            "",
            1592532000,
            1593090000
        ],
        [
            "9.4 (C++)",
            "<p>Define the Complex class.</p><pre style=\"\"># 输入\n8.1\n6.2\n2.7\n5.9\n\n\n# 输出\nc1 + c2 = 10.8 + 12.1 i \nc1 - c2 = 5.4 + 0.3 i  <br></pre>",
            "#include <iostream>\nusing namespace std;\n\n#include \"source.cpp\"\n\nint main(){\n    Complex c1, c2, c3;\n    cin >> c1 >> c2;\n    c3 = c1 + c2;\n    cout << \"c1 + c2 = \" << c3 << endl;\n    c3 = c1 - c2;\n    cout << \"c1 - c2 = \" << c3 << endl;\n}",
            "#include <cmath>\n\n//复数类\nclass Complex{\npublic:  //构造函数\n    Complex(double real = 0.0, double imag = 0.0): m_real(real), m_imag(imag){ }\npublic:  //成员函数\n    double real() const{ return m_real; }\n    double imag() const{ return m_imag; }\n    double m_real;  //实部\n    double m_imag;  //虚部\n};\n//重载+运算符\nComplex operator+(const Complex &c1, const Complex &c2){\n    Complex c;\n    c.m_real = c1.m_real + c2.m_real;\n    c.m_imag = c1.m_imag + c2.m_imag;\n    return c;\n}\n//重载-运算符\nComplex operator-(const Complex &c1, const Complex &c2){\n    Complex c;\n    c.m_real = c1.m_real - c2.m_real;\n    c.m_imag = c1.m_imag - c2.m_imag;\n    return c;\n}\n//重载*运算符  (a+bi) * (c+di) = (ac-bd) + (bc+ad)i\nComplex operator*(const Complex &c1, const Complex &c2){\n    Complex c;\n    c.m_real = c1.m_real * c2.m_real - c1.m_imag * c2.m_imag;\n    c.m_imag = c1.m_imag * c2.m_real + c1.m_real * c2.m_imag;\n    return c;\n}\n//重载/运算符  (a+bi) / (c+di) = [(ac+bd) / (c²+d²)] + [(bc-ad) / (c²+d²)]i\nComplex operator/(const Complex &c1, const Complex &c2){\n    Complex c;\n    c.m_real = (c1.m_real*c2.m_real + c1.m_imag*c2.m_imag) / (pow(c2.m_real, 2) + pow(c2.m_imag, 2));\n    c.m_imag = (c1.m_imag*c2.m_real - c1.m_real*c2.m_imag) / (pow(c2.m_real, 2) + pow(c2.m_imag, 2));\n    return c;\n}\n\n//重载输入运算符\nistream & operator>>(istream & in, Complex & A){\n    in >> A.m_real >> A.m_imag;\n    return in;\n}\n//重载输出运算符\nostream & operator<<(ostream & out, Complex & A){\n    out << A.m_real <<\" + \"<< A.m_imag <<\" i \";;\n    return out;\n}",
            "from random import randint\nprint(randint(10,99)/10)\nprint(randint(10,99)/10)\nprint(randint(10,99)/10)\nprint(randint(10,99)/10)",
            1592532000,
            1593090000
        ],
        [
            "9.5 (C++)",
            "<p>Define the Complex class.</p><pre style=\"font-size: 14px;\"># 输入\n5.8\n6.2\n\n\n# 输出\n++ c1 = 6.8 + 6.2 i \nc1 ++ = 6.8 + 6.2 i \nreal = 7.8</pre>",
            "#include <iostream>\nusing namespace std;\n\n#include \"source.cpp\"\n\nint main(){\n    Complex c1;\n    cin >> c1;\n    cout << \"++ c1 = \" << ++ c1 << endl; // 实部 += 1\n    cout << \"c1 ++ = \" << c1 ++ << endl; // 实部 += 1\n\tdouble real = c1; // 获取实部\n    cout << \"real = \" << real << endl;\n}",
            "#include <cmath>\n\n//复数类\nclass Complex{\npublic:  //构造函数\n    Complex(double real = 0.0, double imag = 0.0): m_real(real), m_imag(imag){ }\npublic:  //成员函数\n    double real() const { return m_real; }\n    double imag() const { return m_imag; }\n\toperator double() const { return m_real; }\n\tComplex & operator ++ () {  //++i，前置形式\n\t\t++ m_real;\n\t\treturn *this;\n\t}\n\tComplex operator ++ (int) {  //i++，后置形式\n\t\tComplex prev_value(*this);\n\t\t++ m_real;\n\t\treturn prev_value;\n\t}\n    double m_real;  //实部\n    double m_imag;  //虚部\n};\n\n//重载输入运算符\nistream & operator>>(istream & in, Complex & A){\n    in >> A.m_real >> A.m_imag;\n    return in;\n}\n//重载输出运算符\nostream & operator<<(ostream & out, const Complex & A){\n    out << A.m_real <<\" + \"<< A.m_imag <<\" i \";;\n    return out;\n}",
            "from random import randint\nprint(randint(10,99)/10)\nprint(randint(10,99)/10)",
            1592532000,
            1593090000
        ],
        [
            "9.6 (C++)",
            "<p>Define the <b>Tensor</b> class.<br></p><pre style=\"font-size: 14px;\"><pre style=\"font-size: 14px;\"># 输入\n79.72\n29.98\n\n\n# 输出\n79.72\n29.98</pre></pre>",
            "#include <vector>\n#include <iostream>\nusing namespace std;\n\n#include \"source.cpp\"\n\nint main() {\n\tTensor t(3,4,5);\n\tcin >> t(0,0,3);\n\tcout << t(0,0,3) << endl;\n\t\n\tTensor t2(2,3,4,5);\n\tcin >> t2(1,2,3,4);\n\tcout << t2(1,2,3,4) << endl;\n}",
            "\nclass Tensor\n{\n\tvector<int> sizes;\n\tvector<double> values;\n\t\n\tint _index(const vector<int> & indexes) const {\n\t\tint index = 0;\n\t\tfor (int i = 0; i < this->sizes.size(); ++ i) {\n\t\t\tindex *= sizes[i];\n\t\t\tindex += indexes[i];\n\t\t}\n\t\treturn index;\n\t}\n\t\n\tstatic vector<int> _I(int i1, int i2=-1, int i3=-1, int i4=-1)\n\t{\n\t\tvector<int> indexes;\n\t\tindexes.push_back(i1);\n\t\tif (i2 != -1) indexes.push_back(i2);\n\t\tif (i3 != -1) indexes.push_back(i3);\n\t\tif (i4 != -1) indexes.push_back(i4);\n\t\treturn indexes;\n\t}\n\npublic:\n\tint numel() const {\n\t\tif (this->sizes.size() == 0) return 0;\n\t\tint size = 1;\n\t\tfor (int i = 0; i < this->sizes.size(); ++ i) size *= sizes[i];\n\t\treturn size;\n\t}\n\t\n\tTensor(int i1, int i2=-1, int i3=-1, int i4=-1) {\n\t\tthis->sizes = _I(i1, i2, i3, i4);\n\t\tthis->values.resize(this->numel());\n\t\tfor (int i = 0; i < this->numel(); ++ i) this->values[i] = 0;\n\t}\n\t\n\tconst double & operator()(int i1, int i2=-1, int i3=-1, int i4=-1) const {\n\t\tvector<int> indexes = _I(i1, i2, i3, i4);\n\t\treturn values[this->_index(indexes)];\n\t}\n\t\n\tdouble & operator()(int i1, int i2=-1, int i3=-1, int i4=-1) {\n\t\tvector<int> indexes = _I(i1, i2, i3, i4);\n\t\treturn values[this->_index(indexes)];\n\t}\n};\n",
            "from random import randint\nprint(randint(1000,9999)/100)\nprint(randint(1000,9999)/100)",
            1592532000,
            1593090000
        ],
        [
            "9.7 (C++)",
            "<p>Define the&nbsp;<span style=\"font-weight: bolder;\">Tensor</span>&nbsp;class.&nbsp;<br>难题 (参考答案约130行)</p><p>输入的第1行是维数<br>输入的第2行是各<span style=\"font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, &quot;Noto Sans&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 1rem;\">维的大小<br>后面是矩阵中的元素</span></p><p><span style=\"color: rgb(34, 34, 34); font-family: SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; font-size: 14px;\"><b>输入</b></span><br></p><pre style=\"\"><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\">3</span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\">2 2 2</span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\"><br></span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\">9.2 1.7&nbsp;</span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\">3.2 5.2&nbsp;</span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\"><br></span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\">9.5 7.7&nbsp;</span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\">5.7 3.1&nbsp;</span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\"><br></span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\">4</span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\">2 2 4 2</span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\"><br></span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\">4.9 2.9&nbsp;</span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\">8.2 1.8&nbsp;</span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\">3.6 2.9&nbsp;</span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\">8.1 4.1&nbsp;</span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\"><br></span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\">2.5 4.3&nbsp;</span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\">6.3 4.4&nbsp;</span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\">4.7 5.3&nbsp;</span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\">4.1 7.0&nbsp;</span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\"><br></span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\">1.5 3.6&nbsp;</span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\">7.4 5.0&nbsp;</span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\">1.9 8.2&nbsp;</span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\">1.5 8.9&nbsp;</span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\"><br></span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\">8.1 3.8&nbsp;</span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\">6.3 4.0&nbsp;</span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\">6.3 5.0&nbsp;</span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\">8.2 6.8&nbsp;</span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal;\"><br></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal;\"><b>输出</b></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal;\"><b><br></b></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\">3</span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\">2 2 2&nbsp;</span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\"><br></span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\">9.2 1.7&nbsp;</span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\">3.2 5.2&nbsp;</span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\"><br></span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\">9.5 7.7&nbsp;</span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\">5.7 3.1&nbsp;</span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\"><br></span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\"><br></span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\">4</span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\">2 2 4 2&nbsp;</span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\"><br></span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\">4.9 2.9&nbsp;</span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\">8.2 1.8&nbsp;</span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\">3.6 2.9&nbsp;</span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\">8.1 4.1&nbsp;</span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\"><br></span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\">2.5 4.3&nbsp;</span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\">6.3 4.4&nbsp;</span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\">4.7 5.3&nbsp;</span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\">4.1 7&nbsp;</span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\"><br></span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\">1.5 3.6&nbsp;</span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\">7.4 5&nbsp;</span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\">1.9 8.2&nbsp;</span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\">1.5 8.9&nbsp;</span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\"><br></span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\">8.1 3.8&nbsp;</span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\">6.3 4&nbsp;</span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\">6.3 5&nbsp;</span></font></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; line-height: normal; background-color: rgb(215, 211, 183);\"><font color=\"#3b2322\" face=\"Courier\"><span style=\"font-size: 18px; font-variant-ligatures: no-common-ligatures; white-space: normal;\">8.2 6.8&nbsp;</span></font></p></pre>",
            "\n#include <vector>\n#include <iostream>\n#include <fstream>\nusing namespace std;\n\n#include \"source.cpp\"\n\nint main() {\n\tTensor t3;\n\tcin >> t3;\n\tcout << t3 << endl;\n\t\n\tTensor t4;\n\tcin >> t4;\n\tcout << t4 << endl;\n}",
            "\nclass Tensor\n{\n\tvector<int> sizes;\n\tvector<double> values;\n\t\n\tint _index(const vector<int> & indexes) const {\n\t\tint index = 0;\n\t\tfor (int i = 0; i < this->sizes.size(); ++ i) {\n\t\t\tindex *= sizes[i];\n\t\t\tindex += indexes[i];\n\t\t}\n\t\treturn index;\n\t}\n\t\n\tstatic vector<int> _I(int i1, int i2=-1, int i3=-1, int i4=-1)\n\t{\n\t\tvector<int> indexes;\n\t\tif (i1 != -1) indexes.push_back(i1);\n\t\tif (i2 != -1) indexes.push_back(i2);\n\t\tif (i3 != -1) indexes.push_back(i3);\n\t\tif (i4 != -1) indexes.push_back(i4);\n\t\treturn indexes;\n\t}\n\npublic:\n\tint dim() const { return sizes.size(); }\n\tint size(int i) const {\n\t\tif (i < 0 || i >= sizes.size()) {\n\t\t\tcout << \"i = \" << i << endl;\n\t\t\tcout << \"sizes.size() = \" << sizes.size() << endl;\n\t\t\texit(1);\n\t\t}\n\t\treturn sizes[i]; \n\t}\n\t\n\tint numel() const {\n\t\tif (this->sizes.size() == 0) return 0;\n\t\tint size = 1;\n\t\tfor (int i = 0; i < this->sizes.size(); ++ i) size *= sizes[i];\n\t\treturn size;\n\t}\n\t\n\tTensor(int i1=-1, int i2=-1, int i3=-1, int i4=-1) {\n\t\tthis->sizes = _I(i1, i2, i3, i4);\n\t\tthis->values.resize(this->numel());\n\t\tfor (int i = 0; i < this->numel(); ++ i) this->values[i] = 0;\n\t}\n\t\n\tconst double & operator()(int i1, int i2=-1, int i3=-1, int i4=-1) const {\n\t\tvector<int> indexes = _I(i1, i2, i3, i4);\n\t\treturn values[this->_index(indexes)];\n\t}\n\t\n\tdouble & operator()(int i1, int i2=-1, int i3=-1, int i4=-1) {\n\t\tvector<int> indexes = _I(i1, i2, i3, i4);\n\t\treturn values[this->_index(indexes)];\n\t}\n};\n\nostream & operator << (ostream & out, const Tensor & m) {\n\tout << m.dim() << endl;\n\tfor (int i = 0; i < m.dim(); ++ i) \n\t\tout << m.size(i) << \" \";\n\tout << endl << endl;\n\tif (m.dim() == 1) {\n\t\tfor (int i = 0; i < m.size(0); ++ i) cout << m(i) << \" \"; \n\t}\n\tif (m.dim() == 2) {\n\t\tfor (int i = 0; i < m.size(0); ++ i) {\n\t\t\tfor (int j = 0; j < m.size(1); ++ j) \n\t\t\t\tout << m(i, j) << \" \";\n\t\t\tout << endl;\n\t\t}\n\t}\n\tif (m.dim() == 3) {\n\t\tfor (int i = 0; i < m.size(0); ++ i) {\n\t\t\tfor (int j = 0; j < m.size(1); ++ j) {\n\t\t\t\tfor (int k = 0; k < m.size(2); ++ k) \n\t\t\t\t\tout << m(i, j, k) << \" \";\n\t\t\t\tout << endl;\n\t\t\t}\n\t\t\tout << endl;\n\t\t}\n\t}\n\tif (m.dim() == 4) {\n\t\tfor (int i = 0; i < m.size(0); ++ i) {\n\t\t\tfor (int j = 0; j < m.size(1); ++ j) {\n\t\t\t\tfor (int k = 0; k < m.size(2); ++ k) {\n\t\t\t\t\tfor (int l = 0; l < m.size(3); ++ l) \n\t\t\t\t\t\tout << m(i, j, k, l) << \" \";\n\t\t\t\t\tout << endl;\n\t\t\t\t}\n\t\t\t\tout << endl;\n\t\t\t}\n\t\t}\n\t}\n    return out;\n}\n\nistream & operator >> (istream & in, Tensor & m) {\n    int dim;\n\tint sizes[4] = {-1,-1,-1,-1};\n\tin >> dim;\n\tfor (int i = 0; i < dim; ++ i) in >> sizes[i];\n\tTensor tmp(sizes[0], sizes[1], sizes[2], sizes[3]);\n\tfor (int i = 0; i < tmp.size(0); ++ i) {\n\t\tif (dim == 1) {\n\t\t\tin >> tmp(i);\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int j = 0; j < tmp.size(1); ++ j) {\n\t\t\tif (dim == 2) {\n\t\t\t\tin >> tmp(i, j);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int k = 0; k < tmp.size(2); ++ k) {\n\t\t\t\tif (dim == 3) {\n\t\t\t\t\tin >> tmp(i, j, k);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (int l = 0; l < tmp.size(3); ++ l) \n\t\t\t\t\tin >> tmp(i, j, k, l);\n\t\t\t}\n\t\t}\n\t}\n\tm = tmp;\n    return in;\n}",
            "from random import randint\n\ndef printm(dim):\n\tsizes = [randint(2,4) for i in range(dim)]\n\tprint(len(sizes))\n\tprint(' '.join(str(s) for s in sizes))\n\tdef _print(sizes):\n\t\tif len(sizes) == 2:\n\t\t\tprint()\n\t\t\tfor i in range(sizes[0]):\n\t\t\t\tfor j in range(sizes[1]):\n\t\t\t\t\tprint(randint(10,99)/10, end= ' ')\n\t\t\t\tprint()\n\t\telse:\n\t\t\tfor i in range(sizes[0]):\n\t\t\t\t_print(sizes[1:])\n\t_print(sizes)\n\nprintm(3)\nprint()\nprintm(4)\n",
            1592532000,
            1593090000
        ],
        [
            "2020-07-09 LAB",
            "<p>实现一个Integer类使得main函数得到例子中的输出。</p><p><span style=\"font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, &quot;Noto Sans&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 1rem;\"># 输入</span><br></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 18px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\">20</span></p><p><span style=\"font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, &quot;Noto Sans&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 1rem;\"><br># 输出</span><br></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 18px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\">10 20</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 18px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\">110 120</span></p><p class=\"p1\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 18px; line-height: normal; font-family: Courier; color: rgb(59, 35, 34); background-color: rgb(215, 211, 183);\"><span class=\"s1\" style=\"font-variant-ligatures: no-common-ligatures;\">230 240</span></p>",
            "#include \"source.cpp\"\n\n#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n\tInteger x = 10;\n\tInteger y; // constructor initializes y to 0\n\tcin >> y;\n\tcout << x << \" \" << y << endl;\n\tInteger::increase_all(100);\n\tcout << x << \" \" << y << endl;\n\tInteger::increase_all(y);\n\tcout << x << \" \" << y << endl;\n}",
            "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Integer\n{\n\tint value;\n\tstatic vector<Integer*> all;\n\npublic:\n\tInteger(int v=0) : value(v) {\n\t\tall.push_back(this);\n\t}\n\n\t~Integer() {\n\t\tfor (int i = 0; i < all.size(); ++ i) {\n\t\t\tif (all[i] == this) {\n\t\t\t\tall[i] = all[all.size()-1];\n\t\t\t\tall.pop_back();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\toperator int() { return value; }\n\n\tstatic void increase_all(int inc) {\n\t\tfor (int i = 0; i < all.size(); ++ i) {\n\t\t\tall[i]->value += inc;\n\t\t}\n\t}\n\n\tfriend istream & operator >> (istream & in, Integer & integer);\n};\n\nvector<Integer*> Integer::all;\n\nistream & operator >> (istream & in, Integer & integer) {\n\tin >> integer.value;\n\treturn in;\n}",
            "from random import randint\nprint(randint(0,99))\n",
            1594260000,
            1594266000
        ],
        [
            "A.1 (C++)",
            "<p>In this exercise, please change the linked-list we learned into a compressed linked-list.</p><p>compressed linked-list:<br>long prev_xor_next = long(prev_node) ^ long(next_node);<br>Node * prev_node = (Node *)(prev_xor_next&nbsp;^ long(next_node));<br><span style=\"font-size: 1rem;\">Node * next_node = (Node *)(</span>prev_xor_next<span style=\"font-size: 1rem;\">&nbsp;^ long(prev_node));</span></p><p># 输入</p><p>8 9<br><span style=\"font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, &quot;Noto Sans&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 1rem;\">80 30 23 95 30 3 98 59<br></span><span style=\"font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, &quot;Noto Sans&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 1rem;\">37 13 94 57 99 4 11 28 15<br></span><span style=\"font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, &quot;Noto Sans&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 1rem;\">3</span></p><p><span style=\"font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, &quot;Noto Sans&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 1rem;\"># 输出</span><br></p><p>15<br><span style=\"font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, &quot;Noto Sans&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 1rem;\">28<br></span><span style=\"font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, &quot;Noto Sans&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 1rem;\">11<br></span><span style=\"font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, &quot;Noto Sans&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 1rem;\">4<br></span><span style=\"font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, &quot;Noto Sans&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 1rem;\">99<br></span><span style=\"font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, &quot;Noto Sans&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 1rem;\">57<br></span><span style=\"font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, &quot;Noto Sans&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 1rem;\">94<br></span><span style=\"font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, &quot;Noto Sans&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 1rem;\">13<br></span><span style=\"font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, &quot;Noto Sans&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 1rem;\">37<br></span><span style=\"font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, &quot;Noto Sans&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 1rem;\">59<br></span><span style=\"font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, &quot;Noto Sans&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 1rem;\">98<br></span><span style=\"font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, &quot;Noto Sans&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 1rem;\">30<br></span><span style=\"font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, &quot;Noto Sans&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 1rem;\">95<br></span><span style=\"font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, &quot;Noto Sans&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 1rem;\">23<br></span><span style=\"font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, &quot;Noto Sans&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 1rem;\">30<br></span><span style=\"font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, &quot;Noto Sans&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 1rem;\">80</span></p>",
            "#include <iostream>\nusing namespace std;\n\ntemplate <typename E>\nclass Node\n{\n\tlong prev_xor_next;\npublic:\t\n\tE element;\n\n\tNode * prev_node(Node * next_node) {\n\t\treturn (Node *)(prev_xor_next ^ (long)next_node);\n\t}\n\tNode * next_node(Node * prev_node) {\n\t\treturn (Node *)(prev_xor_next ^ (long)prev_node);\n\t}\n\tvoid update_prev_and_next_node(Node * prev_node, Node * next_node) {\n\t\tprev_xor_next = long(prev_node) ^ long(next_node);\n\t}\n\tvoid update_prev_node(Node * old_prev_node, Node * prev_node) {\n\t\tNode * next_node = this->next_node(old_prev_node);\n\t\tupdate_prev_and_next_node(prev_node, next_node);\n\t}\n\tvoid update_next_node(Node * old_next_node, Node * next_node) {\n\t\tNode * prev_node = this->prev_node(old_next_node);\n\t\tupdate_prev_and_next_node(prev_node, next_node);\n\t}\n};\n\n#define I(i,n) for (int i = 0; i < n; ++ i)\n\nclass NotSuchElementException {};\n\ntemplate <typename E>\nclass LinkedList\n{\n\tint _size;\n\tNode<E> * head;\n\tNode<E> * tail;\n\npublic:\n\tLinkedList() : _size(0), head(0), tail(0) {}\n\n\tint size() const { return _size; }\n\n#include \"source.cpp\"\n};\n\nint main() {\n\tint size1, size2;\n\tcin >> size1 >> size2;\n\tLinkedList<double> list1;\n\tI(i,size1) {\n\t\tint val;\n\t\tcin >> val;\n\t\tlist1.addFirst(val);\n\t}\n\tI(i,size2) {\n\t\tint val;\n\t\tcin >> val;\n\t\tlist1.addLast(val);\n\t}\n\tLinkedList<double> list2 = list1;\n\tint val;\n\tcin >> val;\n\tlist2.removeFirstOccurrence(val);\n\tI(i,size2) {\n\t\tcout << list2.get(list2.size()-1) << endl;\n\t\tlist2.removeLast(); \n\t}\n\tI(i,size1-1) {\n\t\tcout << list2.get(0) << endl;\n\t\tlist2.removeFirst(); \n\t}\n}",
            "private:\n\tvoid get_node(int index, Node<E> * & prev_node, Node<E> * & node, Node<E> * & next_node) const {\n\t\tif (index < 0 || index >= _size) \n\t\t\tthrow NotSuchElementException();\n\t\tif (index < _size / 2) {\n\t\t\tnode = head;\n\t\t\tprev_node = 0;\n\t\t\tnext_node = node->next_node(prev_node);\n\t\t\tI(i, index) {\n\t\t\t\tprev_node = node;\n\t\t\t\tnode = next_node;\n\t\t\t\tnext_node = node->next_node(prev_node);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tnode = tail;\n\t\t\tnext_node = 0;\n\t\t\tprev_node = node->prev_node(next_node);\n\t\t\tI(i, (_size-1-index)) {\n\t\t\t\tnext_node = node;\n\t\t\t\tnode = prev_node;\n\t\t\t\tprev_node = node->prev_node(next_node);\n\t\t\t}\n\t\t}\n\t}\n\npublic:\n\tE & get(int index) const {\n\t\tNode<E> * node;\n\t\tNode<E> * prev_node;\n\t\tNode<E> * next_node;\n\t\tget_node(index, prev_node, node, next_node);\n\t\treturn node->element;\n\t}\n\tvoid set(int index, const E & e) {\n\t\tNode<E> * node;\n\t\tNode<E> * prev_node;\n\t\tNode<E> * next_node;\n\t\tget_node(index, prev_node, node, next_node);\n\t\tnode->element = e;\n\t}\n\n\tE & getFirst() const {\n\t\treturn get(0);\n\t}\n\n\tE & getLast() const {\n\t\treturn get(_size - 1);\n\t}\n\n\tvoid remove (int index) {\n\t\tNode<E> * node;\n\t\tNode<E> * prev_node;\n\t\tNode<E> * next_node;\n\t\tget_node(index, prev_node, node, next_node);\n\t\tif (prev_node != 0) prev_node->update_next_node(node, next_node);\n\t\tif (next_node != 0) next_node->update_prev_node(node, prev_node);\n\t\tif (prev_node == 0) head = next_node;\n\t\tif (next_node == 0) tail = prev_node;\n\t\tdelete node;\n\t\t-- _size;\n\t}\n\n\tvoid removeFirst () {\n\t\tremove(0);\n\t}\n\n\tvoid removeLast () {\n\t\tremove(_size-1);\n\t}\n\n\tvoid add(int index, const E & e) {\n\t\tif (index < 0 || index > _size) \n\t\t\tthrow NotSuchElementException();\n\t\tNode<E> * node = new Node<E>();\n\t\tnode->element = e;\n\t\tNode<E> * prev_node = tail;\n\t\tNode<E> * next_node = 0;\n\t\tNode<E> * next_next_node;\n\t\tif (index != _size)\n\t\t\tget_node(index, prev_node, next_node, next_next_node);\n\t\tif (next_node != 0)\n\t\t\tprev_node = next_node->prev_node(next_next_node);\n\t\tnode->update_prev_and_next_node(prev_node, next_node);\n\t\tif (prev_node != 0) prev_node->update_next_node(next_node, node);\n\t\tif (next_node != 0) next_node->update_prev_node(prev_node, node);\n\t\tif (prev_node == 0) head = node;\n\t\tif (next_node == 0) tail = node;\n\t\t++ _size;\n\t}\n\n\tvoid addFirst (const E & e) {\n\t\tadd(0, e);\n\t}\n\n\tvoid addLast (const E & e) {\n\t\tadd(_size, e);\n\t}\n\n\t// copy and clear\n\npublic:\n\tvoid clear() {\n\t\twhile (_size > 0) removeFirst();\n\t}\n\n\tvoid addAll(const LinkedList & list, int index=-1) {\n\t\tif (index == -1) index = _size;\n\t\tNode<E> * node = list.head;\n\t\tNode<E> * prev_node = 0;\n\t\tI(i, list._size) {\n\t\t\tadd(index + i, node->element);\n\t\t\tNode<E> * next_node = node->next_node(prev_node);\n\t\t\tprev_node = node;\n\t\t\tnode = next_node;\n\t\t}\n\t}\n\n\tLinkedList(const LinkedList & list) : _size(0), head(0), tail(0) {\n\t\taddAll(list);\n\t}\n\n\tLinkedList & operator = (const LinkedList & list) {\n\t\tclear();\n\t\taddAll(list);\n\t\treturn *this;\n\t}\n\n\t~LinkedList() {\n\t\tclear();\n\t}\n\n\tint indexOf(const E & e) const {\n\t\tNode<E> * node = head;\n\t\tNode<E> * prev_node = 0;\n\t\tI(i, _size) {\n\t\t\tif (node->element == e) return i;\n\t\t\tNode<E> * next_node = node->next_node(prev_node);\n\t\t\tprev_node = node;\n\t\t\tnode = next_node;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tint lastIndexOf(const E & e) const {\n\t\tNode<E> * node = tail;\n\t\tNode<E> * next_node = 0;\n\t\tI(i, _size) {\n\t\t\tif (node->element == e) return i;\n\t\t\tNode<E> * prev_node = node->prev_node(next_node);\n\t\t\tnext_node = node;\n\t\t\tnode = prev_node;\n\t\t}\n\t\treturn -1;\n\t}\n\n\t// element-oriented ops\n\n\tbool contains(const E & e) const {\n\t\treturn indexOf(e) >= 0;\n\t}\n\n\tvoid removeFirstOccurrence(const E & e) {\n\t\tint index = indexOf(e);\n\t\tif (index == -1)\n\t\t\tthrow NotSuchElementException();\n\t\tremove(index);\n\t}\n\n\tvoid removeLastOccurrence(const E & e) {\n\t\tint index = lastIndexOf(e);\n\t\tif (index == -1)\n\t\t\tthrow NotSuchElementException();\n\t\tremove(index);\n\t}",
            "from random import randint\nsize1 = randint(5,9)\nsize2 = randint(5,9)\nprint(size1, size2)\ndata1 = [randint(1,99) for i in range(size1)]\ndata2 = [randint(1,99) for i in range(size2)]\nprint(' '.join(str(d) for d in data1))\nprint(' '.join(str(d) for d in data2))\nprint(data1[randint(0,size1-1)])\n",
            1594346400,
            1594904400
        ],
        [
            "A.2 (C++)",
            "<p>In this exercise, please add a member function, removeAll, into the linked-list class.</p><p># 输入</p><p>9<br><span style=\"font-size: 1rem;\">77 57 70 21 31 95 14 77 95<br></span><span style=\"font-size: 1rem;\">77</span></p><p><span style=\"font-size: 1rem;\"># 输出</span><br></p><p>57<br><span style=\"font-size: 1rem;\">70<br></span><span style=\"font-size: 1rem;\">21<br></span><span style=\"font-size: 1rem;\">31<br></span><span style=\"font-size: 1rem;\">95<br></span><span style=\"font-size: 1rem;\">14<br></span><span style=\"font-size: 1rem;\">95</span></p><div><br></div>",
            "#include <iostream>\nusing namespace std;\n\ntemplate <typename E>\nstruct Node\n{\n\tE element;\n\tNode * next_node;\n\tNode * prev_node;\n};\n\n#define I(i,n) for (int i = 0; i < n; ++ i)\n\nclass NotSuchElementException {};\n\ntemplate <typename E>\nclass LinkedList\n{\n\tint _size;\n\tNode<E> * head;\n\tNode<E> * tail;\n\npublic:\n\tLinkedList() : _size(0), head(0), tail(0) {}\n\n\tint size() const { return _size; }\n\nprivate:\n\tNode<E> * get_node(int index) const {\n\t\tif (index < 0 || index >= _size) \n\t\t\tthrow NotSuchElementException();\n\t\tif (index < _size / 2) {\n\t\t\tNode<E> * node = head;\n\t\t\tI(i, index) node = node->next_node;\n\t\t\treturn node;\n\t\t}\n\t\telse {\n\t\t\tNode<E> * node = tail;\n\t\t\tI(i, (_size-1-index)) node = node->prev_node;\n\t\t\treturn node;\n\t\t}\n\t}\n\npublic:\n\tE & get(int index) const {\n\t\tNode<E> * node = get_node(index);\n\t\treturn node->element;\n\t}\n\tvoid set(int index, const E & e) {\n\t\tNode<E> * node = get_node(index);\n\t\tnode->element = e;\n\t}\n\n\tE & getFirst() const {\n\t\treturn get(0);\n\t}\n\n\tE & getLast() const {\n\t\treturn get(_size - 1);\n\t}\n\n\tvoid remove (int index) {\n\t\tNode<E> * node = get_node(index);\n\t\tNode<E> * prev_node = node->prev_node;\n\t\tNode<E> * next_node = node->next_node;\n\t\tif (prev_node != 0) prev_node->next_node = next_node;\n\t\tif (next_node != 0) next_node->prev_node = prev_node;\n\t\tif (prev_node == 0) head = next_node;\n\t\tif (next_node == 0) tail = prev_node;\n\t\tdelete node;\n\t\t-- _size;\n\t}\n\n\tvoid removeFirst () {\n\t\tremove(0);\n\t}\n\n\tvoid removeLast () {\n\t\tremove(_size-1);\n\t}\n\n\tvoid add(int index, const E & e) {\n\t\tif (index < 0 || index > _size) \n\t\t\tthrow NotSuchElementException();\n\t\tNode<E> * node = new Node<E>();\n\t\tnode->element = e;\n\t\tNode<E> * next_node = (index == _size ? 0 : get_node(index));\n\t\tNode<E> * prev_node = (next_node == 0 ? tail : next_node->prev_node);\n\t\tnode->next_node = next_node;\n\t\tnode->prev_node = prev_node;\n\t\tif (prev_node != 0) prev_node->next_node = node;\n\t\tif (next_node != 0) next_node->prev_node = node;\n\t\tif (prev_node == 0) head = node;\n\t\tif (next_node == 0) tail = node;\n\t\t++ _size;\n\t}\n\n\tvoid addFirst (const E & e) {\n\t\tadd(0, e);\n\t}\n\n\tvoid addLast (const E & e) {\n\t\tadd(_size, e);\n\t}\n\npublic:\n\tvoid clear() {\n\t\twhile (_size > 0) removeFirst();\n\t}\n\n\tvoid addAll(const LinkedList & list, int index=-1) {\n\t\tif (index == -1) index = _size;\n\t\tNode<E> * node = list.head;\n\t\tI(i, list._size) {\n\t\t\tadd(index, node->element);\n\t\t\tnode = node->next_node;\n\t\t\t++ index;\n\t\t}\n\t}\n\n\tLinkedList(const LinkedList & list) : _size(0), head(0), tail(0) {\n\t\taddAll(list);\n\t}\n\n\tLinkedList & operator = (const LinkedList & list) {\n\t\tclear();\n\t\taddAll(list);\n\t}\n\n\t~LinkedList() {\n\t\tclear();\n\t}\n\n\tint indexOf(const E & e) const {\n\t\tNode<E> * node = head;\n\t\tI(i, _size) {\n\t\t\tif (node->element == e) return i;\n\t\t\tnode = node->next_node;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tint lastIndexOf(const E & e) const {\n\t\tNode<E> * node = tail;\n\t\tI(i, _size) {\n\t\t\tif (node->element == e) return i;\n\t\t\tnode = node->prev_node;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tbool contains(const E & e) const {\n\t\treturn indexOf(e) >= 0;\n\t}\n\n\tvoid removeFirstOccurrence(const E & e) {\n\t\tint index = indexOf(e);\n\t\tif (index == -1)\n\t\t\tthrow NotSuchElementException();\n\t\tremove(index);\n\t}\n\n\tvoid removeLastOccurrence(const E & e) {\n\t\tint index = lastIndexOf(e);\n\t\tif (index == -1)\n\t\t\tthrow NotSuchElementException();\n\t\tremove(index);\n\t}\n\n\tvoid removeAll(const E & e); // TODO\n};\n\n#include \"source.cpp\"\n\nint main() {\n\tint size;\n\tcin >> size;\n\tLinkedList<double> list;\n\tI(i, size) {\n\t\tint val;\n\t\tcin >> val;\n\t\tlist.addLast(val);\n\t}\n\tint val;\n\tcin >> val;\n\tlist.removeAll(val);\n\tI(i, list.size())\n\t\tcout << list.get(i) << endl;\n\n}\n",
            "template <typename E>\nvoid LinkedList<E>::removeAll(const E & e) {\n\twhile (true) {\n\t\tint index = indexOf(e);\n\t\tif (index == -1) break;\n\t\tremove(index);\n\t}\n}",
            "from random import randint\nsize = randint(5,9)\nto_remove = randint(1,99)\ndata = []\nfor i in range(size):\n\tif randint(0,1) == 0:\n\t\tdata.append(to_remove)\n\telse:\n\t\tdata.append(randint(1,99))\nprint(size)\nprint(' '.join(str(d) for d in data))\nprint(to_remove)\n",
            1594864800,
            1594870800
        ],
        [
            "A.3 (C++)",
            "在课堂上讲的哈希表的基础上，写一个以整数为键的只有一个类型参数的哈希表类, HT&lt;E&gt;。<br><p><span style=\"font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, &quot;Noto Sans&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 1rem;\">另外，请添加一个函数 getKeys，该函数返回所有二元组(tuple)中的键(key)。</span></p><p><span style=\"font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, &quot;Noto Sans&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 1rem; font-weight: bolder;\">HINT</span><span style=\"font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, &quot;Noto Sans&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 1rem;\">：尝试通过添加额外代码(&lt;10行)完成该题。</span><br></p><p><span style=\"font-weight: bolder;\">EXAMPLE INPUT</span></p><pre style=\"font-size: 14px;\">2000\n</pre><p><span style=\"font-weight: bolder;\">EXAMPLE OUTPUT</span></p><pre style=\"font-size: 14px;\">2000\ntext51\ntext151\ntext251\ntext351\ntext451\ntext551\ntext651\ntext751\ntext851\ntext951\ntext1051\ntext1151\ntext1251\ntext1351\ntext1451\ntext1551\ntext1651\ntext1751\ntext1851\ntext1951\n0</pre>",
            "\n#include \"source.cpp\"\n\n#include <iostream>\n#include <sstream>\nusing namespace std;\n\nint main() {\n\tint test_count;\n\tcin >> test_count;\n\tHT<string> map;\n\tfor (int i = 0; i < test_count; ++ i) {\n\t\tstringstream ss;\n\t\tss << \"text\" << (1 + i);\n\t\tmap.put(i * 10, ss.str());\n\t}\n\tcout << map.size() << endl;\n\tfor (int i = 0; i < test_count; ++ i) {\n\t\tif (! map.containsKey(i * 10)) {\n\t\t\tcout << \"bad\" << endl;\n\t\t}\n\t\telse if (i % 100 == 50) {\n\t\t\tcout << map[i * 10] << endl;\n\t\t}\n\t}\n\tvector<int> keys = map.getKeys();\n\tfor (int i = 0; i < keys.size(); ++ i) {\n\t\tmap.remove(keys[i]);\n\t}\n\tcout << map.size() << endl;\n}",
            "#include <iostream>\n#include <vector>\n#include <string>\n#include <stdexcept>\nusing namespace std;\n\n#define I(i,n) for (size_t i = 0; i < n; ++ i)\n\nclass NoSuchKeyException {};\n\nsize_t hash_function(const int & key) {\n\treturn key;\n}\n\ntemplate <typename K, typename V>\nclass HashTable\n{\n\tclass Tuple\n\t{\n\tpublic:\n\t\tK key;\n\t\tV val;\n\t\tbool in_use;\n\n\t\tTuple() : in_use(false) {}\n\t};\n\n\tvector<Tuple> tuples;\n\tsize_t _size;\n\n\tsize_t canonical_index(const K & key) const {\n\t\tsize_t hash_code = hash_function(key); // needs hash_function(K)\n\t\treturn hash_code % tuples.size();\n\t}\n\n\t// the returned tuple is either empty or with the same key\n\tsize_t indexOfKey(const K & key) const {\n\t\tsize_t index = canonical_index(key);\n\t\twhile (true) { // will enter a dead loop if there is not empty tuple\n\t\t\tif (! tuples[index].in_use) return index;\n\t\t\tif (tuples[index].key == key) return index;\n\t\t\tindex = (index + 1) % tuples.size();\n\t\t}\n\t}\n\npublic:\n\tHashTable() : _size(0) {\n\t\ttuples.resize(2);\n\t}\n\n\tbool containsKey(const K & key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\treturn tuples[index].in_use;\n\t}\n\n\tconst V & operator [] (const K & key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples[index].val;\n\t}\n\n\tV & operator [] (const K & key) {\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples[index].val;\n\t}\n\n\tvoid put(const K & key, const V & val) {\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].key = key;\n\t\ttuples[index].val = val;\n\t\tif (tuples[index].in_use) return;\n\t\ttuples[index].in_use = true;\n\t\t++ _size;\n\t\t// make sure empty > size / 2\n\t\tif (2 * _size > tuples.size())\n\t\t\t_double_tuples();\n\t}\n\n\tvoid _double_tuples() {\n\t\tvector<Tuple> non_empty_tuples;\n\t\tI(i, tuples.size())\n\t\t\tif (tuples[i].in_use)\n\t\t\t\tnon_empty_tuples.push_back(tuples[i]);\n\t\tclear();\n\t\ttuples.resize(tuples.size() * 2);\n\t\tI(i, non_empty_tuples.size())\n\t\t\tput(non_empty_tuples[i].key, non_empty_tuples[i].val);\n\t}\n\n\tstatic bool _between(size_t hole, size_t canonical, size_t tuple_index) {\n\t\tif (hole < tuple_index)\n\t\t\treturn canonical > hole && canonical <= tuple_index;\n\t\telse\n\t\t\treturn canonical > hole || canonical <= tuple_index;\n\t}\n\n\tvoid remove(const K & key) { \n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\ttuples[index].in_use = false;\n\t\t-- _size;\n\t\t// if there is a hole between a tuple and its canonical position\n\t\t// move the tuple to the hole\n\t\tsize_t hole = index;\n\t\tsize_t tuple_index = hole;\n\t\twhile (true) {\n\t\t\ttuple_index = (tuple_index + 1) % tuples.size();\n\t\t\tif (! tuples[tuple_index].in_use) return;\n\t\t\tsize_t canonical = canonical_index(tuples[tuple_index].key);\n\t\t\tif (_between(hole, canonical, tuple_index)) continue;\n\t\t\ttuples[hole] = tuples[tuple_index];\n\t\t\thole = tuple_index;\n\t\t\ttuples[hole].in_use = false;\n\t\t}\n\t}\n\n\tsize_t size() const { return _size; }\n\n\tvoid clear() {\n\t\tI(i, tuples.size())\n\t\t\ttuples[i].in_use = false;\n\t\t_size = 0;\n\t}\n\n\ttemplate <typename K2, typename V2>\n\tfriend ostream & operator << (ostream & out, const HashTable<K2,V2> & dict);\n\n\ttemplate <typename K2, typename V2>\n\tfriend istream & operator >> (istream & in, HashTable<K2,V2> & dict);\n\n\tvoid _inspect() const {\n\t\tI(i, tuples.size())\n\t\t\tif (tuples[i].in_use)\n\t\t\t\tcout << \"#\" << i << \" C\" << canonical_index(tuples[i].key) \n\t\t\t\t\t<< \" \" << tuples[i].key << \" \" << tuples[i].val << endl;\n\t}\n\t\n\tvector<K> getKeys() const {\n\t\tvector<K> keys;\n\t\tI(i, tuples.size())\n\t\t\tif (tuples[i].in_use)\n\t\t\t\tkeys.push_back(tuples[i].key);\n\t\treturn keys;\n\t}\n};\n\ntemplate <typename E>\nclass HT : public HashTable<int, E> {};",
            "from random import randint\nprint(randint(1000,2300))",
            1595469600,
            1595475600
        ],
        [
            "A.4 (C++)",
            "<p>写出一个键和值的类型都可以是string或int的哈希表类, HT。<br>本题难度大，<span style=\"font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, &quot;Noto Sans&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 1rem;\">参考</span><span style=\"font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, &quot;Noto Sans&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 1rem;\">答案有200行，截止时间延长4天。</span></p><p>注意<br></p><ol><li>HT不是一个模版类，但是HT的一个对象可以同时使用int和string的对象作为键。</li></ol><p><span style=\"font-weight: bolder;\">EXAMPLE INPUT</span></p><pre style=\"font-size: 14px;\">1 2 3 4 5 6 7 8\n</pre><p><span style=\"font-weight: bolder;\">EXAMPLE OUTPUT</span></p><pre style=\"font-size: 14px;\">4\n2\n4\n6\n8</pre>",
            "#include \"source.cpp\"\n\n#include <iostream>\n#include <sstream>\nusing namespace std;\n\nint main() {\n\tHT map;\n\t\n\tint key1;\n\tint value1;\n\tcin >> key1 >> value1;\n\tmap.put(key1, value1);\n\t\n\tstring key2;\n\tstring value2;\n\tcin >> key2 >> value2;\n\tmap.put(key2, value2);\n\t\n\tint key3;\n\tstring value3;\n\tcin >> key3 >> value3;\n\tmap.put(key3, value3);\n\t\n\tstring key4;\n\tint value4;\n\tcin >> key4 >> value4;\n\tmap.put(key4, value4);\n\t\n\tcout << map.size() << endl;\n\tcout << (int)map[key1] << endl;\n\tcout << (string)map[key2] << endl;\n\tcout << (string)map[key3] << endl;\n\tcout << (int)map[key4] << endl;\n}",
            "#include <iostream>\n#include <vector>\n#include <string>\n#include <stdexcept>\nusing namespace std;\n\n#define I(i,n) for (size_t i = 0; i < n; ++ i)\n\nclass NoSuchKeyException {};\n\ntemplate <typename K, typename V>\nclass HashTable\n{\n\tclass Tuple\n\t{\n\tpublic:\n\t\tK key;\n\t\tV val;\n\t\tbool in_use;\n\n\t\tTuple() : in_use(false) {}\n\t};\n\n\tvector<Tuple> tuples;\n\tsize_t _size;\n\n\tsize_t canonical_index(const K & key) const {\n\t\tsize_t hash_code = hash_function(key); // needs hash_function(K)\n\t\treturn hash_code % tuples.size();\n\t}\n\n\t// the returned tuple is either empty or with the same key\n\tsize_t indexOfKey(const K & key) const {\n\t\tsize_t index = canonical_index(key);\n\t\twhile (true) { // will enter a dead loop if there is not empty tuple\n\t\t\tif (! tuples[index].in_use) return index;\n\t\t\tif (tuples[index].key == key) return index;\n\t\t\tindex = (index + 1) % tuples.size();\n\t\t}\n\t}\n\npublic:\n\tHashTable() : _size(0) {\n\t\ttuples.resize(2);\n\t}\n\n\tbool containsKey(const K & key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\treturn tuples[index].in_use;\n\t}\n\n\tconst V & operator [] (const K & key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples[index].val;\n\t}\n\n\tV & operator [] (const K & key) {\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples[index].val;\n\t}\n\n\tvoid put(const K & key, const V & val) {\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].key = key;\n\t\ttuples[index].val = val;\n\t\tif (tuples[index].in_use) return;\n\t\ttuples[index].in_use = true;\n\t\t++ _size;\n\t\t// make sure empty > size / 2\n\t\tif (2 * _size > tuples.size())\n\t\t\t_double_tuples();\n\t}\n\n\tvoid _double_tuples() {\n\t\tvector<Tuple> non_empty_tuples;\n\t\tI(i, tuples.size())\n\t\t\tif (tuples[i].in_use)\n\t\t\t\tnon_empty_tuples.push_back(tuples[i]);\n\t\tclear();\n\t\ttuples.resize(tuples.size() * 2);\n\t\tI(i, non_empty_tuples.size())\n\t\t\tput(non_empty_tuples[i].key, non_empty_tuples[i].val);\n\t}\n\n\tstatic bool _between(size_t hole, size_t canonical, size_t tuple_index) {\n\t\tif (hole < tuple_index)\n\t\t\treturn canonical > hole && canonical <= tuple_index;\n\t\telse\n\t\t\treturn canonical > hole || canonical <= tuple_index;\n\t}\n\n\tvoid remove(const K & key) { \n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\ttuples[index].in_use = false;\n\t\t-- _size;\n\t\t// if there is a hole between a tuple and its canonical position\n\t\t// move the tuple to the hole\n\t\tsize_t hole = index;\n\t\tsize_t tuple_index = hole;\n\t\twhile (true) {\n\t\t\ttuple_index = (tuple_index + 1) % tuples.size();\n\t\t\tif (! tuples[tuple_index].in_use) return;\n\t\t\tsize_t canonical = canonical_index(tuples[tuple_index].key);\n\t\t\tif (_between(hole, canonical, tuple_index)) continue;\n\t\t\ttuples[hole] = tuples[tuple_index];\n\t\t\thole = tuple_index;\n\t\t\ttuples[hole].in_use = false;\n\t\t}\n\t}\n\n\tsize_t size() const { return _size; }\n\n\tvoid clear() {\n\t\tI(i, tuples.size())\n\t\t\ttuples[i].in_use = false;\n\t\t_size = 0;\n\t}\n\n\ttemplate <typename K2, typename V2>\n\tfriend ostream & operator << (ostream & out, const HashTable<K2,V2> & dict);\n\n\ttemplate <typename K2, typename V2>\n\tfriend istream & operator >> (istream & in, HashTable<K2,V2> & dict);\n\n\tvoid _inspect() const {\n\t\tI(i, tuples.size())\n\t\t\tif (tuples[i].in_use)\n\t\t\t\tcout << \"#\" << i << \" C\" << canonical_index(tuples[i].key) \n\t\t\t\t\t<< \" \" << tuples[i].key << \" \" << tuples[i].val << endl;\n\t}\n\t\n\tvector<K> getKeys() const {\n\t\tvector<K> keys;\n\t\tI(i, tuples.size())\n\t\t\tif (tuples[i].in_use)\n\t\t\t\tkeys.push_back(tuples[i].key);\n\t\treturn keys;\n\t}\n};\n\n\nsize_t hash_function(const int & key) {\n\treturn key;\n}\n\nsize_t circular_shift(size_t bits, int shift_bits) {\n\tconst int num_bits = 8 * sizeof(size_t);\n\tshift_bits = shift_bits % num_bits;\n\treturn bits << shift_bits | bits >> (num_bits - shift_bits);\n}\n\nsize_t hash_function(const string & key) {\n\tsize_t code = 0;\n\tI(i, key.size())\n\t\tcode ^= circular_shift(key[i], i * 5);\n\treturn code;\n}\n\nclass SI\n{\n\tbool is_int;\n\tint key1;\n\tstring key2;\npublic:\n\tSI() {}\n\tSI(int key) {\n\t\tis_int = true;\n\t\tkey1 = key;\n\t}\n\tSI(const string & key) {\n\t\tis_int = false;\n\t\tkey2 = key;\n\t}\n\tbool operator == (const SI & that) const {\n\t\tif (is_int != that.is_int) return false;\n\t\tif (is_int)\n\t\t\treturn key1 == that.key1;\n\t\treturn key2 == that.key2;\n\t}\n\tbool isInt() const {\n\t\treturn is_int;\n\t}\n\toperator int() const {\n\t\tif (! is_int) throw runtime_error(\"Cannot convert a string to an integer\");\n\t\treturn key1;\n\t}\n\toperator string() const {\n\t\tif (is_int) throw runtime_error(\"Cannot convert an integer to a string\");\n\t\treturn key2;\n\t}\n};\n\nsize_t hash_function(const SI & key) {\n\tif (key.isInt()) return hash_function(int(key));\n\treturn hash_function(string(key));\n}\n\nclass HT : public HashTable<SI, SI> {};",
            "from random import randint\nfor i in range(8):\n\tprint(randint(1,99), end=' ')",
            1594951200,
            1595854800
        ],
        [
            "A.5 (C++)",
            "<p>写出一个键和值的类型都可以是string或int的哈希表类, HT。<br>本题难度大，参考答案有270行，截止时间延长8天。<br>注意<br></p><ol><li>HT不是一个模版类，但是HT的一个对象可以同时使用int和string的对象作为键。</li><li>HT中去掉了put函数，HT的[]操作符同时具有get和put的功能。</li></ol><p><span style=\"font-weight: bolder;\">EXAMPLE INPUT</span></p><pre style=\"font-size: 14px;\">1 2 3 4 5 6 7 8\n</pre><p><span style=\"font-weight: bolder;\">EXAMPLE OUTPUT</span></p><pre style=\"font-size: 14px;\">4\n2\n4\n6\n8</pre>",
            "#include \"source.cpp\"\n\n#include <iostream>\n#include <sstream>\nusing namespace std;\n\nint main() {\n\tHT map;\n\t\n\tint key1;\n\tint value1;\n\tcin >> key1 >> value1;\n\tmap[key1] = value1;\n\t\n\tstring key2;\n\tstring value2;\n\tcin >> key2 >> value2;\n\tmap[key2] = value2;\n\t\n\tint key3;\n\tstring value3;\n\tcin >> key3 >> value3;\n\tmap[key3] = value3;\n\t\n\tstring key4;\n\tint value4;\n\tcin >> key4 >> value4;\n\tmap[key4] = value4;\n\t\n\tcout << map.size() << endl;\n\tcout << (int)map[key1] << endl;\n\tcout << (string)map[key2] << endl;\n\tcout << (string)map[key3] << endl;\n\tcout << (int)map[key4] << endl;\n}",
            "#include <iostream>\n#include <vector>\n#include <string>\n#include <stdexcept>\nusing namespace std;\n\n#define I(i,n) for (size_t i = 0; i < n; ++ i)\n\nclass NoSuchKeyException {};\n\ntemplate <typename K, typename V>\nclass HashTable\n{\n\tclass Tuple\n\t{\n\tpublic:\n\t\tK key;\n\t\tV val;\n\t\tbool in_use;\n\n\t\tTuple() : in_use(false) {}\n\t};\n\t\n\tclass _TupleRef\n\t{\n\tpublic:\n\t\tHashTable * table;\n\t\tTuple & tuple;\n\t\tconst K & key;\n\t\t_TupleRef(HashTable * table, Tuple & tuple, const K & key) \n\t\t\t: table(table), tuple(tuple), key(key) {}\n\t\t\n\t\toperator V() const {\n\t\t\tif (! tuple.in_use) throw NoSuchKeyException();\n\t\t\treturn tuple.val;\n\t\t}\n\t\t\n\t\t_TupleRef & operator = (const V & val) {\n\t\t\tif (tuple.in_use && tuple.key == key)\n\t\t\t\ttuple.val = val;\n\t\t\telse\n\t\t\t\ttable->_put(key, val);\n\t\t\treturn *this;\n\t\t}\n\t};\n\t\n\tvector<Tuple> tuples;\n\tsize_t _size;\n\n\tsize_t canonical_index(const K & key) const {\n\t\tsize_t hash_code = hash_function(key); // needs hash_function(K)\n\t\treturn hash_code % tuples.size();\n\t}\n\n\t// the returned tuple is either empty or with the same key\n\tsize_t indexOfKey(const K & key) const {\n\t\tsize_t index = canonical_index(key);\n\t\twhile (true) { // will enter a dead loop if there is not empty tuple\n\t\t\tif (! tuples[index].in_use) return index;\n\t\t\tif (tuples[index].key == key) return index;\n\t\t\tindex = (index + 1) % tuples.size();\n\t\t}\n\t}\n\npublic:\n\tHashTable() : _size(0) {\n\t\ttuples.resize(2);\n\t}\n\n\tbool containsKey(const K & key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\treturn tuples[index].in_use;\n\t}\n\n\tconst V & operator [] (const K & key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples[index].val;\n\t}\n\n\t_TupleRef operator [] (const K & key) {\n\t\tsize_t index = indexOfKey(key);\n\t\treturn _TupleRef(this, tuples[index], key);\n\t}\n\n\tvoid _put(const K & key, const V & val) {\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].key = key;\n\t\ttuples[index].val = val;\n\t\tif (tuples[index].in_use) return;\n\t\ttuples[index].in_use = true;\n\t\t++ _size;\n\t\t// make sure empty > size / 2\n\t\tif (2 * _size > tuples.size())\n\t\t\t_double_tuples();\n\t}\n\n\tvoid _double_tuples() {\n\t\tvector<Tuple> non_empty_tuples;\n\t\tI(i, tuples.size())\n\t\t\tif (tuples[i].in_use)\n\t\t\t\tnon_empty_tuples.push_back(tuples[i]);\n\t\tclear();\n\t\ttuples.resize(tuples.size() * 2);\n\t\tI(i, non_empty_tuples.size())\n\t\t\t_put(non_empty_tuples[i].key, non_empty_tuples[i].val);\n\t}\n\n\tstatic bool _between(size_t hole, size_t canonical, size_t tuple_index) {\n\t\tif (hole < tuple_index)\n\t\t\treturn canonical > hole && canonical <= tuple_index;\n\t\telse\n\t\t\treturn canonical > hole || canonical <= tuple_index;\n\t}\n\n\tvoid remove(const K & key) { \n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\ttuples[index].in_use = false;\n\t\t-- _size;\n\t\t// if there is a hole between a tuple and its canonical position\n\t\t// move the tuple to the hole\n\t\tsize_t hole = index;\n\t\tsize_t tuple_index = hole;\n\t\twhile (true) {\n\t\t\ttuple_index = (tuple_index + 1) % tuples.size();\n\t\t\tif (! tuples[tuple_index].in_use) return;\n\t\t\tsize_t canonical = canonical_index(tuples[tuple_index].key);\n\t\t\tif (_between(hole, canonical, tuple_index)) continue;\n\t\t\ttuples[hole] = tuples[tuple_index];\n\t\t\thole = tuple_index;\n\t\t\ttuples[hole].in_use = false;\n\t\t}\n\t}\n\n\tsize_t size() const { return _size; }\n\n\tvoid clear() {\n\t\tI(i, tuples.size())\n\t\t\ttuples[i].in_use = false;\n\t\t_size = 0;\n\t}\n\n\tvoid _inspect() const {\n\t\tI(i, tuples.size())\n\t\t\tif (tuples[i].in_use)\n\t\t\t\tcout << \"#\" << i << \" C\" << canonical_index(tuples[i].key) \n\t\t\t\t\t<< \" \" << tuples[i].key << \" \" << tuples[i].val << endl;\n\t}\n\t\n\tvector<K> getKeys() const {\n\t\tvector<K> keys;\n\t\tI(i, tuples.size())\n\t\t\tif (tuples[i].in_use)\n\t\t\t\tkeys.push_back(tuples[i].key);\n\t\treturn keys;\n\t}\n\t\n\tfriend class HT;\n};\n\n\nclass SI\n{\n\tbool is_int;\n\tint key1;\n\tstring key2;\npublic:\n\tSI() {}\n\tSI(int key) {\n\t\tis_int = true;\n\t\tkey1 = key;\n\t}\n\tSI(const string & key) {\n\t\tis_int = false;\n\t\tkey2 = key;\n\t}\n\tbool operator == (const SI & that) const {\n\t\tif (is_int != that.is_int) return false;\n\t\tif (is_int)\n\t\t\treturn key1 == that.key1;\n\t\treturn key2 == that.key2;\n\t}\n\tbool isInt() const {\n\t\treturn is_int;\n\t}\n\toperator int() const {\n\t\tif (! is_int) throw runtime_error(\"Cannot convert a string to an integer\");\n\t\treturn key1;\n\t}\n\toperator string() const {\n\t\tif (is_int) throw runtime_error(\"Cannot convert an integer to a string\");\n\t\treturn key2;\n\t}\n};\n\nsize_t hash_function(const int & key) {\n\treturn key;\n}\n\nsize_t circular_shift(size_t bits, int shift_bits) {\n\tconst int num_bits = 8 * sizeof(size_t);\n\tshift_bits = shift_bits % num_bits;\n\treturn bits << shift_bits | bits >> (num_bits - shift_bits);\n}\n\nsize_t hash_function(const string & key) {\n\tsize_t code = 0;\n\tI(i, key.size())\n\t\tcode ^= circular_shift(key[i], i * 5);\n\treturn code;\n}\n\nsize_t hash_function(const SI & key) {\n\tif (key.isInt()) return hash_function(int(key));\n\treturn hash_function(string(key));\n}\n\n\nclass HT\n{\n\tHashTable<SI, SI> ht;\npublic:\n\tbool containsKey(const SI & key) const {\n\t\treturn ht.containsKey(key);\n\t}\n\n\tconst SI & operator [] (const SI & key) const {\n\t\treturn ht[key];\n\t}\n\t\n\tclass _TupleRef\n\t{\n\tpublic:\n\t\tHashTable<SI, SI>::_TupleRef ref;\n\t\t_TupleRef(HashTable<SI, SI>::_TupleRef ref) : ref(ref) {}\n\t\t\n\t\toperator int() const {\n\t\t\treturn int(SI(ref));\n\t\t}\n\t\t\n\t\toperator string() const {\n\t\t\treturn string(SI(ref));\n\t\t}\n\t\t\n\t\t_TupleRef & operator = (const int & val) {\n\t\t\tref = val;\n\t\t\treturn *this;\n\t\t}\t\t\n\t\t_TupleRef & operator = (const string & val) {\n\t\t\tref = val;\n\t\t\treturn *this;\n\t\t}\t\t\n\t};\n\n\t_TupleRef operator [] (const SI & key) {\n\t\treturn _TupleRef(ht[key]);\n\t}\n\n\tvoid remove(const SI & key) {\n\t\tht.remove(key);\n\t}\n\n\tsize_t size() const { return ht.size(); }\n\n\tvoid clear() { ht.clear(); }\n\t\n\tvector<SI> getKeys() const { return ht.getKeys(); }\n\n};",
            "from random import randint\nfor i in range(8):\n\tprint(randint(1,99), end=' ')",
            1594951200,
            1596200400
        ]
    ],
    "table_name": "题目"
}