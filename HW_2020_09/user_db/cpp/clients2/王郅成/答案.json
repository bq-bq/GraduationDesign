{
    "__update_time__": 1595809190.8800113,
    "field_names": [
        "题目名",
        "用户名",
        "答案",
        "提交时间",
        "分数",
        "评语"
    ],
    "field_types": [
        "text",
        "text",
        "text",
        "time",
        "number",
        "text"
    ],
    "foreign_keys": {},
    "primary_keys": [],
    "rows": [
        [
            "测试2",
            "王郅成",
            "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nint main(){\n    char a[11][50],temp[50];\n    for (int i = 0; i < 10; i++)\n    {\n        cin >> a[i];\n    }\n    for (int i = 0; i < 9; i++)\n    {\n        for (int j = i+1; j < 10; j++)\n        {\n            if(strcmp(a[i],a[j])>0){\n                strcpy(temp, a[i]); \n                strcpy(a[i], a[j]);\n                strcpy(a[j], temp);\n            }\n        }\n        \n    }\n    for (int i = 0; i < 10; i++)\n    {\n        cout << a[i]<<' ';\n    }\n}",
            1587609371.8513777,
            100,
            "# 答案正确"
        ],
        [
            "测试1",
            "王郅成",
            "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nint main(){\n    char a[11][50],temp[50];\n    for (int i = 0; i < 3; i++)\n    {\n        cin >> a[i];\n    }\n    // for (int i = 0; i < 9; i++)\n    // {\n    //     for (int j = i+1; j < 10; j++)\n    //     {\n    //         if(strcmp(a[i],a[j])>0){\n    //             strcpy(temp, a[i]); \n    //             strcpy(a[i], a[j]);\n    //             strcpy(a[j], temp);\n    //         }\n    //     }\n        \n    // }\n    cout << a[2]<<' '<<a[1]<<' '<<a[0];\n\n}",
            1587609468.0803082,
            100,
            "# 答案正确"
        ],
        [
            "1.1 (C++)",
            "王郅成",
            "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nclass Matrix5x5\n{\npublic:\n    double a[5][5];\n    Matrix5x5()  {\n        for (int i = 0; i < 5; i++)\n        {\n            for (int j = 0; j < 5; j++)\n            {\n                a[i][j]=0;\n            }\n            \n        }\n    } \n    double get(int num_a,int num_b){\n        return this->a[num_a][num_b];\n    }\n    void set(int num_a,int num_b,double num_c){\n        this->a[num_a][num_b]=num_c;\n    }\n    Matrix5x5 operator + (Matrix5x5 &m1)\n    {\n        Matrix5x5 temp;\n        for (int i = 0; i < 5; i++)\n        {\n            for (int j = 0; j < 5; j++)\n            {\n                temp.a[i][j]=m1.a[i][j]+this->a[i][j];\n            }\n        }\n        return temp;\n    }\n};",
            1587698357.0628078,
            100,
            "# 答案正确"
        ],
        [
            "1.2 (C++)",
            "王郅成",
            "#include <iostream>\nusing namespace std;\n\nclass School\n{\n    public:\n        string name;\n        int age;\n    \n    School()\n    {\n        name=\"NO_NAME\";\n        age=0;\n    }\n    void setName(string a){\n        this->name = a;\n    }\n    void setAge(int year){\n        this->age = year;\n    }\n    void operator++(){\n        this->age=this->age + 1;\n    }\n};",
            1588213539.5435915,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/08",
            "王郅成",
            "#include <iostream>\n#include <cmath>\nusing namespace std;\n\ndouble & Tensor_get(int dimensions, int sizes[], double data[], int x0, int x1, int x2, int x3){\n    int a[4];\n    a[0]=x0;\n    a[1]=x1;\n    a[2]=x2;\n    a[3]=x3;\n    int num=0;\n    for (int i = 0; i < dimensions; i++)\n    {\n        num=num*10+a[i];\n    }\n    data[0]=num;\n    return *data;\n}\n\n",
            1588906172.7995152,
            100,
            "# 答案正确"
        ],
        [
            "2.1 (C++)",
            "王郅成",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    double * values;\npublic:\n    Matrix(int row, int column){\n        int total_size = row * column;\n        this->values = new double[total_size];\n        this->rows = row;\n        this->columns = column;\n        for (int i = 0; i < total_size; i++)\n        {\n            this->values[i] = 0;\n        }\n        \n    }\n\n    ~Matrix(){\n        delete [] this->values;\n    }\n\n    void print(){\n        for (int i = 0; i < this->rows; i++)\n        {\n            for (int j = 0; j < this->columns; j++)\n            {\n                cout << this->values[i*columns+j] << \"    \";\n    \n            }\n            cout <<\"\\n\";        \n        }\n        \n    }\n\n};",
            1589172239.5694096,
            100,
            "# 答案正确"
        ],
        [
            "2.2 (C++)",
            "王郅成",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    double * values;\npublic:\n    Matrix(int row, int column, double value[]){\n        int total_size = row * column;\n        this->values = new double[total_size];\n        this->rows = row;\n        this->columns = column;\n        for (int i = 0; i < total_size; i++)\n        {\n            this->values[i] = value[i];\n        }\n        \n    }\n\n    ~Matrix(){\n        delete [] this->values;\n    }\n\n    void print(){\n        for (int i = 0; i < this->rows; i++)\n        {\n            for (int j = 0; j < this->columns; j++)\n            {\n                if(this->values[i*columns+j]>=10)\n                cout << \"   \"<< this->values[i*columns+j] ;\n                else\n                cout << \"    \"<< this->values[i*columns+j] ;\n                \n            }\n            cout <<\"\\n\";        \n        }\n        \n    }\n\n};",
            1589172659.1472878,
            100,
            "# 答案正确"
        ],
        [
            "2.3 (C++)",
            "王郅成",
            "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    double * values;\npublic:\n    Matrix(int row, int column, double value[]){\n        int total_size = row * column;\n        this->values = new double[total_size];\n        this->rows = row;\n        this->columns = column;\n        for (int i = 0; i < total_size; i++)\n        {\n            this->values[i] = value[i];\n        }\n        \n    }\n\n    ~Matrix(){\n        delete [] this->values;\n    }\n\n    void print(){\n        for (int i = 0; i < this->rows; i++)\n        {\n            for (int j = 0; j < this->columns; j++)\n            {\n                //if(this->values[i*columns+j]>=10)\n                cout << \"    \"<< this->values[i*columns+j] ;\n                //else\n                //cout << \"    \"<< this->values[i*columns+j] ;\n                \n            }\n            cout <<\"\\n\";        \n        }\n        \n    }\n\n    Matrix(const Matrix & matrix2) {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        int total_size = this->rows*this->columns;\n        this->values = new double[total_size];\n        memcpy(this->values, matrix2.values ,sizeof(matrix2.values)*total_size);\n    }\n\n\n};",
            1589174244.3460233,
            100,
            "# 答案正确"
        ],
        [
            "2.5 (C++)",
            "王郅成",
            "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    double * values;\npublic:\n    Matrix(int row, int column, double value[]){\n        int total_size = row * column;\n        this->values = new double[total_size];\n        this->rows = row;\n        this->columns = column;\n        for (int i = 0; i < total_size; i++)\n        {\n            this->values[i] = value[i];\n        }\n        \n    }\n    Matrix(int row, int column){\n        int total_size = row * column;\n        this->values = new double[total_size];\n        this->rows = row;\n        this->columns = column;\n        for (int i = 0; i < total_size; i++)\n        {\n            this->values[i] = 0;\n        }\n        \n    }\n\n    ~Matrix(){\n        delete [] this->values;\n    }\n\n    void print(){\n        for (int i = 0; i < this->rows; i++)\n        {\n            for (int j = 0; j < this->columns; j++)\n            {\n                //if(this->values[i*columns+j]>=10)\n                cout << \"    \"<< this->values[i*columns+j] ;\n                //else\n                //cout << \"    \"<< this->values[i*columns+j] ;\n                \n            }\n            cout <<\"\\n\";        \n        }\n        \n    }\n\n    Matrix(const Matrix & matrix2) {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        int total_size = this->rows*this->columns;\n        this->values = new double[total_size];\n        memcpy(this->values, matrix2.values ,sizeof(matrix2.values)*total_size);\n    }\n\n    Matrix getRow(int row) {\n        double* map = NULL;\n        map = new double[this->columns+1];\n        for (int i = 0; i < this->columns; i++)\n        {\n            map[i]=this->values[(row-1)*this->columns+i];\n        }\n        Matrix m1(1,this->columns,map);\n        delete [] map;\n        return m1;\n        \n    }\n    Matrix getColumn(int column) {\n        double* map = NULL;\n        map = new double[this->rows+1];\n        for (int i = 0; i < this->rows; i++)\n        {\n            map[i]=this->values[i*this->columns+column-1];\n        }\n        Matrix m1(this->rows,1,map);\n        delete [] map;\n        return m1;\n        \n    }\n\n\n};",
            1589439557.189369,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/14",
            "王郅成",
            "#include <iostream>\nusing namespace std;\n\nvoid Tensor_print(int dimensions, const int sizes[], const double data[]){\n    cout << \"Tensor of \"<<sizes[0];\n    for (int i = 1; i < dimensions; i++)\n    {\n        cout << \"x\" << sizes[i] ;\n    }\n    cout << \"\\n\";\n    if(dimensions==1){\n        for (int i = 0; i < sizes[0]; i++)\n        {\n            cout << data[0] << \"\\n\";\n        }\n    }\n    if(dimensions==2){\n        for (int i = 0; i < sizes[0]; i++)\n        {\n            for (int j = 0; j < sizes[1]; j++)\n            {\n                cout <<\"    \"<<data[0];\n            }\n            cout << \"\\n\";\n            \n        }\n        \n    }\n    if(dimensions==3){\n        for (int i = 0; i < sizes[0]; i++)\n        {\n            cout <<\"data[\"<<i<<\"]\"<<\"\\n\";\n            for (int k = 0; k < sizes[1]; k++)\n            {\n                for (int j = 0; j < sizes[2]; j++)\n                {\n                    cout <<\"    \"<<data[0];\n                }\n                cout << \"\\n\";\n            \n            }\n        }\n        \n    }\n    if(dimensions==4){\n        for (int p = 0; p < sizes[0]; p++)\n        {\n            for (int i = 0; i < sizes[1]; i++)\n            {\n                cout <<\"data[\"<<p<<\"]\"<<\"[\"<<i<<\"]\"<<\"\\n\";\n                for (int k = 0; k < sizes[2]; k++)\n                {\n                    for (int j = 0; j < sizes[3]; j++)\n                    {\n                        cout <<\"    \"<<data[0];\n                    }\n                    cout << \"\\n\";\n            \n                }\n            }\n        }\n        \n    }\n    \n    \n}\n\n",
            1589423737.4917295,
            100,
            "# 答案正确"
        ],
        [
            "2.6 (C++)",
            "王郅成",
            "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    double * values;\npublic:\n    Matrix(int row, int column, double value[]){\n        int total_size = row * column;\n        this->values = new double[total_size];\n        this->rows = row;\n        this->columns = column;\n        for (int i = 0; i < total_size; i++)\n        {\n            this->values[i] = value[i];\n        }\n        \n    }\n    \n\n    ~Matrix(){\n        delete [] this->values;\n    }\n\n    void print(){\n        for (int i = 0; i < this->rows; i++)\n        {\n            for (int j = 0; j < this->columns; j++)\n            {\n                //if(this->values[i*columns+j]>=10)\n                cout << \"    \"<< this->values[i*columns+j] ;\n                //else\n                //cout << \"    \"<< this->values[i*columns+j] ;\n                \n            }\n            cout <<\"\\n\";        \n        }\n        \n    }\n\n    Matrix(const Matrix & matrix2) {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        int total_size = this->rows*this->columns;\n        this->values = new double[total_size];\n        memcpy(this->values, matrix2.values ,sizeof(matrix2.values)*total_size);\n    }\n\n        Matrix concatenateRows(const Matrix & matrix2)\n\t\t{\n\t\t\tdouble* map = NULL; \n\t\t\tmap = new double[(this->rows+matrix2.rows)*this->columns];\n\t\t\tint i=0;\n\t\t\tfor(;i<this->rows*this->columns;++i) map[i] = this->values[i];\n\t\t\tfor(int j=0;j<matrix2.rows*matrix2.columns;++j) map[i++] = matrix2.values[j];\n\t\t\tMatrix myMatrix(this->rows+matrix2.rows,this->columns,map);\n            delete [] map;\n\t\t\treturn myMatrix;\n\t\t}\n\t\n\t\tMatrix concatenateColumns(const Matrix & matrix2)\n\t\t{\n\t\t\t\n\t\t\tdouble* map = NULL; \n\t\t\t map = new double[this->rows*(this->columns+matrix2.columns)];\n\t\t\tint c=0;\n\t\t\tfor(int i=0;i<this->rows;++i)\n\t\t\t{\n\t\t\t\tfor(int j=0;j<this->columns;++j)map[c++] = this->values[i*columns+j];\n\t\t\t\tfor(int j=0;j<matrix2.columns;++j)map[c++] = matrix2.values[i*columns+j];\n\t\t\t}\n\t\t\tMatrix myMatrix(this->rows,this->columns+matrix2.columns,map);\n\t\t\tdelete [] map;\n            return myMatrix;\n\t\t}\n\n\n};",
            1589440153.2912657,
            100,
            "# 答案正确"
        ],
        [
            "2.9 (C++)",
            "王郅成",
            "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    double * values;\npublic:\n    Matrix(int row, int column, double value[]){\n        int total_size = row * column;\n        this->values = new double[total_size];\n        this->rows = row;\n        this->columns = column;\n        for (int i = 0; i < total_size; i++)\n        {\n            this->values[i] = value[i];\n        }\n        \n    }\n    Matrix(int row, int column){\n        int total_size = row * column;\n        this->values = new double[total_size];\n        this->rows = row;\n        this->columns = column;\n        for (int i = 0; i < total_size; i++)\n        {\n            this->values[i] = 0;\n        }\n        \n    }\n\n    ~Matrix(){\n        delete [] this->values;\n    }\n\n    void print(){\n        for (int i = 0; i < this->rows; i++)\n        {\n            for (int j = 0; j < this->columns; j++)\n            {\n                //if(this->values[i*columns+j]>=10)\n                cout << \"    \"<< this->values[i*columns+j] ;\n                //else\n                //cout << \"    \"<< this->values[i*columns+j] ;\n                \n            }\n            cout <<\"\\n\";        \n\n        }\n        \n    }\n\n    Matrix(const Matrix & matrix2) {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        int total_size = this->rows*this->columns;\n        this->values = new double[total_size];\n        memcpy(this->values, matrix2.values ,sizeof(matrix2.values)*total_size);\n    }\n    \n    \n    Matrix operator + (const Matrix & matrix2){\n        double* map = NULL;\n        map = new double[this->columns*this->rows];\n        int c=0;\n\t\tfor(int i=0;i<this->rows*this->columns;++i)\n\t\t{\n\t\t\tmap[c++] = matrix2.values[i] + this->values[i];\n\t\t}\n        Matrix myMatrix(this->rows,this->columns,map);\n\t\tdelete [] map;\n        return myMatrix;\n    \n    }\n\n    Matrix operator - (const Matrix & matrix2){\n        double* map = NULL;\n        map = new double[this->columns*this->rows];\n        int c=0;\n\t\tfor(int i=0;i<this->rows*this->columns;++i)\n\t\t{\n\t\t\tmap[c++] = this->values[i] - matrix2.values[i];\n\t\t}\n        Matrix myMatrix(this->rows,this->columns,map);\n\t\tdelete [] map;\n        return myMatrix;\n    \n    }\n    Matrix operator + (double va){\n        double* map = NULL;\n        map = new double[this->columns*this->rows];\n        int c=0;\n\t\tfor(int i=0;i<this->rows*this->columns;++i)\n\t\t{\n\t\t\tmap[c++] = va + this->values[i];\n\t\t}\n        Matrix myMatrix(this->rows,this->columns,map);\n\t\tdelete [] map;\n        return myMatrix;\n    \n    }\n\n    Matrix operator - (double va){\n        double* map = NULL;\n        map = new double[this->columns*this->rows];\n        int c=0;\n\t\tfor(int i=0;i<this->rows*this->columns;++i)\n\t\t{\n\t\t\tmap[c++] = this->values[i] - va;\n\t\t}\n        Matrix myMatrix(this->rows,this->columns,map);\n\t\tdelete [] map;\n        return myMatrix;\n    \n    }\n\n    \n\n\n\n\n\n\n};\n\n",
            1590028201.625912,
            100,
            "# 答案正确"
        ],
        [
            "2.4 (C++)",
            "王郅成",
            "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    double * values;\npublic:\n    Matrix(int row, int column, double value[]){\n        int total_size = row * column;\n        this->values = new double[total_size];\n        this->rows = row;\n        this->columns = column;\n        for (int i = 0; i < total_size; i++)\n        {\n            this->values[i] = value[i];\n        }\n        \n    }\n    Matrix(int row, int column){\n        int total_size = row * column;\n        this->values = new double[total_size];\n        this->rows = row;\n        this->columns = column;\n        for (int i = 0; i < total_size; i++)\n        {\n            this->values[i] = 0;\n        }\n        \n    }\n\n    ~Matrix(){\n        delete [] this->values;\n    }\n\n    void print(){\n        for (int i = 0; i < this->rows; i++)\n        {\n            for (int j = 0; j < this->columns; j++)\n            {\n                //if(this->values[i*columns+j]>=10)\n                cout << \"    \"<< this->values[i*columns+j] ;\n                //else\n                //cout << \"    \"<< this->values[i*columns+j] ;\n                \n            }\n            cout <<\"\\n\";        \n\n        }\n        \n    }\n\n    void set(int row, int column, double value){\n        this->values[(row-1)*this->columns+column-1] = value;\n    }\n\n    Matrix(const Matrix & matrix2) {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        int total_size = this->rows*this->columns;\n        this->values = new double[total_size];\n        memcpy(this->values, matrix2.values ,sizeof(matrix2.values)*total_size);\n    }\n    \n    Matrix operator = (const Matrix & matrix2){\n        \n        this->columns = matrix2.columns;\n        this->rows = matrix2.rows;\n        delete[] values;\n        values = new double[matrix2.columns*matrix2.rows];\n        int c=0;\n\t\tfor(int i=0;i<this->rows*this->columns;++i)\n\t\t{\n\t\t\tvalues[i] = matrix2.values[i];\n\t\t}\n        return (*this);\n    \n    }\n\n    Matrix operator + (const Matrix & matrix2){\n        double* map = NULL;\n        map = new double[this->columns*this->rows];\n        int c=0;\n\t\tfor(int i=0;i<this->rows*this->columns;++i)\n\t\t{\n\t\t\tmap[c++] = matrix2.values[i] + this->values[i];\n\t\t}\n        Matrix myMatrix(this->rows,this->columns,map);\n\t\tdelete [] map;\n        return myMatrix;\n    \n    }\n\n    Matrix operator - (const Matrix & matrix2){\n        double* map = NULL;\n        map = new double[this->columns*this->rows];\n        int c=0;\n\t\tfor(int i=0;i<this->rows*this->columns;++i)\n\t\t{\n\t\t\tmap[c++] = this->values[i] - matrix2.values[i];\n\t\t}\n        Matrix myMatrix(this->rows,this->columns,map);\n\t\tdelete [] map;\n        return myMatrix;\n    \n    }\n    Matrix operator + (double va){\n        double* map = NULL;\n        map = new double[this->columns*this->rows];\n        int c=0;\n\t\tfor(int i=0;i<this->rows*this->columns;++i)\n\t\t{\n\t\t\tmap[c++] = va + this->values[i];\n\t\t}\n        Matrix myMatrix(this->rows,this->columns,map);\n\t\tdelete [] map;\n        return myMatrix;\n    \n    }\n\n    Matrix operator - (double va){\n        double* map = NULL;\n        map = new double[this->columns*this->rows];\n        int c=0;\n\t\tfor(int i=0;i<this->rows*this->columns;++i)\n\t\t{\n\t\t\tmap[c++] = this->values[i] - va;\n\t\t}\n        Matrix myMatrix(this->rows,this->columns,map);\n\t\tdelete [] map;\n        return myMatrix;\n    \n    }\n\n    \n\n\n\n\n\n\n};\n\n",
            1590029259.5967917,
            100,
            "# 答案正确"
        ],
        [
            "2.7 (C++)",
            "王郅成",
            "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    double * values;\npublic:\n    Matrix(int row, int column, double value[]){\n        int total_size = row * column;\n        this->values = new double[total_size];\n        this->rows = row;\n        this->columns = column;\n        for (int i = 0; i < total_size; i++)\n        {\n            this->values[i] = value[i];\n        }\n        \n    }\n    Matrix(int row, int column){\n        int total_size = row * column;\n        this->values = new double[total_size];\n        this->rows = row;\n        this->columns = column;\n        for (int i = 0; i < total_size; i++)\n        {\n            this->values[i] = 0;\n        }\n        \n    }\n\n    ~Matrix(){\n        delete [] this->values;\n    }\n\n    void print(){\n        for (int i = 0; i < this->rows; i++)\n        {\n            for (int j = 0; j < this->columns; j++)\n            {\n                //if(this->values[i*columns+j]>=10)\n                cout << \"    \"<< this->values[i*columns+j] ;\n                //else\n                //cout << \"    \"<< this->values[i*columns+j] ;\n                \n            }\n            cout <<\"\\n\";        \n\n        }\n        \n    }\n\n    void set(int row, int column, double value){\n        this->values[(row-1)*this->columns+column-1] = value;\n    }\n\n    Matrix(const Matrix & matrix2) {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        int total_size = this->rows*this->columns;\n        this->values = new double[total_size];\n        memcpy(this->values, matrix2.values ,sizeof(matrix2.values)*total_size);\n    }\n    \n    Matrix operator = (const Matrix & matrix2){\n        \n        this->columns = matrix2.columns;\n        this->rows = matrix2.rows;\n        delete[] values;\n        values = new double[matrix2.columns*matrix2.rows];\n        int c=0;\n\t\tfor(int i=0;i<this->rows*this->columns;++i)\n\t\t{\n\t\t\tvalues[i] = matrix2.values[i];\n\t\t}\n        return (*this);\n    \n    }\n\n    Matrix operator + (const Matrix & matrix2){\n        double* map = NULL;\n        map = new double[this->columns*this->rows];\n        int c=0;\n\t\tfor(int i=0;i<this->rows*this->columns;++i)\n\t\t{\n\t\t\tmap[c++] = matrix2.values[i] + this->values[i];\n\t\t}\n        Matrix myMatrix(this->rows,this->columns,map);\n\t\tdelete [] map;\n        return myMatrix;\n    \n    }\n\n    Matrix operator - (const Matrix & matrix2){\n        double* map = NULL;\n        map = new double[this->columns*this->rows];\n        int c=0;\n\t\tfor(int i=0;i<this->rows*this->columns;++i)\n\t\t{\n\t\t\tmap[c++] = this->values[i] - matrix2.values[i];\n\t\t}\n        Matrix myMatrix(this->rows,this->columns,map);\n\t\tdelete [] map;\n        return myMatrix;\n    \n    }\n    Matrix operator + (double va){\n        double* map = NULL;\n        map = new double[this->columns*this->rows];\n        int c=0;\n\t\tfor(int i=0;i<this->rows*this->columns;++i)\n\t\t{\n\t\t\tmap[c++] = va + this->values[i];\n\t\t}\n        Matrix myMatrix(this->rows,this->columns,map);\n\t\tdelete [] map;\n        return myMatrix;\n    \n    }\n\n    Matrix operator - (double va){\n        double* map = NULL;\n        map = new double[this->columns*this->rows];\n        int c=0;\n\t\tfor(int i=0;i<this->rows*this->columns;++i)\n\t\t{\n\t\t\tmap[c++] = this->values[i] - va;\n\t\t}\n        Matrix myMatrix(this->rows,this->columns,map);\n\t\tdelete [] map;\n        return myMatrix;\n    \n    }\n\n    Matrix reshape(int r,int c)const{\n\t\t\tMatrix res(r,c);\n\t\t\tint index = 0;\n\t\t\tfor (int i = 0; i < c;i++){\n\t\t\t\tfor (int j = 0; j < r;j++){\n\t\t\t\t\tdouble ling ;\n\t\t\t\t\t\n\t\t\t\t\tling = this->values[index];\n\t\t\t\t\tindex+=this->columns;\n\t\t\t\t\tif(index>=r*c){\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t\tindex -= r * c;\n\t\t\t\t\t}\n\t\t\t\t\tres.values[j*c+i] = ling;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n    \n\n\n\n\n\n\n};\n\n",
            1590040823.0668383,
            100,
            "# 答案正确"
        ],
        [
            "2.8 (C++)",
            "王郅成",
            "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    double * values;\npublic:\n    Matrix(int row, int column, double value[]){\n        int total_size = row * column;\n        this->values = new double[total_size];\n        this->rows = row;\n        this->columns = column;\n        for (int i = 0; i < total_size; i++)\n        {\n            this->values[i] = value[i];\n        }\n        \n    }\n    Matrix(int row, int column){\n        int total_size = row * column;\n        this->values = new double[total_size];\n        this->rows = row;\n        this->columns = column;\n        for (int i = 0; i < total_size; i++)\n        {\n            this->values[i] = 0;\n        }\n        \n    }\n\n    ~Matrix(){\n        delete [] this->values;\n    }\n\n    void print(){\n        for (int i = 0; i < this->rows; i++)\n        {\n            for (int j = 0; j < this->columns; j++)\n            {\n                //if(this->values[i*columns+j]>=10)\n                cout << \"    \"<< this->values[i*columns+j] ;\n                //else\n                //cout << \"    \"<< this->values[i*columns+j] ;\n                \n            }\n            cout <<\"\\n\";        \n\n        }\n        \n    }\n\n    void set(int row, int column, double value){\n        this->values[(row-1)*this->columns+column-1] = value;\n    }\n\n    Matrix(const Matrix & matrix2) {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        int total_size = this->rows*this->columns;\n        this->values = new double[total_size];\n        memcpy(this->values, matrix2.values ,sizeof(matrix2.values)*total_size);\n    }\n    \n    Matrix operator = (const Matrix & matrix2){\n        \n        this->columns = matrix2.columns;\n        this->rows = matrix2.rows;\n        delete[] values;\n        values = new double[matrix2.columns*matrix2.rows];\n        int c=0;\n\t\tfor(int i=0;i<this->rows*this->columns;++i)\n\t\t{\n\t\t\tvalues[i] = matrix2.values[i];\n\t\t}\n        return (*this);\n    \n    }\n\n    Matrix operator + (const Matrix & matrix2){\n        double* map = NULL;\n        map = new double[this->columns*this->rows];\n        int c=0;\n\t\tfor(int i=0;i<this->rows*this->columns;++i)\n\t\t{\n\t\t\tmap[c++] = matrix2.values[i] + this->values[i];\n\t\t}\n        Matrix myMatrix(this->rows,this->columns,map);\n\t\tdelete [] map;\n        return myMatrix;\n    \n    }\n\n    Matrix operator - (const Matrix & matrix2){\n        double* map = NULL;\n        map = new double[this->columns*this->rows];\n        int c=0;\n\t\tfor(int i=0;i<this->rows*this->columns;++i)\n\t\t{\n\t\t\tmap[c++] = this->values[i] - matrix2.values[i];\n\t\t}\n        Matrix myMatrix(this->rows,this->columns,map);\n\t\tdelete [] map;\n        return myMatrix;\n    \n    }\n    Matrix operator + (double va){\n        double* map = NULL;\n        map = new double[this->columns*this->rows];\n        int c=0;\n\t\tfor(int i=0;i<this->rows*this->columns;++i)\n\t\t{\n\t\t\tmap[c++] = va + this->values[i];\n\t\t}\n        Matrix myMatrix(this->rows,this->columns,map);\n\t\tdelete [] map;\n        return myMatrix;\n    \n    }\n\n    Matrix operator - (double va){\n        double* map = NULL;\n        map = new double[this->columns*this->rows];\n        int c=0;\n\t\tfor(int i=0;i<this->rows*this->columns;++i)\n\t\t{\n\t\t\tmap[c++] = this->values[i] - va;\n\t\t}\n        Matrix myMatrix(this->rows,this->columns,map);\n\t\tdelete [] map;\n        return myMatrix;\n    \n    }\n\n    Matrix reshape(int r,int c)const{\n\t\t\tMatrix res(r,c);\n\t\t\tint index = 0;\n\t\t\tfor (int i = 0; i < c;i++){\n\t\t\t\tfor (int j = 0; j < r;j++){\n\t\t\t\t\tdouble ling ;\n\t\t\t\t\t\n\t\t\t\t\tling = this->values[index];\n\t\t\t\t\tindex+=this->columns;\n\t\t\t\t\tif(index>=r*c){\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t\tindex -= r * c;\n\t\t\t\t\t}\n\t\t\t\t\tres.values[j*c+i] = ling;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n    Matrix transpose(){\n\t\t\tint r=this->columns,c=this->rows;\n\t\t\tMatrix res(r,c);\n\t\t\tint index = 0;\n\t\t\tfor (int i = 0; i < c;i++){\n\t\t\t\tfor (int j = 0; j < r;j++){\n\t\t\t\t\tdouble ling ;\n\t\t\t\t\t\n\t\t\t\t\tling = this->values[index];\n\t\t\t\t\tindex++;\n\t\t\t\t\tres.values[j*c+i] = ling;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\n\n\n\n\n};\n\n",
            1590040864.6458669,
            100,
            "# 答案正确"
        ],
        [
            "2.10 (C++)",
            "王郅成",
            "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    double * values;\npublic:\n    Matrix(int row, int column, double value[]){\n        int total_size = row * column;\n        this->values = new double[total_size];\n        this->rows = row;\n        this->columns = column;\n        for (int i = 0; i < total_size; i++)\n        {\n            this->values[i] = value[i];\n        }\n        \n    }\n    Matrix(int row, int column){\n        int total_size = row * column;\n        this->values = new double[total_size];\n        this->rows = row;\n        this->columns = column;\n        for (int i = 0; i < total_size; i++)\n        {\n            this->values[i] = 0;\n        }\n        \n    }\n\n    ~Matrix(){\n        delete [] this->values;\n    }\n\n    void print(){\n        for (int i = 0; i < this->rows; i++)\n        {\n            for (int j = 0; j < this->columns; j++)\n            {\n                //if(this->values[i*columns+j]>=10)\n                cout << \"    \"<< this->values[i*columns+j] ;\n                //else\n                //cout << \"    \"<< this->values[i*columns+j] ;\n                \n            }\n            cout <<\"\\n\";        \n\n        }\n        \n    }\n\n    void set(int row, int column, double value){\n        this->values[(row-1)*this->columns+column-1] = value;\n    }\n\n    Matrix(const Matrix & matrix2) {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        int total_size = this->rows*this->columns;\n        this->values = new double[total_size];\n        memcpy(this->values, matrix2.values ,sizeof(matrix2.values)*total_size);\n    }\n    \n    Matrix operator = (const Matrix & matrix2){\n        \n        this->columns = matrix2.columns;\n        this->rows = matrix2.rows;\n        delete[] values;\n        values = new double[matrix2.columns*matrix2.rows];\n        int c=0;\n\t\tfor(int i=0;i<this->rows*this->columns;++i)\n\t\t{\n\t\t\tvalues[i] = matrix2.values[i];\n\t\t}\n        return (*this);\n    \n    }\n\n    Matrix operator + (const Matrix & matrix2){\n        double* map = NULL;\n        map = new double[this->columns*this->rows];\n        int c=0;\n\t\tfor(int i=0;i<this->rows*this->columns;++i)\n\t\t{\n\t\t\tmap[c++] = matrix2.values[i] + this->values[i];\n\t\t}\n        Matrix myMatrix(this->rows,this->columns,map);\n\t\tdelete [] map;\n        return myMatrix;\n    \n    }\n\n    Matrix operator - (const Matrix & matrix2){\n        double* map = NULL;\n        map = new double[this->columns*this->rows];\n        int c=0;\n\t\tfor(int i=0;i<this->rows*this->columns;++i)\n\t\t{\n\t\t\tmap[c++] = this->values[i] - matrix2.values[i];\n\t\t}\n        Matrix myMatrix(this->rows,this->columns,map);\n\t\tdelete [] map;\n        return myMatrix;\n    \n    }\n    Matrix operator + (double va){\n        double* map = NULL;\n        map = new double[this->columns*this->rows];\n        int c=0;\n\t\tfor(int i=0;i<this->rows*this->columns;++i)\n\t\t{\n\t\t\tmap[c++] = va + this->values[i];\n\t\t}\n        Matrix myMatrix(this->rows,this->columns,map);\n\t\tdelete [] map;\n        return myMatrix;\n    \n    }\n\n    Matrix operator - (double va){\n        double* map = NULL;\n        map = new double[this->columns*this->rows];\n        int c=0;\n\t\tfor(int i=0;i<this->rows*this->columns;++i)\n\t\t{\n\t\t\tmap[c++] = this->values[i] - va;\n\t\t}\n        Matrix myMatrix(this->rows,this->columns,map);\n\t\tdelete [] map;\n        return myMatrix;\n    \n    }\n\n    Matrix reshape(int r,int c)const{\n\t\t\tMatrix res(r,c);\n\t\t\tint index = 0;\n\t\t\tfor (int i = 0; i < c;i++){\n\t\t\t\tfor (int j = 0; j < r;j++){\n\t\t\t\t\tdouble ling ;\n\t\t\t\t\t\n\t\t\t\t\tling = this->values[index];\n\t\t\t\t\tindex+=this->columns;\n\t\t\t\t\tif(index>=r*c){\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t\tindex -= r * c;\n\t\t\t\t\t}\n\t\t\t\t\tres.values[j*c+i] = ling;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n    Matrix transpose(){\n\t\t\tint r=this->columns,c=this->rows;\n\t\t\tMatrix res(r,c);\n\t\t\tint index = 0;\n\t\t\tfor (int i = 0; i < c;i++){\n\t\t\t\tfor (int j = 0; j < r;j++){\n\t\t\t\t\tdouble ling ;\n\t\t\t\t\t\n\t\t\t\t\tling = this->values[index];\n\t\t\t\t\tindex++;\n\t\t\t\t\tres.values[j*c+i] = ling;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n    Matrix operator*(const Matrix &M)const\n\t\t{\n\t\t\tMatrix res(M.columns, M.columns);\n\t\t\tdouble ling=0;\n\t\t\tfor (int i = 0; i < this->rows;i++){\n\t\t\t\tfor (int j = 0; j < this->rows;j++){\n\t\t\t\t\tfor (int k = 0; k < this->columns;k++){\n\t\t\t\t\t\tling += this->values[i * this->columns + k] * M.values[k * M.columns + j];\n\n\t\t\t\t\t}\n\t\t\t\t\tres.values[i * M.columns + j]=ling;\n\t\t\t\t\tling = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tMatrix operator*(double v)const{\n\t\t\tMatrix res(this->rows,this->columns);\n\t\t\tfor (int i = 0; i < this->rows * this->columns;i++){\n\t\t\t\tres.values[i] = this->values[i] * v;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\n\n\n\n};\n\n",
            1590040913.5315583,
            100,
            "# 答案正确"
        ],
        [
            "2.11 (C++)",
            "王郅成",
            "#include <iostream>\n#include <cstring>\nusing namespace std;\n\n#define maxsize (int)52\n#define MAXsize 100000\n\nclass Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    double * values;\npublic:\n    Matrix(int row, int column, double value[]){\n        int total_size = row * column;\n        this->values = new double[total_size];\n        this->rows = row;\n        this->columns = column;\n        for (int i = 0; i < total_size; i++)\n        {\n            this->values[i] = value[i];\n        }\n        \n    }\n    Matrix(int row, int column){\n        int total_size = row * column;\n        this->values = new double[total_size];\n        this->rows = row;\n        this->columns = column;\n        for (int i = 0; i < total_size; i++)\n        {\n            this->values[i] = 0;\n        }\n        \n    }\n\n    ~Matrix(){\n        delete [] this->values;\n    }\n\n    void print(){\n        for (int i = 0; i < this->rows; i++)\n        {\n            for (int j = 0; j < this->columns; j++)\n            {\n                //if(this->values[i*columns+j]>=10)\n                cout << \"    \"<< this->values[i*columns+j] ;\n                //else\n                //cout << \"    \"<< this->values[i*columns+j] ;\n                \n            }\n            cout <<\"\\n\";        \n\n        }\n        \n    }\n\n    void set(int row, int column, double value){\n        this->values[(row-1)*this->columns+column-1] = value;\n    }\n\n    Matrix(const Matrix & matrix2) {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        int total_size = this->rows*this->columns;\n        this->values = new double[total_size];\n        memcpy(this->values, matrix2.values ,sizeof(matrix2.values)*total_size);\n    }\n    \n    Matrix operator = (const Matrix & matrix2){\n        \n        this->columns = matrix2.columns;\n        this->rows = matrix2.rows;\n        delete[] values;\n        values = new double[matrix2.columns*matrix2.rows];\n        int c=0;\n\t\tfor(int i=0;i<this->rows*this->columns;++i)\n\t\t{\n\t\t\tvalues[i] = matrix2.values[i];\n\t\t}\n        return (*this);\n    \n    }\n\n    Matrix operator + (const Matrix & matrix2){\n        double* map = NULL;\n        map = new double[this->columns*this->rows];\n        int c=0;\n\t\tfor(int i=0;i<this->rows*this->columns;++i)\n\t\t{\n\t\t\tmap[c++] = matrix2.values[i] + this->values[i];\n\t\t}\n        Matrix myMatrix(this->rows,this->columns,map);\n\t\tdelete [] map;\n        return myMatrix;\n    \n    }\n\n    Matrix operator - (const Matrix & matrix2){\n        double* map = NULL;\n        map = new double[this->columns*this->rows];\n        int c=0;\n\t\tfor(int i=0;i<this->rows*this->columns;++i)\n\t\t{\n\t\t\tmap[c++] = this->values[i] - matrix2.values[i];\n\t\t}\n        Matrix myMatrix(this->rows,this->columns,map);\n\t\tdelete [] map;\n        return myMatrix;\n    \n    }\n    Matrix operator + (double va){\n        double* map = NULL;\n        map = new double[this->columns*this->rows];\n        int c=0;\n\t\tfor(int i=0;i<this->rows*this->columns;++i)\n\t\t{\n\t\t\tmap[c++] = va + this->values[i];\n\t\t}\n        Matrix myMatrix(this->rows,this->columns,map);\n\t\tdelete [] map;\n        return myMatrix;\n    \n    }\n\n    Matrix operator - (double va){\n        double* map = NULL;\n        map = new double[this->columns*this->rows];\n        int c=0;\n\t\tfor(int i=0;i<this->rows*this->columns;++i)\n\t\t{\n\t\t\tmap[c++] = this->values[i] - va;\n\t\t}\n        Matrix myMatrix(this->rows,this->columns,map);\n\t\tdelete [] map;\n        return myMatrix;\n    \n    }\n\n    Matrix reshape(int r,int c)const{\n\t\t\tMatrix res(r,c);\n\t\t\tint index = 0;\n\t\t\tfor (int i = 0; i < c;i++){\n\t\t\t\tfor (int j = 0; j < r;j++){\n\t\t\t\t\tdouble ling ;\n\t\t\t\t\t\n\t\t\t\t\tling = this->values[index];\n\t\t\t\t\tindex+=this->columns;\n\t\t\t\t\tif(index>=r*c){\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t\tindex -= r * c;\n\t\t\t\t\t}\n\t\t\t\t\tres.values[j*c+i] = ling;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n    Matrix transpose(){\n\t\t\tint r=this->columns,c=this->rows;\n\t\t\tMatrix res(r,c);\n\t\t\tint index = 0;\n\t\t\tfor (int i = 0; i < c;i++){\n\t\t\t\tfor (int j = 0; j < r;j++){\n\t\t\t\t\tdouble ling ;\n\t\t\t\t\t\n\t\t\t\t\tling = this->values[index];\n\t\t\t\t\tindex++;\n\t\t\t\t\tres.values[j*c+i] = ling;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n    Matrix operator*(const Matrix &M)const\n\t\t{\n\t\t\tMatrix res(M.columns, M.columns);\n\t\t\tdouble ling=0;\n\t\t\tfor (int i = 0; i < this->rows;i++){\n\t\t\t\tfor (int j = 0; j < this->rows;j++){\n\t\t\t\t\tfor (int k = 0; k < this->columns;k++){\n\t\t\t\t\t\tling += this->values[i * this->columns + k] * M.values[k * M.columns + j];\n\n\t\t\t\t\t}\n\t\t\t\t\tres.values[i * M.columns + j]=ling;\n\t\t\t\t\tling = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tMatrix operator*(double v)const{\n\t\t\tMatrix res(this->rows,this->columns);\n\t\t\tfor (int i = 0; i < this->rows * this->columns;i++){\n\t\t\t\tres.values[i] = this->values[i] * v;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n    Matrix max()const{\n\t\t\tMatrix res(1, this->columns);\n\t\t\tint mindex = 0;\n\t\t\tint MAX = 0;\n\t\t\tif(this->rows!=1){\n\t\t\t\tfor (int j = 0; j < this->columns;j++){\n\t\t\t\t\tfor (int i = 0; i < this->rows;i++){\n\t\t\t\t\t\tif(this->values[i*this->columns+j]>MAX){\n\t\t\t\t\t\t\tMAX = this->values[i * this->columns + j];\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tres.values[j] = MAX;\n\t\t\t\t\tMAX = 0;\n\t\t\t\t}\n\n\t\t\t\t\t\n\t\t\t}else{\n\t\t\t\tfor (int i = 0; i < this->columns;i++){\n\t\t\t\t\tif(this->values[i]>MAX){\n\t\t\t\t\t\tMAX = this->values[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tres.columns = 1;\n\t\t\t\tres.values[0] = MAX;\n\t\t\t}\n\t\t\t\n\t\t\treturn res;\n\t\t}\n\t\tMatrix min() const\n\t\t{\n\t\t\tMatrix res(1, this->columns);\n\t\t\tint mindex = 0;\n\t\t\tint MAX = 10000000;\n\t\t\tif (this->rows != 1)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < this->columns; j++)\n\t\t\t\t{\n\t\t\t\t\tfor (int i = 0; i < this->rows; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (this->values[i * this->columns + j] < MAX)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tMAX = this->values[i * this->columns + j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tres.values[j] = MAX;\n\t\t\t\t\tMAX = MAXsize;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor (int i = 0; i < this->columns; i++)\n\t\t\t\t{\n\t\t\t\t\tif (this->values[i] < MAX)\n\t\t\t\t\t{\n\t\t\t\t\t\tMAX = this->values[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tres.columns = 1;\n\t\t\t\tres.values[0] = MAX;\n\t\t\t}\n\n\t\t\treturn res;\n\t\t}\n\t\tMatrix sum()const{\n\t\t\tdouble sum=0;\n\t\t\tMatrix res(1, this->columns);\n\t\t\tif(this->rows==1){\n\t\t\t\t\n\t\t\t\tfor (int i = 0; i < this->columns;i++){\n\t\t\t\t\tsum += this->values[i];\n\t\t\t\t}\n\t\t\t\tres.columns = 1;\n\t\t\t\tres.values[0] = sum;\n\t\t\t}else{\n\t\t\t\tfor (int j = 0; j < this->columns;j++){\n\t\t\t\t\tfor (int i = 0; i < this->rows;i++){\n\t\t\t\t\t\tsum += this->values[i * this->columns + j];\n\t\t\t\t\t}\n\t\t\t\t\tres.values[j] = sum;\n\t\t\t\t\tsum = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\n\n\n};\n\n",
            1590041001.4152699,
            100,
            "# 答案正确"
        ],
        [
            "2.12 (C++)",
            "王郅成",
            "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n#define maxsize (int)52\n#define MAXsize 100000\n\ndouble E(double a){\n\treturn exp(a);\n}\n\ndouble L(double a){\n\treturn log(a);\n}\n\ndouble A(double a){\n\treturn abs(a);\n}\n\nclass Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    double * values;\npublic:\n    Matrix(int row, int column, double value[]){\n        int total_size = row * column;\n        this->values = new double[total_size];\n        this->rows = row;\n        this->columns = column;\n        for (int i = 0; i < total_size; i++)\n        {\n            this->values[i] = value[i];\n        }\n        \n    }\n    Matrix(int row, int column){\n        int total_size = row * column;\n        this->values = new double[total_size];\n        this->rows = row;\n        this->columns = column;\n        for (int i = 0; i < total_size; i++)\n        {\n            this->values[i] = 0;\n        }\n        \n    }\n\n    ~Matrix(){\n        delete [] this->values;\n    }\n\n    void print(){\n        for (int i = 0; i < this->rows; i++)\n        {\n            for (int j = 0; j < this->columns; j++)\n            {\n                //if(this->values[i*columns+j]>=10)\n                cout << \"    \"<< this->values[i*columns+j] ;\n                //else\n                //cout << \"    \"<< this->values[i*columns+j] ;\n                \n            }\n            cout <<\"\\n\";        \n\n        }\n        \n    }\n\n    void set(int row, int column, double value){\n        this->values[(row-1)*this->columns+column-1] = value;\n    }\n\n    Matrix(const Matrix & matrix2) {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        int total_size = this->rows*this->columns;\n        this->values = new double[total_size];\n        memcpy(this->values, matrix2.values ,sizeof(matrix2.values)*total_size);\n    }\n    \n    Matrix operator = (const Matrix & matrix2){\n        \n        this->columns = matrix2.columns;\n        this->rows = matrix2.rows;\n        delete[] values;\n        values = new double[matrix2.columns*matrix2.rows];\n        int c=0;\n\t\tfor(int i=0;i<this->rows*this->columns;++i)\n\t\t{\n\t\t\tvalues[i] = matrix2.values[i];\n\t\t}\n        return (*this);\n    \n    }\n\n    Matrix operator + (const Matrix & matrix2){\n        double* map = NULL;\n        map = new double[this->columns*this->rows];\n        int c=0;\n\t\tfor(int i=0;i<this->rows*this->columns;++i)\n\t\t{\n\t\t\tmap[c++] = matrix2.values[i] + this->values[i];\n\t\t}\n        Matrix myMatrix(this->rows,this->columns,map);\n\t\tdelete [] map;\n        return myMatrix;\n    \n    }\n\n    Matrix operator - (const Matrix & matrix2){\n        double* map = NULL;\n        map = new double[this->columns*this->rows];\n        int c=0;\n\t\tfor(int i=0;i<this->rows*this->columns;++i)\n\t\t{\n\t\t\tmap[c++] = this->values[i] - matrix2.values[i];\n\t\t}\n        Matrix myMatrix(this->rows,this->columns,map);\n\t\tdelete [] map;\n        return myMatrix;\n    \n    }\n    Matrix operator + (double va){\n        double* map = NULL;\n        map = new double[this->columns*this->rows];\n        int c=0;\n\t\tfor(int i=0;i<this->rows*this->columns;++i)\n\t\t{\n\t\t\tmap[c++] = va + this->values[i];\n\t\t}\n        Matrix myMatrix(this->rows,this->columns,map);\n\t\tdelete [] map;\n        return myMatrix;\n    \n    }\n\n    Matrix operator - (double va){\n        double* map = NULL;\n        map = new double[this->columns*this->rows];\n        int c=0;\n\t\tfor(int i=0;i<this->rows*this->columns;++i)\n\t\t{\n\t\t\tmap[c++] = this->values[i] - va;\n\t\t}\n        Matrix myMatrix(this->rows,this->columns,map);\n\t\tdelete [] map;\n        return myMatrix;\n    \n    }\n\n    Matrix reshape(int r,int c)const{\n\t\t\tMatrix res(r,c);\n\t\t\tint index = 0;\n\t\t\tfor (int i = 0; i < c;i++){\n\t\t\t\tfor (int j = 0; j < r;j++){\n\t\t\t\t\tdouble ling ;\n\t\t\t\t\t\n\t\t\t\t\tling = this->values[index];\n\t\t\t\t\tindex+=this->columns;\n\t\t\t\t\tif(index>=r*c){\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t\tindex -= r * c;\n\t\t\t\t\t}\n\t\t\t\t\tres.values[j*c+i] = ling;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n    Matrix transpose(){\n\t\t\tint r=this->columns,c=this->rows;\n\t\t\tMatrix res(r,c);\n\t\t\tint index = 0;\n\t\t\tfor (int i = 0; i < c;i++){\n\t\t\t\tfor (int j = 0; j < r;j++){\n\t\t\t\t\tdouble ling ;\n\t\t\t\t\t\n\t\t\t\t\tling = this->values[index];\n\t\t\t\t\tindex++;\n\t\t\t\t\tres.values[j*c+i] = ling;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n    Matrix operator*(const Matrix &M)const\n\t\t{\n\t\t\tMatrix res(M.columns, M.columns);\n\t\t\tdouble ling=0;\n\t\t\tfor (int i = 0; i < this->rows;i++){\n\t\t\t\tfor (int j = 0; j < this->rows;j++){\n\t\t\t\t\tfor (int k = 0; k < this->columns;k++){\n\t\t\t\t\t\tling += this->values[i * this->columns + k] * M.values[k * M.columns + j];\n\n\t\t\t\t\t}\n\t\t\t\t\tres.values[i * M.columns + j]=ling;\n\t\t\t\t\tling = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tMatrix operator*(double v)const{\n\t\t\tMatrix res(this->rows,this->columns);\n\t\t\tfor (int i = 0; i < this->rows * this->columns;i++){\n\t\t\t\tres.values[i] = this->values[i] * v;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n    Matrix max()const{\n\t\t\tMatrix res(1, this->columns);\n\t\t\tint mindex = 0;\n\t\t\tint MAX = 0;\n\t\t\tif(this->rows!=1){\n\t\t\t\tfor (int j = 0; j < this->columns;j++){\n\t\t\t\t\tfor (int i = 0; i < this->rows;i++){\n\t\t\t\t\t\tif(this->values[i*this->columns+j]>MAX){\n\t\t\t\t\t\t\tMAX = this->values[i * this->columns + j];\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tres.values[j] = MAX;\n\t\t\t\t\tMAX = 0;\n\t\t\t\t}\n\n\t\t\t\t\t\n\t\t\t}else{\n\t\t\t\tfor (int i = 0; i < this->columns;i++){\n\t\t\t\t\tif(this->values[i]>MAX){\n\t\t\t\t\t\tMAX = this->values[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tres.columns = 1;\n\t\t\t\tres.values[0] = MAX;\n\t\t\t}\n\t\t\t\n\t\t\treturn res;\n\t\t}\n\t\tMatrix min() const\n\t\t{\n\t\t\tMatrix res(1, this->columns);\n\t\t\tint mindex = 0;\n\t\t\tint MAX = 10000000;\n\t\t\tif (this->rows != 1)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < this->columns; j++)\n\t\t\t\t{\n\t\t\t\t\tfor (int i = 0; i < this->rows; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (this->values[i * this->columns + j] < MAX)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tMAX = this->values[i * this->columns + j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tres.values[j] = MAX;\n\t\t\t\t\tMAX = MAXsize;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor (int i = 0; i < this->columns; i++)\n\t\t\t\t{\n\t\t\t\t\tif (this->values[i] < MAX)\n\t\t\t\t\t{\n\t\t\t\t\t\tMAX = this->values[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tres.columns = 1;\n\t\t\t\tres.values[0] = MAX;\n\t\t\t}\n\n\t\t\treturn res;\n\t\t}\n\t\tMatrix sum()const{\n\t\t\tdouble sum=0;\n\t\t\tMatrix res(1, this->columns);\n\t\t\tif(this->rows==1){\n\t\t\t\t\n\t\t\t\tfor (int i = 0; i < this->columns;i++){\n\t\t\t\t\tsum += this->values[i];\n\t\t\t\t}\n\t\t\t\tres.columns = 1;\n\t\t\t\tres.values[0] = sum;\n\t\t\t}else{\n\t\t\t\tfor (int j = 0; j < this->columns;j++){\n\t\t\t\t\tfor (int i = 0; i < this->rows;i++){\n\t\t\t\t\t\tsum += this->values[i * this->columns + j];\n\t\t\t\t\t}\n\t\t\t\t\tres.values[j] = sum;\n\t\t\t\t\tsum = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n        Matrix pow(double p){\n\t\t\tMatrix res(this->rows,this->columns);\n\t\t\tfor (int i = 0; i < this->rows;i++){\n\t\t\t\tfor (int j = 0; j < this->columns;j++){\n\t\t\t\t\tdouble ling = this->values[i * this->columns + j];\n\t\t\t\t\tdouble sum = 1;\n\t\t\t\t\tfor (int k = 0; k < p;k++){\n\t\t\t\t\t\tsum *= ling;\n\t\t\t\t\t}\n\t\t\t\t\tres.values[i * this->columns + j] = sum;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tMatrix exp(){\n\t\t\tint r = this->rows, c = this->columns;\n\t\t\tMatrix res(r, c);\n\t\t\tfor (int i = 0; i < r;i++){\n\t\t\t\tfor (int j = 0; j < c;j++){\n\t\t\t\t\tdouble ling=this->values[i*c+j];\n\t\t\t\t\tdouble sum = E(ling);\n\t\t\t\t\tres.values[i * c + j] = sum;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tMatrix log(){\n\t\t\tint r = this->rows, c = this->columns;\n\t\t\tMatrix res(r, c);\n\t\t\tfor (int i = 0; i < r; i++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < c; j++)\n\t\t\t\t{\n\t\t\t\t\tdouble ling = this->values[i * c + j];\n\t\t\t\t\tdouble sum = L(ling);\n\t\t\t\t\tres.values[i * c + j] = sum;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tMatrix abs(){\n\t\t\tint r = this->rows, c = this->columns;\n\t\t\tMatrix res(r, c);\n\t\t\tfor (int i = 0; i < r; i++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < c; j++)\n\t\t\t\t{\n\t\t\t\t\tdouble ling = this->values[i * c + j];\n\t\t\t\t\tdouble sum = A(ling);\n\t\t\t\t\tres.values[i * c + j] = sum;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\n\n\n};\n\n",
            1590041130.2774644,
            100,
            "# 答案正确"
        ],
        [
            "6.2 (C++)",
            "王郅成",
            "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n\ntemplate<typename T> class Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    T * values;\npublic:\n    Matrix(int row, int column, T value[]){\n        int total_size = row * column;\n        this->values = new T[total_size];\n        this->rows = row;\n        this->columns = column;\n        for (int i = 0; i < total_size; i++)\n        {\n            this->values[i] = value[i];\n        }\n        \n    }\n    Matrix(int row, int column){\n        int total_size = row * column;\n        this->values = new T[total_size];\n        this->rows = row;\n        this->columns = column;\n        for (int i = 0; i < total_size; i++)\n        {\n            this->values[i] = 0;\n        }\n        \n    }\n\n    ~Matrix(){\n        delete [] this->values;\n    }\n\n    void print(){\n        for (int i = 0; i < this->rows; i++)\n        {\n            for (int j = 0; j < this->columns; j++)\n            {\n                //if(this->values[i*columns+j]>=10)\n                cout << \"    \"<< this->values[i*columns+j] ;\n                //else\n                //cout << \"    \"<< this->values[i*columns+j] ;\n                \n            }\n            cout <<\"\\n\";        \n\n        }\n        \n    }\n    \n};\n",
            1590632210.2917185,
            100,
            "# 答案正确"
        ],
        [
            "6.1 (C++)",
            "王郅成",
            "#include <iostream>\n\n#include <string>\n#include <cstring>\n#include <vector>\n\nusing namespace std;\n\ntemplate <typename T>//任意类型定义\n\nclass Matrix{\n\tprivate:\n\t\tT *values;\n\t\tint rows;\n\t\tint colunms;\n\n\tpublic:\n\t\tMatrix(int r,int c){\n\t\t\tthis->rows = r, this->colunms = c;\n\t\t\tthis->values = new T[r * c ];\n\t\t\tmemset(values, 0, sizeof(T) * r * c);\n\t\t}\n\t\tMatrix(int r,int c,const T v[]){\n\t\t\tthis->rows = r, this->colunms = c;\n\t\t\tthis->values = new T[r * c ];\n\t\t\tfor (int i = 0; i < r * c;i++){\n\t\t\t\tthis->values[i] = v[i];\n\t\t\t}\n\t\t}\n\t\tMatrix(const Matrix & M){\n\t\t\tthis->rows = M.rows, this->colunms = M.colunms;\n\t\t\tint r = M.rows, c = M.colunms;\n\t\t\tthis->values = new T[M.rows * M.colunms];\n\t\t\tfor (int i = 0; i < r*c;i++){\n\t\t\t\t\n\t\t\t\t\tthis->values[i] = M.values[i];\n\t\t\t\t\n\t\t\t}\n\t\t\t//memcpy(this->values, M.values, sizeof(T) * M.rows * M.colunms );\n\t\t}\n\t\tMatrix operator=(const Matrix &other){\n\t\t\tthis->rows = other.rows, this->colunms = other.colunms;\n\t\t\tint r = this->rows, c = this->colunms;\n\t\t\tdelete[] values;\n\t\t\tthis->values = new T[r * c];\n\t\t\tfor (int i = 0; i < r * c;i++){\n\t\t\t\tthis->values[i] = other.values[i];\n\t\t\t}\n\t\t}\n\t\tvoid print(){\n\t\t\tint r = this->rows, c = this->colunms;\n\t\t\tfor (int i = 0; i < r; i++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < c;j++){\n\t\t\t\t\tcout << \"    \" << values[i * c + j];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t\tT & get(int x,int y){\n\t\t\treturn values[(x - 1) * this->colunms + y - 1];\n\t\t}\n\t\t~Matrix(){\n\t\t\tdelete[] values;\n\t\t}\n};",
            1590646403.560521,
            100,
            "# 答案正确"
        ],
        [
            "6.3 (C++)",
            "王郅成",
            "#include <iostream>\n\n#include <string>\n#include <cstring>\n#include <vector>\n\nusing namespace std;\n\n#define Max_index (int)52\n#define Max_size Max_index*Max_index\ntemplate <typename T>//任意类型定义\n\nclass Matrix{\n\tprivate:\n\t\tT *values;\n\t\tint rows;\n\t\tint colunms;\n\n\tpublic:\n\t\tMatrix(int r,int c){\n\t\t\tthis->rows = r, this->colunms = c;\n\t\t\tthis->values = new T[r * c ];\n\t\t\tmemset(values, 0, sizeof(T) * r * c);\n\t\t}\n\t\tMatrix(int r,int c,const double v[]){\n\t\t\tthis->rows = r, this->colunms = c;\n\t\t\tthis->values = new T[r * c ];\n\t\t\tfor (int i = 0; i < r * c;i++){\n\t\t\t\tthis->values[i] = v[i];\n\t\t\t}\n\t\t}\n\t\tMatrix(int r,int c,const vector<double> v){\n\t\t\tthis->rows = r, this->colunms = c;\n\t\t\tthis->values = new double[r * c];\n\t\t\tfor (int i = 0; i < r * c;i++){\n\t\t\t\tthis->values[i] = v[i];\n\t\t\t}\n\t\t}\n\t\tMatrix(const Matrix & M){\n\t\t\tthis->rows = M.rows, this->colunms = M.colunms;\n\t\t\tint r = M.rows, c = M.colunms;\n\t\t\tthis->values = new T[M.rows * M.colunms];\n\t\t\tfor (int i = 0; i < r*c;i++){\n\t\t\t\t\n\t\t\t\t\tthis->values[i] = M.values[i];\n\t\t\t\t\n\t\t\t}\n\t\t\t//memcpy(this->values, M.values, sizeof(T) * M.rows * M.colunms );\n\t\t}\n\t\tMatrix getColumn(int index){\n\t\t\tT va[Max_index];\n\t\t\tint r=this->rows,c=this->colunms;\n\t\t\tfor (int i = 0; i < r;i++){\n\t\t\t\tva[i] = this->values[i * c + index - 1];\n\t\t\t}\n\t\t\tMatrix res(r,1,va);\n\t\t\treturn res;\n\t\t}\n\t\tMatrix getRow(int index){\n\t\t\tT va[Max_index];\n\t\t\tint r = this->rows, c = this->colunms;\n\t\t\tfor (int i = 0; i < c;i++){\n\t\t\t\tva[i] = this->values[(index - 1) * c + i];\n\t\t\t}\n\t\t\tMatrix res(1, c, va);\n\t\t\treturn res;\n\t\t}\n\t\tMatrix concatenateColumns(const Matrix & M){\n\t\t\tT va[Max_index];\n\t\t\tint r = this->rows, c = this->colunms;\n\t\t\tfor (int i = 0; i < r;i++){\n\t\t\t\tfor (int j = 0; j < 2 * c;j++){\n\t\t\t\t\tif(j>=c){\n\t\t\t\t\t\tva[i * c * 2 + j] = M.values[i * c + j - c];\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tva[i * c * 2 + j] = this->values[i * c + j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tMatrix res(r, c * 2, va);\n\t\t\treturn res;\n\t\t}\n\t\tMatrix concatenateRows(const Matrix & M){\n\t\t\tT v[Max_index];\n\t\t\tint r = this->rows, c = this->colunms;\n\t\t\tfor (int i = 0; i < 2 * c * r;i++){\n\t\t\t\tif(i>=c*r){\n\t\t\t\t\tv[i] = M.values[i-r*c];\n\t\t\t\t}else {\n\t\t\t\t\tv[i] = this->values[i];\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tMatrix res(r * 2, c, v);\n\t\t\treturn res;\n\t\t}\n\t\tMatrix reshape(int x,int y){\n\t\t\tT v[Max_index];\n\t\t\tint r = this->rows, c = this->colunms;\n\t\t\tint id = 0;\n\t\t\tfor (int i = 0; i < y;i++){\n\t\t\t\tfor (int j = 0; j < x;j++){\n\t\t\t\t\tv[j * y + i] = this->values[id];\n\t\t\t\t\tid = id + c;\n\t\t\t\t\tif(id>=r*c){\n\t\t\t\t\t\tid -= r * c;\n\t\t\t\t\t\tid++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tMatrix ling(x, y, v);\n\t\t\treturn ling;\n\t\t}\n\t\tMatrix transpose(){\n\t\t\tT v[Max_index];\n\t\t\tint r = this->rows, c = this->colunms;\n\t\t\tfor (int i = 0; i < r;i++){\n\t\t\t\tfor (int j = 0; j < c;j++){\n\t\t\t\t\tv[i * c + j] = this->values[j * r + i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tMatrix res(c,r,v);\n\t\t\treturn res;\n\t\t}\n\t\tMatrix operator+(const Matrix & M){\n\t\t\tT v[Max_index];\n\t\t\tint r = this->rows, c = this->colunms;\n\t\t\tfor (int i = 0; i < r * c;i++){\n\t\t\t\tv[i] = this->values[i] + M.values[i];\n\t\t\t}\n\t\t\tMatrix res(r,c,v);\n\t\t\treturn res;\n\t\t}\n\t\tMatrix operator+(const T val){\n\t\t\tT v[Max_index];\n\t\t\tint r = this->rows, c = this->colunms;\n\t\t\tfor (int i = 0; i < r * c;i++){\n\t\t\t\tv[i] = this->values[i] + val;\n\t\t\t}\n\t\t\tMatrix res(r, c, v);\n\t\t\treturn res;\n\t\t}\n\t\tMatrix operator-(const Matrix & M){\n\t\t\tT v[Max_index];\n\t\t\tint r = this->rows, c = this->colunms;\n\t\t\tfor (int i = 0; i < r * c;i++){\n\t\t\t\tv[i] = this->values[i] - M.values[i];\n\t\t\t}\n\t\t\tMatrix res(r, c, v);\n\t\t\treturn res;\n\t\t}\n\t\tMatrix operator-(const T val){\n\t\t\tT v[Max_index];\n\t\t\tint r = this->rows, c = this->colunms;\n\t\t\tfor (int i = 0; i < r * c; i++)\n\t\t\t{\n\t\t\t\tv[i] = this->values[i] - val;\n\t\t\t}\n\t\t\tMatrix res(r, c, v);\n\t\t\treturn res;\n\t\t}\n\t\tMatrix operator=(const Matrix &other){\n\t\t\tthis->rows = other.rows, this->colunms = other.colunms;\n\t\t\tint r = this->rows, c = this->colunms;\n\t\t\t\n\t\t\t\n\t\t\tfor (int i = 0; i < r * c;i++){\n\t\t\t\tthis->values[i] = other.values[i];\n\t\t\t}\n\t\t\treturn (*this);\n\t\t}\n\t\tMatrix operator*(const Matrix & M){\n\t\t\tT v[Max_index];\n\t\t\tint r = this->rows, c = this->colunms;\n\t\t\tdouble ling = 0;\n\t\t\tfor (int x = 0; x < r;x++){\n\t\t\t\tfor (int y = 0; y < r;y++){\n\t\t\t\t\tfor (int k = 0; k < c;k++){\n\t\t\t\t\t\tling += this->values[x * c + k] * M.values[k * M.colunms + y];\n\t\t\t\t\t}\n\t\t\t\t\tv[x * r + y] = ling;\n\t\t\t\t\tling = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tMatrix res(r,r,v);\n\t\t\treturn res;\n\t\t}\n\t\tMatrix operator*(const T val){\n\t\t\tT v[Max_index];\n\t\t\tint r = this->rows, c = this->colunms;\n\t\t\tfor (int i = 0; i < r * c;i++){\n\t\t\t\tv[i] = this->values[i] * val;\n\t\t\t}\n\t\t\tMatrix res(r, c, v);\n\t\t\treturn res;\n\t\t}\n\t\tMatrix max(){\n\t\t\tT v[Max_index];\n\t\t\tint r=this->rows,c=this->colunms;\n\t\t\tdouble maxn = 0;\n\t\t\tif(r!=1){\n\t\t\t\tfor (int i = 0; i < c;i++){\n\t\t\t\t\tfor (int j =0 ; j < r;j++){\n\t\t\t\t\t\tif(this->values[j*c+i]>maxn)\n\t\t\t\t\t\t\tmaxn = this->values[j * c + i];\n\t\t\t\t\t}\n\t\t\t\t\tv[i] = maxn;\n\t\t\t\t\tmaxn = 0;\n\t\t\t\t}\n\t\t\t\tMatrix res(1, c, v);\n\t\t\t\treturn res;\n\t\t\t}else{\n\t\t\t\tfor (int i = 0; i < c;i++){\n\t\t\t\t\tif(this->values[i]>maxn)\n\t\t\t\t\t\tmaxn = this->values[i];\n\t\t\t\t}\n\t\t\t\tv[0] = maxn;\n\t\t\t\tMatrix res(1, 1, v);\n\t\t\t\treturn res;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tMatrix min()\n\t\t{\n\t\t\tT v[Max_index];\n\t\t\tint r = this->rows, c = this->colunms;\n\t\t\tdouble maxn = Max_size;\n\t\t\tif (r != 1)\n\t\t\t{\n\t\t\t\tfor (int i = 0; i < c; i++)\n\t\t\t\t{\n\t\t\t\t\tfor (int j = 0; j < r; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (this->values[j * c + i] < maxn)\n\t\t\t\t\t\t\tmaxn = this->values[j * c + i];\n\t\t\t\t\t}\n\t\t\t\t\tv[i] = maxn;\n\t\t\t\t\tmaxn = Max_size;\n\t\t\t\t}\n\t\t\t\tMatrix res(1, c, v);\n\t\t\t\treturn res;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor (int i = 0; i < c; i++)\n\t\t\t\t{\n\t\t\t\t\tif (this->values[i] < maxn)\n\t\t\t\t\t\tmaxn = this->values[i];\n\t\t\t\t}\n\t\t\t\tv[0] = maxn;\n\t\t\t\tMatrix res(1, 1, v);\n\t\t\t\treturn res;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tMatrix sum(){\n\t\t\tT v[Max_index];\n\t\t\tint r = this->rows, c = this->colunms;\n\t\t\tdouble sumn = 0;\n\t\t\tif(r!=1){\n\t\t\t\tfor (int j = 0; j < c;j++){\n\t\t\t\t\tfor (int i = 0; i < r;i++){\n\t\t\t\t\t\tsumn += this->values[i * c + j];\n\t\t\t\t\t}\n\t\t\t\t\tv[j] = sumn;\n\t\t\t\t\tsumn = 0;\n\t\t\t\t}\n\t\t\t\tMatrix res(1, c, v);\n\t\t\t\treturn res;\n\t\t\t}else {\n\t\t\t\tfor (int i = 0; i < c;i++){\n\t\t\t\t\tsumn += this->values[i];\n\t\t\t\t}\n\t\t\t\tv[0] = sumn;\n\t\t\t\tMatrix res(1, 1, v);\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\t\tvoid print(){\n\t\t\tint r = this->rows, c = this->colunms;\n\t\t\tfor (int i = 0; i < r; i++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < c;j++){\n\t\t\t\t\tcout << \"    \" << values[i * c + j];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t\tT & get(int x,int y){\n\t\t\treturn values[(x - 1) * this->colunms + y - 1];\n\t\t}\n\t\t~Matrix(){\n\t\t\tdelete[] values;\n\t\t}\n};",
            1590647674.783441,
            100,
            "# 答案正确"
        ],
        [
            "7.2 (C++)",
            "王郅成",
            "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\nvector<string> split(string s,char ch=' '){\n    int start=0;\n    int len=0;\n    vector<string> ret;\n    for(int i=0;i<s.length();i++){\n        if(s[i]==ch){\n            ret.push_back(s.substr(start,len));\n            start=i+1;\n            len=0;\n        }\n        else{\n            len++;\n        }\n    }\n    if(start<s.length())\n        ret.push_back(s.substr(start,len));\n    return ret;\n}",
            1591236813.8500667,
            100,
            "# 答案正确"
        ],
        [
            "7.1 (C++)",
            "王郅成",
            "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <math.h>\nusing namespace std;\nclass Triangle : public GeometricObject \n{\nprivate:\n\tdouble side1, side2, side3;\n\t\npublic:\n\tTriangle()\n\t{\n\t\tthis->side1 = this->side2 = this->side3 = 1;\n\t\t\n\t}\n\tTriangle(double a, double b, double c)\n\t{\n\t\tthis->side1 = a;\n\t\tthis->side2 = b;\n\t\tthis->side3 = c;\n\t\t\n\t}\n\tdouble getSide1(){\n\t\treturn this->side1;\n\t}double getSide2(){\n\t\treturn this->side2;\n\t}double getSide3(){\n\t\treturn this->side3;\n\t}\n\tdouble getArea()\n\t{\n\t\tdouble a = this->side1, b = this->side2, c = this->side3;\n\t\tdouble s = (a + b + c) / 2;\n\t\tdouble res = sqrt(s * (s - a) * (s - b) * (s - c));\n\t\treturn res;\n\t}\n\tdouble getPerimeter()\n\t{\n\t\tdouble res = this->side3 + this->side2 + this->side1;\n\t\treturn res;\n\t}\n};",
            1591250817.465003,
            100,
            "# 答案正确"
        ],
        [
            "7.3 (C++)",
            "王郅成",
            "template <typename A, typename R>\nvector<R> map2(const vector<A> &x, const vector<A> &y, R (*map_func)(const A &,const A &))\n{\n\tvector<R> res;\n\tfor (int i = 0; i < x.size();i++){\n\t\tres.push_back(map_func(x[i], y[i]));\n\t}\n\treturn res;\n}\n\ntemplate <typename A, typename R>\nvector<R> map2(const vector<A> &x, const int & y, R (*map_func)(const A &, const int &))\n{\n\tvector<R> res;\n\tfor (int i = 0; i < x.size(); i++)\n\t{\n\t\tres.push_back(map_func(x[i], y));\n\t}\n\treturn res;\n}\n",
            1591250831.7821832,
            100,
            "# 答案正确"
        ],
        [
            "8.5 (C++)",
            "王郅成",
            "class Point3D:public Point2D{\n\tprivate:\n\t\tdouble z;\n\tpublic:\n\t\tPoint3D(double x,double y,double z){\n\t\t\tsetX(x);\n\t\t\tsetY(y);\n\t\t\tthis->z = z;\n\t\t}\n\t\t\n\t\tvirtual double getZ(){\n\t\t\treturn this->z;\n\t\t}\n\t\t double distance(Point3D & a){\n\t\t\tdouble dx = this->getX() - a.getX();\n\t\t\tdouble dy = this->getY() - a.getY();\n\t\t\tdouble dz = this->getZ() - a.getZ();\n\t\t\treturn sqrt(dx * dx + dy * dy + dz * dz);\n\t\t}\n};",
            1591846778.2974284,
            87,
            "# 答案不正确\n\n# 随机输入:\n17 22 25\n281 161 179\n\n\n# 参考答案:\npoint1.getX() = 17\npoint1.getY() = 22\npoint1.getZ() = 25\npoint2.getX() = 281\npoint2.getY() = 161\npoint2.getZ() = 179\npoint1.distance(point2) = 335.757\n\n\n# 我的答案:\npoint1.getX() = 17\npoint1.getY() = 22\npoint1.getZ() = 25\npoint2.getX() = 281\npoint2.getY() = 161\npoint2.getZ() = 179\npoint1.distance(point2) = 298.357\n"
        ],
        [
            "8.1 (C++)",
            "王郅成",
            "class Full:public Matrix {\n\tprivate:\n\t\tdouble *values;\n\t\tint row;\n\t\tint colunm;\n\n\tpublic:\n\t\tFull(int r,int c){\n\t\t\tthis->row = r, this->colunm = c;\n\t\t\tthis->values = new double[r * c];\n\t\t\tfor (int i = 0; i < r * c;i++)\n\t\t\t\tthis->values[i] = 0;\n\t\t}\n\t\tFull(int r,int c,double v[]){\n\t\t\tthis->row = r, this->colunm = c;\n\t\t\tthis->values = new double[r * c];\n\t\t\tfor (int i = 0; i < r * c;i++)\n\t\t\t\tthis->values[i] = v[i];\n\t\t}\n\t\tFull(const Matrix & M){\n\t\t\tthis->row = M.size(1), this->colunm = M.size(2);\n\t\t\tthis->values = new double[M.size(1) * M.size(2)];\n\t\t\tfor (int i = 0; i <  this->row;i++){\n\t\t\t\tfor (int j = 0; j < this->colunm;j++){\n\t\t\t\t\tthis->values[i * this->colunm + j] = M.get(i+1, j+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//delete[] this->values;\n\t\t}\n\t\t~Full(){\n\t\t\tif(this->values != NULL){\n\t\t\t\t\n\t\t\t\tdelete[] values;\n\t\t\t\tthis->values=0;\n\t\t\t}\n\t\t}\n\t\tint size(int dimension)const{\n\t\t\tif(dimension==1)\n\t\t\t\treturn this->row;\n\t\t\telse if(dimension==2)\n\t\t\t\treturn this->colunm;\n\t\t}\n\t\tvoid set(int r,int c,double v){\n\t\t\tint index = (r-1) * this->colunm + c - 1;\n\t\t\tthis->values[index] = v;\n\t\t}\n\t\tdouble get(int r,int c)const{\n\t\t\tint index = (r-1) * this->colunm + c - 1;\n\t\t\treturn this->values[index];\n\t\t}\n\t\tvoid print()const{\n\t\t\tint r = this->row, c = this->colunm;\n\t\t\tfor (int i = 0; i < r;i++){\n\t\t\t\tfor (int j = 0; j < c;j++){\n\t\t\t\t\tcout << \"    \" << values[i * c + j];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t\tMatrix & operator=(const Matrix & matrix2){\n\t\t\tthis->row = matrix2.size(1), this->colunm = matrix2.size(2);\n\t\t\t\n\t\t\tfor (int i = 0; i < this->row; i++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < this->colunm; j++)\n\t\t\t\t{\n\t\t\t\t\tthis->values[i * this->colunm + j] = matrix2.get(i+1, j+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//return (*this);\n\t\t}\n};",
            1591855036.6263835,
            100,
            "# 答案正确"
        ],
        [
            "8.3 (C++)",
            "王郅成",
            "#include <iostream>\nusing namespace std;\nclass Sparse:public Matrix {\n\tprivate:\n\t\tEntry *values;\n\t\tint row;\n\t\tint colunm;\n\t\tint point;\n\n\tpublic:\n\t\tSparse(int r,int c){\n\t\t\tthis->row = r, this->colunm = c;\n\t\t\tthis->values = new Entry[10];\n\t\t\tthis->point = 0;\n\t\t}\n\t\t\n\t\t~Sparse(){\n\t\t\tif(this->values != NULL)\n\t\t\tdelete[] this->values;\n\t\t}\n\t\tint size(int dimension)const{\n\t\t\treturn this->point;\n\t\t}\n\t\tvoid set(int r,int c,double v){\n\t\t\tthis->values[this->point].row = r;\n\t\t\tthis->values[this->point].column = c;\n\t\t\tthis->values[this->point].value = v;\n\t\t\tthis->point++;\n\t\t}\n\t\tdouble get(int r,int c)const{\n\t\t\tfor (int i = 0; i < this->point;i++){\n\t\t\t\tif(r==this->values[i].row && c==this->values[i].column)\n\t\t\t\t\treturn this->values[i].value;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tint compare(Entry & a,Entry & b){\n\t\t\tif(a.row>b.row)\n\t\t\t\treturn 1;\n\t\t\tif(a.row==b.row && a.column>b.column)\n\t\t\t\treturn 1;\n\t\t\tif(a.row==b.row && a.column==b.column)\n\t\t\t\treturn 2;\n\t\t\treturn 0;\n\t\t}\n\t\tvoid print(){\n\t\t\tint r = this->point;\n\t\t\tEntry temp;\n\t\t\tfor (int i = 0; i < r;i++){\n\t\t\t\tfor (int j = r - 2; j >= i;j--){\n\t\t\t\t\tif(compare(this->values[j],this->values[j+1])==1){\n\t\t\t\t\t\ttemp = this->values[j];\n\t\t\t\t\t\tthis->values[j] = this->values[j + 1];\n\t\t\t\t\t\tthis->values[j + 1] = temp;\n\t\t\t\t\t}\n\t\t\t\t\telse if (compare(this->values[j], this->values[j + 1]) == 2){\n\t\t\t\t\t\tfor (int k = j + 1; j < this->point-1;j++){\n\t\t\t\t\t\t\tthis->values[k] = this->values[k + 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis->point--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\tfor (int i = 0; i < r; i++)\n\t\t\t\t{\n\t\t\t\t\tif (this->values[i].value == 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tcout << \"(\" << this->values[i].row << \",\" << this->values[i].column << \",\" << this->values[i].value<<\")\";\n\t\t\t\t\tcout << endl;\n\t\t\t\t}\n\t\t}\n\t\tSparse operator+ (const Sparse & a){\n\t\t\tSparse result(a.row,a.colunm);\n\t\t\tfor (int i = 0; i < this->point;i++){\n\t\t\t\tresult.values[i].row = this->values[i].row;\n\t\t\t\tresult.values[i].column = this->values[i].column;\n\t\t\t\tresult.values[i].value = this->values[i].value + a.get(this->values[i].row, this->values[i].column);\n\t\t\t}\n\t\t\tfor (int i = 0; i < a.point; i++)\n\t\t\t{\n\t\t\t\tresult.values[i + this->point].row = a.values[i].row;\n\t\t\t\tresult.values[i + this->point].column = a.values[i].column;\n\t\t\t\tresult.values[i + this->point].value = this->get(result.values[i + this->point].row, result.values[i + this->point].column) + a.values[i].value;\n\t\t\t}\n\t\t\tresult.point = this->point+a.point;\n\t\t\treturn result;\n\t\t}\n};\n",
            1591855068.9182153,
            100,
            "# 答案正确"
        ],
        [
            "8.4 (C++)",
            "王郅成",
            "#include <iostream>\nusing namespace std;\nclass Sparse:public Matrix {\n\tprivate:\n\t\tEntry *values;\n\t\tint row;\n\t\tint colunm;\n\t\tint point;\n\n\tpublic:\n\t\tSparse(int r,int c){\n\t\t\tthis->row = r, this->colunm = c;\n\t\t\tthis->values = new Entry[100];\n\t\t\tthis->point = 0;\n\t\t}\n\t\t\n\t\t~Sparse(){\n\t\t\tif(this->values != NULL)\n\t\t\tdelete[] this->values;\n\t\t}\n\t\tint size(int dimension)const{\n\t\t\treturn this->point;\n\t\t}\n\t\tvoid set(int r,int c,double v){\n\t\t\tthis->values[this->point].row = r;\n\t\t\tthis->values[this->point].column = c;\n\t\t\tthis->values[this->point].value = v;\n\t\t\tthis->point++;\n\t\t}\n\t\tdouble get(int r=-1,int c=-1)const{\n\t\t\tdouble sum = 0;\n\t\t\tfor (int i = 0; i < this->point;i++){\n\t\t\t\tif((r==-1 && c==this->values[i].column) || (c==-1 && r == this->values[i].row)\n\t\t\t\t|| (r==this->values[i].row && c==this->values[i].column))\n\t\t\t\t\treturn this->values[i].value;\n\t\t\t}\n\t\t\t\n\t\t\treturn sum;\n\t\t}\n\t\tint compare(Entry & a,Entry & b){\n\t\t\tif(a.row>b.row)\n\t\t\t\treturn 1;\n\t\t\tif(a.row==b.row && a.column>b.column)\n\t\t\t\treturn 1;\n\t\t\tif(a.row==b.row && a.column==b.column)\n\t\t\t\treturn 2;\n\t\t\treturn 0;\n\t\t}\n\t\tvoid print(){\n\t\t\t\n\t\t\tEntry temp;\n\t\t\tfor (int i = 0; i < this->point;i++){\n\t\t\t\tfor (int j = this->point - 2; j >= i;j--){\n\t\t\t\t\tif(compare(this->values[j],this->values[j+1])==1){\n\t\t\t\t\t\ttemp = this->values[j];\n\t\t\t\t\t\tthis->values[j] = this->values[j + 1];\n\t\t\t\t\t\tthis->values[j + 1] = temp;\n\t\t\t\t\t}\n\t\t\t\t\telse if (compare(this->values[j], this->values[j + 1]) == 2){\n\t\t\t\t\t\tthis->values[j].value += this->values[j + 1].value;\n\t\t\t\t\t\tfor (int k = j + 1; k < this->point;k++){\n\t\t\t\t\t\t\tthis->values[k] = this->values[k + 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis->point--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\tfor (int i = 0; i < this->point; i++)\n\t\t\t\t{\n\t\t\t\t\t/*if(i==r-2)\n\t\t\t\t\t\tcontinue;*/\n\t\t\t\t\tcout << \"(\" << this->values[i].row << \",\" << this->values[i].column << \",\" << this->values[i].value<<\")\";\n\t\t\t\t\tcout << endl;\n\t\t\t\t}\n\t\t}\n\t\tSparse operator* (const Sparse & a){\n\t\t\tSparse result(a.row,a.colunm);\n\t\t\tfor (int i = 0; i < this->point;i++){\n\t\t\t\tfor (int j = 0; j < a.point;j++){\n\t\t\t\t\tif(this->values[i].column==a.values[j].row){\n\t\t\t\t\t\tresult.values[result.point].row = this->values[i].row;\n\t\t\t\t\t\tresult.values[result.point].column = a.values[j].column;\n\t\t\t\t\t\tresult.values[result.point].value = this->values[i].value * a.values[j].value;\n\t\t\t\t\t\tresult.point++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\treturn result;\n\t\t}\n};\n\n",
            1591855086.2003047,
            100,
            "# 答案正确"
        ],
        [
            "8.6 (C++)",
            "王郅成",
            "#include<vector>\n#include<iostream>\nusing namespace std;\nclass MyTensor : public Tensor<double>\n{\nprivate:\n    vector<double> temp;\n\npublic:\n    MyTensor(vector<int> indexes) : Tensor(indexes)\n    {\n        int num = 1;\n        for (int i = 0; i < indexes.size(); i++)\n        {\n            num *= indexes[i];\n        }\n        temp.resize(num);\n    }\n    ~MyTensor(){};\n    double &get(const vector<int> &indexes)\n    {\n        int a = 0;\n        for (int i = 0; i < indexes.size(); i++)\n        {\n            if (i == indexes.size() - 1)\n            {\n                a += indexes[i];\n                break;\n            }\n            int temp = indexes[i];\n            for (int j = i + 1; j < indexes.size(); j++)\n            {\n                temp *= sizes[j];\n            }\n            a += temp;\n        }\n        return temp[a];\n    }\n};\n",
            1592448825.851957,
            100,
            "# 答案正确"
        ],
        [
            "9.1 (C++)",
            "王郅成",
            "class Circle{\n\tprivate:\n\t\tdouble value;\n\tpublic:\n\t\tCircle(double v){\n\t\t\tthis->value = v;\n\t\t}\n\t\tint operator<=(Circle & other){\n\t\t\tdouble a = this->value;\n\t\t\tif(a < other.value || a==other.value){\n\t\t\t\treturn 1;\n\t\t\t}else\n\t\t\t\treturn 0;\n\t\t}\n\t\tint operator<(Circle & o){\n\t\t\tdouble a = this->value;\n\t\t\tif(a < o.value)\n\t\t\t\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t\tint operator==(Circle & o){\n\t\t\tif(this->value==o.value)\n\t\t\t\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t\tint operator!=(Circle & o){\n\t\t\tif(*this == o)\n\t\t\t\treturn 0;\n\t\t\treturn 1;\n\t\t}\n\t\tint operator>=(Circle & o){\n\t\t\tif(this->value<o.value)\n\t\t\t\treturn 0;\n\t\t\treturn 1;\n\t\t}\n\t\tint operator>(Circle & o){\n\t\t\tif(this->value>o.value)\n\t\t\t\treturn 1;\n\t\t\treturn 0;\n\t\t}\n};",
            1593069766.7180946,
            100,
            "# 答案正确"
        ],
        [
            "9.2 (C++)",
            "王郅成",
            "class I{\n\tprivate:\n\t\tvector<int> sizes;\n\n\tpublic:\n\t\t\n\t\tI(int a,int b=-1,int c=-1,int d=-1){\n\t\t\tsizes.push_back(a);\n\t\t\tif(b!=-1)\n\t\t\t\tsizes.push_back(b);\n\t\t\tif(c!=-1)\n\t\t\t\tsizes.push_back(c);\n\t\t\tif(d!=-1)\n\t\t\t\tsizes.push_back(d);\n\t\t}\n\t\t\n\t\toperator vector<int>() const{\n\t\t\treturn this->sizes;\n\t\t}\n\n};",
            1593069793.1261516,
            100,
            "# 答案正确"
        ],
        [
            "9.3 (C++)",
            "王郅成",
            "class Complex{\n\tprivate:\n\t\tdouble reals;\n\t\tdouble image;\n\tpublic:\n\t\tComplex(double a,double b){\n\t\t\tthis->reals = a;\n\t\t\tthis->image = b;\n\t\t}\n\t\tdouble real(){\n\t\t\treturn this->reals;\n\t\t}\n\t\tdouble imag(){\n\t\t\treturn this->image;\n\t\t}\n\t\tComplex operator+ (Complex & o){\n\t\t\tdouble a = this->reals + o.reals;\n\t\t\tdouble b = this->image + o.image;\n\t\t\tComplex sum(a, b);\n\t\t\treturn sum;\n\t\t}\n\t\tComplex operator-(Complex &o)\n\t\t{\n\t\t\tdouble a = this->reals - o.reals;\n\t\t\tdouble b = this->image - o.image;\n\t\t\tComplex sum(a, b);\n\t\t\treturn sum;\n\t\t}\n\t\tComplex operator*(Complex &o)\n\t\t{\n\t\t\tdouble a = this->reals * o.reals - this->image * o.image;\n\t\t\tdouble b = this->image * o.reals + this->reals * o.image;\n\t\t\tComplex sum(a, b);\n\t\t\treturn sum;\n\t\t}\n\t\tComplex operator/ (Complex &o)\n\t\t{\n\t\t\tdouble r = this->reals, i = this->image;\n\t\t\tdouble a = (r * o.reals + i * o.image) / (o.reals * o.reals + o.image * o.image);\n\t\t\tdouble b = (i * o.reals - r * o.image) / (o.reals * o.reals + o.image * o.image);\n\t\t\tComplex sum(a, b);\n\t\t\treturn sum;\n\t\t}\n\t\tComplex operator-(double o)\n\t\t{\n\t\t\tdouble a = this->reals - o;\n\t\t\tdouble b = this->image;\n\t\t\tComplex sum(a, b);\n\t\t\treturn sum;\n\t\t}\n\t\t\n\t\tComplex & operator+=(Complex &o)\n\t\t{\n\t\t\tthis->reals = this->reals + o.reals;\n\t\t\tthis->image = this->image + o.image;\n\t\t\treturn (*this);\n\t\t}\n\t\tComplex & operator-=(Complex &o)\n\t\t{\n\t\t\tthis->reals = this->reals - o.reals;\n\t\t\tthis->image = this->image - o.image;\n\t\t\treturn (*this);\n\t\t}\n\t\tComplex & operator*=(Complex &o)\n\t\t{\n\t\t\tdouble r = this->reals, i = this->image;\n\t\t\tthis->reals = r * o.reals - i * o.image;\n\t\t\tthis->image = i * o.reals + r * o.image;\n\t\t\treturn (*this);\n\t\t}\n\t\tComplex & operator/=(Complex & o){\n\t\t\tdouble r = this->reals, i = this->image;\n\t\t\tthis->reals = (r * o.reals + i * o.image) / (o.reals * o.reals + o.image * o.image);\n\t\t\tthis->image = (i * o.reals - r * o.image) / (o.reals * o.reals + o.image * o.image);\n\t\t\treturn *this;\n\t\t}\n\t\t\n};\n\nComplex operator+(double o, Complex &oth)\n{\n\tdouble a = oth.real() + o;\n\tdouble b = oth.imag();\n\tComplex sum(a, b);\n\treturn sum;\n}\nint operator==(Complex &a,Complex &b){\n\tif(a.real()==b.real() && a.imag()==b.imag())\n\t\treturn 1;\n\treturn 0;\n}\nint operator!=(Complex &a,Complex &b){\n\tif(a==b)\n\t\treturn 0;\n\treturn 1;\n}",
            1593069836.0460994,
            100,
            "# 答案正确"
        ],
        [
            "9.4 (C++)",
            "王郅成",
            "class Complex{\n\tprivate:\n\t\tdouble reals;\n\t\tdouble image;\n\tpublic:\n\t\tComplex(double a,double b){\n\t\t\tthis->reals = a;\n\t\t\tthis->image = b;\n\t\t}\n\t\tComplex (){\n\t\t\tthis->image = this->reals = 0;\n\t\t}\n\t\tdouble set_real(double a){\n\t\t\t this->reals=a;\n\t\t}\n\t\tdouble set_imag(double a){\n\t\t\tthis->image=a;\n\t\t}\n\t\tdouble getv(int n){\n\t\t\tif(n==0)\n\t\t\t\treturn this->reals;\n\t\t\treturn this->image;\n\t\t}\n\t\tComplex operator+(Complex & o){\n\t\t\tdouble r = this->reals + o.reals;\n\t\t\tdouble i = this->image + o.image;\n\t\t\tComplex sum(r, i);\n\t\t\treturn sum;\n\t\t}\n\t\tComplex operator-(Complex & o){\n\t\t\tdouble r = this->reals - o.reals;\n\t\t\tdouble i = this->image - o.image;\n\t\t\tComplex sum(r, i);\n\t\t\treturn sum;\n\t\t}\n};\n\nistream & operator >> (istream &in,Complex & o){\n\tdouble r, c;\n\tin >> r >> c;\n\to.set_real(r);\n\to.set_imag(c);\n\treturn in;\n}\nostream & operator << (ostream&out,Complex & o){\n\tout << o.getv(0) << \" + \" << o.getv(1) << \" i\" ;\n}",
            1593069885.4541426,
            100,
            "# 答案正确"
        ],
        [
            "9.5 (C++)",
            "王郅成",
            "class Complex{\n\tprivate:\n\t\tdouble reals;\n\t\tdouble image;\n\tpublic:\n\t\tComplex(double a,double b){\n\t\t\tthis->reals = a;\n\t\t\tthis->image = b;\n\t\t}\n\t\tComplex (){\n\t\t\tthis->image = this->reals = 0;\n\t\t}\n\t\tComplex(Complex & o){\n\t\t\tthis->reals = o.reals;\n\t\t\tthis->image = o.image;\n\t\t}\n\t\tvoid set_real(double a){\n\t\t\t this->reals=a;\n\t\t}\n\t\tvoid set_imag(double a){\n\t\t\tthis->image=a;\n\t\t}\n\t\tdouble getv(int n)const{\n\t\t\tif(n==0)\n\t\t\t\treturn this->reals;\n\t\t\telse if(n==1)\n\t\t\t\treturn this->image;\n\t\t}\n\t\toperator double() \n\t\t{\n\t\t\treturn this->reals;\n\t\t}\n\t\tComplex operator ++(int){\n\t\t\tComplex res(*this);\n\t\t\t\n\t\t\tthis->reals++;\n\t\t\treturn res;\n\t\t}\n\t\tComplex & operator ++(){\n\t\t\tthis->reals++;\n\t\t\treturn *this;\n\t\t}\n\t\t\n};\n\nistream & operator >> (istream &in,Complex & o){\n\tdouble r, c;\n\tin >> r >> c;\n\to.set_real(r);\n\to.set_imag(c);\n\treturn in;\n}\nostream & operator << (ostream & out,const Complex & o){\n\tout << o.getv(0) << \" + \" << o.getv(1) << \" i\" ;\n}",
            1593069912.918105,
            100,
            "# 答案正确"
        ],
        [
            "9.6 (C++)",
            "王郅成",
            "class Tensor{\n\tprivate:\n\t\tint sizes[4];\n\t\tdouble *data;\n\t\tint numl;\n\n\tpublic:\n\t\tTensor(int a,int b=-1,int c=-1,int d=-1){\n\t\t\tint count = 1;\n\t\t\tint sum=a;\n\t\t\tthis->sizes[1] = a;\n\t\t\tif(b!= -1){\n\t\t\t\tcount++;\n\t\t\t\tthis->sizes[2] = b;\n\t\t\t\tsum *= b;\n\t\t\t}if(c!=-1){\n\t\t\t\tcount++;\n\t\t\t\tthis->sizes[3] = c;\n\t\t\t\tsum *= c;\n\t\t\t}if(d!=-1){\n\t\t\t\tcount++;\n\t\t\t\tthis->sizes[count] = d;\n\t\t\t\tsum *= d;\n\t\t\t}\n\t\t\tthis->numl = count;\n\t\t\tdata = new double[sum];\n\t\t}\n\t\t~Tensor(){\n\t\t\tdelete[] data;\n\t\t}\n\t\tdouble & operator()(int a,int b=-1,int c=-1,int d=-1){\n\t\t\tint index = a;\n\t\t\tif(b!=-1){\n\t\t\t\tindex += b * this->sizes[1];\n\t\t\t}\n\t\t\tif(c!=-1){\n\t\t\t\tindex += c * this->sizes[1] * this->sizes[2];\n\t\t\t}if(d!=-1){\n\t\t\t\tindex += d * this->sizes[1] * this->sizes[2] * this->sizes[3];\n\t\t\t}\n\t\t\treturn data[index];\n\t\t}\n};",
            1593069943.8860955,
            100,
            "# 答案正确"
        ],
        [
            "9.7 (C++)",
            "王郅成",
            "class Tensor{\n\tprivate:\n\t\tint sizes[5];\n\t\tdouble *data;\n\t\tint numl;\n\n\tpublic:\n\t\tTensor(int a,int b=-1,int c=-1,int d=-1){\n\t\t\tint count = 1;\n\t\t\tint sum=a;\n\t\t\tfor (int i = 0; i <= 4;i++)\n\t\t\t\tsizes[i] = 0;\n\t\t\tthis->sizes[1] = a;\n\t\t\tif(b!= -1){\n\t\t\t\tcount++;\n\t\t\t\tthis->sizes[2] = b;\n\t\t\t\tsum *= b;\n\t\t\t}if(c!=-1){\n\t\t\t\tcount++;\n\t\t\t\tthis->sizes[3] = c;\n\t\t\t\tsum *= c;\n\t\t\t}if(d!=-1){\n\t\t\t\tcount++;\n\t\t\t\tthis->sizes[count] = d;\n\t\t\t\tsum *= d;\n\t\t\t}\n\t\t\tthis->numl = count;\n\t\t\tdata = new double[sum];\n\t\t}\n\t\tint get(int n){\n\t\t\t\n\t\t\treturn this->sizes[n];\n\t\t}\n\t\tvoid set_value(double va[]){\n\t\t\tint max = 1;\n\t\t\tfor (int i = 0; i < numl;i++)\n\t\t\t\tmax *= sizes[i + 1];\n\t\t\tfor (int i = 0; i < max;i++)\n\t\t\t\tthis->data[i] = va[i];\n\t\t}\n\t\tint get_numl(){\n\t\t\treturn this->numl;\n\t\t}\n\t\tvoid set_numl(int a){\n\t\t\tthis->numl = a;\n\t\t}\n\t\tvoid resize(int a, int b = -1, int c = -1, int d = -1){\n\t\t\t\n\t\t\tint max = a;\n\t\t\tfor (int i = 0; i <= 4; i++)\n\t\t\t\tsizes[i] = 0;\n\t\t\tthis->sizes[1] = a;\n\t\t\tif (b != -1)\n\t\t\t{\n\t\t\t\tthis->sizes[2] = b;\n\t\t\t\tmax *= b;\n\t\t\t}\n\t\t\tif (c != -1)\n\t\t\t{\n\t\t\t\tthis->sizes[3]=c;\n\t\t\t\tmax *= c;\n\t\t\t}\n\t\t\tif (d != -1)\n\t\t\t{\n\t\t\t\tthis->sizes[4]=d;\n\t\t\t\tmax *= d;\n\t\t\t}\n\t\t\tdata = new double[max];\n\t\t}\n\t\tTensor() {}\n\t\t~Tensor(){\n\t\t\tdelete[] data;\n\t\t}\n\t\tdouble & get_v(int index){\n\t\t\treturn data[index];\n\t\t}\n};\n\nistream & operator>>(istream & in,Tensor & o){\n\tdouble arr[5];\n\tdouble v[1000];\n\tint numl;\n\tin >> numl;\n\to.set_numl(numl);\n\tfor (int i = 0; i <= 4;i++)\n\t\tarr[i] = 1;\n\tint max = 1;\n\tfor (int i = 0; i < numl;i++){\n\t\tin >> arr[i + 1];\n\t\tmax *= arr[i + 1];\n\t}\n\to.resize(arr[1], arr[2], arr[3], arr[4]);\n\t\n\tfor (int i = 0; i < max;i++)\n\t\tin >> v[i];\n\to.set_value(v);\n\treturn in;\n}\nostream & operator <<(ostream &out,Tensor &o){\n\tint numl = o.get_numl();\n\tout << numl << endl;\n\tfor (int i = 1; i <= numl;i++)\n\t\tout << o.get(i) << \" \";\n\t\n\tout << endl;\n\tout<<endl;\n\tswitch (numl)\n\t{\n\tcase 2:\n\t\tfor (int a = 0; a < o.get(1); a++)\n\t\t{\n\t\t\tfor (int b = 0; b < o.get(2); b++)\n\t\t\t{\n\t\t\t\tout << o.get_v(a * o.get(2) + b) << \" \";\n\t\t\t}\n\t\t\tout << endl;\n\t\t}\n\t\tbreak;\n\tcase 3:\n\t\tfor (int a = 0; a < o.get(1); a++)\n\t\t{\n\t\t\tfor (int b = 0; b < o.get(2); b++)\n\t\t\t{\n\t\t\t\tfor (int c = 0; c < o.get(3); c++)\n\t\t\t\t{\n\t\t\t\t\tout << o.get_v(a * o.get(3) * o.get(2) + b * o.get(3) + c) << \" \";\n\t\t\t\t}\n\t\t\t\tout << endl;\n\t\t\t}\n\t\t\tout << endl;\n\t\t}\n\t\tbreak;\n\tcase 4:\n\t\tfor (int a = 0; a < o.get(1); a++)\n\t\t{\n\t\t\tfor (int b = 0; b < o.get(2); b++)\n\t\t\t{\n\t\t\t\tfor (int c = 0; c < o.get(3); c++)\n\t\t\t\t{\n\t\t\t\t\tfor (int d = 0; d < o.get(4); d++)\n\t\t\t\t\t{\n\t\t\t\t\t\tout << o.get_v(a * o.get(4) * o.get(2) * o.get(3) + b * o.get(4) * o.get(3) + c * o.get(4) + d) << \" \";\n\t\t\t\t\t}\n\t\t\t\t\tout << endl;\n\t\t\t\t}\n\t\t\t\tout << endl;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\tout << endl;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\t\n\treturn out;\n}",
            1593069984.6821303,
            100,
            "# 答案正确"
        ],
        [
            "10.2 (C++)",
            "王郅成",
            "catch (NonPositiveValueException & ex){\n\tcout << \"caught: NonPositiveValueException\" << endl;\n}catch(out_of_range & ex){\n\tcout << \"caught: out_of_range\" << endl;\n}",
            1593659204.508935,
            100,
            "# 答案正确"
        ],
        [
            "10.1 (C++)",
            "王郅成",
            "#include <iostream>\n#include <string>\n#include <exception>\nclass MatrixSizesDoNotMatchException{\n};\n\ndouble Matrix::get(int r, int c) const\n{\n\tif (r > this->size(1) || c > this->size(2)){\n\t\tout_of_range error(\"A\");\n\t\tthrow error;\n\t}\n\t\t\n\tint size1 = size(2);\n\treturn elements[r * size1 + c];\n}\n\nvoid Matrix:: set(int r,int c,double v){\n\tint sizes1 = this->size(1), sizes2 = this->size(2);\n\tif(r>sizes1 || c > sizes2){\n\t\tout_of_range error(\"A\");\n\t\tthrow error;\n\t}\n\telse{\n\t\tint index = r * sizes2 + c;\n\t\tthis->elements[index] = v;\n\t}\n}\n\nMatrix Matrix::operator+(const Matrix & M)const{\n\tif(this->size(1) != M.size(1) || this->size(2) != M.size(2)){\n\t\tMatrixSizesDoNotMatchException error;\n\t\tthrow error;\n\t}\n\telse{\n\t\tMatrix result(M.size(1), M.size(2));\n\t\tfor (int i = 1; i <= M.size(1);i++){\n\t\t\tfor (int j = 1; j <= M.size(2);j++){\n\t\t\t\tresult.set(i, j, M.get(i, j) + this->get(i, j));\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}",
            1593659241.546197,
            100,
            "# 答案正确"
        ],
        [
            "2020-07-09 LAB",
            "王郅成",
            "#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Integer\n{\npublic:\n    static int add;\n    int a;\n    Integer(){\n        a = 0;\n    }\n    Integer(int s) {\n        a = s;\n    }\n    static void increase_all(int n) {\n        add = n;\n    }\n    static void increase_all(Integer n) {\n        add = n.a;\n    }\n    \n};\nint Integer::add = 0;\nistream & operator >> (istream & in, Integer & s) {\n    in >> s.a;\n    return in;\n}\nostream & operator << (ostream & out, Integer & s) {\n    s.a += Integer::add;\n    out << s.a;\n    return out;\n}",
            1594263214.1685514,
            100,
            "# 答案正确"
        ],
        [
            "15.1 (C++)",
            "王郅成",
            "#include <string>\n#include <vector>\nusing namespace std;\nstring tostr(vector<string> value)\n{\n\tstring tmp;\n\tstring result;\n\tresult.push_back('\\t');\n\tresult.push_back('\\t');\n\tresult.push_back('[');\n\tfor (int i = 0; i < value.size(); i++)\n\t{\n\t\ttmp = value[i];\n\t\tresult.push_back('\\'');\n\t\tfor (int j = 0; j < tmp.size(); j++)\n\t\t\tresult.push_back(tmp[j]);\n\t\tresult.push_back('\\'');\n\t\tresult.push_back(',');\n\t}\n\tresult.insert(result.size(), \"],\\n\");\n\treturn result;\n}\n\nclass Table{\n\t\n\tvector<string> head;\n\tvector<vector<string>> value;\n\npublic:\n\t//friend ostream &operator<<(ostream &out, const Table &table);\n\tvoid addCol(string str){\n\t\thead.push_back(str);\n\t};\n\tTable(){\n\t\thead.resize(0);\n\t\tvalue.resize(0);\n\t}\n\tstring json()const\n\t{\n\t\tstring result;\n\t\tresult = \"{\\n\\theaders: [\";\n\t\tstring tmp;\n\t\tfor (int i = 0; i < head.size();i++){\n\t\t\ttmp = head[i];\n\t\t\tresult.push_back('\\'');\n\t\t\tfor (int j = 0; j < tmp.size();j++)\n\t\t\t\tresult.push_back(tmp[j]);\n\t\t\tresult.push_back('\\'');\n\t\t\t\n\t\t\tresult.push_back(',');\n\t\t}\n\t\tresult.insert(result.size(), \"],\\n\\trows: [\\n\");\n\t\tfor (int i = 0; i < value.size();i++)\n\t\t\tresult.insert(result.size(), tostr(value[i]));\n\n\t\tresult.insert(result.size(), \"\\t],\\n}\");\n\n\t\treturn result;\n\t}\n\tvector<string> & operator[](int index){\n\t\t\n\t\tif(index < value.size()){\n\t\t\t\n\t\t}else{\n\t\t\tvalue.resize(index+1);\n\t\t\t\n\t\t}\n\t\treturn value[index];\n\t}\n};",
            1594297351.5332158,
            100,
            "# 答案正确"
        ],
        [
            "A.2 (C++)",
            "王郅成",
            "template <typename E>\nvoid LinkedList<E>::removeAll(const E &val)\n{\n\ttry{\n\t\twhile(1)\n\t\t\tremoveFirstOccurrence(val);\n\t}catch(NotSuchElementException & o){\n\t\treturn;\n\t}\n}",
            1594868768.1577353,
            100,
            "# 答案正确"
        ],
        [
            "A.1 (C++)",
            "王郅成",
            "LinkedList(const LinkedList &o) : _size(0), head(0), tail(0) { addAll(o);\n\t\t\n\t}\n\n\tLinkedList & operator= (const LinkedList & o){\n\t\tclear();\n\t\taddAll(o);\n\t}\n\t~LinkedList() { clear(); }\n\tvoid clear(){\n\t\twhile(_size > 0)\n\t\t\tremoveFirst();\n\t}\n\tvoid addAll(const LinkedList & o){\n\t\tNode<E> *temp = o.head;\n\t\tNode<E> *prev = 0;\n\t\tNode<E> *next = temp->next_node(prev);\n\t\tfor (int i = 0; i < o._size-1;i++){\n\t\t\tadd( i, temp->element);\n\t\t\tprev = temp;\n\t\t\ttemp = next;\n\t\t\tnext = next->next_node(prev);\n\t\t}\n\t\tadd(o._size, temp->element);\n\t}\n\tvoid print(const LinkedList &o)\n\t{\n\t\tNode<E> *temp = o.head;\n\t\tNode<E> *prev = 0;\n\t\tNode<E> *next = temp->next_node(prev);\n\t\tfor (int i = 0; i < o._size-1;i++){\n\t\t\tcout << temp->element << \" \";\n\t\t\tprev = temp;\n\t\t\ttemp = next;\n\t\t\tnext = next->next_node(prev);\n\t\t}\n\t\tcout <<temp->element<< endl;\n\t}\n\t\n\tvoid add(int index,const E o){\n\t\tNode<E> *node = new Node<E>();\n\t\tnode->element = o;\n\t\tif(this->head == 0){\n\t\t\tthis->head = node;\n\t\t\tthis->tail = this->head;\n\t\t}else if(index==0 && this->head != 0){\n\t\t\thead->update_prev_node(0, node);\n\t\t\tnode->update_next_node(0, head);\n\t\t\thead = node;\n\t\t}else if(index=this->_size){\n\t\t\tNode<E> *temp = this->tail;\n\t\t\tNode<E> *next = 0;\n\t\t\tnext = node;\n\t\t\tnode->update_prev_node(0, temp);\n\t\t\ttemp->update_next_node(0, next);\n\t\t\ttail = node;\n\t\t}\n\t\t++_size;\n\t}\n\tvoid remove(int index){\n\t\t\n\t\tif(index==0){\n\t\t\tNode<E> *temp = this->head;\n\t\t\tNode<E> *next = temp->next_node(0);\n\t\t\tNode<E> *prev = 0;\n\t\t\tif(next!=0){\n\t\t\tnext->update_prev_node(head,0);}\n\t\t\thead = next;\n\t\t\tdelete temp;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tNode<E> *temp = this->tail;\n\t\t\tNode<E> *prev = temp->prev_node(0);\n\t\t\tthis->tail = prev;\n\t\t\tprev->update_next_node(temp, 0);\n\t\t\tdelete temp;\n\t\t}\n\t\tthis->_size--;\n\t}\n\tvoid addFirst(E val){\n\t\tadd(0, val);\n\t}\n\tvoid addLast(E val){\n\t\tadd(_size, val);\n\t}\n\tvoid removeFirstOccurrence(int val){\n\t\tNode<E> *temp = this->head;\n\t\tNode<E> *next = temp->next_node(0);\n\t\tNode<E> *prev = 0;\n\t\tif(this->tail->element == val){\n\t\t\tremoveLast();\n\t\t\treturn;\n\t\t}else if(this->head->element==val){\n\t\t\tremoveFirst();\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 0; i < this->_size-1;i++){\n\t\t\tprev = temp, temp = next;\n\t\t\tnext = temp->next_node(prev);\n\t\t\tif (temp->element == val)\n\t\t\t\tbreak;\n\t\t}\n\t\tprev->update_next_node(temp, next);\n\t\tnext->update_prev_node(temp, prev);\n\t\tdelete temp;\n\t\tthis->_size--;\n\t}\n\tint get(int index){\n\t\tNode<E> *temp = this->head;\n\t\tNode<E> *prev = 0;\n\t\tNode<E> *next = temp->next_node(prev);\n\t\tif(index==this->_size-1)\n\t\t\treturn this->tail->element;\n\t\telse if(index==0){\n\t\t\treturn temp->element;\n\t\t}\n\t\treturn temp->element;\n\t}\n\tvoid removeLast() { remove(this->_size);\n\t\t\n\t}\n\tvoid removeFirst() { remove(0);\n\t\t\n\t}",
            1594868795.0157394,
            100,
            "# 答案正确"
        ],
        [
            "A.3 (C++)",
            "王郅成",
            "#include <vector>\n#include <cctype>\nusing namespace std;\n\ntemplate <typename E>\nclass Tuple\n{\npublic:\n int key;\n E a;\n bool in_use;\n Tuple()\n {\n  in_use = false;\n }\n};\n\ntemplate <typename E>\nclass HT\n{\nprivate:\n vector<Tuple<E>> tuples;\n int _size;\n\npublic:\n HT()\n {\n  tuples.resize(4000);\n  _size = 0;\n }\n int hashfunction(int key)\n {\n  int hc = 0;\n  while (key)\n  {\n   hc = (hc << 5) + (key % 10);\n   key /= 10;\n  }\n  return hc % tuples.size();\n }\n int indexofkey(int key)\n {\n  int index = hashfunction(key);\n  while (true)\n  {\n   if (tuples[index].in_use == false)\n    return index;\n   if (tuples[index].key == key)\n    return index;\n   index = (index + 1) % tuples.size();\n  }\n }\n void put(int key, E a)\n {\n  int index = indexofkey(key);\n  tuples[index].a = a;\n  tuples[index].key = key;\n  if (tuples[index].in_use == false)\n  {\n   tuples[index].in_use = true;\n   _size++;\n  }\n }\n int size()\n {\n  return _size;\n }\n bool containsKey(int key)\n {\n  int index = indexofkey(key);\n  return tuples[index].in_use == true;\n }\n E operator[](int key)\n {\n  int index = indexofkey(key);\n  return tuples[index].a;\n }\n vector<int> getKeys()\n {\n  vector<int> ans;\n  for (int i = 0; i < tuples.size(); i++)\n  {\n   if (tuples[i].in_use)\n   {\n    ans.push_back(tuples[i].key);\n   }\n  }\n  return ans;\n }\n void remove(int key)\n {\n  int index = indexofkey(key);\n  tuples[index].in_use = false;\n  _size--;\n }\n};",
            1595473354.382265,
            100,
            "# 答案正确"
        ],
        [
            "A.4 (C++)",
            "王郅成",
            "#include <iostream>\n#include <sstream>\n#include <string>\nusing namespace std;\n\t\tclass Tuple\n\t\t{\n\t\tpublic:\n\t\t\tint key,val;\n\t\t\tTuple() {}\n\t\t\tTuple(int k, int v)\n\t\t\t{\n\t\t\t\tkey = k;\n\t\t\t\tval = v;\n\t\t\t}\n\t\t\toperator int(){\n\t\t\t\treturn this->val;\n\t\t\t}\n\t\t\toperator string(){\n\t\t\t\tstring result;\n\t\t\t\tstringstream ss;\n\t\t\t\tss << this->val;\n\t\t\t\tss >> result;\n\t\t\t\treturn result;\n\t\t\t}\n\t\t};\nclass HT{\n\tprivate:\n\t\tTuple dict[10];\n\t\tint _size;\n\tpublic:\n\t\tHT(): _size(0) {}\n\t\t~HT(){}\n\t\ttemplate<typename K,typename V>\n\t\tvoid put(K key,V val){\n\t\t\tint ke;\n\t\t\tint va;\n\t\t\tke = str_to_int(key);\n\t\t\tva = str_to_int(val);\n\t\t\tTuple ling(ke, va);\n\t\t\tdict[this->_size] = ling;\n\t\t\tthis->_size++;\n\t\t}\n\t\tint size(){\n\t\t\treturn this->_size;\n\t\t}\n\t\tint str_to_int(int str) { return str; }\n\t\tint str_to_int(string str){\n\t\t\tstringstream ss;\n\t\t\tss << str;\n\t\t\tint res;\n\t\t\tss >> res;\n\t\t\treturn res;\n\t\t}\n\t\tstring int_to_str(string v) { return v; }\n\t\tstring int_to_str(int v){\n\t\t\tstring result;\n\t\t\tstringstream ss;\n\t\t\tss << v;\n\t\t\tss >> result;\n\t\t\treturn result;\n\t\t}\n\t\ttemplate < typename V>\n\t\tTuple operator[](const V &index)\n\t\t{\n\t\t\tint ling;\n\t\t\tling = str_to_int(index);\n\t\t\tfor (int i = 0; i <= 10;i++){\n\t\t\t\tif(dict[i].key == ling){\n\t\t\t\t\treturn dict[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n};",
            1595809154.1460388,
            100,
            "# 答案正确"
        ],
        [
            "A.5 (C++)",
            "王郅成",
            "#include <iostream>\n#include <sstream>\n#include <string>\n\nusing namespace std;\n\n\n\t\tclass Tuple\n\t\t{\n\t\tpublic:\n\t\t\tint key;\n\t\t\tint val;\n\t\t\tbool used;\n\t\t\tTuple() : used(false)\n\t\t\t{\n\t\t\t}\n\t\t\tTuple(int k, int v)\n\t\t\t{\n\t\t\t\tused = true;\n\t\t\t\tkey = k;\n\t\t\t\tval = v;\n\t\t\t}\n\t\t\toperator int(){\n\t\t\t\treturn this->val;\n\t\t\t}\n\t\t\toperator string(){\n\t\t\t\tstring result;\n\t\t\t\tstringstream ss;\n\t\t\t\tss << this->val;\n\t\t\t\tss >> result;\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tint str_to_int(string &str){\n\t\t\t\tstringstream ss;\n\t\t\t\tss << str;\n\t\t\t\tint res;\n\t\t\t\tss >> res;\n\t\t\t\treturn res;\n\t\t\t}\n\t\t\tint str_to_int(int a) { return a; }\n\t\t\ttemplate<typename K>\n\t\t\tTuple& operator= (K oth)\n\t\t\t{\n\t\t\t\tthis->val = str_to_int(oth);\n\t\t\t\tthis->used = true;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t};\n\t#define max_index 100\nclass HT{\n\tprivate:\n\t\t\n\t\tTuple dict[max_index+2];\n\t\tint _size;\n\n\tpublic:\n\t\tHT(): _size(0) {}\n\t\t~HT(){}\n\t\tsize_t size(){\n\t\t\tsize_t count=0;\n\t\t\tfor (size_t i = 0; i <= max_index;i++)\n\t\t\t\tif(dict[i].used==true)\n\t\t\t\t\tcount++;\n\t\t\t\treturn count;\n\t\t}\n\t\tint str_to_int(int str) { return str; }\n\t\tint str_to_int(string str){\n\t\t\tstringstream ss;\n\t\t\tss << str;\n\t\t\tint res;\n\t\t\tss >> res;\n\t\t\treturn res;\n\t\t}\n\t\tint find_index(int key)\n\t\t{\n\t\t\treturn key%max_index;\n\t\t}\n\t\ttemplate < typename V>\n\t\tTuple & operator[](const V &index)\n\t\t{\n\t\t\tint ling;\n\t\t\tling = str_to_int(index);\n\t\t\treturn dict[find_index(ling)];\n\t\t}\n\t\t\n};",
            1595809189.1498065,
            100,
            "# 答案正确"
        ]
    ],
    "table_name": "答案"
}