{
    "__update_time__": 1595473152.3481193,
    "field_names": [
        "题目名",
        "用户名",
        "答案",
        "提交时间",
        "分数",
        "评语"
    ],
    "field_types": [
        "text",
        "text",
        "text",
        "time",
        "number",
        "text"
    ],
    "foreign_keys": {},
    "primary_keys": [],
    "rows": [
        [
            "测试1",
            "肖澧寅",
            "#include <iostream>\nusing namespace std;\n\nint main()\n{\n    string a,b,c;\n    cin >> a >> b >> c;\n    cout << c << \" \" << b << \" \" << a;\n}\n\n",
            1587607535.079056,
            100,
            "# 答案正确"
        ],
        [
            "测试2",
            "肖澧寅",
            "#include <iostream>\nusing namespace std;\n\n\nint main()\n{\n    string a[10];\n    for(int i = 0;i < 10;i++){\n        cin >> a[i];\n    }\n    for(int i = 0;i < 9;i++){\n        for(int j = i + 1;j < 10;j++){\n            if(a[i] > a[j]){\n                string tmp;\n                tmp = a[i];\n                a[i] = a[j];\n                a[j] = tmp;\n            }\n        }\n    }\n    for(int i = 0;i < 10;i++){\n        cout << a[i] << \" \";\n    }\n}\n\n",
            1587608745.2390437,
            100,
            "# 答案正确"
        ],
        [
            "1.1 (C++)",
            "肖澧寅",
            "class Matrix5x5{\npublic:\n    double mat[5][5];\n    Matrix5x5(){\n        for(int i = 0;i < 5;i++){\n            for(int j = 0;j < 5;j++){\n                mat[i][j] = 0;\n            }\n        }\n    }\n    ~Matrix5x5(){}\n\n    double get(int a,int b){\n        return mat[a][b];\n    }\n    void set(int a,int b,double c){\n        mat[a][b] = c;\n    }\n    Matrix5x5 operator + (Matrix5x5 &other){\n        Matrix5x5 tmp;\n        for(int i = 0;i < 5;i++){\n            for(int j = 0;j < 5;j++){\n                tmp.mat[i][j] = this->mat[i][j] + other.mat[i][j];\n            }\n        }\n        return tmp;\n    }\n};",
            1588087498.611289,
            100,
            "# 答案正确"
        ],
        [
            "1.2 (C++)",
            "肖澧寅",
            "#include <cstring>\n\nclass School{\npublic:\n    int age;\n    char name[10];\n    School(){\n        age = 0;\n        strcpy(name,\"NO_NAME\");\n    }\n    ~School(){}\n\n    void setName(char nam[]){\n        strcpy(name,nam);\n    }\n    void setAge(int year){\n        age = year;\n    }\n    void operator ++ (){\n        age++;\n    }\n};",
            1588212689.0357208,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/08",
            "肖澧寅",
            "double & Tensor_get(int dimensions, const int sizes[], double data[], int x0, int x1, int x2, int x3){\n    int sum[4] = {1,1,1,1};\n    for(int i = 0;i < dimensions;i++){\n        for(int j = i + 1;j < dimensions;j++){\n            sum[i] *= sizes[j];\n        }\n    }\n    int cnt = 0;\n    int di[4] = {x0,x1,x2,x3};\n    for(int i = 0;i < dimensions;i++){\n        cnt += di[i] * sum[i];\n    }\n    return data[cnt];\n}",
            1588907676.3374934,
            100,
            "# 答案正确"
        ],
        [
            "2.1 (C++)",
            "肖澧寅",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix{\nprivate:\n    int row;\n    int column;\n    double * values;\npublic:\n    Matrix(int rows, int columns) : row(rows), column(columns) {\n        values = new double [row * column];\n        for(int i = 0;i < row * column;i++) values[i] = 0;\n    }\n    ~Matrix(){\n        delete []values;\n    }\n    void print(){\n        for(int i = 0;i < row;i++){\n            for(int j = 0;j < column;j++){\n                cout << \"    \" << 0;\n            }\n            cout << endl;\n        }\n    }\n};",
            1589384192.6693575,
            100,
            "# 答案正确"
        ],
        [
            "2.2 (C++)",
            "肖澧寅",
            "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nclass Matrix{\nprivate:\n    int row;\n    int column;\n    double * values;\npublic:\n    Matrix(int rows, int columns ,double value[]) : row(rows), column(columns) {\n        values = new double [row * column];\n        for(int i = 0;i < row * column;i++) values[i] = value[i];\n    }\n    ~Matrix(){\n        delete []values;\n    }\n    void print(){\n        for(int i = 0;i < row;i++){\n            for(int j = 0;j < column;j++){\n                cout << setw(5) << values[i * column + j];\n            }\n            cout << endl;\n        }\n    }\n};",
            1589384482.872042,
            100,
            "# 答案正确"
        ],
        [
            "2.3 (C++)",
            "肖澧寅",
            "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nclass Matrix{\nprivate:\n    int row;\n    int column;\n    double * values;\npublic:\n    Matrix(int rows, int columns ,double value[]) : row(rows), column(columns) {\n        values = new double [row * column];\n        for(int i = 0;i < row * column;i++) values[i] = value[i];\n    }\n    Matrix(const Matrix & matrix2){\n        row = matrix2.row;\n        column = matrix2.column;\n        values = new double [row * column];\n        for(int i = 0;i < row * column;i++){\n            values[i] = matrix2.values[i];\n        }\n    }\n    ~Matrix(){\n        delete []values;\n    }\n    void print(){\n        for(int i = 0;i < row;i++){\n            for(int j = 0;j < column;j++){\n                cout << \"    \" << values[i * column + j];\n            }\n            cout << endl;\n        }\n    }\n};",
            1589384760.465029,
            100,
            "# 答案正确"
        ],
        [
            "2.5 (C++)",
            "肖澧寅",
            "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nclass Matrix{\nprivate:\n    int row;\n    int column;\n    double * values;\npublic:\n    Matrix(int rows, int columns ,double value[]) : row(rows), column(columns) {\n        values = new double [row * column];\n        for(int i = 0;i < row * column;i++) values[i] = value[i];\n    }\n    Matrix(const Matrix & matrix2){\n        row = matrix2.row;\n        column = matrix2.column;\n        values = new double [row * column];\n        for(int i = 0;i < row * column;i++){\n            values[i] = matrix2.values[i];\n        }\n    }\n    ~Matrix(){\n        delete []values;\n    }\n    void print(){\n        for(int i = 0;i < row;i++){\n            for(int j = 0;j < column;j++){\n                cout << \"    \" << values[i * column + j];\n            }\n            cout << endl;\n        }\n    }\n    Matrix getRow(int roww){\n        double tvalue[1000];\n        for(int i = 0;i < column;i++){\n            tvalue[i] = values[(roww - 1) * column + i];\n        }\n        Matrix temp(1,column,tvalue);\n        return temp;\n    }\n    Matrix getColumn(int columnn){\n        double tvalue[1000];\n        for(int i = 0;i < row;i++){\n            tvalue[i] = values[i * column + columnn - 1];\n        }\n        Matrix temp(row,1,tvalue);\n        return temp;\n    }\n};",
            1589421919.7283115,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/14",
            "肖澧寅",
            "#include <iostream>\nusing namespace std;\n\ndouble Tensor_get(int dimensions, const int sizes[],const double data[], int x0, int x1 = 1, int x2 = 1, int x3 = 1){\n    int sum[4] = {1,1,1,1};\n    for(int i = 0;i < dimensions;i++){\n        for(int j = i + 1;j < dimensions;j++){\n            sum[i] *= sizes[j];\n        }\n    }\n    int cnt = 0;\n    int di[4] = {x0,x1,x2,x3};\n    for(int i = 0;i < dimensions;i++){\n        cnt += di[i] * sum[i];\n    }\n    return data[cnt];\n}\nvoid Tensor_print(int dimensions, const int sizes[], const double data[]){\n    if(dimensions == 1){\n        cout << \"Tensor of \" << sizes[0] << endl;\n        for(int i = 0;i < sizes[0];i++){\n            cout << data[i] << endl;\n        }\n    }\n    if(dimensions == 2){\n        cout << \"Tensor of \" << sizes[0] << \"x\" << sizes[1] << endl;\n        for(int i = 0;i < sizes[0];i++){\n            for(int j = 0;j < sizes[1];j++){\n                cout << \"    \" << Tensor_get(dimensions,sizes,data,i,j);\n            }\n            cout << endl;\n        }\n    }\n    if(dimensions == 3){\n        cout << \"Tensor of \" << sizes[0] << \"x\" << sizes[1] << \"x\" << sizes[2] << endl;\n        for(int i = 0;i < sizes[0];i++){\n            cout << \"data[\" << i << \"]\" << endl;\n            for(int j = 0;j < sizes[1];j++){\n                for(int k = 0;k < sizes[2];k++){\n                    cout << \"    \" << Tensor_get(dimensions,sizes,data,i,j,k);\n                }\n                cout << endl;\n            }\n        }\n    }\n    if(dimensions == 4){\n        cout << \"Tensor of \" << sizes[0] << \"x\" << sizes[1] << \"x\" << sizes[2] << \"x\" << sizes[3] << endl;\n        for(int i = 0;i < sizes[0];i++){\n            for(int j = 0;j < sizes[1];j++){\n                cout << \"data[\" << i << \"][\" << j << \"]\" << endl;\n                for(int k = 0;k < sizes[2];k++){\n                    for(int l = 0;l < sizes[3];l++){\n                        cout << \"    \" << Tensor_get(dimensions,sizes,data,i,j,k,l);\n                    }\n                    cout << endl;\n                }\n            }\n        }\n    }\n}",
            1589424006.1353445,
            100,
            "# 答案正确"
        ],
        [
            "2.6 (C++)",
            "肖澧寅",
            "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nclass Matrix{\nprivate:\n    int row;\n    int column;\n    double * values;\npublic:\n    Matrix(int rows, int columns ,double value[]) : row(rows), column(columns) {\n        values = new double [row * column];\n        for(int i = 0;i < row * column;i++) values[i] = value[i];\n    }\n    Matrix(const Matrix & matrix2){\n        row = matrix2.row;\n        column = matrix2.column;\n        values = new double [row * column];\n        for(int i = 0;i < row * column;i++){\n            values[i] = matrix2.values[i];\n        }\n    }\n    ~Matrix(){\n        delete []values;\n    }\n    void print(){\n        for(int i = 0;i < row;i++){\n            for(int j = 0;j < column;j++){\n                cout << \"    \" << values[i * column + j];\n            }\n            cout << endl;\n        }\n    }\n    Matrix getRow(int roww){\n        double tvalue[1000];\n        for(int i = 0;i < column;i++){\n            tvalue[i] = values[(roww - 1) * column + i];\n        }\n        Matrix temp(1,column,tvalue);\n        return temp;\n    }\n    Matrix getColumn(int columnn){\n        double tvalue[1000];\n        for(int i = 0;i < row;i++){\n            tvalue[i] = values[i * column + columnn - 1];\n        }\n        Matrix temp(row,1,tvalue);\n        return temp;\n    }\n    Matrix concatenateRows(const Matrix & matrix2) const{\n        double tvalue[1000];\n        int thisize = row * column;\n        int thatsize = matrix2.row * matrix2.column;\n        for(int i = 0;i < thisize;i++){\n            tvalue[i] = values[i];\n        }\n        for(int i = 0;i < thatsize;i++){\n            tvalue[thisize + i] = matrix2.values[i];\n        }\n        Matrix temp(row + matrix2.row,column,tvalue);\n        return temp;\n    }\n    Matrix concatenateColumns(const Matrix & matrix2) const{\n        double tvalue[1000];\n        int tindex = 0;\n        for(int i = 0;i < row;i++){\n            for(int j = 0;j < column;j++){\n                tvalue[tindex++] = values[i * column + j];\n            }\n            for(int j = 0;j < matrix2.column;j++){\n                tvalue[tindex++] = matrix2.values[i * matrix2.column + j];\n            }\n        }\n        Matrix temp(row,column + matrix2.column,tvalue);\n        return temp;\n    }\n};",
            1589425804.0750597,
            100,
            "# 答案正确"
        ],
        [
            "2.4 (C++)",
            "肖澧寅",
            "#include <iostream>\n#include <string>\n#include <iomanip>\n#define f(i,start,n) for(int i = start;i < n;i++)\nusing namespace std;\n\nclass Matrix{\nprivate:\n    int rows;\n    int columns;\n    double *values;\n    void ass(int row, int column, double value[]){\n        rows = row;\n        columns = column;\n        if(values != 0) delete []values;\n        values = new double[row * column];\n        f(i,0,row * column) values[i] = value[i];\n    }\npublic:\n    Matrix(int row,int column){\n        rows = row;\n        column = columns;\n        values = new double[row * column];\n        f(i,0,row * column) values[i] = 0;\n    }\n    Matrix(int row, int column, double value[]){\n        values = 0;\n        ass(row,column,value);\n    }\n    ~Matrix(){\n        delete []values;\n    }\n    void print(){\n        f(i,0,rows){\n            f(j,0,columns){\n                cout << \"    \" << values[i * columns + j];\n            }\n            cout << endl;\n        }\n    }\n    void set(int row, int column, double value){\n        row--;\n        column--;\n        values[row * columns + column] = value;\n    }\n    Matrix& operator = (const Matrix& mat){\n        ass(mat.rows,mat.columns,mat.values);\n        return (*this);\n    }\n};",
            1589601082.0396674,
            100,
            "# 答案正确"
        ],
        [
            "2.7 (C++)",
            "肖澧寅",
            "#include <iostream>\n#include <string>\n#include <iomanip>\n#define f(i,start,n) for(int i = start;i < n;i++)\nusing namespace std;\n\nclass Matrix{\nprivate:\n    int rows;\n    int columns;\n    double *values;\n    void ass(int row, int column, double value[]){\n        rows = row;\n        columns = column;\n        if(values != 0) delete []values;\n        values = new double[row * column];\n        f(i,0,row * column) values[i] = value[i];\n    }\npublic:\n    Matrix(int row,int column){\n        rows = row;\n        column = columns;\n        values = new double[row * column];\n        f(i,0,row * column) values[i] = 0;\n    }\n    Matrix(int row, int column, double value[]){\n        values = 0;\n        ass(row,column,value);\n    }\n    Matrix(const Matrix & matrix2){\n        values = 0;\n        ass(matrix2.rows,matrix2.columns,matrix2.values);\n    }\n    ~Matrix(){\n        delete []values;\n    }\n    void print(){\n        f(i,0,rows){\n            f(j,0,columns){\n                cout << \"    \" << values[i * columns + j];\n            }\n            cout << endl;\n        }\n    }\n    void set(int row, int column, double value){\n        row--;\n        column--;\n        values[row * columns + column] = value;\n    }\n    Matrix& operator = (const Matrix& mat){\n        ass(mat.rows,mat.columns,mat.values);\n        return (*this);\n    }\n    Matrix reshape(int row, int column) const{\n        double value[row * column];\n        int index = 0;\n        f(j,0,columns) f(i,0,rows) value[index++] = values[i * columns + j];\n        double value2[row * column];\n        index = 0;\n        f(j,0,column) f(i,0,row) value2[i * column + j] = value[index++];\n        Matrix temp(row,column,value2);\n        return temp;\n    }\n\n};",
            1589603011.5674167,
            100,
            "# 答案正确"
        ],
        [
            "2.8 (C++)",
            "肖澧寅",
            "#include <iostream>\n#include <string>\n#include <iomanip>\n#define f(i,start,n) for(int i = start;i < n;i++)\nusing namespace std;\n\nclass Matrix{\nprivate:\n    int rows;\n    int columns;\n    double *values;\n    void ass(int row, int column, double value[]){\n        rows = row;\n        columns = column;\n        if(values != 0) delete []values;\n        values = new double[row * column];\n        f(i,0,row * column) values[i] = value[i];\n    }\npublic:\n    Matrix(int row,int column){\n        rows = row;\n        column = columns;\n        values = new double[row * column];\n        f(i,0,row * column) values[i] = 0;\n    }\n    Matrix(int row, int column, double value[]){\n        values = 0;\n        ass(row,column,value);\n    }\n    Matrix(const Matrix & matrix2){\n        values = 0;\n        ass(matrix2.rows,matrix2.columns,matrix2.values);\n    }\n    ~Matrix(){\n        delete []values;\n    }\n    void print(){\n        f(i,0,rows){\n            f(j,0,columns){\n                cout << \"    \" << values[i * columns + j];\n            }\n            cout << endl;\n        }\n    }\n    void set(int row, int column, double value){\n        row--;\n        column--;\n        values[row * columns + column] = value;\n    }\n    Matrix& operator = (const Matrix& mat){\n        ass(mat.rows,mat.columns,mat.values);\n        return (*this);\n    }\n    Matrix reshape(int row, int column) const{\n        double value[row * column];\n        int index = 0;\n        f(j,0,columns) f(i,0,rows) value[index++] = values[i * columns + j];\n        double value2[row * column];\n        index = 0;\n        f(j,0,column) f(i,0,row) value2[i * column + j] = value[index++];\n        Matrix temp(row,column,value2);\n        return temp;\n    }\n    Matrix transpose(){\n        double value[rows * columns];\n        f(i,0,rows) f(j,0,columns) value[j * rows + i] = values[i * columns + j];\n        Matrix temp(columns,rows,value);\n        return temp;\n    }\n\n};",
            1589603293.2638383,
            100,
            "# 答案正确"
        ],
        [
            "2.10 (C++)",
            "肖澧寅",
            "#include <iostream>\n#include <string>\n#include <iomanip>\n#define f(i,start,n) for(int i = start;i < n;i++)\nusing namespace std;\n\nclass Matrix{\nprivate:\n    int rows;\n    int columns;\n    double *values;\n    void ass(int row, int column, double value[]){\n        rows = row;\n        columns = column;\n        if(values != 0) delete []values;\n        values = new double[row * column];\n        f(i,0,row * column) values[i] = value[i];\n    }\npublic:\n    Matrix(int row,int column){\n        rows = row;\n        column = columns;\n        values = new double[row * column];\n        f(i,0,row * column) values[i] = 0;\n    }\n    Matrix(int row, int column, double value[]){\n        values = 0;\n        ass(row,column,value);\n    }\n    Matrix(const Matrix & matrix2){\n        values = 0;\n        ass(matrix2.rows,matrix2.columns,matrix2.values);\n    }\n    ~Matrix(){\n        delete []values;\n    }\n    void print(){\n        f(i,0,rows){\n            f(j,0,columns){\n                cout << \"    \" << values[i * columns + j];\n            }\n            cout << endl;\n        }\n    }\n    void set(int row, int column, double value){\n        row--;\n        column--;\n        values[row * columns + column] = value;\n    }\n    Matrix& operator = (const Matrix& mat){\n        ass(mat.rows,mat.columns,mat.values);\n        return (*this);\n    }\n    Matrix reshape(int row, int column) const{\n        double value[row * column];\n        int index = 0;\n        f(j,0,columns) f(i,0,rows) value[index++] = values[i * columns + j];\n        double value2[row * column];\n        index = 0;\n        f(j,0,column) f(i,0,row) value2[i * column + j] = value[index++];\n        Matrix temp(row,column,value2);\n        return temp;\n    }\n    Matrix transpose(){\n        double value[rows * columns];\n        f(i,0,rows) f(j,0,columns) value[j * rows + i] = values[i * columns + j];\n        Matrix temp(columns,rows,value);\n        return temp;\n    }\n    Matrix operator * (const Matrix & matrix2) const{\n        double value[rows * matrix2.columns] = {0};\n        f(i,0,rows) f(j,0,matrix2.columns) f(k,0,columns)\n            value[i * matrix2.columns + j] += values[i * columns + k] * matrix2.values[k * matrix2.columns + j];\n        Matrix temp(rows,matrix2.columns,value);\n        return temp;\n    }\n    Matrix operator * (double value) const{\n        double val[rows * columns];\n        f(i,0,rows * columns) val[i] = value * values[i];\n        Matrix temp(rows,columns,val);\n        return temp;\n    }\n    \n};",
            1589605059.800021,
            100,
            "# 答案正确"
        ],
        [
            "2.11 (C++)",
            "肖澧寅",
            "#include <iostream>\n#include <string>\n#include <iomanip>\n#define f(i,start,n) for(int i = start;i < n;i++)\nusing namespace std;\n\nclass Matrix{\nprivate:\n    int rows;\n    int columns;\n    double *values;\n    void ass(int row, int column, double value[]){\n        rows = row;\n        columns = column;\n        if(values != 0) delete []values;\n        values = new double[row * column];\n        f(i,0,row * column) values[i] = value[i];\n    }\npublic:\n    Matrix(int row,int column){\n        rows = row;\n        column = columns;\n        values = new double[row * column];\n        f(i,0,row * column) values[i] = 0;\n    }\n    Matrix(int row, int column, double value[]){\n        values = 0;\n        ass(row,column,value);\n    }\n    Matrix(const Matrix & matrix2){\n        values = 0;\n        ass(matrix2.rows,matrix2.columns,matrix2.values);\n    }\n    ~Matrix(){\n        delete []values;\n    }\n    void print(){\n        f(i,0,rows){\n            f(j,0,columns){\n                cout << \"    \" << values[i * columns + j];\n            }\n            cout << endl;\n        }\n    }\n    void set(int row, int column, double value){\n        row--;\n        column--;\n        values[row * columns + column] = value;\n    }\n    Matrix& operator = (const Matrix& mat){\n        ass(mat.rows,mat.columns,mat.values);\n        return (*this);\n    }\n    Matrix reshape(int row, int column) const{\n        double value[row * column];\n        int index = 0;\n        f(j,0,columns) f(i,0,rows) value[index++] = values[i * columns + j];\n        double value2[row * column];\n        index = 0;\n        f(j,0,column) f(i,0,row) value2[i * column + j] = value[index++];\n        Matrix temp(row,column,value2);\n        return temp;\n    }\n    Matrix transpose(){\n        double value[rows * columns];\n        f(i,0,rows) f(j,0,columns) value[j * rows + i] = values[i * columns + j];\n        Matrix temp(columns,rows,value);\n        return temp;\n    }\n    Matrix operator * (const Matrix & matrix2) const{\n        double value[rows * matrix2.columns] = {0};\n        f(i,0,rows) f(j,0,matrix2.columns) f(k,0,columns)\n            value[i * matrix2.columns + j] += values[i * columns + k] * matrix2.values[k * matrix2.columns + j];\n        Matrix temp(rows,matrix2.columns,value);\n        return temp;\n    }\n    Matrix operator * (double value) const{\n        double val[rows * columns];\n        f(i,0,rows * columns) val[i] = value * values[i];\n        Matrix temp(rows,columns,val);\n        return temp;\n    }\n    Matrix max() const{\n        if(rows == 1){\n            double max = -9999999.9;\n            f(i,0,columns) if(values[i] > max) max = values[i];\n            Matrix temp(1,1,&max);\n            return temp;\n        }\n        else{\n            double max[columns];\n            f(i,0,columns) max[i] = -9999999;\n            int index = 0;\n            f(j,0,columns){\n                f(i,0,rows){\n                    if(values[i * columns + j] > max[index]) max[index] = values[i * columns + j];\n                }\n                index++;\n            }\n            Matrix temp(1,columns,max);\n            return temp;\n        }\n    }\n    Matrix min() const{\n        if(rows == 1){\n            double min = 9999999.9;\n            f(i,0,columns) if(values[i] < min) min = values[i];\n            Matrix temp(1,1,&min);\n            return temp;\n        }\n        else{\n            double min[columns];\n            f(i,0,columns) min[i] = 9999999;\n            int index = 0;\n            f(j,0,columns){\n                f(i,0,rows){\n                    if(values[i * columns + j] < min[index]) min[index] = values[i * columns + j];\n                }\n                index++;\n            }\n            Matrix temp(1,columns,min);\n            return temp;\n        }\n    }\n    Matrix sum() const{\n        if(rows == 1){\n            double sum = 0;\n            f(i,0,columns) sum += values[i];\n            Matrix temp(1,1,&sum);\n            return temp;\n        }\n        else{\n            double sum[columns] = {0};\n            int index = 0;\n            f(j,0,columns){\n                f(i,0,rows){\n                    sum[index] += values[i * columns + j];\n                }\n                index++;\n            }\n            Matrix temp(1,columns,sum);\n            return temp;\n        }\n    }\n    \n};",
            1589606565.2417758,
            100,
            "# 答案正确"
        ],
        [
            "2.12 (C++)",
            "肖澧寅",
            "#include <iostream>\n#include <string>\n#include <iomanip>\n#include <cmath>\n#define f(i,start,n) for(int i = start;i < n;i++)\nusing namespace std;\n\nclass Matrix{\nprivate:\n    int rows;\n    int columns;\n    double *values;\n    void ass(int row, int column, double value[]){\n        rows = row;\n        columns = column;\n        if(values != 0) delete []values;\n        values = new double[row * column];\n        f(i,0,row * column) values[i] = value[i];\n    }\npublic:\n    Matrix(int row,int column){\n        rows = row;\n        column = columns;\n        values = new double[row * column];\n        f(i,0,row * column) values[i] = 0;\n    }\n    Matrix(int row, int column, double value[]){\n        values = 0;\n        ass(row,column,value);\n    }\n    Matrix(const Matrix & matrix2){\n        values = 0;\n        ass(matrix2.rows,matrix2.columns,matrix2.values);\n    }\n    ~Matrix(){\n        delete []values;\n    }\n    void print(){\n        f(i,0,rows){\n            f(j,0,columns){\n                cout << \"    \" << values[i * columns + j];\n            }\n            cout << endl;\n        }\n    }\n    void set(int row, int column, double value){\n        row--;\n        column--;\n        values[row * columns + column] = value;\n    }\n    Matrix& operator = (const Matrix& mat){\n        ass(mat.rows,mat.columns,mat.values);\n        return (*this);\n    }\n    Matrix reshape(int row, int column) const{\n        double value[row * column];\n        int index = 0;\n        f(j,0,columns) f(i,0,rows) value[index++] = values[i * columns + j];\n        double value2[row * column];\n        index = 0;\n        f(j,0,column) f(i,0,row) value2[i * column + j] = value[index++];\n        Matrix temp(row,column,value2);\n        return temp;\n    }\n    Matrix transpose(){\n        double value[rows * columns];\n        f(i,0,rows) f(j,0,columns) value[j * rows + i] = values[i * columns + j];\n        Matrix temp(columns,rows,value);\n        return temp;\n    }\n    Matrix operator * (const Matrix & matrix2) const{\n        double value[rows * matrix2.columns] = {0};\n        f(i,0,rows) f(j,0,matrix2.columns) f(k,0,columns)\n            value[i * matrix2.columns + j] += values[i * columns + k] * matrix2.values[k * matrix2.columns + j];\n        Matrix temp(rows,matrix2.columns,value);\n        return temp;\n    }\n    Matrix operator * (double value) const{\n        double val[rows * columns];\n        f(i,0,rows * columns) val[i] = value * values[i];\n        Matrix temp(rows,columns,val);\n        return temp;\n    }\n    Matrix max() const{\n        if(rows == 1){\n            double max = -9999999.9;\n            f(i,0,columns) if(values[i] > max) max = values[i];\n            Matrix temp(1,1,&max);\n            return temp;\n        }\n        else{\n            double max[columns];\n            f(i,0,columns) max[i] = -9999999;\n            int index = 0;\n            f(j,0,columns){\n                f(i,0,rows){\n                    if(values[i * columns + j] > max[index]) max[index] = values[i * columns + j];\n                }\n                index++;\n            }\n            Matrix temp(1,columns,max);\n            return temp;\n        }\n    }\n    Matrix min() const{\n        if(rows == 1){\n            double min = 9999999.9;\n            f(i,0,columns) if(values[i] < min) min = values[i];\n            Matrix temp(1,1,&min);\n            return temp;\n        }\n        else{\n            double min[columns];\n            f(i,0,columns) min[i] = 9999999;\n            int index = 0;\n            f(j,0,columns){\n                f(i,0,rows){\n                    if(values[i * columns + j] < min[index]) min[index] = values[i * columns + j];\n                }\n                index++;\n            }\n            Matrix temp(1,columns,min);\n            return temp;\n        }\n    }\n    Matrix sum() const{\n        if(rows == 1){\n            double sum = 0;\n            f(i,0,columns) sum += values[i];\n            Matrix temp(1,1,&sum);\n            return temp;\n        }\n        else{\n            double sum[columns] = {0};\n            int index = 0;\n            f(j,0,columns){\n                f(i,0,rows){\n                    sum[index] += values[i * columns + j];\n                }\n                index++;\n            }\n            Matrix temp(1,columns,sum);\n            return temp;\n        }\n    }\n    Matrix pow(double exponent){\n        double val[rows * columns];\n        f(i,0,rows * columns) val[i] = std::pow(values[i],exponent);\n        Matrix temp(rows,columns,val);\n        return temp;\n    }\n    Matrix exp(){\n        double val[rows * columns];\n        f(i,0,rows * columns) val[i] = std::exp(values[i]);\n        Matrix temp(rows,columns,val);\n        return temp;\n    }\n    Matrix log(){\n        double val[rows * columns];\n        f(i,0,rows * columns) val[i] = std::log(values[i]);\n        Matrix temp(rows,columns,val);\n        return temp;\n    }\n    Matrix abs(){\n        double val[rows * columns];\n        f(i,0,rows * columns) val[i] = std::abs(values[i]);\n        Matrix temp(rows,columns,val);\n        return temp;\n    }\n};",
            1589607349.834202,
            100,
            "# 答案正确"
        ],
        [
            "2.9 (C++)",
            "肖澧寅",
            "#include <iostream>\n#include <string>\n#include <iomanip>\n#include <cmath>\n#define f(i,start,n) for(int i = start;i < n;i++)\nusing namespace std;\n\nclass Matrix{\nprivate:\n    int rows;\n    int columns;\n    double *values;\n    void ass(int row, int column, double value[]){\n        rows = row;\n        columns = column;\n        if(values != 0) delete []values;\n        values = new double[row * column];\n        f(i,0,row * column) values[i] = value[i];\n    }\npublic:\n    Matrix(int row,int column){\n        rows = row;\n        column = columns;\n        values = new double[row * column];\n        f(i,0,row * column) values[i] = 0;\n    }\n    Matrix(int row, int column, double value[]){\n        values = 0;\n        ass(row,column,value);\n    }\n    Matrix(const Matrix & matrix2){\n        values = 0;\n        ass(matrix2.rows,matrix2.columns,matrix2.values);\n    }\n    ~Matrix(){\n        delete []values;\n    }\n    void print(){\n        f(i,0,rows){\n            f(j,0,columns){\n                cout << \"    \" << values[i * columns + j];\n            }\n            cout << endl;\n        }\n    }\n    void set(int row, int column, double value){\n        row--;\n        column--;\n        values[row * columns + column] = value;\n    }\n    Matrix& operator = (const Matrix& mat){\n        ass(mat.rows,mat.columns,mat.values);\n        return (*this);\n    }\n    Matrix reshape(int row, int column) const{\n        double value[row * column];\n        int index = 0;\n        f(j,0,columns) f(i,0,rows) value[index++] = values[i * columns + j];\n        double value2[row * column];\n        index = 0;\n        f(j,0,column) f(i,0,row) value2[i * column + j] = value[index++];\n        Matrix temp(row,column,value2);\n        return temp;\n    }\n    Matrix transpose(){\n        double value[rows * columns];\n        f(i,0,rows) f(j,0,columns) value[j * rows + i] = values[i * columns + j];\n        Matrix temp(columns,rows,value);\n        return temp;\n    }\n    Matrix operator * (const Matrix & matrix2) const{\n        double value[rows * matrix2.columns] = {0};\n        f(i,0,rows) f(j,0,matrix2.columns) f(k,0,columns)\n            value[i * matrix2.columns + j] += values[i * columns + k] * matrix2.values[k * matrix2.columns + j];\n        Matrix temp(rows,matrix2.columns,value);\n        return temp;\n    }\n    Matrix operator * (double value) const{\n        double val[rows * columns];\n        f(i,0,rows * columns) val[i] = value * values[i];\n        Matrix temp(rows,columns,val);\n        return temp;\n    }\n    Matrix max() const{\n        if(rows == 1){\n            double max = -9999999.9;\n            f(i,0,columns) if(values[i] > max) max = values[i];\n            Matrix temp(1,1,&max);\n            return temp;\n        }\n        else{\n            double max[columns];\n            f(i,0,columns) max[i] = -9999999;\n            int index = 0;\n            f(j,0,columns){\n                f(i,0,rows){\n                    if(values[i * columns + j] > max[index]) max[index] = values[i * columns + j];\n                }\n                index++;\n            }\n            Matrix temp(1,columns,max);\n            return temp;\n        }\n    }\n    Matrix min() const{\n        if(rows == 1){\n            double min = 9999999.9;\n            f(i,0,columns) if(values[i] < min) min = values[i];\n            Matrix temp(1,1,&min);\n            return temp;\n        }\n        else{\n            double min[columns];\n            f(i,0,columns) min[i] = 9999999;\n            int index = 0;\n            f(j,0,columns){\n                f(i,0,rows){\n                    if(values[i * columns + j] < min[index]) min[index] = values[i * columns + j];\n                }\n                index++;\n            }\n            Matrix temp(1,columns,min);\n            return temp;\n        }\n    }\n    Matrix sum() const{\n        if(rows == 1){\n            double sum = 0;\n            f(i,0,columns) sum += values[i];\n            Matrix temp(1,1,&sum);\n            return temp;\n        }\n        else{\n            double sum[columns] = {0};\n            int index = 0;\n            f(j,0,columns){\n                f(i,0,rows){\n                    sum[index] += values[i * columns + j];\n                }\n                index++;\n            }\n            Matrix temp(1,columns,sum);\n            return temp;\n        }\n    }\n    Matrix pow(double exponent){\n        double val[rows * columns];\n        f(i,0,rows * columns) val[i] = std::pow(values[i],exponent);\n        Matrix temp(rows,columns,val);\n        return temp;\n    }\n    Matrix exp(){\n        double val[rows * columns];\n        f(i,0,rows * columns) val[i] = std::exp(values[i]);\n        Matrix temp(rows,columns,val);\n        return temp;\n    }\n    Matrix log(){\n        double val[rows * columns];\n        f(i,0,rows * columns) val[i] = std::log(values[i]);\n        Matrix temp(rows,columns,val);\n        return temp;\n    }\n    Matrix abs(){\n        double val[rows * columns];\n        f(i,0,rows * columns) val[i] = std::abs(values[i]);\n        Matrix temp(rows,columns,val);\n        return temp;\n    }\n    Matrix operator + (const Matrix & matrix2) const{\n        double val[rows * columns];\n        f(i,0,rows * columns) val[i] = values[i] + matrix2.values[i];\n        Matrix temp(rows,columns,val);\n        return temp;\n    }\n    Matrix operator + (double value) const{\n        double val[rows * columns];\n        f(i,0,rows * columns) val[i] = value + values[i];\n        Matrix temp(rows,columns,val);\n        return temp;\n    }\n    Matrix operator - (const Matrix & matrix2) const{\n        double val[rows * columns];\n        f(i,0,rows * columns) val[i] = values[i] - matrix2.values[i];\n        Matrix temp(rows,columns,val);\n        return temp;\n    }\n    Matrix operator - (double value) const{\n        double val[rows * columns];\n        f(i,0,rows * columns) val[i] = values[i] - value;\n        Matrix temp(rows,columns,val);\n        return temp;\n    }\n};",
            1590026999.9330552,
            100,
            "# 答案正确"
        ],
        [
            "6.2 (C++)",
            "肖澧寅",
            "#include <iostream>\n#include <string>\n#include <iomanip>\n#include <cmath>\n#define f(i,start,n) for(int i = start;i < n;i++)\nusing namespace std;\n\ntemplate <typename E>\nclass Matrix{\nprivate:\n    int rows;\n    int columns;\n    E *values;\npublic:\n    Matrix(int row,int column){\n        rows = row;\n        columns = column;\n        values = new E[row * column];\n        f(i,0,row * column) values[i] = 0;\n    }\n    ~Matrix(){\n        delete []values;\n    }\n    void print(){\n        f(i,0,rows){\n            f(j,0,columns){\n                cout << \"    \" << values[i * columns + j];\n            }\n            cout << endl;\n        }\n    }\n};",
            1590631876.0162485,
            100,
            "# 答案正确"
        ],
        [
            "6.1 (C++)",
            "肖澧寅",
            "#include <iostream>\n#include <string>\n#include <cstring>\n#include <cstdlib>\n#include <iomanip>\n#include <cmath>\n#define f(i,start,n) for(int i = start;i < n;i++)\nusing namespace std;\n\ntemplate <typename E>\nclass Matrix{\nprivate:\n    int rows;\n    int columns;\n    E *values;\n    void ass(int row, int column, const E value[]){\n        rows = row;\n        columns = column;\n        if(values != 0) delete []values;\n        values = new E[row * column];\n        f(i,0,row * column) values[i] = value[i];\n    }\npublic:\n    Matrix<E>(int row,int column){\n        rows = row;\n        columns = column;\n        values = new E[row * column];\n        memset(values,0,row * column * sizeof(E)) ;\n    }\n    Matrix<E>(int row, int column, const E value[]){\n        values = 0;\n        ass(row,column,value);\n    }\n    Matrix<E>(const Matrix<E> & matrix2){\n        values = 0;\n        ass(matrix2.rows,matrix2.columns,matrix2.values);\n    }\n    ~Matrix(){\n        delete []values;\n    }\n    void print(){\n        f(i,0,rows){\n            f(j,0,columns){\n                cout << \"    \" << values[i * columns + j];\n            }\n            cout << endl;\n        }\n    }\n    E& get(int row, int column){\n        row--;\n        column--;\n        return values[row * columns + column];\n    }\n    Matrix<E>& operator = (const Matrix<E>& mat){\n        ass(mat.rows,mat.columns,mat.values);\n        return (*this);\n    }\n\n};",
            1590636901.1794324,
            100,
            "# 答案正确"
        ],
        [
            "6.3 (C++)",
            "肖澧寅",
            "#include <iostream>\n#include <string>\n#include <cstring>\n#include <cstdlib>\n#include <iomanip>\n#include <cmath>\n#include <vector>\n#define f(i,start,n) for(int i = start;i < n;i++)\nusing namespace std;\n\ntemplate <typename E>\nclass Matrix{\nprivate:\n    int rows;\n    int columns;\n    vector<E> values;\n    void ass(int row, int column, const vector<E> value){\n        rows = row;\n        columns = column;\n        values = value;\n    }\npublic:\n    Matrix<E>(int row,int column){\n        rows = row;\n        columns = column;\n        values = vector<E>(row * column);\n    }\n    Matrix<E>(int row, int column, const vector<E> value){\n        ass(row,column,value);\n    }\n    Matrix<E>(const Matrix<E> & matrix2){\n        ass(matrix2.rows,matrix2.columns,matrix2.values);\n    }\n    ~Matrix(){}\n    void print(){\n        f(i,0,rows){\n            f(j,0,columns){\n                cout << \"    \" << values[i * columns + j];\n            }\n            cout << endl;\n        }\n    }\n    E& get(int row, int column){\n        row--;\n        column--;\n        return values[row * columns + column];\n    }\n    Matrix<E>& operator = (const Matrix<E>& mat){\n        ass(mat.rows,mat.columns,mat.values);\n        return (*this);\n    }\n    Matrix<E> getColumn(int col){\n        vector<E> tem;\n        col--;\n        f(i,0,rows){\n            tem.push_back(values[i * columns + col]);\n        }\n        Matrix temp(rows,1,tem);\n        return temp;\n    }\n    Matrix<E> getRow(int row){\n        vector<E> tem;\n        row--;\n        f(i,0,columns){\n            tem.push_back(values[row * columns + i]);\n        }\n        Matrix<E> temp(1,columns,tem);\n        return temp;\n    }\n    Matrix<E> concatenateRows(Matrix& mat){\n        vector<E> tem;\n        f(i,0,values.size()){\n            tem.push_back(values[i]);\n        }\n        f(i,0,mat.values.size()){\n            tem.push_back(mat.values[i]);\n        }\n        Matrix<E> temp(rows+mat.rows,columns,tem);\n        return temp;\n    }\n    Matrix<E> concatenateColumns(Matrix& mat){\n        vector<E> tem;\n        f(i,0,rows){\n            f(j,0,columns){\n                tem.push_back(values[i * columns + j]);\n            }\n            f(j,0,mat.columns){\n                tem.push_back(mat.values[i * mat.columns + j]);\n            }\n        }\n        Matrix<E> temp(rows,columns + mat.columns,tem);\n        return temp;\n    }\n    Matrix<E> reshape(int row,int column){\n        vector<E> value;\n        f(j,0,columns) f(i,0,rows) value.push_back(values[i * columns + j]);\n        vector<E> value2(row * column);\n        int index = 0;\n        f(j,0,column) f(i,0,row) value2[i * column + j] = value[index++];\n        Matrix<E> temp(row,column,value2);\n        return temp;\n    }\n    Matrix transpose(){\n        vector<E> value(rows * columns);\n        f(i,0,rows) f(j,0,columns) value[j * rows + i] = values[i * columns + j];\n        Matrix temp(columns,rows,value);\n        return temp;\n    }\n    Matrix operator + (const Matrix<E> & matrix2) const{\n        vector<E> val(rows * columns);\n        f(i,0,rows * columns) val[i] = values[i] + matrix2.values[i];\n        Matrix temp(rows,columns,val);\n        return temp;\n    }\n    Matrix operator + (E value) const{\n        vector<E> val(rows * columns);\n        f(i,0,rows * columns) val[i] = value + values[i];\n        Matrix temp(rows,columns,val);\n        return temp;\n    }\n    Matrix operator - (const Matrix<E> & matrix2) const{\n        vector<E> val(rows * columns);\n        f(i,0,rows * columns) val[i] = values[i] - matrix2.values[i];\n        Matrix temp(rows,columns,val);\n        return temp;\n    }\n    Matrix operator - (E value) const{\n        vector<E> val(rows * columns);\n        f(i,0,rows * columns) val[i] = values[i] - value;\n        Matrix temp(rows,columns,val);\n        return temp;\n    }\n    Matrix operator * (const Matrix & matrix2) const{\n        vector<E> value(rows * columns,0);\n        f(i,0,rows) f(j,0,matrix2.columns) f(k,0,columns)\n            value[i * matrix2.columns + j] += values[i * columns + k] * matrix2.values[k * matrix2.columns + j];\n        Matrix temp(rows,matrix2.columns,value);\n        return temp;\n    }\n    Matrix operator * (E value) const{\n        vector<E> val(rows * columns);\n        f(i,0,rows * columns) val[i] = value * values[i];\n        Matrix temp(rows,columns,val);\n        return temp;\n    }\n    Matrix max() const{\n        if(rows == 1){\n            E max = values[0];\n            f(i,0,columns) if(values[i] > max) max = values[i];\n            vector<E> tem = {max};\n            Matrix temp(1,1,tem);\n            return temp;\n        }\n        else{\n            vector<E> max(columns);\n            f(i,0,columns) max[i] = values[i];\n            int index = 0;\n            f(j,0,columns){\n                f(i,0,rows){\n                    if(values[i * columns + j] > max[index]) max[index] = values[i * columns + j];\n                }\n                index++;\n            }\n            Matrix temp(1,columns,max);\n            return temp;\n        }\n    }\n    Matrix min() const{\n        if(rows == 1){\n            E min = values[0];\n            f(i,0,columns) if(values[i] < min) min = values[i];\n            vector<E> tem = {min};\n            Matrix temp(1,1,tem);\n            return temp;\n        }\n        else{\n            vector<E> min(columns);\n            f(i,0,columns) min[i] = values[i];\n            int index = 0;\n            f(j,0,columns){\n                f(i,0,rows){\n                    if(values[i * columns + j] < min[index]) min[index] = values[i * columns + j];\n                }\n                index++;\n            }\n            Matrix temp(1,columns,min);\n            return temp;\n        }\n    }\n    Matrix sum() const{\n        if(rows == 1){\n            E sum = 0;\n            f(i,0,columns) sum += values[i];\n            vector<E> tem{sum};\n            Matrix temp(1,1,tem);\n            return temp;\n        }\n        else{\n            vector<E> sum(columns,0);\n            int index = 0;\n            f(j,0,columns){\n                f(i,0,rows){\n                    sum[index] += values[i * columns + j];\n                }\n                index++;\n            }\n            Matrix temp(1,columns,sum);\n            return temp;\n        }\n    }\n};",
            1590643258.5953815,
            100,
            "# 答案正确"
        ],
        [
            "7.1 (C++)",
            "肖澧寅",
            "#include <cmath>\nclass Triangle: public GeometricObject{\nprivate:\n    double side1 = 1.0, side2 = 1.0, side3 = 1.0;\npublic:\n    Triangle() = default;\n    Triangle(double a,double b,double c) : side1(a) , side2(b) , side3(c){}\n    double getSide1(){\n        return side1;\n    }\n    double getSide2(){\n        return side2;\n    }\n    double getSide3(){\n        return side3;\n    }\n    double getArea(){\n        double s = (side1 + side2 + side3) / 2.0;\n        double area = sqrt(s * (s - side1) * (s - side2) * (s - side3));\n        return area;\n    }\n    double getPerimeter(){\n        return side1 + side2 + side3;\n    }\n};",
            1590736444.4294786,
            100,
            "# 答案正确"
        ],
        [
            "7.3 (C++)",
            "肖澧寅",
            "template <typename E>\nE add(const E &a,const E &b){\n    return a + b;\n}\n\ntemplate <typename A>\nvector<A> map2(vector<A> data1,vector<A> data2,A (*map2_func)(const A &,const A &)){\n    vector<A> res;\n    for(int i = 0;i < data1.size();i++){\n        res.push_back(map2_func(data1[i],data2[i]));\n    }\n    return res;\n}\n\ntemplate <typename A>\nvector<A> map2(vector<A> data1,A data2,A (*map2_func)(const A &,const A &)){\n    vector<A> res;\n    for(int i = 0;i < data1.size();i++){\n        res.push_back(map2_func(data1[i],data2));\n    }\n    return res;\n}",
            1590738151.718337,
            100,
            "# 答案正确"
        ],
        [
            "7.2 (C++)",
            "肖澧寅",
            "#include <string>\n#include <vector>\nusing namespace std;\nvector<string> split(const string line){\n    vector<string> ans;\n    string space = \" \";\n    int index = 0,findindex;\n    while(index < line.size()){\n        findindex = line.find(space,index);\n        if(findindex == index){\n            index++;\n            continue;\n        }\n        if(findindex != -1){\n            ans.push_back(line.substr(index,findindex - index));\n            index = findindex + 1;\n        }\n        else{\n            ans.push_back(line.substr(index));\n            break;\n        }\n    }\n    return ans;\n}",
            1591237732.4594378,
            100,
            "# 答案正确"
        ],
        [
            "8.1 (C++)",
            "肖澧寅",
            "#define f(i,start,n) for(int i = start;i < n;i++)\nclass Full:public Matrix{\nprivate:\n    int rows;\n    int columns;\n    double *values;\n    void ass(int row, int column, double value[]){\n        rows = row;\n        columns = column;\n        if(values != 0) delete []values;\n        values = new double[row * column];\n        f(i,0,row * column) values[i] = value[i];\n    }\npublic:\n    Full(int row,int column){\n        rows = row;\n        columns = column;\n        values = new double[row * column];\n        f(i,0,row * column) values[i] = 0;\n    }\n    Full(int row, int column, double value[]){\n        values = 0;\n        ass(row,column,value);\n    }\n    Full(const Matrix & matrix2){\n        values = 0;\n        int row,column;\n        row = matrix2.size(1);\n        column = matrix2.size(2);\n        double value[row * column];\n        f(i,0,row){\n            f(j,0,column){\n                value[i * column + j] = matrix2.get(i+1,j+1);\n            }\n        }\n        ass(row,column,value);\n    }\n    ~Full(){\n        delete []values;\n    }\n    virtual void print() const{\n        f(i,0,rows){\n            f(j,0,columns){\n                cout << \"    \" << values[i * columns + j];\n            }\n            cout << endl;\n        }\n    }\n    virtual void set(int row, int column, double value){\n        row--;\n        column--;\n        values[row * columns + column] = value;\n    }\n    virtual int size(int dimension) const{\n        if(dimension == 1) return rows;\n        else return columns;\n    }\n    virtual double get(int row, int column) const{\n        row--;\n        column--;\n        return values[row * columns + column];\n    }\n    virtual Matrix & operator = (const Matrix & matrix2){\n        int row,column;\n        row = matrix2.size(1);\n        column = matrix2.size(2);\n        double value[row * column];\n        f(i,0,row){\n            f(j,0,column){\n                value[i * column + j] = matrix2.get(i+1,j+1);\n            }\n        }\n        ass(row,column,value);\n        return (*this);\n    }\n};",
            1591347578.503866,
            100,
            "# 答案正确"
        ],
        [
            "8.3 (C++)",
            "肖澧寅",
            "#define f(i,start,n) for(int i = start;i < n;i++)\n#include<vector>\n#include<iostream>\nusing namespace std;\nclass Sparse:public Matrix{\nprivate:\n    int rows;\n    int columns;\n    vector<Entry> entry;\npublic:\n    Sparse(int row, int column): rows(row),columns(column){}\n    Sparse(const Sparse& other){\n        rows = other.rows;\n        columns = other.columns;\n        entry = other.entry;\n    }\n    int find(const int row,const int column,const vector<Entry> entry) const{\n        f(i,0,entry.size()){\n            if(row == entry[i].row && column == entry[i].column) return i;\n        }\n        return -1;\n    }\n    Sparse operator + (Sparse & sparse2){\n        Sparse ans(rows,columns);\n        f(i,0,entry.size()){\n            Entry temp = entry[i];\n            int index = find(entry[i].row,entry[i].column,sparse2.entry);\n            if(index != -1){\n                temp.value += sparse2.entry[index].value;\n            }\n            if(temp.value != 0) ans.entry.push_back(temp);\n        }\n        f(i,0,sparse2.entry.size()){\n            if(find(sparse2.entry[i].row,sparse2.entry[i].column,entry) == -1) ans.entry.push_back(sparse2.entry[i]);\n        }\n        return ans;\n    }\n    virtual int size(int dimension) const{\n        if(dimension == 1) return rows;\n        else return columns;\n    }\n    virtual void set(int row, int column, double value){\n        int index = find(row,column,entry);\n        if(index == -1){\n            Entry temp{row,column,value};\n            entry.push_back(temp);\n        }\n        else{\n            entry[index].value = value;\n        }\n    }\n\tvirtual double get(int row, int column) const{\n\t    int index = find(row,column,entry);\n\t    return entry[index].value;\n\t}\n\tvirtual void print(){\n        f(i,0,entry.size() - 1){\n            f(j,i+1,entry.size()){\n                if(entry[i].row > entry[j].row || (entry[i].row == entry[j].row && entry[i].column > entry[j].column)){\n                    Entry temp;\n                    temp = entry[i];\n                    entry[i] = entry[j];\n                    entry[j] = temp;\n                }\n            }\n        }\n        f(i,0,entry.size()){\n            cout << \"(\" << entry[i].row << \",\" << entry[i].column << \",\" << entry[i].value << \")\" << endl;\n        }\n\t}\n};",
            1591361692.713847,
            100,
            "# 答案正确"
        ],
        [
            "8.4 (C++)",
            "肖澧寅",
            "#define f(i,start,n) for(int i = start;i < n;i++)\n#include<vector>\n#include<iostream>\nusing namespace std;\nclass Sparse:public Matrix{\nprivate:\n    int rows;\n    int columns;\n    vector<Entry> entry;\npublic:\n    Sparse(int row, int column): rows(row),columns(column){}\n    Sparse(const Sparse& other){\n        rows = other.rows;\n        columns = other.columns;\n        entry = other.entry;\n    }\n    int find(const int row,const int column,const vector<Entry> entry) const{\n        f(i,0,entry.size()){\n            if(row == entry[i].row && column == entry[i].column) return i;\n        }\n        return -1;\n    }\n    int finnd(const int row,const vector<Entry> entry,const int start) const{\n        f(i,start,entry.size()){\n            if(row == entry[i].row) return i;\n        }\n        return -1;\n    }\n    Sparse operator + (Sparse & sparse2){\n        Sparse ans(rows,columns);\n        f(i,0,entry.size()){\n            Entry temp = entry[i];\n            int index = find(entry[i].row,entry[i].column,sparse2.entry);\n            if(index != -1){\n                temp.value += sparse2.entry[index].value;\n            }\n            if(temp.value != 0) ans.entry.push_back(temp);\n        }\n        f(i,0,sparse2.entry.size()){\n            if(find(sparse2.entry[i].row,sparse2.entry[i].column,entry) == -1) ans.entry.push_back(sparse2.entry[i]);\n        }\n        return ans;\n    }\n    Sparse operator * (Sparse & sparse2){\n        Sparse ans(rows,sparse2.columns);\n        f(i,0,entry.size()){\n            int index = -1;\n            while(index < (int)sparse2.entry.size()){\n                index = finnd(entry[i].column,sparse2.entry,index + 1);\n                if(index == -1){\n                    break;\n                }\n                Entry temp;\n                temp.row = entry[i].row;\n                temp.column = sparse2.entry[index].column;\n                temp.value = entry[i].value * sparse2.entry[index].value;\n                int iindex = find(temp.row,temp.column,ans.entry);\n                if(iindex == -1) ans.entry.push_back(temp);\n                else ans.entry[iindex].value += temp.value;\n            }\n        }\n        return ans;\n    }\n    virtual int size(int dimension) const{\n        if(dimension == 1) return rows;\n        else return columns;\n    }\n    virtual void set(int row, int column, double value){\n        int index = find(row,column,entry);\n        if(index == -1){\n            Entry temp{row,column,value};\n            entry.push_back(temp);\n        }\n        else{\n            entry[index].value = value;\n        }\n    }\n\tvirtual double get(int row, int column) const{\n\t    int index = find(row,column,entry);\n\t    return entry[index].value;\n\t}\n\tvirtual void print(){\n        f(i,0,(int)entry.size() - 1){\n            f(j,i+1,(int)entry.size()){\n                if(entry[i].row > entry[j].row || (entry[i].row == entry[j].row && entry[i].column > entry[j].column)){\n                    Entry temp;\n                    temp = entry[i];\n                    entry[i] = entry[j];\n                    entry[j] = temp;\n                }\n            }\n        }\n        f(i,0,(int)entry.size()){\n            cout << \"(\" << entry[i].row << \",\" << entry[i].column << \",\" << entry[i].value << \")\" << endl;\n        }\n\t}\n};",
            1591456993.7684062,
            100,
            "# 答案正确"
        ],
        [
            "8.5 (C++)",
            "肖澧寅",
            "class Point3D: public Point2D{\nprivate:\n    double z;\npublic:\n    Point3D() : Point2D(),z(0){}\n    Point3D(double xx,double yy,double zz): z(zz){\n        setX(xx);\n        setY(yy);\n    }\n    double getZ() {\n\t\treturn z;\n\t}\n\tvirtual double distance(Point2D & point2) {\n\t    Point3D& p2 = dynamic_cast<Point3D&> (point2);\n\t\tdouble dx = getX() - p2.getX();\n\t\tdouble dy = getY() - p2.getY();\n\t\tdouble dz = getZ() - p2.getZ();\n\t\treturn sqrt(dx * dx + dy * dy + dz * dz);\n\t}\n};",
            1591843986.0195851,
            100,
            "# 答案正确"
        ],
        [
            "8.6 (C++)",
            "肖澧寅",
            "#include <iostream>\nclass MyTensor : public Tensor<double>{\nprivate:\n    double* data;\npublic:\n    MyTensor(vector<int> i) : Tensor<double>(i){\n        int sum = 1;\n        for(int i = 0;i < sizes.size();i++){\n            sum *= sizes[i];\n        }\n        data = new double[sum];\n    }\n    ~MyTensor(){\n        delete []data;\n    }\n    virtual double & get(const vector<int> & indexes){\n        int siz = sizes.size();\n        int sizzz = indexes[0];\n        for(int i = 0;i < siz-1;i++){\n            sizzz = sizzz * sizes[i+1] + indexes[i+1];\n        }\n        return data[sizzz];\n    }\n};",
            1592448584.5165036,
            100,
            "# 答案正确"
        ],
        [
            "9.1 (C++)",
            "肖澧寅",
            "class Circle{\nprivate:\n    double radii;\npublic:\n    Circle(double radius): radii(radius){}\n    int operator <(Circle c2){\n        if(radii < c2.radii) return 1;\n        else return 0;\n    }\n    int operator <=(Circle c2){\n        if(radii <= c2.radii) return 1;\n        else return 0;\n    }\n    int operator ==(Circle c2){\n        if(radii == c2.radii) return 1;\n        else return 0;\n    }\n    int operator !=(Circle c2){\n        if(radii != c2.radii) return 1;\n        else return 0;\n    }\n    int operator >(Circle c2){\n        if(radii > c2.radii) return 1;\n        else return 0;\n    }\n    int operator >=(Circle c2){\n        if(radii >= c2.radii) return 1;\n        else return 0;\n    }\n};",
            1592537012.751837,
            100,
            "# 答案正确"
        ],
        [
            "9.2 (C++)",
            "肖澧寅",
            "class I{\nprivate:\n    vector<int> sizes;\npublic:\n    I(int a,int b,int c){\n        sizes.push_back(a);\n        sizes.push_back(b);\n        sizes.push_back(c);\n    }\n    I(int a,int b,int c,int d){\n        sizes.push_back(a);\n        sizes.push_back(b);\n        sizes.push_back(c);\n        sizes.push_back(d);\n    }\n    operator vector<int>()const{\n        return sizes;\n    }\n};",
            1592538046.7261295,
            100,
            "# 答案正确"
        ],
        [
            "9.3 (C++)",
            "肖澧寅",
            "class Complex{\nprivate:\n    double a;\n    double b;\npublic:\n    Complex(double x): a(x),b(0){}\n    Complex(double a,double b): a(a),b(b){}\n    Complex(const Complex& ano): a(ano.a),b(ano.b){}\n    double real()const{return a;}\n    double imag()const{return b;}\n    Complex& operator =(const Complex& ano){\n        a = ano.a;\n        b = ano.b;\n        return (*this);\n    }\n    Complex operator -(const Complex& ano) const{\n        Complex temp(a - ano.a,b - ano.b);\n        return temp;\n    }\n    Complex operator *(const Complex& ano) const{\n        double aa = a * ano.a - b * ano.b;\n        double bb = a * ano.b + ano.a * b;\n        Complex temp(aa,bb);\n        return temp;\n    }\n    Complex operator /(const Complex& ano) const{\n        double aa = (a * ano.a + b * ano.b) / (ano.a * ano.a + ano.b * ano.b);\n        double bb = (-a * ano.b + ano.a * b) / (ano.a * ano.a + ano.b * ano.b);\n        Complex temp(aa,bb);\n        return temp;\n    }\n    Complex& operator +=(const Complex& ano){\n        a += ano.a;\n        b += ano.b;\n        return (*this);\n    }\n    Complex& operator -=(const Complex& ano){\n        a -= ano.a;\n        b -= ano.b;\n        return (*this);\n    }\n    Complex& operator *=(const Complex& ano){\n        double aa = a * ano.a - b * ano.b;\n        double bb = a * ano.b + ano.a * b;\n        a = aa;\n        b = bb;\n        return (*this);\n    }\n    Complex& operator /=(const Complex& ano){\n        double aa = (a * ano.a + b * ano.b) / (ano.a * ano.a + ano.b * ano.b);\n        double bb = (-a * ano.b + ano.a * b) / (ano.a * ano.a + ano.b * ano.b);\n        a = aa;\n        b = bb;\n        return (*this);\n    }\n    bool operator ==(const Complex& ano){\n        if(a == ano.a && b == ano.b) return true;\n        else return false;\n    }\n    bool operator !=(const Complex& ano){\n        if(a == ano.a && b == ano.b) return false;\n        else return true;\n    }\n};\n\nComplex operator +(const Complex& a,const Complex& b){\n    Complex temp(a.real() + b.real(),a.imag() + b.imag());\n    return temp;\n}",
            1592540063.4392385,
            100,
            "# 答案正确"
        ],
        [
            "9.4 (C++)",
            "肖澧寅",
            "class Complex{\nprivate:\n    double a;\n    double b;\npublic:\n    Complex():a(0),b(0){}\n    Complex(double x): a(x),b(0){}\n    Complex(double a,double b): a(a),b(b){}\n    Complex(const Complex& ano): a(ano.a),b(ano.b){}\n    double real()const{return a;}\n    double imag()const{return b;}\n    Complex& operator =(const Complex& ano){\n        a = ano.a;\n        b = ano.b;\n        return (*this);\n    }\n    Complex operator -(const Complex& ano) const{\n        Complex temp(a - ano.a,b - ano.b);\n        return temp;\n    }\n    Complex operator *(const Complex& ano) const{\n        double aa = a * ano.a - b * ano.b;\n        double bb = a * ano.b + ano.a * b;\n        Complex temp(aa,bb);\n        return temp;\n    }\n    Complex operator /(const Complex& ano) const{\n        double aa = (a * ano.a + b * ano.b) / (ano.a * ano.a + ano.b * ano.b);\n        double bb = (-a * ano.b + ano.a * b) / (ano.a * ano.a + ano.b * ano.b);\n        Complex temp(aa,bb);\n        return temp;\n    }\n    Complex& operator +=(const Complex& ano){\n        a += ano.a;\n        b += ano.b;\n        return (*this);\n    }\n    Complex& operator -=(const Complex& ano){\n        a -= ano.a;\n        b -= ano.b;\n        return (*this);\n    }\n    Complex& operator *=(const Complex& ano){\n        double aa = a * ano.a - b * ano.b;\n        double bb = a * ano.b + ano.a * b;\n        a = aa;\n        b = bb;\n        return (*this);\n    }\n    Complex& operator /=(const Complex& ano){\n        double aa = (a * ano.a + b * ano.b) / (ano.a * ano.a + ano.b * ano.b);\n        double bb = (-a * ano.b + ano.a * b) / (ano.a * ano.a + ano.b * ano.b);\n        a = aa;\n        b = bb;\n        return (*this);\n    }\n    bool operator ==(const Complex& ano){\n        if(a == ano.a && b == ano.b) return true;\n        else return false;\n    }\n    bool operator !=(const Complex& ano){\n        if(a == ano.a && b == ano.b) return false;\n        else return true;\n    }\n\n};\n\nComplex operator +(const Complex& a,const Complex& b){\n    Complex temp(a.real() + b.real(),a.imag() + b.imag());\n    return temp;\n}\nistream& operator >> (istream& in,Complex& com){\n    double a,b;\n    in >> a >> b;\n    Complex temp(a,b);\n    com = temp;\n    return in;\n}\nostream& operator << (ostream& out,Complex& com){\n    out <<  com.real() << \" + \" << com.imag() << \" i\";\n    return out;\n}",
            1592540586.1091888,
            100,
            "# 答案正确"
        ],
        [
            "9.5 (C++)",
            "肖澧寅",
            "class Complex{\nprivate:\n    double a;\n    double b;\npublic:\n    Complex():a(0),b(0){}\n    Complex(double x): a(x),b(0){}\n    Complex(double a,double b): a(a),b(b){}\n    Complex(const Complex& ano): a(ano.a),b(ano.b){}\n    double real()const{return a;}\n    double imag()const{return b;}\n    Complex& operator =(const Complex& ano){\n        a = ano.a;\n        b = ano.b;\n        return (*this);\n    }\n    Complex operator -(const Complex& ano) const{\n        Complex temp(a - ano.a,b - ano.b);\n        return temp;\n    }\n    Complex operator *(const Complex& ano) const{\n        double aa = a * ano.a - b * ano.b;\n        double bb = a * ano.b + ano.a * b;\n        Complex temp(aa,bb);\n        return temp;\n    }\n    Complex operator /(const Complex& ano) const{\n        double aa = (a * ano.a + b * ano.b) / (ano.a * ano.a + ano.b * ano.b);\n        double bb = (-a * ano.b + ano.a * b) / (ano.a * ano.a + ano.b * ano.b);\n        Complex temp(aa,bb);\n        return temp;\n    }\n    Complex& operator +=(const Complex& ano){\n        a += ano.a;\n        b += ano.b;\n        return (*this);\n    }\n    Complex& operator -=(const Complex& ano){\n        a -= ano.a;\n        b -= ano.b;\n        return (*this);\n    }\n    Complex& operator *=(const Complex& ano){\n        double aa = a * ano.a - b * ano.b;\n        double bb = a * ano.b + ano.a * b;\n        a = aa;\n        b = bb;\n        return (*this);\n    }\n    Complex& operator /=(const Complex& ano){\n        double aa = (a * ano.a + b * ano.b) / (ano.a * ano.a + ano.b * ano.b);\n        double bb = (-a * ano.b + ano.a * b) / (ano.a * ano.a + ano.b * ano.b);\n        a = aa;\n        b = bb;\n        return (*this);\n    }\n    bool operator ==(const Complex& ano){\n        if(a == ano.a && b == ano.b) return true;\n        else return false;\n    }\n    bool operator !=(const Complex& ano){\n        if(a == ano.a && b == ano.b) return false;\n        else return true;\n    }\n    Complex& operator ++(){\n        a++;\n        return (*this);\n    }\n    Complex operator ++(int){\n        Complex temp(*this);\n        a++;\n//        cout <<  temp.real() << \" + \" << temp.imag() << \" i\" << endl;\n        return temp;\n    }\n    operator double(){\n        return a;\n    }\n};\n\nComplex operator +(const Complex& a,const Complex& b){\n    Complex temp(a.real() + b.real(),a.imag() + b.imag());\n    return temp;\n}\nistream& operator >> (istream& in,Complex& com){\n    double a,b;\n    in >> a >> b;\n    Complex temp(a,b);\n    com = temp;\n    return in;\n}\nostream& operator << (ostream& out,const Complex& com){\n    out <<  com.real() << \" + \" << com.imag() << \" i\";\n    return out;\n}",
            1592542039.662085,
            100,
            "# 答案正确"
        ],
        [
            "9.6 (C++)",
            "肖澧寅",
            "class Tensor{\nprivate:\n    vector<int> sizes;\n    double* data;\npublic:\n    Tensor(int a,int b,int c){\n        sizes.push_back(a);\n        sizes.push_back(b);\n        sizes.push_back(c);\n        data = new double[a * b * c];\n    }\n    Tensor(int a,int b,int c,int d){\n        sizes.push_back(a);\n        sizes.push_back(b);\n        sizes.push_back(c);\n        sizes.push_back(d);\n        data = new double[a * b * c * d];\n    }\n    ~Tensor(){\n        delete []data;\n    }\n    double& operator ()(int a,int b,int c){\n        int s = (a * sizes[1] + b) * sizes[2] + c;\n        return data[s];\n    }\n    double& operator ()(int a,int b,int c,int d){\n        int s = ((a * sizes[1] + b) * sizes[2] + c) * sizes[3] + d;\n        return data[s];\n    }\n};",
            1592548026.7782319,
            100,
            "# 答案正确"
        ],
        [
            "9.7 (C++)",
            "肖澧寅",
            "class Tensor\n{\nprivate:\n    int dimention;\n\tvector<int> sizes;\n\tvector<double> values;\npublic:\n\tTensor() = default;\n\tTensor(int dimention,vector<int> sizes,vector<double> values): dimention(dimention),sizes(sizes),values(values){}\n\tint allsize() const {\n\t\tif (this->sizes.size() == 0) return 0;\n\t\tint size = 1;\n\t\tfor (int i = 0; i < this->sizes.size(); ++ i) size *= sizes[i];\n\t\treturn size;\n\t}\n\tint di() const{return dimention;}\n    int size(int i) const{return sizes[i];}\n\tdouble get(int i) const {return values[i];}\n\tTensor& operator =(Tensor& ano){\n        dimention = ano.dimention;\n        sizes = ano.sizes;\n        values = ano.values;\n        return (*this);\n\t}\n};\nistream& operator >>(istream& in,Tensor& t){\n    int dimention;\n    in >> dimention;\n    vector<int> sizes;\n    vector<double> values;\n    int allsize = 1;\n    for(int i = 0;i < dimention;i++){\n        int temp;\n        in >> temp;\n        allsize *= temp;\n        sizes.push_back(temp);\n    }\n    for(int i = 0;i < allsize;i++){\n        double temp;\n        in >> temp;\n        values.push_back(temp);\n    }\n    Tensor temp(dimention,sizes,values);\n    t = temp;\n    return in;\n}\nostream& operator <<(ostream& out,const Tensor& t){\n    out << t.di() << endl;\n    for(int i = 0;i < t.di();i++){\n        out << t.size(i) << \" \";\n    }\n    out << endl << endl;\n    int sum = 1;\n    for(int i = 0;i < t.di() - 2;i++){\n        sum *= t.size(i);\n    }\n    int index = 0;\n    for(int i = 0;i < sum;i++){\n        for(int j = 0;j < t.size(t.di() - 2);j++){\n            for(int k = 0;k < t.size(t.di() - 1);k++){\n                out << t.get(index++) << \" \";\n            }\n            out << endl;\n        }\n        out << endl;\n    }\n    return out;\n}",
            1592573471.5060666,
            100,
            "# 答案正确"
        ],
        [
            "10.1 (C++)",
            "肖澧寅",
            "#include <stdexcept>\n#define f(i,start,n) for(int i = start;i < n;i++)\nclass MatrixSizesDoNotMatchException{};\ndouble Matrix::get(int row,int column) const{\n    if(row > rows || column > columns) throw out_of_range(\"error\");\n    row--;\n    column--;\n    return elements[row * columns + column];\n}\nvoid Matrix::set(int row, int column, double value){\n    if(row > rows || column > columns) throw out_of_range(\"error\");\n    row--;\n    column--;\n    elements[row * columns + column] = value;\n}\nMatrix Matrix::operator+ (const Matrix & matrix2) const{\n    if(rows != matrix2.size(1) || columns != matrix2.size(2)) throw MatrixSizesDoNotMatchException();\n    Matrix temp(rows,columns);\n    f(i,0,rows) f(j,0,columns) temp.set(i+1,j+1,get(i+1,j+1) + matrix2.get(i+1,j+1));\n    return temp;\n}",
            1593491197.1692345,
            100,
            "# 答案正确"
        ],
        [
            "10.2 (C++)",
            "肖澧寅",
            "catch(NonPositiveValueException& error){\n            cout << \"caught: NonPositiveValueException\" << endl;\n        }\n        catch(out_of_range& error){\n            cout << \"caught: out_of_range\" << endl;\n        }",
            1593656515.6907465,
            100,
            "# 答案正确"
        ],
        [
            "15.1 (C++)",
            "肖澧寅",
            "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\ntypedef struct{\n    vector<string> head;\n    vector<vector<string> > rol;\n}Json;\nclass Table{\nprivate:\n    vector<string> head;\n    vector<vector<string> > rol;\npublic:\n    Table(){}\n    ~Table(){}\n    void addCol(string temp){\n        head.push_back(temp);\n    }\n    vector<string>& operator [](int i){\n        if(i < rol.size()) return rol[i];\n        rol.push_back(vector<string>());\n        return rol[i];\n    }\n    Json json()const{\n        Json ans;\n        ans.head = head;\n        ans.rol = rol;\n        return ans;\n    }\n};\nostream& operator << (ostream & out,const Json& ans){\n    out << \"{\" << endl;\n    out << \"\theaders: [\";\n    for(int i = 0;i < ans.head.size();i++){\n        out << \"'\" << ans.head[i] << \"',\";\n    }\n    out << \"],\" << endl;\n    out << \"\trows: [\" << endl;\n    for(int i = 0;i < ans.rol.size();i++){\n        out << \"\t\t[\";\n        for(int j = 0;j < ans.rol[i].size();j++){\n            out << \"'\" << ans.rol[i][j] << \"',\";\n        }\n        out << \"],\" << endl;\n    }\n    out << \"\t],\" << endl << \"}\" << endl;\n    return out;\n}",
            1593747079.6214857,
            100,
            "# 答案正确"
        ],
        [
            "2020-07-09 LAB",
            "肖澧寅",
            "#include<iostream>\n#include<vector>\nusing namespace std;\n\nclass Integer{\nprivate:\n    int num;\n    static vector<Integer*> index;\npublic:\n    Integer(): num(0){\n        index.push_back(this);\n    }\n    Integer(int x): num(x){\n        index.push_back(this);\n    }\n    void change_value(const int& x){num = x;}\n    int get_value()const{return num;}\n    static void increase_all(const Integer& x){\n        for(int i = 0;i < index.size();i++){\n            index[i]->change_value(index[i]->get_value()+x.get_value());\n        }\n    }\n};\nvector<Integer*> Integer::index = vector<Integer*>();\n\nistream& operator >> (istream& in,Integer& x){\n    int num;\n    in >> num;\n    x.change_value(num);\n    return in;\n}\nostream& operator << (ostream& out,Integer& x){\n    out << x.get_value();\n    return out;\n}",
            1594262776.9701931,
            100,
            "# 答案正确"
        ],
        [
            "A.1 (C++)",
            "肖澧寅",
            "LinkedList(const LinkedList<E>& ano) : _size(0), head(0), tail(0) {\n        Node<E>* anoptr = ano.head;\n        Node<E>* anopre = 0;\n        Node<E>* temp;\n        while(anoptr != 0){\n            E val = anoptr->element;\n            addLast(val);\n            temp = anoptr;\n            anoptr = anoptr->next_node(anopre);\n            anopre = temp;\n        }\n    }\n    ~LinkedList(){\n        Node<E>* ptr = head;\n        Node<E>* pre = 0;\n        Node<E>* temp;\n        while(ptr != 0){\n            temp = ptr;\n            ptr = ptr->next_node(pre);\n            pre = temp;\n            delete pre;\n        }\n    }\n    void addFirst(const E& val){\n        Node<E> * node = new Node<E>();\n        node->element = val;\n        node->update_prev_and_next_node(0,head);\n        if(head != 0) head->update_prev_node(0,node);\n        head = node;\n        if(tail == 0) tail = node;\n        _size++;\n    }\n    void addLast(const E& val){\n        Node<E> * node = new Node<E>();\n        node->element = val;\n        node->update_prev_and_next_node(tail,0);\n        if(tail != 0) tail->update_next_node(0,node);\n        tail = node;\n        if(head == 0) head = node;\n        _size++;\n    }\n    E get(const int& index)const{\n        if(index < 0 || index >= _size) throw NotSuchElementException();\n        Node<E>* ptr = head;\n        Node<E>* pre = 0;\n        Node<E>* temp;\n        I(i,index){\n            temp = ptr;\n            ptr = ptr->next_node(pre);\n            pre = temp;\n        }\n        return ptr->element;\n    }\n    void removeFirst(){\n        if(_size == 0) throw NotSuchElementException();\n        Node<E>* temp = head;\n        head = head->next_node(0);\n        if(head != 0) head->update_prev_node(temp,0);\n        delete temp;\n        _size--;\n        if(_size == 0) tail = 0;\n    }\n    void removeLast(){\n        if(_size == 0) throw NotSuchElementException();\n        Node<E>* temp = tail;\n        tail = tail->prev_node(0);\n        if(tail != 0) tail->update_next_node(temp,0);\n        delete temp;\n        _size--;\n        if(_size == 0) head = 0;\n    }\n    void removeFirstOccurrence(const E& val){\n        Node<E>* ptr = head;\n        Node<E>* pre = 0;\n        Node<E>* temp;\n        while(ptr != 0 && ptr->element != val){\n            temp = ptr;\n            ptr = ptr->next_node(pre);\n            pre = temp;\n        }\n        if(ptr == 0) throw NotSuchElementException();\n        Node<E>* next = ptr->next_node(pre);\n        if(pre != 0) pre->update_next_node(ptr,next);\n        if(next != 0) next->update_prev_node(ptr,pre);\n        if(ptr == head) head = next;\n        if(ptr == tail) tail = pre;\n        delete ptr;\n        _size--;\n    }",
            1594458580.9241269,
            100,
            "# 答案正确"
        ],
        [
            "A.2 (C++)",
            "肖澧寅",
            "template <typename E>\nvoid LinkedList<E>::removeAll(const E & e){\n    while(contains(e) == true){\n        removeFirstOccurrence(e);\n    }\n}",
            1594865576.1095734,
            100,
            "# 答案正确"
        ],
        [
            "A.4 (C++)",
            "肖澧寅",
            "#include<string>\n#include<iostream>\n#include<vector>\n#define f(i,start,n) for(int i = start;i < n;i++)\nusing namespace std;\n\nclass NotSuchKeyException{};\nclass Key_int_return;\nclass HT{\n    class ssTuple{\n    public:\n        string key;\n        string value;\n        ssTuple(const string& key,const string& value): key(key),value(value){}\n    };\n    class iiTuple{\n    public:\n        int key;\n        int value;\n        iiTuple(const int& key,const int& value): key(key),value(value){}\n    };\n    class isTuple{\n    public:\n        int key;\n        string value;\n        isTuple(const int& key,const string& value): key(key),value(value){}\n    };\n    class siTuple{\n    public:\n        string key;\n        int value;\n        siTuple(const string& key,const int& value): key(key),value(value){}\n    };\n    class Key_int_return{\n    private:\n        HT* ht;\n        isTuple* istuple;\n        iiTuple* iituple;\n        const int& key;\n    public:\n        Key_int_return(HT* ht,isTuple* istuple,iiTuple* iituple,const int& key):\n            ht(ht), istuple(istuple), iituple(iituple), key(key){}\n        operator int() const{\n            if(iituple == 0) throw NotSuchKeyException();\n            return iituple->value;\n        }\n        operator string() const{\n            if(istuple == 0) throw NotSuchKeyException();\n            return istuple->value;\n        }\n    };\n    class Key_string_return{\n    private:\n        HT* ht;\n        ssTuple* sstuple;\n        siTuple* situple;\n        const string& key;\n    public:\n        Key_string_return(HT* ht,ssTuple* sstuple,siTuple* situple,const string& key):\n            ht(ht), sstuple(sstuple), situple(situple), key(key){}\n        operator int() const{\n            if(situple == 0) throw NotSuchKeyException();\n            return situple->value;\n        }\n        operator string() const{\n            if(sstuple == 0) throw NotSuchKeyException();\n            return sstuple->value;\n        }\n    };\nprivate:\n    vector<ssTuple> sstuples;\n    vector<iiTuple> iituples;\n    vector<siTuple> situples;\n    vector<isTuple> istuples;\n    size_t ii_indexOfkey(const int& key)const{\n        f(i,0,iituples.size()){\n            if(iituples[i].key == key) return i;\n        }\n        return -1;\n    }\n    size_t is_indexOfkey(const int& key)const{\n        f(i,0,istuples.size()){\n            if(istuples[i].key == key) return i;\n        }\n        return -1;\n    }\n    size_t ss_indexOfkey(const string& key)const{\n        f(i,0,sstuples.size()){\n            if(sstuples[i].key == key) return i;\n        }\n        return -1;\n    }\n    size_t si_indexOfkey(const string& key)const{\n        f(i,0,situples.size()){\n            if(situples[i].key == key) return i;\n        }\n        return -1;\n    }\n\npublic:\n    void put(const int& key,const int& value){\n        size_t index = ii_indexOfkey(key);\n        if(index == -1){\n            iituples.push_back(iiTuple(key,value));\n        }\n        else{\n            iituples[index].value = value;\n        }\n    }\n    void put(const int& key,const string& value){\n        size_t index = is_indexOfkey(key);\n        if(index == -1){\n            istuples.push_back(isTuple(key,value));\n        }\n        else{\n            istuples[index].value = value;\n        }\n    }\n    void put(const string& key,const string& value){\n        size_t index = ss_indexOfkey(key);\n        if(index == -1){\n            sstuples.push_back(ssTuple(key,value));\n        }\n        else{\n            sstuples[index].value = value;\n        }\n    }\n    void put(const string& key,const int& value){\n        size_t index = si_indexOfkey(key);\n        if(index == -1){\n            situples.push_back(siTuple(key,value));\n        }\n        else{\n            situples[index].value = value;\n        }\n    }\n    Key_int_return operator [](const int& key){\n        size_t index;\n        index = ii_indexOfkey(key);\n        if(index != -1) return Key_int_return(this,0,&iituples[index],key);\n        else{\n            index = is_indexOfkey(key);\n            if(index != -1) return Key_int_return(this,&istuples[index],0,key);\n            else return Key_int_return(this,0,0,key);\n        }\n    }\n    Key_string_return operator [](const string& key){\n        size_t index;\n        index = si_indexOfkey(key);\n        if(index != -1) return Key_string_return(this,0,&situples[index],key);\n        else{\n            index = ss_indexOfkey(key);\n            if(index != -1) return Key_string_return(this,&sstuples[index],0,key);\n            else return Key_string_return(this,0,0,key);\n        }\n    }\n    int size(){\n        return iituples.size()+sstuples.size()+situples.size()+istuples.size();\n    }\n\n};",
            1595411364.520177,
            100,
            "# 答案正确"
        ],
        [
            "A.5 (C++)",
            "肖澧寅",
            "#include<string>\n#include<iostream>\n#include<vector>\n#define f(i,start,n) for(int i = start;i < n;i++)\nusing namespace std;\n\nclass NotSuchKeyException{};\nclass Key_int_return;\nclass HT{\n    class ssTuple{\n    public:\n        string key;\n        string value;\n        ssTuple(const string& key,const string& value): key(key),value(value){}\n    };\n    class iiTuple{\n    public:\n        int key;\n        int value;\n        iiTuple(const int& key,const int& value): key(key),value(value){}\n    };\n    class isTuple{\n    public:\n        int key;\n        string value;\n        isTuple(const int& key,const string& value): key(key),value(value){}\n    };\n    class siTuple{\n    public:\n        string key;\n        int value;\n        siTuple(const string& key,const int& value): key(key),value(value){}\n    };\n    class Key_int_return{\n    private:\n        HT* ht;\n        isTuple* istuple;\n        iiTuple* iituple;\n        const int& key;\n    public:\n        Key_int_return(HT* ht,isTuple* istuple,iiTuple* iituple,const int& key):\n            ht(ht), istuple(istuple), iituple(iituple), key(key){}\n        operator int() const{\n            if(iituple == 0) throw NotSuchKeyException();\n            return iituple->value;\n        }\n        operator string() const{\n            if(istuple == 0) throw NotSuchKeyException();\n            return istuple->value;\n        }\n        Key_int_return& operator = (const int& value){\n            if(iituple != 0) iituple->value = value;\n            else ht->put(key,value);\n            return *this;\n        }\n        Key_int_return& operator = (const string& value){\n            if(istuple != 0) istuple->value = value;\n            else ht->put(key,value);\n            return *this;\n        }\n    };\n    class Key_string_return{\n    private:\n        HT* ht;\n        ssTuple* sstuple;\n        siTuple* situple;\n        const string& key;\n    public:\n        Key_string_return(HT* ht,ssTuple* sstuple,siTuple* situple,const string& key):\n            ht(ht), sstuple(sstuple), situple(situple), key(key){}\n        operator int() const{\n            if(situple == 0) throw NotSuchKeyException();\n            return situple->value;\n        }\n        operator string() const{\n            if(sstuple == 0) throw NotSuchKeyException();\n            return sstuple->value;\n        }\n        Key_string_return& operator = (const string& value){\n            if(sstuple != 0) sstuple->value = value;\n            else ht->put(key,value);\n            return *this;\n        }\n        Key_string_return& operator = (const int& value){\n            if(situple != 0) situple->value = value;\n            else ht->put(key,value);\n            return *this;\n        }\n    };\nprivate:\n    vector<ssTuple> sstuples;\n    vector<iiTuple> iituples;\n    vector<siTuple> situples;\n    vector<isTuple> istuples;\n    size_t ii_indexOfkey(const int& key)const{\n        f(i,0,iituples.size()){\n            if(iituples[i].key == key) return i;\n        }\n        return -1;\n    }\n    size_t is_indexOfkey(const int& key)const{\n        f(i,0,istuples.size()){\n            if(istuples[i].key == key) return i;\n        }\n        return -1;\n    }\n    size_t ss_indexOfkey(const string& key)const{\n        f(i,0,sstuples.size()){\n            if(sstuples[i].key == key) return i;\n        }\n        return -1;\n    }\n    size_t si_indexOfkey(const string& key)const{\n        f(i,0,situples.size()){\n            if(situples[i].key == key) return i;\n        }\n        return -1;\n    }\n\npublic:\n    void put(const int& key,const int& value){\n        size_t index = ii_indexOfkey(key);\n        if(index == -1){\n            iituples.push_back(iiTuple(key,value));\n        }\n        else{\n            iituples[index].value = value;\n        }\n    }\n    void put(const int& key,const string& value){\n        size_t index = is_indexOfkey(key);\n        if(index == -1){\n            istuples.push_back(isTuple(key,value));\n        }\n        else{\n            istuples[index].value = value;\n        }\n    }\n    void put(const string& key,const string& value){\n        size_t index = ss_indexOfkey(key);\n        if(index == -1){\n            sstuples.push_back(ssTuple(key,value));\n        }\n        else{\n            sstuples[index].value = value;\n        }\n    }\n    void put(const string& key,const int& value){\n        size_t index = si_indexOfkey(key);\n        if(index == -1){\n            situples.push_back(siTuple(key,value));\n        }\n        else{\n            situples[index].value = value;\n        }\n    }\n    Key_int_return operator [](const int& key){\n        size_t index;\n        index = ii_indexOfkey(key);\n        if(index != -1) return Key_int_return(this,0,&iituples[index],key);\n        else{\n            index = is_indexOfkey(key);\n            if(index != -1) return Key_int_return(this,&istuples[index],0,key);\n            else return Key_int_return(this,0,0,key);\n        }\n    }\n    Key_string_return operator [](const string& key){\n        size_t index;\n        index = si_indexOfkey(key);\n        if(index != -1) return Key_string_return(this,0,&situples[index],key);\n        else{\n            index = ss_indexOfkey(key);\n            if(index != -1) return Key_string_return(this,&sstuples[index],0,key);\n            else return Key_string_return(this,0,0,key);\n        }\n    }\n    int size(){\n        return iituples.size()+sstuples.size()+situples.size()+istuples.size();\n    }\n\n};",
            1595420170.3969343,
            100,
            "# 答案正确"
        ],
        [
            "A.3 (C++)",
            "肖澧寅",
            "#include<vector>\n#include<iostream>\n#include<string>\nusing namespace std;\n\nclass NotSuchKey{};\ntemplate <typename E>\nclass HT{\n    class Tuple{\n    public:\n        int key;\n        E value;\n        Tuple(int key,E value) : key(key), value(value){}\n    };\nprivate:\n    vector<Tuple> tuples;\n    size_t indexOfkey(const int& key)const{\n        for(size_t i = 0;i < tuples.size();i++){\n            if(tuples[i].key == key) return i;\n        }\n        return -1;\n    }\npublic:\n    void put(int key, E value){\n        size_t index = indexOfkey(key);\n        if(index == -1) tuples.push_back(Tuple(key,value));\n        else{\n            tuples[index].value = value;\n        }\n    }\n    size_t size(){\n        return tuples.size();\n    }\n    bool containsKey(int key){\n        return (indexOfkey(key) != -1);\n    }\n    E operator [] (const int& key){\n        size_t index = indexOfkey(key);\n        if(index == -1) throw NotSuchKey();\n        return tuples[index].value;\n    }\n    void remove(const int& key){\n        size_t index = indexOfkey(key);\n        if(index == -1) throw NotSuchKey();\n        tuples[index] = tuples[tuples.size()-1];\n        tuples.pop_back();\n    }\n    vector<int> getKeys(){\n        vector<int> ans;\n        for(size_t i = 0;i < tuples.size();i++){\n            ans.push_back(tuples[i].key);\n        }\n        return ans;\n    }\n};",
            1595473150.6873493,
            100,
            "# 答案正确"
        ]
    ],
    "table_name": "答案"
}