{
    "__update_time__": 1595470891.1801198,
    "field_names": [
        "题目名",
        "用户名",
        "答案",
        "提交时间",
        "分数",
        "评语"
    ],
    "field_types": [
        "text",
        "text",
        "text",
        "time",
        "number",
        "text"
    ],
    "foreign_keys": {},
    "primary_keys": [],
    "rows": [
        [
            "测试1",
            "潘小健",
            "#include <iostream>\n#include<string>\nusing namespace std;\nint main() {\n\tstring a[3];\n\tfor (int i = 0; i < 3; ++ i)\n\t\tcin >> a[i];\n\tfor (int i = 2; i >=0 ; --i)\n\t\tcout << a[i] <<' ';\n}",
            1587519618.0,
            100,
            "# 答案正确"
        ],
        [
            "测试2",
            "潘小健",
            "#include <iostream>\n#include <vector>\n#include <iomanip>\n#include <string>\nusing namespace std;\n\nint main(){\n\tstring words[10];\n\tfor (int i = 0; i < 10; ++i)\n\t{\n\t\tcin >> words[i];\n\t}\n\t// sort(words[0],words[10],cmp);\n\n\tfor (int i = 0; i < 10; ++i)\n\t{\n\t\tfor (int j = 0; j < 9-i; ++j)\n\t\t{\n\t\t\tif(words[j]>words[j+1]){\n\t\t\t\tstring tmp=words[j];\n\t\t\t\twords[j]=words[j+1];\n\t\t\t\twords[j+1]=tmp;\n\t\t\t}\n\n\t\t}\n\t}\n\tfor (int i = 0; i < 10; ++i)\n\t{\n\t\tcout <<words[i]<<' ';\n\t}\n\n}\n",
            1587610496.923453,
            100,
            "# 答案正确"
        ],
        [
            "1.1 (C++)",
            "潘小健",
            "\nclass Matrix5x5\n{\n\tdouble matrix[5][5];\npublic:\n\tMatrix5x5();\n\tdouble get(int, int);\n\tvoid set(int, int, double);\n\tMatrix5x5 operator+(Matrix5x5&);\n};\n\nMatrix5x5::Matrix5x5(){\n\tfor (int i = 0; i < 5; ++i)\n\t\tfor (int j = 0; j < 5; ++j)\n\t\t\tmatrix[i][j]=0;\n}\n\ndouble Matrix5x5::get(int i,int j){\n\treturn matrix[i][j];\n}\n\nvoid Matrix5x5::set(int i,int j,double val){\n\tmatrix[i][j]=val;\n}\n\nMatrix5x5 Matrix5x5::operator+(Matrix5x5&other){\n\tMatrix5x5 result;\n\tfor (int i = 0; i < 5; ++i)\n\t\tfor (int j = 0; j < 5; ++j)\n\t\t\tresult.matrix[i][j]=other.matrix[i][j]+this->matrix[i][j];\n\treturn result;\n}\n",
            1587697600.027404,
            100,
            "# 答案正确"
        ],
        [
            "1.2 (C++)",
            "潘小健",
            "#include <string>\nusing namespace std;\nclass School\n{\npublic:\n\tstring name;\n\tint age;\n\tSchool(){\n\t\tname=\"NO_NAME\";\n\t\tage=0;\n\t}\n\tvoid setName(char name[]){\n\t\tthis->name=name;\n\t}\n\tvoid setAge(int year){\n\t\tage=year;\n\t}\n\tvoid operator++(){\n\t\t++age;\n\t}\n\t\n};",
            1588213738.8636453,
            100,
            "# 答案正确"
        ],
        [
            "2.1 (C++)",
            "潘小健",
            "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <iomanip>\n#include <string>\nusing namespace std;\n\nclass Matrix\n{\n\tint rows;\n\tint columns;\n\tdouble *values;\npublic:\n\tMatrix(int _rows,int _columns):rows(_rows),columns(_columns){\n\t\tvalues=new double[_columns*_rows];\n\t\tmemset(values,0,sizeof(double)*_rows*_columns);\n\n\t}\n\t~Matrix(){\n\t\tdelete values;\n\t}\n\tvoid print(){\n\t\tfor (int i = 0; i < rows; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j <columns ; ++j)\n\t\t\t{\n\t\t\t\tcout<<\"    \"<<values[i*columns+j];\n\t\t\t}\n\t\t\tcout <<endl;\n\t\t}\n\t} \n\t\n};",
            1588831154.506712,
            100,
            "# 答案正确"
        ],
        [
            "2.2 (C++)",
            "潘小健",
            "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <iomanip>\n#include <string>\nusing namespace std;\n\nclass Matrix\n{\n\tint rows;\n\tint columns;\n\tdouble *values;\npublic:\n\tMatrix(int _rows,int _columns,double*_values):rows(_rows),columns(_columns){\n\t\tvalues=new double[_columns*_rows];\n\t\tfor (int i = 0; i < _columns*_rows; ++i)\n\t\t{\n\t\t\tvalues[i]=_values[i];\n\t\t}\n\t}\n\t~Matrix(){\n\t\tdelete values;\n\t}\n\tvoid print(){\n\t\tfor (int i = 0; i < rows; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j <columns ; ++j)\n\t\t\t{\n\t\t\t\tcout<<setw(5)<<values[i*columns+j];\n\t\t\t}\n\t\t\tcout <<endl;\n\t\t}\n\t} \n\t\n};\n",
            1588831752.2329297,
            100,
            "# 答案正确"
        ],
        [
            "2.3 (C++)",
            "潘小健",
            "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <iomanip>\n#include <string>\nusing namespace std;\n\nclass Matrix\n{\n\tint rows;\n\tint columns;\n\tdouble *values;\npublic:\n\tMatrix(int _rows,int _columns,double*_values):rows(_rows),columns(_columns){\n\t\tvalues=new double[_columns*_rows];\n\t\tfor (int i = 0; i < _columns*_rows; ++i)\n\t\t{\n\t\t\tvalues[i]=_values[i];\n\t\t}\n\t}\n\n\tMatrix(const Matrix & matrix2){\n\t\trows=matrix2.rows;\n\t\tcolumns=matrix2.columns;\n\t\tvalues=new double[rows*columns];\n\t\tmemcpy(values,matrix2.values,sizeof(double)*columns*rows);\n\t}\n\t\n\t~Matrix(){\n\t\tdelete values;\n\t}\n\t\n\tvoid print(){\n\t\tfor (int i = 0; i < rows; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j <columns ; ++j)\n\t\t\t{\n\t\t\t\tcout<<\"    \"<<values[i*columns+j];\n\t\t\t}\n\t\t\tcout <<endl;\n\t\t}\n\t}\n\n};",
            1588832207.728053,
            100,
            "# 答案正确"
        ],
        [
            "2.5 (C++)",
            "潘小健",
            "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <iomanip>\n#include <string>\nusing namespace std;\n\nclass Matrix\n{\n\tint rows;\n\tint columns;\n\tdouble *values;\npublic:\n\tMatrix(int _rows,int _columns):rows(_rows),columns(_columns){\n\t\tvalues=new double[_columns*_rows];\n\t\tmemset(values,0,sizeof(double)*rows*columns);\n\t}\n\n\tMatrix(int _rows,int _columns,double*_values):rows(_rows),columns(_columns){\n\t\tvalues=new double[_columns*_rows];\n\t\tfor (int i = 0; i < _columns*_rows; ++i)\n\t\t{\n\t\t\tvalues[i]=_values[i];\n\t\t}\n\t}\n\n\tMatrix(const Matrix & matrix2){\n\t\trows=matrix2.rows;\n\t\tcolumns=matrix2.columns;\n\t\tvalues=new double[rows*columns];\n\t\tmemcpy(values,matrix2.values,sizeof(double)*columns*rows);\n\t}\n\t\n\t~Matrix(){\n\t\tdelete values;\n\t}\n\t\n\tvoid print(){\n\t\tfor (int i = 0; i < rows; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j <columns ; ++j)\n\t\t\t{\n\t\t\t\tcout<<\"    \"<<values[i*columns+j];\n\t\t\t}\n\t\t\tcout <<endl;\n\t\t}\n\t}\n\n\tMatrix getRow(int row){\n\t\treturn Matrix(1,columns,values+columns*(row-1));\n\t}\n\n\tMatrix getColumn(int column){\n\t\tdouble tmp[rows];\n\t\tfor (int i = 0; i < rows; ++i)\n\t\t{\n\t\t\ttmp[i]=values[column-1+i*columns];\n\t\t}\n\t\treturn Matrix(rows,1,tmp);\n\t}\n\n};",
            1588833047.4191058,
            100,
            "# 答案正确"
        ],
        [
            "2.6 (C++)",
            "潘小健",
            "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <iomanip>\n#include <string>\nusing namespace std;\n\nclass Matrix\n{\n\tint rows;\n\tint columns;\n\tdouble *values;\npublic:\n\tMatrix(int _rows,int _columns):rows(_rows),columns(_columns){\n\t\tvalues=new double[_columns*_rows];\n\t\tmemset(values,0,sizeof(double)*rows*columns);\n\t}\n\n\tMatrix(int _rows,int _columns,double*_values):rows(_rows),columns(_columns){\n\t\tvalues=new double[_columns*_rows];\n\t\tfor (int i = 0; i < _columns*_rows; ++i)\n\t\t{\n\t\t\tvalues[i]=_values[i];\n\t\t}\n\t}\n\n\tMatrix(const Matrix & matrix2){\n\t\trows=matrix2.rows;\n\t\tcolumns=matrix2.columns;\n\t\tvalues=new double[rows*columns];\n\t\tmemcpy(values,matrix2.values,sizeof(double)*columns*rows);\n\t}\n\t\n\t~Matrix(){\n\t\tdelete values;\n\t}\n\t\n\tvoid print(){\n\t\tfor (int i = 0; i < rows; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j <columns ; ++j)\n\t\t\t{\n\t\t\t\tcout<<\"    \"<<values[i*columns+j];\n\t\t\t}\n\t\t\tcout <<endl;\n\t\t}\n\t}\n\n\tMatrix getRow(int row){\n\t\treturn Matrix(1,columns,values+columns*(row-1));\n\t}\n\n\tMatrix getColumn(int column){\n\t\tdouble tmp[rows];\n\t\tfor (int i = 0; i < rows; ++i)\n\t\t{\n\t\t\ttmp[i]=values[column-1+i*columns];\n\t\t}\n\t\treturn Matrix(rows,1,tmp);\n\t}\n\n\tMatrix concatenateColumns(const Matrix & matrix2) const{\n\t\tdouble tmp[(columns+matrix2.columns)*rows];\n\t\tfor (int i = 0; i < rows; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < columns; ++j)\n\t\t\t{\n\t\t\t\ttmp[i*(columns+matrix2.columns)+j]=values[i*columns+j];\n\t\t\t}\n\t\t\tfor (int j = 0; j < matrix2.columns; ++j)\n\t\t\t{\n\t\t\t\ttmp[i*(columns+matrix2.columns)+j+columns]=matrix2.values[i*matrix2.columns+j];\n\t\t\t}\n\t\t}\n\t\treturn Matrix(rows,columns+matrix2.columns,tmp);\n\t}\n\n\tMatrix concatenateRows(const Matrix & matrix2) const{\n\t\tdouble tmp[(rows+matrix2.rows)*columns];\n\t\tmemcpy(tmp,values,sizeof(double)*columns*rows);\n\t\tmemcpy(tmp+columns*rows,matrix2.values,sizeof(double)*matrix2.columns*matrix2.rows);\n\t\treturn Matrix(rows+matrix2.rows,columns,tmp);\n\t}\n\t\n\n};\n",
            1588833863.451695,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/08",
            "潘小健",
            "\ndouble & Tensor_get(int dimensions, int* sizes, double* data, int x0, int x1, int x2, int x3){\n\tint position=0;\n\tposition+=x0;\n\tif(x1!=-1)\n\t\tposition+=x1*sizes[0];\n\tif(x2!=-1)\n\t\tposition+=x2*sizes[0]*sizes[1];\n\tif(x3!=-1)\n\t\tposition+=x3*sizes[0]*sizes[1]*sizes[2];\n\treturn data[position];\n}",
            1588905492.830254,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/14",
            "潘小健",
            "#include <iostream>\n\nusing namespace std;\n\nvoid Tensor_print(int dimensions, const int*sizes, const double*data){\n\tif(dimensions==1){\n\t\tcout <<\"Tensor of \"<<sizes[0]<<endl;\n\t\tfor (int i = 0; i < sizes[0]; ++i)\n\t\t{\n\t\t\tcout<<data[i];\n\t\t\tcout <<endl;\n\t\t}\n\t}\n\telse if(dimensions==2){\n\t\tcout <<\"Tensor of \"<<sizes[0]<<\"*\"<<sizes[1]<<endl;\t\n\t\tfor (int i = 0; i < sizes[0]; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < sizes[1]; ++j)\n\t\t\t{\n\t\t\t\tcout<<\"    \"<<data[i*sizes[1]+j];\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t}\n\n\telse if(dimensions==3){\n\t\tcout <<\"Tensor of \"<<sizes[0]<<\"*\"<<sizes[1]<<\"*\"<<sizes[2]<<endl;\n\t\tfor (int i = 0; i < sizes[0]; ++i)\n\t\t{\n\t\t\tcout<<\"data[\"<<i<<\"]\"<<endl;\n\t\t\tfor (int j = 0; j < sizes[1]; ++j)\n\t\t\t{\n\t\t\t\tfor (int k = 0; k < sizes[2]; ++k)\n\t\t\t\t{\n\t\t\t\t\tcout<<\"    \"<<data[i*sizes[1]*sizes[2]+j*sizes[2]+k];\n\t\t\t\t}\n\t\t\t\tcout<<endl;\n\t\t\t}\n\t\t}\n\t}\n\n\telse if(dimensions==4){\n\t\tcout <<\"Tensor of \"<<sizes[0]<<\"*\"<<sizes[1]<<\"*\"<<sizes[2]<<\"*\"<<sizes[3]<<endl;\n\n\t\tfor (int i = 0; i < sizes[0]; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < sizes[1]; ++j)\n\t\t\t{\n\t\t\t\tcout<<\"data[\"<<i<<\"][\"<<j<<\"]\"<<endl;\n\t\t\t\tfor (int k = 0; k < sizes[2]; ++k)\n\t\t\t\t{\n\t\t\t\t\tfor (int l = 0; l < sizes[3]; ++l)\n\t\t\t\t\t{\n\t\t\t\t\tcout<<\"    \"<<data[i*sizes[1]*sizes[2]*sizes[3]+j*sizes[2]*sizes[3]+k*sizes[3]+l];\n\t\t\t\t\t}\n\t\t\t\t\tcout<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
            1589427191.0961375,
            100,
            "# 答案不正确\n\n# 随机输入:\n5.6\n8.5\n7.7\n9.7\n\n\n# 参考答案:\nTensor of 5\n5.6\n5.6\n5.6\n5.6\n5.6\n\nTensor of 3x4\n    8.5    8.5    8.5    8.5\n    8.5    8.5    8.5    8.5\n    8.5    8.5    8.5    8.5\n\nTensor of 3x4x5\ndata[0]\n    7.7    7.7    7.7    7.7    7.7\n    7.7    7.7    7.7    7.7    7.7\n    7.7    7.7    7.7    7.7    7.7\n    7.7    7.7    7.7    7.7    7.7\ndata[1]\n    7.7    7.7    7.7    7.7    7.7\n    7.7    7.7    7.7    7.7    7.7\n    7.7    7.7    7.7    7.7    7.7\n    7.7    7.7    7.7    7.7    7.7\ndata[2]\n    7.7    7.7    7.7    7.7    7.7\n    7.7    7.7    7.7    7.7    7.7\n    7.7    7.7    7.7    7.7    7.7\n    7.7    7.7    7.7    7.7    7.7\n\nTensor of 2x3x4x5\ndata[0][0]\n    9.7    9.7    9.7    9.7    9.7\n    9.7    9.7    9.7    9.7    9.7\n    9.7    9.7    9.7    9.7    9.7\n    9.7    9.7    9.7    9.7    9.7\ndata[0][1]\n    9.7    9.7    9.7    9.7    9.7\n    9.7    9.7    9.7    9.7    9.7\n    9.7    9.7    9.7    9.7    9.7\n    9.7    9.7    9.7    9.7    9.7\ndata[0][2]\n    9.7    9.7    9.7    9.7    9.7\n    9.7    9.7    9.7    9.7    9.7\n    9.7    9.7    9.7    9.7    9.7\n    9.7    9.7    9.7    9.7    9.7\ndata[1][0]\n    9.7    9.7    9.7    9.7    9.7\n    9.7    9.7    9.7    9.7    9.7\n    9.7    9.7    9.7    9.7    9.7\n    9.7    9.7    9.7    9.7    9.7\ndata[1][1]\n    9.7    9.7    9.7    9.7    9.7\n    9.7    9.7    9.7    9.7    9.7\n    9.7    9.7    9.7    9.7    9.7\n    9.7    9.7    9.7    9.7    9.7\ndata[1][2]\n    9.7    9.7    9.7    9.7    9.7\n    9.7    9.7    9.7    9.7    9.7\n    9.7    9.7    9.7    9.7    9.7\n    9.7    9.7    9.7    9.7    9.7\n\n\n# 我的答案:\nTensor of 5\n5.6\n5.6\n5.6\n5.6\n5.6\n\nTensor of 3*4\n    8.5    8.5    8.5    8.5\n    8.5    8.5    8.5    8.5\n    8.5    8.5    8.5    8.5\n\nTensor of 3*4*5\ndata[0]\n    7.7    7.7    7.7    7.7    7.7\n    7.7    7.7    7.7    7.7    7.7\n    7.7    7.7    7.7    7.7    7.7\n    7.7    7.7    7.7    7.7    7.7\ndata[1]\n    7.7    7.7    7.7    7.7    7.7\n    7.7    7.7    7.7    7.7    7.7\n    7.7    7.7    7.7    7.7    7.7\n    7.7    7.7    7.7    7.7    7.7\ndata[2]\n    7.7    7.7    7.7    7.7    7.7\n    7.7    7.7    7.7    7.7    7.7\n    7.7    7.7    7.7    7.7    7.7\n    7.7    7.7    7.7    7.7    7.7\n\nTensor of 2*3*4*5\ndata[0][0]\n    9.7    9.7    9.7    9.7    9.7\n    9.7    9.7    9.7    9.7    9.7\n    9.7    9.7    9.7    9.7    9.7\n    9.7    9.7    9.7    9.7    9.7\ndata[0][1]\n    9.7    9.7    9.7    9.7    9.7\n    9.7    9.7    9.7    9.7    9.7\n    9.7    9.7    9.7    9.7    9.7\n    9.7    9.7    9.7    9.7    9.7\ndata[0][2]\n    9.7    9.7    9.7    9.7    9.7\n    9.7    9.7    9.7    9.7    9.7\n    9.7    9.7    9.7    9.7    9.7\n    9.7    9.7    9.7    9.7    9.7\ndata[1][0]\n    9.7    9.7    9.7    9.7    9.7\n    9.7    9.7    9.7    9.7    9.7\n    9.7    9.7    9.7    9.7    9.7\n    9.7    9.7    9.7    9.7    9.7\ndata[1][1]\n    9.7    9.7    9.7    9.7    9.7\n    9.7    9.7    9.7    9.7    9.7\n    9.7    9.7    9.7    9.7    9.7\n    9.7    9.7    9.7    9.7    9.7\ndata[1][2]\n    9.7    9.7    9.7    9.7    9.7\n    9.7    9.7    9.7    9.7    9.7\n    9.7    9.7    9.7    9.7    9.7\n    9.7    9.7    9.7    9.7    9.7\n"
        ],
        [
            "2.4 (C++)",
            "潘小健",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tMatrix(int rows, int columns)\n\t{\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tif(rows*columns==0)\n\t\t\tthis->values=NULL;\n\t\telse\n\t\t\tvalues = new double[rows*columns];\n\t\tfor (int i = 0; i < rows*columns; ++i)\n\t\t\tvalues[i] = 0;\n\t}\n\tMatrix(int rows, int columns, double values[])\n\t{\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tif(rows*columns==0)\n\t\t\tthis->values=NULL;\n\t\telse\n\t\t \tthis->values = new double[rows*columns];\n\t\tfor (int i = 0; i < rows*columns; ++i)\n\t\t\tthis->values[i] = values[i];\n\t}\n\t~Matrix()\n\t{\n\t\tif(values != 0)\n\t\t\tdelete [] values;\n\t}\n\tvoid print()\n\t{\n\t\tfor (int i = 0; i < rows; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < columns; ++j)\n\t\t\t\tcout << \"    \" << values[i*columns+j];\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tvoid set(int row, int column, double value)\n\t{\n\t\tvalues[(row-1)*columns+(column-1)] = value;\n\t}\n\tMatrix & operator =(const Matrix &matrix)\n\t{\n\t\trows = matrix.rows;\n\t\tcolumns = matrix.columns;\n\t\tif(values != 0)\n\t\t\tdelete [] values;\n\t\tvalues = new double[rows*columns];\n\t\tfor (int i = 0; i < rows*columns; ++i)\n\t\t\tvalues[i] = matrix.values[i];\n\t\treturn *this;\n\t}\n};\n",
            1589865359.0529118,
            100,
            "# 答案正确"
        ],
        [
            "2.7 (C++)",
            "潘小健",
            "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nclass Matrix\n{\n\tint rows;\n\tint columns;\n\tdouble *values;\npublic:\n\tMatrix(int _rows,int _columns,double*_values=NULL):rows(_rows),columns(_columns){\n\t\tif(rows*columns==0)\n\t\t\tvalues=NULL;\n\t\tvalues=new double[rows*columns];\n\t\tif(_values==NULL){\n\t\t\tmemset(values,0,rows*columns*sizeof(double));\n\t\t}\n\t\telse{\n\t\t\tmemcpy(values,_values,rows*columns*sizeof(double));\n\t\t\t\t\n\t\t}\n\t}\n\n\tMatrix(const Matrix& matrix_out){\n\t\tthis->columns=matrix_out.columns;\n\t\tthis->rows=matrix_out.rows;\n\t\tthis->values=new double[rows*columns];\n\t\tmemcpy(this->values,matrix_out.values,rows*columns*sizeof(double));\n\t}\n\n\t~Matrix(){\n\t\tdelete [] values;\n\t}\n\t\n\tvoid print(){\n\t\tfor (int i = 0; i < rows; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < columns; ++j)\n\t\t\t{\n\t\t\t\tcout<<\"    \"<<values[i*columns+j];\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t}\n\n\tvoid set(int row,int column,double value){\n\t\t--row;\n\t\t--column;\n\t\tvalues[row*columns+column]=value;\n\t}\n\n\tMatrix& operator=(Matrix& matrix_out){\n\t\tthis->columns=matrix_out.columns;\n\t\tthis->rows=matrix_out.rows;\n\t\tif(this->values!=NULL)\n\t\t\tdelete[]this->values;\n\t\tthis->values=new double[rows*columns];\n\t\tmemcpy(this->values,matrix_out.values,rows*columns*sizeof(double));\n\t\treturn *this;\n\t}\n\n\tMatrix reshape(int _rows, int _columns) const{\n\t\tdouble tmp[rows*columns];\n\t\tfor (int i = 0; i <columns ; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < rows; ++j)\n\t\t\t{\n\t\t\t\tint position=i*rows+j;\n\t\t\t\tint to_row=position%_rows;\n\t\t\t\tint to_column=position/_rows;\n\t\t\t\ttmp[to_row*_columns+to_column]=values[i+j*columns];\n\t\t\t}\n\t\t}\n\t\treturn Matrix(_rows,_columns,tmp);\n\t}\n};",
            1589544516.03843,
            100,
            "# 答案正确"
        ],
        [
            "2.8 (C++)",
            "潘小健",
            "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nclass Matrix\n{\n\tint rows;\n\tint columns;\n\tdouble *values;\npublic:\n\tMatrix(int _rows,int _columns,double*_values=NULL):rows(_rows),columns(_columns){\n\t\tif(rows*columns==0)\n\t\t\tvalues=NULL;\n\t\tvalues=new double[rows*columns];\n\t\tif(_values==NULL){\n\t\t\tmemset(values,0,rows*columns*sizeof(double));\n\t\t}\n\t\telse{\n\t\t\tmemcpy(values,_values,rows*columns*sizeof(double));\n\t\t\t\t\n\t\t}\n\t}\n\n\tMatrix(const Matrix& matrix_out){\n\t\tthis->columns=matrix_out.columns;\n\t\tthis->rows=matrix_out.rows;\n\t\tthis->values=new double[rows*columns];\n\t\tmemcpy(this->values,matrix_out.values,rows*columns*sizeof(double));\n\t}\n\n\t~Matrix(){\n\t\tdelete [] values;\n\t}\n\t\n\tvoid print(){\n\t\tfor (int i = 0; i < rows; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < columns; ++j)\n\t\t\t{\n\t\t\t\tcout<<\"    \"<<values[i*columns+j];\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t}\n\n\tvoid set(int row,int column,double value){\n\t\t--row;\n\t\t--column;\n\t\tvalues[row*columns+column]=value;\n\t}\n\n\tMatrix& operator=(Matrix& matrix_out){\n\t\tthis->columns=matrix_out.columns;\n\t\tthis->rows=matrix_out.rows;\n\t\tif(this->values!=NULL)\n\t\t\tdelete[]this->values;\n\t\tthis->values=new double[rows*columns];\n\t\tmemcpy(this->values,matrix_out.values,rows*columns*sizeof(double));\n\t\treturn *this;\n\t}\n\n\tMatrix reshape(int _rows, int _columns) const{\n\t\tdouble tmp[rows*columns];\n\t\tfor (int i = 0; i <columns ; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < rows; ++j)\n\t\t\t{\n\t\t\t\tint position=i*rows+j;\n\t\t\t\tint to_row=position%_rows;\n\t\t\t\tint to_column=position/_rows;\n\t\t\t\ttmp[to_row*_columns+to_column]=values[i+j*columns];\n\t\t\t}\n\t\t}\n\t\treturn Matrix(_rows,_columns,tmp);\n\t}\n\n\tMatrix transpose(){\n\t\tdouble tmp[rows*columns];\n\t\tfor (int i = 0; i < rows; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < columns; ++j)\n\t\t\t{\n\t\t\t\ttmp[j*rows+i]=values[i*columns+j];\n\t\t\t}\n\t\t}\n\t\treturn Matrix(columns,rows,tmp);\n\t}\n};\n",
            1589544876.3114996,
            100,
            "# 答案正确"
        ],
        [
            "2.10 (C++)",
            "潘小健",
            "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nclass Matrix\n{\n\tint rows;\n\tint columns;\n\tdouble *values;\npublic:\n\tMatrix(int _rows,int _columns,double*_values=NULL):rows(_rows),columns(_columns){\n\t\tif(rows*columns==0)\n\t\t\tvalues=NULL;\n\t\tvalues=new double[rows*columns];\n\t\tif(_values==NULL){\n\t\t\tmemset(values,0,rows*columns*sizeof(double));\n\t\t}\n\t\telse{\n\t\t\tmemcpy(values,_values,rows*columns*sizeof(double));\n\t\t\t\t\n\t\t}\n\t}\n\n\tMatrix(const Matrix& matrix_out){\n\t\tthis->columns=matrix_out.columns;\n\t\tthis->rows=matrix_out.rows;\n\t\tthis->values=new double[rows*columns];\n\t\tmemcpy(this->values,matrix_out.values,rows*columns*sizeof(double));\n\t}\n\n\t~Matrix(){\n\t\tdelete [] values;\n\t}\n\t\n\tvoid print(){\n\t\tfor (int i = 0; i < rows; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < columns; ++j)\n\t\t\t{\n\t\t\t\tcout<<\"    \"<<values[i*columns+j];\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t}\n\n\tvoid set(int row,int column,double value){\n\t\t--row;\n\t\t--column;\n\t\tvalues[row*columns+column]=value;\n\t}\n\n\tMatrix& operator=(Matrix& matrix_out){\n\t\tthis->columns=matrix_out.columns;\n\t\tthis->rows=matrix_out.rows;\n\t\tif(this->values!=NULL)\n\t\t\tdelete[]this->values;\n\t\tthis->values=new double[rows*columns];\n\t\tmemcpy(this->values,matrix_out.values,rows*columns*sizeof(double));\n\t\treturn *this;\n\t}\n\n\tMatrix reshape(int _rows, int _columns) const{\n\t\tdouble tmp[rows*columns];\n\t\tfor (int i = 0; i <columns ; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < rows; ++j)\n\t\t\t{\n\t\t\t\tint position=i*rows+j;\n\t\t\t\tint to_row=position%_rows;\n\t\t\t\tint to_column=position/_rows;\n\t\t\t\ttmp[to_row*_columns+to_column]=values[i+j*columns];\n\t\t\t}\n\t\t}\n\t\treturn Matrix(_rows,_columns,tmp);\n\t}\n\n\tMatrix transpose(){\n\t\tdouble tmp[rows*columns];\n\t\tfor (int i = 0; i < rows; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < columns; ++j)\n\t\t\t{\n\t\t\t\ttmp[j*rows+i]=values[i*columns+j];\n\t\t\t}\n\t\t}\n\t\treturn Matrix(columns,rows,tmp);\n\t}\n\n\tMatrix operator*(double value)const{\n\t\tdouble tmp[rows*columns]; \n\t\tfor (int i = 0; i < columns*rows; ++i)\n\t\t{\n\t\t\ttmp[i]=values[i]*value;\n\t\t}\n\t\treturn Matrix(rows,columns,tmp);\n\t}\n\n\tMatrix operator*(const Matrix&matrix_2){\n\t\tif(this->columns!=matrix_2.rows)\n\t\t\treturn Matrix(0,0);\n\n\t\tdouble tmp[this->rows*matrix_2.columns];\n\t\tfor (int i = 0; i < this->rows; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < matrix_2.columns; ++j)\n\t\t\t{\n\t\t\t\tdouble result=0;\n\t\t\t\tfor (int k = 0; k < this->columns; ++k)\n\t\t\t\t{\n\t\t\t\t\tresult+=this->values[i*this->columns+k]*matrix_2.values[k*matrix_2.columns+j];\n\t\t\t\t}\n\t\t\t\ttmp[i*matrix_2.columns+j]=result;\n\t\t\t}\n\t\t}\n\t\treturn Matrix(this->rows,matrix_2.columns,tmp);\n\t}\n};\n",
            1589546577.9821703,
            100,
            "# 答案正确"
        ],
        [
            "2.11 (C++)",
            "潘小健",
            "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nclass Matrix\n{\n\tint rows;\n\tint columns;\n\tdouble *values;\n\tconst static int INF = 1e9;\npublic:\n\tMatrix(int _rows,int _columns,double*_values=NULL):rows(_rows),columns(_columns){\n\t\tif(rows*columns==0)\n\t\t\tvalues=NULL;\n\t\tvalues=new double[rows*columns];\n\t\tif(_values==NULL){\n\t\t\tmemset(values,0,rows*columns*sizeof(double));\n\t\t}\n\t\telse{\n\t\t\tmemcpy(values,_values,rows*columns*sizeof(double));\n\t\t\t\t\n\t\t}\n\t}\n\n\tMatrix(const Matrix& matrix_out){\n\t\tthis->columns=matrix_out.columns;\n\t\tthis->rows=matrix_out.rows;\n\t\tthis->values=new double[rows*columns];\n\t\tmemcpy(this->values,matrix_out.values,rows*columns*sizeof(double));\n\t}\n\n\t~Matrix(){\n\t\tdelete [] values;\n\t}\n\t\n\tvoid print(){\n\t\tfor (int i = 0; i < rows; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < columns; ++j)\n\t\t\t{\n\t\t\t\tcout<<\"    \"<<values[i*columns+j];\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t}\n\n\tvoid set(int row,int column,double value){\n\t\t--row;\n\t\t--column;\n\t\tvalues[row*columns+column]=value;\n\t}\n\n\tMatrix& operator=(Matrix& matrix_out){\n\t\tthis->columns=matrix_out.columns;\n\t\tthis->rows=matrix_out.rows;\n\t\tif(this->values!=NULL)\n\t\t\tdelete[]this->values;\n\t\tthis->values=new double[rows*columns];\n\t\tmemcpy(this->values,matrix_out.values,rows*columns*sizeof(double));\n\t\treturn *this;\n\t}\n\n\tMatrix reshape(int _rows, int _columns) const{\n\t\tdouble tmp[rows*columns];\n\t\tfor (int i = 0; i <columns ; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < rows; ++j)\n\t\t\t{\n\t\t\t\tint position=i*rows+j;\n\t\t\t\tint to_row=position%_rows;\n\t\t\t\tint to_column=position/_rows;\n\t\t\t\ttmp[to_row*_columns+to_column]=values[i+j*columns];\n\t\t\t}\n\t\t}\n\t\treturn Matrix(_rows,_columns,tmp);\n\t}\n\n\tMatrix transpose(){\n\t\tdouble tmp[rows*columns];\n\t\tfor (int i = 0; i < rows; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < columns; ++j)\n\t\t\t{\n\t\t\t\ttmp[j*rows+i]=values[i*columns+j];\n\t\t\t}\n\t\t}\n\t\treturn Matrix(columns,rows,tmp);\n\t}\n\n\tMatrix operator*(double value)const{\n\t\tdouble tmp[rows*columns]; \n\t\tfor (int i = 0; i < columns*rows; ++i)\n\t\t{\n\t\t\ttmp[i]=values[i]*value;\n\t\t}\n\t\treturn Matrix(rows,columns,tmp);\n\t}\n\n\tMatrix operator*(const Matrix&matrix_2){\n\t\tif(this->columns!=matrix_2.rows)\n\t\t\treturn Matrix(0,0);\n\n\t\tdouble tmp[this->rows*matrix_2.columns];\n\t\tfor (int i = 0; i < this->rows; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < matrix_2.columns; ++j)\n\t\t\t{\n\t\t\t\tdouble result=0;\n\t\t\t\tfor (int k = 0; k < this->columns; ++k)\n\t\t\t\t{\n\t\t\t\t\tresult+=this->values[i*this->columns+k]*matrix_2.values[k*matrix_2.columns+j];\n\t\t\t\t}\n\t\t\t\ttmp[i*matrix_2.columns+j]=result;\n\t\t\t}\n\t\t}\n\t\treturn Matrix(this->rows,matrix_2.columns,tmp);\n\t}\n\n\tMatrix max() const{\n\t\tif(rows==1){\n\t\t\tdouble max=0;\n\t\t\tfor (int i = 0; i < columns; ++i)\n\t\t\t{\n\t\t\t\tif(values[i]>max)\n\t\t\t\t\tmax=values[i];\n\t\t\t}\n\t\t\treturn Matrix(1,1,&max);\n\t\t}\n\t\tdouble max_tmp[columns];\n\t\tmemset(max_tmp,0,columns*sizeof(double));\n\t\tfor (int i = 0; i < columns; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < rows; ++j)\n\t\t\t{\n\t\t\t\tif(values[j*columns+i]>max_tmp[i])\n\t\t\t\t\tmax_tmp[i]=values[j*columns+i];\n\t\t\t}\n\t\t}\n\t\treturn Matrix(1,columns,max_tmp);\n\t}\n\n\tMatrix min() const{\n\t\tif(rows==1){\n\t\t\tdouble min =INF;\n\t\t\tfor (int i = 0; i < columns; ++i)\n\t\t\t{\n\t\t\t\tif(values[i]<min)\n\t\t\t\t\tmin=values[i];\n\t\t\t}\n\t\t\treturn Matrix(1,1,&min);\n\t\t}\n\t\tdouble min_tmp[columns];\n\t\tfor (int i = 0; i < columns; ++i)\n\t\t{\n\t\t\tdouble min =INF;\n\t\t\tfor (int j = 0; j < rows; ++j)\n\t\t\t{\n\t\t\t\tif(values[j*columns+i]<min)\n\t\t\t\t\tmin=values[j*columns+i];\n\t\t\t}\n\t\t\tmin_tmp[i]=min;\n\t\t}\n\t\treturn Matrix(1,columns,min_tmp);\n\t}\n\n\tMatrix sum() const{\n\t\tif(rows==1){\n\t\t\tdouble sum=0;\n\t\t\tfor (int i = 0; i < columns; ++i)\n\t\t\t{\n\t\t\t\tsum+=values[i];\n\t\t\t}\n\t\t\treturn Matrix(1,1,&sum);\n\t\t}\n\n\t\tdouble tmp_sum[columns];\n\t\tfor (int i = 0; i < columns; ++i)\n\t\t{\n\t\t\tdouble sum=0;\n\t\t\tfor (int j = 0; j < rows; ++j)\n\t\t\t{\n\t\t\t\tsum+=values[j*columns+i];\n\t\t\t}\n\t\t\ttmp_sum[i]=sum;\n\t\t}\n\t\treturn Matrix(1,columns,tmp_sum);\n\t}\n\n\n};\n\n",
            1589548925.662078,
            100,
            "# 答案正确"
        ],
        [
            "2.12 (C++)",
            "潘小健",
            "#include <iostream>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\nclass Matrix\n{\n\tint rows;\n\tint columns;\n\tdouble *values;\n\tconst static int INF = 1e9;\npublic:\n\tMatrix(int _rows,int _columns,double*_values=NULL):rows(_rows),columns(_columns){\n\t\tif(rows*columns==0)\n\t\t\tvalues=NULL;\n\t\tvalues=new double[rows*columns];\n\t\tif(_values==NULL){\n\t\t\tmemset(values,0,rows*columns*sizeof(double));\n\t\t}\n\t\telse{\n\t\t\tmemcpy(values,_values,rows*columns*sizeof(double));\n\t\t\t\t\n\t\t}\n\t}\n\n\tMatrix(const Matrix& matrix_out){\n\t\tthis->columns=matrix_out.columns;\n\t\tthis->rows=matrix_out.rows;\n\t\tthis->values=new double[rows*columns];\n\t\tmemcpy(this->values,matrix_out.values,rows*columns*sizeof(double));\n\t}\n\n\t~Matrix(){\n\t\tdelete [] values;\n\t}\n\t\n\tvoid print(){\n\t\tfor (int i = 0; i < rows; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < columns; ++j)\n\t\t\t{\n\t\t\t\tcout<<\"    \"<<values[i*columns+j];\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t}\n\n\tvoid set(int row,int column,double value){\n\t\t--row;\n\t\t--column;\n\t\tvalues[row*columns+column]=value;\n\t}\n\n\tMatrix& operator=(Matrix& matrix_out){\n\t\tthis->columns=matrix_out.columns;\n\t\tthis->rows=matrix_out.rows;\n\t\tif(this->values!=NULL)\n\t\t\tdelete[]this->values;\n\t\tthis->values=new double[rows*columns];\n\t\tmemcpy(this->values,matrix_out.values,rows*columns*sizeof(double));\n\t\treturn *this;\n\t}\n\n\tMatrix reshape(int _rows, int _columns) const{\n\t\tdouble tmp[rows*columns];\n\t\tfor (int i = 0; i <columns ; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < rows; ++j)\n\t\t\t{\n\t\t\t\tint position=i*rows+j;\n\t\t\t\tint to_row=position%_rows;\n\t\t\t\tint to_column=position/_rows;\n\t\t\t\ttmp[to_row*_columns+to_column]=values[i+j*columns];\n\t\t\t}\n\t\t}\n\t\treturn Matrix(_rows,_columns,tmp);\n\t}\n\n\tMatrix transpose(){\n\t\tdouble tmp[rows*columns];\n\t\tfor (int i = 0; i < rows; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < columns; ++j)\n\t\t\t{\n\t\t\t\ttmp[j*rows+i]=values[i*columns+j];\n\t\t\t}\n\t\t}\n\t\treturn Matrix(columns,rows,tmp);\n\t}\n\n\tMatrix operator*(double value)const{\n\t\tdouble tmp[rows*columns]; \n\t\tfor (int i = 0; i < columns*rows; ++i)\n\t\t{\n\t\t\ttmp[i]=values[i]*value;\n\t\t}\n\t\treturn Matrix(rows,columns,tmp);\n\t}\n\n\tMatrix operator*(const Matrix&matrix_2){\n\t\tif(this->columns!=matrix_2.rows)\n\t\t\treturn Matrix(0,0);\n\n\t\tdouble tmp[this->rows*matrix_2.columns];\n\t\tfor (int i = 0; i < this->rows; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < matrix_2.columns; ++j)\n\t\t\t{\n\t\t\t\tdouble result=0;\n\t\t\t\tfor (int k = 0; k < this->columns; ++k)\n\t\t\t\t{\n\t\t\t\t\tresult+=this->values[i*this->columns+k]*matrix_2.values[k*matrix_2.columns+j];\n\t\t\t\t}\n\t\t\t\ttmp[i*matrix_2.columns+j]=result;\n\t\t\t}\n\t\t}\n\t\treturn Matrix(this->rows,matrix_2.columns,tmp);\n\t}\n\n\tMatrix max() const{\n\t\tif(rows==1){\n\t\t\tdouble max=0;\n\t\t\tfor (int i = 0; i < columns; ++i)\n\t\t\t{\n\t\t\t\tif(values[i]>max)\n\t\t\t\t\tmax=values[i];\n\t\t\t}\n\t\t\treturn Matrix(1,1,&max);\n\t\t}\n\t\tdouble max_tmp[columns];\n\t\tmemset(max_tmp,0,columns*sizeof(double));\n\t\tfor (int i = 0; i < columns; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < rows; ++j)\n\t\t\t{\n\t\t\t\tif(values[j*columns+i]>max_tmp[i])\n\t\t\t\t\tmax_tmp[i]=values[j*columns+i];\n\t\t\t}\n\t\t}\n\t\treturn Matrix(1,columns,max_tmp);\n\t}\n\n\tMatrix min() const{\n\t\tif(rows==1){\n\t\t\tdouble min =INF;\n\t\t\tfor (int i = 0; i < columns; ++i)\n\t\t\t{\n\t\t\t\tif(values[i]<min)\n\t\t\t\t\tmin=values[i];\n\t\t\t}\n\t\t\treturn Matrix(1,1,&min);\n\t\t}\n\t\tdouble min_tmp[columns];\n\t\tfor (int i = 0; i < columns; ++i)\n\t\t{\n\t\t\tdouble min =INF;\n\t\t\tfor (int j = 0; j < rows; ++j)\n\t\t\t{\n\t\t\t\tif(values[j*columns+i]<min)\n\t\t\t\t\tmin=values[j*columns+i];\n\t\t\t}\n\t\t\tmin_tmp[i]=min;\n\t\t}\n\t\treturn Matrix(1,columns,min_tmp);\n\t}\n\n\tMatrix sum() const{\n\t\tif(rows==1){\n\t\t\tdouble sum=0;\n\t\t\tfor (int i = 0; i < columns; ++i)\n\t\t\t{\n\t\t\t\tsum+=values[i];\n\t\t\t}\n\t\t\treturn Matrix(1,1,&sum);\n\t\t}\n\n\t\tdouble tmp_sum[columns];\n\t\tfor (int i = 0; i < columns; ++i)\n\t\t{\n\t\t\tdouble sum=0;\n\t\t\tfor (int j = 0; j < rows; ++j)\n\t\t\t{\n\t\t\t\tsum+=values[j*columns+i];\n\t\t\t}\n\t\t\ttmp_sum[i]=sum;\n\t\t}\n\t\treturn Matrix(1,columns,tmp_sum);\n\t}\n\n\tMatrix pow(double exponent){\n\t\tdouble tmp[rows*columns];\n\t\tfor (int i = 0; i < rows*columns; ++i)\n\t\t{\n\t\t\ttmp[i]=std::pow(values[i],exponent);\n\t\t}\n\t\treturn Matrix(rows,columns,tmp);\n\t}\n\n\tMatrix exp(){\n\t\tdouble tmp[rows*columns];\n\t\tfor (int i = 0; i < rows*columns; ++i)\n\t\t{\n\t\t\ttmp[i]=std::exp(values[i]);\n\t\t}\n\t\treturn Matrix(rows,columns,tmp);\n\t}\n\n\tMatrix log(){\n\t\tdouble tmp[rows*columns];\n\t\tfor (int i = 0; i < rows*columns; ++i)\n\t\t{\n\t\t\ttmp[i]=std::log(values[i]);\n\t\t}\n\t\treturn Matrix(rows,columns,tmp);\n\t}\n\n\tMatrix abs(){\n\t\tdouble tmp[rows*columns];\n\t\tfor (int i = 0; i < rows*columns; ++i)\n\t\t{\n\t\t\ttmp[i]=std::abs(values[i]);\n\t\t}\n\t\treturn Matrix(rows,columns,tmp);\n\t}\n\n\n};\n",
            1589550145.4058568,
            100,
            "# 答案正确"
        ],
        [
            "2.9 (C++)",
            "潘小健",
            "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nclass Matrix\n{\n\tint rows;\n\tint columns;\n\tdouble *values;\n\tconst static int INF = 1e9;\npublic:\n\tMatrix(int _rows,int _columns,double*_values=NULL):rows(_rows),columns(_columns){\n\t\tif(rows*columns==0)\n\t\t\tvalues=NULL;\n\t\tvalues=new double[rows*columns];\n\t\tif(_values==NULL){\n\t\t\tmemset(values,0,rows*columns*sizeof(double));\n\t\t}\n\t\telse{\n\t\t\tmemcpy(values,_values,rows*columns*sizeof(double));\n\t\t\t\t\n\t\t}\n\t}\n\n\tMatrix(const Matrix& matrix_out){\n\t\tthis->columns=matrix_out.columns;\n\t\tthis->rows=matrix_out.rows;\n\t\tthis->values=new double[rows*columns];\n\t\tmemcpy(this->values,matrix_out.values,rows*columns*sizeof(double));\n\t}\n\n\t~Matrix(){\n\t\tdelete [] values;\n\t}\n\t\n\tvoid print(){\n\t\tfor (int i = 0; i < rows; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < columns; ++j)\n\t\t\t{\n\t\t\t\tcout<<\"    \"<<values[i*columns+j];\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t}\n\n\tMatrix operator+(const Matrix &matrix2)const{\n\t\tdouble tmp[rows*columns]; \n\t\tfor (int i = 0; i < columns*rows; ++i)\n\t\t{\n\t\t\ttmp[i]=values[i]+matrix2.values[i];\n\t\t}\n\t\treturn Matrix(rows,columns,tmp);\n\t}\n\n\tMatrix operator-(const Matrix &matrix2)const{\n\t\tdouble tmp[rows*columns]; \n\t\tfor (int i = 0; i < columns*rows; ++i)\n\t\t{\n\t\t\ttmp[i]=values[i]-matrix2.values[i];\n\t\t}\n\t\treturn Matrix(rows,columns,tmp);\n\t}\n\n\tMatrix operator+(double value)const{\n\t\tdouble tmp[rows*columns]; \n\t\tfor (int i = 0; i < columns*rows; ++i)\n\t\t{\n\t\t\ttmp[i]=values[i]+value;\n\t\t}\n\t\treturn Matrix(rows,columns,tmp);\n\t}\n\n\tMatrix operator-(double value)const{\n\t\tdouble tmp[rows*columns]; \n\t\tfor (int i = 0; i < columns*rows; ++i)\n\t\t{\n\t\t\ttmp[i]=values[i]-value;\n\t\t}\n\t\treturn Matrix(rows,columns,tmp);\n\t}\n};",
            1590028564.2855093,
            100,
            "# 答案正确"
        ],
        [
            "6.1 (C++)",
            "潘小健",
            "#include <iostream>\n#include <cstring>\n#include <vector>\nusing namespace std;\n\ntemplate <typename T>\nclass Matrix\n {\n \tstd::vector<T> v_context;\n \tint rows;\n \tint columns;\n public:\n \tMatrix(int _rows,int _columns,const T* _values=NULL):rows(_rows),columns(_columns),v_context(_rows*_columns){\n \t\tif(_values!=NULL){\n \t\t\tfor (int i = 0; i < rows*columns; ++i)\n \t\t\t{\n\t\t \t\tv_context[i]=_values[i];\n \t\t\t}\n \t\t}\n \t}\n\n \tvoid print(){\n \t\tfor (int i = 0; i < rows; ++i)\n \t\t{\n \t\t\tfor (int j = 0; j < columns; ++j)\n \t\t\t{\n \t\t\t\tcout<<\"    \"<<v_context[i*columns+j];\n \t\t\t}\n \t\t\tcout<<endl;\n \t\t}\n \t}\n\n \tT& get(int row,int column){\n \t\treturn v_context[(row-1)*columns+column-1];\n \t}\n \t\n }; ",
            1590124639.9118097,
            100,
            "# 答案正确"
        ],
        [
            "6.3 (C++)",
            "潘小健",
            "#include <iostream>\n#include <cstring>\n#include <vector>\nusing namespace std;\n\ntemplate <typename T>\nclass Matrix\n {\n \tstd::vector<T> v_context;\n \tint rows;\n \tint columns;\n public:\n \tMatrix(int _rows,int _columns,const T* _values=NULL):v_context(_rows*_columns),rows(_rows),columns(_columns){\n \t\tif(_values!=NULL){\n \t\t\tfor (int i = 0; i < rows*columns; ++i)\n \t\t\t{\n\t\t \t\tv_context[i]=_values[i];\n \t\t\t}\n \t\t}\n \t}\n\n \tMatrix(int _rows,int _columns,vector<T> &_values):rows(_rows),columns(_columns){\n \t\tfor(auto i:_values){\n \t\t\tv_context.push_back(i);\n \t\t}\n \t}\n\n \tMatrix& print(){\n \t\tfor (int i = 0; i < rows; ++i)\n \t\t{\n \t\t\tfor (int j = 0; j < columns; ++j)\n \t\t\t{\n \t\t\t\tcout<<\"    \"<<v_context[i*columns+j];\n \t\t\t}\n \t\t\tcout<<endl;\n \t\t}\n \t\treturn*this;\n \t}\n\n \tT& get(int row,int column){\n \t\treturn v_context[(row-1)*columns+column-1];\n \t}\n\n \tMatrix getColumn(int column){\n \t\tvector<T> tmp_value;\n \t\tfor (int i = 0; i < rows; ++i)\n \t\t{\n \t\t\ttmp_value.push_back(v_context[i*columns+column-1]);\n \t\t}\n \t\treturn Matrix(rows,1,tmp_value);\n \t}\n\n \tMatrix getRow(int row){\n \t\tvector<T> tmp_value;\n \t\tfor (int i = 0; i < columns; ++i)\n \t\t{\n \t\t\ttmp_value.push_back(v_context[(row-1)*columns+i]);\n \t\t}\n \t\treturn Matrix(1,columns,tmp_value);\n \t}\n\n \tMatrix concatenateRows(const Matrix &matrix2){\n \t\tvector<T> tmp_value;\n \t\tfor(auto i:this->v_context){\n \t\t\ttmp_value.push_back(i);\n \t\t}\n \t\tfor(auto i:matrix2.v_context){\n \t\t\ttmp_value.push_back(i);\n \t\t}\n \t\treturn Matrix(this->rows+matrix2.rows,this->columns,tmp_value);\n \t}\n\n \tMatrix concatenateColumns(const Matrix &matrix2){\n \t\tvector<T> tmp_value(this->rows*(this->columns+matrix2.columns));\n \t\tfor (int i = 0; i < this->rows; ++i)\n \t\t{\n \t\t\tfor (int j = 0; j <this->columns ; ++j)\n \t\t\t{\n \t\t\t\ttmp_value[i*(this->columns+matrix2.columns)+j]=this->v_context[i*this->columns+j];\n \t\t\t}\n \t\t\tfor (int j = 0; j <matrix2.columns ; ++j)\n \t\t\t{\n \t\t\t\ttmp_value[i*(this->columns+matrix2.columns)+j+this->columns]=matrix2.v_context[i*matrix2.columns+j];\n \t\t\t}\n \t\t}\t\n \t\treturn Matrix(this->rows,this->columns+matrix2.columns,tmp_value);\n \t}\n\n \tMatrix reshape(int row,int column){\n \t\tvector<T> tmp_value1;\n \t\tfor (int i = 0; i < this->columns; ++i)\n \t\t{\n \t\t\tfor (int j = 0; j <this->rows; ++j)\n \t\t\t{\n \t\t\t\ttmp_value1.push_back(v_context[j*columns+i]);\n \t\t\t}\n \t\t}\n \t\tvector<T> tmp_value2(row*column);\n \t\tfor (int i = 0; i < columns*rows; ++i)\n \t\t{\n \t\t\tint to_column=i/row;\n \t\t\tint to_row=i%row;\n \t\t\ttmp_value2[to_row*column+to_column]=tmp_value1[i];\n \t\t}\n \t\treturn Matrix(row,column,tmp_value2);\n \t}\n\n \tMatrix transpose(){\n \t\tvector<T> tmp_value;\n \t\tfor (int i = 0; i < this->columns; ++i)\n \t\t{\n \t\t\tfor (int j = 0; j <this->rows; ++j)\n \t\t\t{\n \t\t\t\ttmp_value.push_back(v_context[j*columns+i]);\n \t\t\t}\n \t\t}\n \t\treturn Matrix(columns,rows,tmp_value);\n \t}\n\n \tMatrix operator+(const Matrix &matrix2){\n \t\tvector<T> tmp_value;\n \t\tfor (int i = 0; i < rows*columns; ++i)\n \t\t{\n \t\t\ttmp_value.push_back(this->v_context[i]+matrix2.v_context[i]);\n \t\t}\n \t\treturn Matrix(rows,columns,tmp_value);\n \t}\n\n\tMatrix operator+(T value){\n \t\tvector<T> tmp_value;\n \t\tfor (int i = 0; i < rows*columns; ++i)\n \t\t{\n \t\t\ttmp_value.push_back(this->v_context[i]+value);\n \t\t}\n \t\treturn Matrix(rows,columns,tmp_value);\n \t}\n\n \tMatrix operator-(const Matrix &matrix2){\n \t\tvector<T> tmp_value;\n \t\tfor (int i = 0; i < rows*columns; ++i)\n \t\t{\n \t\t\ttmp_value.push_back(this->v_context[i]-matrix2.v_context[i]);\n \t\t}\n \t\treturn Matrix(rows,columns,tmp_value);\n \t}\n\n \tMatrix operator-(T value){\n \t\tvector<T> tmp_value;\n \t\tfor (int i = 0; i < rows*columns; ++i)\n \t\t{\n \t\t\ttmp_value.push_back(this->v_context[i]-value);\n \t\t}\n \t\treturn Matrix(rows,columns,tmp_value);\n \t}\n\n \tMatrix operator*(const Matrix &matrix2){\n \t\tvector<T> tmp_value;\n \t\tfor (int i = 0; i < this->rows; ++i)\n \t\t{\n \t\t\tfor (int j = 0; j < matrix2.columns; ++j)\n \t\t\t{\n \t\t\t\tT sum=0;\n \t\t\t\tfor (int k = 0; k < this->columns; ++k)\n \t\t\t\t{\n \t\t\t\t\tsum+=this->v_context[i*this->columns+k]*matrix2.v_context[k*matrix2.columns+j];\n \t\t\t\t}\n \t\t\t\ttmp_value.push_back(sum);\n \t\t\t}\n \t\t}\n \t\treturn Matrix(this->rows,matrix2.columns,tmp_value);\n \t}\n\n \tMatrix operator*(T value){\n \t\tvector<T> tmp_value;\n \t\tfor (int i = 0; i < rows*columns; ++i)\n \t\t{\n \t\t\ttmp_value.push_back(this->v_context[i]*value);\n \t\t}\n \t\treturn Matrix(rows,columns,tmp_value);\n \t}\n\n \tMatrix max(){\n \t\tif(rows==1){\n \t\t\tT maximum=0;\n \t\t\tfor(auto i:v_context){\n \t\t\t\tif(i>maximum)\n \t\t\t\t\tmaximum=i;\n \t\t\t}\n \t\t\treturn Matrix(1,1,&maximum);\n \t\t}\n\n \t\tvector<T> tmp_value;\n \t\tfor (int i = 0; i < columns; ++i)\n \t\t{\n \t\t\tT maximum=0;\n \t\t\tfor (int j = 0; j < rows; ++j)\n \t\t\t{\n \t\t\t\tif(v_context[j*columns+i]>maximum)\n \t\t\t\t\tmaximum=v_context[j*columns+i];\n \t\t\t}\n \t\t\ttmp_value.push_back(maximum);\n \t\t}\n \t\treturn Matrix(1,columns,tmp_value);\n\n \t}\n\n \tMatrix min(){\n \t\tif(rows==1){\n \t\t\tT minimum=999999999;\n \t\t\tfor(auto i:v_context){\n \t\t\t\tif(i<minimum)\n \t\t\t\t\tminimum=i;\n \t\t\t}\n \t\t\treturn Matrix(1,1,&minimum);\n \t\t}\n\n \t\tvector<T> tmp_value;\n \t\tfor (int i = 0; i < columns; ++i)\n \t\t{\n \t\t\tT minimum=999999999;\n \t\t\tfor (int j = 0; j < rows; ++j)\n \t\t\t{\n \t\t\t\tif(v_context[j*columns+i]<minimum)\n \t\t\t\t\tminimum=v_context[j*columns+i];\n \t\t\t}\n \t\t\ttmp_value.push_back(minimum);\n \t\t}\n \t\treturn Matrix(1,columns,tmp_value);\n\n \t}\n\n \tMatrix sum(){\n \t\tif(rows==1){\n \t\t\tT all_sum=0;\n \t\t\tfor(auto i:v_context){\n \t\t\t\t\tall_sum+=i;\n \t\t\t}\n \t\t\treturn Matrix(1,1,&all_sum);\n \t\t}\n\n \t\tvector<T> tmp_value;\n \t\tfor (int i = 0; i < columns; ++i)\n \t\t{\n \t\t\tT all_sum=0;\n \t\t\tfor (int j = 0; j < rows; ++j)\n \t\t\t{\n\t\t\t\tall_sum+=v_context[j*columns+i];\n \t\t\t}\n \t\t\ttmp_value.push_back(all_sum);\n \t\t}\n \t\treturn Matrix(1,columns,tmp_value);\n\n \t}\n }; \n",
            1590173660.364952,
            100,
            "# 答案正确"
        ],
        [
            "6.2 (C++)",
            "潘小健",
            "#include <iostream>\n#include <cstring>\n#include <vector>\nusing namespace std;\ntemplate <typename T>\nclass Matrix\n {\n \tT *v_context;\n \tint rows;\n \tint columns;\n public:\n \tMatrix(int _rows,int _columns):rows(_rows),columns(_columns){\n \t\tv_context=new T[_rows*_columns];\n \t\tmemset(v_context,0,sizeof(T)*_columns*_rows);\n \t}\n\n \t~Matrix(){\n \t\tdelete []v_context;\n \t}\n\n\n \tMatrix& print(){\n \t\tfor (int i = 0; i < rows; ++i)\n \t\t{\n \t\t\tfor (int j = 0; j < columns; ++j)\n \t\t\t{\n \t\t\t\tcout<<\"    \"<<v_context[i*columns+j];\n \t\t\t}\n \t\t\tcout<<endl;\n \t\t}\n \t\treturn*this;\n \t}\n};",
            1590635442.2093632,
            100,
            "# 答案正确"
        ],
        [
            "7.1 (C++)",
            "潘小健",
            "#include <iostream>\n#include <cstring>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\n\nclass Triangle:public GeometricObject\n{\n\tdouble side1,side2,side3;\n\npublic:\n\tTriangle(double _side1=1,double _side2=1,double _side3=1):side1(_side1),side2(_side2),side3(_side3){}\n\n\tdouble getSide1(){\n\t\treturn side1;\n\t}\n\n\tdouble getSide2(){\n\t\treturn side2;\n\t}\n\n\tdouble getSide3(){\n\t\treturn side3;\n\t}\n\n\tdouble getArea(){\n\t\tdouble s=(side1+side2+side3)/2;\n\t\treturn sqrt(s*(s-side1)*(s-side2)*(s-side3));\n\t}\n\n\tdouble getPerimeter(){\n\t\treturn side1+side2+side3;\n\t}\n};\n",
            1590767210.7341363,
            100,
            "# 答案正确"
        ],
        [
            "7.3 (C++)",
            "潘小健",
            "#include <iostream>\n#include <cstring>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\ntemplate<typename A>\nvector<A> map2(const vector<A>& x,const vector<A>& y,A (*map_func)(const A &a,const A &b)){\n\tvector<A> result;\n\tfor (int i = 0; i < x.size(); ++i)\n\t{\n\t\tresult.push_back(map_func(x[i],y[i]));\n\t}\n\treturn result;\n}\n\ntemplate<typename A>\nvector<A> map2(const vector<A>& x,int c,A (*map_func)(const A &a,const A &b)){\n\tvector<A> result;\n\tfor (int i = 0; i < x.size(); ++i)\n\t{\n\t\tresult.push_back(map_func(x[i],c));\n\t}\n\treturn result;\n}\n",
            1590767808.7184374,
            100,
            "# 答案正确"
        ],
        [
            "7.2 (C++)",
            "潘小健",
            "#include <iostream>\n#include <cstring>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\n// vector<string> split(const string& line,const string& delimiter=\" \"){\n// \tvector<string> result;\n// \tint cur=0;\n// \twhile(cur<(int)line.size()){\n// \t\tint end=line.find(delimiter,cur);\n// \t\tif(end==cur){\n// \t\t\tcur+=delimiter.size();\n// \t\t}\n// \t\telse if(end==-1){\n// \t\t\tresult.push_back(line.substr(cur));\n// \t\t\tbreak;\n// \t\t}\n// \t\telse{\n// \t\t\tresult.push_back(line.substr(cur,end-cur));\n// \t\t\tcur=end+delimiter.size();\n// \t\t}\n\n// \t}\n// \treturn result;\n// }\n\nvector<string> split(const string& line){\n\tvector<string> result={\"\"};\n\tfor(auto i:line){\n\t\tif(i=='\\n')\n\t\t\tcontinue;\n\t\telse if(i==' '){\n\t\t\tif(result.back().empty()==false)\n\t\t\t\tresult.push_back(string());\n\t\t}\n\t\telse{\n\t\t\tresult.back()+=i;\n\t\t}\n\t}\n\tif(result.back().empty()==true){\n\t\tresult.pop_back();\n\t}\n\treturn result;\n}",
            1591240044.2180908,
            100,
            "# 答案正确"
        ],
        [
            "8.1 (C++)",
            "潘小健",
            "#include <iostream>\n#include <cstring>\n#include <vector>\n#include <cmath>\n\nusing std::cout;\n\nclass Full:public Matrix\n{\n    int row,column;\n    std::vector<double> values;\npublic:\n    Full(int out_row,int out_column,const double out_values[]=0):row(out_row),column(out_column),values(row*column){\n        if(out_values!=NULL){\n            for (int i = 0; i < row*column; ++i)\n            {\n                values[i]=out_values[i];\n            }\n        }\n    }\n\n    Full(const Matrix & out_matrix){\n        row=out_matrix.size(1);\n        column=out_matrix.size(2);\n        for (int i = 0; i < row; ++i)\n        {\n            for (int j = 0; j < column; ++j)\n            {\n                values.push_back(out_matrix.get(i,j));\n            }\n        }\n    }\n\n    int size(int dimension) const override{\n        if(dimension==1)\n            return row;\n        else if(dimension==2)\n            return column;\n        else\n            return 0;\n    }\n\n    void set(int out_row, int out_column, double out_value) override{\n        values[out_row*column+out_column]=out_value;\n    }\n\n    double get(int out_row, int out_column) const override{\n        return values[out_row*column+out_column];\n    }\n\n    vector<double>& get(){\n        return values;\n    }\n\n    void print() const override{\n        for (int i = 0; i < row; ++i)\n        {\n            for (int j = 0; j < column; ++j)\n            {\n                cout <<\"    \"<<values[i*column+j];\n            }\n            cout<<endl;\n        }\n    }\n\n     Full & operator = (const Matrix & matrix2) override{\n\n        row=matrix2.size(1);\n        column=matrix2.size(2);\n        values.clear();\n        for (int i = 0; i < row; ++i)\n        {\n            for (int j = 0; j < column; ++j)\n            {\n                values.push_back(matrix2.get(i,j));\n            }\n        }\n        return *this;\n     }\n};",
            1591387682.8883643,
            100,
            "# 答案正确"
        ],
        [
            "8.3 (C++)",
            "潘小健",
            "#include <iostream>\n#include <cstring>\n#include <vector>\n#include <cmath>\n#include <algorithm>\nusing std::cout;\n\nbool operator<(Entry &a,Entry &b){\n    if(a.row<b.row)\n        return true;\n    else if(a.row==b.row && a.column<b.column)\n        return true;\n    else \n        return false;\n}\nbool operator<=(Entry &a,Entry &b){\n    if(a.row<b.row)\n        return true;\n    else if(a.row==b.row && a.column<=b.column)\n        return true;\n    else \n        return false;\n}\nbool operator==(Entry &a,Entry &b){\n    if(a.row==b.row && a.column==b.column)\n        return true;\n    else \n        return false;\n}\n\nclass Sparse:public Matrix\n{\n    int row,column;\n    std::vector<Entry> values;\npublic:\n    Sparse(int out_row,int out_column):row(out_row),column(out_column){}\n\n    \n    int size(int dimension) const override{\n        if(dimension==1)\n            return row;\n        else if(dimension==2)\n            return column;\n        else\n            return 0;\n    }\n\n    void set(int out_row, int out_column, double out_value) override{\n        for(auto i:values){\n            if(i.row==out_row && i.column==out_column){\n                i.value=out_value;\n                return;\n            }\n        }\n        Entry tmp;\n        tmp.row=out_row;\n        tmp.column=out_column;\n        tmp.value=out_value;\n        values.push_back(tmp);\n    }\n\n    double get(int out_row, int out_column) const override{\n        for(auto i:values){\n            if(i.row==out_row && i.column==out_column)\n                return i.value;\n        }\n        return -1;\n    }\n\n    void print() override{\n        sort(values.begin(), values.end());\n        for(auto i:values){\n            if(i.value!=0)\n                cout<<\"(\"<<i.row<<\",\"<<i.column<<\",\"<<i.value<<\")\\n\";\n        }\n    }\n\n    Sparse operator+(Sparse & sparse2) {\n        sort(values.begin(), values.end());\n        sort(sparse2.values.begin(), sparse2.values.end());\n        Sparse tmp(row,column);\n        tmp.values=values;\n\n        int j=0;\n        for(auto i:sparse2.values){\n          \n            while(j<(int)this->values.size()&&tmp.values[j]<i){\n                ++j;\n            }\n            if(j<(int)this->values.size()&&i==tmp.values[j]){\n                tmp.values[j].value+=i.value;\n                // cout<<tmp.values[j].value<<\"text is ok!\\n\";\n            }\n            else \n                tmp.values.push_back(i);\n\n        }\n        return tmp;\n    }\n\n};",
            1591446195.34452,
            100,
            "# 答案正确"
        ],
        [
            "8.4 (C++)",
            "潘小健",
            "#include <iostream>\n#include <cstring>\n#include <vector>\n#include <cmath>\n#include <algorithm>\nusing std::cout;\n\nbool operator<(Entry &a,Entry &b){\n    if(a.row<b.row)\n        return true;\n    else if(a.row==b.row && a.column<b.column)\n        return true;\n    else \n        return false;\n}\nbool operator<=(Entry &a,Entry &b){\n    if(a.row<b.row)\n        return true;\n    else if(a.row==b.row && a.column<=b.column)\n        return true;\n    else \n        return false;\n}\nbool operator==(Entry &a,Entry &b){\n    if(a.row==b.row && a.column==b.column)\n        return true;\n    else \n        return false;\n}\n\nbool cmp1(Entry &a,Entry &b){\n    if(a.column<b.column)\n        return true;\n    else if(a.column==b.column && a.row<b.row)\n        return true;\n    else \n        return false;   \n}\n\nclass Sparse:public Matrix\n{\n    int row,column;\n    std::vector<Entry> values;\npublic:\n    Sparse(int out_row,int out_column):row(out_row),column(out_column){}\n\n    \n    int size(int dimension) const override{\n        if(dimension==1)\n            return row;\n        else if(dimension==2)\n            return column;\n        else\n            return 0;\n    }\n\n    void set(int out_row, int out_column, double out_value) override{\n        for(auto i:values){\n            if(i.row==out_row && i.column==out_column){\n                i.value=out_value;\n                return;\n            }\n        }\n        Entry tmp;\n        tmp.row=out_row;\n        tmp.column=out_column;\n        tmp.value=out_value;\n        values.push_back(tmp);\n    }\n\n    double get(int out_row, int out_column) const override{\n        for(auto i:values){\n            if(i.row==out_row && i.column==out_column)\n                return i.value;\n        }\n        return -1;\n    }\n\n    void print() override{\n        sort(values.begin(), values.end());\n        for(auto i:values){\n            if(i.value!=0)\n                cout<<\"(\"<<i.row<<\",\"<<i.column<<\",\"<<i.value<<\")\\n\";\n        }\n    }\n\n    Sparse operator+(Sparse & sparse2) {\n        sort(values.begin(), values.end());\n        sort(sparse2.values.begin(), sparse2.values.end());\n        Sparse tmp(row,column);\n        tmp.values=values;\n\n        int j=0;\n        for(auto i:sparse2.values){\n          \n            while(j<(int)this->values.size()&&tmp.values[j]<i){\n                ++j;\n            }\n            if(j<(int)this->values.size()&&i==tmp.values[j]){\n                tmp.values[j].value+=i.value;\n                // cout<<tmp.values[j].value<<\"text is ok!\\n\";\n            }\n            else \n                tmp.values.push_back(i);\n\n        }\n        return tmp;\n    }\n\n    Sparse operator*(Sparse & sparse2){\n        sort(this->values.begin(), this->values.end());\n        sort(sparse2.values.begin(),sparse2.values.end(),cmp1);\n\n        Sparse result(this->row,sparse2.column);\n        std::vector<Entry> tmp1;\n\n        for (int i = 0; i < (int)this->values.size();)\n        {\n            tmp1.clear();\n            do{\n                tmp1.push_back(this->values[i++]);\n            }while(i<(int)this->values.size()&&this->values[i].row==tmp1[0].row);\n            \n            Entry last;\n            last.row=tmp1[0].row;\n            last.column=sparse2.values[0].column;\n            last.value=0;\n\n            for(auto j:sparse2.values){\n                if(last.column!=j.column){\n                    result.values.push_back(last);\n                    last.row=tmp1[0].row;\n                    last.column=j.column;\n                    last.value=0;\n                }\n\n                for(auto k:tmp1){\n                    if(k.column>j.row)\n                        break;\n                    if(k.column==j.row){\n                        last.value+=k.value*j.value;\n                        break;\n                    }\n                }\n            }\n            result.values.push_back(last);\n        }\n        return result;\n    }    \n\n};",
            1591455120.4515946,
            100,
            "# 答案正确"
        ],
        [
            "8.5 (C++)",
            "潘小健",
            "#include <iostream>\n#include <cstring>\n#include <vector>\n#include <cmath>\n#include <algorithm>\nusing std::cout;\n\nclass Point3D:public Point2D\n{\n    double z;\npublic:\n    Point3D(double x1=0,double y1=0,double z1=0){\n        setX(x1);\n        setY(y1);\n        z=z1;\n    }\n    \n    double getZ(){\n        return z;\n    }\n    //ad\n    double distance(Point2D & point2)override{\n        Point3D&point3 = dynamic_cast<Point3D&> (point2);\n        return sqrt(pow(point3.getX()-this->getX(),2)+pow(point3.getY()-this->getY(),2)+pow(point3.getZ()-this->getZ(),2));\n    }\n};",
            1591843476.269393,
            100,
            "# 答案正确"
        ],
        [
            "8.6 (C++)",
            "潘小健",
            "#include <iostream>\nclass MyTensor:public Tensor<double>\n{\n    double* value;\npublic:\n    MyTensor(vector<int> sizes):Tensor(sizes)\n    {\n        int size=1;\n        for(auto i:sizes)\n            size*=i;\n        value = new double[size];\n    }\n\n    double& get(const vector<int> & indexes)\n    {\n        int position=0;\n        for (int i = 0; i < (int)sizes.size(); ++i)\n        {\n            int t=1;\n            for (int j = 0; j < i; ++j)\n            {\n                t*=sizes[j];\n            }\n            position+=t*indexes[i];\n        }\n        return value[position];\n    }\n\n    ~MyTensor()\n    {\n        delete []value;\n    }\n    \n};",
            1592450171.3909478,
            100,
            "# 答案正确"
        ],
        [
            "9.1 (C++)",
            "潘小健",
            "class Circle\n{\n    double radii;\npublic:\n    Circle(double radii2):radii(radii2){}\n\n    bool operator<(const Circle &out) const\n    {\n        return this->radii<out.radii;\n    }\n\n    bool operator<=(const Circle &out) const\n    {\n        return this->radii<=out.radii;\n    }\n\n    bool operator==(const Circle &out) const\n    {\n        return this->radii==out.radii;\n    }\n\n    bool operator!=(const Circle &out) const\n    {\n        return this->radii!=out.radii;\n    }\n\n    bool operator>=(const Circle &out) const\n    {\n        return this->radii>=out.radii;\n    }\n\n    bool operator>(const Circle &out) const\n    {\n        return this->radii>out.radii;\n    }\n};",
            1592584679.9501276,
            100,
            "# 答案正确"
        ],
        [
            "9.2 (C++)",
            "潘小健",
            "class I\n{\n    vector<int> v;\npublic:\n    I(int a=-1,int b=-1,int c=-1,int d=-1)\n    {\n        if(a!=-1)\n            v.push_back(a);\n        if(b!=-1)\n            v.push_back(b);\n        if(c!=-1)\n            v.push_back(c);\n        if(d!=-1)\n            v.push_back(d);\n    }\n    \n    operator vector<int>() const\n    {\n        return v;\n    }\n};",
            1592585162.238095,
            100,
            "# 答案正确"
        ],
        [
            "9.3 (C++)",
            "潘小健",
            "class Complex\n{\n    double in_real;\n    double in_image;\npublic:\n    Complex(double a,double b=0):in_real(a),in_image(b)\n    {}\n    \n    double real() const\n    {\n        return in_real;\n    }\n\n    double imag() const\n    {\n        return in_image;\n    }\n    Complex operator*(const Complex&b) const\n    {\n        double tmp_in_real=this->in_real*b.in_real-this->in_image*b.in_image;\n        double tmp_in_image=this->in_image*b.in_real+this->in_real*b.in_image;\n        return Complex(tmp_in_real,tmp_in_image);\n    }\n\n    Complex operator/(const Complex&b) const\n    {\n        double tmp=b.in_real*b.in_real+b.in_image*b.in_image;\n        double tmp_in_real=(this->in_real*b.in_real+this->in_image*b.in_image)/tmp;\n        double tmp_in_image=(this->in_image*b.in_real-this->in_real*b.in_image)/tmp;\n        return Complex(tmp_in_real,tmp_in_image);\n    }\n\n    Complex& operator+=(const Complex&b)\n    {\n        this->in_real+=b.in_real;\n        this->in_image+=b.in_image;\n        return*this;\n    }\n\n    Complex& operator-=(const Complex&b)\n    {\n        this->in_real-=b.in_real;\n        this->in_image-=b.in_image;\n        return*this;\n    }\n\n    Complex& operator*=(const Complex &b)\n    {\n        double tmp_in_real=this->in_real*b.in_real-this->in_image*b.in_image;\n        double tmp_in_image=this->in_image*b.in_real+this->in_real*b.in_image;\n        this->in_real=tmp_in_real;\n        this->in_image=tmp_in_image;\n        return *this;\n    }\n\n    Complex& operator/=(const Complex &b) \n    {\n        double tmp=b.in_real*b.in_real+b.in_image*b.in_image;\n        double tmp_in_real=(this->in_real*b.in_real+this->in_image*b.in_image)/tmp;\n        double tmp_in_image=(this->in_image*b.in_real-this->in_real*b.in_image)/tmp;\n        this->in_real=tmp_in_real;\n        this->in_image=tmp_in_image;\n        return *this;\n    }\n\n    bool operator==(const Complex&b) const\n    {\n        return in_real==b.in_real&&in_image==b.in_image;\n    }\n\n    bool operator!=(const Complex&b) const\n    {\n        return in_real!=b.in_real||in_image!=b.in_image;\n    }\n\n\n\n};\n\nComplex operator+(const Complex a,const Complex b)\n{\n    return Complex(a.real()+b.real(),a.imag()+b.imag());\n}\n\nComplex operator-(const Complex a,const Complex b)\n{\n    return Complex(a.real()-b.real(),a.imag()-b.imag());\n}",
            1593019395.3940969,
            100,
            "# 答案正确"
        ],
        [
            "9.4 (C++)",
            "潘小健",
            "class Complex\n{\n    double in_real;\n    double in_image;\npublic:\n    Complex(double a=0,double b=0):in_real(a),in_image(b)\n    {}\n    \n    double real() const\n    {\n        return in_real;\n    }\n\n    double imag() const\n    {\n        return in_image;\n    }\n    Complex operator*(const Complex&b) const\n    {\n        double tmp_in_real=this->in_real*b.in_real-this->in_image*b.in_image;\n        double tmp_in_image=this->in_image*b.in_real+this->in_real*b.in_image;\n        return Complex(tmp_in_real,tmp_in_image);\n    }\n\n    Complex operator/(const Complex&b) const\n    {\n        double tmp=b.in_real*b.in_real+b.in_image*b.in_image;\n        double tmp_in_real=(this->in_real*b.in_real+this->in_image*b.in_image)/tmp;\n        double tmp_in_image=(this->in_image*b.in_real-this->in_real*b.in_image)/tmp;\n        return Complex(tmp_in_real,tmp_in_image);\n    }\n\n    Complex& operator+=(const Complex&b)\n    {\n        this->in_real+=b.in_real;\n        this->in_image+=b.in_image;\n        return*this;\n    }\n\n    Complex& operator-=(const Complex&b)\n    {\n        this->in_real-=b.in_real;\n        this->in_image-=b.in_image;\n        return*this;\n    }\n\n    Complex& operator*=(const Complex &b)\n    {\n        double tmp_in_real=this->in_real*b.in_real-this->in_image*b.in_image;\n        double tmp_in_image=this->in_image*b.in_real+this->in_real*b.in_image;\n        this->in_real=tmp_in_real;\n        this->in_image=tmp_in_image;\n        return *this;\n    }\n\n    Complex& operator/=(const Complex &b) \n    {\n        double tmp=b.in_real*b.in_real+b.in_image*b.in_image;\n        double tmp_in_real=(this->in_real*b.in_real+this->in_image*b.in_image)/tmp;\n        double tmp_in_image=(this->in_image*b.in_real-this->in_real*b.in_image)/tmp;\n        this->in_real=tmp_in_real;\n        this->in_image=tmp_in_image;\n        return *this;\n    }\n\n    bool operator==(const Complex&b) const\n    {\n        return in_real==b.in_real&&in_image==b.in_image;\n    }\n\n    bool operator!=(const Complex&b) const\n    {\n        return in_real!=b.in_real||in_image!=b.in_image;\n    }\n\n\n\n};\n\nComplex operator+(const Complex a,const Complex b)\n{\n    return Complex(a.real()+b.real(),a.imag()+b.imag());\n}\n\nComplex operator-(const Complex a,const Complex b)\n{\n    return Complex(a.real()-b.real(),a.imag()-b.imag());\n}\n\nistream & operator>>(istream&input,Complex &out)\n{\n    double a,b;\n    input>>a>>b;\n    out=Complex(a,b);\n    return input;\n}\n\nostream & operator<<(ostream&output,const Complex &a)\n{\n    output<<a.real()<<\" + \"<<a.imag()<<\" i\";\n    return output;\n}",
            1592590993.5739958,
            100,
            "# 答案正确"
        ],
        [
            "9.5 (C++)",
            "潘小健",
            "class Complex\n{\n    double in_real;\n    double in_image;\npublic:\n    Complex(double a=0,double b=0):in_real(a),in_image(b)\n    {}\n    \n    double real() const\n    {\n        return in_real;\n    }\n\n    double imag() const\n    {\n        return in_image;\n    }\n    Complex operator*(const Complex&b) const\n    {\n        double tmp_in_real=this->in_real*b.in_real-this->in_image*b.in_image;\n        double tmp_in_image=this->in_image*b.in_real+this->in_real*b.in_image;\n        return Complex(tmp_in_real,tmp_in_image);\n    }\n\n    Complex operator/(const Complex&b) const\n    {\n        double tmp=b.in_real*b.in_real+b.in_image*b.in_image;\n        double tmp_in_real=(this->in_real*b.in_real+this->in_image*b.in_image)/tmp;\n        double tmp_in_image=(this->in_image*b.in_real-this->in_real*b.in_image)/tmp;\n        return Complex(tmp_in_real,tmp_in_image);\n    }\n\n    Complex& operator+=(const Complex&b)\n    {\n        this->in_real+=b.in_real;\n        this->in_image+=b.in_image;\n        return*this;\n    }\n\n    Complex& operator-=(const Complex&b)\n    {\n        this->in_real-=b.in_real;\n        this->in_image-=b.in_image;\n        return*this;\n    }\n\n    Complex& operator*=(const Complex &b)\n    {\n        double tmp_in_real=this->in_real*b.in_real-this->in_image*b.in_image;\n        double tmp_in_image=this->in_image*b.in_real+this->in_real*b.in_image;\n        this->in_real=tmp_in_real;\n        this->in_image=tmp_in_image;\n        return *this;\n    }\n\n    Complex& operator/=(const Complex &b) \n    {\n        double tmp=b.in_real*b.in_real+b.in_image*b.in_image;\n        double tmp_in_real=(this->in_real*b.in_real+this->in_image*b.in_image)/tmp;\n        double tmp_in_image=(this->in_image*b.in_real-this->in_real*b.in_image)/tmp;\n        this->in_real=tmp_in_real;\n        this->in_image=tmp_in_image;\n        return *this;\n    }\n\n    Complex& operator++()\n    {\n        ++this->in_real;\n        return *this;\n    }\n    Complex operator++(int)\n    {\n        Complex tmp=*this;\n        ++this->in_real;\n        return tmp;\n    }\n\n    operator double()const\n    {\n        return in_real;\n    }\n\n    bool operator==(const Complex&b) const\n    {\n        return in_real==b.in_real&&in_image==b.in_image;\n    }\n\n    bool operator!=(const Complex&b) const\n    {\n        return in_real!=b.in_real||in_image!=b.in_image;\n    }\n\n\n\n};\n\nComplex operator+(const Complex a,const Complex b)\n{\n    return Complex(a.real()+b.real(),a.imag()+b.imag());\n}\n\nComplex operator-(const Complex a,const Complex b)\n{\n    return Complex(a.real()-b.real(),a.imag()-b.imag());\n}\n\nistream & operator>>(istream&input,Complex &out)\n{\n    double a,b;\n    input>>a>>b;\n    out=Complex(a,b);\n    return input;\n}\n\nostream & operator<<(ostream&output,const Complex &a)\n{\n    output<<a.real()<<\" + \"<<a.imag()<<\" i\";\n    return output;\n}",
            1592590819.7140615,
            100,
            "# 答案正确"
        ],
        [
            "9.6 (C++)",
            "潘小健",
            "class Tensor\n{\n    std::vector<double> values;\n    std::vector<int> sizes;\npublic:\n    Tensor(int a,int b,int c,int d=-1)\n    {\n        int size=a*b*c;\n        sizes.push_back(a);\n        sizes.push_back(b);\n        sizes.push_back(c);\n    \n\n        if(d!=-1)\n        {\n            size*=d;\n            sizes.push_back(d);\n        }\n\n        values.resize(size);\n    }\n\n    double &operator() (int a, int b,int c,int d=-1)\n    {\n        int position=a;\n        position=position*sizes[0]+b;\n        position=position*sizes[1]+c;\n        if(d!=-1)\n            position=position*sizes[2]+d;\n\n        return values[position];\n    }\n    \n};",
            1592588037.7726974,
            100,
            "# 答案正确"
        ],
        [
            "9.7 (C++)",
            "潘小健",
            "class Tensor\n{\npublic:\n    std::vector<double> values;\n    std::vector<int> sizes;\n};\n\nistream& operator>>(istream&input,Tensor&matrix)\n{\n    int dimension;\n    input>>dimension;\n    int size=1;\n    for (int i = 0; i < dimension; ++i)\n    {\n        int tmp;\n        cin>>tmp;\n        size*=tmp;\n        matrix.sizes.push_back(tmp);\n    }\n    for (int i = 0; i < size; ++i)\n    {\n        double tmp;\n        input>>tmp;\n        matrix.values.push_back(tmp);\n    }\n    return input;\n}\n\nostream& operator<<(ostream&output,Tensor&matrix)\n{\n    int dimension=matrix.sizes.size();\n    output<<dimension<<endl;\n    for (int i = 0; i < dimension; ++i)\n        output<<matrix.sizes[i]<<\" \";\n    output<<endl<<endl;\n\n    if(dimension==1)\n    {\n        for (int i = 0; i < matrix.sizes[0]; ++i)\n        {\n            output<<matrix.values[i];\n            matrix.values[i];\n        }\n        return output;\n    }\n\n    int dim1=matrix.sizes[dimension-2];\n    int dim2=matrix.sizes[dimension-1];\n    int other_dimension=1;\n    for (int i = 0; i < dimension-2; ++i)\n        other_dimension*=matrix.sizes[i];\n\n    for (int i = 0; i < other_dimension; ++i)\n    {\n        for (int j = 0; j < dim1; ++j)\n        {\n            for (int k = 0; k < dim2; ++k)\n            {\n                output<<matrix.values[k+j*dim2+i*dim1*dim2]<<\" \";\n            }\n            output<<endl;\n        }\n        output<<endl;\n    }\n    return output;\n}",
            1592590059.0902593,
            100,
            "# 答案正确"
        ],
        [
            "10.1 (C++)",
            "潘小健",
            "#include <iostream>\n#include <vector>\n#include <stdexcept>\nusing namespace std;\n\nclass MatrixSizesDoNotMatchException{};\n\ndouble Matrix::get(int row,int column)const\n{\n    if(row<=0|| column <= 0  || row > rows ||column > columns)\n    {\n        throw out_of_range(\"out_of_range\");\n    }\n    --row;--column;\n    return elements[row*columns+column];\n}\n\nvoid Matrix::set(int row, int column, double value)\n{\n    if(row<=0|| column <= 0  || row > rows ||column > columns)\n    {\n        throw out_of_range(\"range\");\n    }\n    --row;--column;\n    elements[row*columns+column]=value;\n}\n\nMatrix Matrix::operator + (const Matrix & matrix2)const\n{\n    if(this->rows!=matrix2.size(1)||this->columns!=matrix2.size(2))\n        throw MatrixSizesDoNotMatchException();\n    Matrix result(this->rows,this->columns);\n    for (int i = 0; i < rows; ++i)\n    {\n        for (int j = 0; j < columns; ++j)\n        {\n            result.set(i+1,j+1,this->get(i+1,j+1)+matrix2.get(i+1,j+1));\n        }\n    }\n\n    return result;\n\n}\n",
            1593319020.8795538,
            100,
            "# 答案正确"
        ],
        [
            "10.2 (C++)",
            "潘小健",
            "catch(NonPositiveValueException&a){\n\tcout<<\"caught: NonPositiveValueException\"<<endl;\n}\ncatch(out_of_range&a){\n\tcout<<\"caught: out_of_range\"<<endl;\n\n}",
            1593656677.500708,
            100,
            "# 答案正确"
        ],
        [
            "15.1 (C++)",
            "潘小健",
            "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nclass Table\n{\n    vector<string> column_header;\n    vector<vector<string> > row;\npublic:\n    void addCol(const string &header)\n    {\n        column_header.push_back(header);\n        return;\n    }\n\n    vector<string>& operator[](int i)\n    {\n        if(i==(int)row.size())\n        {\n            row.push_back(vector<string>());\n        }\n        return row[i];\n    }\n\n    string json() const\n    {\n        string res;\n        res+=\"{\\n\";\n        res+=\"\\theaders: [\";\n        for(auto i:column_header)\n        {\n            res+=\"'\";\n            res+=i;\n            res+=\"',\";\n\n        }\n        res+=\"],\\n\";\n\n        res+=\"\\trows: [\\n\";\n        for (int i = 0; i < (int)row.size(); ++i)\n        {\n            res+=\"\\t\\t[\";\n            for(auto j:row[i])\n            {\n                res+=\"'\";\n                res+=j;\n                res+=\"',\";\n            }\n            res+=\"],\\n\";\n        }\n\n        res+=\"\\t],\\n\";\n        res+=\"}\\n\";\n        return res;\n    }\n    \n};\n",
            1593747817.010236,
            100,
            "# 答案正确"
        ],
        [
            "2020-07-09 LAB",
            "潘小健",
            "#include <iostream>\n#include <string>\nusing namespace std;\nclass Integer\n{\n    int val;\n    static int added_all;\npublic:\n    Integer(int _val=0)\n    {\n        val=_val;\n    }\n\n    static void increase_all(int added)\n    {\n        added_all+=added;\n    }\n\n    static void increase_all(Integer added)\n    {\n        added_all+=added_all;\n        added_all+=added.val;\n    }\n\n\n\n    friend istream& operator>>(istream&in,Integer &x);\n    friend ostream& operator<<(ostream&out,Integer &x);\n};\n\nint Integer::added_all=0;\n\nistream& operator>>(istream&in,Integer &x)\n{\n    in>>x.val;\n    return in;\n}\n\nostream& operator<<(ostream&out,Integer &x)\n{\n    out<<x.val+x.added_all;\n    return out;\n}",
            1594263457.7502077,
            100,
            "# 答案正确"
        ],
        [
            "A.1 (C++)",
            "潘小健",
            "\nLinkedList(LinkedList &list1)\n{\n    _size=0;\n    tail=NULL;\n    head=NULL;\n    for (int i = 0; i < list1.size(); ++i)\n    {\n        E tmp=list1.get(i);\n        addLast(tmp);\n    }\n}\n\n~LinkedList()\n{\n    while(_size>0)\n    {\n        removeFirst();\n    }\n}\n\nvoid addFirst(E val)\n{\n    Node<E>*tmp=new Node<E>;\n    tmp->element=val;\n\n    tmp->update_prev_and_next_node(NULL,head);\n    if(head!=NULL)\n        head->update_prev_node(NULL,tmp);\n    head=tmp;\n    if(tail==NULL)\n        tail=tmp;\n    ++_size;\n    return;\n}\n\nvoid addLast(E val)\n{\n    Node<E>*tmp=new Node<E>;\n    tmp->element=val;\n\n    tmp->update_prev_and_next_node(tail,NULL);\n    if(tail!=NULL)\n        tail->update_next_node(NULL,tmp);\n    tail=tmp;\n    if(head==NULL)\n        head=tmp;\n    ++_size;\n    return;\n}\n\nNode<E>* getNode(int index)\n{\n    if(index < 0||index >=_size)\n        throw NotSuchElementException();\n    Node<E>*cur;\n    if(index<_size/2)\n    {\n        cur=head;\n        Node<E>*last=NULL;\n        for (int i = 0; i < index; ++i)\n        {\n            Node<E>*next=cur->next_node(last);\n            last=cur;\n            cur=next;\n        }\n    }\n    else\n    {\n        cur=tail;\n        Node<E>*next=NULL;\n        for (int i = 0; i < _size-index-1; ++i)\n        {\n            Node<E>*last=cur->prev_node(next);\n            next=cur;\n            cur=last;\n        }\n    }\n\n    return cur;\n}\n\nE& get(int index)\n{\n    return getNode(index)->element;\n}\n\nvoid removeFirstOccurrence(E val)\n{\n    Node<E>*cur=head;\n    Node<E>*last=NULL;\n    for (int i = 0; i < _size; ++i)\n    {\n        Node<E>*next=cur->next_node(last);\n        if(cur->element==val)\n        {\n            if(last==NULL)\n                head=next;\n            else\n            {\n                last->update_next_node(cur,next);\n            }\n            if(next==NULL)\n                tail=last;\n            else\n            {\n                next->update_prev_node(cur,last);\n            }\n\n            delete cur;\n            --_size;\n            return;\n        }\n\n        last=cur;\n        cur=next;\n    }\n    throw NotSuchElementException();\n}\n\nvoid removeLast()\n{\n    if(tail==NULL)\n        throw NotSuchElementException();\n\n    Node<E>*cur=tail;\n    Node<E>*last=cur->prev_node(NULL);\n    if(last!=NULL)\n    {\n        last->update_next_node(cur,NULL);\n        tail=last;\n    }\n    else\n    {\n        head=NULL;\n        tail=NULL;\n    }\n\n    --_size;\n    delete cur;\n}\n\nvoid removeFirst()\n{\n    if(head==NULL)\n        throw NotSuchElementException();\n\n    Node<E>*cur=head;\n    Node<E>*next=cur->next_node(NULL);\n    if(next!=NULL)\n    {\n        next->update_prev_node(cur,NULL);\n        head=next;\n    }\n    else\n    {\n        head=NULL;\n        tail=NULL;\n    }\n\n    --_size;\n    delete cur;\n}\n\n",
            1594446206.5697556,
            100,
            "# 答案正确"
        ],
        [
            "A.2 (C++)",
            "潘小健",
            "template <typename E>\nvoid LinkedList<E>::removeAll(const E & e)\n{\n    try\n    {\n        while(1)\n        {\n            this->removeFirstOccurrence(e);\n        }\n    }\n    catch(NotSuchElementException tmp)\n    {\n        return;\n    }\n}",
            1594867822.3062356,
            100,
            "# 答案正确"
        ],
        [
            "A.4 (C++)",
            "潘小健",
            "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass NoSuchKeyException{};\n\nclass HT\n{\n    class Tuple\n    {\n    public:\n        string key1;\n        int key2;\n        string val1;\n        int val2;\n        bool used;\n        bool key_switch_string;\n        bool val_switch_string;\n\n        Tuple():used(false){}\n\n        operator int()\n        {\n            return val2;\n        }\n\n        operator string()\n        {\n            return val1;\n        }\n    };\n\n    vector<Tuple> tuples;\n    int sizes;\n\n    size_t _hash_function(const int& key)\n    {\n        size_t code=key;\n        for (int i = 0; i < 20; ++i)\n        {\n            code=((code*i+7)*code)^(code+3);\n        }\n        return code;\n    }\n\n    size_t _hash_function(const string& key)\n    {\n        size_t code=0;\n        for (int i = 0; i < (int)key.size(); ++i)\n        {\n            code^=_hash_function((int)key[i]);\n        }\n        return code;\n    }\n\n    inline bool _match(Tuple& tuple,int key)\n    {\n        if(!tuple.key_switch_string)\n            return tuple.key2==key;\n        return false;\n    }\n\n    inline bool _match(Tuple& tuple,string key)\n    {\n        if(tuple.key_switch_string)\n            return tuple.key1==key;\n        return false;\n    }\n\n    template<typename K>\n    size_t _canonical_index(const K& key)\n    {\n        size_t hash_code=_hash_function(key);\n        return hash_code%tuples.size();\n    }\n\n    bool _between(size_t a,size_t b,size_t c)\n    {\n        if(a<c)\n            return b>a&&b<=c;\n        else\n            return b>a||b<=c;\n    }\npublic:\n    HT():tuples(1000),sizes(0){}\n\n    template<typename K>\n    size_t index_of_key(const K& key)\n    {\n        size_t index=_canonical_index(key);\n        while(true)\n        {\n            if(!tuples[index].used)\n                return index;\n            if(_match(tuples[index],key))\n                return index;\n            index=(index+1)%tuples.size();\n        }\n    }\n\n    void put(int key,int val)\n    {\n        size_t index=index_of_key(key);\n        tuples[index].key2=key;\n        tuples[index].val2=val;\n        tuples[index].key_switch_string=false;\n        tuples[index].val_switch_string=false;\n        if(tuples[index].used==false)\n        {\n            tuples[index].used=true;\n            ++sizes;\n        }\n    }\n\n    void put(int key,string val)\n    {\n        size_t index=index_of_key(key);\n        tuples[index].key2=key;\n        tuples[index].val1=val;\n        tuples[index].key_switch_string=false;\n        tuples[index].val_switch_string=true;\n        if(tuples[index].used==false)\n        {\n            tuples[index].used=true;\n            ++sizes;\n        }\n    }\n    \n    void put(string key,string val)\n    {\n        size_t index=index_of_key(key);\n        tuples[index].key1=key;\n        tuples[index].val1=val;\n        tuples[index].key_switch_string=true;\n        tuples[index].val_switch_string=true;\n        if(tuples[index].used==false)\n        {\n            tuples[index].used=true;\n            ++sizes;\n        }\n    }\n\n    void put(string key,int val)\n    {\n        size_t index=index_of_key(key);\n        tuples[index].key1=key;\n        tuples[index].val2=val;\n        tuples[index].key_switch_string=true;\n        tuples[index].val_switch_string=false;\n        if(tuples[index].used==false)\n        {\n            tuples[index].used=true;\n            ++sizes;\n        }\n    }\n\n    template<typename K>\n    void remove(K key)\n    {\n        size_t index=index_of_key(key);\n        if(!tuples[index].used)\n            throw NoSuchKeyException();\n        tuples[index].used=false;\n        --sizes;\n\n        size_t hole=index;\n        size_t tuple_index;\n        while(true)\n        {\n            tuple_index=(tuple_index+1)%tuples.size();\n            if(!tuples[tuple_index].used)\n                return;\n            size_t canonical=_canonical_index(tuples[tuple_index]);\n            if(_between(hole,canonical,tuple_index))\n                continue;\n            tuples[hole]=tuples[tuple_index];\n            tuples[tuple_index].used=false;\n            hole=tuple_index;\n        }\n\n    }\n\n    template<typename K>\n    Tuple operator[](K key)\n    {\n        size_t index=index_of_key(key);\n        if(!tuples[index].used)\n            throw NoSuchKeyException();\n        return tuples[index];\n    } \n\n    int size()\n    {\n        return sizes;\n    }\n};",
            1595150192.360289,
            100,
            "# 答案正确"
        ],
        [
            "A.5 (C++)",
            "潘小健",
            "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass NoSuchKeyException{};\n\nclass HT\n{\n    class Tuple\n    {\n    public:\n        string key1;\n        int key2;\n        string val1;\n        int val2;\n        bool used;\n\n        Tuple():used(false){}\n\n        operator int()\n        {\n            return val2;\n        }\n\n        operator string()\n        {\n            return val1;\n        }\n\n        void operator=(string val)\n        {\n            if(used==false)\n                used=true;\n            val1=val;\n        }\n\n        void operator=(int val)\n        {\n            if(used==false)\n                used=true;\n            val2=val;\n        }\n    };\n\n    vector<Tuple> tuples;\n    int sizes;\n\n    size_t _hash_function(const int& key)\n    {\n        size_t code=key;\n        for (int i = 0; i < 20; ++i)\n        {\n            code=((code*i+7)*code)^(code+3);\n        }\n        return code;\n    }\n\n    size_t _hash_function(const string& key)\n    {\n        size_t code=0;\n        for (int i = 0; i < (int)key.size(); ++i)\n        {\n            code^=_hash_function((int)key[i]);\n        }\n        return code;\n    }\n\n    inline bool _match(Tuple& tuple,int key)\n    {\n        return tuple.key2==key;\n    }\n\n    inline bool _match(Tuple& tuple,string key)\n    {\n        return tuple.key1==key;\n    }\n\n    template<typename K>\n    size_t _canonical_index(const K& key)\n    {\n        size_t hash_code=_hash_function(key);\n        return hash_code%tuples.size();\n    }\n\n    bool _between(size_t a,size_t b,size_t c)\n    {\n        if(a<c)\n            return b>a&&b<=c;\n        else\n            return b>a||b<=c;\n    }\npublic:\n    HT():tuples(1000),sizes(0){}\n\n    template<typename K>\n    size_t index_of_key(const K& key)\n    {\n        size_t index=_canonical_index(key);\n        while(true)\n        {\n            if(!tuples[index].used)\n                return index;\n            if(_match(tuples[index],key))\n                return index;\n            index=(index+1)%tuples.size();\n        }\n    }\n\n    void put(int key,int val)\n    {\n        size_t index=index_of_key(key);\n        tuples[index].key2=key;\n        tuples[index].val2=val;\n        if(tuples[index].used==false)\n        {\n            tuples[index].used=true;\n            ++sizes;\n        }\n    }\n\n    void put(int key,string val)\n    {\n        size_t index=index_of_key(key);\n        tuples[index].key2=key;\n        tuples[index].val1=val;\n        if(tuples[index].used==false)\n        {\n            tuples[index].used=true;\n            ++sizes;\n        }\n    }\n    \n    void put(string key,string val)\n    {\n        size_t index=index_of_key(key);\n        tuples[index].key1=key;\n        tuples[index].val1=val;\n        if(tuples[index].used==false)\n        {\n            tuples[index].used=true;\n            ++sizes;\n        }\n    }\n\n    void put(string key,int val)\n    {\n        size_t index=index_of_key(key);\n        tuples[index].key1=key;\n        tuples[index].val2=val;\n        if(tuples[index].used==false)\n        {\n            tuples[index].used=true;\n            ++sizes;\n        }\n    }\n\n    template<typename K>\n    void remove(K key)\n    {\n        size_t index=index_of_key(key);\n        if(!tuples[index].used)\n            throw NoSuchKeyException();\n        tuples[index].used=false;\n        --sizes;\n\n        size_t hole=index;\n        size_t tuple_index;\n        while(true)\n        {\n            tuple_index=(tuple_index+1)%tuples.size();\n            if(!tuples[tuple_index].used)\n                return;\n            size_t canonical=_canonical_index(tuples[tuple_index]);\n            if(_between(hole,canonical,tuple_index))\n                continue;\n            tuples[hole]=tuples[tuple_index];\n            tuples[tuple_index].used=false;\n            hole=tuple_index;\n        }\n\n    }\n\n    Tuple& operator[](string key)\n    {\n        size_t index=index_of_key(key);\n        if(!tuples[index].used)\n        {\n            tuples[index].key1=key;\n            ++sizes;\n        }\n        return tuples[index];\n    } \n\n    Tuple& operator[](int key)\n    {\n        size_t index=index_of_key(key);\n        if(!tuples[index].used)\n        {\n            tuples[index].key2=key;\n            ++sizes;\n        }\n        return tuples[index];\n    } \n\n    int size()\n    {\n        return sizes;\n    }\n};",
            1595183218.6301959,
            100,
            "# 答案正确"
        ],
        [
            "A.3 (C++)",
            "潘小健",
            "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <stdexcept>\nusing namespace std;\n\n#define I(i,n) for (size_t i = 0; i < n; ++ i)\n\nclass NoSuchKeyException {};\n\nsize_t circular_shift(size_t bits, int shift_bits) {\n\tconst int num_bits = 8 * sizeof(size_t);\n\tshift_bits = shift_bits % num_bits;\n\treturn bits << shift_bits | bits >> (num_bits - shift_bits);\n}\n\nsize_t hash_function(const int& key)\n{\n    size_t code=key;\n    for (int i = 0; i < 20; ++i)\n    {\n        code=((code*i+7)*code)^(code+3);\n    }\n    return code;\n}\n\ntemplate <typename V>\nclass HT\n{\n\tclass Tuple\n\t{\n\tpublic:\n\t\tint key;\n\t\tV val;\n\t\tbool in_use;\n\n\t\tTuple() : in_use(false) {}\n\t};\n\n\tvector<Tuple> tuples;\n\tsize_t _size;\n\n\tsize_t canonical_index(const int& key) const {\n\t\tsize_t hash_code = hash_function(key); // needs hash_function(K)\n\t\treturn hash_code % tuples.size();\n\t}\n\n\t// the returned tuple is either empty or with the same key\n\tsize_t indexOfKey(const int& key) const {\n\t\tsize_t index = canonical_index(key);\n\t\twhile (true) { // will enter a dead loop if there is not empty tuple\n\t\t\tif (! tuples[index].in_use) return index;\n\t\t\tif (tuples[index].key == key) return index;\n\t\t\tindex = (index + 1) % tuples.size();\n\t\t}\n\t}\n\npublic:\n\tHT() : _size(0) {\n\t\ttuples.resize(2);\n\t}\n\n\tbool containsKey(const int& key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\treturn tuples[index].in_use;\n\t}\n\n\tconst V & operator [] (const int& key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples[index].val;\n\t}\n\n\tV & operator [] (int& key) {\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples[index].val;\n\t}\n\n\tvoid put(const int & key, const V & val) {\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].key = key;\n\t\ttuples[index].val = val;\n\t\tif (tuples[index].in_use) return;\n\t\ttuples[index].in_use = true;\n\t\t++ _size;\n\t\t// make sure empty > size / 2\n\t\tif (2 * _size > tuples.size())\n\t\t\t_double_tuples();\n\t}\n\n\tvoid _double_tuples() {\n\t\tvector<Tuple> non_empty_tuples;\n\t\tI(i, tuples.size())\n\t\t\tif (tuples[i].in_use)\n\t\t\t\tnon_empty_tuples.push_back(tuples[i]);\n\t\tclear();\n\t\ttuples.resize(tuples.size() * 2);\n\t\tI(i, non_empty_tuples.size())\n\t\t\tput(non_empty_tuples[i].key, non_empty_tuples[i].val);\n\t}\n\n\tstatic bool _between(size_t hole, size_t canonical, size_t tuple_index) {\n\t\tif (hole < tuple_index)\n\t\t\treturn canonical > hole && canonical <= tuple_index;\n\t\telse\n\t\t\treturn canonical > hole || canonical <= tuple_index;\n\t}\n\n\tvoid remove(const int & key) { \n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\ttuples[index].in_use = false;\n\t\t-- _size;\n\t\t// if there is a hole between a tuple and its canonical position\n\t\t// move the tuple to the hole\n\t\tsize_t hole = index;\n\t\tsize_t tuple_index = hole;\n\t\twhile (true) {\n\t\t\ttuple_index = (tuple_index + 1) % tuples.size();\n\t\t\tif (! tuples[tuple_index].in_use) return;\n\t\t\tsize_t canonical = canonical_index(tuples[tuple_index].key);\n\t\t\tif (_between(hole, canonical, tuple_index)) continue;\n\t\t\ttuples[hole] = tuples[tuple_index];\n\t\t\thole = tuple_index;\n\t\t\ttuples[hole].in_use = false;\n\t\t}\n\t}\n\n\tsize_t size() const { return _size; }\n\n\tvoid clear() {\n\t\tI(i, tuples.size())\n\t\t\ttuples[i].in_use = false;\n\t\t_size = 0;\n\t}\n    \n    vector<int> getKeys()\n    {\n        vector<int> tmp;\n        for (auto i:tuples)\n        {\n            if(i.in_use)\n                tmp.push_back(i.key);\n        }\n        return tmp;\n    }\t\n};\n",
            1595470888.7885387,
            100,
            "# 答案正确"
        ]
    ],
    "table_name": "答案"
}