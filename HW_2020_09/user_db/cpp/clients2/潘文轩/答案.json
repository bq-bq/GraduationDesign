{
    "__update_time__": 1595474724.5613322,
    "field_names": [
        "题目名",
        "用户名",
        "答案",
        "提交时间",
        "分数",
        "评语"
    ],
    "field_types": [
        "text",
        "text",
        "text",
        "time",
        "number",
        "text"
    ],
    "foreign_keys": {},
    "primary_keys": [],
    "rows": [
        [
            "测试1",
            "潘文轩",
            "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint main() {\n\tchar word[10], words[10][10];\n\tint n = 0;\n\twhile(cin >> word) {\n\t\tmemcpy(words[n], word, sizeof(word));\n\t\tn ++;\n\t}\n\tfor(int i = n - 1; i >= 0; i --) {\n\t\tcout << words[i];\n\t\tif(i != 0) cout << ' ';\n\t}\n\treturn 0;\n}",
            1587609462.8875504,
            100,
            "# 答案正确"
        ],
        [
            "测试2",
            "潘文轩",
            "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nchar words[10][20];\n\nvoid swap1(char * a, char * b) {\n    char temp[20];\n    memcpy(temp, a, sizeof(a));\n    memcpy(a, b, sizeof(a));\n    memcpy(b, temp, sizeof(temp));\n}\n\nbool compare(char * a, char * b) {\n    int len_a = strlen(a);\n    int len_b = strlen(b);\n    if(len_a != len_b) {\n        return len_a < len_b;\n    }\n    int n = 0;\n    while(n < len_a) {\n        if(a[n] != b[n]) return a[n] < b[n];\n        n ++;\n    }\n    return false;\n}\n\nint main() {\n    memset(words, 0, sizeof(words));\n    char word[20];\n    int n = 0;\n    while(cin >> word) {\n        memcpy(words[n ++], word, sizeof(word));\n    }\n    for(int i = 0; i < n; i ++) {\n        char * min = words[i], * now = words[i];\n        for(int j = i + 1; j < n; j ++) {\n            if(compare(words[j], min)) {\n                min = words[j];\n            }\n        }\n        swap1(now, min);\n    }\n    for(int i = 0; i < n; i ++) {\n        cout << words[i];\n        if(i != n - 1) cout << ' ';\n    }\n    cout << endl;\n\treturn 0;\n}",
            1587612319.5314946,
            100,
            "# 答案正确"
        ],
        [
            "1.1 (C++)",
            "潘文轩",
            "#include <cstring>\n\nclass Matrix5x5 {\npublic:\n\tdouble m[5][5];\n    double get(int, int);\n    void set(int, int, double);\n\tMatrix5x5() {\n\t\tmemset(m, 0, sizeof(m));\n\t}\n};\n\ndouble Matrix5x5::get(int r, int c) {\n\treturn m[r][c];\n}\n\nvoid Matrix5x5::set(int r, int c, double value) {\n\tm[r][c] = value;\n}\n\nMatrix5x5 operator + (Matrix5x5 & m1, Matrix5x5 & m2) {\n\tMatrix5x5 res;\n\tfor(int i = 0; i < 5; i ++) {\n\t\tfor(int j = 0; j < 5; j ++) {\n\t\t\tres.m[i][j] = m1.m[i][j] + m2.m[i][j];\n\t\t}\n\t}\n\treturn res;\n}",
            1587697823.3955503,
            100,
            "# 答案正确"
        ],
        [
            "1.2 (C++)",
            "潘文轩",
            "#include <cstring>\n#include <iostream>\nusing namespace std;\n\nclass School {\npublic:\n\tchar name[20];\n\tint age;\n\t\n\tvoid setName(char[]);\n\tvoid setAge(int);\n\tvoid print();\n\tSchool() {\n\t\tmemcpy(name, \"NO_NAME\", 8);\n\t}\n\tvoid operator ++ (){\n\t\tage ++;\n\t}\n};\n\nvoid School::setName(char Name[]) {\n\tmemcpy(name, Name, strlen(Name) + 1);\n}\n\nvoid School::setAge(int Age) {\n\tage = Age;\n}\n",
            1588216688.8776782,
            100,
            "# 答案正确"
        ],
        [
            "2.1 (C++)",
            "潘文轩",
            "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nclass Matrix {\nprivate:\n    int row, columns;\n    double * values;\npublic:\n    Matrix(int row, int columns) {\n        this -> row = row;\n        this -> columns = columns;\n        values = (double *) new double[row * columns];\n        memset(values, 0, sizeof(double) * row * columns);\n    }\n    ~Matrix() {\n        delete[] values;\n    }\n    void print() {\n        for(int i = 0; i < row; i ++) {\n            for(int j = 0; j < columns; j ++) {\n                cout << \"    \" << values[i * row + columns];\n            }\n            cout << endl;\n        }\n    }\n};",
            1588851978.818506,
            100,
            "# 答案正确"
        ],
        [
            "2.2 (C++)",
            "潘文轩",
            "#include <iostream>\n#include <cstring>\n#include <iomanip>\nusing namespace std;\n\nclass Matrix {\nprivate:\n    int rows, columns;\n    double * values;\npublic:\n    Matrix(int row, int columns, double * v) {\n        this -> rows = row;\n        this -> columns = columns;\n        this -> values = (double *) new double[rows * columns];\n        memcpy(this -> values, v, sizeof(double) * rows * columns);\n    }\n    ~Matrix() {\n        delete[] values;\n    }\n    void print() {\n        for(int i = 0; i < rows; i ++) {\n            for(int j = 0; j < columns; j ++) {\n                cout << setw(5) << setfill(' ') << right << values[i * columns + j];\n            }\n        cout << endl;\n        }\n    }\n};",
            1588852616.4284356,
            100,
            "# 答案正确"
        ],
        [
            "2.3 (C++)",
            "潘文轩",
            "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nclass Matrix {\nprivate:\n    int rows, columns;\n    double * values;\npublic:\n    Matrix(int row, int columns, double * v) {\n        this -> rows = row;\n        this -> columns = columns;\n        this -> values = (double *) new double[rows * columns];\n        memcpy(this -> values, v, sizeof(double) * rows * columns);\n    }\n    Matrix(const Matrix & m) {\n        this -> rows = m.rows;\n        this -> columns = m.columns;\n\t\tthis -> values = (double *) new double[rows * columns];\n        memcpy(this -> values, m.values, sizeof(double) * this -> rows * this -> columns);\n    }\n    ~Matrix() {\n        delete[] values;\n    }\n    void print() {\n        for(int i = 0; i < rows; i ++) {\n            for(int j = 0; j < columns; j ++) {\n                cout << \"    \" << values[i * columns + j];\n            }\n            cout << endl;\n        }\n    }\n};",
            1588853238.2993143,
            100,
            "# 答案正确"
        ],
        [
            "2.5 (C++)",
            "潘文轩",
            "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nclass Matrix {\nprivate:\n    int rows, columns;\n    double * values;\npublic:\n    Matrix(int r, int c) {\n        this -> rows = r;\n        this -> columns = c;\n        this -> values = (double *) new double[rows * columns];\n        memset(this -> values, 0, sizeof(double) * r * c);\n    }\n    Matrix(int row, int columns, double * v) {\n        this -> rows = row;\n        this -> columns = columns;\n        this -> values = (double *) new double[rows * columns];\n        memcpy(this -> values, v, sizeof(double) * rows * columns);\n    }\n    Matrix(const Matrix & m) {\n        this -> rows = m.rows;\n        this -> columns = m.columns;\n        memcpy(this -> values, m.values, sizeof(double) * (rows) * (columns));\n    }\n    ~Matrix() {\n        delete[] values;\n    }\n    void print() {\n        for(int i = 0; i < rows; i ++) {\n            for(int j = 0; j < columns; j ++) {\n                cout << \"    \" << values[i * columns + j];\n            }\n            cout << endl;\n        }\n    }\n    Matrix getRow(int r) {\n        Matrix m(1, columns);\n        memcpy(m.values, this -> values + (r - 1) * (columns), sizeof(double) * (this -> columns));\n        return m;\n    }\n    Matrix getColumn(int c) {\n        Matrix m(rows, 1);\n        for(int i = 0; i < rows; i ++) {\n            m.values[i] = this -> values[columns * i + c - 1];\n        }\n        return m;\n    }\n};",
            1588855415.8874283,
            100,
            "# 答案正确"
        ],
        [
            "2.6 (C++)",
            "潘文轩",
            "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nclass Matrix {\nprivate:\n    int rows, columns;\n    double * values;\npublic:\n    Matrix(int r, int c) {\n        this -> rows = r;\n        this -> columns = c;\n        this -> values = (double *) new double[rows * columns];\n        memset(this -> values, 0, sizeof(double) * r * c);\n    }\n    Matrix(int row, int columns, double * v) {\n        this -> rows = row;\n        this -> columns = columns;\n        this -> values = (double *) new double[rows * columns];\n        memcpy(this -> values, v, sizeof(double) * rows * columns);\n    }\n    Matrix(const Matrix & m) {\n        this -> rows = m.rows;\n        this -> columns = m.columns;\n        memcpy(this -> values, m.values, sizeof(double) * (rows) * (columns));\n    }\n    ~Matrix() {\n        delete[] values;\n    }\n    void print() {\n        for(int i = 0; i < rows; i ++) {\n            for(int j = 0; j < columns; j ++) {\n                cout << \"    \" << values[i * columns + j];\n            }\n            cout << endl;\n        }\n    }\n    Matrix concatenateRows(const Matrix & matrix2) const {\n        Matrix m(rows + matrix2.rows, columns);\n        m.values = (double *) new double[m.rows * m.columns];\n        memcpy(m.values, values, sizeof(double) * rows * columns);\n        memcpy(m.values + rows * columns, matrix2.values, sizeof(double) * matrix2.rows * matrix2.columns);\n        return m;\n    }\n    Matrix concatenateColumns(const Matrix & matrix2) const {\n        Matrix m(rows, columns + matrix2.columns);\n        m.values = (double *) new double[m.rows * m.columns];\n        for(int i = 0; i < rows; i ++) {\n            memcpy(m.values + i * m.columns, values + i * columns, sizeof(double) * columns);\n            memcpy(m.values + i * m.columns + columns,\n            matrix2.values + i * matrix2.columns, sizeof(double) * matrix2.columns);\n        }\n        return m;\n    }\n};",
            1588856272.9556487,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/08",
            "潘文轩",
            "double & Tensor_get(int dimensions, const int sizes[], double data[], int x0, int x1, int x2, int x3) {\n\tint pos = x0;\n\tif(dimensions == 2) pos = x1 + x0 * sizes[1];\n\telse if(dimensions == 3) pos = x2 + x1 * sizes[1] + x0 * sizes[1] * sizes[2];\n\telse if(dimensions == 4) pos = x3 + x2 * sizes[1] + x1 * sizes[1] * sizes[2] + x0 * sizes[1] * sizes[2] * sizes[3];\n\treturn data[pos];\n}",
            1588906451.2307854,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/14",
            "潘文轩",
            "#include <iostream>\nusing namespace std;\n\nvoid print_one_dim(int dimensions, const int sizes[], const double data[], int begin) {\n\tif(dimensions == 1) {\n\t\tfor(int i = 0; i < sizes[0]; i ++) {\n\t\t\tcout << data[i + begin] << endl;\n\t\t}\n\t}\n\telse {\n\t\tfor(int i = 0; i < sizes[dimensions - 1]; i ++) {\n\t\t\tcout << \"    \" << data[i + begin];\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nvoid print_two_dim(int dimensions, const int sizes[], const double data[], int begin) {\n\tfor(int i = 0; i < sizes[dimensions - 2]; i ++) {\n\t\tprint_one_dim(dimensions, sizes, data, i * sizes[dimensions - 1]);\n\t}\n}\n\nvoid print_three_dim(int dimensions, const int sizes[], const double data[], int begin) {\n\tfor(int i = 0; i < sizes[dimensions - 3]; i ++) {\n\t\tcout << \"data[\" << i << \"]\" << endl;\n\t\tprint_two_dim(dimensions, sizes, data, i * sizes[dimensions - 1] * sizes[dimensions - 2]);\n\t}\n}\n\nvoid print_four_dim(int dimensions, const int sizes[], const double data[], int begin) {\n\tfor(int i = 0; i < sizes[dimensions - 4]; i ++) {\n\t\tfor(int j = 0; j < sizes[dimensions - 3]; j ++) {\n\t\t\tcout << \"data[\" << i << \"][\" << j << \"]\" << endl;\n \t\t\tprint_two_dim(dimensions, sizes, data, i * sizes[dimensions - 1] * sizes[dimensions - 2] * sizes[dimensions - 3] + j * sizes[dimensions - 1] * sizes[dimensions - 2]);\n\t\t}\n\t}\n}\n\nvoid Tensor_print(int dimensions, const int sizes[], const double data[]) {\n\tif(dimensions == 1) {\n\t\tcout << \"Tensor of \" << sizes[0] << endl;\n\t\tprint_one_dim(dimensions, sizes, data, 0);\n\t}\n\telse if(dimensions == 2) {\n\t\tcout << \"Tensor of \" << sizes[0] << \"x\" << sizes[1] << endl;\n\t\tprint_two_dim(dimensions, sizes, data, 0);\n\t}\n\telse if(dimensions == 3) {\n\t\tcout << \"Tensor of \" << sizes[0] << \"x\" << sizes[1] << \"x\" << sizes[2] << endl;\n\t\tprint_three_dim(dimensions, sizes, data, 0);\n\t}\n\telse {\n\t\tcout << \"Tensor of \" << sizes[0] << \"x\" << sizes[1] << \"x\" << sizes[2] << \"x\" << sizes[3] << endl;\n\t\tprint_four_dim(dimensions, sizes, data, 0);\n\t}\n}",
            1589424809.62111,
            100,
            "# 答案正确"
        ],
        [
            "2.4 (C++)",
            "潘文轩",
            "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nclass Matrix{\nprivate:\n\tint rows, columns;\n\tdouble * values;\npublic:\n\tMatrix(int r, int c) {\n\t\trows = r, columns = c;\n\t\tif(r == 0 || c == 0) {\n\t\t\tvalues = NULL;\n\t\t}\n\t\telse {\n\t\t\tvalues = new double[r * c];\n\t\t\tmemset(values, 0, sizeof(double) * r * c);\n\t\t}\n\t}\n\tMatrix(int r, int c, double * v) {\n\t\trows = r, columns = c;\n\t\tvalues = new double[r * c];\n\t\tmemcpy(values, v, sizeof(double) * r * c);\n\t}\n\t~Matrix() {\n\t\tdelete[] values;\n\t}\n\tvoid print() {\n\t\tfor(int r = 0; r < rows; r ++) {\n\t\t\tfor(int c = 0; c < columns; c ++) {\n\t\t\t\tcout << \"    \" << values[r * columns + c];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tvoid set(int r, int c, double v) {\n\t\tvalues[(r - 1) * columns + c - 1] = v;\n\t}\n\tMatrix & operator = (const Matrix & m1) {\n\t\trows = m1.rows;\n\t\tcolumns = m1.columns;\n\t\tif(values != NULL) delete[] values;\n\t\tvalues = new double[m1.rows * m1.columns];\n\t\tmemcpy(values, m1.values, sizeof(double) * rows * columns);\n\t\treturn *this;\n\t}\n};",
            1589529681.409348,
            100,
            "# 答案正确"
        ],
        [
            "2.7 (C++)",
            "潘文轩",
            "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nclass Matrix{\nprivate:\n\tint rows, columns;\n\tdouble * values;\npublic:\n\tMatrix() {}\n\tMatrix(int r, int c) {\n\t\trows = r, columns = c;\n\t\tif(r == 0 || c == 0) {\n\t\t\tvalues = NULL;\n\t\t}\n\t\telse {values = new double[r * c];\n\t\t\tmemset(values, 0, sizeof(double) * r * c);\n\t\t}\n\t}\n\tMatrix(int r, int c, double * v) {\n\t\trows = r, columns = c;\n\t\tvalues = new double[r * c];\n\t\tmemcpy(values, v, sizeof(double) * r * c);\n\t}\n\tMatrix(const Matrix & m) {\n\t\trows = m.rows, columns = m.columns;\n\t\tvalues = new double[rows * columns];\n\t\tmemcpy(values, m.values, sizeof(double) * rows * columns);\n\t}\n\t~Matrix() {\n\t\tdelete[] values;\n\t}\n\tvoid print() {\n\t\tfor(int r = 0; r < rows; r ++) {\n\t\t\tfor(int c = 0; c < columns; c ++) {\n\t\t\t\tcout << \"    \" << values[r * columns + c];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tvoid set(int r, int c, double v) {\n\t\tvalues[(r - 1) * columns + c - 1] = v;\n\t}\n\tMatrix & operator = (const Matrix & m1) {\n\t\trows = m1.rows;\n\t\tcolumns = m1.columns;\n\t\tif(values != NULL) delete[] values;\n\t\tvalues = new double[m1.rows * m1.columns];\n\t\tmemcpy(values, m1.values, sizeof(double) * rows * columns);\n\t\treturn *this;\n\t}\n\tMatrix reshape(int r, int c) const{\n\t\tMatrix m(r, c, this -> values);\n\t\tint count = 0, cycle = 0;\n\t\tfor(int i = 0; i < this -> columns; i ++) {\n\t\t\tfor(int j = 0; j < this -> rows; j ++) {\n\t\t\t\tm.values[cycle + (m.columns * count ++)] = this -> values[i + columns * j];\n\t\t\t\tif(count >= m.rows) {\n\t\t\t\t\tcount = 0;\n\t\t\t\t\tcycle ++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn m;\n\t}\n};",
            1589769025.0165877,
            100,
            "# 答案正确"
        ],
        [
            "2.8 (C++)",
            "潘文轩",
            "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nclass Matrix{\nprivate:\n\tint rows, columns;\n\tdouble * values;\npublic:\n\tMatrix() {}\n\tMatrix(int r, int c) {\n\t\trows = r, columns = c;\n\t\tif(r == 0 || c == 0) {\n\t\t\tvalues = NULL;\n\t\t}\n\t\telse {values = new double[r * c];\n\t\t\tmemset(values, 0, sizeof(double) * r * c);\n\t\t}\n\t}\n\tMatrix(int r, int c, double * v) {\n\t\trows = r, columns = c;\n\t\tvalues = new double[r * c];\n\t\tmemcpy(values, v, sizeof(double) * r * c);\n\t}\n\tMatrix(const Matrix & m) {\n\t\trows = m.rows, columns = m.columns;\n\t\tvalues = new double[rows * columns];\n\t\tmemcpy(values, m.values, sizeof(double) * rows * columns);\n\t}\n\t~Matrix() {\n\t\tdelete[] values;\n\t}\n\tvoid print() {\n\t\tfor(int r = 0; r < rows; r ++) {\n\t\t\tfor(int c = 0; c < columns; c ++) {\n\t\t\t\tcout << \"    \" << values[r * columns + c];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tvoid set(int r, int c, double v) {\n\t\tvalues[(r - 1) * columns + c - 1] = v;\n\t}\n\tMatrix & operator = (const Matrix & m1) {\n\t\trows = m1.rows;\n\t\tcolumns = m1.columns;\n\t\tif(values != NULL) delete[] values;\n\t\tvalues = new double[m1.rows * m1.columns];\n\t\tmemcpy(values, m1.values, sizeof(double) * rows * columns);\n\t\treturn *this;\n\t}\n\tMatrix reshape(int r, int c) const{\n\t\tMatrix m(r, c, this -> values);\n\t\tint count = 0, cycle = 0;\n\t\tfor(int i = 0; i < this -> columns; i ++) {\n\t\t\tfor(int j = 0; j < this -> rows; j ++) {\n\t\t\t\tm.values[cycle + (m.columns * count ++)] = this -> values[i + columns * j];\n\t\t\t\tif(count >= m.rows) {\n\t\t\t\t\tcount = 0;\n\t\t\t\t\tcycle ++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn m;\n\t}\n\tMatrix transpose() {\n\t\tint new_rows = columns, new_columns = rows;\n\t\tint count = 0;\n\t\tdouble new_values[rows * columns];\n\t\tfor(int i = 0; i < columns; i ++) {\n\t\t\tfor(int j = 0; j < rows; j ++) {\n\t\t\t\tnew_values[count ++] = this -> values[i + columns * j];\n\t\t\t}\n\t\t}\n\t\tmemcpy(values, new_values, sizeof(double) * rows * columns);\n\t\trows = new_rows, columns = new_columns;\n\t\treturn *this;\n\t}\n};",
            1589769408.1155543,
            100,
            "# 答案正确"
        ],
        [
            "2.10 (C++)",
            "潘文轩",
            "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nclass Matrix{\nprivate:\n\tint rows, columns;\n\tdouble * values;\npublic:\n\tMatrix() {}\n\tMatrix(int r, int c) {\n\t\trows = r, columns = c;\n\t\tif(r == 0 || c == 0) {\n\t\t\tvalues = NULL;\n\t\t}\n\t\telse {values = new double[r * c];\n\t\t\tmemset(values, 0, sizeof(double) * r * c);\n\t\t}\n\t}\n\tMatrix(int r, int c, double * v) {\n\t\trows = r, columns = c;\n\t\tvalues = new double[r * c];\n\t\tmemcpy(values, v, sizeof(double) * r * c);\n\t}\n\tMatrix(const Matrix & m) {\n\t\trows = m.rows, columns = m.columns;\n\t\tvalues = new double[rows * columns];\n\t\tmemcpy(values, m.values, sizeof(double) * rows * columns);\n\t}\n\t~Matrix() {\n\t\tdelete[] values;\n\t}\n\tvoid print() {\n\t\tfor(int r = 0; r < rows; r ++) {\n\t\t\tfor(int c = 0; c < columns; c ++) {\n\t\t\t\tcout << \"    \" << values[r * columns + c];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tvoid set(int r, int c, double v) {\n\t\tvalues[(r - 1) * columns + c - 1] = v;\n\t}\n\tMatrix & operator = (const Matrix & m1) {\n\t\trows = m1.rows;\n\t\tcolumns = m1.columns;\n\t\tif(values != NULL) delete[] values;\n\t\tvalues = new double[m1.rows * m1.columns];\n\t\tmemcpy(values, m1.values, sizeof(double) * rows * columns);\n\t\treturn *this;\n\t}\n\tMatrix reshape(int r, int c) const{\n\t\tMatrix m(r, c, this -> values);\n\t\tint count = 0, cycle = 0;\n\t\tfor(int i = 0; i < this -> columns; i ++) {\n\t\t\tfor(int j = 0; j < this -> rows; j ++) {\n\t\t\t\tm.values[cycle + (m.columns * count ++)] = this -> values[i + columns * j];\n\t\t\t\tif(count >= m.rows) {\n\t\t\t\t\tcount = 0;\n\t\t\t\t\tcycle ++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn m;\n\t}\n\tMatrix transpose() {\n\t\tint new_rows = columns, new_columns = rows;\n\t\tint count = 0;\n\t\tdouble new_values[rows * columns];\n\t\tfor(int i = 0; i < columns; i ++) {\n\t\t\tfor(int j = 0; j < rows; j ++) {\n\t\t\t\tnew_values[count ++] = this -> values[i + columns * j];\n\t\t\t}\n\t\t}\n\t\tmemcpy(values, new_values, sizeof(double) * rows * columns);\n\t\trows = new_rows, columns = new_columns;\n\t\treturn *this;\n\t}\n\tMatrix operator * (const Matrix & m) {\n\t\tMatrix new_m(rows, m.columns);\n\t\tif(columns != m.rows) return new_m;\n\t\tfor(int r = 0; r < new_m.rows; r ++) {\n\t\t\tfor(int c = 0; c < new_m.columns; c ++) {\n\t\t\t\tfor(int k = 0; k < columns; k ++) {\n\t\t\t\t\tnew_m.values[r * new_m.columns + c] += this -> values[r * columns + k] *\n\t\t\t\t\tm.values[k * m.columns + c];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new_m;\n\t}\n\tMatrix operator * (double c) {\n\t\tfor(int i = 0; i < rows * columns; i ++) {\n\t\t\tthis -> values[i] = this -> values[i] * c;\n\t\t}\n\t\treturn *this;\n\t}\n};",
            1589783563.2353625,
            100,
            "# 答案正确"
        ],
        [
            "2.11 (C++)",
            "潘文轩",
            "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nconst int MIN = INT16_MIN;\nconst int MAX = INT16_MAX;\n\nclass Matrix{\nprivate:\n\tint rows, columns;\n\tdouble * values;\npublic:\n\tMatrix() {}\n\tMatrix(int r, int c) {\n\t\trows = r, columns = c;\n\t\tif(r == 0 || c == 0) {\n\t\t\tvalues = NULL;\n\t\t}\n\t\telse {values = new double[r * c];\n\t\t\tmemset(values, 0, sizeof(double) * r * c);\n\t\t}\n\t}\n\tMatrix(int r, int c, double * v) {\n\t\trows = r, columns = c;\n\t\tvalues = new double[r * c];\n\t\tmemcpy(values, v, sizeof(double) * r * c);\n\t}\n\tMatrix(const Matrix & m) {\n\t\trows = m.rows, columns = m.columns;\n\t\tvalues = new double[rows * columns];\n\t\tmemcpy(values, m.values, sizeof(double) * rows * columns);\n\t}\n\t~Matrix() {\n\t\tdelete[] values;\n\t}\n\tvoid print() {\n\t\tfor(int r = 0; r < rows; r ++) {\n\t\t\tfor(int c = 0; c < columns; c ++) {\n\t\t\t\tcout << \"    \" << values[r * columns + c];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tvoid set(int r, int c, double v) {\n\t\tvalues[(r - 1) * columns + c - 1] = v;\n\t}\n\tMatrix & operator = (const Matrix & m1) {\n\t\trows = m1.rows;\n\t\tcolumns = m1.columns;\n\t\tif(values != NULL) delete[] values;\n\t\tvalues = new double[m1.rows * m1.columns];\n\t\tmemcpy(values, m1.values, sizeof(double) * rows * columns);\n\t\treturn *this;\n\t}\n\tMatrix reshape(int r, int c) const{\n\t\tMatrix m(r, c, this -> values);\n\t\tint count = 0, cycle = 0;\n\t\tfor(int i = 0; i < this -> columns; i ++) {\n\t\t\tfor(int j = 0; j < this -> rows; j ++) {\n\t\t\t\tm.values[cycle + (m.columns * count ++)] = this -> values[i + columns * j];\n\t\t\t\tif(count >= m.rows) {\n\t\t\t\t\tcount = 0;\n\t\t\t\t\tcycle ++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn m;\n\t}\n\tMatrix transpose() {\n\t\tint new_rows = columns, new_columns = rows;\n\t\tint count = 0;\n\t\tdouble new_values[rows * columns];\n\t\tfor(int i = 0; i < columns; i ++) {\n\t\t\tfor(int j = 0; j < rows; j ++) {\n\t\t\t\tnew_values[count ++] = this -> values[i + columns * j];\n\t\t\t}\n\t\t}\n\t\tmemcpy(values, new_values, sizeof(double) * rows * columns);\n\t\trows = new_rows, columns = new_columns;\n\t\treturn *this;\n\t}\n\tMatrix operator * (const Matrix & m) {\n\t\tMatrix new_m(rows, m.columns);\n\t\tif(columns != m.rows) return new_m;\n\t\tfor(int r = 0; r < new_m.rows; r ++) {\n\t\t\tfor(int c = 0; c < new_m.columns; c ++) {\n\t\t\t\tfor(int k = 0; k < columns; k ++) {\n\t\t\t\t\tnew_m.values[r * new_m.columns + c] += this -> values[r * columns + k] *\n\t\t\t\t\tm.values[k * m.columns + c];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new_m;\n\t}\n\tMatrix operator * (double c) {\n\t\tfor(int i = 0; i < rows * columns; i ++) {\n\t\t\tthis -> values[i] = this -> values[i] * c;\n\t\t}\n\t\treturn *this;\n\t}\n\tMatrix max() const{\n\t\tif(rows == 1) {\n\t\t\tint max = MIN;\n\t\t\tMatrix m(1, 1);\n\t\t\tfor(int i = 0; i < columns; i ++) {\n\t\t\t\tif(values[i] > max) max = values[i];\n\t\t\t}\n\t\t\tm.values[0] = max;\n\t\t\treturn m;\n\t\t}\n\t\tMatrix m(1, this -> columns);\n\t\tfor(int i = 0; i < columns; i ++) {\n\t\t\tint max = MIN;\n\t\t\tfor(int j = 0; j < rows; j ++) {\n\t\t\t\tif(values[i + columns * j] > max) max = values[i + columns * j];\n\t\t\t}\n\t\t\tm.values[i] = max;\n\t\t}\n\t\treturn m;\n\t}\n\tMatrix min() const{\n\t\tif(rows == 1) {\n\t\t\tint min = MAX;\n\t\t\tMatrix m(1, 1);\n\t\t\tfor(int i = 0; i < columns; i ++) {\n\t\t\t\tif(values[i] < min) min = values[i];\n\t\t\t}\n\t\t\tm.values[0] = min;\n\t\t\treturn m;\n\t\t}\n\t\tMatrix m(1, this -> columns);\n\t\tfor(int i = 0; i < columns; i ++) {\n\t\t\tint min = MAX;\n\t\t\tfor(int j = 0; j < rows; j ++) {\n\t\t\t\tif(values[i + columns * j] < min) min = values[i + columns * j];\n\t\t\t}\n\t\t\tm.values[i] = min;\n\t\t}\n\t\treturn m;\n\t}\n\tMatrix sum() const{\n\t\tif(rows == 1) {\n\t\t\tMatrix m(1, 1);\n\t\t\tfor(int i = 0; i < columns; i ++) {\n\t\t\t\tm.values[0] += values[i];\n\t\t\t}\n\t\t\treturn m;\n\t\t}\n\t\tMatrix m(1, this -> columns);\n\t\tfor(int i = 0; i < columns; i ++) {\n\t\t\tdouble sum = 0;\n\t\t\tfor(int j = 0; j < rows; j ++) {\n\t\t\t\tsum += values[i + columns * j];\n\t\t\t}\n\t\t\tm.values[i] = sum;\n\t\t}\n\t\treturn m;\n\t}\n};",
            1589784778.9784498,
            100,
            "# 答案正确"
        ],
        [
            "2.12 (C++)",
            "潘文轩",
            "#include <iostream>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nconst int MIN = INT16_MIN;\nconst int MAX = INT16_MAX;\n\nclass Matrix{\nprivate:\n\tint rows, columns;\n\tdouble * values;\npublic:\n\tMatrix() {}\n\tMatrix(int r, int c) {\n\t\trows = r, columns = c;\n\t\tif(r == 0 || c == 0) {\n\t\t\tvalues = NULL;\n\t\t}\n\t\telse {values = new double[r * c];\n\t\t\tmemset(values, 0, sizeof(double) * r * c);\n\t\t}\n\t}\n\tMatrix(int r, int c, double * v) {\n\t\trows = r, columns = c;\n\t\tvalues = new double[r * c];\n\t\tmemcpy(values, v, sizeof(double) * r * c);\n\t}\n\tMatrix(const Matrix & m) {\n\t\trows = m.rows, columns = m.columns;\n\t\tvalues = new double[rows * columns];\n\t\tmemcpy(values, m.values, sizeof(double) * rows * columns);\n\t}\n\t~Matrix() {\n\t\tdelete[] values;\n\t}\n\tvoid print() {\n\t\tfor(int r = 0; r < rows; r ++) {\n\t\t\tfor(int c = 0; c < columns; c ++) {\n\t\t\t\tcout << \"    \" << values[r * columns + c];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tvoid set(int r, int c, double v) {\n\t\tvalues[(r - 1) * columns + c - 1] = v;\n\t}\n\tMatrix & operator = (const Matrix & m1) {\n\t\trows = m1.rows;\n\t\tcolumns = m1.columns;\n\t\tif(values != NULL) delete[] values;\n\t\tvalues = new double[m1.rows * m1.columns];\n\t\tmemcpy(values, m1.values, sizeof(double) * rows * columns);\n\t\treturn *this;\n\t}\n\tMatrix reshape(int r, int c) const{\n\t\tMatrix m(r, c, this -> values);\n\t\tint count = 0, cycle = 0;\n\t\tfor(int i = 0; i < this -> columns; i ++) {\n\t\t\tfor(int j = 0; j < this -> rows; j ++) {\n\t\t\t\tm.values[cycle + (m.columns * count ++)] = this -> values[i + columns * j];\n\t\t\t\tif(count >= m.rows) {\n\t\t\t\t\tcount = 0;\n\t\t\t\t\tcycle ++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn m;\n\t}\n\tMatrix transpose() {\n\t\tint new_rows = columns, new_columns = rows;\n\t\tint count = 0;\n\t\tdouble new_values[rows * columns];\n\t\tfor(int i = 0; i < columns; i ++) {\n\t\t\tfor(int j = 0; j < rows; j ++) {\n\t\t\t\tnew_values[count ++] = this -> values[i + columns * j];\n\t\t\t}\n\t\t}\n\t\tmemcpy(values, new_values, sizeof(double) * rows * columns);\n\t\trows = new_rows, columns = new_columns;\n\t\treturn *this;\n\t}\n\tMatrix operator * (const Matrix & m) {\n\t\tMatrix new_m(rows, m.columns);\n\t\tif(columns != m.rows) return new_m;\n\t\tfor(int r = 0; r < new_m.rows; r ++) {\n\t\t\tfor(int c = 0; c < new_m.columns; c ++) {\n\t\t\t\tfor(int k = 0; k < columns; k ++) {\n\t\t\t\t\tnew_m.values[r * new_m.columns + c] += this -> values[r * columns + k] *\n\t\t\t\t\tm.values[k * m.columns + c];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new_m;\n\t}\n\tMatrix operator * (double c) {\n\t\tfor(int i = 0; i < rows * columns; i ++) {\n\t\t\tthis -> values[i] = this -> values[i] * c;\n\t\t}\n\t\treturn *this;\n\t}\n\tMatrix max() const{\n\t\tif(rows == 1) {\n\t\t\tint max = MIN;\n\t\t\tMatrix m(1, 1);\n\t\t\tfor(int i = 0; i < columns; i ++) {\n\t\t\t\tif(values[i] > max) max = values[i];\n\t\t\t}\n\t\t\tm.values[0] = max;\n\t\t\treturn m;\n\t\t}\n\t\tMatrix m(1, this -> columns);\n\t\tfor(int i = 0; i < columns; i ++) {\n\t\t\tint max = MIN;\n\t\t\tfor(int j = 0; j < rows; j ++) {\n\t\t\t\tif(values[i + columns * j] > max) max = values[i + columns * j];\n\t\t\t}\n\t\t\tm.values[i] = max;\n\t\t}\n\t\treturn m;\n\t}\n\tMatrix min() const{\n\t\tif(rows == 1) {\n\t\t\tint min = MAX;\n\t\t\tMatrix m(1, 1);\n\t\t\tfor(int i = 0; i < columns; i ++) {\n\t\t\t\tif(values[i] < min) min = values[i];\n\t\t\t}\n\t\t\tm.values[0] = min;\n\t\t\treturn m;\n\t\t}\n\t\tMatrix m(1, this -> columns);\n\t\tfor(int i = 0; i < columns; i ++) {\n\t\t\tint min = MAX;\n\t\t\tfor(int j = 0; j < rows; j ++) {\n\t\t\t\tif(values[i + columns * j] < min) min = values[i + columns * j];\n\t\t\t}\n\t\t\tm.values[i] = min;\n\t\t}\n\t\treturn m;\n\t}\n\tMatrix sum() const{\n\t\tif(rows == 1) {\n\t\t\tMatrix m(1, 1);\n\t\t\tfor(int i = 0; i < columns; i ++) {\n\t\t\t\tm.values[0] += values[i];\n\t\t\t}\n\t\t\treturn m;\n\t\t}\n\t\tMatrix m(1, this -> columns);\n\t\tfor(int i = 0; i < columns; i ++) {\n\t\t\tdouble sum = 0;\n\t\t\tfor(int j = 0; j < rows; j ++) {\n\t\t\t\tsum += values[i + columns * j];\n\t\t\t}\n\t\t\tm.values[i] = sum;\n\t\t}\n\t\treturn m;\n\t}\n\tMatrix pow(double exponent) {\n\t\tMatrix m(rows, columns);\n\t\tfor(int r = 0; r < rows; r ++) {\n\t\t\tfor(int c = 0; c < columns; c ++) {\n\t\t\t\tm.values[c + r * columns] = std::pow(values[c + r * columns], exponent);\n\t\t\t}\n\t\t}\n\t\treturn m;\n\t}\n\tMatrix exp() {\n\t\tMatrix m(rows, columns);\n\t\tfor(int r = 0; r < rows; r ++) {\n\t\t\tfor(int c = 0; c < columns; c ++) {\n\t\t\t\tm.values[c + r * columns] = std::exp(values[c + r * columns]);\n\t\t\t}\n\t\t}\n\t\treturn m;\n\t}\n\tMatrix log() {\n\t\tMatrix m(rows, columns);\n\t\tfor(int r = 0; r < rows; r ++) {\n\t\t\tfor(int c = 0; c < columns; c ++) {\n\t\t\t\tm.values[c + r * columns] = std::log(values[c + r * columns]);\n\t\t\t}\n\t\t}\n\t\treturn m;\n\t}\n\tMatrix abs() {\n\t\tMatrix m(rows, columns);\n\t\tfor(int r = 0; r < rows; r ++) {\n\t\t\tfor(int c = 0; c < columns; c ++) {\n\t\t\t\tm.values[c + r * columns] = values[c + r * columns] > 0 ?\n\t\t\t\tvalues[c + r * columns] : - values[c + r * columns];\n\t\t\t}\n\t\t}\n\t\treturn m;\n\t}\n};",
            1589786416.1994941,
            100,
            "# 答案正确"
        ],
        [
            "2.9 (C++)",
            "潘文轩",
            "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nconst int MIN = INT16_MIN;\nconst int MAX = INT16_MAX;\n\nclass Matrix{\nprivate:\n\tint rows, columns;\n\tdouble * values;\npublic:\n\tMatrix() {}\n\tMatrix(int r, int c) {\n\t\trows = r, columns = c;\n\t\tif(r == 0 || c == 0) {\n\t\t\tvalues = NULL;\n\t\t}\n\t\telse {values = new double[r * c];\n\t\t\tmemset(values, 0, sizeof(double) * r * c);\n\t\t}\n\t}\n\tMatrix(int r, int c, double * v) {\n\t\trows = r, columns = c;\n\t\tvalues = new double[r * c];\n\t\tmemcpy(values, v, sizeof(double) * r * c);\n\t}\n\tMatrix(const Matrix & m) {\n\t\trows = m.rows, columns = m.columns;\n\t\tvalues = new double[rows * columns];\n\t\tmemcpy(values, m.values, sizeof(double) * rows * columns);\n\t}\n\t~Matrix() {\n\t\tdelete[] values;\n\t}\n\tvoid print() {\n\t\tfor(int r = 0; r < rows; r ++) {\n\t\t\tfor(int c = 0; c < columns; c ++) {\n\t\t\t\tcout << \"    \" << values[r * columns + c];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tvoid set(int r, int c, double v) {\n\t\tvalues[(r - 1) * columns + c - 1] = v;\n\t}\n\tMatrix & operator = (const Matrix & m1) {\n\t\trows = m1.rows;\n\t\tcolumns = m1.columns;\n\t\tif(values != NULL) delete[] values;\n\t\tvalues = new double[m1.rows * m1.columns];\n\t\tmemcpy(values, m1.values, sizeof(double) * rows * columns);\n\t\treturn *this;\n\t}\n\tMatrix reshape(int r, int c) const{\n\t\tMatrix m(r, c, this -> values);\n\t\tint count = 0, cycle = 0;\n\t\tfor(int i = 0; i < this -> columns; i ++) {\n\t\t\tfor(int j = 0; j < this -> rows; j ++) {\n\t\t\t\tm.values[cycle + (m.columns * count ++)] = this -> values[i + columns * j];\n\t\t\t\tif(count >= m.rows) {\n\t\t\t\t\tcount = 0;\n\t\t\t\t\tcycle ++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn m;\n\t}\n\tMatrix transpose() {\n\t\tint new_rows = columns, new_columns = rows;\n\t\tint count = 0;\n\t\tdouble new_values[rows * columns];\n\t\tfor(int i = 0; i < columns; i ++) {\n\t\t\tfor(int j = 0; j < rows; j ++) {\n\t\t\t\tnew_values[count ++] = this -> values[i + columns * j];\n\t\t\t}\n\t\t}\n\t\tmemcpy(values, new_values, sizeof(double) * rows * columns);\n\t\trows = new_rows, columns = new_columns;\n\t\treturn *this;\n\t}\n\tMatrix operator * (const Matrix & m) {\n\t\tMatrix new_m(rows, m.columns);\n\t\tif(columns != m.rows) return new_m;\n\t\tfor(int r = 0; r < new_m.rows; r ++) {\n\t\t\tfor(int c = 0; c < new_m.columns; c ++) {\n\t\t\t\tfor(int k = 0; k < columns; k ++) {\n\t\t\t\t\tnew_m.values[r * new_m.columns + c] += this -> values[r * columns + k] *\n\t\t\t\t\tm.values[k * m.columns + c];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new_m;\n\t}\n\tMatrix operator * (double c) {\n\t\tfor(int i = 0; i < rows * columns; i ++) {\n\t\t\tthis -> values[i] = this -> values[i] * c;\n\t\t}\n\t\treturn *this;\n\t}\n\tMatrix operator +(const Matrix & m) const {\n\t\tMatrix new_m(rows, columns);\n\t\tint len = rows * columns;\n\t\tfor(int i = 0; i < len; i ++) {\n\t\t\tnew_m.values[i] = this -> values[i] + m.values[i];\n\t\t}\n\t\treturn new_m;\n\t}\n\tMatrix operator +(const double value) const {\n\t\tMatrix new_m(rows, columns);\n\t\tint len = rows * columns;\n\t\tfor(int i = 0; i < len; i ++) {\n\t\t\tnew_m.values[i] = this -> values[i] + value;\n\t\t}\n\t\treturn new_m;\n\t}\n\tMatrix operator -(const Matrix & m) const {\n\t\tMatrix new_m(rows, columns);\n\t\tint len = rows * columns;\n\t\tfor(int i = 0; i < len; i ++) {\n\t\t\tnew_m.values[i] = this -> values[i] - m.values[i];\n\t\t}\n\t\treturn new_m;\n\t}\n\tMatrix operator -(const double value) const {\n\t\tMatrix new_m(rows, columns);\n\t\tint len = rows * columns;\n\t\tfor(int i = 0; i < len; i ++) {\n\t\t\tnew_m.values[i] = this -> values[i] - value;\n\t\t}\n\t\treturn new_m;\n\t}\n};",
            1590028149.9631732,
            100,
            "# 答案正确"
        ],
        [
            "6.1 (C++)",
            "潘文轩",
            "#include <iostream>\n#include <string>\n#include <typeinfo>\n#include <cstring>\nusing namespace std;\n\nconst int MIN = INT16_MIN;\nconst int MAX = INT16_MAX;\n\ntemplate <typename T>\nclass Matrix{\nprivate:\n\tT * values;\n\tint rows, columns;\npublic:\n\tMatrix() {}\n\tMatrix(int r, int c) {\n\t\trows = r, columns = c;\n\t\tif(r == 0 || c == 0) {\n\t\t\tvalues = NULL;\n\t\t}\n\t\telse {values = new T[r * c];\n\t\t\tmemset(values, 0, sizeof(T) * r * c);\n\t\t}\n\t}\n\tMatrix(int r, int c, const T * v) {\n\t\trows = r, columns = c;\n\t\tvalues = new T[r * c];\n\t\tfor(int i = 0; i < rows * columns; i ++) {\n\t\t\tvalues[i] = v[i];\n\t\t}\n\t}\n\tMatrix(const Matrix & m) {\n\t\trows = m.rows, columns = m.columns;\n\t\tvalues = new T[rows * columns];\n\t\tfor(int i = 0; i < rows * columns; i ++) {\n\t\t\tvalues[i] = m.values[i];\n\t\t}\n\t}\n\t~Matrix() {\n\t\tdelete[] values;\n\t}\n\tvoid print() {\n\t\tfor(int r = 0; r < rows; r ++) {\n\t\t\tfor(int c = 0; c < columns; c ++) {\n\t\t\t\tcout << \"    \" << values[r * columns + c];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tvoid set(int r, int c, T v) {\n\t\tvalues[(r - 1) * columns + c - 1] = v;\n\t}\n\tMatrix & operator = (const Matrix & m1) {\n\t\trows = m1.rows;\n\t\tcolumns = m1.columns;\n\t\tif(values != NULL) delete[] values;\n\t\tvalues = new T[m1.rows * m1.columns];\n\t\t//memcpy(values, m1.values, sizeof(T) * rows * columns);\n\t\tfor(int i = 0; i < rows * columns; i ++) {\n\t\t\tvalues[i] = m1.values[i];\n\t\t}\n\t\treturn *this;\n\t}\n\tT & get(int r, int c) {\n\t\treturn values[(r - 1) * columns + c - 1];\n\t}\n};",
            1590410432.083038,
            100,
            "# 答案正确"
        ],
        [
            "6.3 (C++)",
            "潘文轩",
            "#include <iostream>\n#include <string>\n#include <cstring>\n#include <vector>\nusing namespace std;\n\nconst int MIN = INT16_MIN;\nconst int MAX = INT16_MAX;\nconst int max_size = 64;\n\ntemplate <typename T>\nclass Matrix{\nprivate:\n\tvector<T> values;\n\tint rows, columns;\npublic:\n\tMatrix() {}\n\tMatrix(int r, int c) {\n\t\trows = r, columns = c;\n\t\tvalues.reserve(max_size);\n\t\tvalues.resize(r * c, 0);\n\t}\n\tMatrix(int r, int c, vector<T> v) {\n\t\trows = r, columns = c;\n\t\tvalues.reserve(max_size);\n\t\tvalues.resize(r * c);\n\t\tfor(int i = 0; i < rows * columns; i ++) {\n\t\t\tvalues[i] = v[i];\n\t\t}\n\t}\n\tvoid print() {\n\t\tfor(int r = 0; r < rows; r ++) {\n\t\t\tfor(int c = 0; c < columns; c ++) {\n\t\t\t\tcout << \"    \" << values[r * columns + c];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tT & get(int r, int c) {\n\t\treturn values[(r - 1) * columns + c - 1];\n\t}\n\tMatrix getColumn(int c){\n\t\tvector<T> m(rows);\n\t\tfor (int i = 0; i < rows; ++ i) \n\t\t\tm[i] = values[c-1+i*columns];\n\t\treturn Matrix(rows,1,m);\n\t}\n\tMatrix getRow(int r){\n\t\tvector<T> m(columns);\n\t\tfor (int i = 0; i < columns; ++ i) \n\t\t\tm[i] = values[(r-1)*columns+i];\n\t\treturn Matrix(1,columns,m);\n\t}\n\tMatrix concatenateRows(Matrix & matrix2){\n\t\tvector<T> m((rows+matrix2.rows)*columns);\n\t\tint p = 0;\n\t\tfor (int i = 0; i < rows*columns; ++ i) \n\t\t\tm[i]=values[i];\n\t\tfor (int j = rows*columns; j <rows*columns+matrix2.rows*matrix2.columns ; ++ j) {\n\t\t\tm[j] = matrix2.values[p];\n\t\t\tp++;\n\t\t}\n\t\treturn Matrix(rows+matrix2.rows,columns,m);\n\t}\n\tMatrix concatenateColumns(Matrix & matrix2){\n\t\tvector<T> m(rows*(columns+matrix2.columns));\n\t\tfor (int i = 0; i < rows; ++ i) {\n\t\t\tfor (int j = 0; j < columns; ++ j) {\n\t\t\t\tm[i*(columns+matrix2.columns)+j]=values[i*columns+j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i <matrix2.rows; ++ i) {\n\t\t\tfor (int j = 0; j < matrix2.columns; ++ j) {\n\t\t\t\tm[i*(columns+matrix2.columns)+j+columns]=matrix2.values[i*columns+j];\n\t\t\t}\n\t\t}\n\t\treturn Matrix(rows,columns+matrix2.columns,m);\n\t}\n\tMatrix max() const {\n\t\tif(rows == 1) {\n\t\t\tint max = MIN;\n\t\t\tMatrix m(1, 1);\n\t\t\tfor(int i = 0; i < columns; i ++) {\n\t\t\t\tif(values[i] > max) max = values[i];\n\t\t\t}\n\t\t\tm.values[0] = max/2;\n\t\t\treturn m;\n\t\t}\n\t\tMatrix m(1, this -> columns);\n\t\tfor(int i = 0; i < columns; i ++) {\n\t\t\tint max = MIN;\n\t\t\tfor(int j = 0; j < rows; j ++) {\n\t\t\t\tif(values[i + columns * j] > max) max = values[i + columns * j];\n\t\t\t}\n\t\t\tm.values[i] = max;\n\t\t}\n\t\t\n\t\treturn m;\n\t}\n\tMatrix min() const {\n\t\tif(rows == 1) {\n\t\t\tint min = MAX;\n\t\t\tMatrix m(1, 1);\n\t\t\tfor(int i = 0; i < columns; i ++) {\n\t\t\t\tif(values[i] < min) min = values[i];\n\t\t\t}\n\t\t\tm.values[0] = min/2;\n\t\t\treturn m;\n\t\t}\n\t\tMatrix m(1, this -> columns);\n\t\tfor(int i = 0; i < columns; i ++) {\n\t\t\tint min = MAX;\n\t\t\tfor(int j = 0; j < rows; j ++) {\n\t\t\t\tif(values[i + columns * j] < min) min = values[i + columns * j];\n\t\t\t}\n\t\t\tm.values[i] = min;\n\t\t}\n\t\treturn m;\n\t}\n\tMatrix sum() const {\n\t\tif(rows == 1) {\n\t\t\tMatrix m(1, 1);\n\t\t\tfor(int i = 0; i < columns; i ++) {\n\t\t\t\tm.values[0] += values[i];\n\t\t\t}\n\t\t\treturn m;\n\t\t}\n\t\tMatrix m(1, this -> columns);\n\t\tfor(int i = 0; i < columns; i ++) {\n\t\t\tdouble sum = 0;\n\t\t\tfor(int j = 0; j < rows; j ++) {\n\t\t\t\tsum += values[i + columns * j];\n\t\t\t}\n\t\t\tm.values[i] = sum/2;\n\t\t}\n\t\treturn m;\n\t}\n\t\tMatrix transpose() {\n\t\tint new_rows = columns, new_columns = rows;\n\t\tint count = 0;\n\t\tvector<T> new_values(rows * columns);\n\t\tfor(int i = 0; i < columns; i ++) {\n\t\t\tfor(int j = 0; j < rows; j ++) {\n\t\t\t\tnew_values[count ++] = this -> values[i + columns * j];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < rows * columns; i ++) {\n\t\t\tvalues[i] = new_values[i];\n\t\t}\n\t\trows = new_rows, columns = new_columns;\n\t\treturn *this;\n\t}\n\tMatrix operator * (const Matrix & m) {\n\t\tMatrix m4 = m;\n\t\tm4.transpose();\n\t\tvector<T> pp(rows*m.columns);\n\t\tfor(int r = 0; r < rows; r ++) {\n\t\t\tfor(int c = 0; c < m.columns; c ++) {\n\t\t\t\tfor(int k = 0; k < columns; k ++) {\n\t\t\t\t\tpp[r * m.columns + c] += this -> values[r * columns + k] *\n\t\t\t\t\tm4.values[k * m.columns + c];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn Matrix(rows,m.columns,pp);\n\t}\n\tMatrix operator * (double c) {\n\t\tMatrix m4 (rows,columns,values);\n\t\tm4.transpose();\n\t\tfor(int i = 0; i < rows * columns; i ++) {\n\t\t\tthis -> values[i] = m4.values[i] * c;\n\t\t}\n\t\treturn *this;\n\t}\n\tMatrix operator +(const Matrix & m2) const {\n\t\tMatrix m4 = m2;\n\t\tm4.transpose();\n\t\tvector<T> m(rows*columns);\n\t\tfor (int i = 0; i < rows*columns; ++ i){\n\t\t\tm[i] =m4.values[i] +m4.values[i];\n\t\t} \n\t\treturn Matrix(rows,columns,m);\n\t}\n\tMatrix operator +(const double value) const {\n\t\tMatrix m4 (rows,columns,values);\n\t\tm4.transpose();\n\t\tvector<T> m(rows*columns);\n\t\tfor (int i = 0; i < rows*columns; ++ i){\n\t\t\tm[i] =m4.values[i] +value;\n\t\t} \n\t\treturn Matrix(rows,columns,m);\n\t}\n\tMatrix operator -(const Matrix & m2) const {\n\t\tMatrix m4 = m2;\n\t\tm4.transpose();\n\t\tvector<T> m(rows*columns);\n\t\tfor (int i = 0; i < rows*columns; ++ i){\n\t\t\tm[i] =m4.values[i] - values[i];\n\t\t} \n\t\treturn Matrix(rows,columns,m);\n\t}\n\tMatrix operator -(const double value) const {\n\t\tvector<T> m(rows*columns);\n\t\tfor (int i = 0; i < rows*columns; ++ i){\n\t\t\tm[i] = values[i] - value;\n\t\t} \n\t\treturn Matrix(rows,columns,m);\n\t}\n\tMatrix reshape(int r, int c) const{\n\t\tMatrix m(r, c, this -> values);\n\t\tint count = 0, cycle = 0;\n\t\tfor(int i = 0; i < this -> columns; i ++) {\n\t\t\tfor(int j = 0; j < this -> rows; j ++) {\n\t\t\t\tm.values[cycle + (m.columns * count ++)] = this -> values[i + columns * j];\n\t\t\t\tif(count >= m.rows) {\n\t\t\t\t\tcount = 0;\n\t\t\t\t\tcycle ++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn m;\n\t}\n};",
            1590594757.0767863,
            100,
            "# 答案正确"
        ],
        [
            "6.2 (C++)",
            "潘文轩",
            "#include <iostream>\nusing namespace std;\n\ntemplate <typename T>\nclass Matrix{\nprivate:\n\tT * values;\n\tint rows, columns;\npublic:\n\tMatrix(int r, int c) {\n\t\trows = r; columns = c;\n\t\tvalues = new T[rows * columns];\n\t\tfor(int i = 0; i < rows * columns; i ++) {\n\t\t\tvalues[i] = 0;\n\t\t}\n\t}\n\t~Matrix() {\n\t\tif(values != NULL) delete[] values;\n\t}\n\tvoid print() {\n\t\tfor(int i = 0; i < rows; i ++) {\n\t\t\tfor(int j = 0; j < columns; j ++) {\n\t\t\t\tcout << \"    \" << values[i * columns + j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n};",
            1590632202.3640444,
            100,
            "# 答案正确"
        ],
        [
            "7.1 (C++)",
            "潘文轩",
            "#include <cmath>\n\nclass Triangle: public GeometricObject {\nprivate:\n\tdouble side1, side2, side3;\n\npublic:\n\tTriangle() {\n\t\tside1 = side2 = side3 = 1;\n\t}\n\tTriangle(double s1, double s2, double s3): side1(s1), side2(s2), side3(s3) {}\n\tdouble getSide1() {\n\t\treturn side1;\n\t}\n\tdouble getSide2() {\n\t\treturn side2;\n\t}\n\tdouble getSide3() {\n\t\treturn side3;\n\t}\n\tdouble getArea() {\n\t\tdouble s = (side1 + side2 + side3) / 2;\n\t\treturn sqrt(s * (s - side1) * (s - side2) * (s - side3));\n\t}\n\tdouble getPerimeter() {\n\t\treturn side1 + side2 + side3;\n\t}\n};",
            1591105134.4084346,
            100,
            "# 答案正确"
        ],
        [
            "7.3 (C++)",
            "潘文轩",
            "template<typename A>\nvector<A> map2(const vector<A> & x, const vector<A> & y, A (*cal_func)(const A &, const A &)) {\n\tvector<A> res;\n\tfor(int i = 0; i < x.size(); i ++) {\n\t\tres.push_back(cal_func(x[i], y[i]));\n\t}\n\treturn res;\n}\n\ntemplate<typename A>\nvector<A> map2(const vector<A> & x, const A y, A (*cal_func)(const A &, const A &)) {\n\tvector<A> res;\n\tfor(int i = 0; i < x.size(); i ++) {\n\t\tres.push_back(cal_func(x[i], y));\n\t}\n\treturn res;\n}",
            1591106141.157005,
            100,
            "# 答案正确"
        ],
        [
            "7.2 (C++)",
            "潘文轩",
            "#include <string>\n#include <vector>\nusing namespace std;\n\nvector<string> split(const string & s) {\n\tconst char c = ' ';\n\tconst int len = s.length();\n\tint cur = 0;\n\tvector<string> subs;\n\twhile(cur < len) {\n\t\tint end = s.find(c, cur);\n\t\tif(end == -1) {\n\t\t\tsubs.push_back(s.substr(cur));\n\t\t\tbreak;\n\t\t}\n\t\telse if(end == cur) cur ++;\n\t\telse {\n\t\t\tsubs.push_back(s.substr(cur, end - cur));\n\t\t\tcur = end + 1;\n\t\t}\n\t}\n\treturn subs;\n}",
            1591239839.204615,
            100,
            "# 答案正确"
        ],
        [
            "8.1 (C++)",
            "潘文轩",
            "#include <vector>\n\nclass Full: public Matrix {\nprivate:\n\tvector<double> matrix;\n\tint rows, columns;\npublic:\n\tFull(int r, int c) {\n\t\trows = r;\n\t\tcolumns = c;\n\t\tmatrix.assign(r * c, 0);\n\t}\n\tFull(int r, int c, double values[]) {\n\t\trows = r;\n\t\tcolumns = c;\n\t\tvector<double> temp(values, values + r * c);\n\t\tmatrix.assign(temp.begin(), temp.end());\n\t}\n\tFull(const Matrix & m) {\n\t\trows = m.size(1);\n\t\tcolumns = m.size(2);\n\t\tfor (int i = 0; i < rows; ++ i) {\n\t\t\tfor (int j = 0; j < columns; ++ j){\n\t\t\tmatrix.push_back(m.get(i,j));\n\t\t\t} \n\t\t}\n\t}\n\t~Full() {}\n\tvirtual void print() const {\n\t\tfor(int i = 0; i < rows; i ++) {\n\t\t\tfor(int j = 0; j < columns; j ++) {\n\t\t\t\tcout << \"    \" << matrix[i * columns + j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tvirtual int size(int dimension) const {\n\t\tif(dimension == 1) return rows;\n\t\telse if(dimension == 2) return columns;\n\t\telse {\n\t\t\tcout << \"Dimension wrong when getting size.\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tvirtual void set(int row, int column, double value) {\n\t\tmatrix[row * columns + column] = value;\n\t}\n\t\n\tvirtual double get(int row, int column) const {\n\t\treturn matrix[row * columns + column];\n\t}\n\tvector<double> get() const {\n\t\treturn matrix;\n\t}\n\tvirtual Matrix & operator = (const Matrix & matrix2) {\n\t\trows = matrix2.size(1);\n\t\tcolumns = matrix2.size(2);\n\t\tfor (int i = 0; i < rows; ++ i) {\n\t\t\tfor (int j = 0; j < columns; ++ j){\n\t\t\tset(i, j, matrix2.get(i,j));\n\t\t\t} \n\t\t}\n\t\treturn *this;\n\t}\n};",
            1591808314.5903063,
            100,
            "# 答案正确"
        ],
        [
            "8.3 (C++)",
            "潘文轩",
            "#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nclass Sparse: public Matrix {\nprivate:\n\tint rows, columns;\n\tint nnz;\npublic:\n\tvector<Entry> p;\n\tSparse() {}\n\tSparse(int r, int c) {\n\t\trows = r;\n\t\tcolumns = c;\n\t\tnnz = 0;\n\t\tp.reserve(100);\n\t}\n\tvirtual int size(int dimension) const {\n\t\tif(dimension == 1) return rows;\n\t\telse if(dimension == 2) return columns;\n\t\telse {\n\t\t\tcout << \"Error when getting size\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tvirtual void set(int r, int c, double v) {\n\t\tfor(auto i = p.begin(); i < p.end(); i ++) {\n\t\t\tif(i -> row == r) {\n\t\t\t\tif(i -> column == c) {\n\t\t\t\t\ti -> value = v;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tEntry temp;\n\t\ttemp.row = r;\n\t\ttemp.column = c;\n\t\ttemp.value = v;\n\t\tfor(auto i = p.begin(); i < p.end(); i ++) {\n\t\t\tif(cmp(*i, temp)) {\n\t\t\t\tp.insert(i, temp);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tp.push_back(temp);\n\t}\n\t\n\tvirtual double get(int r, int c) const {\n\t\tfor(auto i = p.begin(); i < p.end(); i ++) {\n\t\t\tif(i -> row == r) {\n\t\t\t\tif(i -> column == c) {\n\t\t\t\t\treturn i -> value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tvirtual void print() {\n\t\tsort(p.begin(), p.end(), cmp);\n\t\tfor(auto i = p.begin(); i < p.end(); i ++) {\n\t\t\tcout << \"(\" << i -> row << \",\" << i -> column;\n\t\t\tcout << \",\" << i -> value << \")\" << endl;\n\t\t}\n\t}\n\n\tSparse operator + (Sparse & sparse2) {\n\t\tsort(p.begin(), p.end(), cmp);\n\t\tsort(sparse2.p.begin(), sparse2.p.end(), cmp);\n\t\tSparse temp(rows, columns);\n\t\tauto pa = p.begin();\n\t\tauto pb = sparse2.p.begin();\n\t\twhile(pa < p.end() && pb < sparse2.p.end()) {\n\t\t\tif(pa -> row == pb -> row && pa -> column == pb -> column) {\n\t\t\t\tEntry t;\n\t\t\t\tt.row = pa -> row;\n\t\t\t\tt.column = pa -> column;\n\t\t\t\tt.value = pa -> value + pb -> value;\n\t\t\t\tif(t.value != 0) temp.p.push_back(t);\n\t\t\t\tpa ++;\n\t\t\t\tpb ++;\n\t\t\t}\n\t\t\telse if(pa -> row > pb -> row || \n\t\t\t(pa -> row == pb -> row && pa -> column > pb -> column)) {\n\t\t\t\ttemp.p.push_back(*pb);\n\t\t\t\tpb ++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttemp.p.push_back(*pa);\n\t\t\t\tpa ++;\n\t\t\t}\n\t\t}\n\t\twhile(pa < p.end()) {\n\t\t\ttemp.p.push_back(*pa);\n\t\t\tpa ++;\n\t\t}\n\t\twhile(pb < sparse2.p.end()) {\n\t\t\ttemp.p.push_back(*pb);\n\t\t\tpb ++;\n\t\t}\n\t\treturn temp;\n\t}\n\n\tstatic bool cmp(Entry a, Entry b) {\n\t\tif(a.row == b.row) {\n\t\t\treturn a.column < b.column;\n\t\t}\n\t\telse return a.row < b.row;\n\t}\n};",
            1591836558.1715717,
            100,
            "# 答案正确"
        ],
        [
            "8.4 (C++)",
            "潘文轩",
            "#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nclass Sparse: public Matrix {\nprivate:\n\tint rows, columns;\n\t\npublic:\n\tvector<Entry> p;\n\tSparse() {}\n\tSparse(int r, int c) {\n\t\trows = r;\n\t\tcolumns = c;\n\t\tp.reserve(100);\n\t}\n\tvirtual int size(int dimension) const {\n\t\tif(dimension == 1) return rows;\n\t\telse if(dimension == 2) return columns;\n\t\telse {\n\t\t\tcout << \"Error when getting size\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tvirtual void set(int r, int c, double v) {\n\t\tfor(auto i = p.begin(); i < p.end(); i ++) {\n\t\t\tif(i -> row == r) {\n\t\t\t\tif(i -> column == c) {\n\t\t\t\t\ti -> value = v;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tEntry temp;\n\t\ttemp.row = r;\n\t\ttemp.column = c;\n\t\ttemp.value = v;\n\t\tfor(auto i = p.begin(); i < p.end(); i ++) {\n\t\t\tif(cmp(*i, temp)) {\n\t\t\t\tp.insert(i, temp);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tp.push_back(temp);\n\t}\n\t\n\tvirtual double get(int r, int c) const {\n\t\tfor(auto i = p.begin(); i < p.end(); i ++) {\n\t\t\tif(i -> row == r) {\n\t\t\t\tif(i -> column == c) {\n\t\t\t\t\treturn i -> value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tvirtual void print() {\n\t\tsort(p.begin(), p.end(), cmp);\n\t\tfor(auto i = p.begin(); i < p.end(); i ++) {\n\t\t\tcout << \"(\" << i -> row << \",\" << i -> column;\n\t\t\tcout << \",\" << i -> value << \")\" << endl;\n\t\t}\n\t}\n\n\tSparse operator + (Sparse & sparse2) {\n\t\tsort(p.begin(), p.end(), cmp);\n\t\tsort(sparse2.p.begin(), sparse2.p.end(), cmp);\n\t\tSparse temp(rows, columns);\n\t\tauto pa = p.begin();\n\t\tauto pb = sparse2.p.begin();\n\t\twhile(pa < p.end() && pb < sparse2.p.end()) {\n\t\t\tif(pa -> row == pb -> row && pa -> column == pb -> column) {\n\t\t\t\tEntry t;\n\t\t\t\tt.row = pa -> row;\n\t\t\t\tt.column = pa -> column;\n\t\t\t\tt.value = pa -> value + pb -> value;\n\t\t\t\tif(t.value != 0) temp.p.push_back(t);\n\t\t\t\tpa ++;\n\t\t\t\tpb ++;\n\t\t\t}\n\t\t\telse if(pa -> row > pb -> row || \n\t\t\t(pa -> row == pb -> row && pa -> column > pb -> column)) {\n\t\t\t\ttemp.p.push_back(*pb);\n\t\t\t\tpb ++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttemp.p.push_back(*pa);\n\t\t\t\tpa ++;\n\t\t\t}\n\t\t}\n\t\twhile(pa < p.end()) {\n\t\t\ttemp.p.push_back(*pa);\n\t\t\tpa ++;\n\t\t}\n\t\twhile(pb < sparse2.p.end()) {\n\t\t\ttemp.p.push_back(*pb);\n\t\t\tpb ++;\n\t\t}\n\t\treturn temp;\n\t}\n\n\tstatic bool cmp(Entry a, Entry b) {\n\t\tif(a.row == b.row) {\n\t\t\treturn a.column < b.column;\n\t\t}\n\t\telse return a.row < b.row;\n\t}\n\n\tstatic bool cmp2(Entry a, Entry b) {\n\t\tif(a.column == b.column) {\n\t\t\treturn a.row < b.row;\n\t\t}\n\t\telse return a.column < b.column;\n\t}\n\n\tSparse operator * (Sparse & sparse2) {\n\t\tsort(p.begin(), p.end(), cmp);\n\t\tsort(sparse2.p.begin(), sparse2.p.end(), cmp);\n\t\tSparse temp(rows, sparse2.columns);\n\t\tfor(int i = 0; i < p.size(); i ++) {\n\t\t\tint cur_row = p[i].row;\n\t\t\tint row_begin = i;\n\t\t\twhile(cur_row == p[i + 1].row) {\n\t\t\t\ti ++;\n\t\t\t}\n\t\t\tint temp_column[100];\n\t\t\tdouble temp_value[100];\n\t\t\tint nnz = 0;\n\t\t\tmemset(temp_value, 0, sizeof(temp_value));\n\t\t\tmemset(temp_column, 0, sizeof(temp_column));\n\t\t\tfor(int j = row_begin; j <= i; j ++) {\n\t\t\t\tint cur_col = p[j].column;\n\t\t\t\tfor(int k = 0; k < sparse2.p.size(); k ++) {\n\t\t\t\t\tif(sparse2.p[k].row == cur_col) {\n\t\t\t\t\t\t// search temp_column, check whether column exists\n\t\t\t\t\t\tbool exists = false;\n\t\t\t\t\t\tint new_column = sparse2.p[k].column;\n\t\t\t\t\t\tfor(int l = 0; l < nnz; l ++) {\n\t\t\t\t\t\t\tif(temp_column[l] == sparse2.p[k].column) {\n\t\t\t\t\t\t\t\ttemp_value[l] += p[j].value * sparse2.p[k].value;\n\t\t\t\t\t\t\t\texists = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!exists) {\n\t\t\t\t\t\t\ttemp_column[nnz] = sparse2.p[k].column;\n\t\t\t\t\t\t\ttemp_value[nnz] = sparse2.p[k].value * p[j].value;\n\t\t\t\t\t\t\tnnz ++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = 0; j < nnz; j ++) {\n\t\t\t\tEntry t;\n\t\t\t\tt.row = cur_row;\n\t\t\t\tt.column = temp_column[j];\n\t\t\t\tt.value = temp_value[j];\n\t\t\t\ttemp.p.push_back(t);\n\t\t\t}\n\t\t}\n\t\treturn temp;\n\t}\n};",
            1591839907.5063663,
            100,
            "# 答案正确"
        ],
        [
            "8.5 (C++)",
            "潘文轩",
            "class Point3D: public Point2D {\nprivate:\n\tdouble z;\npublic:\n\tPoint3D() {\n\t\tsetX(0);\n\t\tsetY(0);\n\t\tz = 0;\n\t}\n\tPoint3D(int X, int Y, int Z) {\n\t\tsetX(X);\n\t\tsetY(Y);\n\t\tz = Z;\n\t}\n\tdouble getZ() {\n\t\treturn z;\n\t}\n\tvirtual double distance(Point2D & point2) {\n\t\tPoint3D & p = dynamic_cast<Point3D &> (point2);\n\t\tdouble dx = getX() - p.getX();\n\t\tdouble dy = getY() - p.getY();\n\t\tdouble dz = getZ() - p.getZ();\n\t\treturn sqrt(dx * dx + dy * dy + dz * dz);\n\t}\n};",
            1591844739.6623971,
            100,
            "# 答案正确"
        ],
        [
            "8.6 (C++)",
            "潘文轩",
            "#include <iostream>\nusing namespace std;\n\nclass MyTensor: public Tensor<double> {\nprivate:\n\tvector<double> tensor;\npublic:\n\tMyTensor(vector<int> Sizes) : Tensor(Sizes) {\n\t\tsizes = Sizes;\n\t\tint size = sizes.size();\n\t\tint length = 1;\n\t\tfor(int i = 0; i < size; i ++) {\n\t\t\tlength *= sizes[i];\n\t\t}\n\t\ttensor.resize(length);\n\t}\n\tvirtual double & get(const vector<int> & indexes) {\n\t\tint size = indexes.size();\n\t\tint i = 0;\n\t\tfor(int j = 0; j < size; j ++) {\n\t\t\ti += indexes[j] * sizes[j];\n\t\t}\n\t\tif(i >= tensor.size()) {\n\t\t\tcout << \"Wrong index.\" << endl;\n\t\t\treturn tensor[0];\n\t\t}\n\t\telse return tensor[i];\n\t}\n};",
            1592450984.0270123,
            100,
            "# 答案正确"
        ],
        [
            "9.1 (C++)",
            "潘文轩",
            "class Circle {\nprivate:\n\tdouble r;\npublic:\n\tCircle() {}\n\tCircle(double r): r(r) {}\n\tdouble get() {\n\t\treturn r;\n\t}\n\tconst double get() const {\n\t\treturn r;\n\t}\n\tbool operator < (const Circle & c1) const {\n\t\treturn r < c1.get();\n\t}\n\tbool operator <= (const Circle & c1) const {\n\t\treturn r <= c1.get();\n\t}\n\tbool operator == (const Circle & c1) const {\n\t\treturn r == c1.get();\n\t}\n\tbool operator != (const Circle & c1) const {\n\t\treturn r != c1.get();\n\t}\n\tbool operator > (const Circle & c1) const {\n\t\treturn r > c1.get();\n\t}\n\tbool operator >= (const Circle & c1) const {\n\t\treturn r >= c1.get();\n\t}\n\n};",
            1593072884.1342256,
            100,
            "# 答案正确"
        ],
        [
            "9.2 (C++)",
            "潘文轩",
            "class I: public vector<int>{\npublic:\n\tI(const int a, const int b, const int c, const int d = 0) {\n\t\tthis -> push_back(a);\n\t\tthis -> push_back(b);\n\t\tthis -> push_back(c);\n\t\tif(d != 0) this -> push_back(d);\n\t}\n};",
            1593073555.1439548,
            100,
            "# 答案正确"
        ],
        [
            "9.3 (C++)",
            "潘文轩",
            "class Complex {\nprivate:\n\tdouble a, b;\npublic:\n\tComplex() {}\n\tComplex(int a): a((double)a), b(0) {}\n\tComplex(double a): a(a), b(0) {} \n\tComplex(double a, double b): a(a), b(b) {}\n\n\tdouble real() {\n\t\treturn a;\n\t}\n\tconst double real() const {\n\t\treturn a;\n\t}\n\tdouble imag() {\n\t\treturn b;\n\t}\n\tconst double imag() const {\n\t\treturn b;\n\t}\n\tComplex & operator = (const Complex & c) {\n\t\ta = c.real();\n\t\tb = c.imag();\n\t\treturn *this;\n\t}\n\t\n\tComplex operator * (const Complex & c) {\n\t\tdouble new_a, new_b;\n\t\tnew_a = a * c.real() - b * c.imag();\n\t\tnew_b = b * c.real() + a * c.imag();\n\t\treturn Complex(new_a, new_b);\n\t}\n\tComplex operator / (const Complex & c) {\n\t\tdouble fenmu = c.real() * c.real() + c.imag() * c.imag();\n\t\tComplex tmp(c.real(), -c.imag());\n\t\ttmp = *this * tmp;\n\t\treturn Complex(tmp.a / fenmu, tmp.b / fenmu);\n\t}\n\tbool operator == (const Complex & c) const {\n\t\treturn a == c.real() && b == c.imag();\n\t}\n\tbool operator != (const Complex & c) const {\n\t\treturn a != c.real() || b != c.imag();\n\t}\n\tComplex & operator += (const Complex & c) {\n\t\ta = a + c.real();\n\t\tb = b + c.imag();\n\t\treturn *this;\n\t}\n\tComplex & operator -= (const Complex & c) {\n\t\ta = a - c.real();\n\t\tb = b - c.imag();\n\t\treturn *this;\n\t}\n\tComplex & operator *= (const Complex & c) {\n\t\t*this = *this * c;\n\t\treturn *this;\n\t}\n\tComplex & operator /= (const Complex & c) {\n\t\t*this = *this / c;\n\t\treturn *this;\n\t}\n};\n\nComplex operator + (const Complex & c1, const Complex & c2) {\n\tdouble new_a, new_b;\n\tnew_a = c1.real() + c2.real();\n\tnew_b = c1.imag() + c2.imag();\n\treturn Complex(new_a, new_b);\n}\nComplex operator - (const Complex & c1, const Complex & c2) {\n\tdouble new_a, new_b;\n\tnew_a = c1.real() - c2.real();\n\tnew_b = c1.imag() - c2.imag();\n\treturn Complex(new_a, new_b);\n}",
            1593078496.156183,
            100,
            "# 答案正确"
        ],
        [
            "9.4 (C++)",
            "潘文轩",
            "class Complex {\nprivate:\n\tdouble a, b;\npublic:\n\tComplex() {}\n\tComplex(int a): a((double)a), b(0) {}\n\tComplex(double a): a(a), b(0) {} \n\tComplex(double a, double b): a(a), b(b) {}\n\n\tdouble & real() {\n\t\treturn a;\n\t}\n\tconst double & real() const {\n\t\treturn a;\n\t}\n\tdouble & imag() {\n\t\treturn b;\n\t}\n\tconst double & imag() const {\n\t\treturn b;\n\t}\n\tComplex & operator = (const Complex & c) {\n\t\ta = c.real();\n\t\tb = c.imag();\n\t\treturn *this;\n\t}\n\t\n\tComplex operator * (const Complex & c) {\n\t\tdouble new_a, new_b;\n\t\tnew_a = a * c.real() - b * c.imag();\n\t\tnew_b = b * c.real() + a * c.imag();\n\t\treturn Complex(new_a, new_b);\n\t}\n\tComplex operator / (const Complex & c) {\n\t\tdouble fenmu = c.real() * c.real() + c.imag() * c.imag();\n\t\tComplex tmp(c.real(), -c.imag());\n\t\ttmp = *this * tmp;\n\t\treturn Complex(tmp.a / fenmu, tmp.b / fenmu);\n\t}\n\tbool operator == (const Complex & c) const {\n\t\treturn a == c.real() && b == c.imag();\n\t}\n\tbool operator != (const Complex & c) const {\n\t\treturn a != c.real() || b != c.imag();\n\t}\n\tComplex & operator += (const Complex & c) {\n\t\ta = a + c.real();\n\t\tb = b + c.imag();\n\t\treturn *this;\n\t}\n\tComplex & operator -= (const Complex & c) {\n\t\ta = a - c.real();\n\t\tb = b - c.imag();\n\t\treturn *this;\n\t}\n\tComplex & operator *= (const Complex & c) {\n\t\t*this = *this * c;\n\t\treturn *this;\n\t}\n\tComplex & operator /= (const Complex & c) {\n\t\t*this = *this / c;\n\t\treturn *this;\n\t}\n\t\n};\n\nComplex operator + (const Complex & c1, const Complex & c2) {\n\tdouble new_a, new_b;\n\tnew_a = c1.real() + c2.real();\n\tnew_b = c1.imag() + c2.imag();\n\treturn Complex(new_a, new_b);\n}\nComplex operator - (const Complex & c1, const Complex & c2) {\n\tdouble new_a, new_b;\n\tnew_a = c1.real() - c2.real();\n\tnew_b = c1.imag() - c2.imag();\n\treturn Complex(new_a, new_b);\n}\n\nistream & operator >> (istream & in, Complex & c) {\n\tdouble new_a, new_b;\n\tin >> new_a >> new_b;\n\tc = Complex(new_a, new_b);\n\treturn in;\n}\nostream & operator << (ostream & out, Complex & c) {\n\tout << c.real() << \" + \" << c.imag() << \" i\";\n\treturn out;\n}",
            1593079189.8424635,
            100,
            "# 答案正确"
        ],
        [
            "9.5 (C++)",
            "潘文轩",
            "class Complex {\nprivate:\n\tdouble a, b;\npublic:\n\tComplex() {}\n\tComplex(int a): a((double)a), b(0) {}\n\tComplex(double a): a(a), b(0) {} \n\tComplex(double a, double b): a(a), b(b) {}\n\n\tdouble & real() {\n\t\treturn a;\n\t}\n\tconst double & real() const {\n\t\treturn a;\n\t}\n\tdouble & imag() {\n\t\treturn b;\n\t}\n\tconst double & imag() const {\n\t\treturn b;\n\t}\n\tComplex & operator = (const Complex & c) {\n\t\ta = c.real();\n\t\tb = c.imag();\n\t\treturn *this;\n\t}\n\t\n\tComplex operator * (const Complex & c) {\n\t\tdouble new_a, new_b;\n\t\tnew_a = a * c.real() - b * c.imag();\n\t\tnew_b = b * c.real() + a * c.imag();\n\t\treturn Complex(new_a, new_b);\n\t}\n\tComplex operator / (const Complex & c) {\n\t\tdouble fenmu = c.real() * c.real() + c.imag() * c.imag();\n\t\tComplex tmp(c.real(), -c.imag());\n\t\ttmp = *this * tmp;\n\t\treturn Complex(tmp.a / fenmu, tmp.b / fenmu);\n\t}\n\tbool operator == (const Complex & c) const {\n\t\treturn a == c.real() && b == c.imag();\n\t}\n\tbool operator != (const Complex & c) const {\n\t\treturn a != c.real() || b != c.imag();\n\t}\n\tComplex & operator += (const Complex & c) {\n\t\ta = a + c.real();\n\t\tb = b + c.imag();\n\t\treturn *this;\n\t}\n\tComplex & operator -= (const Complex & c) {\n\t\ta = a - c.real();\n\t\tb = b - c.imag();\n\t\treturn *this;\n\t}\n\tComplex & operator *= (const Complex & c) {\n\t\t*this = *this * c;\n\t\treturn *this;\n\t}\n\tComplex & operator /= (const Complex & c) {\n\t\t*this = *this / c;\n\t\treturn *this;\n\t}\n\tComplex & operator ++ () {\n\t\ta ++;\n\t\treturn *this;\n\t}\n\tComplex operator ++ (int) {\n\t\tComplex prev_complex = *this;\n\t\ta ++;\n\t\treturn prev_complex;\n\t}\n\toperator double() {\n\t\treturn a;\n\t}\n};\n\nComplex operator + (const Complex & c1, const Complex & c2) {\n\tdouble new_a, new_b;\n\tnew_a = c1.real() + c2.real();\n\tnew_b = c1.imag() + c2.imag();\n\treturn Complex(new_a, new_b);\n}\nComplex operator - (const Complex & c1, const Complex & c2) {\n\tdouble new_a, new_b;\n\tnew_a = c1.real() - c2.real();\n\tnew_b = c1.imag() - c2.imag();\n\treturn Complex(new_a, new_b);\n}\n\nistream & operator >> (istream & in, Complex & c) {\n\tdouble new_a, new_b;\n\tin >> new_a >> new_b;\n\tc = Complex(new_a, new_b);\n\treturn in;\n}\nostream & operator << (ostream & out, const Complex & c) {\n\tout << c.real() << \" + \" << c.imag() << \" i\";\n\treturn out;\n}",
            1593086030.9781945,
            100,
            "# 答案正确"
        ],
        [
            "9.6 (C++)",
            "潘文轩",
            "class Tensor {\nprivate:\n\tvector<double> t;\n\tvector<int> dim;\npublic:\n\tTensor() {}\n\tTensor(int a, int b, int c, int d = 1) {\n\t\tdim.push_back(a);\n\t\tdim.push_back(b);\n\t\tdim.push_back(c);\n\t\tif(d > 1) dim.push_back(d);\n\t\tt.reserve(a * b * c * d);\n\t}\n\tdouble & operator () (int a, int b, int c, int d = 0) {\n\t\treturn t[((a * dim[0] + b) * dim[1] + c) * dim[2] + d];\n\t}\n\tconst double & operator () (int a, int b, int c, int d = 0) const {\n\t\treturn t[((a * dim[0] + b) * dim[1] + c) * dim[2] + d];\n\t}\n};",
            1593086625.4661176,
            100,
            "# 答案正确"
        ],
        [
            "9.7 (C++)",
            "潘文轩",
            "class Tensor {\nprivate:\n\tvector<double> t;\n\tvector<int> dim;\n\tint total_dim, total_size;\npublic:\n\tTensor(): total_size(1) {}\n\tTensor(int a, int b, int c, int d = 1) {\n\t\ttotal_dim = 3;\n\t\tdim.push_back(a);\n\t\tdim.push_back(b);\n\t\tdim.push_back(c);\n\t\tif(d > 1) {\n\t\t\tdim.push_back(d);\n\t\t\ttotal_dim ++;\n\t\t}\n\t\tt.resize(a * b * c * d);\n\t\ttotal_size = a * b * c * d;\n\t}\n\tfriend istream & operator >> (istream & in, Tensor & ten);\n\tfriend ostream & operator << (ostream & out, const Tensor & ten);\n};\n\nistream & operator >> (istream & in, Tensor & ten) {\n\tten.total_size = 1;\n\tin >> ten.total_dim;\n\tten.dim.resize(ten.total_dim);\n\tfor(int i = 0; i < ten.total_dim; i ++) {\n\t\tin >> ten.dim[i];\n\t\tten.total_size *= ten.dim[i];\n\t}\n\tten.t.resize(ten.total_size);\n\tfor(int i = 0; i < ten.total_size; i ++) {\n\t\tin >> ten.t[i];\n\t}\n\treturn in;\n}\n\nostream & operator << (ostream & out, const Tensor & ten) {\n\tout << ten.total_dim << endl;\n\tfor(int i = 0; i < ten.total_dim; i ++) {\n\t\tout << ten.dim[i] << \" \";\n\t}\n\tout << endl << endl;\n\tfor(int i = 0; i < ten.dim[0]; i ++) {\n\t\tint cur_index = i * ten.dim[0];\n\t\tfor(int j = 0; j < ten.dim[1]; j ++) {\n\t\t\tif(ten.total_dim >= 3) {\n\t\t\t\tcur_index = (cur_index + j) * ten.dim[1];\n\t\t\t\tfor(int k = 0; k < ten.dim[2]; k ++) {\n\t\t\t\t\tif(ten.total_dim >= 4) {\n\t\t\t\t\t\tcur_index = (cur_index + k) * ten.dim[2];\n\t\t\t\t\t\tfor(int l = 0; l < ten.dim[3]; l ++) {\n\t\t\t\t\t\t\tout << ten.t[cur_index + l];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tout << endl;\n\t\t\t\t\t}\n\t\t\t\t\telse out << ten.t[cur_index + k];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse out << ten.t[cur_index + j];\n\t\t\tout << endl;\n\t\t}\n\t}\n\treturn out;\n}",
            1593089819.6743224,
            100,
            "=================================================================\n==29031==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x610000008000 at pc 0x562ec2bece11 bp 0x7fff5f2996b0 sp 0x7fff5f2996a0\nREAD of size 8 at 0x610000008000 thread T0\n    #0 0x562ec2bece10 in operator<<(std::ostream&, Tensor const&) /home/潘文轩/source.cpp:58\n    #1 0x562ec2bed4dd in main /home/潘文轩/main.cpp:12\n    #2 0x7fa2000ba82f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2082f)\n    #3 0x562ec2bec4d8 in _start (/home/潘文轩/main.out+0x14d8)\n\n0x610000008000 is located 0 bytes to the right of 192-byte region [0x610000007f40,0x610000008000)\nallocated by thread T0 here:\n    #0 0x7fa200a95532 in operator new(unsigned long) (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x99532)\n    #1 0x562ec2bed812 in __gnu_cxx::new_allocator<double>::allocate(unsigned long, void const*) /usr/include/c++/5/ext/new_allocator.h:104\n    #2 0x562ec2bed812 in std::allocator_traits<std::allocator<double> >::allocate(std::allocator<double>&, unsigned long) /usr/include/c++/5/bits/alloc_traits.h:491\n    #3 0x562ec2bed812 in std::_Vector_base<double, std::allocator<double> >::_M_allocate(unsigned long) /usr/include/c++/5/bits/stl_vector.h:170\n    #4 0x562ec2bed812 in std::vector<double, std::allocator<double> >::_M_default_append(unsigned long) /usr/include/c++/5/bits/vector.tcc:557\n    #5 0x562ec2bed307 in std::vector<double, std::allocator<double> >::resize(unsigned long) /usr/include/c++/5/bits/stl_vector.h:676\n    #6 0x562ec2bed307 in operator>>(std::istream&, Tensor&) /home/潘文轩/source.cpp:32\n    #7 0x562ec2bed4ca in main /home/潘文轩/main.cpp:11\n    #8 0x7fa2000ba82f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2082f)\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /home/潘文轩/source.cpp:58 operator<<(std::ostream&, Tensor const&)\nShadow bytes around the buggy address:\n  0x0c207fff8fb0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c207fff8fc0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c207fff8fd0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c207fff8fe0: fa fa fa fa fa fa fa fa 00 00 00 00 00 00 00 00\n  0x0c207fff8ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n=>0x0c207fff9000:[fa]fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c207fff9010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c207fff9020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c207fff9030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c207fff9040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c207fff9050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Heap right redzone:      fb\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack partial redzone:   f4\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n==29031==ABORTING\n"
        ],
        [
            "10.1 (C++)",
            "潘文轩",
            "#include <exception>\n#include <stdexcept>\nusing namespace std;\n\nclass MatrixSizesDoNotMatchException {};\n\ndouble Matrix::get(int row, int column) const {\n\tif(row <= 0 || column <= 0 || row > size(1) || column > size(2)) {\n\t\tthrow out_of_range(\"Matrix index out of range\");\n\t}\n\treturn elements[(row - 1) * size(2) + column - 1];\n}\n\nvoid Matrix::set(int row, int column, double value) {\n\tif(row <= 0 || column <= 0 || row > size(1) || column > size(2)) {\n\t\tthrow out_of_range(\"Matrix index out of index\");\n\t}\n\telements[(row - 1) * size(2) + column - 1] = value;\n}\n\nMatrix Matrix::operator + (const Matrix & matrix2) const {\n\tif(size(1) != matrix2.size(1) || size(2) != matrix2.size(2)) {\n\t\tthrow MatrixSizesDoNotMatchException();\n\t}\n\tMatrix m(size(1), size(2));\n\tfor(int i = 1; i <= size(1); i ++) {\n\t\tfor(int j = 1; j <= size(2); j ++) {\n\t\t\tm.set(i, j, get(i, j) + matrix2.get(i, j));\n\t\t}\n\t}\n\treturn m;\n}",
            1593654120.5773587,
            100,
            "# 答案正确"
        ],
        [
            "10.2 (C++)",
            "潘文轩",
            "catch(NonPositiveValueException & ex) {\n\t\t\tcout << \"caught: NonPositiveValueException\" << endl;\n\t\t}\n\t\tcatch(out_of_range & ) {\n\t\t\tcout << \"caught: out_of_range\" << endl;\n\t\t}",
            1593657418.9209445,
            100,
            "# 答案正确"
        ],
        [
            "15.1 (C++)",
            "潘文轩",
            "#include <vector>\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Table {\nprivate:\n\tvector<string> header;\n\tvector<vector<string> > rows;\n\tint number_rows;\n\npublic:\n\tTable(): number_rows(0) {}\n\tvoid addCol(string s) {\n\t\theader.push_back(s);\n\t}\n\tvector<string> & operator [] (const int r) {\n\t\tif(r == number_rows) {\n\t\t\tnumber_rows ++;\n\t\t\trows.push_back(vector<string>());\n\t\t\treturn rows[r];\n\t\t}\n\t\telse return rows[number_rows - 1];\n\t}\n\tstring json() const {\n\t\tstring out;\n\t\tout += \"{\\n\";\n\t\tout += \"\\theaders: [\";\n\t\tfor(int i = 0; i < header.size(); i ++) {\n\t\t\tout = out + \"'\" + header[i] + \"',\";\n\t\t}\n\t\tout += \"],\\n\";\n\t\tout += \"\\trows: [\\n\";\n\t\tfor(int i = 0; i < number_rows; i ++) {\n\t\t\tout += \"\\t\\t[\";\n\t\t\tfor(int j = 0; j < rows[i].size(); j ++) {\n\t\t\t\tout = out + \"'\" + rows[i][j] + \"',\";\n\t\t\t}\n\t\t\tout += \"],\\n\";\n\t\t}\n\t\tout += \"\\t],\\n\";\n\t\tout += \"}\\n\";\n\t\treturn out;\n\t}\n\t\n};",
            1594258753.2167745,
            100,
            "# 答案正确"
        ],
        [
            "2020-07-09 LAB",
            "潘文轩",
            "#include <vector>\n#include <iostream>\nusing namespace std;\n\nclass Integer {\nprivate:\n\tstatic Integer * integers[20];\n\tstatic int size;\n\tint value;\npublic:\n\tInteger(): value(0) {\n\t\tintegers[size ++] = this;\n\t}\n\tInteger(int v): value(v) {\n\t\tintegers[size ++] = this;\n\t}\n\tvoid increase_one(int v) {\n\t\tvalue += v;\n\t}\n\tint & get_value() {\n\t\treturn value;\n\t}\n\tconst int & get_value() const {\n\t\treturn value;\n\t}\n\tstatic void increase_all(Integer v) {\n\t\tfor(int i = 0; i < size; i ++) {\n\t\t\tintegers[i] -> increase_one(v.get_value());\n\t\t}\n\t}\n\t\n};\n\nInteger * Integer::integers[20];\nint Integer::size = 0;\n\nostream & operator << (ostream & out, const Integer & i) {\n\tout << i.get_value();\n\treturn out;\n}\n\nistream & operator >> (istream & in, Integer & i) {\n\tin >> i.get_value();\n\treturn in;\n}",
            1594262531.1477196,
            100,
            "# 答案正确"
        ],
        [
            "A.2 (C++)",
            "潘文轩",
            "template <typename E>\nvoid LinkedList<E>::removeAll(const E & e) {\n\twhile(indexOf(e) != -1) {\n\t\tint i = indexOf(e);\n\t\tif(i == 0) {\n\t\t\tNode<E> * new_head = head -> next_node;\n\t\t\tdelete head;\n\t\t\thead = new_head;\n\t\t\thead -> prev_node = NULL;\n\t\t}\n\t\telse if(i == size() - 1) {\n\t\t\tNode<E> * new_tail = tail -> prev_node;\n\t\t\tdelete tail;\n\t\t\ttail = new_tail;\n\t\t\ttail -> next_node = NULL;\n\t\t}\n\t\telse {\n\t\t\tNode<E> * prev = get_node(i - 1);\n\t\t\tNode<E> * next = get_node(i + 1);\n\t\t\tdelete get_node(i);\n\t\t\tprev -> next_node = next;\n\t\t\tnext -> prev_node = prev;\n\t\t}\n\t\t_size --;\n\t}\n}",
            1594869796.4021902,
            100,
            "# 答案正确"
        ],
        [
            "A.1 (C++)",
            "潘文轩",
            "\tclass NotSuchElementException {};\n\n\tNode<E> & get_node(int index) {\n\t\tif(index < 0 || index >= _size) {\n\t\t\tthrow NotSuchElementException();\n\t\t}\n\t\tNode<E> node;\n\t\tif(index < _size / 2) {\n\t\t\tNode<E> * last = NULL;\n\t\t\tnode = head;\n\t\t\tfor(int i = 0; i < index; i ++) {\n\t\t\t\tNode<E> * tmp = node;\n\t\t\t\tnode = node -> next_node(last);\n\t\t\t\tlast = tmp;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tNode<E> * last = NULL;\n\t\t\tnode = tail;\n\t\t\tfor(int i = _size - 1; i >= index; i --) {\n\t\t\t\tNode<E> * tmp = node;\n\t\t\t\tnode = node -> prev_node(last);\n\t\t\t\tlast = tmp;\n\t\t\t}\n\t\t}\n\t\treturn node;\n\t}\n\n\tNode<E> & get(int index) {\n\t\treturn get_node(index);\n\t}\n\n\tvoid add(int index, const E & e) {\n\t\tif(index < 0 || index >= _size) {\n\t\t\tthrow NotSuchElementException();\n\t\t}\n\t\tNode<E> * node = new Node<E>();\n\t\tnode -> element = e;\n\t\tNode<E> * next_node = (index == _size ? 0 : get_node(index));\n\t\tNode<E> * prev_node = (next_node == 0 ? tail : next_node -> prev_node(next_node));\n\t\tnode -> prev_xor_next = (long) next_node ^ (long) prev_node;\n\t\tif(prev_node != 0) prev_node -> prev_xor_next = (long) (prev_node -> prev_node(next_node)) ^ (long) node;\n\t\tif(next_node != 0) next_node -> prev_xor_next = (long) (next_node -> next_node(prev_node)) ^ (long) node;\n\t\tif(prev_node == 0) head = node;\n\t\tif(next_node == 0) tail = node;\n\t\t++ _size;\n\t}\n\n\tvoid addFirst(const E & e) {\n\t\tadd(0, e);\n\t}\n\n\tvoid addLast(const E & e) {\n\t\tadd(_size, e);\n\t}\n\n\tvoid remove(int index) {\n\t\tif(index < 0 || index >= _size) {\n\t\t\tthrow NotSuchElementException();\n\t\t}\n\t\tNode<E> * prev_node;\n\t\tif(index > 0) prev_node = get_node(index - 1);\n\t\telse prev_node = NULL;\n\t\tNode<E> * node = get_node(index);\n\t\tNode<E> * next_node = node -> next_node(prev_node);\n\t\tif(prev_node != 0) prev_node -> prev_xor_next = (long) (prev_node -> prev_node(node)) ^ (long) next_node;\n\t\tif(next_node != 0) next_node -> prev_xor_next = (long) (next_node -> next_node(node)) ^ (long) prev_node;\n\t\tif(prev_node == 0) head = next_node;\n\t\tif(next_node == 0) tail = prev_node;\n\t\tdelete node;\n\t\t-- _size;\n\t}\n\n\tvoid removeFirst() {\n\t\tremove(0);\n\t}\n\n\tvoid removeLast() {\n\t\tremove(_size - 1);\n\t}\n\n\tint indexOf(const E & val) {\n\t\tNode<E> * node = head, * last = NULL;\n\t\tfor(int i = 0; i < _size; i ++) {\n\t\t\tif(node -> element == val) return i;\n\t\t\tNode<E> * tmp = node;\n\t\t\tnode = node -> next_node(last);\n\t\t\tlast = tmp;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tvoid removeFirstOccurrence(E val) {\n\t\tremove(indexOf(val));\n\t}",
            1594904377.6085556,
            0,
            "main.cpp: In function ‘int main()’:\nmain.cpp:68:8: error: no match for ‘operator<<’ (operand types are ‘std::ostream {aka std::basic_ostream<char>}’ and ‘Node<double>’)\n   cout << list2.get(list2.size()-1) << endl;\n        ^\nIn file included from /usr/include/c++/5/iostream:39:0,\n                 from main.cpp:1:\n/usr/include/c++/5/ostream:108:7: note: candidate: std::basic_ostream<_CharT, _Traits>::__ostream_type& std::basic_ostream<_CharT, _Traits>::operator<<(std::basic_ostream<_CharT, _Traits>::__ostream_type& (*)(std::basic_ostream<_CharT, _Traits>::__ostream_type&)) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_ostream<_CharT, _Traits>::__ostream_type = std::basic_ostream<char>]\n       operator<<(__ostream_type& (*__pf)(__ostream_type&))\n       ^\n/usr/include/c++/5/ostream:108:7: note:   no known conversion for argument 1 from ‘Node<double>’ to ‘std::basic_ostream<char>::__ostream_type& (*)(std::basic_ostream<char>::__ostream_type&) {aka std::basic_ostream<char>& (*)(std::basic_ostream<char>&)}’\n/usr/include/c++/5/ostream:117:7: note: candidate: std::basic_ostream<_CharT, _Traits>::__ostream_type& std::basic_ostream<_CharT, _Traits>::operator<<(std::basic_ostream<_CharT, _Traits>::__ios_type& (*)(std::basic_ostream<_CharT, _Traits>::__ios_type&)) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_ostream<_CharT, _Traits>::__ostream_type = std::basic_ostream<char>; std::basic_ostream<_CharT, _Traits>::__ios_type = std::basic_ios<char>]\n       operator<<(__ios_type& (*__pf)(__ios_type&))\n       ^\n/usr/include/c++/5/ostream:117:7: note:   no known conversion for argument 1 from ‘Node<double>’ to ‘std::basic_ostream<char>::__ios_type& (*)(std::basic_ostream<char>::__ios_type&) {aka std::basic_ios<char>& (*)(std::basic_ios<char>&)}’\n/usr/include/c++/5/ostream:127:7: note: candidate: std::basic_ostream<_CharT, _Traits>::__ostream_type& std::basic_ostream<_CharT, _Traits>::operator<<(std::ios_base& (*)(std::ios_base&)) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_ostream<_CharT, _Traits>::__ostream_type = std::basic_ostream<char>]\n       operator<<(ios_base& (*__pf) (ios_base&))\n       ^\n/usr/include/c++/5/ostream:127:7: note:   no known conversion for argument 1 from ‘Node<double>’ to ‘std::ios_base& (*)(std::ios_base&)’\n/usr/include/c++/5/ostream:166:7: note: candidate: std::basic_ostream<_CharT, _Traits>::__ostream_type& std::basic_ostream<_CharT, _Traits>::operator<<(long int) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_ostream<_CharT, _Traits>::__ostream_type = std::basic_ostream<char>]\n       operator<<(long __n)\n       ^\n/usr/include/c++/5/ostream:166:7: note:   no known conversion for argument 1 from ‘Node<double>’ to ‘long int’\n/usr/include/c++/5/ostream:170:7: note: candidate: std::basic_ostream<_CharT, _Traits>::__ostream_type& std::basic_ostream<_CharT, _Traits>::operator<<(long unsigned int) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_ostream<_CharT, _Traits>::__ostream_type = std::basic_ostream<char>]\n       operator<<(unsigned long __n)\n       ^\n/usr/include/c++/5/ostream:170:7: note:   no known conversion for argument 1 from ‘Node<double>’ to ‘long unsigned int’\n/usr/include/c++/5/ostream:174:7: note: candidate: std::basic_ostream<_CharT, _Traits>::__ostream_type& std::basic_ostream<_CharT, _Traits>::operator<<(bool) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_ostream<_CharT, _Traits>::__ostream_type = std::basic_ostream<char>]\n       operator<<(bool __n)\n       ^\n/usr/include/c++/5/ostream:174:7: note:   no known conversion for argument 1 from ‘Node<double>’ to ‘bool’\nIn file included from /usr/include/c++/5/ostream:638:0,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/ostream.tcc:91:5: note: candidate: std::basic_ostream<_CharT, _Traits>& std::basic_ostream<_CharT, _Traits>::operator<<(short int) [with _CharT = char; _Traits = std::char_traits<char>]\n     basic_ostream<_CharT, _Traits>::\n     ^\n/usr/include/c++/5/bits/ostream.tcc:91:5: note:   no known conversion for argument 1 from ‘Node<double>’ to ‘short int’\nIn file included from /usr/include/c++/5/iostream:39:0,\n                 from main.cpp:1:\n/usr/include/c++/5/ostream:181:7: note: candidate: std::basic_ostream<_CharT, _Traits>::__ostream_type& std::basic_ostream<_CharT, _Traits>::operator<<(short unsigned int) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_ostream<_CharT, _Traits>::__ostream_type = std::basic_ostream<char>]\n       operator<<(unsigned short __n)\n       ^\n/usr/include/c++/5/ostream:181:7: note:   no known conversion for argument 1 from ‘Node<double>’ to ‘short unsigned int’\nIn file included from /usr/include/c++/5/ostream:638:0,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/ostream.tcc:105:5: note: candidate: std::basic_ostream<_CharT, _Traits>& std::basic_ostream<_CharT, _Traits>::operator<<(int) [with _CharT = char; _Traits = std::char_traits<char>]\n     basic_ostream<_CharT, _Traits>::\n     ^\n/usr/include/c++/5/bits/ostream.tcc:105:5: note:   no known conversion for argument 1 from ‘Node<double>’ to ‘int’\nIn file included from /usr/include/c++/5/iostream:39:0,\n                 from main.cpp:1:\n/usr/include/c++/5/ostream:192:7: note: candidate: std::basic_ostream<_CharT, _Traits>::__ostream_type& std::basic_ostream<_CharT, _Traits>::operator<<(unsigned int) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_ostream<_CharT, _Traits>::__ostream_type = std::basic_ostream<char>]\n       operator<<(unsigned int __n)\n       ^\n/usr/include/c++/5/ostream:192:7: note:   no known conversion for argument 1 from ‘Node<double>’ to ‘unsigned int’\n/usr/include/c++/5/ostream:201:7: note: candidate: std::basic_ostream<_CharT, _Traits>::__ostream_type& std::basic_ostream<_CharT, _Traits>::operator<<(long long int) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_ostream<_CharT, _Traits>::__ostream_type = std::basic_ostream<char>]\n       operator<<(long long __n)\n       ^\n/usr/include/c++/5/ostream:201:7: note:   no known conversion for argument 1 from ‘Node<double>’ to ‘long long int’\n/usr/include/c++/5/ostream:205:7: note: candidate: std::basic_ostream<_CharT, _Traits>::__ostream_type& std::basic_ostream<_CharT, _Traits>::operator<<(long long unsigned int) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_ostream<_CharT, _Traits>::__ostream_type = std::basic_ostream<char>]\n       operator<<(unsigned long long __n)\n       ^\n/usr/include/c++/5/ostream:205:7: note:   no known conversion for argument 1 from ‘Node<double>’ to ‘long long unsigned int’\n/usr/include/c++/5/ostream:220:7: note: candidate: std::basic_ostream<_CharT, _Traits>::__ostream_type& std::basic_ostream<_CharT, _Traits>::operator<<(double) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_ostream<_CharT, _Traits>::__ostream_type = std::basic_ostream<char>]\n       operator<<(double __f)\n       ^\n/usr/include/c++/5/ostream:220:7: note:   no known conversion for argument 1 from ‘Node<double>’ to ‘double’\n/usr/include/c++/5/ostream:224:7: note: candidate: std::basic_ostream<_CharT, _Traits>::__ostream_type& std::basic_ostream<_CharT, _Traits>::operator<<(float) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_ostream<_CharT, _Traits>::__ostream_type = std::basic_ostream<char>]\n       operator<<(float __f)\n       ^\n/usr/include/c++/5/ostream:224:7: note:   no known conversion for argument 1 from ‘Node<double>’ to ‘float’\n/usr/include/c++/5/ostream:232:7: note: candidate: std::basic_ostream<_CharT, _Traits>::__ostream_type& std::basic_ostream<_CharT, _Traits>::operator<<(long double) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_ostream<_CharT, _Traits>::__ostream_type = std::basic_ostream<char>]\n       operator<<(long double __f)\n       ^\n/usr/include/c++/5/ostream:232:7: note:   no known conversion for argument 1 from ‘Node<double>’ to ‘long double’\n/usr/include/c++/5/ostream:245:7: note: candidate: std::basic_ostream<_CharT, _Traits>::__ostream_type& std::basic_ostream<_CharT, _Traits>::operator<<(const void*) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_ostream<_CharT, _Traits>::__ostream_type = std::basic_ostream<char>]\n       operator<<(const void* __p)\n       ^\n/usr/include/c++/5/ostream:245:7: note:   no known conversion for argument 1 from ‘Node<double>’ to ‘const void*’\nIn file included from /usr/include/c++/5/ostream:638:0,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/ostream.tcc:119:5: note: candidate: std::basic_ostream<_CharT, _Traits>& std::basic_ostream<_CharT, _Traits>::operator<<(std::basic_ostream<_CharT, _Traits>::__streambuf_type*) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_ostream<_CharT, _Traits>::__streambuf_type = std::basic_streambuf<char>]\n     basic_ostream<_CharT, _Traits>::\n     ^\n/usr/include/c++/5/bits/ostream.tcc:119:5: note:   no known conversion for argument 1 from ‘Node<double>’ to ‘std::basic_ostream<char>::__streambuf_type* {aka std::basic_streambuf<char>*}’\nIn file included from /usr/include/c++/5/string:52:0,\n                 from /usr/include/c++/5/bits/locale_classes.h:40,\n                 from /usr/include/c++/5/bits/ios_base.h:41,\n                 from /usr/include/c++/5/ios:42,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/basic_string.h:5172:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> std::basic_ostream<_CharT, _Traits>& std::operator<<(std::basic_ostream<_CharT, _Traits>&, const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)\n     operator<<(basic_ostream<_CharT, _Traits>& __os,\n     ^\n/usr/include/c++/5/bits/basic_string.h:5172:5: note:   template argument deduction/substitution failed:\nmain.cpp:68:35: note:   ‘Node<double>’ is not derived from ‘const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>’\n   cout << list2.get(list2.size()-1) << endl;\n                                   ^\nIn file included from /usr/include/c++/5/bits/ios_base.h:46:0,\n                 from /usr/include/c++/5/ios:42,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:1:\n/usr/include/c++/5/system_error:209:5: note: candidate: template<class _CharT, class _Traits> std::basic_ostream<_CharT, _Traits>& std::operator<<(std::basic_ostream<_CharT, _Traits>&, const std::error_code&)\n     operator<<(basic_ostream<_CharT, _Traits>& __os, const error_code& __e)\n     ^\n/usr/include/c++/5/system_error:209:5: note:   template argument deduction/substitution failed:\nmain.cpp:68:20: note:   cannot convert ‘list2.LinkedList<E>::get<double>((list2.LinkedList<E>::size<double>() + -1))’ (type ‘Node<double>’) to type ‘const std::error_code&’\n   cout << list2.get(list2.size()-1) << endl;\n                    ^\nIn file included from /usr/include/c++/5/iostream:39:0,\n                 from main.cpp:1:\n/usr/include/c++/5/ostream:497:5: note: candidate: template<class _CharT, class _Traits> std::basic_ostream<_CharT, _Traits>& std::operator<<(std::basic_ostream<_CharT, _Traits>&, _CharT)\n     operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c)\n     ^\n/usr/include/c++/5/ostream:497:5: note:   template argument deduction/substitution failed:\nmain.cpp:68:35: note:   deduced conflicting types for parameter ‘_CharT’ (‘char’ and ‘Node<double>’)\n   cout << list2.get(list2.size()-1) << endl;\n                                   ^\nIn file included from /usr/include/c++/5/iostream:39:0,\n                 from main.cpp:1:\n/usr/include/c++/5/ostream:502:5: note: candidate: template<class _CharT, class _Traits> std::basic_ostream<_CharT, _Traits>& std::operator<<(std::basic_ostream<_CharT, _Traits>&, char)\n     operator<<(basic_ostream<_CharT, _Traits>& __out, char __c)\n     ^\n/usr/include/c++/5/ostream:502:5: note:   template argument deduction/substitution failed:\nmain.cpp:68:20: note:   cannot convert ‘list2.LinkedList<E>::get<double>((list2.LinkedList<E>::size<double>() + -1))’ (type ‘Node<double>’) to type ‘char’\n   cout << list2.get(list2.size()-1) << endl;\n                    ^\nIn file included from /usr/include/c++/5/iostream:39:0,\n                 from main.cpp:1:\n/usr/include/c++/5/ostream:508:5: note: candidate: template<class _Traits> std::basic_ostream<char, _Traits>& std::operator<<(std::basic_ostream<char, _Traits>&, char)\n     operator<<(basic_ostream<char, _Traits>& __out, char __c)\n     ^\n/usr/include/c++/5/ostream:508:5: note:   template argument deduction/substitution failed:\nmain.cpp:68:20: note:   cannot convert ‘list2.LinkedList<E>::get<double>((list2.LinkedList<E>::size<double>() + -1))’ (type ‘Node<double>’) to type ‘char’\n   cout << list2.get(list2.size()-1) << endl;\n                    ^\nIn file included from /usr/include/c++/5/iostream:39:0,\n                 from main.cpp:1:\n/usr/include/c++/5/ostream:514:5: note: candidate: template<class _Traits> std::basic_ostream<char, _Traits>& std::operator<<(std::basic_ostream<char, _Traits>&, signed char)\n     operator<<(basic_ostream<char, _Traits>& __out, signed char __c)\n     ^\n/usr/include/c++/5/ostream:514:5: note:   template argument deduction/substitution failed:\nmain.cpp:68:20: note:   cannot convert ‘list2.LinkedList<E>::get<double>((list2.LinkedList<E>::size<double>() + -1))’ (type ‘Node<double>’) to type ‘signed char’\n   cout << list2.get(list2.size()-1) << endl;\n                    ^\nIn file included from /usr/include/c++/5/iostream:39:0,\n                 from main.cpp:1:\n/usr/include/c++/5/ostream:519:5: note: candidate: template<class _Traits> std::basic_ostream<char, _Traits>& std::operator<<(std::basic_ostream<char, _Traits>&, unsigned char)\n     operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)\n     ^\n/usr/include/c++/5/ostream:519:5: note:   template argument deduction/substitution failed:\nmain.cpp:68:20: note:   cannot convert ‘list2.LinkedList<E>::get<double>((list2.LinkedList<E>::size<double>() + -1))’ (type ‘Node<double>’) to type ‘unsigned char’\n   cout << list2.get(list2.size()-1) << endl;\n                    ^\nIn file included from /usr/include/c++/5/iostream:39:0,\n                 from main.cpp:1:\n/usr/include/c++/5/ostream:539:5: note: candidate: template<class _CharT, class _Traits> std::basic_ostream<_CharT, _Traits>& std::operator<<(std::basic_ostream<_CharT, _Traits>&, const _CharT*)\n     operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s)\n     ^\n/usr/include/c++/5/ostream:539:5: note:   template argument deduction/substitution failed:\nmain.cpp:68:35: note:   mismatched types ‘const _CharT*’ and ‘Node<double>’\n   cout << list2.get(list2.size()-1) << endl;\n                                   ^\nIn file included from /usr/include/c++/5/ostream:638:0,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/ostream.tcc:321:5: note: candidate: template<class _CharT, class _Traits> std::basic_ostream<_CharT, _Traits>& std::operator<<(std::basic_ostream<_CharT, _Traits>&, const char*)\n     operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s)\n     ^\n/usr/include/c++/5/bits/ostream.tcc:321:5: note:   template argument deduction/substitution failed:\nmain.cpp:68:20: note:   cannot convert ‘list2.LinkedList<E>::get<double>((list2.LinkedList<E>::size<double>() + -1))’ (type ‘Node<double>’) to type ‘const char*’\n   cout << list2.get(list2.size()-1) << endl;\n                    ^\nIn file included from /usr/include/c++/5/iostream:39:0,\n                 from main.cpp:1:\n/usr/include/c++/5/ostream:556:5: note: candidate: template<class _Traits> std::basic_ostream<char, _Traits>& std::operator<<(std::basic_ostream<char, _Traits>&, const char*)\n     operator<<(basic_ostream<char, _Traits>& __out, const char* __s)\n     ^\n/usr/include/c++/5/ostream:556:5: note:   template argument deduction/substitution failed:\nmain.cpp:68:20: note:   cannot convert ‘list2.LinkedList<E>::get<double>((list2.LinkedList<E>::size<double>() + -1))’ (type ‘Node<double>’) to type ‘const char*’\n   cout << list2.get(list2.size()-1) << endl;\n                    ^\nIn file included from /usr/include/c++/5/iostream:39:0,\n                 from main.cpp:1:\n/usr/include/c++/5/ostream:569:5: note: candidate: template<class _Traits> std::basic_ostream<char, _Traits>& std::operator<<(std::basic_ostream<char, _Traits>&, const signed char*)\n     operator<<(basic_ostream<char, _Traits>& __out, const signed char* __s)\n     ^\n/usr/include/c++/5/ostream:569:5: note:   template argument deduction/substitution failed:\nmain.cpp:68:20: note:   cannot convert ‘list2.LinkedList<E>::get<double>((list2.LinkedList<E>::size<double>() + -1))’ (type ‘Node<double>’) to type ‘const signed char*’\n   cout << list2.get(list2.size()-1) << endl;\n                    ^\nIn file included from /usr/include/c++/5/iostream:39:0,\n                 from main.cpp:1:\n/usr/include/c++/5/ostream:574:5: note: candidate: template<class _Traits> std::basic_ostream<char, _Traits>& std::operator<<(std::basic_ostream<char, _Traits>&, const unsigned char*)\n     operator<<(basic_ostream<char, _Traits>& __out, const unsigned char* __s)\n     ^\n/usr/include/c++/5/ostream:574:5: note:   template argument deduction/substitution failed:\nmain.cpp:68:20: note:   cannot convert ‘list2.LinkedList<E>::get<double>((list2.LinkedList<E>::size<double>() + -1))’ (type ‘Node<double>’) to type ‘const unsigned char*’\n   cout << list2.get(list2.size()-1) << endl;\n                    ^\nIn file included from /usr/include/c++/5/iostream:39:0,\n                 from main.cpp:1:\n/usr/include/c++/5/ostream:628:5: note: candidate: std::basic_ostream<_CharT, _Traits>& std::operator<<(std::basic_ostream<_CharT, _Traits>&&, const _Tp&) [with _CharT = char; _Traits = std::char_traits<char>; _Tp = Node<double>] <near match>\n     operator<<(basic_ostream<_CharT, _Traits>&& __os, const _Tp& __x)\n     ^\n/usr/include/c++/5/ostream:628:5: note:   conversion of argument 1 would be ill-formed:\nmain.cpp:68:35: error: cannot bind ‘std::ostream {aka std::basic_ostream<char>}’ lvalue to ‘std::basic_ostream<char>&&’\n   cout << list2.get(list2.size()-1) << endl;\n                                   ^\nmain.cpp:72:8: error: no match for ‘operator<<’ (operand types are ‘std::ostream {aka std::basic_ostream<char>}’ and ‘Node<double>’)\n   cout << list2.get(0) << endl;\n        ^\nIn file included from /usr/include/c++/5/iostream:39:0,\n                 from main.cpp:1:\n/usr/include/c++/5/ostream:108:7: note: candidate: std::basic_ostream<_CharT, _Traits>::__ostream_type& std::basic_ostream<_CharT, _Traits>::operator<<(std::basic_ostream<_CharT, _Traits>::__ostream_type& (*)(std::basic_ostream<_CharT, _Traits>::__ostream_type&)) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_ostream<_CharT, _Traits>::__ostream_type = std::basic_ostream<char>]\n       operator<<(__ostream_type& (*__pf)(__ostream_type&))\n       ^\n/usr/include/c++/5/ostream:108:7: note:   no known conversion for argument 1 from ‘Node<double>’ to ‘std::basic_ostream<char>::__ostream_type& (*)(std::basic_ostream<char>::__ostream_type&) {aka std::basic_ostream<char>& (*)(std::basic_ostream<char>&)}’\n/usr/include/c++/5/ostream:117:7: note: candidate: std::basic_ostream<_CharT, _Traits>::__ostream_type& std::basic_ostream<_CharT, _Traits>::operator<<(std::basic_ostream<_CharT, _Traits>::__ios_type& (*)(std::basic_ostream<_CharT, _Traits>::__ios_type&)) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_ostream<_CharT, _Traits>::__ostream_type = std::basic_ostream<char>; std::basic_ostream<_CharT, _Traits>::__ios_type = std::basic_ios<char>]\n       operator<<(__ios_type& (*__pf)(__ios_type&))\n       ^\n/usr/include/c++/5/ostream:117:7: note:   no known conversion for argument 1 from ‘Node<double>’ to ‘std::basic_ostream<char>::__ios_type& (*)(std::basic_ostream<char>::__ios_type&) {aka std::basic_ios<char>& (*)(std::basic_ios<char>&)}’\n/usr/include/c++/5/ostream:127:7: note: candidate: std::basic_ostream<_CharT, _Traits>::__ostream_type& std::basic_ostream<_CharT, _Traits>::operator<<(std::ios_base& (*)(std::ios_base&)) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_ostream<_CharT, _Traits>::__ostream_type = std::basic_ostream<char>]\n       operator<<(ios_base& (*__pf) (ios_base&))\n       ^\n/usr/include/c++/5/ostream:127:7: note:   no known conversion for argument 1 from ‘Node<double>’ to ‘std::ios_base& (*)(std::ios_base&)’\n/usr/include/c++/5/ostream:166:7: note: candidate: std::basic_ostream<_CharT, _Traits>::__ostream_type& std::basic_ostream<_CharT, _Traits>::operator<<(long int) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_ostream<_CharT, _Traits>::__ostream_type = std::basic_ostream<char>]\n       operator<<(long __n)\n       ^\n/usr/include/c++/5/ostream:166:7: note:   no known conversion for argument 1 from ‘Node<double>’ to ‘long int’\n/usr/include/c++/5/ostream:170:7: note: candidate: std::basic_ostream<_CharT, _Traits>::__ostream_type& std::basic_ostream<_CharT, _Traits>::operator<<(long unsigned int) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_ostream<_CharT, _Traits>::__ostream_type = std::basic_ostream<char>]\n       operator<<(unsigned long __n)\n       ^\n/usr/include/c++/5/ostream:170:7: note:   no known conversion for argument 1 from ‘Node<double>’ to ‘long unsigned int’\n/usr/include/c++/5/ostream:174:7: note: candidate: std::basic_ostream<_CharT, _Traits>::__ostream_type& std::basic_ostream<_CharT, _Traits>::operator<<(bool) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_ostream<_CharT, _Traits>::__ostream_type = std::basic_ostream<char>]\n       operator<<(bool __n)\n       ^\n/usr/include/c++/5/ostream:174:7: note:   no known conversion for argument 1 from ‘Node<double>’ to ‘bool’\nIn file included from /usr/include/c++/5/ostream:638:0,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/ostream.tcc:91:5: note: candidate: std::basic_ostream<_CharT, _Traits>& std::basic_ostream<_CharT, _Traits>::operator<<(short int) [with _CharT = char; _Traits = std::char_traits<char>]\n     basic_ostream<_CharT, _Traits>::\n     ^\n/usr/include/c++/5/bits/ostream.tcc:91:5: note:   no known conversion for argument 1 from ‘Node<double>’ to ‘short int’\nIn file included from /usr/include/c++/5/iostream:39:0,\n                 from main.cpp:1:\n/usr/include/c++/5/ostream:181:7: note: candidate: std::basic_ostream<_CharT, _Traits>::__ostream_type& std::basic_ostream<_CharT, _Traits>::operator<<(short unsigned int) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_ostream<_CharT, _Traits>::__ostream_type = std::basic_ostream<char>]\n       operator<<(unsigned short __n)\n       ^\n/usr/include/c++/5/ostream:181:7: note:   no known conversion for argument 1 from ‘Node<double>’ to ‘short unsigned int’\nIn file included from /usr/include/c++/5/ostream:638:0,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/ostream.tcc:105:5: note: candidate: std::basic_ostream<_CharT, _Traits>& std::basic_ostream<_CharT, _Traits>::operator<<(int) [with _CharT = char; _Traits = std::char_traits<char>]\n     basic_ostream<_CharT, _Traits>::\n     ^\n/usr/include/c++/5/bits/ostream.tcc:105:5: note:   no known conversion for argument 1 from ‘Node<double>’ to ‘int’\nIn file included from /usr/include/c++/5/iostream:39:0,\n                 from main.cpp:1:\n/usr/include/c++/5/ostream:192:7: note: candidate: std::basic_ostream<_CharT, _Traits>::__ostream_type& std::basic_ostream<_CharT, _Traits>::operator<<(unsigned int) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_ostream<_CharT, _Traits>::__ostream_type = std::basic_ostream<char>]\n       operator<<(unsigned int __n)\n       ^\n/usr/include/c++/5/ostream:192:7: note:   no known conversion for argument 1 from ‘Node<double>’ to ‘unsigned int’\n/usr/include/c++/5/ostream:201:7: note: candidate: std::basic_ostream<_CharT, _Traits>::__ostream_type& std::basic_ostream<_CharT, _Traits>::operator<<(long long int) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_ostream<_CharT, _Traits>::__ostream_type = std::basic_ostream<char>]\n       operator<<(long long __n)\n       ^\n/usr/include/c++/5/ostream:201:7: note:   no known conversion for argument 1 from ‘Node<double>’ to ‘long long int’\n/usr/include/c++/5/ostream:205:7: note: candidate: std::basic_ostream<_CharT, _Traits>::__ostream_type& std::basic_ostream<_CharT, _Traits>::operator<<(long long unsigned int) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_ostream<_CharT, _Traits>::__ostream_type = std::basic_ostream<char>]\n       operator<<(unsigned long long __n)\n       ^\n/usr/include/c++/5/ostream:205:7: note:   no known conversion for argument 1 from ‘Node<double>’ to ‘long long unsigned int’\n/usr/include/c++/5/ostream:220:7: note: candidate: std::basic_ostream<_CharT, _Traits>::__ostream_type& std::basic_ostream<_CharT, _Traits>::operator<<(double) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_ostream<_CharT, _Traits>::__ostream_type = std::basic_ostream<char>]\n       operator<<(double __f)\n       ^\n/usr/include/c++/5/ostream:220:7: note:   no known conversion for argument 1 from ‘Node<double>’ to ‘double’\n/usr/include/c++/5/ostream:224:7: note: candidate: std::basic_ostream<_CharT, _Traits>::__ostream_type& std::basic_ostream<_CharT, _Traits>::operator<<(float) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_ostream<_CharT, _Traits>::__ostream_type = std::basic_ostream<char>]\n       operator<<(float __f)\n       ^\n/usr/include/c++/5/ostream:224:7: note:   no known conversion for argument 1 from ‘Node<double>’ to ‘float’\n/usr/include/c++/5/ostream:232:7: note: candidate: std::basic_ostream<_CharT, _Traits>::__ostream_type& std::basic_ostream<_CharT, _Traits>::operator<<(long double) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_ostream<_CharT, _Traits>::__ostream_type = std::basic_ostream<char>]\n       operator<<(long double __f)\n       ^\n/usr/include/c++/5/ostream:232:7: note:   no known conversion for argument 1 from ‘Node<double>’ to ‘long double’\n/usr/include/c++/5/ostream:245:7: note: candidate: std::basic_ostream<_CharT, _Traits>::__ostream_type& std::basic_ostream<_CharT, _Traits>::operator<<(const void*) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_ostream<_CharT, _Traits>::__ostream_type = std::basic_ostream<char>]\n       operator<<(const void* __p)\n       ^\n/usr/include/c++/5/ostream:245:7: note:   no known conversion for argument 1 from ‘Node<double>’ to ‘const void*’\nIn file included from /usr/include/c++/5/ostream:638:0,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/ostream.tcc:119:5: note: candidate: std::basic_ostream<_CharT, _Traits>& std::basic_ostream<_CharT, _Traits>::operator<<(std::basic_ostream<_CharT, _Traits>::__streambuf_type*) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_ostream<_CharT, _Traits>::__streambuf_type = std::basic_streambuf<char>]\n     basic_ostream<_CharT, _Traits>::\n     ^\n/usr/include/c++/5/bits/ostream.tcc:119:5: note:   no known conversion for argument 1 from ‘Node<double>’ to ‘std::basic_ostream<char>::__streambuf_type* {aka std::basic_streambuf<char>*}’\nIn file included from /usr/include/c++/5/string:52:0,\n                 from /usr/include/c++/5/bits/locale_classes.h:40,\n                 from /usr/include/c++/5/bits/ios_base.h:41,\n                 from /usr/include/c++/5/ios:42,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/basic_string.h:5172:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> std::basic_ostream<_CharT, _Traits>& std::operator<<(std::basic_ostream<_CharT, _Traits>&, const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)\n     operator<<(basic_ostream<_CharT, _Traits>& __os,\n     ^\n/usr/include/c++/5/bits/basic_string.h:5172:5: note:   template argument deduction/substitution failed:\nmain.cpp:72:22: note:   ‘Node<double>’ is not derived from ‘const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>’\n   cout << list2.get(0) << endl;\n                      ^\nIn file included from /usr/include/c++/5/bits/ios_base.h:46:0,\n                 from /usr/include/c++/5/ios:42,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:1:\n/usr/include/c++/5/system_error:209:5: note: candidate: template<class _CharT, class _Traits> std::basic_ostream<_CharT, _Traits>& std::operator<<(std::basic_ostream<_CharT, _Traits>&, const std::error_code&)\n     operator<<(basic_ostream<_CharT, _Traits>& __os, const error_code& __e)\n     ^\n/usr/include/c++/5/system_error:209:5: note:   template argument deduction/substitution failed:\nmain.cpp:72:20: note:   cannot convert ‘list2.LinkedList<E>::get<double>(0)’ (type ‘Node<double>’) to type ‘const std::error_code&’\n   cout << list2.get(0) << endl;\n                    ^\nIn file included from /usr/include/c++/5/iostream:39:0,\n                 from main.cpp:1:\n/usr/include/c++/5/ostream:497:5: note: candidate: template<class _CharT, class _Traits> std::basic_ostream<_CharT, _Traits>& std::operator<<(std::basic_ostream<_CharT, _Traits>&, _CharT)\n     operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c)\n     ^\n/usr/include/c++/5/ostream:497:5: note:   template argument deduction/substitution failed:\nmain.cpp:72:22: note:   deduced conflicting types for parameter ‘_CharT’ (‘char’ and ‘Node<double>’)\n   cout << list2.get(0) << endl;\n                      ^\nIn file included from /usr/include/c++/5/iostream:39:0,\n                 from main.cpp:1:\n/usr/include/c++/5/ostream:502:5: note: candidate: template<class _CharT, class _Traits> std::basic_ostream<_CharT, _Traits>& std::operator<<(std::basic_ostream<_CharT, _Traits>&, char)\n     operator<<(basic_ostream<_CharT, _Traits>& __out, char __c)\n     ^\n/usr/include/c++/5/ostream:502:5: note:   template argument deduction/substitution failed:\nmain.cpp:72:20: note:   cannot convert ‘list2.LinkedList<E>::get<double>(0)’ (type ‘Node<double>’) to type ‘char’\n   cout << list2.get(0) << endl;\n                    ^\nIn file included from /usr/include/c++/5/iostream:39:0,\n                 from main.cpp:1:\n/usr/include/c++/5/ostream:508:5: note: candidate: template<class _Traits> std::basic_ostream<char, _Traits>& std::operator<<(std::basic_ostream<char, _Traits>&, char)\n     operator<<(basic_ostream<char, _Traits>& __out, char __c)\n     ^\n/usr/include/c++/5/ostream:508:5: note:   template argument deduction/substitution failed:\nmain.cpp:72:20: note:   cannot convert ‘list2.LinkedList<E>::get<double>(0)’ (type ‘Node<double>’) to type ‘char’\n   cout << list2.get(0) << endl;\n                    ^\nIn file included from /usr/include/c++/5/iostream:39:0,\n                 from main.cpp:1:\n/usr/include/c++/5/ostream:514:5: note: candidate: template<class _Traits> std::basic_ostream<char, _Traits>& std::operator<<(std::basic_ostream<char, _Traits>&, signed char)\n     operator<<(basic_ostream<char, _Traits>& __out, signed char __c)\n     ^\n/usr/include/c++/5/ostream:514:5: note:   template argument deduction/substitution failed:\nmain.cpp:72:20: note:   cannot convert ‘list2.LinkedList<E>::get<double>(0)’ (type ‘Node<double>’) to type ‘signed char’\n   cout << list2.get(0) << endl;\n                    ^\nIn file included from /usr/include/c++/5/iostream:39:0,\n                 from main.cpp:1:\n/usr/include/c++/5/ostream:519:5: note: candidate: template<class _Traits> std::basic_ostream<char, _Traits>& std::operator<<(std::basic_ostream<char, _Traits>&, unsigned char)\n     operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)\n     ^\n/usr/include/c++/5/ostream:519:5: note:   template argument deduction/substitution failed:\nmain.cpp:72:20: note:   cannot convert ‘list2.LinkedList<E>::get<double>(0)’ (type ‘Node<double>’) to type ‘unsigned char’\n   cout << list2.get(0) << endl;\n                    ^\nIn file included from /usr/include/c++/5/iostream:39:0,\n                 from main.cpp:1:\n/usr/include/c++/5/ostream:539:5: note: candidate: template<class _CharT, class _Traits> std::basic_ostream<_CharT, _Traits>& std::operator<<(std::basic_ostream<_CharT, _Traits>&, const _CharT*)\n     operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s)\n     ^\n/usr/include/c++/5/ostream:539:5: note:   template argument deduction/substitution failed:\nmain.cpp:72:22: note:   mismatched types ‘const _CharT*’ and ‘Node<double>’\n   cout << list2.get(0) << endl;\n                      ^\nIn file included from /usr/include/c++/5/ostream:638:0,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/ostream.tcc:321:5: note: candidate: template<class _CharT, class _Traits> std::basic_ostream<_CharT, _Traits>& std::operator<<(std::basic_ostream<_CharT, _Traits>&, const char*)\n     operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s)\n     ^\n/usr/include/c++/5/bits/ostream.tcc:321:5: note:   template argument deduction/substitution failed:\nmain.cpp:72:20: note:   cannot convert ‘list2.LinkedList<E>::get<double>(0)’ (type ‘Node<double>’) to type ‘const char*’\n   cout << list2.get(0) << endl;\n                    ^\nIn file included from /usr/include/c++/5/iostream:39:0,\n                 from main.cpp:1:\n/usr/include/c++/5/ostream:556:5: note: candidate: template<class _Traits> std::basic_ostream<char, _Traits>& std::operator<<(std::basic_ostream<char, _Traits>&, const char*)\n     operator<<(basic_ostream<char, _Traits>& __out, const char* __s)\n     ^\n/usr/include/c++/5/ostream:556:5: note:   template argument deduction/substitution failed:\nmain.cpp:72:20: note:   cannot convert ‘list2.LinkedList<E>::get<double>(0)’ (type ‘Node<double>’) to type ‘const char*’\n   cout << list2.get(0) << endl;\n                    ^\nIn file included from /usr/include/c++/5/iostream:39:0,\n                 from main.cpp:1:\n/usr/include/c++/5/ostream:569:5: note: candidate: template<class _Traits> std::basic_ostream<char, _Traits>& std::operator<<(std::basic_ostream<char, _Traits>&, const signed char*)\n     operator<<(basic_ostream<char, _Traits>& __out, const signed char* __s)\n     ^\n/usr/include/c++/5/ostream:569:5: note:   template argument deduction/substitution failed:\nmain.cpp:72:20: note:   cannot convert ‘list2.LinkedList<E>::get<double>(0)’ (type ‘Node<double>’) to type ‘const signed char*’\n   cout << list2.get(0) << endl;\n                    ^\nIn file included from /usr/include/c++/5/iostream:39:0,\n                 from main.cpp:1:\n/usr/include/c++/5/ostream:574:5: note: candidate: template<class _Traits> std::basic_ostream<char, _Traits>& std::operator<<(std::basic_ostream<char, _Traits>&, const unsigned char*)\n     operator<<(basic_ostream<char, _Traits>& __out, const unsigned char* __s)\n     ^\n/usr/include/c++/5/ostream:574:5: note:   template argument deduction/substitution failed:\nmain.cpp:72:20: note:   cannot convert ‘list2.LinkedList<E>::get<double>(0)’ (type ‘Node<double>’) to type ‘const unsigned char*’\n   cout << list2.get(0) << endl;\n                    ^\nIn file included from /usr/include/c++/5/iostream:39:0,\n                 from main.cpp:1:\n/usr/include/c++/5/ostream:628:5: note: candidate: std::basic_ostream<_CharT, _Traits>& std::operator<<(std::basic_ostream<_CharT, _Traits>&&, const _Tp&) [with _CharT = char; _Traits = std::char_traits<char>; _Tp = Node<double>] <near match>\n     operator<<(basic_ostream<_CharT, _Traits>&& __os, const _Tp& __x)\n     ^\n/usr/include/c++/5/ostream:628:5: note:   conversion of argument 1 would be ill-formed:\nmain.cpp:72:22: error: cannot bind ‘std::ostream {aka std::basic_ostream<char>}’ lvalue to ‘std::basic_ostream<char>&&’\n   cout << list2.get(0) << endl;\n                      ^\nIn file included from main.cpp:46:0:\nsource.cpp: In instantiation of ‘void LinkedList<E>::add(int, const E&) [with E = double]’:\nsource.cpp:50:6:   required from ‘void LinkedList<E>::addFirst(const E&) [with E = double]’\nmain.cpp:56:21:   required from here\nsource.cpp:39:41: error: operands to ?: have different types ‘int’ and ‘Node<double>’\n   Node<E> * next_node = (index == _size ? 0 : get_node(index));\n                                         ^\nmain.cpp:7:7: error: ‘long int Node<double>::prev_xor_next’ is private\n  long prev_xor_next;\n       ^\nIn file included from main.cpp:46:0:\nsource.cpp:41:25: error: within this context\n   node -> prev_xor_next = (long) next_node ^ (long) prev_node;\n                         ^\nmain.cpp:7:7: error: ‘long int Node<double>::prev_xor_next’ is private\n  long prev_xor_next;\n       ^\nIn file included from main.cpp:46:0:\nsource.cpp:42:49: error: within this context\n   if(prev_node != 0) prev_node -> prev_xor_next = (long) (prev_node -> prev_node(next_node)) ^ (long) node;\n                                                 ^\nmain.cpp:7:7: error: ‘long int Node<double>::prev_xor_next’ is private\n  long prev_xor_next;\n       ^\nIn file included from main.cpp:46:0:\nsource.cpp:43:49: error: within this context\n   if(next_node != 0) next_node -> prev_xor_next = (long) (next_node -> next_node(prev_node)) ^ (long) node;\n                                                 ^\nsource.cpp: In instantiation of ‘void LinkedList<E>::remove(int) [with E = double]’:\nsource.cpp:94:9:   required from ‘void LinkedList<E>::removeFirstOccurrence(E) [with E = double]’\nmain.cpp:66:33:   required from here\nsource.cpp:62:27: error: cannot convert ‘Node<double>’ to ‘Node<double>*’ in assignment\n   if(index > 0) prev_node = get_node(index - 1);\n                           ^\nsource.cpp:64:34: error: cannot convert ‘Node<double>’ to ‘Node<double>*’ in initialization\n   Node<E> * node = get_node(index);\n                                  ^\nmain.cpp:7:7: error: ‘long int Node<double>::prev_xor_next’ is private\n  long prev_xor_next;\n       ^\nIn file included from main.cpp:46:0:\nsource.cpp:66:49: error: within this context\n   if(prev_node != 0) prev_node -> prev_xor_next = (long) (prev_node -> prev_node(node)) ^ (long) next_node;\n                                                 ^\nmain.cpp:7:7: error: ‘long int Node<double>::prev_xor_next’ is private\n  long prev_xor_next;\n       ^\nIn file included from main.cpp:46:0:\nsource.cpp:67:49: error: within this context\n   if(next_node != 0) next_node -> prev_xor_next = (long) (next_node -> next_node(node)) ^ (long) prev_node;\n                                                 ^\nsource.cpp: In instantiation of ‘Node<E>& LinkedList<E>::get_node(int) [with E = double]’:\nsource.cpp:30:18:   required from ‘Node<E>& LinkedList<E>::get(int) [with E = double]’\nmain.cpp:68:35:   required from here\nsource.cpp:10:9: error: no match for ‘operator=’ (operand types are ‘Node<double>’ and ‘Node<double>*’)\n    node = head;\n         ^\nmain.cpp:5:7: note: candidate: Node<double>& Node<double>::operator=(const Node<double>&)\n class Node\n       ^\nmain.cpp:5:7: note:   no known conversion for argument 1 from ‘Node<double>*’ to ‘const Node<double>&’\nmain.cpp:5:7: note: candidate: Node<double>& Node<double>::operator=(Node<double>&&)\nmain.cpp:5:7: note:   no known conversion for argument 1 from ‘Node<double>*’ to ‘Node<double>&&’\nIn file included from main.cpp:46:0:\nsource.cpp:12:21: error: cannot convert ‘Node<double>’ to ‘Node<double>*’ in initialization\n     Node<E> * tmp = node;\n                     ^\nsource.cpp:13:12: error: base operand of ‘->’ has non-pointer type ‘Node<double>’\n     node = node -> next_node(last);\n            ^\nsource.cpp:19:9: error: no match for ‘operator=’ (operand types are ‘Node<double>’ and ‘Node<double>*’)\n    node = tail;\n         ^\nmain.cpp:5:7: note: candidate: Node<double>& Node<double>::operator=(const Node<double>&)\n class Node\n       ^\nmain.cpp:5:7: note:   no known conversion for argument 1 from ‘Node<double>*’ to ‘const Node<double>&’\nmain.cpp:5:7: note: candidate: Node<double>& Node<double>::operator=(Node<double>&&)\nmain.cpp:5:7: note:   no known conversion for argument 1 from ‘Node<double>*’ to ‘Node<double>&&’\nIn file included from main.cpp:46:0:\nsource.cpp:21:21: error: cannot convert ‘Node<double>’ to ‘Node<double>*’ in initialization\n     Node<E> * tmp = node;\n                     ^\nsource.cpp:22:12: error: base operand of ‘->’ has non-pointer type ‘Node<double>’\n     node = node -> prev_node(last);\n            ^\nsource.cpp:7:11: warning: reference to local variable ‘node’ returned [-Wreturn-local-addr]\n   Node<E> node;\n           ^\n"
        ],
        [
            "A.4 (C++)",
            "潘文轩",
            "#include <iostream>\n#include <string>\n#include <vector>\n#include <typeinfo>\nusing namespace std;\n\nconst int initial_size = 40;\n\nclass NoSuchKeyException {};\nclass NoSuchValueException {};\n\nsize_t circular_shift(size_t bits, int shift_bits) {\n\tconst int num_bits = 8 * sizeof(size_t);\n\tshift_bits = shift_bits % num_bits;\n\treturn bits << shift_bits | bits >> (num_bits - shift_bits);\n}\n\nsize_t hash_function(const string & key) {\n\tsize_t code = 0;\n\tfor(int i = 0; i < key.size(); i ++) {\n\t\tcode ^= circular_shift(key[i], i * 5);\n\t}\n\treturn code;\n}\n\nsize_t hash_function(const int & key) {\n\tsize_t code = 0;\n\tint tmp = key;\n\tfor(int i = 0; tmp > 0; tmp /= 10, i ++) {\n\t\tcode ^= circular_shift(tmp % 10, i * 5);\n\t}\n\treturn code;\n}\n\nclass HT {\n\tclass Tuple {\n\tpublic:\n\t\tstring key_string;\n\t\tint key_int;\n\t\tstring value_string;\n\t\tint value_int;\n\t\tbool string_in_use;\n\t\tbool int_in_use;\n\n\t\tTuple(): string_in_use(false), int_in_use(false), value_int(0) {}\n\t};\n\n\tclass RefTuple {\n\tpublic:\n\t\tHT * hash_table;\n\t\tTuple * tuple;\n\t\tstring key_string;\n\t\tint key_int;\n\n\t\tRefTuple(HT * ht, Tuple * tp, string key_string): hash_table(ht), tuple(tp), key_string(key_string) {}\n\n\t\tRefTuple(HT * ht, Tuple * tp, int key_int): hash_table(ht), tuple(tp), key_int(key_int) {}\n\n\t\toperator string() {\n\t\t\tif(tuple == NULL) throw NoSuchKeyException();\n\t\t\treturn tuple -> value_string;\n\t\t}\n\n\t\toperator int() {\n\t\t\tif(tuple == NULL) throw NoSuchValueException();\n\t\t\treturn tuple -> value_int;\n\t\t}\n\t};\n\n\tvector<Tuple> tuples;\n\tsize_t _size;\npublic:\n\tHT() {\n\t\t_size = 0;\n\t\ttuples.resize(initial_size);\n\t}\n\n\tsize_t size() {return _size;}\n\n\ttemplate <typename K>\n\tsize_t canonical_index(const K & key) const {\n\t\tsize_t hash_code = hash_function(key);\n\t\treturn hash_code % tuples.size();\n\t}\n\n\tsize_t indexOfKey(const string & key) const {\n\t\tsize_t index = canonical_index(key);\n\t\twhile(true) {\n\t\t\tif(!tuples[index].string_in_use) return index;\n\t\t\tif(tuples[index].key_string == key) return index;\n\t\t\tindex = (index + 1) % tuples.size();\n\t\t}\n\t}\n\n\tsize_t indexOfKey(const int & key) const {\n\t\tsize_t index = canonical_index(key);\n\t\twhile(true) {\n\t\t\tif(!tuples[index].int_in_use) return index;\n\t\t\tif(tuples[index].key_int == key) return index;\n\t\t\tindex = (index + 1) % tuples.size();\n\t\t}\n\t}\n\n\tstring To_string(int value) {\n\t\tint temp = value;\n\t\tstring s;\n\t\tfor(int i = 0; temp > 0; temp /= 10, i ++) {\n\t\t\ts += temp % 10;\n\t\t}\n\t\treturn s;\n\t}\n\n\tvoid put(const string & key, string & value) {\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].key_string = key;\n\t\ttuples[index].value_string = value;\n\t\tif(tuples[index].string_in_use) return;\n\t\ttuples[index].string_in_use = true;\n\t\t_size ++;\n\t\tif(2 * _size > tuples.size()) _double_tuples();\n\t}\n\n\tvoid put(const string & key, int & value) {\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].key_string = key;\n\t\ttuples[index].value_int = value;\n\t\ttuples[index].value_string = To_string(value);\n\t\tif(tuples[index].string_in_use) return;\n\t\ttuples[index].string_in_use = true;\n\t\t_size ++;\n\t\tif(2 * _size > tuples.size()) _double_tuples();\n\t}\n\n\tvoid put(int key, string & value) {\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].key_int = key;\n\t\ttuples[index].value_string = value;\n\t\tif(tuples[index].int_in_use) return;\n\t\ttuples[index].int_in_use = true;\n\t\t_size ++;\n\t\tif(2 * _size > tuples.size()) _double_tuples();\n\t}\n\n\tvoid put(int key, int & value) {\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].key_int = key;\n\t\ttuples[index].value_int = value;\n\t\ttuples[index].value_string = To_string(value);\n\t\tif(tuples[index].int_in_use) return;\n\t\ttuples[index].int_in_use = true;\n\t\t_size ++;\n\t\tif(2 * _size > tuples.size()) _double_tuples();\n\t}\n\n\tvoid _double_tuples() {\n\t\tvector<Tuple> non_empty_tuples;\n\t\tfor(int i = 0; i < tuples.size(); i ++) {\n\t\t\tif(tuples[i].string_in_use || tuples[i].int_in_use) {\n\t\t\t\tnon_empty_tuples.push_back(tuples[i]);\n\t\t\t}\n\t\t\ttuples[i].string_in_use = false;\n\t\t\ttuples[i].int_in_use = false;\n\t\t}\n\t\ttuples.resize(2 * tuples.size());\n\t\tfor(int i = 0; i < non_empty_tuples.size(); i ++) {\n\t\t\tif(non_empty_tuples[i].string_in_use) {\n\t\t\t\tput(non_empty_tuples[i].key_string, non_empty_tuples[i].value_string);\n\t\t\t}\n\t\t\tif(non_empty_tuples[i].int_in_use) {\n\t\t\t\tput(non_empty_tuples[i].key_int, non_empty_tuples[i].value_int);\n\t\t\t}\n\t\t}\n\t}\n\n\ttemplate <typename K>\n\tRefTuple operator[] (const K & key) {\n\t\tsize_t index = indexOfKey(key);\n\t\tif(!tuples[index].int_in_use && !tuples[index].string_in_use) return RefTuple(this, NULL, key);\n\t\treturn RefTuple(this, &tuples[index], key);\n\t}\n\n\ttemplate <typename K>\n\tconst RefTuple operator[] (const K & key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\tif(!tuples[index].int_in_use && !tuples[index].string_in_use) return RefTuple(this, NULL, key);\n\t\treturn RefTuple(this, &tuples[index], key);\n\t}\n};",
            1595395714.7207193,
            100,
            "# 答案正确"
        ],
        [
            "A.5 (C++)",
            "潘文轩",
            "#include <iostream>\n#include <string>\n#include <vector>\n#include <typeinfo>\nusing namespace std;\n\nconst int initial_size = 40;\n\nclass NoSuchKeyException {};\nclass NoSuchValueException {};\n\nsize_t circular_shift(size_t bits, int shift_bits) {\n\tconst int num_bits = 8 * sizeof(size_t);\n\tshift_bits = shift_bits % num_bits;\n\treturn bits << shift_bits | bits >> (num_bits - shift_bits);\n}\n\nsize_t hash_function(const string & key) {\n\tsize_t code = 0;\n\tfor(int i = 0; i < key.size(); i ++) {\n\t\tcode ^= circular_shift(key[i], i * 5);\n\t}\n\treturn code;\n}\n\nsize_t hash_function(const int & key) {\n\tsize_t code = 0;\n\tint tmp = key;\n\tfor(int i = 0; tmp > 0; tmp /= 10, i ++) {\n\t\tcode ^= circular_shift(tmp % 10, i * 5);\n\t}\n\treturn code;\n}\n\nclass HT {\n\tclass Tuple {\n\tpublic:\n\t\tstring key_string;\n\t\tint key_int;\n\t\tstring value_string;\n\t\tint value_int;\n\t\tbool string_in_use;\n\t\tbool int_in_use;\n\n\t\tTuple(): string_in_use(false), int_in_use(false), value_int(0) {}\n\t};\n\n\tclass RefTuple {\n\tpublic:\n\t\tHT * hash_table;\n\t\tTuple * tuple;\n\t\tstring key_string;\n\t\tint key_int;\n\n\t\tRefTuple(HT * ht, Tuple * tp, string key_string): hash_table(ht), tuple(tp), key_string(key_string) {}\n\n\t\tRefTuple(HT * ht, Tuple * tp, int key_int): hash_table(ht), tuple(tp), key_int(key_int) {}\n\n\t\toperator string() {\n\t\t\tif(tuple == NULL) throw NoSuchKeyException();\n\t\t\treturn tuple -> value_string;\n\t\t}\n\n\t\toperator int() {\n\t\t\tif(tuple == NULL) throw NoSuchValueException();\n\t\t\treturn tuple -> value_int;\n\t\t}\n\n\t\tRefTuple & operator = (const int value) {\n\t\t\tif(tuple == NULL) {\n\t\t\t\tif(key_string.size() == 0) {\n\t\t\t\t\thash_table -> put(key_int, value);\n\t\t\t\t}\n\t\t\t\telse hash_table -> put(key_string, value);\n\t\t\t}\n\t\t\telse tuple -> value_int = value;\n\t\t\treturn *this;\n\t\t}\n\n\t\tRefTuple & operator = (const string & value) {\n\t\t\tif(tuple == NULL) {\n\t\t\t\tif(key_string.size() == 0) {\n\t\t\t\t\thash_table -> put(key_int, value);\n\t\t\t\t}\n\t\t\t\telse hash_table -> put(key_string, value);\n\t\t\t}\n\t\t\telse tuple -> value_string = value;\n\t\t\treturn *this;\n\t\t}\n\t};\n\n\tvector<Tuple> tuples;\n\tsize_t _size;\npublic:\n\tHT() {\n\t\t_size = 0;\n\t\ttuples.resize(initial_size);\n\t}\n\n\tsize_t size() {return _size;}\n\n\ttemplate <typename K>\n\tsize_t canonical_index(const K & key) const {\n\t\tsize_t hash_code = hash_function(key);\n\t\treturn hash_code % tuples.size();\n\t}\n\n\tsize_t indexOfKey(const string & key) const {\n\t\tsize_t index = canonical_index(key);\n\t\twhile(true) {\n\t\t\tif(!tuples[index].string_in_use) return index;\n\t\t\tif(tuples[index].key_string == key) return index;\n\t\t\tindex = (index + 1) % tuples.size();\n\t\t}\n\t}\n\n\tsize_t indexOfKey(const int & key) const {\n\t\tsize_t index = canonical_index(key);\n\t\twhile(true) {\n\t\t\tif(!tuples[index].int_in_use) return index;\n\t\t\tif(tuples[index].key_int == key) return index;\n\t\t\tindex = (index + 1) % tuples.size();\n\t\t}\n\t}\n\n\tstring To_string(int value) {\n\t\tint temp = value;\n\t\tstring s;\n\t\tfor(int i = 0; temp > 0; temp /= 10, i ++) {\n\t\t\ts += temp % 10;\n\t\t}\n\t\treturn s;\n\t}\n\n\tvoid put(const string & key, const string & value) {\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].key_string = key;\n\t\ttuples[index].value_string = value;\n\t\tif(tuples[index].string_in_use) return;\n\t\ttuples[index].string_in_use = true;\n\t\t_size ++;\n\t\tif(2 * _size > tuples.size()) _double_tuples();\n\t}\n\n\tvoid put(const string & key, const int & value) {\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].key_string = key;\n\t\ttuples[index].value_int = value;\n\t\ttuples[index].value_string = To_string(value);\n\t\tif(tuples[index].string_in_use) return;\n\t\ttuples[index].string_in_use = true;\n\t\t_size ++;\n\t\tif(2 * _size > tuples.size()) _double_tuples();\n\t}\n\n\tvoid put(const int key, const string & value) {\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].key_int = key;\n\t\ttuples[index].value_string = value;\n\t\tif(tuples[index].int_in_use) return;\n\t\ttuples[index].int_in_use = true;\n\t\t_size ++;\n\t\tif(2 * _size > tuples.size()) _double_tuples();\n\t}\n\n\tvoid put(const int key, const int & value) {\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].key_int = key;\n\t\ttuples[index].value_int = value;\n\t\ttuples[index].value_string = To_string(value);\n\t\tif(tuples[index].int_in_use) return;\n\t\ttuples[index].int_in_use = true;\n\t\t_size ++;\n\t\tif(2 * _size > tuples.size()) _double_tuples();\n\t}\n\n\tvoid _double_tuples() {\n\t\tvector<Tuple> non_empty_tuples;\n\t\tfor(int i = 0; i < tuples.size(); i ++) {\n\t\t\tif(tuples[i].string_in_use || tuples[i].int_in_use) {\n\t\t\t\tnon_empty_tuples.push_back(tuples[i]);\n\t\t\t}\n\t\t\ttuples[i].string_in_use = false;\n\t\t\ttuples[i].int_in_use = false;\n\t\t}\n\t\ttuples.resize(2 * tuples.size());\n\t\tfor(int i = 0; i < non_empty_tuples.size(); i ++) {\n\t\t\tif(non_empty_tuples[i].string_in_use) {\n\t\t\t\tput(non_empty_tuples[i].key_string, non_empty_tuples[i].value_string);\n\t\t\t}\n\t\t\tif(non_empty_tuples[i].int_in_use) {\n\t\t\t\tput(non_empty_tuples[i].key_int, non_empty_tuples[i].value_int);\n\t\t\t}\n\t\t}\n\t}\n\n\ttemplate <typename K>\n\tRefTuple operator[] (const K & key) {\n\t\tsize_t index = indexOfKey(key);\n\t\tif(!tuples[index].int_in_use && !tuples[index].string_in_use) return RefTuple(this, NULL, key);\n\t\treturn RefTuple(this, &tuples[index], key);\n\t}\n\n\ttemplate <typename K>\n\tconst RefTuple operator[] (const K & key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\tif(!tuples[index].int_in_use && !tuples[index].string_in_use) return RefTuple(this, NULL, key);\n\t\treturn RefTuple(this, &tuples[index], key);\n\t}\n};",
            1595400869.4684134,
            100,
            "# 答案正确"
        ],
        [
            "A.3 (C++)",
            "潘文轩",
            "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\nconst int initial_size = 1;\n\nclass NoSuchKeyException {};\nclass NoSuchValueException {};\n\nsize_t circular_shift(size_t bits, int shift_bits) {\n\tconst int num_bits = 8 * sizeof(size_t);\n\tshift_bits = shift_bits % num_bits;\n\treturn bits << shift_bits | bits >> (num_bits - shift_bits);\n}\n\nsize_t hash_function(const int & key) {\n\tsize_t code = 0;\n\tint tmp = key;\n\tfor(int i = 0; tmp > 0; tmp /= 10, i ++) {\n\t\tcode ^= circular_shift(tmp % 10, i * 5);\n\t}\n\treturn code;\n}\ntemplate <typename V>\nclass HT {\n    class Tuple{\n    public:\n        int key;\n        V value;\n        bool in_use;\n\n        Tuple(): in_use(false) {}\n        Tuple(int key, V value): key(key), value(value), in_use(true) {}\n    };\n\n    vector<Tuple> tuples;\n    size_t _size;\n\npublic:\n    HT() {\n        _size = 0;\n        tuples.resize(initial_size);\n    }\n\n    size_t size() {return _size;}\n\n    size_t canonical_index(const int key) const {\n        size_t hash_code = hash_function(key);\n        return hash_code % tuples.size();\n    }\n\n    size_t indexOfKey(const int key) const {\n        size_t index = canonical_index(key);\n        while(true) {\n            if(!tuples[index].in_use) return index;\n            if(tuples[index].key == key) return index;\n            index = (index + 1) % tuples.size();\n        }\n    }\n\n    void put(const int key, const V & value) {\n        size_t index = indexOfKey(key);\n        tuples[index].key = key;\n        tuples[index].value = value;\n        if(tuples[index].in_use) return;\n        tuples[index].in_use = true;\n        _size ++;\n        if(_size * 2 > tuples.size()) _double_tuples();\n    }\n\n    void _double_tuples() {\n        vector<Tuple> non_empty_tuples;\n        for(int i = 0; i < tuples.size(); i ++) {\n            if(tuples[i].in_use) non_empty_tuples.push_back(tuples[i]);\n            tuples[i].in_use = false;\n        }\n\t\t_size = 0;\n        tuples.resize(2 * tuples.size());\n        for(int i = 0; i < non_empty_tuples.size(); i ++) {\n            put(non_empty_tuples[i].key, non_empty_tuples[i].value);\n        }\n    }\n\n    bool _between(size_t hole, size_t canonical, size_t tuple_index) {\n        if(hole < tuple_index) \n            return canonical > hole && canonical <= tuple_index;\n        else \n            return canonical > hole || canonical <= tuple_index;\n    }\n\n    void remove(const int key) {\n        size_t index = indexOfKey(key);\n        if(!tuples[index].in_use) throw NoSuchKeyException();\n        tuples[index].in_use = false;\n        _size --;\n        size_t hole = index;\n        size_t tuple_index = hole;\n        while(true) {\n            tuple_index = (tuple_index + 1) % tuples.size();\n            if(!tuples[tuple_index].in_use) return;\n            size_t canonical = canonical_index(tuples[tuple_index].key);\n            if(_between(hole, canonical, tuple_index)) continue;\n            tuples[hole] = tuples[tuple_index];\n            hole = tuple_index;\n            tuples[hole].in_use = false;\n        }\n    }\n\t\n\tV & operator [] (const int key) {\n        size_t index = indexOfKey(key);\n        if(tuples[index].in_use) return tuples[index].value;\n        else throw NoSuchKeyException();\n    }\n\n    const V & operator [] (const int key) const {\n        size_t index = indexOfKey(key);\n        if(tuples[index].in_use) return tuples[index].value;\n        else return V();\n    }\n\n    bool containsKey(const int key) {\n        size_t index = indexOfKey(key);\n        return tuples[index].in_use;\n    }\n\n    vector<int> getKeys() {\n        vector<int> keys;\n        for(int i = 0; i < tuples.size(); i ++) {\n            if(tuples[i].in_use)\n                keys.push_back(tuples[i].key);\n        }\n        return keys;\n    }\n};",
            1595474722.59609,
            100,
            "# 答案正确"
        ]
    ],
    "table_name": "答案"
}