{
    "__update_time__": 1596199302.6944928,
    "field_names": [
        "题目名",
        "用户名",
        "答案",
        "提交时间",
        "分数",
        "评语"
    ],
    "field_types": [
        "text",
        "text",
        "text",
        "time",
        "number",
        "text"
    ],
    "foreign_keys": {},
    "primary_keys": [],
    "rows": [
        [
            "测试1",
            "王彬",
            "#include<iostream>\nusing namespace std;\n\nint main()\n{\n\tstring str1, str2, str3;\n\tcin >> str1 >> str2 >> str3;\n\tcout << str3 << \" \" << str2 << \" \" << str1 << endl;\n\treturn 0;\n}",
            1587516707.0,
            100,
            "# 答案正确"
        ],
        [
            "测试2",
            "王彬",
            "#include<iostream>\nusing namespace std;\n\nint main()\n{\n\tstring str[10];\n\tfor (int i = 0; i < 10; i ++) cin >> str[i];\n\tfor (int i = 0; i < 10; i ++)\n\t{\n\t\tfor (int j = 0; j < 9; j ++)\n\t\t{\n\t\t\tif (str[j].compare(str[j + 1]) > 0)\n\t\t\t{\n\t\t\t\tstring t;\n\t\t\t\tt = str[j];\n\t\t\t\tstr[j] = str[j +1];\n\t\t\t\tstr[j + 1] = t;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < 10; i ++) cout << str[i] << \" \";\n\tcout << endl;\n\treturn 0;\n}",
            1587609473.553484,
            100,
            "# 答案正确"
        ],
        [
            "1.1 (C++)",
            "王彬",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix5x5\n{\n\tpublic:\n\t\tdouble get(int num1, int num2)\n\t\t{\n\t\t\treturn matrix5x5[num1][num2];\n\t\t}\n\t\tvoid set(int num1, int num2, double value)\n\t\t{\n\t\t\tmatrix5x5[num1][num2] = value;\n\t\t}\n\t\tfriend Matrix5x5 operator + (Matrix5x5 & m1, Matrix5x5 & m2)\n\t\t{\n\t\t\tMatrix5x5 m;\n\t\t\tfor (int row = 0; row < 5; ++ row)\n\t\t\t{\n\t\t\t\tfor (int col = 0; col < 5; ++ col)\n\t\t\t\t{\n\t\t\t\t\tm.matrix5x5[row][col] = m1.matrix5x5[row][col] + m2.matrix5x5[row][col];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn m;\n\t\t}\n\tprivate:\n\t\tint matrix5x5[6][6];\n};",
            1587702575.7268932,
            100,
            "# 答案正确"
        ],
        [
            "1.2 (C++)",
            "王彬",
            "#include <iostream>\n\nusing namespace std;\n\nclass School\n{\n\tpublic:\n\t\tchar name[10] = \"NO_NAME\";\n\t\tint age = 0;\n\t\tvoid setName(char name[])\n\t\t{\n\t\t\tfor (int i = 0; i < 10; ++ i)\n\t\t\t{\n\t\t\t\tthis->name[i] = name[i];\n\t\t\t}\n\t\t}\n\t\tvoid setAge(int year)\n\t\t{\n\t\t\tthis->age = year;\n\t\t}\n\t\tvoid operator ++ ()\n\t\t{\n\t\t\tthis->age ++;\n\t\t}\n};",
            1588213723.8074377,
            100,
            "# 答案正确"
        ],
        [
            "2.1 (C++)",
            "王彬",
            "#include<iostream>\n\nusing namespace std;\n\nclass Matrix\n{\n\tprivate:\n\t\tint rows;\n\t\tint columns;\n\t\tdouble * values;\n\tpublic:\n\t\tMatrix(int rows, int columns)\n\t\t{\n\t\t\tthis->rows = rows;\n\t\t\tthis->columns = columns;\n\t\t\tthis->values = new double [rows * columns + 1];\n\t\t\tfor (int i = 0; i < this->rows; i ++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < this->columns; j ++) values[i * this->columns + j] = 0;\n\t\t\t}\n\t\t}\n\t\t~Matrix()\n\t\t{\n\t\t\tdelete [] this->values;\n\t\t}\n\t\tvoid print()\n\t\t{\n\t\t\tfor (int i = 0; i < this->rows; i ++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < this->columns; j ++) cout << values[i * this->columns + j] << \"    \";\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n};",
            1588827301.2467828,
            100,
            "# 答案正确"
        ],
        [
            "2.2 (C++)",
            "王彬",
            "#include<iostream>\n#include<iomanip>\n\nusing namespace std;\n\nclass Matrix\n{\n\tprivate:\n\t\tint rows;\n\t\tint columns;\n\t\tdouble * values;\n\tpublic:\n\t\tMatrix(int rows, int columns, double values[])\n\t\t{\n\t\t\tthis->rows = rows;\n\t\t\tthis->columns = columns;\n\t\t\tthis->values = new double [rows * columns + 1];\n\t\t\tfor (int i = 0; i < this->rows; i ++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < this->columns; j ++) this->values[i * this->columns + j] = values[i * this->columns + j];\n\t\t\t}\n\t\t}\n\t\t~Matrix()\n\t\t{\n\t\t\tdelete [] this->values;\n\t\t}\n\t\tvoid print()\n\t\t{\n\t\t\tfor (int i = 0; i < this->rows; i ++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < this->columns; j ++) cout << setw(5) << values[i * this->columns + j];\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n};",
            1588828766.807084,
            100,
            "# 答案正确"
        ],
        [
            "2.3 (C++)",
            "王彬",
            "#include<iostream>\n#include<iomanip>\n#include<cstring>\n\nusing namespace std;\n\nclass Matrix\n{\n\tprivate:\n\t\tint rows;\n\t\tint columns;\n\t\tdouble * values;\n\tpublic:\n\t\tMatrix(int rows, int columns, double values[])\n\t\t{\n\t\t\tthis->rows = rows;\n\t\t\tthis->columns = columns;\n\t\t\tthis->values = new double [rows * columns + 1];\n\t\t\tfor (int i = 0; i < this->rows; i ++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < this->columns; j ++) this->values[i * this->columns + j] = values[i * this->columns + j];\n\t\t\t}\n\t\t}\n\t\t~Matrix()\n\t\t{\n\t\t\tdelete [] this->values;\n\t\t}\n\t\tMatrix(const Matrix & matrix2)\n\t\t{\n\t\t\tthis->rows = matrix2.rows;\n\t\t\tthis->columns = matrix2.columns;\n\t\t\tthis->values = new double [rows * columns + 1];\n\t\t\tfor (int i = 0; i < this->rows; i ++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < this->columns; j ++) this->values[i * this->columns + j] = matrix2.values[i * this->columns + j];\n\t\t\t}\n\t\t}\n\t\tvoid print()\n\t\t{\n\t\t\tfor (int i = 0; i < this->rows; i ++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < this->columns; j ++) cout << \"    \" << values[i * this->columns + j];\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n};",
            1588829785.8481836,
            100,
            "# 答案正确"
        ],
        [
            "2.5 (C++)",
            "王彬",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix\n{\n\tprivate:\n\t\tint rows;\n\t\tint columns;\n\t\tdouble * values;\n\tpublic:\n\t\tdouble mat[50][50];\n\t\tMatrix(int rows, int columns)\n\t\t{\n\t\t\tthis -> rows = rows;\n\t\t\tthis -> columns = columns;\n\t\t\tfor(int i = 0; i < rows; ++i)\n\t\t\t{\n\t\t\t\tfor(int j = 0; j < columns; ++j)\n\t\t\t\t{\n\t\t\t\t\tmat [i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tMatrix(int rows, int columns, double values[])\n\t\t{\n\t\t\tthis -> rows = rows;\n\t\t\tthis -> columns = columns;\n\t\t\tfor(int i = 0; i < rows;i ++)\n\t\t\t{\n\t\t\t\tfor(int j = 0; j < columns;j ++)\n\t\t\t\t{\n\t\t\t\t\tint count;\n\t\t\t\t\tcount = i * columns + j;\n\t\t\t\t\tmat [i][j] = values[count];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvoid print()\n\t\t{\n\t\t\tfor(int i = 0; i < rows; ++i)\n\t\t\t{\n\t\t\t\tfor(int j = 0; j < columns; ++j)\n\t\t\t\t{\n\t\t\t\t\tcout << mat[i][j] << \"    \";\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t\tMatrix getRow(int row)\n\t\t{\n\t\t\tMatrix matr(1,columns);\n\t\t\tfor(int i = 0; i < columns; ++i)\n\t\t\t{\n\t\t\t\tmatr.mat[0][i] = mat[row-1][i];\n\t\t\t}\n\t\t\treturn matr;\n\t\t}\n\t\tMatrix getColumn(int column)\n\t\t{\n\t\t\tMatrix matr(rows,1);\n\t\t\tfor(int i = 0; i < rows; ++i)\n\t\t\t{\n\t\t\t\tmatr.mat[i][0] = mat[i][column-1];\n\t\t\t}\n\t\t\treturn matr;\n\t\t}\n\t\t~Matrix(){}\n};",
            1589457107.0160658,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/08",
            "王彬",
            "#include <iostream>\n\nusing namespace std;\n\ndouble & Tensor_get(int dimensions,int sizes[], double data[], int x0, int x1, int x2, int x3)\n{\n\tdata[0] = x0;\n\tdata[1] = data[0] * 10 + x1;\n\tdata[2] = data[1] * 10 + x2;\n\tdata[3] = data[2] * 10 + x3;\n\tif (x1 == -1) return data[0];\n\telse if (x2 == -1) return data[1];\n\telse if (x3 == -1) return data[2];\n\telse return data[3];\n}",
            1588908550.669604,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/14",
            "王彬",
            "#include <iostream>\n\nusing namespace std;\n\nvoid Tensor_print(int dimensions, const int sizes[], const double data[])\n{\n\tif (dimensions == 1)\n\t{\n\t\tcout << \"Tensor of \" << sizes[0] << endl;\n\t\tfor (int i = 0; i < sizes[0]; i ++)\n\t\t{\n\t\t\tcout << data[i] << endl;\n\t\t}\n\t}\n\tif (dimensions == 2)\n\t{\n\t\tcout << \"Tensor of \" << sizes[0] << \"x\" << sizes[1] << endl;\n\t\tfor (int i = 0; i < sizes[0]; i ++)\n\t\t{\n\t\t\tfor (int j = 0; j < sizes[1]; j ++)\n\t\t\t{\n\t\t\t\tcout << \"    \" << data[i * sizes[1] + j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tif (dimensions == 3)\n\t{\n\t\tcout << \"Tensor of \" << sizes[0] << \"x\" << sizes[1] << \"x\" << sizes[2] << endl;\n\t\tfor (int i = 0; i < sizes[0]; i ++)\n\t\t{\n\t\t\tcout << \"data\" << \"[\" << i << \"]\" << endl;\n\t\t\tfor (int m = 0; m < sizes[1]; m ++)\n\t\t\t{\n\t\t\t\tfor (int n = 0; n < sizes[2]; n ++)\n\t\t\t\t{\n\t\t\t\t\tcout << \"    \" << data[m * sizes[2] + n];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t}\n\tif (dimensions == 4)\n\t{\n\t\tcout << \"Tensor of \" << sizes[0] << \"x\" << sizes[1] << \"x\" << sizes[2] << \"x\" << sizes[3] << endl;\n\t\tfor (int i = 0; i < sizes[0]; i ++)\n\t\t{\n\t\t\tfor (int j = 0; j < sizes[1]; j ++)\n\t\t\t{\n\t\t\t\tcout << \"data\" << \"[\" << i << \"]\" << \"[\" << j << \"]\" << endl;\n\t\t\t\tfor (int m = 0; m < sizes[2]; m ++)\n\t\t\t\t{\n\t\t\t\t\tfor (int n = 0; n < sizes[3]; n ++)\n\t\t\t\t\t{\n\t\t\t\t\t\tcout << \"    \" << data[m * sizes[3] + n];\n\t\t\t\t\t}\n\t\t\t\t\tcout << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
            1589424875.7827647,
            100,
            "# 答案正确"
        ],
        [
            "2.6 (C++)",
            "王彬",
            "#include <iostream>\n\nusing namespace std;\n\nclass Matrix\n{\n\tprivate:\n\t\tint rows;\n\t\tint columns;\n\t\tdouble * values;\n\tpublic:\n\t\tdouble mat[50][50];\n\t\tMatrix(int rows, int columns)\n\t\t{\n\t\t\tthis -> rows = rows;\n\t\t\tthis -> columns = columns;\n\t\t\tfor(int i = 0; i < rows; ++i)\n\t\t\t{\n\t\t\t\tfor(int j = 0; j < columns; ++j)\n\t\t\t\t{\n\t\t\t\t\tmat [i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tMatrix(int rows, int columns, double values[])\n\t\t{\n\t\t\tthis -> rows = rows;\n\t\t\tthis -> columns = columns;\n\t\t\tfor(int i = 0; i < rows; ++i)\n\t\t\t{\n\t\t\t\tfor(int j = 0; j < columns; ++j)\n\t\t\t\t{\n\t\t\t\t\tint count;\n\t\t\t\t\tcount = i * columns + j;\n\t\t\t\t\tmat [i][j] = values[count];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvoid print()\n\t\t{\n\t\t\tfor(int i = 0; i < rows; ++i)\n\t\t\t{\n\t\t\t\tfor(int j = 0; j < columns; ++j)\n\t\t\t\t{\n\t\t\t\t\tcout << mat[i][j] << \"    \";\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t\tMatrix concatenateRows(const Matrix & matrix2) const\n\t\t{\n\t\t\tMatrix m(this->rows + matrix2.rows,this->columns);\n\t\t\tfor(int i = 0; i < this->rows + matrix2.rows; ++i)\n\t\t\t{\n\t\t\t\tfor(int j = 0; j < columns; ++j)\n\t\t\t\t{\n\t\t\t\t\tif(i < this->rows)\n\t\t\t\t\t{\n\t\t\t\t\t\tm.mat[i][j] = this->mat[i][j];\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tm.mat[i][j] = matrix2.mat[i-this->rows][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn m;\n\t\t}\n\t\tMatrix concatenateColumns(const Matrix & matrix2) const\n\t\t{\n\t\t\tMatrix m(this->rows ,this->columns + matrix2.columns);\n\t\t\tfor(int i = 0; i < this->rows; i ++)\n\t\t\t{\n\t\t\t\tfor(int j = 0; j < columns+ matrix2.columns;j ++)\n\t\t\t\t{\n\t\t\t\t\tif(j < this->columns)\n\t\t\t\t\t{\n\t\t\t\t\t\tm.mat[i][j] = this->mat[i][j];\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tm.mat[i][j] = matrix2.mat[i][j - this-> columns];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn m;\n\t\t}\n\t\t~Matrix(){}\n};",
            1589456551.1120615,
            100,
            "# 答案正确"
        ],
        [
            "2.4 (C++)",
            "王彬",
            "#include <iostream>\n#include<cstring>\n\nusing namespace std;\n\nclass Matrix\n{\n\tprivate:\n\t\tint rows;\n\t\tint columns;\n\t\tdouble * values;\n\tpublic:\n\t\tMatrix(int rows, int column)\n\t\t{\n\t\t\tthis->rows = rows;\n\t\t\tthis->columns = column;\n\t\t\tthis->values = new double [rows * columns + 1];\n\t\t\tfor (int i = 0; i < this->rows; ++ i)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < this->columns; ++ j) values[i * this->columns + j] = 0; \n\t\t\t}\n\t\t}\n\t\tMatrix(int rows, int column, double values[])\n\t\t{\n\t\t\tthis->rows = rows;\n\t\t\tthis->columns = column;\n\t\t\tthis->values = new double [rows * columns + 1];\n\t\t\tfor (int i = 0; i < this->rows; ++ i)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < this->columns; ++ j) this->values[i * this->columns + j] = values[i * this->columns + j]; \n\t\t\t}\n\t\t}\n\t\t~Matrix()\n\t\t{\n\t\t\tdelete [] this->values;\n\t\t}\n\t\tvoid print()\n\t\t{\n\t\t\tfor (int i = 0; i < this->rows; ++ i)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < this->columns; ++ j) cout << \"    \" << values[i * this->columns + j];\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t\tvoid set(int row, int column, double value)\n\t\t{\n\t\t\tthis->values[(row - 1)* this->columns + column - 1] = value; \n\t\t}\n\t\tMatrix & operator = (const Matrix & mat)\n\t\t{\n\t\t\tif (values != 0) delete [] values;\n\t\t\trows = mat.rows;\n\t\t\tcolumns = mat.columns;\n\t\t\tthis->values = new double [rows * columns + 1];\n\t\t\tfor (int i = 0; i < this->rows; ++ i)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < this->columns; ++ j) this->values[i * this->columns + j] = mat.values[i * this->columns + j]; \n\t\t\t}\n\t\t\treturn (*this);\n\t\t}\n};",
            1589513183.6406977,
            100,
            "# 答案正确"
        ],
        [
            "2.7 (C++)",
            "王彬",
            "#include <iostream>\n#include<cstring>\n\nusing namespace std;\n\nclass Matrix\n{\n\tprivate:\n\t\tint rows;\n\t\tint columns;\n\t\tdouble * values;\n\tpublic:\n\t\tMatrix(const Matrix & matrix2)\n\t\t{\n\t\t\tthis->rows = matrix2.rows;\n\t\t\tthis->columns = matrix2.columns;\n\t\t\tthis->values = new double [rows * columns + 1];\n\t\t\tfor (int i = 0; i < this->rows; ++ i)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < this->columns; ++ j) values[i * this->columns + j] = matrix2.values[i * this->columns + j]; \n\t\t\t}\n\t\t}\n\t\tMatrix(int rows, int column)\n\t\t{\n\t\t\tthis->rows = rows;\n\t\t\tthis->columns = column;\n\t\t\tthis->values = new double [rows * columns + 1];\n\t\t\tfor (int i = 0; i < this->rows; ++ i)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < this->columns; ++ j) values[i * this->columns + j] = 0; \n\t\t\t}\n\t\t}\n\t\tMatrix(int rows, int column, double values[])\n\t\t{\n\t\t\tthis->rows = rows;\n\t\t\tthis->columns = column;\n\t\t\tthis->values = new double [rows * columns + 1];\n\t\t\tfor (int i = 0; i < this->rows * this->columns; ++ i)\n\t\t\t{\n\t\t\t\tthis->values[i] = values[i]; \n\t\t\t}\n\t\t}\n\t\t~Matrix()\n\t\t{\n\t\t\tdelete [] this->values;\n\t\t}\n\t\tvoid print()\n\t\t{\n\t\t\tfor (int i = 0; i < this->rows; ++ i)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < this->columns; ++ j) cout << \"    \" << values[i * this->columns + j];\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t\tvoid set(int row, int column, double value)\n\t\t{\n\t\t\tthis->values[(row - 1)* this->columns + column - 1] = value; \n\t\t}\n\t\tMatrix & operator = (const Matrix & mat)\n\t\t{\n\t\t\tif (values != 0) delete [] values;\n\t\t\trows = mat.rows;\n\t\t\tcolumns = mat.columns;\n\t\t\tthis->values = new double [rows * columns + 1];\n\t\t\tfor (int i = 0; i < this->rows; ++ i)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < this->columns; ++ j) this->values[i * this->columns + j] = mat.values[i * this->columns + j]; \n\t\t\t}\n\t\t\treturn (*this);\n\t\t}\n\t\tMatrix reshape(int rows, int columns) const\n\t\t{\n\t\t\tMatrix mat(columns, rows);\n\t\t\tint array[this->rows * this->columns];\n\t\t\tint count = 0;\n\t\t\tfor (int i = 0; i < this->columns; ++ i)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < this->rows; ++ j) array[count ++] = this->values[i + this->columns * j]; \n\t\t\t}\n\t\t\tcount = 0;\n\t\t\tfor (int i = 0; i < mat.columns; ++ i)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < mat.rows; ++ j) mat.values[i + mat.rows * j] = array[count ++]; \n\t\t\t}\n\t\t\treturn mat;\n\t\t}\n};",
            1589704515.0545113,
            100,
            "# 答案正确"
        ],
        [
            "2.8 (C++)",
            "王彬",
            "#include <iostream>\n#include<cstring>\n\nusing namespace std;\n\nclass Matrix\n{\n\tprivate:\n\t\tint rows;\n\t\tint columns;\n\t\tdouble * values;\n\tpublic:\n\t\tMatrix(const Matrix & matrix2)\n\t\t{\n\t\t\tthis->rows = matrix2.rows;\n\t\t\tthis->columns = matrix2.columns;\n\t\t\tthis->values = new double [rows * columns + 1];\n\t\t\tfor (int i = 0; i < this->rows; ++ i)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < this->columns; ++ j) values[i * this->columns + j] = matrix2.values[i * this->columns + j]; \n\t\t\t}\n\t\t}\n\t\tMatrix(int rows, int column)\n\t\t{\n\t\t\tthis->rows = rows;\n\t\t\tthis->columns = column;\n\t\t\tthis->values = new double [rows * columns + 1];\n\t\t\tfor (int i = 0; i < this->rows; ++ i)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < this->columns; ++ j) values[i * this->columns + j] = 0; \n\t\t\t}\n\t\t}\n\t\tMatrix(int rows, int column, double values[])\n\t\t{\n\t\t\tthis->rows = rows;\n\t\t\tthis->columns = column;\n\t\t\tthis->values = new double [rows * columns + 1];\n\t\t\tfor (int i = 0; i < this->rows * this->columns; ++ i)\n\t\t\t{\n\t\t\t\tthis->values[i] = values[i]; \n\t\t\t}\n\t\t}\n\t\t~Matrix()\n\t\t{\n\t\t\tdelete [] this->values;\n\t\t}\n\t\tvoid print()\n\t\t{\n\t\t\tfor (int i = 0; i < this->rows; ++ i)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < this->columns; ++ j) cout << \"    \" << values[i * this->columns + j];\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t\tvoid set(int row, int column, double value)\n\t\t{\n\t\t\tthis->values[(row - 1)* this->columns + column - 1] = value; \n\t\t}\n\t\tMatrix & operator = (const Matrix & mat)\n\t\t{\n\t\t\tif (values != 0) delete [] values;\n\t\t\trows = mat.rows;\n\t\t\tcolumns = mat.columns;\n\t\t\tthis->values = new double [rows * columns + 1];\n\t\t\tfor (int i = 0; i < this->rows; ++ i)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < this->columns; ++ j) this->values[i * this->columns + j] = mat.values[i * this->columns + j]; \n\t\t\t}\n\t\t\treturn (*this);\n\t\t}\n\t\tMatrix transpose()\n\t\t{\n\t\t\tMatrix mat(this->columns, this->rows);\n\t\t\tint array[this->rows * this->columns];\n\t\t\tint count = 0;\n\t\t\tfor (int i = 0; i < this->rows; ++ i)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < this->columns; ++ j) array[count ++] = this->values[i * this->columns + j]; \n\t\t\t}\n\t\t\tcount = 0;\n\t\t\tfor (int i = 0; i < mat.columns; ++ i)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < mat.rows; ++ j) mat.values[i + mat.rows * j] = array[count ++]; \n\t\t\t}\n\t\t\treturn mat;\n\t\t}\n};",
            1589704825.7330947,
            100,
            "# 答案正确"
        ],
        [
            "2.10 (C++)",
            "王彬",
            "#include <iostream>\n#include<cstring>\n\nusing namespace std;\n\nclass Matrix\n{\n\tprivate:\n\t\tint rows;\n\t\tint columns;\n\t\tdouble * values;\n\tpublic:\n\t\tMatrix(const Matrix & matrix2)\n\t\t{\n\t\t\tthis->rows = matrix2.rows;\n\t\t\tthis->columns = matrix2.columns;\n\t\t\tthis->values = new double [rows * columns + 1];\n\t\t\tfor (int i = 0; i < this->rows; ++ i)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < this->columns; ++ j) values[i * this->columns + j] = matrix2.values[i * this->columns + j]; \n\t\t\t}\n\t\t}\n\t\tMatrix(int rows, int column)\n\t\t{\n\t\t\tthis->rows = rows;\n\t\t\tthis->columns = column;\n\t\t\tthis->values = new double [rows * columns + 1];\n\t\t\tfor (int i = 0; i < this->rows; ++ i)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < this->columns; ++ j) values[i * this->columns + j] = 0; \n\t\t\t}\n\t\t}\n\t\tMatrix(int rows, int column, double values[])\n\t\t{\n\t\t\tthis->rows = rows;\n\t\t\tthis->columns = column;\n\t\t\tthis->values = new double [rows * columns + 1];\n\t\t\tfor (int i = 0; i < this->rows * this->columns; ++ i)\n\t\t\t{\n\t\t\t\tthis->values[i] = values[i]; \n\t\t\t}\n\t\t}\n\t\t~Matrix()\n\t\t{\n\t\t\tdelete [] this->values;\n\t\t}\n\t\tvoid print()\n\t\t{\n\t\t\tfor (int i = 0; i < this->rows; ++ i)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < this->columns; ++ j) cout << \"    \" << values[i * this->columns + j];\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t\tvoid set(int row, int column, double value)\n\t\t{\n\t\t\tthis->values[(row - 1)* this->columns + column - 1] = value; \n\t\t}\n\t\tMatrix & operator = (const Matrix & mat)\n\t\t{\n\t\t\tif (values != 0) delete [] values;\n\t\t\trows = mat.rows;\n\t\t\tcolumns = mat.columns;\n\t\t\tthis->values = new double [rows * columns + 1];\n\t\t\tfor (int i = 0; i < this->rows; ++ i)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < this->columns; ++ j) this->values[i * this->columns + j] = mat.values[i * this->columns + j]; \n\t\t\t}\n\t\t\treturn (*this);\n\t\t}\n\t\tMatrix operator * (const Matrix & matrix2) const\n\t\t{\n\t\t\tMatrix mat(this->rows, matrix2.columns);\n\t\t\tint array1[this->rows][this->columns];\n\t\t\tint array2[matrix2.rows][matrix2.columns];\n\t\t\tfor (int i = 0; i < this->rows; i ++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < this->columns; j ++) array1[i][j] = this->values[i * this->columns + j];\n\t\t\t}\n\t\t\tfor (int i = 0; i < matrix2.rows; i ++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < matrix2.columns; j ++) array2[i][j] = matrix2.values[i * matrix2.columns + j];\n\t\t\t}\n\t\t\tfor (int i = 0; i < mat.rows; ++ i)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < mat.columns; ++ j)\n\t\t\t\t{\n\t\t\t\t\tfor (int p = 0; p < this->columns; p ++)\n\t\t\t\t\t{\n\t\t\t\t\t\tmat.values[i * mat.columns + j] += (array1[i][p] * array2[p][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn mat;\n\t\t}\n\t\tMatrix operator * (double value)\n\t\t{\n\t\t\tMatrix mat(this->rows, this->columns);\n\t\t\tfor (int i = 0; i < this->rows; ++ i)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < this->columns; ++ j) mat.values[i * this->columns + j] = this->values[i * this->columns + j] * value; \n\t\t\t}\n\t\t\treturn mat;\n\t\t}\n};",
            1589707427.1127896,
            100,
            "# 答案正确"
        ],
        [
            "2.11 (C++)",
            "王彬",
            "#include <iostream>\n#include<cstring>\n\nusing namespace std;\n\nclass Matrix\n{\n\tprivate:\n\t\tint rows;\n\t\tint columns;\n\t\tdouble * values;\n\tpublic:\n\t\tMatrix(const Matrix & matrix2)\n\t\t{\n\t\t\tthis->rows = matrix2.rows;\n\t\t\tthis->columns = matrix2.columns;\n\t\t\tthis->values = new double [rows * columns + 1];\n\t\t\tfor (int i = 0; i < this->rows; ++ i)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < this->columns; ++ j) values[i * this->columns + j] = matrix2.values[i * this->columns + j]; \n\t\t\t}\n\t\t}\n\t\tMatrix(int rows, int column)\n\t\t{\n\t\t\tthis->rows = rows;\n\t\t\tthis->columns = column;\n\t\t\tthis->values = new double [rows * columns + 1];\n\t\t\tfor (int i = 0; i < this->rows; ++ i)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < this->columns; ++ j) values[i * this->columns + j] = 0; \n\t\t\t}\n\t\t}\n\t\tMatrix(int rows, int column, double values[])\n\t\t{\n\t\t\tthis->rows = rows;\n\t\t\tthis->columns = column;\n\t\t\tthis->values = new double [rows * columns + 1];\n\t\t\tfor (int i = 0; i < this->rows * this->columns; ++ i)\n\t\t\t{\n\t\t\t\tthis->values[i] = values[i]; \n\t\t\t}\n\t\t}\n\t\t~Matrix()\n\t\t{\n\t\t\tdelete [] this->values;\n\t\t}\n\t\tvoid print()\n\t\t{\n\t\t\tfor (int i = 0; i < this->rows; ++ i)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < this->columns; ++ j) cout << \"    \" << values[i * this->columns + j];\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t\tMatrix max() const\n\t\t{\n\t\t\tif (this->rows == 1)\n\t\t\t{\n\t\t\t\tMatrix mat(1, 1);\n\t\t\t\tint max = 0;\n\t\t\t\tfor (int i = 0; i < this->columns; ++ i)\n\t\t\t\t{\n\t\t\t\t\tif (this->values[i] > max)\n\t\t\t\t\t{\n\t\t\t\t\t\tmax = this->values[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmat.values[0] = max;\n\t\t\t\treturn mat;\n\t\t\t}\n\t\t\tMatrix mat(1, this->columns);\n\t\t\tint array[this->rows][this->columns];\n\t\t\tfor (int i = 0; i < this->rows; i ++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < this->columns; j ++) array[i][j] = this->values[i * this->columns + j];\n\t\t\t}\n\t\t\tint num[this->columns + 1] = {0};\n\t\t\tint max = 0;\n\t\t\tfor (int i = 0; i < this->columns; ++ i)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < this->rows; j ++)\n\t\t\t\t{\n\t\t\t\t\tif (array[j][i] > max)\n\t\t\t\t\t{\n\t\t\t\t\t\tmax = array[j][i];\n\t\t\t\t\t\tnum[i] = max;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmax = 0;\n\t\t\t}\n\t\t\tfor (int j = 0; j < this->columns; ++ j) mat.values[j] = num[j];\n\t\t\treturn mat;\n\t\t}\n\t\tMatrix min() const\n\t\t{\n\t\t\tif (this->rows == 1)\n\t\t\t{\n\t\t\t\tMatrix mat(1, 1);\n\t\t\t\tint min = 99999;\n\t\t\t\tfor (int i = 0; i < this->columns; ++ i)\n\t\t\t\t{\n\t\t\t\t\tif (this->values[i] < min)\n\t\t\t\t\t{\n\t\t\t\t\t\tmin = this->values[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmat.values[0] = min;\n\t\t\t\treturn mat;\n\t\t\t}\n\t\t\tMatrix mat(1, this->columns);\n\t\t\tint array[this->rows][this->columns];\n\t\t\tfor (int i = 0; i < this->rows; i ++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < this->columns; j ++) array[i][j] = this->values[i * this->columns + j];\n\t\t\t}\n\t\t\tint num[this->columns + 1] = {0};\n\t\t\tint min = 99999;\n\t\t\tfor (int i = 0; i < this->columns; ++ i)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < this->rows; j ++)\n\t\t\t\t{\n\t\t\t\t\tif (array[j][i] < min)\n\t\t\t\t\t{\n\t\t\t\t\t\tmin = array[j][i];\n\t\t\t\t\t\tnum[i] = min;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmin = 99999;\n\t\t\t}\n\t\t\tfor (int j = 0; j < this->columns; ++ j) mat.values[j] = num[j];\n\t\t\treturn mat;\n\t\t}\n\t\tMatrix sum() const\n\t\t{\n\t\t\tif (this->rows == 1)\n\t\t\t{\n\t\t\t\tMatrix mat(1, 1);\n\t\t\t\tfor (int i = 0; i < this->columns; ++ i)\n\t\t\t\t{\n\t\t\t\t\tmat.values[0] += this->values[i];\n\t\t\t\t}\n\t\t\t\treturn mat;\n\t\t\t}\n\t\t\tMatrix mat(1, this->columns);\n\t\t\tint array[this->rows][this->columns];\n\t\t\tfor (int i = 0; i < this->rows; i ++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < this->columns; j ++) array[i][j] = this->values[i * this->columns + j];\n\t\t\t}\n\t\t\tint num[this->columns + 1] = {0};\n\t\t\tfor (int i = 0; i < this->columns; ++ i)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < this->rows; ++ j) num[i] += array[j][i];\n\t\t\t}\n\t\t\tfor (int j = 0; j < this->columns; ++ j) mat.values[j] = num[j];\n\t\t\treturn mat;\n\t\t}\n};",
            1589712578.8616076,
            100,
            "# 答案正确"
        ],
        [
            "2.12 (C++)",
            "王彬",
            "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define mem0(x) memset(x,0,sizeof(x));\n#define memI(x) memset(x,0x3f3f3f,sizeof(x));\n#define f(m,n) for(int i=m;i<n;i++)\n#define df(m,n) for(int j=m;j<n;j++)\n\nclass Matrix\n{\n\tprivate:\n\t\tint rows;\n\t\tint columns;\n\t\tdouble * values;\n\t\tvoid assign()\n\t\t{\n\t\t\tif(values!=0)\n\t\t\tdelete [ ] values;\n\t\t}\n\tpublic:\n\t\tMatrix(int rows, int column, double values[])\n\t\t{\n\t\t\tthis->columns=column;\n\t\t\tthis->rows=rows;\n\t\t\tthis->values=new double[rows*columns];\n\t\t\tfor(int i=0;i<rows;i++){\n\t\t\t\tfor(int j=0;j<columns;j++){\n\t\t\t\t\tthis->values[i*columns+j]=values[i*columns+j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tMatrix(const Matrix & matrix2):rows(matrix2.rows),columns(matrix2.columns)\n\t\t{\n\t\t\tassign();\n\t\t\tvalues=new double[rows*columns];\n\t\t\tfor(int i=0;i<rows;i++){\n\t\t\t\tfor(int j=0;j<columns;j++){\n\t\t\t\t\tvalues[i*columns+j]=matrix2.values[i*columns+j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t~Matrix()\n\t\t{\n\t\t\tassign();\n\t\t}\n\t\t void print()\n\t\t {\n\t\t\tif(values==NULL)\n\t\t\treturn ;\n\t\t\tfor(int i=0;i<rows;i++){\n\t\t\t\tfor(int j=0;j<columns;j++){\n\t\t\t\t\tcout<<\"    \"<<values[i*columns+j];\n\t\t\t\t}cout<<endl;\n\t\t\t}\n\t\t }\n\t\t  Matrix pow(double exponent)\n\t\t  {\n\t\t  \tdouble temp[1000];\n\t\t  \tmem0(temp);\n\t\t  \tf(0,rows){\n\t\t  \t\tdf(0,columns){\n\t\t  \t\t\ttemp[i*columns+j]=::pow(values[i*columns+j],exponent);\n\t\t\t\t  }\n\t\t\t  }\n\t\t\t  Matrix a(rows,columns,temp);\n\t\t\t  return a;\n\t\t  }\n\t\t  Matrix exp()\n\t\t  {\n\t\t  \tdouble temp[1000];\n\t\t  \tmem0(temp);\n\t\t  \tf(0,rows){\n\t\t  \t\tdf(0,columns){\n\t\t  \t\t\ttemp[i*columns+j]=::exp(values[i*columns+j]);\n\t\t\t\t  }\n\t\t\t  }\n\t\t\t  Matrix a(rows,columns,temp);\n\t\t\t  return a;\n\t\t  }\n\t\t  Matrix log()\n\t\t  {\n\t\t  \tdouble temp[1000];\n\t\t  \tmem0(temp);\n\t\t  \tf(0,rows){\n\t\t  \t\tdf(0,columns){\n\t\t  \t\t\ttemp[i*columns+j]=::log(values[i*columns+j]);\n\t\t\t\t  }\n\t\t\t  }\n\t\t\t  Matrix a(rows,columns,temp);\n\t\t\t  return a;\n\t\t  }\n\t\t  Matrix abs()\n\t\t  {\n\t\t  \tdouble temp[1000];\n\t\t  \tmem0(temp);\n\t\t  \tf(0,rows){\n\t\t  \t\tdf(0,columns){\n\t\t  \t\t\ttemp[i*columns+j]=::abs(values[i*columns+j]);\n\t\t\t\t  }\n\t\t\t  }\n\t\t\t  Matrix a(rows,columns,temp);\n\t\t\t  return a;\n\t\t  }\n};\n",
            1589875900.1851208,
            100,
            "# 答案正确"
        ],
        [
            "2.9 (C++)",
            "王彬",
            "#include <iostream>\n#include<cstring>\n\nusing namespace std;\n\nclass Matrix\n{\n\tprivate:\n\t\tint rows;\n\t\tint columns;\n\t\tdouble * values;\n\tpublic:\n\t\tMatrix(const Matrix & matrix2)\n\t\t{\n\t\t\tthis->rows = matrix2.rows;\n\t\t\tthis->columns = matrix2.columns;\n\t\t\tthis->values = new double [rows * columns + 1];\n\t\t\tfor (int i = 0; i < this->rows; ++ i)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < this->columns; ++ j) values[i * this->columns + j] = matrix2.values[i * this->columns + j]; \n\t\t\t}\n\t\t}\n\t\tMatrix(int rows, int column)\n\t\t{\n\t\t\tthis->rows = rows;\n\t\t\tthis->columns = column;\n\t\t\tthis->values = new double [rows * columns + 1];\n\t\t\tfor (int i = 0; i < this->rows; ++ i)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < this->columns; ++ j) values[i * this->columns + j] = 0; \n\t\t\t}\n\t\t}\n\t\tMatrix(int rows, int column, double values[])\n\t\t{\n\t\t\tthis->rows = rows;\n\t\t\tthis->columns = column;\n\t\t\tthis->values = new double [rows * columns + 1];\n\t\t\tfor (int i = 0; i < this->rows * this->columns; ++ i)\n\t\t\t{\n\t\t\t\tthis->values[i] = values[i]; \n\t\t\t}\n\t\t}\n\t\t~Matrix()\n\t\t{\n\t\t\tdelete [] this->values;\n\t\t}\n\t\tvoid print()\n\t\t{\n\t\t\tfor (int i = 0; i < this->rows; ++ i)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < this->columns; ++ j) cout << \"    \" << values[i * this->columns + j];\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t\tMatrix operator + (const Matrix & matrix2) const\n\t\t{\n\t\t\tMatrix mat (this->rows, this->columns);\n\t\t\tfor (int i = 0; i < this->rows; ++ i)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < this->columns; ++ j) mat.values[i * this->columns + j] = this->values[i * this->columns + j] + matrix2.values[i * this->columns + j]; \n\t\t\t}\n\t\t\treturn mat;\n\t\t}\n\t\tMatrix operator - (const Matrix & matrix2) const\n\t\t{\n\t\t\tMatrix mat (this->rows, this->columns);\n\t\t\tfor (int i = 0; i < this->rows; ++ i)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < this->columns; ++ j) mat.values[i * this->columns + j] = this->values[i * this->columns + j] - matrix2.values[i * this->columns + j]; \n\t\t\t}\n\t\t\treturn mat;\n\t\t}\n\t\tMatrix operator + (double value) const\n\t\t{\n\t\t\tMatrix mat (this->rows, this->columns);\n\t\t\tfor (int i = 0; i < this->rows; ++ i)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < this->columns; ++ j) mat.values[i * this->columns + j] = this->values[i * this->columns + j] + value; \n\t\t\t}\n\t\t\treturn mat;\n\t\t}\n\t\tMatrix operator - (double value) const\n\t\t{\n\t\t\tMatrix mat (this->rows, this->columns);\n\t\t\tfor (int i = 0; i < this->rows; ++ i)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < this->columns; ++ j) mat.values[i * this->columns + j] = this->values[i * this->columns + j] - value; \n\t\t\t}\n\t\t\treturn mat;\n\t\t}\n};",
            1590027058.335986,
            100,
            "# 答案正确"
        ],
        [
            "6.1 (C++)",
            "王彬",
            "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename T>\nclass Matrix\n{\n\tprivate:\n\t\tint rows;\n\t\tint columns;\n\t\tT * values;\n\tpublic:\n\t\tMatrix(const Matrix & matrix2)\n\t\t{\n\t\t\tthis->rows = matrix2.rows;\n\t\t\tthis->columns = matrix2.columns;\n\t\t\tthis->values = new T [rows * columns + 1];\n\t\t\tfor (int i = 0; i < this->rows; ++ i)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < this->columns; ++ j) values[i * this->columns + j] = matrix2.values[i * this->columns + j]; \n\t\t\t}\n\t\t}\n\t\tMatrix(int rows, int column)\n\t\t{\n\t\t\tthis->rows = rows;\n\t\t\tthis->columns = column;\n\t\t\tthis->values = new T [rows * columns + 1];\n\t\t\tfor (int i = 0; i < this->rows; ++ i)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < this->columns; ++ j) values[i * this->columns + j] = 0; \n\t\t\t}\n\t\t}\n\t\tMatrix(int rows, int column, T * values)\n\t\t{\n\t\t\tthis->rows = rows;\n\t\t\tthis->columns = column;\n\t\t\tthis->values = new T [rows * columns + 1];\n\t\t\tfor (int i = 0; i < this->rows * this->columns; ++ i)\n\t\t\t{\n\t\t\t\tthis->values[i] = values[i]; \n\t\t\t}\n\t\t}\n\t\t~Matrix()\n\t\t{\n\t\t\tdelete [] this->values;\n\t\t}\n\t\tvoid print()\n\t\t{\n\t\t\tfor (int i = 0; i < this->rows; ++ i)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < this->columns; ++ j) cout << \"    \" << values[i * this->columns + j];\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t\tMatrix & operator = (const Matrix & mat)\n\t\t{\n\t\t\tif (values != 0) delete [] values;\n\t\t\trows = mat.rows;\n\t\t\tcolumns = mat.columns;\n\t\t\tthis->values = new T [rows * columns + 1];\n\t\t\tfor (int i = 0; i < this->rows; ++ i)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < this->columns; ++ j) this->values[i * this->columns + j] = mat.values[i * this->columns + j]; \n\t\t\t}\n\t\t\treturn (*this);\n\t\t}\n\t\tT & get(int row, int column)\n\t\t{\n\t\t\treturn this->values[(row - 1) * this->columns + column - 1];\n\t\t}\n};",
            1590547030.0308623,
            100,
            "main.cpp: In function ‘int main4double()’:\nmain.cpp:18:38: error: invalid conversion from ‘const double*’ to ‘double*’ [-fpermissive]\n  Matrix<double> matrix2(3, 3, values2);\n                                      ^\nIn file included from main.cpp:5:0:\nsource.cpp:33:3: note:   initializing argument 3 of ‘Matrix<T>::Matrix(int, int, T*) [with T = double]’\n   Matrix(int rows, int column, T * values)\n   ^\nmain.cpp: In function ‘int main4string()’:\nmain.cpp:45:38: error: invalid conversion from ‘const string* {aka const std::__cxx11::basic_string<char>*}’ to ‘std::__cxx11::basic_string<char>*’ [-fpermissive]\n  Matrix<string> matrix2(3, 3, values2);\n                                      ^\nIn file included from main.cpp:5:0:\nsource.cpp:33:3: note:   initializing argument 3 of ‘Matrix<T>::Matrix(int, int, T*) [with T = std::__cxx11::basic_string<char>]’\n   Matrix(int rows, int column, T * values)\n   ^\nsource.cpp: In instantiation of ‘Matrix<T>::Matrix(int, int) [with T = std::__cxx11::basic_string<char>]’:\nmain.cpp:36:29:   required from here\nsource.cpp:30:76: error: ambiguous overload for ‘operator=’ (operand types are ‘std::__cxx11::basic_string<char>’ and ‘int’)\n     for (int j = 0; j < this->columns; ++ j) values[i * this->columns + j] = 0; \n                                                                            ^\nIn file included from /usr/include/c++/5/string:52:0,\n                 from /usr/include/c++/5/bits/locale_classes.h:40,\n                 from /usr/include/c++/5/bits/ios_base.h:41,\n                 from /usr/include/c++/5/ios:42,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/basic_string.h:550:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::operator=(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\n       operator=(const basic_string& __str)\n       ^\n/usr/include/c++/5/bits/basic_string.h:558:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::operator=(const _CharT*) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\n       operator=(const _CharT* __s)\n       ^\n/usr/include/c++/5/bits/basic_string.h:569:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::operator=(_CharT) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\n       operator=(_CharT __c)\n       ^\n/usr/include/c++/5/bits/basic_string.h:587:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::operator=(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\n       operator=(basic_string&& __str)\n       ^\n"
        ],
        [
            "6.3 (C++)",
            "王彬",
            "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename T>\nclass Matrix{\n\tprivate:\n\t\tint rows;\n\t\tint col;\n\t\tvector <T> val;\n\t\tvoid assign()\n\t\t{\n\t\t\tval.clear();\n\t\t}\n\tpublic:\n\t\tMatrix(int r,int c)\n\t\t{\n\t\t\tthis->rows = r;\n\t\t\tthis->col = c;\n\t\t\tfor(int i=0;i<rows*col;i++)\n\t\t\tval.push_back(0);\n\t\t}\n\t\tMatrix(int r,int c,vector <T> v):rows(r),col(c){\n\t\t\tfor(int i=0;i<rows*col;i++)\n\t\t\tval.push_back(v[i]);\n\t\t}\n\t\tvoid print(){\n\t\t\tfor(int i=0;i<rows;i++){\n\t\t\t\tfor(int j=0;j<col;j++){\n\t\t\t\t\tcout<<\"    \"<<val[i*col+j];\n\t\t\t\t}cout<<endl;\n\t\t\t}\n\t\t}\n\t\tT& get(int i,int j){\n\t\t\treturn val[(i-1)*col+j-1];\n\t\t}\n\t\tMatrix getColumn(int a){\n\t\t\tvector<T> temp;\n\t\t\tfor(int i=0;i<rows;i++){\n\t\t\t\ttemp.push_back(val[i*col+(a-1)]);\n\t\t\t}\n\t\t\tMatrix b(rows,1,temp);\n\t\t\treturn b;\n\t\t}\n\t\tMatrix getRow(int a){\n\t\t\tvector<T> temp;\n\t\t\tfor(int i=0;i<col;i++){\n\t\t\t\ttemp.push_back(val[i+(a-1)*rows]);\n\t\t\t}\n\t\t\tMatrix b(1,col,temp);\n\t\t\treturn b;\n\t\t}\n\t\tMatrix concatenateRows(Matrix a){\n\t\t\tvector <T> temp;\n\t\t\tfor(int i=0;i<rows*col;i++)\n\t\t\ttemp.push_back(val[i]);\n\t\t\tfor(int i=0;i<a.col*a.rows;i++){\n\t\t\t\ttemp.push_back(a.val[i]);\n\t\t\t}\n\t\t\tMatrix b(rows+a.rows,col,temp);\n\t\t\treturn b;\n\t\t}\n\t\tMatrix concatenateColumns(Matrix a){\n\t\t\tvector <T> temp;\n\t\t\tfor(int i=0;i<rows;i++)\n\t\t\t{\n\t\t\t\tfor(int j=0;j<col;j++){\n\t\t\t\t\ttemp.push_back(val[i*col+j]);\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<a.col;j++)\n\t\t\t\ttemp.push_back(a.val[i*a.col+j]);\n\t\t\t}\n\t\t\tMatrix b(rows,col+a.col,temp);\n\t\t\treturn b;\n\t\t}\n\t\tMatrix reshape(int r,int c){\n\t\t\tvector <T> temp(rows*col);\n\t\t\tvector<T> t1(rows*col);\n\t\t\tint k=0;\n\t\t\tfor(int i=0;i<col;i++){\n\t\t\t\tfor(int j=0;j<rows;j++){\n\t\t\t\t\tt1[k++]=val[i+j*col];\n\t\t\t\t}\n\t\t\t}\n\t\t\tk=0;\n\t\t\tfor(int i=0;i<c;i++){\n\t\t\t\tfor(int j=0;j<r;j++){\n\t\t\t\t\ttemp[i+j*c]=t1[k++];\n\t\t\t\t}\n\t\t\t}\n\t\t\tMatrix b(r,c,temp);\n\t\t\treturn b;\n\t\t}\n\t\tMatrix transpose(){\n\t\t\tvector<T> t1(rows*col);\n\t\t\tint k=0;\n\t\t\tfor(int i=0;i<col;i++){\n\t\t\t\tfor(int j=0;j<rows;j++){\n\t\t\t\t\tt1[k++]=val[i+j*col];\n\t\t\t\t}\n\t\t\t}\n\t\t\tMatrix b(rows,col,t1);\n\t\t\treturn b;\n\t\t}\n\t\tMatrix operator +(Matrix a){\n\t\t\tvector <T> temp;\n\t\t\tfor(int i=0;i<rows*col;i++)\n\t\t\ttemp.push_back(val[i]+a.val[i]);\n\t\t\tMatrix b(rows,col,temp);\n\t\t\treturn b;\n\t\t}\n\t\tMatrix operator +(T a){\n\t\t\tvector <T> temp;\n\t\t\tfor(int i=0;i<rows*col;i++)\n\t\t\ttemp.push_back(val[i]+a);\n\t\t\tMatrix b(rows,col,temp);\n\t\t\treturn b;\n\t\t}\n\t\tMatrix operator -(Matrix a){\n\t\t\tvector <T> temp;\n\t\t\tfor(int i=0;i<rows*col;i++)\n\t\t\ttemp.push_back(val[i]-a.val[i]);\n\t\t\tMatrix b(rows,col,temp);\n\t\t\treturn b;\n\t\t}\n\t\tMatrix operator -(T a){\n\t\t\tvector <T> temp;\n\t\t\tfor(int i=0;i<rows*col;i++)\n\t\t\ttemp.push_back(val[i]-a);\n\t\t\tMatrix b(rows,col,temp);\n\t\t\treturn b;\n\t\t}\n\t\tMatrix operator *(Matrix a){\n\t\t\tvector <T> temp(rows*a.col,0);\n\t\t\tfor(int i=0;i<rows;i++){\n\t\t\t\tfor(int j=0;j<a.col;j++){\n\t\t\t\t\tfor(int k=0;k<col;k++){\n\t\t\t\t\t\ttemp[i*a.col+j]+=val[i*col+k]*a.val[k*a.col+j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tMatrix b(rows,col,temp);\n\t\t\treturn b;\n\t\t}\n\t\tMatrix operator *(T a){\n\t\t\tvector <T> temp(rows*col);\n\t\t\tfor(int i=0;i<rows*col;i++){\n\t\t\t\ttemp[i]=val[i]*a;\n\t\t\t}\n\t\t\tMatrix b(rows,col,temp);\n\t\t\treturn b;\n\t\t}\n\t\t\tMatrix max(){\n\t\t\tvector <T> temp;\n\t\t\tT max=val[0];\n\t\t\tint maxrow=0;\n\t\t\t\tfor(int i=0;i<rows*col;i++){\n\t\t\t\t\t\n\t\t\t\t\tif(max<val[i]){\n\t\t\t\t\t\tmax=val[i];\n\t\t\t\t\t\tmaxrow=i/col;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(rows==1){\n\t\t\t\ttemp.push_back(max);\n\t\t\t\treturn Matrix(1,1,temp);\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\telse{\n\t\t\t\tfor(int i=0;i<col;i++){\n\t\t\t\t\ttemp.push_back(val[i+maxrow*col]);\n\t\t\t\t\t//cout<<\"  \"<<\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn Matrix(1,col,temp);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\n\t\tMatrix min(){\n\t\t\tvector <T> temp;\n\t\t\tT max=val[0];\n\t\t\tint maxrow=0;\n\t\t\t\tfor(int i=0;i<rows*col;i++){\n\t\t\t\t\t\n\t\t\t\t\tif(max>val[i]){\n\t\t\t\t\t\tmax=val[i];\n\t\t\t\t\t\tmaxrow=i/col;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(rows==1){\n\t\t\t\ttemp.push_back(max);\n\t\t\t\treturn Matrix(1,1,temp);\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\telse{\n\t\t\t\tfor(int i=0;i<col;i++)\n\t\t\t\ttemp.push_back(val[i+maxrow*col]);\n\t\t\t\treturn Matrix(1,col,temp);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\tMatrix sum(){\n\t\t\tvector <T> temp;\n\t\t\tint sum=0;\n\t\t\tif(rows==1){\n\t\t\t\tfor(int i=0;i<col;i++)\n\t\t\t\tsum+=val[i];\n\t\t\t\t\n\t\t\t\ttemp.push_back(sum);\n\t\t\t\treturn Matrix(1,1,temp);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int i=0;i<rows;i++){\n\t\t\t\t\tsum=0;\n\t\t\t\t\tfor(int j=0;j<col;j++){\n\t\t\t\t\t\tsum+=val[i*col+j];\n\t\t\t\t\t}\n\t\t\t\t\ttemp.push_back(sum);\n\t\t\t\t}\n\t\t\t\t\n\t\t\treturn Matrix(1,col,temp);\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n}; ",
            1590635821.6013474,
            100,
            "# 答案正确"
        ],
        [
            "6.2 (C++)",
            "王彬",
            "#include <iostream>\nusing namespace std;\ntemplate <typename T>\nclass Matrix\n{\n\tprivate:\n\t\tint rows;\n\t\tint columns;\n\t\tT * values;\n\tpublic:\n\t\tMatrix(int rows, int column)\n\t\t{\n\t\t\tthis->rows = rows;\n\t\t\tthis->columns = column;\n\t\t\tthis->values = new T [rows * columns + 1];\n\t\t\tfor (int i = 0; i < this->rows; ++ i)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < this->columns; ++ j) values[i * this->columns + j] = 0; \n\t\t\t}\n\t\t}\n\t\t~Matrix()\n\t\t{\n\t\t\tif(values != 0)\n\t\t\t{\n\t\t\t\tdelete [] values;\n\t\t\t\tvalues = 0;\n\t\t\t}\n\t\t}\n\t\tvoid print()\n\t\t{\n\t\t\tfor(int i = 0; i < rows; i ++)\n\t\t\t{\n\t\t\t\tfor(int j = 0; j < columns; j ++)\n\t\t\t\t{\n\t\t\t\t\tcout << \"    \" << values[i * columns + j];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n};",
            1590632784.6773756,
            100,
            "# 答案正确"
        ],
        [
            "7.2 (C++)",
            "王彬",
            "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nvector<string> split(string line)\n{\n\tvector<string> words;\n\tstring delimiter = \" \";\n\tint st = 0;\n\twhile (st < line.size())\n\t{\n\t\tint end = line.find(delimiter, st);\n\t\tif (end == st) st += 1;\n\t\telse\n\t\t{\n\t\t\tif (end == -1)\n\t\t\t{\n\t\t\t\twords.push_back(line.substr(st));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twords.push_back(line.substr(st, end - st));\n\t\t\tst = end + 1;\n\t\t}\n\t}\n\treturn words;\n}",
            1591238752.925079,
            100,
            "# 答案正确"
        ],
        [
            "7.1 (C++)",
            "王彬",
            "#include <cmath>\n\nclass Triangle: public GeometricObject\n{\n\tprivate:\n\t\tdouble side1 = 1.0;\n\t\tdouble side2 = 1.0;\n\t\tdouble side3 = 1.0;\n\tpublic:\n\t\tTriangle() {};\n\t\tTriangle(double a, double b, double c)\n\t\t{\n \t\t\tside1 = a;\n \t\t\tside2 = b;\n \t\t\tside3 = c;\n\t\t}\n\tdouble getSide1()\n\t{\n \t\treturn side1;\n\t}\n\tdouble getSide2()\n\t{\n \t\treturn side2;\n\t}\n\tdouble getSide3()\n\t{\n \t\treturn side3;\n\t}\n\tdouble getArea()\n\t{\n \t\tdouble s = (side1 + side2 + side3) / 2;\n\t\treturn sqrt(s * (s - side1) * (s - side2) * (s - side3));\n\t}\n \tdouble getPerimeter()\n\t{\n  \t\treturn side1 + side2 + side3;\n \t}\n};",
            1591240074.671897,
            100,
            "# 答案正确"
        ],
        [
            "7.3 (C++)",
            "王彬",
            "template<typename A, typename R>\nvector<R> map2(const vector<A> & x, const vector<A> & y, R(*map_func)(const A &, const A &))\n{\n\tvector<R> res;\n\tfor(int i = 0; i < x.size(); ++i)\n\t{\n\t\tres.push_back(map_func(x[i], y[i]));\n\t}\n\treturn res;\n}\n\ntemplate<typename A, typename R>\nvector<R> map2(const vector<A> & x, const int a, R (*map_func)(const A &, const A &))\n{\n\tvector<R> res;\n\tfor(int i = 0; i < x.size(); ++i)\n\t{\n\t\tres.push_back(map_func(x[i], a));\n\t}\n\treturn res;\n}\n",
            1591240764.3544617,
            100,
            "# 答案正确"
        ],
        [
            "8.1 (C++)",
            "王彬",
            "#include <iostream>\n\nusing namespace std;\n\nclass Full: public Matrix\n{\n\tprivate :\n\t\tint rows;\n\t\tint column;\n\t\tdouble * values;\n\t\tpublic:\n\t\t\tFull(int rows, int column)\n\t\t\t{\n\t\t\t\tthis->rows = rows;\n\t\t\t\tthis->column = column;\n\t\t\t\tthis->values = new double[this->rows * this->column + 1];\n\t\t\t\tfor (int i = 0; i < rows * column; i ++) this->values[i] = 0;\n\t\t\t}\n\t\t\tFull(int rows, int column, double values[])\n\t\t\t{\n\t\t\t\tthis->rows = rows;\n\t\t\t\tthis->column = column;\n\t\t\t\tthis->values = new double[this->rows * this->column + 1];\n\t\t\t\tfor(int i = 0; i < this->rows * this->column; i ++) this->values[i] = values[i];\n\t\t\t}\n\t\t\tFull(const Matrix & matrix2)\n\t\t\t{\n\t\t\t\tthis->rows = matrix2.size(1);\n\t\t\t\tthis->column = matrix2.size(2);\n\t\t\t\tthis->values = new double[this->rows * this->column + 1];\n\t\t\t\tfor(int i = 0; i < this->rows; i ++)\n\t\t\t\t{\n\t\t\t\t\tfor(int j = 0; j < this->column; j ++)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis->values[i * this->column + j] = matrix2.get(i + 1, j + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint size(int dimension) const\n\t\t\t{\n\t\t\t\tif(dimension==1) return rows;\n\t\t\t\telse return column;\n\t\t\t}\n\t\t\tvoid set(int row, int column, double value)\n\t\t\t{\n\t\t\t\tthis->values[(row-1) * this->column + column - 1] = value;\n\t\t\t}\n\t\t\tdouble get(int row, int column) const\n\t\t\t{\n\t\t\t\treturn this->values[(row-1) * this->column + column - 1];\n\t\t\t}\n\t\t\tvoid print() const\n\t\t\t{\n\t\t\t\tfor(int i = 0; i < this->rows; i ++)\n\t\t\t\t{\n\t\t\t\t\tfor(int j = 0; j < this->column; j ++)\n\t\t\t\t\t{\n\t\t\t\t\t\tcout << \"    \" << this->values[i * this->column + j];\n\t\t\t\t\t}\n\t\t\t\t\tcout << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\tMatrix & operator = (const Matrix & matrix2)\n\t\t\t{\n\t\t\t\tthis->rows = matrix2.size(1);\n\t\t\t\tthis->column = matrix2.size(2);\n\t\t\t\tif(values != 0)\n\t\t\t\t{\n\t\t\t\t\tdelete [] values;\n\t\t\t\t}\n\t\t\t\tthis->values = new double[this->rows * this->column + 1];\n\t\t\t\tfor(int i = 0; i < this->rows; i ++)\n\t\t\t\t{\n\t\t\t\t\tfor(int j = 0; j < this->column; j ++)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis->values[i * this->column + j] = matrix2.get(i + 1, j + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t\t~Full()\n\t\t\t{\n\t\t\t\tdelete [] values;\n\t\t\t}\n};",
            1591749141.5941343,
            100,
            "# 答案正确"
        ],
        [
            "8.3 (C++)",
            "王彬",
            "#include <iostream>\n\nusing namespace std;\n\nvoid sort(Entry * val,int cnt)\n{\n\tfor(int i = 0; i < cnt; i ++)\n\t{\n\t\tfor(int j = 0; j < cnt - 1; j ++)\n\t\t{\n\t\t\tif(val[j].row > val[j + 1].row || (val[j].row == val[j + 1].row && val[j].column > val[j + 1].column))\n\t\t\t{\n\t\t\t\tEntry temp = val[j];\n\t\t\t\tval[j] = val[j + 1];\n\t\t\t\tval[j + 1] = temp;\n\t\t\t}\n\t\t}\n\t}\n}\nclass Sparse : public Matrix\n{\n\tpublic:\n\t\tint cnt;\n\t\tEntry val[100];\n\t\tSparse(int rows, int column)\n\t\t{\n\t\t\tcnt = 0;\n\t\t}\n\t\tint size(int dimension) const\n\t\t{\n\t\t\treturn cnt;\n\t\t}\n\t\tvoid set(int row, int column, double value)\n\t\t{\n\t\t\tint flag=0;\n\t\t\tint i;\n\t\t\tfor(i = 0; i < cnt; i ++)\n\t\t\t{\n\t\t\t\tif(val[i].row == row && val[i].column == column)\n\t\t\t\t{\n\t\t\t\t\tflag = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\t\n\t\t\t}\n\t\t\tif(flag)\n\t\t\t{\n\t\t\t\tval[i].value = value;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcnt ++;\n\t\t\t\tval[cnt - 1].row = row;\n\t\t\t\tval[cnt - 1].column = column;\n\t\t\t\tval[cnt - 1].value = value;\n\t\t\t}\n\t\t}\n\t\tdouble get(int row, int column) const\n\t\t{\n\t\t\tfor(int i=0;i<cnt;i++)\n\t\t\t{\n\t\t\t\tif(val[i].row == row && val[i].column == column)\n\t\t\t\t{\n\t\t\t\t\treturn val[i].value;\n\t\t\t\t}\n\t\t\t}\n\t\t} \n\t\tvoid print()\n\t\t{\n\t\t\tsort(val, cnt);\n\t\t\tfor(int i = 0; i < cnt; i ++)\n\t\t\t{\n\t\t\t\tcout << \"(\" << val[i].row << \",\" << val[i].column << \",\" << val[i].value << \")\" << endl; \n\t\t\t}\n\t\t}\n\t\tSparse operator + (Sparse & sparse2)\n\t\t{\n\t\t\tSparse temp=*this;\n\t\t\tfor(int i = 0; i < sparse2.cnt; i ++)\n\t\t\t{\n\t\t\t\tint flag = 0;\n\t\t\t\tfor(int j = 0; j < cnt; j ++)\n\t\t\t\t{\n\t\t\t\t\tif(temp.val[j].row == sparse2.val[i].row && temp.val[j].column == sparse2.val[i].column)\n\t\t\t\t\t{\n\t\t\t\t\t\ttemp.val[j].value += sparse2.val[i].value;\n\t\t\t\t\t\tif(temp.val[j].value == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttemp.cnt --;\n\t\t\t\t\t\t\ttemp.val[j]=temp.val[temp.cnt];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag == 0)\n\t\t\t\t{\n\t\t\t\t\ttemp.val[temp.cnt ++]=sparse2.val[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn temp;\n\t\t}\n};\n",
            1591750061.1857536,
            100,
            "# 答案正确"
        ],
        [
            "8.4 (C++)",
            "王彬",
            "#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid sort(Entry * val,int cnt)\n{\n\tfor(int i = 0; i < cnt; i ++)\n\t{\n\t\tfor(int j = 0; j < cnt - 1; j ++)\n\t\t{\n\t\t\tif(val[j].row > val[j + 1].row || (val[j].row == val[j + 1].row && val[j].column > val[j + 1].column))\n\t\t\t{\n\t\t\t\tEntry temp = val[j];\n\t\t\t\tval[j] = val[j + 1];\n\t\t\t\tval[j + 1] = temp;\n\t\t\t}\n\t\t}\n\t}\n}\nclass Sparse : public Matrix\n{\n\tpublic:\n\t\tint cnt;\n\t\tEntry val[100];\n\t\tSparse(int rows, int column)\n\t\t{\n\t\t\tcnt = 0;\n\t\t}\n\t\tint size(int dimension) const\n\t\t{\n\t\t\treturn cnt;\n\t\t}\n\t\tvoid set(int row, int column, double value)\n\t\t{\n\t\t\tint flag=0;\n\t\t\tint i;\n\t\t\tfor(i = 0; i < cnt; i ++)\n\t\t\t{\n\t\t\t\tif(val[i].row == row && val[i].column == column)\n\t\t\t\t{\n\t\t\t\t\tflag = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\t\n\t\t\t}\n\t\t\tif(flag)\n\t\t\t{\n\t\t\t\tval[i].value = value;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcnt ++;\n\t\t\t\tval[cnt - 1].row = row;\n\t\t\t\tval[cnt - 1].column = column;\n\t\t\t\tval[cnt - 1].value = value;\n\t\t\t}\n\t\t}\n\t\tdouble get(int row, int column) const\n\t\t{\n\t\t\tfor(int i=0;i<cnt;i++)\n\t\t\t{\n\t\t\t\tif(val[i].row == row && val[i].column == column)\n\t\t\t\t{\n\t\t\t\t\treturn val[i].value;\n\t\t\t\t}\n\t\t\t}\n\t\t} \n\t\tvoid print()\n\t\t{\n\t\t\tsort(val, cnt);\n\t\t\tfor(int i = 0; i < cnt; i ++)\n\t\t\t{\n\t\t\t\tcout << \"(\" << val[i].row << \",\" << val[i].column << \",\" << val[i].value << \")\" << endl; \n\t\t\t}\n\t\t}\n\t\tSparse operator * (Sparse & sparse2)\n\t\t{\n\t\t\tSparse temp(0, 0);\n\t\t\tmemset(temp.val, 0, sizeof(double) * 100);\n\t\t\tfor(int i = 0; i < sparse2.cnt; i ++)\n\t\t\t{\n\t\t\t\tfor(int j = 0; j < cnt; j ++)\n\t\t\t\t{\n\t\t\t\t\tif(val[j].column == sparse2.val[i].row)\n\t\t\t\t\t{\n\t\t\t\t\t\tint flag = 1;\n\t\t\t\t\t\tfor(int k = 0; k < temp.cnt; k ++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(temp.val[k].row == val[j].row && temp.val[k].column == sparse2.val[i].column)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttemp.val[k].value += val[j].value * sparse2.val[i].value;\n\t\t\t\t\t\t\t\tflag = 0;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(flag)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttemp.val[temp.cnt].row = val[j].row;\n\t\t\t\t\t\t\ttemp.val[temp.cnt].column = sparse2.val[i].column;\n\t\t\t\t\t\t\ttemp.val[temp.cnt].value += val[j].value * sparse2.val[i].value;\n\t\t\t\t\t\t\ttemp.cnt ++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\t\n\t\t\t}\n\t\t\treturn temp;\n\t\t}\n};\n",
            1591753260.0515454,
            100,
            "# 答案正确"
        ],
        [
            "8.5 (C++)",
            "王彬",
            "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nclass Point3D : public Point2D\n{\n\tprivate:\n\t\tdouble z;\n\tpublic:\n\t\tPoint3D()\n\t\t{\n\t\t\tsetX(0);\n\t\t\tsetY(0);\n\t\t\tz = 0;\n\t\t}\n\t\tPoint3D(double x, double y, double z)\n\t\t{\n\t\t\tsetX(x);\n\t\t\tsetY(y);\n\t\t\tthis->z = z;\n\t\t}\n\t\tdouble getZ()\n\t\t{\n\t\t\treturn z;\n\t\t}\n\t\tdouble distance(Point2D & point2)\n\t\t{\n\t\t\tPoint3D & a = dynamic_cast<Point3D &> (point2);\n\t\t\tdouble dx = getX() - a.getX();\n\t\t\tdouble dy = getY() - a.getY();\n\t\t\tdouble dz = this->z - a.getZ();\n\t\t\treturn sqrt(dx * dx + dy * dy + dz * dz);\n\t\t}\n};",
            1591845671.8416798,
            100,
            "# 答案正确"
        ],
        [
            "8.6 (C++)",
            "王彬",
            "#include <iostream>\n\nusing namespace std;\n\nclass MyTensor:public Tensor<double>\n{\n \tprivate:\n  \t\tvector<double>nums;\n \tpublic:\n  \t\tMyTensor(vector<int>sizes):Tensor<double>(sizes)\n\t\t{\n   \t\t\tint total=1;\n   \t\t\tfor(int i=0;i<sizes.size();++i) total*=sizes[i];\n   \t\t\tfor(int i=0;i<total;++i) nums.push_back(double());\n  \t\t};\n  \t\tdouble&get(const vector<int>&indexes)\n\t\t{\n   \t\t\tint index=0;\n   \t\t\tfor(int i=0;i<indexes.size();++i)\n\t\t\t{\n    \t\t\tint temp=indexes[i];\n    \t\t\tfor(int j=i+1;j<indexes.size();++j) temp*=indexes[j];\n    \t\t\tindex+=temp;\n   \t\t\t}\n   \t\t\treturn nums[index];\n \t\t}\n \n}; ",
            1592450843.4352746,
            100,
            "# 答案正确"
        ],
        [
            "9.1 (C++)",
            "王彬",
            "#include <iostream>\n\nusing namespace std;\n\nclass Circle\n{\n\tprivate:\n\t\tdouble radius;\n\tpublic:\n\t\tCircle(double radius)\n\t\t{\n\t\t\tthis->radius = radius;\n\t\t}\n\t//<, <=, ==, !=, >, >=\n\tbool operator < (const Circle circle)\n\t{\n\t\tif (this->radius < circle.radius) return true;\n\t\telse return false;\n\t}\n\tbool operator <= (const Circle circle)\n\t{\n\t\tif (this->radius <= circle.radius) return true;\n\t\telse return false;\n\t}\n\tbool operator != (const Circle circle)\n\t{\n\t\tif (this->radius != circle.radius) return true;\n\t\telse return false;\n\t}\n\tbool operator == (const Circle circle)\n\t{\n\t\tif (this->radius == circle.radius) return true;\n\t\telse return false;\n\t}\n\tbool operator > (const Circle circle)\n\t{\n\t\tif (this->radius > circle.radius) return true;\n\t\telse return false;\n\t}\n\tbool operator >= (const Circle circle)\n\t{\n\t\tif (this->radius >= circle.radius) return true;\n\t\telse return false;\n\t}\n};",
            1592738478.1660779,
            100,
            "# 答案正确"
        ],
        [
            "9.2 (C++)",
            "王彬",
            "#include <iostream>\n\nusing namespace std;\n\nclass I\n{\n\tprivate:\n\t\tvector<int> sizes;\n\tpublic:\n\t\tI(int a, int b = -1, int c = -1, int d = -1)\n\t\t{\n\t\t\tsizes.push_back(a);\n\t\t\tif(b != -1) sizes.push_back(b);\n\t\t\tif(c != -1) sizes.push_back(c);\n\t\t\tif(d != -1) sizes.push_back(d);\n\t\t}\n\t\toperator vector<int>() const\n\t\t{\n\t\t\treturn this->sizes;\n\t\t}\n\n};",
            1592745336.1742887,
            100,
            "# 答案正确"
        ],
        [
            "9.3 (C++)",
            "王彬",
            "#include <iostream>\n\nusing namespace std;\n\nclass Complex\n{\n\tprivate:\n\t\tdouble m_real;\n\t\tdouble m_imag;\n\tpublic:\n\t\tComplex(double real, double imag)\n\t\t{\n\t\t\tthis->m_real = real;\n\t\t\tthis->m_imag = imag;\n\t\t}\n\t\tdouble real()\n\t\t{\n\t\t\treturn this->m_real;\n\t\t}\n\t\tdouble imag()\n\t\t{\n\t\t\treturn this->m_imag;\n\t\t}\n\t\tComplex operator + (Complex & c)\n\t\t{\n\t\t\tdouble num1 = this->m_real + c.m_real;\n\t\t\tdouble num2 = this->m_imag + c.m_imag;\n\t\t\tComplex com_com(num1, num2);\n\t\t\treturn com_com;\n\t\t}\n\t\tComplex operator - (Complex & c)\n\t\t{\n\t\t\tdouble num1 = this->m_real - c.m_real;\n\t\t\tdouble num2 = this->m_imag - c.m_imag;\n\t\t\tComplex com_com(num1, num2);\n\t\t\treturn com_com;\n\t\t}\n\t\tComplex operator * (Complex & c)\n\t\t{\n\t\t\tdouble num1 = this->m_real * c.m_real - this->m_imag * c.m_imag;\n\t\t\tdouble num2 = this->m_imag * c.m_real + this->m_real * c.m_imag;\n\t\t\tComplex com_com(num1, num2);\n\t\t\treturn com_com;\n\t\t}\n\t\tComplex operator / (Complex & c)\n\t\t{\n\t\t\tdouble num1 = (this->m_real * c.m_real + this->m_imag * c.m_imag) / (c.m_real * c.m_real + c.m_imag * c.m_imag);\n\t\t\tdouble num2 = (this->m_imag * c.m_real - this->m_real * c.m_imag) / (c.m_real * c.m_real + c.m_imag * c.m_imag);\n\t\t\tComplex com_com(num1, num2);\n\t\t\treturn com_com;\n\t\t}\n\t\tComplex operator - (double num)\n\t\t{\n\t\t\tdouble num1 = this->m_real - num;\n\t\t\tdouble num2 = this->m_imag;\n\t\t\tComplex com_com(num1, num2);\n\t\t\treturn com_com;\n\t\t}\n\t\tComplex & operator += (Complex & c)\n\t\t{\n\t\t\tthis->m_real = this->m_real + c.m_real;\n\t\t\tthis->m_imag = this->m_imag + c.m_imag;\n\t\t\treturn (*this);\n\t\t}\n\t\tComplex & operator -= (Complex & c)\n\t\t{\n\t\t\tthis->m_real = this->m_real - c.m_real;\n\t\t\tthis->m_imag = this->m_imag - c.m_imag;\n\t\t\treturn (*this);\n\t\t}\n\t\tComplex & operator *= (Complex & c)\n\t\t{\n\t\t\tdouble r = this->m_real, i = this->m_imag;\n\t\t\tthis->m_real = r * c.m_real - i * c.m_imag;\n\t\t\tthis->m_imag = i * c.m_real + r * c.m_imag;\n\t\t\treturn (*this);\n\t\t}\n\t\tComplex & operator /= (Complex & c)\n\t\t{\n\t\t\tdouble r = this->m_real, i = this->m_imag;\n\t\t\tthis->m_real = (r * c.m_real + i * c.m_imag) / (c.m_real * c.m_real + c.m_imag * c.m_imag);\n\t\t\tthis->m_imag = (i * c.m_real - r * c.m_imag) / (c.m_real * c.m_real + c.m_imag * c.m_imag);\n\t\t\treturn (*this);\n\t\t}\n};\nComplex operator + (double num, Complex & c)\n{\n\tdouble num1 = c.real() + num;\n\tdouble num2 = c.imag();\n\tComplex com_com(num1, num2);\n\treturn com_com;\n}\nbool operator == (Complex & c1, Complex & c2)\n{\n\tif(c1.real() == c2.real() && c1.imag() == c2.imag()) return true;\n\treturn false;\n}\nbool operator != (Complex & c1,Complex & c2)\n{\n\tif(c1 == c2) return false;\n\treturn true;\n}",
            1592747909.946127,
            100,
            "# 答案正确"
        ],
        [
            "9.4 (C++)",
            "王彬",
            "#include <iostream>\n\nusing namespace std;\n\nclass Complex\n{\n\tprivate:\n\t\tdouble real;\n\t\tdouble imag;\n\tpublic:\n\t\tfriend istream & operator>>(istream & in, Complex & A);\n    \tfriend ostream & operator<<(ostream & out, Complex & A);\n\t\tComplex operator + (const Complex c)\n\t\t{\n\t\t\tComplex com_com;\n\t\t\tcom_com.real = this->real + c.real;\n\t\t\tcom_com.imag = this->imag + c.imag;\n\t\t\treturn com_com;\n\t\t}\n\t\tComplex operator - (const Complex c)\n\t\t{\n\t\t\tComplex com_com;\n\t\t\tcom_com.real = this->real - c.real;\n\t\t\tcom_com.imag = this->imag - c.imag;\n\t\t\treturn com_com;\n\t\t}\n};\nistream & operator >> (istream & in, Complex & A)\n{\n\tin >> A.real >> A.imag;\n\treturn in;\n}\nostream & operator << (ostream & out, Complex & A)\n{\n\tout << A.real <<\" + \"<< A.imag <<\" i \";\n\treturn out;\n}",
            1592742769.2864504,
            100,
            "# 答案正确"
        ],
        [
            "9.5 (C++)",
            "王彬",
            "#include <iostream>\n\nusing namespace std;\n\nclass Complex\n{\n\tprivate:\n\t\tdouble real;\n\t\tdouble imag;\n\tpublic:\n\t\tfriend istream & operator >> (istream & in, Complex & c);\n\t\tfriend ostream & operator << (ostream & out,const Complex & c);\n\t\tComplex ()\n\t\t{ \n\t\t\tthis->real = 0;\n\t\t\tthis->imag = 0;\n\t\t}\n\t\tComplex(Complex & c)\n\t\t{\n\t\t\tthis->real = c.real;\n\t\t\tthis->imag = c.imag;\n\t\t}\n\t\toperator double() \n\t\t{\n\t\t\treturn this->real;\n\t\t}\n\t\tComplex operator ++ (int)\n\t\t{\n\t\t\tComplex c(*this);\n\t\t\t\n\t\t\tthis->real ++;\n\t\t\treturn c;\n\t\t}\n\t\tComplex & operator ++()\n\t\t{\n\t\t\tthis->real ++;\n\t\t\treturn (*this);\n\t\t}\n\t\t\n};\n\nistream & operator >> (istream & in, Complex & c)\n{\n\tin >> c.real >> c.imag;\n\treturn in;\n}\nostream & operator << (ostream & out,const Complex & c)\n{\n\tout << c.real << \" + \" << c.imag << \" i\" ;\n\treturn out;\n}",
            1592753143.45231,
            100,
            "# 答案正确"
        ],
        [
            "9.6 (C++)",
            "王彬",
            "#include <iostream>\n\nusing namespace std;\n\nclass Tensor\n{\n\tprivate:\n\t\tint sizes[4];\n\t\tdouble * data;\n\t\tint num;\n\n\tpublic:\n\t\tTensor(int a, int b = -1, int c = -1, int d = -1)\n\t\t{\n\t\t\tint count = 1;\n\t\t\tint sum = a;\n\t\t\tthis->sizes[0] = a;\n\t\t\tif(b!= -1)\n\t\t\t{\n\t\t\t\tcount ++;\n\t\t\t\tthis->sizes[1] = b;\n\t\t\t\tsum *= b;\n\t\t\t}\n\t\t\tif(c != -1)\n\t\t\t{\n\t\t\t\tcount ++;\n\t\t\t\tthis->sizes[2] = c;\n\t\t\t\tsum *= c;\n\t\t\t}\n\t\t\tif(d!=-1)\n\t\t\t{\n\t\t\t\tcount ++;\n\t\t\t\tthis->sizes[3] = d;\n\t\t\t\tsum *= d;\n\t\t\t}\n\t\t\tthis->num = count;\n\t\t\tdata = new double[sum];\n\t\t}\n\t\t~Tensor()\n\t\t{\n\t\t\tdelete[] data;\n\t\t}\n\t\tdouble & operator() (int a, int b = -1, int c = -1, int d =- 1)\n\t\t{\n\t\t\tint index = a;\n\t\t\tif(b != -1)\n\t\t\t{\n\t\t\t\tindex += b * this->sizes[0];\n\t\t\t}\n\t\t\tif(c != -1)\n\t\t\t{\n\t\t\t\tindex += c * this->sizes[0] * this->sizes[1];\n\t\t\t}if(d != -1)\n\t\t\t{\n\t\t\t\tindex += d * this->sizes[0] * this->sizes[1] * this->sizes[2];\n\t\t\t}\n\t\t\treturn data[index];\n\t\t}\n};",
            1592753984.2780807,
            100,
            "# 答案正确"
        ],
        [
            "9.7 (C++)",
            "王彬",
            "#include <iostream>\n\nusing namespace std;\n\nclass Tensor\n{\n\tprivate:\n\t\tint num;\n\t\tint size[4];\n\t\tdouble * value;\n\tpublic:\n\t\tfriend istream & operator>>(istream & in, Tensor & tensor);\n    \tfriend ostream & operator<<(ostream & out, Tensor & tensor);\n\t\tTensor() {}\n\t\t~Tensor()\n\t\t{\n\t\t\tdelete[] value;\n\t\t}\n};\nistream & operator >> (istream & in, Tensor & tensor)\n{\n\tin >> tensor.num;\n\tint sum = 1;\n\tfor (int i = 0; i < tensor.num; i ++)\n\t{\n\t\tin >> tensor.size[i];\n\t\tsum *= tensor.size[i];\n\t}\n\ttensor.value = new double[sum + 1];\n\tfor (int i = 0; i < sum; i ++) in >> tensor.value[i];\n\treturn in;\n}\nostream & operator << (ostream & out, Tensor & tensor)\n{\n\tout << tensor.num;\n\tint sum = 1;\n\tout << endl;\n\tfor (int i = 0; i < tensor.num; i ++)\n\t{\n\t\tout << tensor.size[i] << \" \";\n\t\tsum *= tensor.size[i];\n\t}\n\tout << endl << endl;\n\tswitch (tensor.num)\n\t{\n\t\tcase 2:\n\t\t\tfor (int a = 0; a < tensor.size[0]; a++)\n\t\t\t{\n\t\t\t\tfor (int b = 0; b < tensor.size[1]; b++)\n\t\t\t\t{\n\t\t\t\t\tout << tensor.value[a * tensor.size[2] + b] << \" \";\n\t\t\t\t}\n\t\t\t\tout << endl;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tfor (int a = 0; a < tensor.size[0]; a++)\n\t\t\t{\n\t\t\t\tfor (int b = 0; b < tensor.size[1]; b++)\n\t\t\t\t{\n\t\t\t\t\tfor (int c = 0; c < tensor.size[2]; c++)\n\t\t\t\t\t{\n\t\t\t\t\t\tout << tensor.value[a * tensor.size[2] * tensor.size[1] + b * tensor.size[0] + c] << \" \";\n\t\t\t\t\t}\n\t\t\t\t\tout << endl;\n\t\t\t\t}\n\t\t\t\tout << endl;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tfor (int a = 0; a < tensor.size[0]; a++)\n\t\t\t{\n\t\t\t\tfor (int b = 0; b < tensor.size[1]; b++)\n\t\t\t\t{\n\t\t\t\t\tfor (int c = 0; c < tensor.size[2]; c++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int d = 0; d < tensor.size[3]; d++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tout << tensor.value[a * tensor.size[3] * tensor.size[2] * tensor.size[1] + b * tensor.size[3] * tensor.size[2] + c * tensor.size[3] + d] << \" \";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tout << endl;\n\t\t\t\t\t}\n\t\t\t\t\tout << endl;\n\t\t\t\t}\n\t\t\t\n\t\t\t}\n\t\t\tout << endl;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\treturn out;\n}",
            1592756086.576136,
            100,
            "# 答案正确"
        ],
        [
            "10.1 (C++)",
            "王彬",
            "#include <iostream>\n#include <exception>\nclass MatrixSizesDoNotMatchException\n{\n};\n\ndouble Matrix::get(int r, int c) const\n{\n\tif (r > this->size(1) || c > this->size(2))\n\t{\n\t\tout_of_range error(\"A\");\n\t\tthrow error;\n\t}\n\t\t\n\tint size1 = size(2);\n\treturn elements[r * size1 + c];\n}\n\nvoid Matrix:: set(int r,int c,double v)\n{\n\tint sizes1 = this->size(1), sizes2 = this->size(2);\n\tif(r>sizes1 || c > sizes2)\n\t{\n\t\tout_of_range error(\"A\");\n\t\tthrow error;\n\t}\n\telse\n\t{\n\t\tint index = r * sizes2 + c;\n\t\tthis->elements[index] = v;\n\t}\n}\n\nMatrix Matrix::operator+(const Matrix & M)const\n{\n\tif(this->size(1) != M.size(1) || this->size(2) != M.size(2))\n\t{\n\t\tMatrixSizesDoNotMatchException error;\n\t\tthrow error;\n\t}\n\telse\n\t{\n\t\tMatrix result(M.size(1), M.size(2));\n\t\tfor (int i = 1; i <= M.size(1);i++)\n\t\t{\n\t\t\tfor (int j = 1; j <= M.size(2);j++)\n\t\t\t{\n\t\t\t\tresult.set(i, j, M.get(i, j) + this->get(i, j));\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n",
            1593577301.3701777,
            100,
            "# 答案正确"
        ],
        [
            "10.2 (C++)",
            "王彬",
            "catch (NonPositiveValueException & ex)\n{\n\tcout << \"caught: NonPositiveValueException\" << endl;\n}\ncatch(out_of_range & ex)\n{\n\tcout << \"caught: out_of_range\" << endl;\n}",
            1593657948.4901948,
            100,
            "# 答案正确"
        ],
        [
            "15.1 (C++)",
            "王彬",
            "#include <string>\n#include <vector>\nusing namespace std;\nstring tostr(vector<string> value)\n{\n\tstring tmp;\n\tstring result;\n\tresult.push_back('\\t');\n\tresult.push_back('\\t');\n\tresult.push_back('[');\n\tfor (int i = 0; i < value.size(); i++)\n\t{\n\t\ttmp = value[i];\n\t\tresult.push_back('\\'');\n\t\tfor (int j = 0; j < tmp.size(); j++)\n\t\t\tresult.push_back(tmp[j]);\n\t\tresult.push_back('\\'');\n\t\tresult.push_back(',');\n\t}\n\tresult.insert(result.size(), \"],\\n\");\n\treturn result;\n}\n\nclass Table\n{\n\t\n\tvector<string> head;\n\tvector<vector<string>> value;\n\npublic:\n\tvoid addCol(string str)\n\t{\n\t\thead.push_back(str);\n\t};\n\tTable()\n\t{\n\t\thead.resize(0);\n\t\tvalue.resize(0);\n\t}\n\tstring json()const\n\t{\n\t\tstring result;\n\t\tresult = \"{\\n\\theaders: [\";\n\t\tstring tmp;\n\t\tfor (int i = 0; i < head.size();i++)\n\t\t{\n\t\t\ttmp = head[i];\n\t\t\tresult.push_back('\\'');\n\t\t\tfor (int j = 0; j < tmp.size();j++)\n\t\t\t\tresult.push_back(tmp[j]);\n\t\t\tresult.push_back('\\'');\n\t\t\t\n\t\t\tresult.push_back(',');\n\t\t}\n\t\tresult.insert(result.size(), \"],\\n\\trows: [\\n\");\n\t\tfor (int i = 0; i < value.size();i++)\n\t\t\tresult.insert(result.size(), tostr(value[i]));\n\n\t\tresult.insert(result.size(), \"\\t],\\n}\");\n\n\t\treturn result;\n\t}\n\tvector<string> & operator[](int index)\n\t{\n\t\t\n\t\tif(index < value.size())\n\t\t{\n\t\t\t\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvalue.resize(index+1);\t\n\t\t}\n\t\treturn value[index];\n\t}\n};",
            1594183988.2899182,
            100,
            "# 答案正确"
        ],
        [
            "2020-07-09 LAB",
            "王彬",
            "#include<iostream>\n#include<vector>\nusing namespace std;\n\nclass Integer{\nprivate:\n    int num;\n    static vector<Integer*> index;\npublic:\n    Integer(): num(0){\n        index.push_back(this);\n    }\n    Integer(int x): num(x){\n        index.push_back(this);\n    }\n    void change_value(const int& x){num = x;}\n    int get_value()const{return num;}\n    static void increase_all(const Integer& x){\n        for(int i = 0;i < index.size();i++){\n            index[i]->change_value(index[i]->get_value()+x.get_value());\n        }\n    }\n};\nvector<Integer*> Integer::index = vector<Integer*>();\n\nistream& operator >> (istream& in,Integer& x){\n    int num;\n    in >> num;\n    x.change_value(num);\n    return in;\n}\nostream& operator << (ostream& out,Integer& x){\n    out << x.get_value();\n    return out;\n}",
            1594265123.8008506,
            100,
            "# 答案正确"
        ],
        [
            "A.1 (C++)",
            "王彬",
            "LinkedList(const LinkedList &o) : _size(0), head(0), tail(0)\n{\n\taddAll(o);\n}\nLinkedList & operator= (const LinkedList & o)\n{\n\tclear();\n\taddAll(o);\n}\n~LinkedList()\n{\n\tclear();\n}\nvoid clear()\n{\n\twhile(_size > 0) removeFirst();\n}\nvoid addAll(const LinkedList & o)\n{\n\tNode<E> *temp = o.head;\n\tNode<E> *prev = 0;\n\tNode<E> *next = temp->next_node(prev);\n\tfor (int i = 0; i < o._size-1;i++)\n\t{\n\t\tadd( i, temp->element);\n\t\tprev = temp;\n\t\ttemp = next;\n\t\tnext = next->next_node(prev);\n\t}\n\tadd(o._size, temp->element);\n}\nvoid print(const LinkedList &o)\n{\n\tNode<E> *temp = o.head;\n\tNode<E> *prev = 0;\n\tNode<E> *next = temp->next_node(prev);\n\tfor (int i = 0; i < o._size-1;i++)\n\t{\n\t\tcout << temp->element << \" \";\n\t\tprev = temp;\n\t\ttemp = next;\n\t\tnext = next->next_node(prev);\n\t}\n\tcout <<temp->element<< endl;\n}\nvoid add(int index,const E o)\n{\n\tNode<E> *node = new Node<E>();\n\tnode->element = o;\n\tif(this->head == 0)\n\t{\n\t\tthis->head = node;\n\t\tthis->tail = this->head;\n\t}\n\telse if(index==0 && this->head != 0)\n\t{\n\t\thead->update_prev_node(0, node);\n\t\tnode->update_next_node(0, head);\n\t\thead = node;\n\t}\n\telse if(index=this->_size)\n\t{\n\t\tNode<E> *temp = this->tail;\n\t\tNode<E> *next = 0;\n\t\tnext = node;\n\t\tnode->update_prev_node(0, temp);\n\t\ttemp->update_next_node(0, next);\n\t\ttail = node;\n\t}\n\t++_size;\n}\nvoid remove(int index)\n{\n\tif(index==0)\n\t{\n\t\tNode<E> *temp = this->head;\n\t\tNode<E> *next = temp->next_node(0);\n\t\tNode<E> *prev = 0;\n\t\tif(next!=0)\n\t\t{\n\t\t\tnext->update_prev_node(head,0);\n\t\t}\n\t\thead = next;\n\t\tdelete temp;\n\t}\n\telse\n\t{\n\t\tNode<E> *temp = this->tail;\n\t\tNode<E> *prev = temp->prev_node(0);\n\t\tthis->tail = prev;\n\t\tprev->update_next_node(temp, 0);\n\t\tdelete temp;\n\t}\n\tthis->_size--;\n}\nvoid addFirst(E val)\n{\n\tadd(0, val);\n}\nvoid addLast(E val)\n{\n\tadd(_size, val);\n}\nvoid removeFirstOccurrence(int val)\n{\n\tNode<E> *temp = this->head;\n\tNode<E> *next = temp->next_node(0);\n\tNode<E> *prev = 0;\n\tif(this->tail->element == val)\n\t{\n\t\tremoveLast();\n\t\treturn;\n\t}\n\telse if(this->head->element==val)\n\t{\n\t\tremoveFirst();\n\t\treturn;\n\t}\n\tfor (int i = 0; i < this->_size-1;i++)\n\t{\n\t\tprev = temp, temp = next;\n\t\tnext = temp->next_node(prev);\n\t\tif (temp->element == val) break;\n\t}\n\tprev->update_next_node(temp, next);\n\tnext->update_prev_node(temp, prev);\n\tdelete temp;\n\tthis->_size--;\n}\nint get(int index)\n{\n\tNode<E> *temp = this->head;\n\tNode<E> *prev = 0;\n\tNode<E> *next = temp->next_node(prev);\n\tif(index==this->_size-1) return this->tail->element;\n\telse if(index==0)\n\t{\n\t\treturn temp->element;\n\t}\n\treturn temp->element;\n}\nvoid removeLast()\n{\n\tremove(this->_size);\n}\nvoid removeFirst()\n{\n\tremove(0);\n}",
            1594813646.3542228,
            100,
            "# 答案正确"
        ],
        [
            "A.2 (C++)",
            "王彬",
            "template <typename E>\nvoid LinkedList<E>:: removeAll(const E & e){\n\t if(contains( e)==false) return;\n\t removeFirstOccurrence(e);\n\t removeAll(e);\n}",
            1594868565.7662601,
            100,
            "# 答案正确"
        ],
        [
            "A.3 (C++)",
            "王彬",
            "#include <vector>\nusing namespace std;\n\ntemplate <typename E>\nclass Tuple {\n\tpublic:\n\t\tint key;\n\t\tE val;\n\t\tbool in_use;\n\t\tTuple() {\n\t\t\tin_use = false;\n\t\t}\n};\n\ntemplate <typename E>\nclass HT {\n\tprivate:\n\t\tvector<Tuple<E>> tuples;\n\t\tint _size;\n\n\tpublic:\n\t\tHT() {\n\t\t\ttuples.resize(4000);\n\t\t\t_size = 0;\n\t\t}\n\t\tint hashfunction(int key) {\n\t\t\tint hashcode = 0;\n\t\t\twhile (key) {\n\t\t\t\thashcode = (hashcode << 5) + (key % 10);\n\t\t\t\tkey /= 10;\n\t\t\t}\n\t\t\treturn hashcode % tuples.size();\n\t\t}\n\t\tint indexofkey(int key) {\n\t\t\tint index = hashfunction(key);\n\t\t\twhile (true) {\n\t\t\t\tif (tuples[index].in_use == false)\n\t\t\t\t\treturn index;\n\t\t\t\tif (tuples[index].key == key)\n\t\t\t\t\treturn index;\n\t\t\t\tindex = (index + 1) % tuples.size();\n\t\t\t}\n\t\t}\n\t\tvoid put(int key, E val) {\n\t\t\tint index = indexofkey(key);\n\t\t\ttuples[index].val = val;\n\t\t\ttuples[index].key = key;\n\t\t\tif (tuples[index].in_use == false) {\n\t\t\t\ttuples[index].in_use = true;\n\t\t\t\t_size++;\n\t\t\t}\n\t\t}\n\t\tint size() {\n\t\t\treturn _size;\n\t\t}\n\t\tbool containsKey(int key) {\n\t\t\tint index = indexofkey(key);\n\t\t\treturn tuples[index].in_use == true;\n\t\t}\n\t\tE operator[](int key) {\n\t\t\tint index = indexofkey(key);\n\t\t\treturn tuples[index].val;\n\t\t}\n\t\tvector<int> getKeys() {\n\t\t\tvector<int> re;\n\t\t\tfor (int i = 0; i < tuples.size(); i++) {\n\t\t\t\tif (tuples[i].in_use) {\n\t\t\t\t\tre.push_back(tuples[i].key);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn re;\n\t\t}\n\t\tvoid remove(int key) {\n\t\t\tint index = indexofkey(key);\n\t\t\ttuples[index].in_use = false;\n\t\t\t_size--;\n\t\t}\n};",
            1595473935.0928237,
            100,
            "# 答案正确"
        ],
        [
            "A.4 (C++)",
            "王彬",
            "#include <iostream>\n#include <sstream>\n#include <string>\nusing namespace std;\nclass Tuple\n{\n\tpublic:\n\t\tint key;\n\t\tint value;\n\t\tTuple() {}\n\t\tTuple(int key, int value)\n\t\t{\n\t\t\tthis->key = key;\n\t\t\tthis->value = value;\n\t\t}\n\t\toperator int()\n\t\t{\n\t\t\treturn this->value;\n\t\t}\n\t\toperator string()\n\t\t{\n\t\t\tstring result;\n\t\t\tstringstream s_s;\n\t\t\ts_s << this->value;\n\t\t\ts_s >> result;\n\t\t\treturn result;\n\t\t}\n};\nclass HT\n{\n\tprivate:\n\t\tTuple dict[10];\n\t\tint _size;\n\tpublic:\n\t\tHT(): _size(0) {}\n\t\t~HT(){}\n\t\ttemplate<typename K,typename V>\n\t\tvoid put(K key,V value)\n\t\t{\n\t\t\tint k;\n\t\t\tint val;\n\t\t\tk = str_to_int(key);\n\t\t\tval = str_to_int(value);\n\t\t\tTuple ling(k, val);\n\t\t\tdict[this->_size] = ling;\n\t\t\tthis->_size ++;\n\t\t}\n\t\tint size()\n\t\t{\n\t\t\treturn this->_size;\n\t\t}\n\t\tint str_to_int(int str)\n\t\t{\n\t\t\treturn str;\n\t\t}\n\t\tint str_to_int(string str)\n\t\t{\n\t\t\tstringstream s_s;\n\t\t\ts_s << str;\n\t\t\tint res;\n\t\t\ts_s >> res;\n\t\t\treturn res;\n\t\t}\n\t\tstring int_to_str(string v)\n\t\t{\n\t\t\treturn v;\n\t\t}\n\t\tstring int_to_str(int v)\n\t\t{\n\t\t\tstring result;\n\t\t\tstringstream s_s;\n\t\t\ts_s << v;\n\t\t\ts_s >> result;\n\t\t\treturn result;\n\t\t}\n\t\ttemplate < typename V>\n\t\tTuple operator[](const V &index)\n\t\t{\n\t\t\tint ling;\n\t\t\tling = str_to_int(index);\n\t\t\tfor (int i = 0; i <= 10;i++)\n\t\t\t{\n\t\t\t\tif(dict[i].key == ling)\n\t\t\t\t{\n\t\t\t\t\treturn dict[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n};",
            1595684156.8445702,
            100,
            "# 答案正确"
        ],
        [
            "A.5 (C++)",
            "王彬",
            "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <map> \n#include <algorithm>\nusing namespace std;\nint total = 0;\nclass V\n{\npublic:\n string s;\n int i;\n V(int _i) :i(_i) {\n }\n V(string _s) :s(_s) {\n }\n operator string() {\n  return s;\n }\n operator int() {\n  return i;\n }\n V& operator=(int val){\n   i=val;\n   return *this;\n }\n V& operator=(string val){\n  s=val;\n  return *this;\n }\n};\n\nclass HT {\n class Tuple1 {\n public:\n  int key;\n  V value;\n  Tuple1(int _key, int _value) :key(_key), value(_value) { total++; };\n  Tuple1(int _key, string _value) :key(_key), value(_value) { total++; };\n };\n class Tuple2 {\n public:\n  string key;\n  V value;\n  Tuple2(string _key, string _value) :key(_key), value(_value) { total++; };\n  Tuple2(string _key, int _value) :key(_key), value(_value) { total++; };\n  void operator=(int val){\n   value=val;\n  }\n  void operator=(string val){\n   value=val;\n  }\n };\n vector<Tuple1>t1;\n vector<Tuple2>t2;\n\npublic:\n int size() { return total; }\n void put(int _key, int _value) {\n  t1.push_back(Tuple1(_key, _value));\n }\n void put(int _key, string _value) {\n  t1.push_back(Tuple1(_key, _value));\n }\n void put(string _key, int _value) {\n  t2.push_back(Tuple2(_key, _value));\n }\n void put(string _key, string _value) {\n  t2.push_back(Tuple2(_key, _value));\n }\n V& operator [] (const int& key) {\n  for (int i = 0; i < t1.size(); ++i) {\n   if (t1[i].key == key) return t1[i].value;\n  }\n  put(key,5);\n  for (int i = 0; i < t1.size(); ++i) {\n   if (t1[i].key == key) {\n    return t1[i].value;\n   }\n  }\n }\n V& operator [] (const string& key) {\n  for (int i = 0; i < t2.size(); ++i) {\n   if (t2[i].key == key) return t2[i].value;\n  }\n  put(key,5);\n  for (int i = 0; i < t2.size(); ++i) {\n   if (t2[i].key == key) {\n    return t2[i].value;\n   }\n  }\n }\n\n};",
            1596199300.2931306,
            100,
            "# 答案正确"
        ]
    ],
    "table_name": "答案"
}