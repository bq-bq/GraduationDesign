{
    "__update_time__": 1595486659.8367343,
    "field_names": [
        "题目名",
        "用户名",
        "答案",
        "提交时间",
        "分数",
        "评语"
    ],
    "field_types": [
        "text",
        "text",
        "text",
        "time",
        "number",
        "text"
    ],
    "foreign_keys": {},
    "primary_keys": [],
    "rows": [
        [
            "测试1",
            "麦子丰",
            "#include <iostream>\nusing namespace std;\n#define MAX 100\n\nint main(){\n    char str[3][MAX];\n    for(int i = 0; i < 3; ++i)\n        cin>>str[i];\n    cout<<str[2]<<' ';\n    cout<<str[0]<<' '<<str[0]<<' '<<endl;\n    cout<<endl;\n    return 0;\n}",
            1587512413.0,
            100,
            "# 答案正确"
        ],
        [
            "测试2",
            "麦子丰",
            "#include <cstring>\n#include <iostream>\nusing namespace std;\n#define MAX 100\n\nint main(){\n\t char str[10][MAX];\n    for(int i = 0; i < 10; i++)\n        cin>>str[i];\n    for(int i = 0; i < 9; i++){\n        for(int j = i; j < 10; j++){\n            if(strcmp(str[i], str[j]) > 0){\n                char tmp[MAX];\n                strcpy(tmp, str[i]);\n                strcpy(str[i], str[j]);\n                strcpy(str[j], tmp);\n            }\n        }\n    }\n    for(int i = 0; i < 10; i++)\n        cout<<str[i]<<' ';\n    cout<<endl;\n    return 0;\n}",
            1587608570.2763164,
            100,
            "# 答案正确"
        ],
        [
            "1.1 (C++)",
            "麦子丰",
            "#include <cstring>\n\nclass Matrix5x5{\n    private:\n        double matrix[5][5];\n    public:\n        Matrix5x5();\n        double get(int row,int col);\n        void set(int row, int col, double value);\n        Matrix5x5 operator + (Matrix5x5 & A);\n};\n\nMatrix5x5::Matrix5x5(){\n    memset(matrix,0,sizeof(matrix));\n}\n\ndouble Matrix5x5::get(int row, int col){\n    return matrix[row][col];\n}\n\nvoid Matrix5x5::set(int row, int col, double value){\n    matrix[row][col] = value;\n}\n\nMatrix5x5 Matrix5x5::operator + (Matrix5x5 & A){\n    Matrix5x5 res;\n    for(int i = 0; i < 5; i++){\n        for(int j = 0; j < 5; j++){\n            res.matrix[i][j] = A.matrix[i][j] + matrix[i][j];\n        }\n    }\n    return res;\n}",
            1587697042.487513,
            100,
            "# 答案正确"
        ],
        [
            "1.2 (C++)",
            "麦子丰",
            "#include <cstring>\n#define MAX 10\n\nclass School{\n    public:\n        char name[MAX];\n        int age;\n        School():age(0),name(\"NO_NAME\"){}\n        void setName(char name_[]);\n        void setAge(int year);\n        void operator ++ ();\n};\n\nvoid School::setName(char name_[]){\n    strcpy(this->name,name_);\n}\n\nvoid School::setAge(int year){\n    this->age = year;\n}\n\nvoid School::operator ++(){\n    ++this->age;\n}",
            1588212638.474538,
            100,
            "# 答案正确"
        ],
        [
            "2.1 (C++)",
            "麦子丰",
            "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nclass Matrix{\n    private:\n        int rows,columns;\n        double* values;\n    public:\n        Matrix(int rows_,int columns_);\n        ~Matrix();\n        void print();\n};\n\nMatrix::Matrix(int rows_,int columns_):rows(rows_),columns(columns_){\n    values = new double[rows*columns];\n    memset(values,0,rows*columns*sizeof(double));\n}\n\nMatrix::~Matrix(){\n    delete[] values;\n}\n\nvoid Matrix::print(){\n    for(int i = 0; i < rows; ++i){\n        for(int j = 0; j < columns; ++j){\n            cout << \"    \" << values[i*columns+j];\n        }\n        cout << endl;\n    }\n}",
            1588828731.1242552,
            100,
            "# 答案正确"
        ],
        [
            "2.2 (C++)",
            "麦子丰",
            "#include <iostream>\n#include <cstring>\n#include <iomanip>\nusing namespace std;\n\nclass Matrix{\n    private:\n        int rows,columns;\n        double* values;\n    public:\n        Matrix(int rows_,int columns_,double values_[]);\n        ~Matrix();\n        void print();\n};\n\nMatrix::Matrix(int rows_,int columns_,double values_[]):rows(rows_),columns(columns_){\n    values = new double[rows*columns];\n    memcpy(values,values_,rows*columns*sizeof(double));\n}\n\nMatrix::~Matrix(){\n    delete[] values;\n}\n\nvoid Matrix::print(){\n    for(int i = 0; i < rows; ++i){\n        for(int j = 0; j < columns; ++j){\n            cout << setw(5) << setfill(' ') << values[i*columns+j];\n        }\n        cout << endl;\n    }\n}",
            1588828980.0622964,
            100,
            "# 答案正确"
        ],
        [
            "2.3 (C++)",
            "麦子丰",
            "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nclass Matrix{\n    private:\n        int rows,columns;\n        double* values;\n    public:\n        Matrix(int rows_,int columns_,double values_[]);\n        Matrix(const Matrix & matrix2);\n        ~Matrix();\n        void print();\n};\n\nMatrix::Matrix(int rows_,int columns_,double values_[]):rows(rows_),columns(columns_){\n    values = new double[rows*columns];\n    memcpy(values,values_,rows*columns*sizeof(double));\n}\n\nMatrix::Matrix(const Matrix & matrix2){\n    this->rows = matrix2.rows;\n    this->columns = matrix2.columns;\n    values = new double[rows*columns];\n    memcpy(values,matrix2.values,rows*columns*sizeof(double));\n}\n\nMatrix::~Matrix(){\n    delete[] values;\n}\n\nvoid Matrix::print(){\n    for(int i = 0; i < rows; ++i){\n        for(int j = 0; j < columns; ++j){\n            cout << \"    \" << values[i*columns+j];\n        }\n        cout << endl;\n    }\n}",
            1588829190.0532148,
            100,
            "# 答案正确"
        ],
        [
            "2.5 (C++)",
            "麦子丰",
            "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nclass Matrix{\n    private:\n        int rows,columns;\n        double* values;\n    public:\n        Matrix(int rows_,int columns_);\n        Matrix(int rows_,int columns_,double values_[]);\n        Matrix(const Matrix & matrix2);\n        ~Matrix();\n        void print();\n        Matrix getRow(int row);\n        Matrix getColumn(int column);\n};\n\nMatrix::Matrix(int rows_,int columns_):rows(rows_),columns(columns_){\n    values = new double[rows*columns];\n    memset(values,0,rows*columns*sizeof(double));\n}\n\nMatrix::Matrix(int rows_,int columns_,double values_[]):rows(rows_),columns(columns_){\n    values = new double[rows*columns];\n    memcpy(values,values_,rows*columns*sizeof(double));\n}\n\nMatrix::Matrix(const Matrix & matrix2){\n    this->rows = matrix2.rows;\n    this->columns = matrix2.columns;\n    values = new double[rows*columns];\n    memcpy(values,matrix2.values,rows*columns*sizeof(double));\n}\n\nMatrix::~Matrix(){\n    delete[] values;\n}\n\nvoid Matrix::print(){\n    for(int i = 0; i < rows; ++i){\n        for(int j = 0; j < columns; ++j){\n            cout << \"    \" << values[i*columns+j];\n        }\n        cout << endl;\n    }\n}\n\nMatrix Matrix::getRow(int row){\n    Matrix res(1, this->columns);\n    --row;\n    for(int i = 0; i < this->columns; ++i){\n        res.values[i] = values[this->columns*row+i];\n    }\n    return res;\n}\n\nMatrix Matrix::getColumn(int column){\n    Matrix res(this->rows, 1);\n    --column;\n    for(int i = 0; i < this->rows; ++i){\n        res.values[i] = values[i*this->columns + column];\n    }\n    return res;\n}",
            1588830792.4188359,
            100,
            "# 答案正确"
        ],
        [
            "2.6 (C++)",
            "麦子丰",
            "#include <cstring>\n#include <iostream>\nusing namespace std;\n\nclass Matrix{\n    private:\n        int rows,columns;\n        double* values;\n    public:\n        Matrix(int rows_,int columns_,double values_[]);\n        Matrix(const Matrix & matrix2);\n        ~Matrix();\n        void print();\n        Matrix concatenateRows(const Matrix & matrix2)const;\n        Matrix concatenateColumns(const Matrix & matrix2)const;\n};\n\nMatrix::Matrix(int rows_,int columns_,double values_[]):rows(rows_),columns(columns_){\n    values = new double[rows*columns];\n    memcpy(values,values_,rows*columns*sizeof(double));\n}\n\nMatrix::Matrix(const Matrix & matrix2){\n    this->rows = matrix2.rows;\n    this->columns = matrix2.columns;\n    values = new double[rows*columns];\n    memcpy(values,matrix2.values,rows*columns*sizeof(double));\n}\n\nMatrix::~Matrix(){\n    delete[] values;\n}\n\nvoid Matrix::print(){\n    for(int i = 0; i < rows; ++i){\n        for(int j = 0; j < columns; ++j){\n            cout << \"    \" << values[i*columns+j];\n        }\n        cout << endl;\n    }\n}\n\nMatrix Matrix::concatenateRows(const Matrix & matrix2)const{\n    int row = this->rows + matrix2.rows;\n    int col = this->columns;\n    double value[row*col];\n    for(int i = 0; i < row; ++i){\n        for(int j = 0; j < col; ++j){\n            if(i < this->rows){//this\n                value[i*col+j] = this->values[i*this->columns+j];\n            }\n            else{//matrix2\n                value[i*col+j] = matrix2.values[(i-this->rows)*matrix2.columns+j];\n            }\n        }\n    }\n    Matrix res(row,col,value);\n    return res;\n}\n\nMatrix Matrix::concatenateColumns(const Matrix & matrix2) const{\n    int row = this->rows;\n    int col = this->columns + matrix2.columns;\n    double value[row*col];\n    for(int i = 0; i < row; ++i){\n        for(int j = 0; j < col; ++j){\n            if(j < this->columns){//this\n                value[i*col+j] = this->values[i*this->columns+j];\n            }\n            else{//matrix2\n                value[i*col+j] = matrix2.values[i*matrix2.columns+j-this->columns];\n            }\n        }\n    }\n    Matrix res(row,col,value);\n    return res;\n}",
            1588834019.6954849,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/08",
            "麦子丰",
            "double& Tensor_get(int dimensions, const int sizes[], double data[], int x0, int x1, int x2, int x3){\n    int a,b,c,d;\n    a = sizes[0];b = sizes[1];\n    c = sizes[2];d = sizes[3];\n    int index;\n    if(dimensions == 4) \n        index = x0*b*c*d + x1*c*d + x2*d + x3;\n    else if(dimensions == 3) \n        index = x0*b*c + x1*c + x2;\n    else if(dimensions == 2) \n        index = x0*b + x1;\n    else \n        index = x0;\n    return data[index];\n}",
            1588905536.987507,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/14",
            "麦子丰",
            "#include <iostream>\nusing namespace std;\n\nvoid Tensor_print(int dimensions, const int sizes[], const double data[]){\n    int a,b,c,d;\n    a = sizes[0]; b = sizes[1];\n    c = sizes[2]; d = sizes[3];\n    if(dimensions == 1){\n        cout << \"Tensor of \" << a << endl;\n        for(int i = 0; i < a; i++) \n            cout << data[i] << endl;\n    }\n    else if(dimensions == 2){\n        cout << \"Tensor of \" << a << 'x' << b << endl;\n        for(int i = 0; i < a; ++i){\n            for(int j = 0; j < b; ++j){\n                cout << \"    \" << data[i*b+j];\n            }\n            cout << endl;\n        }\n    }\n    else if(dimensions == 3){\n        cout << \"Tensor of \" << a << 'x' << b << 'x' << c << endl;\n        for(int i = 0; i < a; ++i){\n            cout << \"data[\" << i << \"]\" << endl;\n            for(int j = 0; j < b; ++j){\n                for(int k = 0; k < c; ++k){\n                    cout << \"    \" << data[i*b*c + j*c + k];\n                }\n                cout << endl;\n            }\n        }\n    }\n    else{\n        cout << \"Tensor of \" << a << 'x' << b << 'x' << c << 'x' << d <<endl;\n        for(int i = 0; i < a; ++i){\n            for(int j = 0; j < b; ++j){\n                cout << \"data[\" << i << ']' << '[' << j << ']' << endl;\n                for(int k = 0; k < c; ++k){\n                    for(int l = 0; l < d; ++l){\n                        cout << \"    \" << data[i*b*c*d + j*c*d + k*d + l];\n                    }\n                    cout << endl;\n                }\n            }\n        }\n    }\n}",
            1589424049.3305445,
            100,
            "# 答案正确"
        ],
        [
            "2.4 (C++)",
            "麦子丰",
            "#include <cstring>\n#include <iostream>\nusing namespace std;\n\nclass Matrix{\n    private:\n        int rows, columns;\n        double* values;\n    public:\n        Matrix(int rows_, int columns_);\n        Matrix(int rows_, int columns_,double values_[]);\n        ~Matrix();\n        void print();\n        void set(int row, int column, double value);\n        Matrix& operator = (const Matrix& matrix);\n};\n\nMatrix::Matrix(int rows_, int columns_):rows(rows_),columns(columns_){\n    values = new double[rows*columns];\n    memset(values, 0, rows*columns*sizeof(double));\n}\n\nMatrix::Matrix(int rows_, int columns_,double values_[]):rows(rows_),columns(columns_){\n    values = new double[rows*columns];\n    memcpy(values, values_, rows*columns*sizeof(double));\n}\n\nMatrix::~Matrix(){\n    delete [] values;\n}\n\nvoid Matrix::print(){\n    for(int i = 0; i < rows; ++i){\n        for(int j = 0; j < columns; ++j){\n            cout << \"    \" << values[i*columns+j];\n        }\n        cout << endl;\n    }\n}\n\nvoid Matrix::set(int row, int column, double value){\n    --row;\n    --column;\n    values[row*columns+column] = value;\n}\n\nMatrix& Matrix::operator = (const Matrix& matrix){\n    rows = matrix.rows;\n    columns = matrix.columns;\n    delete[] values;\n    values = new double[rows*columns];\n    memcpy(values, matrix.values,rows*columns*sizeof(double));\n    return *this;\n}",
            1589522078.626925,
            100,
            "# 答案正确"
        ],
        [
            "2.7 (C++)",
            "麦子丰",
            "#include <cstring>\n#include <iostream>\nusing namespace std;\n#define MAX 10000\n\nclass Matrix{\n    private:\n        int rows, columns;\n        double* values;\n    public:\n        Matrix(int rows_, int columns_,double values_[]);\n        Matrix(const Matrix& matrix2);\n        ~Matrix();\n        void print();\n        Matrix reshape(int rows, int columns) const;\n};\n\nMatrix::Matrix(int rows_, int columns_,double values_[]):rows(rows_),columns(columns_){\n    values = new double[rows*columns];\n    memcpy(values, values_, rows*columns*sizeof(double));\n}\n\nMatrix::Matrix(const Matrix& matrix2){\n    rows = matrix2.rows;\n    columns = matrix2.columns;\n    values = new double[rows*columns];\n    memcpy(values, matrix2.values, rows*columns*sizeof(double));\n}\n\nMatrix::~Matrix(){\n    delete [] values;\n}\n\nvoid Matrix::print(){\n    for(int i = 0; i < rows; ++i){\n        for(int j = 0; j < columns; ++j){\n            cout << \"    \" << values[i*columns+j];\n        }\n        cout << endl;\n    }\n}\n\nMatrix Matrix::reshape(int rows, int columns) const{\n    int row1,row2,col1,col2;\n    row1 = this->rows; col1 = this->columns;\n    row2 = rows; col2 = columns;\n    double values_[row2*col2];\n    int nowRow=0, nowCol=0;\n    for(int j = 0; j < col1; ++j){\n        for(int i = 0; i < row1; ++i){\n            values_[nowRow*col2+nowCol] = this->values[i*col1+j];\n            ++nowRow;\n            if(nowRow == row2){\n                nowRow = 0;\n                ++nowCol;\n            }\n        }\n    }\n    Matrix res(row2, col2, values_);\n    return res;\n}",
            1589523672.402789,
            100,
            "# 答案正确"
        ],
        [
            "2.8 (C++)",
            "麦子丰",
            "#include <cstring>\n#include <iostream>\nusing namespace std;\n#define MAX 10000\n\nclass Matrix{\n    private:\n        int rows, columns;\n        double* values;\n    public:\n        Matrix(int rows_, int columns_,double values_[]);\n        Matrix(const Matrix& matrix2);\n        ~Matrix();\n        void print();\n        Matrix transpose();\n};\n\nMatrix::Matrix(int rows_, int columns_,double values_[]):rows(rows_),columns(columns_){\n    values = new double[rows*columns];\n    memcpy(values, values_, rows*columns*sizeof(double));\n}\n\nMatrix::Matrix(const Matrix& matrix2){\n    rows = matrix2.rows;\n    columns = matrix2.columns;\n    values = new double[rows*columns];\n    memcpy(values, matrix2.values, rows*columns*sizeof(double));\n}\n\nMatrix::~Matrix(){\n    delete [] values;\n}\n\nvoid Matrix::print(){\n    for(int i = 0; i < rows; ++i){\n        for(int j = 0; j < columns; ++j){\n            cout << \"    \" << values[i*columns+j];\n        }\n        cout << endl;\n    }\n}\n\nMatrix Matrix::transpose(){\n    double value_[rows*columns];\n    for(int i = 0; i < rows; ++i){\n        for(int j = 0; j < columns; ++j){\n            value_[j*rows+i] = values[i*columns+j];\n        }\n    }\n    Matrix res(columns,rows,value_);\n    return res;\n}",
            1589528452.1346328,
            100,
            "# 答案正确"
        ],
        [
            "2.10 (C++)",
            "麦子丰",
            "#include <cstring>\n#include <iostream>\nusing namespace std;\n#define MAX 10000\n\nclass Matrix{\n    private:\n        int rows, columns;\n        double* values;\n    public:\n        Matrix(int rows_, int columns_,double values_[]);\n        Matrix(const Matrix& matrix2);\n        ~Matrix();\n        void print();\n        Matrix operator * (const Matrix & matrix2) const;\n        Matrix operator * (double value) const;\n};\n\nMatrix::Matrix(int rows_, int columns_,double values_[]):rows(rows_),columns(columns_){\n    values = new double[rows*columns];\n    memcpy(values, values_, rows*columns*sizeof(double));\n}\n\nMatrix::Matrix(const Matrix& matrix2){\n    rows = matrix2.rows;\n    columns = matrix2.columns;\n    values = new double[rows*columns];\n    memcpy(values, matrix2.values, rows*columns*sizeof(double));\n}\n\nMatrix::~Matrix(){\n    delete [] values;\n}\n\nvoid Matrix::print(){\n    for(int i = 0; i < rows; ++i){\n        for(int j = 0; j < columns; ++j){\n            cout << \"    \" << values[i*columns+j];\n        }\n        cout << endl;\n    }\n}\n\nMatrix Matrix::operator * (const Matrix & matrix2) const{\n    int n,m,p;\n    n = rows; m = columns; p = matrix2.columns;\n    double value_[n*p] = {0};\n    for(int i = 0; i < n; ++i){\n        for(int j = 0; j < p; ++j){\n            for(int k = 0; k < m; ++k){\n                value_[i*p+j] += values[i*m+k] * matrix2.values[k*p+j];\n            }\n        }\n    }\n    Matrix res(n,p,value_);\n    return res;\n}\n\nMatrix Matrix::operator * (double value) const{\n    double value_[rows*columns];\n    memcpy(value_, values, rows*columns*sizeof(double));\n    for(int i = 0; i < rows*columns; ++i)\n        value_[i] *= value;\n    Matrix res(rows, columns, value_);\n    return res;\n}",
            1589529522.0779946,
            100,
            "# 答案正确"
        ],
        [
            "2.11 (C++)",
            "麦子丰",
            "#include <cstring>\n#include <iostream>\nusing namespace std;\n#define MAX 10000\n\nclass Matrix{\n    private:\n        int rows, columns;\n        double* values;\n    public:\n        Matrix(int rows_, int columns_,double values_[]);\n        Matrix(const Matrix& matrix2);\n        ~Matrix();\n        void print();\n        Matrix max() const;\n        Matrix min() const;\n        Matrix sum() const;\n};\n\nMatrix::Matrix(int rows_, int columns_,double values_[]):rows(rows_),columns(columns_){\n    values = new double[rows*columns];\n    memcpy(values, values_, rows*columns*sizeof(double));\n}\n\nMatrix::Matrix(const Matrix& matrix2){\n    rows = matrix2.rows;\n    columns = matrix2.columns;\n    values = new double[rows*columns];\n    memcpy(values, matrix2.values, rows*columns*sizeof(double));\n}\n\nMatrix::~Matrix(){\n    delete [] values;\n}\n\nvoid Matrix::print(){\n    for(int i = 0; i < rows; ++i){\n        for(int j = 0; j < columns; ++j){\n            cout << \"    \" << values[i*columns+j];\n        }\n        cout << endl;\n    }\n}\n\nMatrix Matrix::max() const{\n    if(rows == 1){\n        double value_[1] = {0};\n        for(int i = 0; i < columns; ++i){\n            if(value_[0] < values[i]) value_[0] = values[i];\n        }\n        Matrix res(1,1,value_);\n        return res;\n    }\n    else{\n        double value_[columns] = {0};\n        for(int i = 0; i < columns; ++i){\n            for(int j = 0; j < rows; ++j){\n                if(value_[i] < values[j*columns+i])\n                    value_[i] = values[j*columns+i];\n            }\n        }\n        Matrix res(1,columns,value_);\n        return res;\n    }\n}\n\nMatrix Matrix::min() const{\n    const double Inf = (double)1000000;\n    if(rows == 1){\n        double value_[1] = {Inf};\n        for(int i = 0; i < columns; ++i){\n            if(value_[0] > values[i]) value_[0] = values[i];\n        }\n        Matrix res(1,1,value_);\n        return res;\n    }\n    else{\n        double value_[columns];\n        for(int i = 0; i < columns; ++i)\n            value_[i] = Inf;\n        for(int i = 0; i < columns; ++i){\n            for(int j = 0; j < rows; ++j){\n                if(value_[i] > values[j*columns+i])\n                    value_[i] = values[j*columns+i];\n            }\n        }\n        Matrix res(1,columns,value_);\n        return res;\n    }\n}\n\nMatrix Matrix::sum() const{\n    if(rows == 1){\n        double value_[1] = {0};\n        for(int i = 0; i < columns; ++i){\n            value_[0] += values[i];\n        }\n        Matrix res(1,1,value_);\n        return res;\n    }\n    else{\n        double value_[columns] = {0};\n        for(int i = 0; i < columns; ++i){\n            for(int j = 0; j < rows; ++j){\n                value_[i] += values[j*columns+i];\n            }\n        }\n        Matrix res(1,columns,value_);\n        return res;\n    }\n}",
            1589531784.1538255,
            100,
            "# 答案正确"
        ],
        [
            "2.12 (C++)",
            "麦子丰",
            "#include <cstring>\n#include <iostream>\n#include <cmath>\nusing namespace std;\n#define MAX 10000\n\nclass Matrix{\n    private:\n        int rows, columns;\n        double* values;\n    public:\n        Matrix(int rows_, int columns_,double values_[]);\n        Matrix(const Matrix& matrix2);\n        ~Matrix();\n        void print();\n        Matrix pow(double exponent) const;\n        Matrix exp() const;\n        Matrix log() const;\n        Matrix abs() const;\n};\n\nMatrix::Matrix(int rows_, int columns_,double values_[]):rows(rows_),columns(columns_){\n    values = new double[rows*columns];\n    memcpy(values, values_, rows*columns*sizeof(double));\n}\n\nMatrix::Matrix(const Matrix& matrix2){\n    rows = matrix2.rows;\n    columns = matrix2.columns;\n    values = new double[rows*columns];\n    memcpy(values, matrix2.values, rows*columns*sizeof(double));\n}\n\nMatrix::~Matrix(){\n    delete [] values;\n}\n\nvoid Matrix::print(){\n    for(int i = 0; i < rows; ++i){\n        for(int j = 0; j < columns; ++j){\n            cout << \"    \" << values[i*columns+j];\n        }\n        cout << endl;\n    }\n}\n\nMatrix Matrix::pow(double exponent)const{\n    Matrix res(*this);\n    for(int i = 0; i < rows*columns; ++i){\n        res.values[i] = std::pow(res.values[i], exponent);\n    }\n\treturn res;\n}\n\nMatrix Matrix::exp()const{\n    Matrix res(*this);\n    for(int i = 0; i < rows*columns; ++i){\n        res.values[i] = std::exp(res.values[i]);\n    }\n\treturn res;\n}\n\nMatrix Matrix::log()const{\n    Matrix res(*this);\n    for(int i = 0; i < rows*columns; ++i){\n        res.values[i] = std::log(res.values[i]);\n    }\n\treturn res;\n}\n\nMatrix Matrix::abs()const{\n    Matrix res(*this);\n    for(int i = 0; i < rows*columns; ++i){\n        if(res.values[i] < 0) res.values[i] = -res.values[i];\n    }\n\treturn res;\n}\n",
            1590040619.0749643,
            100,
            "# 答案正确"
        ],
        [
            "2.9 (C++)",
            "麦子丰",
            "#include <cstring>\n#include <iostream>\nusing namespace std;\n#define MAX 10000\n\nclass Matrix{\n    private:\n        int rows, columns;\n        double* values;\n    public:\n        Matrix(int rows_, int columns_,double values_[]);\n        Matrix(const Matrix& matrix2);\n        ~Matrix();\n        void print();\n        Matrix operator + (const Matrix & matrix2) const;\n        Matrix operator + (double value) const;\n        Matrix operator - (const Matrix & matrix2) const;\n        Matrix operator - (double value) const;\n};\n\nMatrix::Matrix(int rows_, int columns_,double values_[]):rows(rows_),columns(columns_){\n    values = new double[rows*columns];\n    memcpy(values, values_, rows*columns*sizeof(double));\n}\n\nMatrix::Matrix(const Matrix& matrix2){\n    rows = matrix2.rows;\n    columns = matrix2.columns;\n    values = new double[rows*columns];\n    memcpy(values, matrix2.values, rows*columns*sizeof(double));\n}\n\nMatrix::~Matrix(){\n    delete [] values;\n}\n\nvoid Matrix::print(){\n    for(int i = 0; i < rows; ++i){\n        for(int j = 0; j < columns; ++j){\n            cout << \"    \" << values[i*columns+j];\n        }\n        cout << endl;\n    }\n}\n\nMatrix Matrix::operator + (const Matrix & matrix2) const{\n\tdouble * value1 = new double [rows * columns];\n   for(int i = 0 ; i < rows * columns ; i ++) \n\t   value1[i] = values[i] + matrix2.values[i];\n   Matrix res(rows, columns, value1);\n   delete[]value1;\n   return res;\n}\n\nMatrix Matrix::operator - (const Matrix & matrix2) const {\n   double * value1 = new double [rows * columns];\n   for(int i = 0 ; i < rows * columns ; i ++) value1[i] = values[i] - matrix2.values[i];\n   Matrix res(rows, columns, value1);\n   delete[]value1;\n   return res;\n}\nMatrix Matrix::operator - (double value) const {\n   double * value1 = new double [rows * columns];\n   for(int i = 0 ; i < rows * columns ; i ++) value1[i] = values[i] - value;\n   Matrix res(rows, columns, value1);\n   delete[]value1;\n   return res;\n}\nMatrix Matrix::operator + (double value) const {\n   double * value1 = new double [rows * columns];\n   for(int i = 0 ; i < rows * columns ; i ++) value1[i] = values[i] + value;\n   Matrix res(rows, columns, value1);\n   delete[]value1;\n   return res;\n}",
            1590031082.747894,
            100,
            "# 答案正确"
        ],
        [
            "6.1 (C++)",
            "麦子丰",
            "#include <cstring>\n#include <iostream>\n#include <string>\nusing namespace std;\n\ntemplate <typename T>\nclass Matrix{\n    private:\n        T* values;\n        int rows, cols;\n    public:\n        Matrix(int row, int col):rows(row),cols(col){\n            values = new T[rows*cols];\n            memset(values, 0, sizeof(T)*rows*cols);\n        }\n        Matrix(int row, int col, const T value[]):rows(row),cols(col){\n            values = new T[rows*cols];\n            for(int i = 0; i < rows*cols; ++i){\n                values[i] = value[i];\n            }\n        }\n\t\tMatrix(const Matrix& matrix2){\n\t\t\trows = matrix2.rows;\n\t\t\tcols = matrix2.cols;\n\t\t\tvalues = new T[rows*cols];\n            for(int i = 0; i < rows*cols; ++i){\n                values[i] = matrix2.values[i];\n            }\n\t\t}\n        ~Matrix(){\n            delete[] values;\n        }\n        void print(){\n            for(int i = 0; i < rows; ++i){\n                for(int j = 0; j < cols; ++j){\n                    cout << \"    \" << values[i*cols+j];\n                }\n                cout << endl;\n            }\n        }\n        T& get(int row,int col){\n            --row;\n            --col;\n            return values[row*cols+col];\n        }\n        Matrix& operator = (const Matrix& matrix2){\n            if(values != 0) delete[] values;\n            rows = matrix2.rows;\n            cols = matrix2.cols;\n            values = new T[rows*cols];\n            for(int i = 0; i < rows*cols; ++i){\n                values[i] = matrix2.values[i];\n            }\n            return *this;\n        }\n};",
            1590127847.829498,
            100,
            "# 答案正确"
        ],
        [
            "6.3 (C++)",
            "麦子丰",
            "#include <iostream>\nusing namespace std;\n#include <vector>\n\ntemplate <typename T>\nclass Matrix{\n    private:\n        vector<T> values;\n        int rows, columns;\n    public:\n        Matrix(int row, int col):rows(row),columns(col){\n            for(int i = 0; i < rows*columns; ++i){\n\t\t\t\tvalues.push_back(0);\n\t\t\t}\n        }\n        Matrix(int row, int col, const vector<T> value):rows(row),columns(col){\n            for(int i = 0; i < rows*columns; ++i){\n                values.push_back(value[i]);\n            }\n        }\n\t\tMatrix(const Matrix& matrix2){\n\t\t\trows = matrix2.rows;\n\t\t\tcolumns = matrix2.columns;\n            for(int i = 0; i < rows*columns; ++i){\n                values.push_back(matrix2.values[i]);\n            }\n\t\t}\n        // ~Matrix(){\n        //     delete[] values;\n        // }\n        void print(){\n            for(int i = 0; i < rows; ++i){\n                for(int j = 0; j < columns; ++j){\n                    cout << \"    \" << values[i*columns+j];\n                }\n                cout << endl;\n            }\n        }\n        T& get(int row,int col){\n            --row;\n            --col;\n            return values[row*columns+col];\n        }\n        Matrix& operator = (const Matrix& matrix2){\n\t\t\tif(values.size() != 0) values.clear();\n            rows = matrix2.rows;\n            columns = matrix2.columns;\n            for(int i = 0; i < rows*columns; ++i){\n                values.push_back(matrix2.values[i]);\n            }\n            return *this;\n        }\n\t\tMatrix getColumn(int col){\n\t\t\tvector<T> value;\n            --col;\n\t\t\tfor(int i = 0; i < rows; ++i){\n\t\t\t\tvalue.push_back(this->values[i*columns+col]);\n\t\t\t}\n\t\t\tMatrix res(rows,1,value);\n            return res;\n\t\t}\n\t\tMatrix getRow(int row){\n\t\t\tvector<T> value;\n            --row;\n\t\t\tfor(int i = 0; i < columns; ++i){\n\t\t\t\tvalue.push_back(this->values[row*columns+i]);\n\t\t\t}\n\t\t\tMatrix res(1,columns,value);\n            return res;\n\t\t}\n        Matrix concatenateRows(const Matrix& matrix2){\n            int row = this->rows + matrix2.rows;\n            int col = this->columns;\n            vector<T> value;\n            for(int i = 0; i < rows; ++i){\n                for(int j = 0; j < columns; ++j){\n                    value.push_back(values[i*columns+j]);\n                }\n            }\n            for(int i = 0; i < matrix2.rows; ++i){\n                for(int j = 0; j < matrix2.columns; ++j){\n                    value.push_back(matrix2.values[i*columns+j]);\n                }\n            }\n            Matrix res(row, col, value);\n            return res;\n        }\n        Matrix concatenateColumns(const Matrix& matrix2){\n            int row = this->rows;\n            int col = this->columns + matrix2.columns;\n            vector<T> value;\n            for(int i = 0; i < row; ++i){\n                for(int j = 0; j < col; ++j){\n                    if(j < this->columns)//this\n                        value.push_back(this->values[i*this->columns+j]);\n                    else//matrix2\n                        value.push_back(matrix2.values[i*matrix2.columns+j-this->columns]);\n                }\n            }\n            Matrix res(row, col, value);\n            return res;\n        }\n        Matrix reshape(int row,int column){\n            vector<T> value;\n            for(int i = 0; i < row*column; i++){\n                value.push_back(0);\n            }\n            int nowRow = 0;\n            int nowCol = 0;\n            for(int i = 0; i < this->columns; i++){\n                for(int j = 0; j < this->rows; j++){\n                    value[nowRow*column+nowCol] = this->values[j*columns+i];\n                    ++nowRow;\n                    if(nowRow == row){\n                        nowRow = 0;\n                        ++nowCol;\n                    }\n                }\n            }\n            Matrix res(row, column, value);\n            return res;\n        }\n        Matrix transpose(){\n            vector<T> value;\n            for(int i = 0; i < columns; ++i){\n                for(int j = 0; j < rows; ++j){\n                    value.push_back(this->values[j*columns+i]);\n                }\n            }\n            Matrix res(columns, rows, value);\n            return res;\n        }\n        Matrix max(){\n            vector<T> value;\n            if(rows == 1){\n                T tmp = values[0];\n                for(int i = 1; i < columns; ++i){\n                    if(tmp < values[i]) tmp = values[i];\n                }\n                value.push_back(tmp);\n                Matrix res(1, 1, value);\n                return res;\n            }\n            else{\n                for(int i = 0; i < columns; ++i){\n                    T tmp = values[i];\n                    for(int j = 1; j < rows; ++j){\n                        if(tmp < values[j*columns+i]) tmp = values[j*columns+i];\n                    }\n                    value.push_back(tmp);\n                }\n                Matrix res(1, columns, value);\n                return res;\n            }\n        }\n        Matrix min(){\n            vector<T> value;\n            if(rows == 1){\n                T tmp = values[0];\n                for(int i = 1; i < columns; ++i){\n                    if(tmp > values[i]) tmp = values[i];\n                }\n                value.push_back(tmp);\n                Matrix res(1, 1, value);\n                return res;\n            }\n            else{\n                for(int i = 0; i < columns; ++i){\n                    T tmp = values[i];\n                    for(int j = 1; j < rows; ++j){\n                        if(tmp > values[j*columns+i]) tmp = values[j*columns+i];\n                    }\n                    value.push_back(tmp);\n                }\n                Matrix res(1, columns, value);\n                return res;\n            }\n        }\n        Matrix sum(){\n            vector<T> value;\n            if(rows == 1){\n                T tmp = values[0];\n                for(int i = 1; i < columns; ++i){\n                    tmp += values[i];\n                }\n                value.push_back(tmp);\n                Matrix res(1, 1, value);\n                return res;\n            }\n            else{\n                for(int i = 0; i < columns; ++i){\n                    T tmp = values[i];\n                    for(int j = 1; j < rows; ++j){\n                        tmp += values[j*columns+i];\n                    }\n                    value.push_back(tmp);\n                }\n                Matrix res(1, columns, value);\n                return res;\n            }\n        }\n        Matrix operator+(const Matrix& matrix2){\n            vector<T> value;\n            for(int i = 0; i < rows; ++i){\n                for(int j = 0; j < columns; ++j){\n                    value.push_back(values[i*columns+j] + matrix2.values[i*columns+j]);\n                }\n            }\n            Matrix res(rows, columns, value);\n            return res; \n        }\n        Matrix operator+(T a){\n            vector<T> value;\n            for(int i = 0; i < rows; ++i){\n                for(int j = 0; j < columns; ++j){\n                    value.push_back(values[i*columns+j] + a);\n                }\n            }\n            Matrix res(rows, columns, value);\n            return res;  \n        }\n        Matrix operator-(const Matrix& matrix2){\n            vector<T> value;\n            for(int i = 0; i < rows; ++i){\n                for(int j = 0; j < columns; ++j){\n                    value.push_back(values[i*columns+j] - matrix2.values[i*columns+j]);\n                }\n            }\n            Matrix res(rows, columns, value);\n            return res; \n        }\n        Matrix operator-(T a){\n            vector<T> value;\n            for(int i = 0; i < rows; ++i){\n                for(int j = 0; j < columns; ++j){\n                    value.push_back(values[i*columns+j] - a);\n                }\n            }\n            Matrix res(rows, columns, value);\n            return res; \n        }\n        Matrix operator*(const Matrix& matrix2){\n            vector<T> value;\n            int n = rows; int m = columns; int p = matrix2.columns;\n            for(int i = 0; i < n; ++i){\n                for(int j = 0; j < p; ++j){\n                    T tmp = 0;\n                    for(int k = 0; k < m; ++k){\n                        tmp += values[i*m+k] * matrix2.values[k*p+j];\n                    }\n                    value.push_back(tmp);\n                }\n            }\n            Matrix res(n, p, value);\n            return res;  \n        }\n        Matrix operator*(T a){\n            vector<T> value;\n            for(int i = 0; i < rows; ++i){\n                for(int j = 0; j < columns; ++j){\n                    value.push_back(values[i*columns+j] * a);\n                }\n            }\n            Matrix res(rows, columns, value);\n            return res; \n        }\n};",
            1590630827.22295,
            100,
            "# 答案正确"
        ],
        [
            "6.2 (C++)",
            "麦子丰",
            "#include <cstring>\n#include <iostream>\nusing namespace std;\n#define MAX 100\n\ntemplate <typename T>\nclass Matrix{\n    private:\n        int rows,columns;\n        T* values;\n    public:\n        Matrix(int row,int column):rows(row),columns(column){\n            values = new T[rows*columns];\n            memset(values,0,rows*columns*sizeof(T));\n        }\n        ~Matrix(){\n            delete[] values;\n        }\n        void print(){\n            for(int i = 0; i < rows; ++i){\n                for(int j = 0; j < columns; ++j){\n                    cout << \"    \" << values[i*columns+j];\n                }\n                cout << endl;\n            }\n        }\n};",
            1590631641.3874106,
            100,
            "# 答案正确"
        ],
        [
            "7.1 (C++)",
            "麦子丰",
            "#include <cmath>\n\nclass Triangle : public GeometricObject{\n    private:\n        double side1=1.0;\n        double side2=1.0;\n        double side3=1.0;\n    public:\n        Triangle(){\n            side1 = side2 = side3 = 1.0;\n        }\n        Triangle(double a, double b, double c){\n            side1 = a;\n            side2 = b;\n            side3 = c;\n        }\n        double getSide1(){return side1;}\n        double getSide2(){return side2;}\n        double getSide3(){return side3;}\n        double getArea(){\n            double s = (side1 + side2 + side3) / 2;\n            return sqrt(s*(s-side1)*(s-side2)*(s-side3));\n        }\n        double getPerimeter(){\n            return side1 + side2 + side3;\n        }\n};",
            1590730106.9484086,
            100,
            "# 答案正确"
        ],
        [
            "7.3 (C++)",
            "麦子丰",
            "template <typename E>\nvector<E> map2(vector<E> data1, E data2, int (*map_func)(const int &, const int &)) {\n    vector<E> res;\n    for(int i = 0; i < data1.size(); ++i) {\n        res.push_back(map_func(data1[i], data2));\n    }\n    return res;\n}\n\ntemplate <typename E>\nvector<E> map2(vector<E> data1, vector<E> data2, int (*map_func)(const int &, const int &)) {\n    vector<E> res;\n    for(int i = 0; i < data1.size(); ++i) {\n        res.push_back(map_func(data1[i], data2[i]));\n    }\n    return res;\n}",
            1590730645.4993033,
            100,
            "# 答案正确"
        ],
        [
            "7.2 (C++)",
            "麦子丰",
            "#include <string>\n#include <vector>\n#include <iostream>\nusing namespace std;\n\nvector<string> split(const string& line, const string& delimiter=\" \"){\n    vector<string> words;\n    int start = 0;\n    while(start < line.size()){\n        int end = line.find(delimiter, start);\n        if(end == start) start += delimiter.size();\n        else{\n            if(end == -1){\n                words.push_back(line.substr(start));\n                break;\n            }\n            else{\n                words.push_back(line.substr(start, end-start));\n                start = end + delimiter.size();\n            }\n        } \n    }\n    return words;\n}",
            1591236601.6834571,
            100,
            "# 答案正确"
        ],
        [
            "8.1 (C++)",
            "麦子丰",
            "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Full: public Matrix{\n    private:\n        int rows,cols;\n        vector<double> values;\n    public:\n        Full(int row, int col):rows(row),cols(col){\n            for(int i = 0; i < rows; i++){\n                for(int j = 0; j < cols; j++){\n                    values.push_back(0);\n                }\n            }\n        }\n        Full(int row, int col, double value[]):rows(row),cols(col){\n            for(int i = 0; i < rows; i++){\n                for(int j = 0; j < cols; j++){\n                    values.push_back(value[i*cols+j]);\n                }\n            }\n        }\n        Full(const Matrix& matrix2){\n            rows = matrix2.size(1);\n            cols = matrix2.size(2);\n            for(int i = 0; i < rows; i++){\n                for(int j = 0; j < cols; j++){\n                    values.push_back(matrix2.get(i+1, j+1));\n                }\n            }\n        }\n        virtual int size(int dimension) const{\n            if(dimension == 1) return rows;\n            else if(dimension == 2) return cols;\n        }\n        virtual void set(int row, int column, double value){\n\t\t\t\trow--;\n\t\t\t\tcolumn--;\n            values[row*cols+column] = value;\n        }\n        virtual double get(int row, int column) const{\n\t\t\t\trow--;\n\t\t\t\tcolumn--;\n            return values[row*cols+column];\n        }\n        virtual void print() const{\n            for(int i = 0; i < rows; ++i){\n                for(int j = 0; j < cols; ++j){\n                    cout << \"    \" << values[i*cols+j];\n                }\n                cout << endl;\n            }\n        }\n        virtual Matrix & operator = (const Matrix & matrix2){\n            values.clear();\n            rows = matrix2.size(1);\n            cols = matrix2.size(2);\n            for(int i = 0; i < rows; i++){\n                for(int j = 0; j < cols; j++){\n                    values.push_back(matrix2.get(i+1, j+1));\n                }\n            }\n            return *this;\n        }\n};",
            1591341340.365137,
            100,
            "# 答案正确"
        ],
        [
            "8.3 (C++)",
            "麦子丰",
            "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Sparse :public Matrix{\n    private:\n        int rows,cols;\n        vector<Entry> values;\n    public:\n        Sparse(int row, int column):rows(row),cols(column){}\n        virtual int size(int dimension) const{\n            if(dimension == 1) return rows;\n            else if(dimension == 2) return cols;\n        }\n        virtual void set(int row, int column, double value){\n            if(value == 0) return;\n            for(int i = 0; i < values.size(); i++){\n                if(values[i].row == row && values[i].column == column){\n                    values[i].value += value;\n                    if(values[i].value == 0) \n                        values.erase(values.begin() + i);\n                    return;\n                }\n            }\n            Entry New;\n            New.row = row; New.column = column; New.value = value;\n            values.push_back(New);\n        }\n        virtual double get(int row, int column) const{\n            for(int i = 0; i < values.size(); i++){\n                if(values[i].row == row && values[i].column == column)\n                    return values[i].value;\n            }\n            return 0;\n        }\n        bool bigger(Entry a, Entry b){\n            if(a.row < b.row) return true;\n            if(a.row > b.row) return false;\n            if(a.column < b.column) return true;\n            if(a.column > b.column) return false;\n        }\n        virtual void print(){\n            int size = values.size();\n            for(int i = 0; i < size; i++){\n                for(int j = 0; j < size; j++){\n                    if(bigger(values[i], values[j])){\n                        Entry tmp = values[i];\n                        values[i] = values[j];\n                        values[j] = tmp;\n                    }\n                }\n            }\n            for(int i = 0; i < size; i++){\n                cout << \"(\" << values[i].row << \",\" << values[i].column;\n                cout << \",\" << values[i].value << \")\" << endl;\n            }\n        }\n        Sparse operator + (Sparse & sparse2){\n            int size1 = values.size();\n            int size2 = sparse2.values.size();\n            Sparse res(rows, cols);\n            for(int i = 0; i < size1; ++i)\n                res.set(values[i].row, values[i].column, values[i].value);\n            for(int i = 0; i < size2; ++i)\n                res.set(sparse2.values[i].row, sparse2.values[i].column, sparse2.values[i].value);\n            return res;\n        }\n};",
            1591840834.061338,
            100,
            "# 答案正确"
        ],
        [
            "8.4 (C++)",
            "麦子丰",
            "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Sparse :public Matrix{\n    private:\n        int rows,cols;\n        vector<Entry> values;\n    public:\n        Sparse(int row, int column):rows(row),cols(column){}\n        virtual int size(int dimension) const{\n            if(dimension == 1) return rows;\n            else if(dimension == 2) return cols;\n        }\n        virtual void set(int row, int column, double value){\n            if(value == 0) return;\n            for(int i = 0; i < values.size(); i++){\n                if(values[i].row == row && values[i].column == column){\n                    values[i].value += value;\n                    if(values[i].value == 0) \n                        values.erase(values.begin() + i);\n                    return;\n                }\n            }\n            Entry New;\n            New.row = row; New.column = column; New.value = value;\n            values.push_back(New);\n        }\n        virtual double get(int row, int column) const{\n            for(int i = 0; i < values.size(); i++){\n                if(values[i].row == row && values[i].column == column)\n                    return values[i].value;\n            }\n            return 0;\n        }\n        bool bigger(Entry a, Entry b){\n            if(a.row < b.row) return true;\n            if(a.row > b.row) return false;\n            if(a.column < b.column) return true;\n            if(a.column > b.column) return false;\n        }\n        virtual void print(){\n            int size = values.size();\n            for(int i = 0; i < size; i++){\n                for(int j = 0; j < size; j++){\n                    if(bigger(values[i], values[j])){\n                        Entry tmp = values[i];\n                        values[i] = values[j];\n                        values[j] = tmp;\n                    }\n                }\n            }\n            for(int i = 0; i < size; i++){\n                cout << \"(\" << values[i].row << \",\" << values[i].column;\n                cout << \",\" << values[i].value << \")\" << endl;\n            }\n        }\n        Sparse operator * (Sparse & sparse2){\n            int size1 = values.size();\n            int size2 = sparse2.values.size();\n            vector<Entry> tmp;\n            Sparse res(rows, sparse2.cols);\n            for(int i = 0; i < size1; ++i){\n                for(int j = 0; j < size2; ++j){\n                    if(values[i].column == sparse2.values[j].row){\n                        Entry New;\n                        New.row = values[i].row; \n                        New.column = sparse2.values[j].column;\n                        New.value = values[i].value * sparse2.values[j].value;\n                        tmp.push_back(New);\n                    }\n                }\n            }\n            for(int i = 0; i < tmp.size(); ++i){\n                res.set(tmp[i].row, tmp[i].column, tmp[i].value);\n            }\n            return res;\n        }\n};",
            1591840861.611871,
            100,
            "# 答案正确"
        ],
        [
            "8.5 (C++)",
            "麦子丰",
            "class Point3D:public Point2D {\n    private:\n        double z;\n    public:\n        Point3D():z(0){\n            setX(0);\n            setY(0);\n        }\n        Point3D(double x_, double y_, double z_):z(z_){\n            setX(x_);\n            setY(y_);\n        }\n        double getZ(){\n            return z;\n        }\n        virtual double distance(Point2D& point2){\n            Point3D& point = dynamic_cast<Point3D&>(point2);\n            double dx = getX()-point.getX();\n            double dy = getY()-point.getY();\n            double dz = getZ()-point.getZ();\n            return sqrt(dx*dx + dy*dy + dz*dz);\n        }\n};",
            1591842659.1607714,
            100,
            "# 答案正确"
        ],
        [
            "8.6 (C++)",
            "麦子丰",
            "#include <iostream>\nusing namespace std;\n\nclass MyTensor : public Tensor<double>{\n    private:\n        vector<double> values;\n    public:\n        virtual double & get(const vector<int> & indexes){\n            int dim = indexes.size();\n            if(dim == 1){\n                return values[indexes[0]];\n            }\n            else if(dim == 2){\n                int i = indexes[0],j = indexes[1];\n                int a = sizes[0], b = sizes[1];\n                return values[i*b+j];\n            }\n            else if(dim == 3){\n                int i = indexes[0],j = indexes[1],k = indexes[2];\n                int a = sizes[0], b = sizes[1], c = sizes[2];\n                return values[i*b*c+j*c+k];\n            }\n            else{\n                int i = indexes[0],j = indexes[1],k = indexes[2], m = indexes[3];\n                int a = sizes[0], b = sizes[1], c = sizes[2], d = sizes[3];\n                return values[i*b*c*d+j*c*d+k*d+m];\n            }\n        }\n        MyTensor(vector<int> sizes):Tensor(sizes){\n            int dim = sizes.size();\n            int size = 1;\n            for(int i = 0; i < dim; ++i)\n                size *= sizes[i];\n            for(int i = 0; i < size; ++i)\n                values.push_back(0);\n        }\n};",
            1592449409.400363,
            100,
            "# 答案正确"
        ],
        [
            "9.1 (C++)",
            "麦子丰",
            "#include <iostream>\nusing namespace std;\n\nclass Circle{\n    private:\n        int r;\n    public:\n        Circle():r(0){}\n        Circle(int r_):r(r_){}\n        int operator<(Circle& circle2){\n            return this->r < circle2.r? 1 : 0;\n        }\n        int operator<=(Circle& circle2){\n            return this->r <= circle2.r? 1 : 0;\n        }\n        int operator==(Circle& circle2){\n            return this->r == circle2.r? 1 : 0;\n        }\n        int operator!=(Circle& circle2){\n            return this->r != circle2.r? 1 : 0;\n        }\n        int operator>(Circle& circle2){\n            return this->r > circle2.r? 1 : 0;\n        }\n        int operator>=(Circle& circle2){\n            return this->r >= circle2.r? 1 : 0;\n        }\n};",
            1592615994.9666102,
            100,
            "# 答案正确"
        ],
        [
            "9.2 (C++)",
            "麦子丰",
            "class I{\n    private:\n        vector<int> sizes;\n    public:\n        I(int size1, int size2=-1, int size3=-1, int size4=-1){\n            sizes.push_back(size1);\n            if(size2 != -1) sizes.push_back(size2);\n            if(size3 != -1) sizes.push_back(size3);\n            if(size4 != -1) sizes.push_back(size4);\n        }\n        operator vector<int> ()const{\n            return sizes;\n        }\n};",
            1592635772.3837135,
            100,
            "# 答案正确"
        ],
        [
            "9.3 (C++)",
            "麦子丰",
            "class Complex{\n    private:\n        double r,i;\n    public:\n        Complex():r(0),i(0){}\n        Complex(double r_, double i_):r(r_),i(i_){}\n        Complex(const Complex& c):r(c.r),i(c.i){}\n        Complex(double r_):r(r_),i(0){}\n        double real()const {return r;}\n        double imag()const {return i;}\n        Complex operator+=(const Complex& a){\n            this->r += a.r;\n            this->i += a.i;\n            return *this;\n        }\n        Complex operator-=(const Complex& a){\n            this->r -= a.r;\n            this->i -= a.i;\n            return *this;\n        }\n        Complex operator*=(const Complex& a){\n            this->r = r*a.r - i*a.i;\n            this->i = i*a.r + r*a.i;\n            return *this;\n        }\n        Complex operator/=(const Complex& a){\n            if (a.i == 0) {\n                r /= a.r;\n                i /= a.r;\n            }\n            else {\n                this->r = (r*a.r + i*a.i) / (a.r*a.r + a.i*a.i);\n                this->i = (i*a.r - r*a.i) / (a.r*a.r + a.i*a.i);\n            }\n            return *this;\n        }\n};\n\nComplex operator+ (Complex a, Complex b){\n    return Complex(a.real() + b.real(), a.imag() + b.imag());\n}\n\nComplex operator- (Complex a, Complex b){\n    return Complex(a.real() - b.real(), a.imag() - b.imag());\n}\n\nComplex operator* (Complex a, Complex b){\n    return Complex(a.real()*b.real() - a.imag()*b.imag(), a.real()*b.imag() + a.imag()*b.real());\n}\n\nComplex operator/ (Complex a, Complex b){\n    if (b.imag() == 0)\n        return Complex(a.real() / b.real(), a.imag() / b.real());\n    else\n        return a * Complex(b.real(), -b.imag()) / Complex(b.real()*b.real() + b.imag()*b.imag(), 0);\n}\n\nbool operator== (Complex& a, Complex& b){\n    return a.real() == b.real() && a.imag() == b.imag();\n}\n\nbool operator!= (Complex& a, Complex& b){\n    return !(a == b);\n}",
            1592638677.6882956,
            100,
            "# 答案不正确\n\n# 随机输入:\n\n\n# 参考答案:\nc7 = 35 + 55i\nc8 = 15 + 15i\nc9 = -450 + 850i\nc10 = 1.9 + -0.3i\nc11 = 20 + 20i\nc12 = -10 + 20i\nc3 = 26 + 37i\nc4 = -6 + -11i\nc5 = 220 + 740i\nc6 = 5.2 + -1.4i\nc1 != c2\n\n\n# 我的答案:\nc7 = 35 + 55i\nc8 = 15 + 15i\nc9 = -450 + 850i\nc10 = 1.9 + -0.3i\nc11 = 20 + 20i\nc12 = -10 + 20i\nc3 = 26 + 37i\nc4 = -6 + -11i\nc5 = 220 + 4460i\nc6 = 5.2 + 1.592i\nc1 != c2\n"
        ],
        [
            "9.4 (C++)",
            "麦子丰",
            "class Complex{\n    private:\n        double r,i;\n    public:\n        Complex():r(0),i(0){}\n        Complex(double r_, double i_):r(r_),i(i_){}\n        double &real() {return r;}\n        double &imag() {return i;}\n};\n\nComplex operator+ (Complex a, Complex b){\n    return Complex(a.real() + b.real(), a.imag() + b.imag());\n}\n\nComplex operator- (Complex a, Complex b){\n    return Complex(a.real() - b.real(), a.imag() - b.imag());\n}\n\nostream& operator << (ostream& out, Complex& a){\n    out << a.real() << \" + \" << a.imag() << \" i \";\n    return out;\n}\n\nistream& operator >> (istream &in, Complex& a){\n    double r_,i_;\n    in >> r_ >> i_;\n    a.real() = r_;\n    a.imag() = i_;\n    return in;\n}",
            1592640542.9220216,
            100,
            "# 答案正确"
        ],
        [
            "9.5 (C++)",
            "麦子丰",
            "class Complex{\n    private:\n        double r,i;\n    public:\n        Complex():r(0),i(0){}\n        Complex(double r_, double i_):r(r_),i(i_){}\n        Complex(const Complex& other):r(other.r),i(other.i){}\n        double &real() {return r;}\n        double &imag() {return i;}\n        Complex& operator++(){\n            ++this->r;\n            return *this;\n        }\n        Complex operator++(int){\n            Complex res(*this);\n            ++this->r;\n            return res;\n        }\n        operator double(){return r;}\n};\n\nostream& operator << (ostream& out, Complex a){\n    out << a.real() << \" + \" << a.imag() << \" i \";\n    return out;\n}\n\nistream& operator >> (istream &in, Complex& a){\n    in >> a.real() >> a.imag();\n    return in;\n}",
            1592641523.2340844,
            100,
            "# 答案正确"
        ],
        [
            "9.6 (C++)",
            "麦子丰",
            "class Tensor{\n    private:\n        vector<int> sizes;\n        vector<double> values;\n    public:\n        Tensor(int size1, int size2=-1, int size3=-1, int size4=-1){\n            int size = 1;\n            sizes.push_back(size1);\n            if(size2 != -1) sizes.push_back(size2);\n            if(size3 != -1) sizes.push_back(size3);\n            if(size4 != -1) sizes.push_back(size4);\n            for(int i = 0; i < sizes.size(); i++)\n                size *= sizes[i];\n            for(int i = 0; i < size; i++){\n                values.push_back(0);\n            }\n        }\n        double& operator()(int i, int j=-1, int k=-1, int m=-1){\n            int dim = sizes.size();\n            if(dim == 1){\n                int a = sizes[0];\n                return values[i];\n            }\n            else if(dim == 2){\n                int a = sizes[0];int b = sizes[1];\n                return values[i*b+j];\n            }\n            else if(dim == 3){\n                int a = sizes[0];int b = sizes[1];\n                int c = sizes[2];\n                return values[i*b*c+j*c+k];\n            }\n            else{\n                int a = sizes[0];int b = sizes[1];\n                int c = sizes[2];int d = sizes[3];\n                return values[i*b*c*d+j*c*d+k*d+m];\n            }\n        }\n};",
            1592642621.870071,
            100,
            "# 答案正确"
        ],
        [
            "9.7 (C++)",
            "麦子丰",
            "class Tensor{\n    public:\n        vector<int> sizes;\n        vector<double> values;\n};\n\nistream& operator>>(istream& in, Tensor& t){\n    int dim, size=1;\n    in >> dim;\n    for(int i = 0; i < dim; ++i){\n        int tmp;\n        in >> tmp;\n        t.sizes.push_back(tmp);\n        size *= tmp;\n    }\n    for(int i = 0; i < size; ++i){\n        double tmp;\n        in >> tmp;\n        t.values.push_back(tmp);\n    }\n    return in;\n}\n\nostream& operator<<(ostream& out,const Tensor& t){\n    int dim = t.sizes.size();\n    out << dim << endl;\n    for(int i = 0; i < dim; i++)\n        out << t.sizes[i] << \" \";\n    out << endl << endl;\n    int a = t.sizes[dim-2], b = t.sizes[dim-1];\n    for(int i = 1; i <= t.values.size(); i++){\n        out << t.values[i-1] << \" \";\n        if(i % b == 0) out << endl;\n        if(i % (a*b) == 0) out << endl;\n    }\n    return out;\n}",
            1592660791.690018,
            100,
            "# 答案正确"
        ],
        [
            "10.1 (C++)",
            "麦子丰",
            "#include <vector>\n#include <stdexcept>\n#include <iostream>\nusing namespace std;\n\ndouble Matrix::get(int row, int column) const{\n    if(row > rows || column > columns) throw out_of_range(\"getError\"); \n    return elements[(row-1)*columns+column-1];\n}\n\nvoid Matrix::set(int row, int column, double value){\n    if(row > rows || column > columns) throw out_of_range(\"setError\"); \n    elements[(row-1)*columns+column-1] = value;\n}\n\nclass MatrixSizesDoNotMatchException{};\nMatrix Matrix::operator+(const Matrix & matrix2)const{\n    if(rows != matrix2.rows || columns != matrix2.columns) throw MatrixSizesDoNotMatchException();\n    Matrix res(rows, columns);\n    for(int i = 0; i < rows*columns; i++) \n        res.elements[i] = matrix2.elements[i]+this->elements[i];\n    return res;\n}",
            1593317998.5307145,
            100,
            "# 答案正确"
        ],
        [
            "10.2 (C++)",
            "麦子丰",
            "catch(NonPositiveValueException& e2){\n            cout << \"caught: NonPositiveValueException\" << endl;\n        }\n        catch(out_of_range& e1){\n            cout << \"caught: out_of_range\" << endl;\n        }",
            1593655684.1853273,
            100,
            "# 答案正确"
        ],
        [
            "15.1 (C++)",
            "麦子丰",
            "#include <vector>\n#include <string>\n#include <iostream>\nusing namespace std;\n\nclass Table{\n    private:\n        vector<string> headers;\n        vector<vector<string>> rows;\n    public:\n        void addCol(string head){\n            headers.push_back(head);\n        }\n        string json()const{\n            string res = \"{\\n\";\n            res += \"\\theaders: [\";\n            for(int i = 0; i < headers.size(); i++){\n                res += \"\\'\";\n                res += headers[i];\n                res += \"\\',\";\n            }\n            res += \"],\\n\";\n            res += \"\\trows: [\\n\";\n            for(int i = 0; i < rows.size(); i++){\n                res += \"\\t\\t[\";\n                for(int j = 0; j < rows[i].size(); j++){\n                    res += \"\\'\";\n                    res += rows[i][j];\n                    res += \"\\',\";\n                }\n                res += \"],\\n\";\n            }\n            res += \"\\t],\\n\";\n            res += \"}\";\n            return res;\n        }\n        vector<string>& operator[](int index){\n            int size = rows.size();\n            if(index < size) return rows[index];\n            vector<string> a;\n            rows.push_back(a);\n            return rows[size];\n        }\n};",
            1593749425.5817645,
            100,
            "# 答案正确"
        ],
        [
            "2020-07-09 LAB",
            "麦子丰",
            "#include <fstream>\n#include <vector>\n#include <iostream>\nusing namespace std;\n\nclass Integer{\n    private:\n        static vector<Integer*> arr;\n        int num;\n    public:\n        Integer():num(0){\n            arr.push_back(this);\n        }\n        Integer(int num_):num(num_){\n            arr.push_back(this);\n        }\n        int& get_num(){\n            return this->num;\n        }\n        static void increase_all(int num1){\n            for(int i = 0; i < arr.size(); ++i){\n                arr[i]->get_num() += num1;\n            }\n        }\n        static void increase_all(Integer Int){\n            int num1 = Int.get_num();\n            for(int i = 0; i < arr.size(); ++i){\n                arr[i]->get_num() += num1;\n            }\n        }\n};\nvector<Integer*> Integer::arr;\n\nistream& operator>>(istream& in, Integer& Int){\n    int num;\n    in >> num;\n    Int.get_num() = num;\n    return in;\n}\n\nostream& operator<<(ostream& out, Integer& Int){\n    out << Int.get_num();\n    return out;\n}",
            1594263546.6538513,
            100,
            "# 答案正确"
        ],
        [
            "A.1 (C++)",
            "麦子丰",
            "private:\n    Node<E> * get_node(int index) const {\n        if (index < _size / 2) {\n            Node<E> * node = head;\n            Node<E> * prev_node = 0;\n            I(i, index){\n                Node<E> * tmp = node;\n                node = node->next_node(prev_node);\n                prev_node = tmp;\n            }\n            return node;\n        }\n        else {\n            Node<E> * node = tail;\n            Node<E> * next_node = 0;\n            I(i, (_size-1-index)){\n                Node<E> * tmp = node;\n                node = node->prev_node(next_node);\n                next_node = tmp;\n            }\n            return node;\n        }\n    }\n\npublic:\n    E & get(int index) const {\n        Node<E> * node = get_node(index);\n        return node->element;\n    }\n    void set(int index, const E & e) {\n        if (index < 0 || index >= _size) \n            throw NotSuchElementException();\n        Node<E> * node = get_node(index);\n        node->element = e;\n    }\n    E & getFirst() const {\n        return get(0);\n    }\n    E & getLast() const {\n        return get(_size - 1);\n    }\n\n    void remove (int index) {\n        Node<E> * node = get_node(index);\n        Node<E> * prev_node = (index == 0 ? 0 : get_node(index-1));\n        Node<E> * next_node = (index == _size-1 ? 0 : get_node(index+1));\n        if (prev_node != 0) prev_node->update_next_node(node, next_node);\n        if (next_node != 0) next_node->update_prev_node(node, prev_node);\n        if (prev_node == 0) head = next_node;\n        if (next_node == 0) tail = prev_node;\n        delete node;\n        -- _size;\n    }\n    void removeFirst () {\n        remove(0);\n    }\n    void removeLast () {\n        remove(_size-1);\n    }\n\n    void add(int index, const E & e) {\n        if (index < 0 || index > _size) \n            throw NotSuchElementException();\n        Node<E> * node = new Node<E>();\n        node->element = e;\n        Node<E> * next_node = (index == _size ? 0 : get_node(index));\n        Node<E> * prev_node;\n        if(next_node == 0) prev_node = tail;\n        else if(index == 0) prev_node = 0;\n        else prev_node = get_node(index-1);\n        node->update_prev_and_next_node(prev_node,next_node);\n        if (prev_node != 0) prev_node->update_next_node(next_node, node);\n        if (next_node != 0) next_node->update_prev_node(prev_node, node);\n        if (prev_node == 0) head = node;\n        if (next_node == 0) tail = node;\n        ++ _size;\n    }\n    void addFirst (const E & e) {\n        add(0, e);\n    }\n    void addLast (const E & e) {\n        add(_size, e);\n    }\n\n    void clear() {\n        while (_size > 0) removeFirst();\n    }\n\n    void addAll(const LinkedList & list, int index=-1) {//添加另一链表\n        if (index == -1) index = _size;\n        Node<E> * node = list.head;\n        Node<E> * prev_node = 0;\n        I(i, list._size) {\n            add(index + i, node->element);\n            Node<E> * tmp = node;\n            node = node->next_node(prev_node);\n            prev_node = tmp;\n        }\n    }\n\n    LinkedList(const LinkedList & list) : _size(0), head(0), tail(0) {\n        addAll(list);\n    }\n\n    LinkedList & operator = (const LinkedList & list) {\n        clear();\n        addAll(list);\n        return *this;\n    }\n\n    ~LinkedList() {\n        clear();\n    }\n\n    int indexOf(const E & e) const {\n        Node<E> * node = head;\n        Node<E> * prev_node = 0;\n        I(i, _size) {\n            if (node->element == e) return i;\n            Node<E> * tmp = node;\n            node = node->next_node(prev_node);\n            prev_node = tmp;\n        }\n        return -1;\n    }\n\n    void removeFirstOccurrence(const E & e) {\n        int index = indexOf(e);\n        if (index == -1)\n            throw NotSuchElementException();\n        remove(index);\n    }",
            1594538424.646569,
            100,
            "# 答案正确"
        ],
        [
            "A.2 (C++)",
            "麦子丰",
            "template <typename E>\nvoid LinkedList<E>::removeAll(const E & e){\n\twhile(1){\n\t\tint index = indexOf(e);\n\t\tif(index == -1) return;\n\t\tremove(index);\n\t}\n}",
            1594865788.1896782,
            100,
            "# 答案正确"
        ],
        [
            "A.4 (C++)",
            "麦子丰",
            "#include <vector>\n#include <string>\n#include <stdexcept>\n#include <iostream>\nusing namespace std;\n\n#define I(i,n) for (size_t i = 0; i < n; ++ i)\n\nclass NoSuchKeyException {};\nclass Type{\npublic:\n    string key1;\n    int key2;\n\n    Type():key1(string()),key2(0){}\n    Type(int num):key2(num),key1(string()){}\n    Type(string str):key2(0),key1(str){}\n\n    bool operator==(const Type& other) const{\n        if(key1 != other.key1) return false;\n        if(key2 != other.key2) return false;\n        return true;\n    }\n\n    operator string() { return key1; }\n    operator int(){ return key2; }\n};\n\nstring _itos(int num){\n    string res;\n    while(num > 0){\n        res.push_back(num%10+'0');\n        num /= 10;\n    }\n    int size = res.length();\n    I(i, size/2){\n        char tmp = res[i];\n        res[i] = res[size-1-i];\n        res[size-1-i] = tmp;\n    }\n    return res;\n}\n\nsize_t circular_shift(size_t bits, int shift_bits) {\n    const int num_bits = 8 * sizeof(size_t);\n    shift_bits = shift_bits % num_bits;\n    return bits << shift_bits | bits >> (num_bits - shift_bits);\n}\n\nsize_t hash_function(Type key){\n    string tmp_key;\n    if(key.key2 == 0) tmp_key = (string)key;\n    else tmp_key = _itos((int)key);\n    size_t code = 0;\n    I(i, tmp_key.size())\n        code ^= circular_shift(tmp_key[i], i * 5);\n    return code;\n}\n\nclass HT{\nprivate:\n    class Tuple{\n    public:\n        Type key;\n        Type val;\n        bool in_use;\n\n        Tuple() : in_use(false) {}\n    };\n\n    vector<Tuple> tuples;\n    size_t _size;\n\n    size_t canonical_index(Type key) const {\n        size_t hash_code = hash_function(key);\n        return hash_code % tuples.size();\n    }\n\n    size_t indexOfKey(Type key) const{\n        size_t index = canonical_index(key);\n        while (true) { \n            if (!tuples[index].in_use) return index;\n            if (tuples[index].key == key) return index;\n            index = (index + 1) % tuples.size();\n        }\n    }\n\npublic:\n    HT(): _size(0){\n        tuples.resize(2);\n    }\n\n    Type & operator [] (Type key){\n        size_t index = indexOfKey(key);\n        if (! tuples[index].in_use) \n            throw NoSuchKeyException();\n        return (Type &)tuples[index].val;\n    }\n\n    size_t size() const { return _size; }\n    void clear() {\n        I(i, tuples.size())\n            tuples[i].in_use = false;\n        _size = 0;\n    }\n    void put(Type key, Type val) {\n        size_t index = indexOfKey(key);\n        tuples[index].key = key;\n        tuples[index].val = val;\n        if (tuples[index].in_use) return;\n        tuples[index].in_use = true;\n        ++ _size;\n        if (2 * _size > tuples.size())\n            _double_tuples();\n    }\n    void _double_tuples() {\n        vector<Tuple> non_empty_tuples;\n        I(i, tuples.size())\n            if (tuples[i].in_use)\n                non_empty_tuples.push_back(tuples[i]);\n        clear();\n        tuples.resize(tuples.size() * 2);\n        I(i, non_empty_tuples.size())\n            put(non_empty_tuples[i].key, non_empty_tuples[i].val);\n    }\n};",
            1595169344.7862024,
            100,
            "# 答案正确"
        ],
        [
            "A.5 (C++)",
            "麦子丰",
            "#include <vector>\n#include <string>\n#include <stdexcept>\n#include <iostream>\nusing namespace std;\n\n#define I(i,n) for (size_t i = 0; i < n; ++ i)\n\nclass NoSuchKeyException {};\nclass Type{\npublic:\n    string key1;\n    int key2;\n\n    Type():key1(string()),key2(0){}\n    Type(int num):key2(num),key1(string()){}\n    Type(string str):key2(0),key1(str){}\n    Type(const Type& other) : key1(other.key1), key2(other.key2){}\n\n    bool operator== (const Type& other) const{\n        if(key1 != other.key1) return false;\n        if(key2 != other.key2) return false;\n        return true;\n    }\n    Type& operator=(const Type& other){\n        this->key1 = other.key1;\n        this->key2 = other.key2;\n        return *this;\n    }\n\n    operator string() { return key1; }\n    operator int(){ return key2; }\n};\n\nstring _itos(int num){\n    string res;\n    while(num > 0){\n        res.push_back(num%10+'0');\n        num /= 10;\n    }\n    int size = res.length();\n    I(i, size/2){\n        char tmp = res[i];\n        res[i] = res[size-1-i];\n        res[size-1-i] = tmp;\n    }\n    return res;\n}\n\nsize_t circular_shift(size_t bits, int shift_bits) {\n    const int num_bits = 8 * sizeof(size_t);\n    shift_bits = shift_bits % num_bits;\n    return bits << shift_bits | bits >> (num_bits - shift_bits);\n}\n\nsize_t hash_function(Type key){\n    string tmp_key;\n    if(key.key2 == 0) tmp_key = (string)key;\n    else tmp_key = _itos((int)key);\n    size_t code = 0;\n    I(i, tmp_key.size())\n        code ^= circular_shift(tmp_key[i], i * 5);\n    return code;\n}\n\nclass HT{\nprivate:\n    class Tuple{\n    public:\n        Type key;\n        Type val;\n        bool in_use;\n        Tuple():in_use(false) {}\n        Tuple(const Tuple& other):key(other.key),val(other.val),in_use(other.in_use){}\n        \n        Tuple & operator=(const Tuple& other){\n            this->key = other.key;\n            this->val = other.val;\n            this->in_use = other.in_use;\n            return *this;\n        }\n    };\n\n    vector<Tuple> tuples;\n    size_t _size;\n\n    size_t canonical_index(Type key) const {\n        size_t hash_code = hash_function(key);\n        return hash_code % tuples.size();\n    }\n\n    size_t indexOfKey(Type key) const{\n        size_t index = canonical_index(key);\n        while (true) { \n            if (!tuples[index].in_use) return index;\n            if (tuples[index].key == key) return index;\n            index = (index + 1) % tuples.size();\n        }\n    }\n\npublic:\n    HT(): _size(0){\n        tuples.resize(2);\n    }\n\n    size_t size() const { return _size; }\n\n    Type & operator [] (Type key){\n        size_t index = indexOfKey(key);\n        if (!tuples[index].in_use) {\n            tuples[index].key = key;\n            ++_size;\n            if (2 * _size > tuples.size())\n                _double_tuples();\n            tuples[index].in_use = true;\n        }\n        return tuples[index].val;\n    }\n\n    void clear() {\n        I(i, tuples.size())\n            tuples[i].in_use = false;\n        _size = 0;\n    }\n\n    void _double_tuples() {\n        vector<Tuple> non_empty_tuples;\n        I(i, tuples.size())\n            if (tuples[i].in_use)\n                non_empty_tuples.push_back(tuples[i]);\n        clear();\n        tuples.resize(tuples.size() * 2);\n        I(i, non_empty_tuples.size()){\n            size_t index = indexOfKey(non_empty_tuples[i].key);\n            tuples[index] = non_empty_tuples[i];\n            ++_size;\n        }\n        ++_size;\n    }\n};",
            1595486646.4661183,
            100,
            "# 答案不正确\n\n# 随机输入:\n40 48 38 59 33 66 74 81 \n\n# 参考答案:\n4\n48\n59\n66\n81\n\n\n# 我的答案:\n4\n48\n66\n\n81\n"
        ],
        [
            "A.3 (C++)",
            "麦子丰",
            "#include <vector>\n#include <string>\n#include <stdexcept>\n#include <sstream>\n#include <iostream>\nusing namespace std;\n\n#define I(i,n) for (size_t i = 0; i < n; ++ i)\n\nclass NoSuchKeyException {};\n\nstring _itos(int num){\n    string res;\n    while(num > 0){\n        res.push_back(num%10+'0');\n        num /= 10;\n    }\n    int size = res.length();\n    I(i, size/2){\n        char tmp = res[i];\n        res[i] = res[size-1-i];\n        res[size-1-i] = tmp;\n    }\n    return res;\n}\n\nsize_t circular_shift(size_t bits, int shift_bits) {\n    const int num_bits = 8 * sizeof(size_t);\n    shift_bits = shift_bits % num_bits;\n    return bits << shift_bits | bits >> (num_bits - shift_bits);\n}\n\nsize_t hash_function(const int & key){\n    string tmp_key = _itos(key);\n    size_t code = 0;\n    I(i, tmp_key.size())\n        code ^= circular_shift(tmp_key[i], i * 5);\n    return code;\n}\n\ntemplate <typename E>\nclass HT{\nprivate:\n    class Tuple{\n    public:\n        int key;\n        E val;\n        bool in_use;\n\n        Tuple():in_use(false) {}\n    };\n\n    vector<Tuple> tuples;\n    size_t _size;\n\n    size_t canonical_index(int key) const {\n        size_t hash_code = hash_function(key);\n        return hash_code % tuples.size();\n    }\n    size_t indexOfKey(int key) const{\n        size_t index = canonical_index(key);\n        while (true) { \n            if (!tuples[index].in_use) return index;\n            if (tuples[index].key == key) return index;\n            index = (index + 1) % tuples.size();\n        }\n    }\n\npublic:\n    HT() : _size(0) {\n        tuples.resize(2);\n    }\n\n    bool containsKey(const int & key) const {\n        size_t index = indexOfKey(key);\n        return tuples[index].in_use;\n    }\n\n    const E & operator [] (const int & key) const {\n        size_t index = indexOfKey(key);\n        if (! tuples[index].in_use) \n            throw NoSuchKeyException();\n        return tuples[index].val;\n    }\n    E & operator [] (const int & key) {\n        size_t index = indexOfKey(key);\n        if (!tuples[index].in_use) \n            throw NoSuchKeyException();\n        return tuples[index].val;\n    }\n\n    void put(const int & key, const E & val) {\n        size_t index = indexOfKey(key);\n        tuples[index].key = key;\n        tuples[index].val = val;\n        if (tuples[index].in_use) return;\n        tuples[index].in_use = true;\n        ++ _size;\n        if (2 * _size > tuples.size())\n            _double_tuples();\n    }\n    void _double_tuples() {\n        vector<Tuple> non_empty_tuples;\n        I(i, tuples.size())\n            if (tuples[i].in_use)\n                non_empty_tuples.push_back(tuples[i]);\n        clear();\n        tuples.resize(tuples.size() * 2);\n        I(i, non_empty_tuples.size())\n            put(non_empty_tuples[i].key, non_empty_tuples[i].val);\n    }\n\n    static bool _between(size_t hole, size_t canonical, size_t tuple_index) {\n        if (hole < tuple_index)\n            return canonical > hole && canonical <= tuple_index;\n        else\n            return canonical > hole || canonical <= tuple_index;\n    }\n    void remove(const int & key) { \n        size_t index = indexOfKey(key);\n        if (! tuples[index].in_use) \n            throw NoSuchKeyException();\n        tuples[index].in_use = false;\n        -- _size;\n        size_t hole = index;\n        size_t tuple_index = hole;\n        while (true) {\n            tuple_index = (tuple_index + 1) % tuples.size();\n            if (! tuples[tuple_index].in_use) return;\n            size_t canonical = canonical_index(tuples[tuple_index].key);\n            if (_between(hole, canonical, tuple_index)) continue;\n            tuples[hole] = tuples[tuple_index];\n            hole = tuple_index;\n            tuples[hole].in_use = false;\n        }\n    }\n\n    size_t size() const { return _size; }\n    void clear() {\n        I(i, tuples.size())\n            tuples[i].in_use = false;\n        _size = 0;\n    }\n\n    vector<int> getKeys() const{ \n        vector<int> keys;\n        I(i, tuples.size())\n            if(tuples[i].in_use)\n                keys.push_back(tuples[i].key);\n        return keys;\n    }\n};",
            1595471996.8082707,
            100,
            "# 答案正确"
        ]
    ],
    "table_name": "答案"
}