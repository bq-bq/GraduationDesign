{
    "__update_time__": 1595472428.6943107,
    "field_names": [
        "题目名",
        "用户名",
        "答案",
        "提交时间",
        "分数",
        "评语"
    ],
    "field_types": [
        "text",
        "text",
        "text",
        "time",
        "number",
        "text"
    ],
    "foreign_keys": {},
    "primary_keys": [],
    "rows": [
        [
            "测试1",
            "覃浩南",
            "#include <iostream>\nusing namespace std;\n\nint main(){\n    string a, b, c;\n    cin >> a >> b >> c;\n    cout << c << \" \" << b << \" \" << a << endl;\n}",
            1587608829.707118,
            100,
            "# 答案正确"
        ],
        [
            "测试2",
            "覃浩南",
            "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main(){\n    vector<string> v(10);\n    for(auto &s: v){\n        cin >> s;\n    }\n\n    for(int i = 0; i != v.size() - 1; ++i){\n        int m = i;\n        for(int j = i + 1; j != v.size(); ++j){\n            if(v[j] < v[m]){\n                m = j;\n            }\n        }\n        if(m != i){\n            auto tmp = v[i];\n            v[i] = v[m];\n            v[m] = tmp;\n        }\n    }\n\n    for(auto t : v){\n        cout << t << \" \";\n    }\n\n    cout << endl;\n}",
            1587609475.3074,
            100,
            "# 答案正确"
        ],
        [
            "1.1 (C++)",
            "覃浩南",
            "struct Matrix5x5{\nprivate:\n    double m[5][5];\npublic:\n    Matrix5x5()\n\t{\n\t\tfor (int row = 0; row < 5; ++ row) {\n\t\t    for (int col = 0; col < 5; ++ col) {\n                this->m[row][col] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tdouble get(int x, int y){\n        return m[x][y];\n    }\n    \n    void set(int x, int y, double k){\n        m[x][y] = k;\n    }\n\n    Matrix5x5 operator+ (Matrix5x5 & x){\n        for (int row = 0; row < 5; ++ row) {\n\t\t    for (int col = 0; col < 5; ++ col) {\n                this->m[row][col] += x.m[row][col];\n\t\t\t}\n\t\t}\n\n        return *this;\n\t}\n};",
            1587697367.8514593,
            100,
            "# 答案正确"
        ],
        [
            "1.2 (C++)",
            "覃浩南",
            "#include<string>\nusing namespace std;\n\nstruct School{\nfriend void print(School & school);\npublic:\n    School(): name(\"NO_NAME\"), age(0){}\n    \n    void setName(char name[]);\n    void setAge(int year);\n\n    void operator ++ ();\nprivate:\n    string name;\n    int age;\n};\n\nvoid School::setName(char name[]){\n    this->name = name;\n}\n\nvoid School::setAge(int year){\n    this->age = year;\n}\n\nvoid School::operator ++ (){\n    ++this->age;\n}",
            1588215458.708108,
            100,
            "# 答案正确"
        ],
        [
            "2.1 (C++)",
            "覃浩南",
            "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nstruct Matrix{\nprivate:\n    int rows;\n    int columns;\n    double **values;\npublic:\n    Matrix(int r, int c) :rows(r), columns(c)\n    {\n        this->values = new double*[rows]();\n        for(int i = 0; i != rows; ++i){\n            values[i] = new double[columns]();\n        }\n    }\n\n    ~Matrix()\n    {\n        for(int i = 0; i != rows; ++i){\n            delete [] values[i];\n        }\n        delete values;\n    }\n\n    void print();\n};\n\nvoid Matrix::print(){\n    for(int i = 0; i != rows; ++i){\n        for(int j = 0; j != columns; ++j){\n            cout << setw(5) << values[i][j];\n        }\n        cout << endl;\n    }\n}\n",
            1588838146.729649,
            100,
            "# 答案正确"
        ],
        [
            "2.2 (C++)",
            "覃浩南",
            "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nstruct Matrix{\nprivate:\n    int rows;\n    int columns;\n    double **values;\npublic:\n    Matrix(int r, int c, double values[]) :rows(r), columns(c)\n    {\n        this->values = new double*[rows]();\n        for(int i = 0; i != rows; ++i){\n            this->values[i] = new double[columns]();\n        }\n        \n        int k = 0;\n        for(int i = 0; i != rows; ++i){\n            for(int j = 0; j != columns; ++j){\n                this->values[i][j] = values[k++];\n            }\n        }\n    }\n\n    ~Matrix()\n    {\n        for(int i = 0; i != rows; ++i){\n            delete [] values[i];\n        }\n        delete values;\n    }\n\n    void print();\n};\n\nvoid Matrix::print(){\n    for(int i = 0; i != rows; ++i){\n        for(int j = 0; j != columns; ++j){\n            cout << setw(5) << values[i][j];\n        }\n        cout << endl;\n    }\n}",
            1588838467.9814665,
            100,
            "# 答案正确"
        ],
        [
            "2.3 (C++)",
            "覃浩南",
            "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nstruct Matrix{\nprivate:\n    int rows;\n    int columns;\n    double **values;\npublic:\n    Matrix(int r, int c, double values[]) :rows(r), columns(c)\n    {\n        this->values = new double*[rows]();\n        for(int i = 0; i != rows; ++i){\n            this->values[i] = new double[columns]();\n        }\n        \n        int k = 0;\n        for(int i = 0; i != rows; ++i){\n            for(int j = 0; j != columns; ++j){\n                this->values[i][j] = values[k++];\n            }\n        }\n    }\n    \n    Matrix(const Matrix & matrix2){\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        this->values = new double*[rows]();\n        for(int i = 0; i != rows; ++i){\n            this->values[i] = new double[columns]();\n        }\n        for(int i = 0; i != rows; ++i){\n            for(int j = 0; j != columns; ++j){\n                this->values[i][j] = matrix2.values[i][j];\n            }\n        }\n    }\n\n    ~Matrix()\n    {\n        for(int i = 0; i != rows; ++i){\n            delete [] values[i];\n        }\n        delete values;\n    }\n\n    void print();\n};\n\nvoid Matrix::print(){\n    for(int i = 0; i != rows; ++i){\n        for(int j = 0; j != columns; ++j){\n            cout << \"    \" << values[i][j];\n        }\n        cout << endl;\n    }\n}",
            1588839179.1123695,
            100,
            "# 答案正确"
        ],
        [
            "2.5 (C++)",
            "覃浩南",
            "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nstruct Matrix{\nprivate:\n    int rows;\n    int columns;\n    double **values;\npublic:\n    Matrix(int r, int c, double values[]) :rows(r), columns(c)\n    {\n        this->values = new double*[rows]();\n        for(int i = 0; i != rows; ++i){\n            this->values[i] = new double[columns]();\n        }\n        \n        int k = 0;\n        for(int i = 0; i != rows; ++i){\n            for(int j = 0; j != columns; ++j){\n                this->values[i][j] = values[k++];\n            }\n        }\n    }\n    \n    Matrix(const Matrix & matrix2){\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        this->values = new double*[rows]();\n        for(int i = 0; i != rows; ++i){\n            this->values[i] = new double[columns]();\n        }\n        for(int i = 0; i != rows; ++i){\n            for(int j = 0; j != columns; ++j){\n                this->values[i][j] = matrix2.values[i][j];\n            }\n        }\n    }\n\n    ~Matrix()\n    {\n        for(int i = 0; i != rows; ++i){\n            delete [] values[i];\n        }\n        delete values;\n    }\n\n    void print();\n    Matrix getRow(int row);\n    Matrix getColumn(int column);\n};\n\nvoid Matrix::print(){\n    for(int i = 0; i != rows; ++i){\n        for(int j = 0; j != columns; ++j){\n            cout << \"    \" << values[i][j];\n        }\n        cout << endl;\n    }\n}\n\nMatrix Matrix::getRow(int row){\n    Matrix tmp(1, this->columns, this->values[row - 1]);\n    return tmp;\n}\n\nMatrix Matrix::getColumn(int column){\n    \n    double d[20];\n    for(int i = 0; i != rows; ++i){\n        d[i] = values[i][column - 1];\n    }\n\n    Matrix tmp(this->rows, 1, d);\n    return tmp;\n}\n",
            1588860297.992582,
            100,
            "# 答案正确"
        ],
        [
            "2.6 (C++)",
            "覃浩南",
            "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nstruct Matrix{\nprivate:\n    int rows;\n    int columns;\n    double **values;\npublic:\n    Matrix(int r, int c, double values[]) :rows(r), columns(c)\n    {\n        this->values = new double*[rows]();\n        for(int i = 0; i != rows; ++i){\n            this->values[i] = new double[columns]();\n        }\n        \n        int k = 0;\n        for(int i = 0; i != rows; ++i){\n            for(int j = 0; j != columns; ++j){\n                this->values[i][j] = values[k++];\n            }\n        }\n    }\n    \n    Matrix(const Matrix & matrix2){\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        this->values = new double*[rows]();\n        for(int i = 0; i != rows; ++i){\n            this->values[i] = new double[columns]();\n        }\n        for(int i = 0; i != rows; ++i){\n            for(int j = 0; j != columns; ++j){\n                this->values[i][j] = matrix2.values[i][j];\n            }\n        }\n    }\n\n    ~Matrix()\n    {\n        for(int i = 0; i != rows; ++i){\n            delete [] values[i];\n        }\n        delete values;\n    }\n\n    void print();\n    Matrix getRow(int row);\n    Matrix getColumn(int column);\n    Matrix concatenateRows(const Matrix & matrix2) const;\n    Matrix concatenateColumns(const Matrix & matrix2) const;\n};\n\nvoid Matrix::print(){\n    for(int i = 0; i != rows; ++i){\n        for(int j = 0; j != columns; ++j){\n            cout << \"    \" << values[i][j];\n        }\n        cout << endl;\n    }\n}\n\nMatrix Matrix::getRow(int row){\n    Matrix tmp(1, this->columns, this->values[row - 1]);\n    return tmp;\n}\n\nMatrix Matrix::getColumn(int column){    \n    double d[20];\n    for(int i = 0; i != rows; ++i){\n        d[i] = values[i][column - 1];\n    }\n\n    Matrix tmp(this->rows, 1, d);\n    return tmp;\n}\n\nMatrix Matrix::concatenateRows(const Matrix & matrix2) const{\n    double st[100];    \n    int k = 0;\n    for(int i = 0; i != this->rows + matrix2.rows; ++i){\n        for(int j = 0; j != this->columns; ++j){\n            if(i < this->rows) st[k++] = this->values[i][j];\n            else st[k++] = matrix2.values[i - this->rows][j];\n        }\n    }\n    Matrix tmp(this->rows + matrix2.rows, this->columns, st);\n    return tmp;\n}\n\nMatrix Matrix::concatenateColumns(const Matrix & matrix2) const{\n    double st[100];    \n    int k = 0;\n    for(int i = 0; i != this->rows; ++i){\n        for(int j = 0; j != this->columns + matrix2.columns; ++j){\n            if(j < this->columns) st[k++] = this->values[i][j];\n            else st[k++] = matrix2.values[i][j - this->columns];\n        }\n    }\n    Matrix tmp(this->rows, this->columns + matrix2.columns, st);\n    return tmp;\n}",
            1588899251.5230098,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/08",
            "覃浩南",
            "double & Tensor_get(int dimensions, const int sizes[], double data[], int x0, int x1, int x2, int x3){\n    switch(dimensions){\n        case 1:\n            return data[x0]; \n            break;\n        case 2:\n            return data[x1 * sizes[0] + x0];\n            break;\n        case 3:\n            return data[x2 * sizes[1] * sizes[0] + x1 * sizes[0] + x0];\n            break;\n        case 4:\n            return data[x3 * sizes[2] * sizes[1] * sizes[0] + x2 * sizes[1] * sizes[0] + x1 * sizes[0] + x0];\n            break;\n    }\n\n    return data[0];\n}",
            1588905748.613063,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/14",
            "覃浩南",
            "#include <iostream>\nusing namespace std;\nvoid Tensor_print(int dimensions, const int sizes[], const double data[]){\n    cout << \"Tensor of \";\n    switch(dimensions){\n        case 1:\n            cout << sizes[0] << endl;\n            break;\n        case 2:\n            cout << sizes[0] << \"x\" << sizes[1] << endl;\n            break;\n        case 3:\n            cout << sizes[0] << \"x\" << sizes[1] << \"x\" << sizes[2] << endl;\n            break;\n        case 4:\n            cout << sizes[0] << \"x\" << sizes[1] << \"x\" << sizes[2] << \"x\" << sizes[3] << endl;\n    }\n\n    if(dimensions == 1){\n        for(int i = 0; i != sizes[0]; ++i){\n            cout << data[i] << endl;\n        }\n    }\n\n    if(dimensions == 2){\n        for(int i = 0; i != sizes[0]; ++i){\n            for(int j = 0; j != sizes[1]; ++j){\n                cout << \"    \" << data[i * sizes[1] + j];\n            }          \n            cout << endl;\n        }\n    }\n\n    if(dimensions == 3){\n        for(int k = 0; k < sizes[0]; ++k){\n            cout << \"data[\" << k << \"]\" << endl;\n            for(int i = 0; i != sizes[1]; ++i){\n                for(int j = 0; j != sizes[2]; ++j){\n                    cout << \"    \" << data[k * sizes[1] * sizes[2] + i * sizes[2] + j];\n                }          \n                cout << endl;\n            }\n        }\n    }\n    if(dimensions == 4){\n        for(int k = 0; k < sizes[0]; ++k){\n            for(int t = 0; t < sizes[1]; ++t){    \n                cout << \"data[\" << k << \"]\" << \"[\" << t << \"]\" << endl;\n                for(int i = 0; i != sizes[2]; ++i){\n                    for(int j = 0; j != sizes[3]; ++j){\n                        cout << \"    \" << data[k * sizes[1] * sizes[2] * sizes[3] + t * sizes[2] * sizes[3] + i * sizes[3] + j];\n                    }          \n                    cout << endl;\n                }\n            }\n        }\n    }  \n}",
            1589425621.6471446,
            100,
            "# 答案正确"
        ],
        [
            "2.4 (C++)",
            "覃浩南",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix{\nprivate:\n    int rows;\n    int columns;\n    double * values;\npublic:\n    Matrix(int row, int column):rows(row), columns(column)\n    {\n        this->values = new double[row * columns];\n        int k;\n        for(k = 0; k < row * column; ++k){\n            this->values[k] = 0;\n        }\n    }\n    \n    Matrix(int row, int column, double value[]): rows(row), columns(column)\n    {\n        this->values = new double[row * column];\n        int k;\n        for(k = 0; k < row * column; ++k){\n            this->values[k] = value[k];\n        }\n    }\n    \n    ~Matrix()\n    {\n        delete [] this->values;\n    }\n\n    void print();\n    void set(int row, int column, double value);\n    Matrix & operator = (const Matrix & m);\n};\n\nvoid Matrix::print(){\n    for(int i = 0; i < rows; ++i){\n        for(int j = 0; j < columns; ++j){\n            cout << \"    \" << values[i * columns + j];\n        }\n        cout << endl; \n    }\n}\n\nvoid Matrix::set(int row, int column, double value){\n    this->values[(row - 1) * this -> columns + column - 1] = value;\n}\n\nMatrix & Matrix::operator = (const Matrix & m){\n    this->rows = m.rows;\n    this->columns = m.columns;\n   if(values != 0){\n        delete [] values;\n    } \n\tthis->values = new double[m.rows * m.columns]; \n\tint k;\n    for(k = 0; k < m.rows * m.columns; ++k){\n        this->values[k] = m.values[k];\n    }\n    return *this;\n}",
            1589589067.1062799,
            100,
            "# 答案正确"
        ],
        [
            "2.7 (C++)",
            "覃浩南",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix{\nprivate:\n    int rows;\n    int columns;\n    double * values;\npublic:\n    Matrix(int row, int column):rows(row), columns(column)\n    {\n        this->values = new double[row * columns];\n        int k;\n        for(k = 0; k < row * column; ++k){\n            this->values[k] = 0;\n        }\n    }\n    \n    Matrix(int row, int column, double value[]): rows(row), columns(column)\n    {\n        this->values = new double[row * column];\n        int k;\n        for(k = 0; k < row * column; ++k){\n            this->values[k] = value[k];\n        }\n    }\n    \n    Matrix(const Matrix & matrix2){\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        if(values != 0){\n            delete [] values;\n        }\n        this->values = new double[matrix2.rows * matrix2.columns];\n        int k;\n        for(k = 0; k < matrix2.rows * matrix2.columns; ++k){\n            this->values[k] = matrix2.values[k];\n        }\n    }\n\n    ~Matrix()\n    {\n        delete [] this->values;\n    }\n\n    void print() const;\n    void set(int row, int column, double value);\n    Matrix & operator = (const Matrix & m);\n    Matrix reshape(int rows, int columns) const;\n};\n\nvoid Matrix::print() const{\n    for(int i = 0; i < rows; ++i){\n        for(int j = 0; j < columns; ++j){\n            cout << \"    \" << values[i * columns + j];\n        }\n        cout << endl; \n    }\n}\n\nvoid Matrix::set(int row, int column, double value){\n    this->values[(row - 1) * this -> columns + column - 1] = value;\n}\n\nMatrix & Matrix::operator = (const Matrix & m){\n    this->rows = m.rows;\n    this->columns = m.columns;\n    if(values != 0){\n        delete [] values;\n    }\n    this->values = new double[m.rows * m.columns];\n    int k;\n    for(k = 0; k < m.rows * m.columns; ++k){\n        this->values[k] = m.values[k];\n    }\n    return *this;\n}\n\nMatrix Matrix::reshape(int row, int column) const{\n    Matrix tmp(row, column);\n    int v[100];\n    int k = 0;\n    for(int i = 0; i < this->columns; ++i){\n        for(int j = 0; j < this->rows; ++j){\n            v[k++] = values[j * this->columns + i];\n        }\n    }\n\n    int t = 0;\n    for(int i = 0; i < column; ++i){\n        for(int j = 0; j < row; ++j){\n            tmp.values[j * column + i] = v[t++];\n        }\n    }\n\n    return tmp;\n}",
            1589590269.0830033,
            100,
            "# 答案正确"
        ],
        [
            "2.8 (C++)",
            "覃浩南",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix{\nprivate:\n    int rows;\n    int columns;\n    double * values;\npublic:\n    Matrix(int row, int column):rows(row), columns(column)\n    {\n        this->values = new double[row * columns];\n        int k;\n        for(k = 0; k < row * column; ++k){\n            this->values[k] = 0;\n        }\n    }\n    \n    Matrix(int row, int column, double value[]): rows(row), columns(column)\n    {\n        this->values = new double[row * column];\n        int k;\n        for(k = 0; k < row * column; ++k){\n            this->values[k] = value[k];\n        }\n    }\n    \n    Matrix(const Matrix & matrix2){\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        if(values != 0){\n            delete [] values;\n        }\n        this->values = new double[matrix2.rows * matrix2.columns];\n        int k;\n        for(k = 0; k < matrix2.rows * matrix2.columns; ++k){\n            this->values[k] = matrix2.values[k];\n        }\n    }\n\n    ~Matrix()\n    {\n        delete [] this->values;\n    }\n\n    void print() const;\n    void set(int row, int column, double value);\n    Matrix & operator = (const Matrix & m);\n    Matrix reshape(int rows, int columns) const;\n    Matrix transpose();\n};\n\nvoid Matrix::print() const{\n    for(int i = 0; i < rows; ++i){\n        for(int j = 0; j < columns; ++j){\n            cout << \"    \" << values[i * columns + j];\n        }\n        cout << endl; \n    }\n}\n\nvoid Matrix::set(int row, int column, double value){\n    this->values[(row - 1) * this -> columns + column - 1] = value;\n}\n\nMatrix & Matrix::operator = (const Matrix & m){\n    this->rows = m.rows;\n    this->columns = m.columns;\n    if(values != 0){\n        delete [] values;\n    }\n    this->values = new double[m.rows * m.columns];\n    int k;\n    for(k = 0; k < m.rows * m.columns; ++k){\n        this->values[k] = m.values[k];\n    }\n    return *this;\n}\n\nMatrix Matrix::reshape(int row, int column) const{\n    Matrix tmp(row, column);\n    int v[100];\n    int k = 0;\n    for(int i = 0; i < this->columns; ++i){\n        for(int j = 0; j < this->rows; ++j){\n            v[k++] = values[j * this->columns + i];\n        }\n    }\n\n    int t = 0;\n    for(int i = 0; i < column; ++i){\n        for(int j = 0; j < row; ++j){\n            tmp.values[j * column + i] = v[t++];\n        }\n    }\n\n    return tmp;\n}\n\nMatrix Matrix::transpose(){\n    Matrix tmp(this->columns, this->rows);\n    for(int i = 0; i < this->columns; ++i){\n        for(int j = 0; j < this->rows; ++j){\n            tmp.values[i * this->rows + j] = this->values[j * this->columns + i]; \n        }\n    }\n    return tmp;\n}",
            1589595592.5489154,
            100,
            "# 答案正确"
        ],
        [
            "2.10 (C++)",
            "覃浩南",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix{\nprivate:\n    int rows = 0;\n    int columns = 0;\n    double * values = 0;\npublic:\n    Matrix(int row, int column):rows(row), columns(column)\n    {\n        this->values = new double[row * columns];\n        int k;\n        for(k = 0; k < row * column; ++k){\n            this->values[k] = 0;\n        }\n    }\n    \n    Matrix(int row, int column, double value[]): rows(row), columns(column)\n    {\n        this->values = new double[row * column];\n        int k;\n        for(k = 0; k < row * column; ++k){\n            this->values[k] = value[k];\n        }\n    }\n    \n    Matrix(const Matrix & matrix2){\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        if(values != 0){\n            delete [] values;\n        }\n        this->values = new double[matrix2.rows * matrix2.columns];\n        int k;\n        for(k = 0; k < matrix2.rows * matrix2.columns; ++k){\n            this->values[k] = matrix2.values[k];\n        }\n    }\n\n    ~Matrix()\n    {\n        delete [] this->values;\n    }\n\n    void print() const;    \n    Matrix & operator = (const Matrix & m);\n    Matrix operator * (const Matrix & matrix2) const;\n    Matrix operator * (double value) const;\n};\n\nvoid Matrix::print() const{\n    for(int i = 0; i < rows; ++i){\n        for(int j = 0; j < columns; ++j){\n            cout << \"    \" << values[i * columns + j];\n        }\n        cout << endl; \n    }\n}\n\nMatrix & Matrix::operator = (const Matrix & m){\n    this->rows = m.rows;\n    this->columns = m.columns;\n    if(values != 0){\n        delete [] values;\n    } \n\tthis->values = new double[m.rows * m.columns]; \n\tint k;\n    for(k = 0; k < m.rows * m.columns; ++k){\n        this->values[k] = m.values[k];\n    }\n    return *this;\n}\n\n\nMatrix Matrix::operator * (const Matrix & matrix2) const{\n    Matrix tmp(this->rows, matrix2.columns);\n    for(int i = 0; i < tmp.rows; ++i){\n        for(int j = 0; j < tmp.columns; ++j){\n            for(int k = 0; k < this->columns; ++k){    \n                tmp.values[i * tmp.columns + j] += this->values[i * this->columns + k] * matrix2.values[k * matrix2.columns + j];\n            }\n        }\n    }\n\n    return tmp; \n}\n\nMatrix Matrix::operator * (double value) const{\n    Matrix tmp(*this);\n    for(int i = 0; i < tmp.rows; ++i){\n        for(int j = 0; j < tmp.columns; ++j){\n            tmp.values[i * tmp.columns + j] *= value;\n        }\n    }\n    return tmp;\n}",
            1589598033.0962043,
            100,
            "# 答案正确"
        ],
        [
            "2.12 (C++)",
            "覃浩南",
            "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nclass Matrix{\nprivate:\n    int rows = 0;\n    int columns = 0;\n    double * values = 0;\npublic:\n    Matrix(int row, int column):rows(row), columns(column)\n    {\n        this->values = new double[row * columns];\n        int k;\n        for(k = 0; k < row * column; ++k){\n            this->values[k] = 0;\n        }\n    }\n    \n    Matrix(int row, int column, double value[]): rows(row), columns(column)\n    {\n        this->values = new double[row * column];\n        int k;\n        for(k = 0; k < row * column; ++k){\n            this->values[k] = value[k];\n        }\n    }\n    \n    Matrix(const Matrix & matrix2){\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        if(values != 0){\n            delete [] values;\n        }\n        this->values = new double[matrix2.rows * matrix2.columns];\n        int k;\n        for(k = 0; k < matrix2.rows * matrix2.columns; ++k){\n            this->values[k] = matrix2.values[k];\n        }\n    }\n\n    ~Matrix()\n    {\n        delete [] this->values;\n    }\n\n    void print() const;    \n    Matrix & operator = (const Matrix & m);\n    Matrix pow(double exponent);\n    Matrix exp();\n    Matrix log();\n    Matrix abs();\n};\n\nvoid Matrix::print() const{\n    for(int i = 0; i < rows; ++i){\n        for(int j = 0; j < columns; ++j){\n            cout << \"    \" << values[i * columns + j];\n        }\n        cout << endl; \n    }\n}\n\nMatrix & Matrix::operator = (const Matrix & m){\n    this->rows = m.rows;\n    this->columns = m.columns;\n    if(values != 0){\n        delete [] values;\n    } \n\tthis->values = new double[m.rows * m.columns]; \n\tint k;\n    for(k = 0; k < m.rows * m.columns; ++k){\n        this->values[k] = m.values[k];\n    }\n    return *this;\n}\n\nMatrix Matrix::pow(double exponent){\n    Matrix tmp(*this);\n    for(int i = 0; i < tmp.rows; ++i){\n        for(int j = 0; j < tmp.columns; ++j){\n            tmp.values[i * tmp.columns + j] =::pow(tmp.values[i * tmp.columns + j], exponent);\n        }\n    }\n\n    return tmp;\n}\n\nMatrix Matrix::exp(){\n    Matrix tmp(*this);\n    for(int i = 0; i < tmp.rows; ++i){\n        for(int j = 0; j < tmp.columns; ++j){\n            tmp.values[i * tmp.columns + j] = ::exp(tmp.values[i * tmp.columns + j]);\n        }\n    }\n\n    return tmp;\n}\n\nMatrix Matrix::log(){\n    Matrix tmp(*this);\n    for(int i = 0; i < tmp.rows; ++i){\n        for(int j = 0; j < tmp.columns; ++j){\n            tmp.values[i * tmp.columns + j] = ::log(tmp.values[i * tmp.columns + j]);\n        }\n    }\n\n    return tmp;\n}\n\nMatrix Matrix::abs(){\n    Matrix tmp(*this);\n    for(int i = 0; i < tmp.rows; ++i){\n        for(int j = 0; j < tmp.columns; ++j){\n            tmp.values[i * tmp.columns + j] = ::abs(tmp.values[i * tmp.columns + j]);\n        }\n    }\n\n    return tmp;\n}",
            1589614451.5652847,
            100,
            "# 答案正确"
        ],
        [
            "2.11 (C++)",
            "覃浩南",
            "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nclass Matrix{\nprivate:\n    int rows = 0;\n    int columns = 0;\n    double * values = 0;\npublic:\n    Matrix(int row, int column):rows(row), columns(column)\n    {\n        this->values = new double[row * columns];\n        int k;\n        for(k = 0; k < row * column; ++k){\n            this->values[k] = 0;\n        }\n    }\n    \n    Matrix(int row, int column, double value[]): rows(row), columns(column)\n    {\n        this->values = new double[row * column];\n        int k;\n        for(k = 0; k < row * column; ++k){\n            this->values[k] = value[k];\n        }\n    }\n    \n    Matrix(const Matrix & matrix2){\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        if(values != 0){\n            delete [] values;\n        }\n        this->values = new double[matrix2.rows * matrix2.columns];\n        int k;\n        for(k = 0; k < matrix2.rows * matrix2.columns; ++k){\n            this->values[k] = matrix2.values[k];\n        }\n    }\n\n    ~Matrix()\n    {\n        delete [] this->values;\n    }\n\n    void print() const;    \n    Matrix & operator = (const Matrix & m);\n    Matrix pow(double exponent);\n    Matrix exp();\n    Matrix log();\n    Matrix abs();\n    Matrix max() const;\n    Matrix min() const;\n    Matrix sum() const;\n};\n\nvoid Matrix::print() const{\n    for(int i = 0; i < rows; ++i){\n        for(int j = 0; j < columns; ++j){\n            cout << \"    \" << values[i * columns + j];\n        }\n        cout << endl; \n    }\n}\n\nMatrix & Matrix::operator = (const Matrix & m){\n    this->rows = m.rows;\n    this->columns = m.columns;\n    if(values != 0){\n        delete [] values;\n    } \n\tthis->values = new double[m.rows * m.columns]; \n\tint k;\n    for(k = 0; k < m.rows * m.columns; ++k){\n        this->values[k] = m.values[k];\n    }\n    return *this;\n}\n\nMatrix Matrix::pow(double exponent){\n    Matrix tmp(*this);\n    for(int i = 0; i < tmp.rows; ++i){\n        for(int j = 0; j < tmp.columns; ++j){\n            tmp.values[i * tmp.columns + j] = powf(tmp.values[i * tmp.columns + j], exponent);\n        }\n    }\n\n    return tmp;\n}\n\nMatrix Matrix::exp(){\n    Matrix tmp(*this);\n    for(int i = 0; i < tmp.rows; ++i){\n        for(int j = 0; j < tmp.columns; ++j){\n            tmp.values[i * tmp.columns + j] = expf(tmp.values[i * tmp.columns + j]);\n        }\n    }\n\n    return tmp;\n}\n\nMatrix Matrix::log(){\n    Matrix tmp(*this);\n    for(int i = 0; i < tmp.rows; ++i){\n        for(int j = 0; j < tmp.columns; ++j){\n            tmp.values[i * tmp.columns + j] = ::log(tmp.values[i * tmp.columns + j]);\n        }\n    }\n\n    return tmp;\n}\n\nMatrix Matrix::abs(){\n    Matrix tmp(*this);\n    for(int i = 0; i < tmp.rows; ++i){\n        for(int j = 0; j < tmp.columns; ++j){\n            tmp.values[i * tmp.columns + j] = ::abs(tmp.values[i * tmp.columns + j]);\n        }\n    }\n\n    return tmp;\n}\n\nMatrix Matrix::max() const{\n    if(this->rows > 1){\n        Matrix tmp(1, this->columns);\n        int i, j; int k = 0; \n        for(i = 0; i < this->columns; ++i){\n            int max = -1;\n            for(j = 0; j < this->rows; ++j){\n                if(this->values[j * columns + i] > max){\n                    max = values[j * columns + i];\n                }\n            }\n            tmp.values[k++] = max;\n        }\n        return tmp;\n    }\n    else{\n        Matrix tmp(1,1); int max = -1;\n        for(int k = 0; k < this->columns; ++k){\n            if(this->values[k] > max){\n                max = this->values[k];\n            }\n        }\n\n        tmp.values[0] = max;\n        return tmp;\n    }\n}\n\nMatrix Matrix::min() const{\n    if(this->rows > 1){\n        Matrix tmp(1, this->columns);\n        int i, j; int k = 0;\n        for(i = 0; i < this->columns; ++i){\n            int min = 0xffffff;\n            for(j = 0; j < this->rows; ++j){\n                if(this->values[j * columns + i] < min){\n                    min = values[j * columns + i];\n                }\n            }\n            tmp.values[k++] = min;\n        }\n\n        return tmp;\n    }\n    else{\n        Matrix tmp(1,1); int min = 0xfffffff;\n        for(int k = 0; k < this->columns; ++k){\n            if(this->values[k] < min){\n                min = this->values[k];\n            }\n        }\n        tmp.values[0] = min;\n        return tmp;\n    }\n}\n\nMatrix Matrix::sum() const{\n    if(this->rows > 1){\n        Matrix tmp(1, this->columns);\n        int i, j, k;\n\n        for(i = 0; i < this->columns; ++i){\n            for(j = 0; j < this->rows; ++j){\n                tmp.values[k] += this->values[j * columns + i];\n            }\n            ++k;\n        }\n\n        return tmp;\n    }\n    else{\n        Matrix tmp(1, 1); int sum = 0;\n        for(int i = 0; i < this->columns; ++i){\n            sum += this->values[i];\n        }\n\n        tmp.values[0] = sum;\n        return tmp;\n    }\n}",
            1589613164.1284337,
            100,
            "# 答案正确"
        ],
        [
            "2.9 (C++)",
            "覃浩南",
            "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nclass Matrix{\nprivate:\n    int rows = 0;\n    int columns = 0;\n    double * values = 0;\npublic:\n    Matrix(int row, int column):rows(row), columns(column)\n    {\n        this->values = new double[row * columns];\n        int k;\n        for(k = 0; k < row * column; ++k){\n            this->values[k] = 0;\n        }\n    }\n    \n    Matrix(int row, int column, double value[]): rows(row), columns(column)\n    {\n        this->values = new double[row * column];\n        int k;\n        for(k = 0; k < row * column; ++k){\n            this->values[k] = value[k];\n        }\n    }\n    \n    Matrix(const Matrix & matrix2){\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        if(values != 0){\n            delete [] values;\n        }\n        this->values = new double[matrix2.rows * matrix2.columns];\n        int k;\n        for(k = 0; k < matrix2.rows * matrix2.columns; ++k){\n            this->values[k] = matrix2.values[k];\n        }\n    }\n\n    ~Matrix()\n    {\n        delete [] this->values;\n    }\n\n    void print() const;    \n    Matrix & operator = (const Matrix & m);\n    Matrix operator + (const Matrix & matrix2) const;\n    Matrix operator + (double value) const;\n    Matrix operator - (const Matrix & matrix2) const;\n    Matrix operator - (double value) const;\n};\n\nvoid Matrix::print() const{\n    for(int i = 0; i < rows; ++i){\n        for(int j = 0; j < columns; ++j){\n            cout << \"    \" << values[i * columns + j];\n        }\n        cout << endl; \n    }\n}\n\nMatrix & Matrix::operator = (const Matrix & m){\n    this->rows = m.rows;\n    this->columns = m.columns;\n    if(values != 0){\n        delete [] values;\n    } \n\tthis->values = new double[m.rows * m.columns]; \n\tint k;\n    for(k = 0; k < m.rows * m.columns; ++k){\n        this->values[k] = m.values[k];\n    }\n    return *this;\n}\n\nMatrix Matrix::operator + (const Matrix & matrix2) const{\n    Matrix tmp(*this);\n\tfor(int i = 0; i < rows; ++i){\n        for(int j = 0; j < columns; ++j){\n            tmp.values[i * columns + j] += matrix2.values[i * columns + j];\n        }\n    }\n\n    return tmp;\n}\n\nMatrix Matrix::operator + (double value) const{\n    Matrix tmp(*this);\n\tfor(int i = 0; i < rows; ++i){\n        for(int j = 0; j < columns; ++j){\n            tmp.values[i * columns + j] += value;\n        }\n    }\n\n    return tmp;\n}\n\nMatrix Matrix::operator - (const Matrix & matrix2) const{\n    Matrix tmp(*this);\n\tfor(int i = 0; i < rows; ++i){\n        for(int j = 0; j < columns; ++j){\n            tmp.values[i * columns + j] -= matrix2.values[i * columns + j];\n        }\n    }\n\n    return tmp;\n}\n\nMatrix Matrix::operator - (double value) const{\n    Matrix tmp(*this);\n\tfor(int i = 0; i < rows; ++i){\n        for(int j = 0; j < columns; ++j){\n            tmp.values[i * columns + j] -= value;\n        }\n    }\n\n    return tmp;\n}",
            1590028729.3235502,
            100,
            "# 答案正确"
        ],
        [
            "6.1 (C++)",
            "覃浩南",
            "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\ntemplate <typename T>\nclass Matrix{\nprivate:\n\tint rows = 0;\n\tint columns = 0;\n\tvector<vector<T>> values;\n\tvoid Matrix_Copy(const Matrix & m){\n\t\trows = m.rows;\n\t\tcolumns = m.columns;\n\t\tfor (int i = 0; i < rows; ++i){\n\t\t\tvalues.push_back(vector<T>());\n\t\t\tfor (int j = 0; j < columns; ++j){\n\t\t\t\tvalues[i].push_back(m.values[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\npublic:\n\tMatrix(int r, int c) : rows(r), columns(c)\n\t{\n\t\tfor (int i = 0; i < rows; ++i){\n\t\t\tvalues.push_back(vector<T>());\n\t\t\tvalues[i].resize(columns);\n\t\t}\n\t}\n\n\tMatrix(int r, int c, const T * v) : rows(r), columns(c)\n\t{\n\t\tfor (int i = 0; i < rows; ++i){\n\t\t\tvalues.push_back(vector<T>());\n\t\t\tfor (int j = 0; j < columns; ++j){\n\t\t\t\tvalues[i].push_back(v[i * columns + j]);\n\t\t\t}\n\t\t}\n\t}\n\n    Matrix(int r, int c, const vector<T> & vec) : rows(r), columns(c)\n\t{\n\t\tfor (int i = 0; i < rows; ++i){\n\t\t\tvalues.push_back(vector<T>());\n\t\t\tfor (int j = 0; j < columns; ++j){\n\t\t\t\tvalues[i].push_back(vec[i*columns + j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tMatrix(const Matrix & m){\n\t\tMatrix_Copy(m);\n\t}\n\n\tMatrix & operator = (const Matrix & m){\n\t\tvalues.resize(m.rows);\n\t\tfor (int i = 0; i < m.rows; ++i){\n\t\t\tvalues[i].resize(m.columns);\n\t\t}\n        rows = m.rows;\n\t\tcolumns = m.columns;\n\n\t\tfor (int i = 0; i < rows; ++i){\n\t\t\tfor (int j = 0; j < columns; ++j){\n\t\t\t\tvalues[i][j] = m.values[i][j];\n\t\t\t}\n\t\t}\n\t\treturn *this;\n\t}\n\n\tT & get(int r, int c){\n\t\treturn values[r - 1][c - 1];\n\t}\n\n\tvoid print(){\n\t\tfor (int i = 0; i < rows; ++i){\n\t\t\tfor (int j = 0; j < columns; ++j){\n\t\t\t\tcout << \"    \" << values[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\n    Matrix getColumn(int k){\n        Matrix tmp(this->rows, 1);\n        for (int i = 0; i < this->rows; ++i){\n\t\t\ttmp.values[i][0] = this->values[i][k-1];\n\t\t}\n        return tmp;\n    }\n\n    Matrix getRow(int k){\n        Matrix tmp(1, this->columns);\n        for (int i = 0; i < this->columns; ++i){\n\t\t\ttmp.values[0][i] = this->values[k-1][i];\n\t\t}\n        return tmp;\n    }\n\n    Matrix concatenateRows(const Matrix & m){\n        Matrix tmp(this->rows + m.rows, this->columns);\n        for (int i = 0; i < this->rows; ++i){\n\t\t\tfor (int j = 0; j < tmp.columns; ++j){\n                tmp.values[i][j] = this->values[i][j];\n            }\n\t\t}\n\n        for (int i = this->rows; i < tmp.rows; ++i){\n\t\t\tfor (int j = 0; j < tmp.columns; ++j){\n                tmp.values[i][j] = m.values[i - this->rows][j];\n            }\n\t\t}\n        return tmp;\n    }\n\n    Matrix concatenateColumns(const Matrix & m){\n        Matrix tmp(this->rows, this->columns + m.columns);\n        for(int i = 0; i < tmp.rows; ++i){\n            for(int j = 0; j < tmp.columns; ++j){\n                if(j >= this->columns){\n                    tmp.values[i][j] = m.values[i][j-this->columns];\n                }\n                else{\n                    tmp.values[i][j] = this->values[i][j];\n                }\n            }\n        }\n        return tmp;\n    }\n\n    Matrix reshape(int r, int c){\n        int v[100]; int k = 0;\n        for(int j = 0; j < this->columns; ++j){\n            for(int i = 0; i < this->rows; ++i){\n                v[k++] = this->values[i][j];\n            }\n        }\n        \n        k = 0;\n        Matrix tmp(r, c);\n        for(int j = 0; j < tmp.columns; ++j){\n            for(int i = 0; i < tmp.rows; ++i){\n                tmp.values[i][j] = v[k++];    \n            }\n        }\n        return tmp;\n    }\n\n    Matrix transpose(){\n        Matrix tmp(this->columns, this->rows);\n        for(int i = 0; i < tmp.rows; ++i){\n            for(int j = 0; j < tmp.columns; ++j){\n                tmp.values[i][j] = this->values[j][i];   \n            }\n        }\n        return tmp;\n    }\n\n    Matrix operator + (const Matrix & m){\n        Matrix tmp(this->rows, this->columns);\n        for(int i = 0; i < tmp.rows; ++i){\n            for(int j = 0; j < tmp.columns; ++j){\n                tmp.values[i][j] = this->values[i][j] + m.values[i][j];\n            }\n        }\n        return tmp;\n    }\n\n     Matrix operator + (int n){\n        Matrix tmp(this->rows, this->columns);\n        for(int i = 0; i < tmp.rows; ++i){\n            for(int j = 0; j < tmp.columns; ++j){\n                tmp.values[i][j] = this->values[i][j] + n;\n            }\n        }\n        return tmp;\n    }\n\n    Matrix operator - (const Matrix & m){\n        Matrix tmp(this->rows, this->columns);\n        for(int i = 0; i < tmp.rows; ++i){\n            for(int j = 0; j < tmp.columns; ++j){\n                tmp.values[i][j] = this->values[i][j] - m.values[i][j];\n            }\n        }\n        return tmp;\n    }\n\n    Matrix operator - (int n){\n        Matrix tmp(this->rows, this->columns);\n        for(int i = 0; i < tmp.rows; ++i){\n            for(int j = 0; j < tmp.columns; ++j){\n                tmp.values[i][j] = this->values[i][j] - n;\n            }\n        }\n        return tmp;\n    }\n\n    Matrix operator * (const Matrix & m){\n        Matrix tmp(this->rows, m.columns);\n        for(int i = 0; i < tmp.rows; ++i){\n            for(int j = 0; j < tmp.columns; ++j){\n                for(int k = 0; k < this->columns; ++k){\n                    tmp.values[i][j] += this->values[i][k] * m.values[k][j];\n                }\n            }\n        }\n        return tmp;\n    }\n\n    Matrix operator * (int n){\n        Matrix tmp(this->rows, this->columns);\n        for(int i = 0; i < tmp.rows; ++i){\n            for(int j = 0; j < tmp.columns; ++j){\n                tmp.values[i][j] = this->values[i][j] * n;\n                \n            }\n        }\n        return tmp;\n    }\n\n    Matrix max() const{\n        if(this->rows > 1){\n            Matrix tmp(1, this->columns);\n            int i, j; int k = 0; \n            for(i = 0; i < this->columns; ++i){\n                int max = -1;\n                for(j = 0; j < this->rows; ++j){\n                    if(this->values[j][i] > max){\n                        max = values[j][i];\n                    }\n                }\n                tmp.values[0][k++] = max;\n            }\n            return tmp;\n        }\n        else{\n            Matrix tmp(1,1); int max = -1;\n            for(int k = 0; k < this->columns; ++k){\n                if(this->values[0][k] > max){\n                    max = this->values[0][k];\n                }\n            }\n\n            tmp.values[0][0] = max;\n            return tmp;\n        }\n    }\n\n    Matrix min() const{\n        if(this->rows > 1){\n            Matrix tmp(1, this->columns);\n            int i, j; int k = 0;\n            for(i = 0; i < this->columns; ++i){\n                int min = 0x7fffffff;\n                for(j = 0; j < this->rows; ++j){\n                    if(this->values[j][i] < min){\n                        min = values[j][i];\n                    }\n                }\n                tmp.values[0][k++] = min;\n            }\n\n            return tmp;\n        }\n        else{\n            Matrix tmp(1,1); int min = 0x7fffffff;\n            for(int k = 0; k < this->columns; ++k){\n                if(this->values[0][k] < min){\n                    min = this->values[0][k];\n                }\n            }\n            tmp.values[0][0] = min;\n            return tmp;\n        }\n    }\n\n    Matrix sum() const{\n        if(this->rows > 1){\n            Matrix tmp(1, this->columns);\n            int i, j, k;\n\n            for(i = 0; i < this->columns; ++i){\n                for(j = 0; j < this->rows; ++j){\n                    tmp.values[0][k] += this->values[j][i];\n                }\n                ++k;\n            }\n\n            return tmp;\n        }\n        else{\n            Matrix tmp(1, 1); int sum = 0;\n            for(int i = 0; i < this->columns; ++i){\n                sum += this->values[0][i];\n            }\n\n            tmp.values[0][0] = sum;\n            return tmp;\n        }\n    }\n};",
            1590218904.761621,
            100,
            "# 答案正确"
        ],
        [
            "6.3 (C++)",
            "覃浩南",
            "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\ntemplate <typename T>\nclass Matrix{\nprivate:\n\tint rows = 0;\n\tint columns = 0;\n\tvector<vector<T>> values;\n\tvoid Matrix_Copy(const Matrix & m){\n\t\trows = m.rows;\n\t\tcolumns = m.columns;\n\t\tfor (int i = 0; i < rows; ++i){\n\t\t\tvalues.push_back(vector<T>());\n\t\t\tfor (int j = 0; j < columns; ++j){\n\t\t\t\tvalues[i].push_back(m.values[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\npublic:\n\tMatrix(int r, int c) : rows(r), columns(c)\n\t{\n\t\tfor (int i = 0; i < rows; ++i){\n\t\t\tvalues.push_back(vector<T>());\n\t\t\tvalues[i].resize(columns);\n\t\t}\n\t}\n\n\tMatrix(int r, int c, const T * v) : rows(r), columns(c)\n\t{\n\t\tfor (int i = 0; i < rows; ++i){\n\t\t\tvalues.push_back(vector<T>());\n\t\t\tfor (int j = 0; j < columns; ++j){\n\t\t\t\tvalues[i].push_back(v[i * columns + j]);\n\t\t\t}\n\t\t}\n\t}\n\n    Matrix(int r, int c, const vector<T> & vec) : rows(r), columns(c)\n\t{\n\t\tfor (int i = 0; i < rows; ++i){\n\t\t\tvalues.push_back(vector<T>());\n\t\t\tfor (int j = 0; j < columns; ++j){\n\t\t\t\tvalues[i].push_back(vec[i*columns + j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tMatrix(const Matrix & m){\n\t\tMatrix_Copy(m);\n\t}\n\n\tMatrix & operator = (const Matrix & m){\n\t\tvalues.resize(m.rows);\n\t\tfor (int i = 0; i < m.rows; ++i){\n\t\t\tvalues[i].resize(m.columns);\n\t\t}\n        rows = m.rows;\n\t\tcolumns = m.columns;\n\n\t\tfor (int i = 0; i < rows; ++i){\n\t\t\tfor (int j = 0; j < columns; ++j){\n\t\t\t\tvalues[i][j] = m.values[i][j];\n\t\t\t}\n\t\t}\n\t\treturn *this;\n\t}\n\n\tT & get(int r, int c){\n\t\treturn values[r - 1][c - 1];\n\t}\n\n\tvoid print(){\n\t\tfor (int i = 0; i < rows; ++i){\n\t\t\tfor (int j = 0; j < columns; ++j){\n\t\t\t\tcout << \"    \" << values[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\n    Matrix getColumn(int k){\n        Matrix tmp(this->rows, 1);\n        for (int i = 0; i < this->rows; ++i){\n\t\t\ttmp.values[i][0] = this->values[i][k-1];\n\t\t}\n        return tmp;\n    }\n\n    Matrix getRow(int k){\n        Matrix tmp(1, this->columns);\n        for (int i = 0; i < this->columns; ++i){\n\t\t\ttmp.values[0][i] = this->values[k-1][i];\n\t\t}\n        return tmp;\n    }\n\n    Matrix concatenateRows(const Matrix & m){\n        Matrix tmp(this->rows + m.rows, this->columns);\n        for (int i = 0; i < this->rows; ++i){\n\t\t\tfor (int j = 0; j < tmp.columns; ++j){\n                tmp.values[i][j] = this->values[i][j];\n            }\n\t\t}\n\n        for (int i = this->rows; i < tmp.rows; ++i){\n\t\t\tfor (int j = 0; j < tmp.columns; ++j){\n                tmp.values[i][j] = m.values[i - this->rows][j];\n            }\n\t\t}\n        return tmp;\n    }\n\n    Matrix concatenateColumns(const Matrix & m){\n        Matrix tmp(this->rows, this->columns + m.columns);\n        for(int i = 0; i < tmp.rows; ++i){\n            for(int j = 0; j < tmp.columns; ++j){\n                if(j >= this->columns){\n                    tmp.values[i][j] = m.values[i][j-this->columns];\n                }\n                else{\n                    tmp.values[i][j] = this->values[i][j];\n                }\n            }\n        }\n        return tmp;\n    }\n\n    Matrix reshape(int r, int c){\n        int v[100]; int k = 0;\n        for(int j = 0; j < this->columns; ++j){\n            for(int i = 0; i < this->rows; ++i){\n                v[k++] = this->values[i][j];\n            }\n        }\n        \n        k = 0;\n        Matrix tmp(r, c);\n        for(int j = 0; j < tmp.columns; ++j){\n            for(int i = 0; i < tmp.rows; ++i){\n                tmp.values[i][j] = v[k++];    \n            }\n        }\n        return tmp;\n    }\n\n    Matrix transpose(){\n        Matrix tmp(this->columns, this->rows);\n        for(int i = 0; i < tmp.rows; ++i){\n            for(int j = 0; j < tmp.columns; ++j){\n                tmp.values[i][j] = this->values[j][i];   \n            }\n        }\n        return tmp;\n    }\n\n    Matrix operator + (const Matrix & m){\n        Matrix tmp(this->rows, this->columns);\n        for(int i = 0; i < tmp.rows; ++i){\n            for(int j = 0; j < tmp.columns; ++j){\n                tmp.values[i][j] = this->values[i][j] + m.values[i][j];\n            }\n        }\n        return tmp;\n    }\n\n     Matrix operator + (int n){\n        Matrix tmp(this->rows, this->columns);\n        for(int i = 0; i < tmp.rows; ++i){\n            for(int j = 0; j < tmp.columns; ++j){\n                tmp.values[i][j] = this->values[i][j] + n;\n            }\n        }\n        return tmp;\n    }\n\n    Matrix operator - (const Matrix & m){\n        Matrix tmp(this->rows, this->columns);\n        for(int i = 0; i < tmp.rows; ++i){\n            for(int j = 0; j < tmp.columns; ++j){\n                tmp.values[i][j] = this->values[i][j] - m.values[i][j];\n            }\n        }\n        return tmp;\n    }\n\n    Matrix operator - (int n){\n        Matrix tmp(this->rows, this->columns);\n        for(int i = 0; i < tmp.rows; ++i){\n            for(int j = 0; j < tmp.columns; ++j){\n                tmp.values[i][j] = this->values[i][j] - n;\n            }\n        }\n        return tmp;\n    }\n\n    Matrix operator * (const Matrix & m){\n        Matrix tmp(this->rows, m.columns);\n        for(int i = 0; i < tmp.rows; ++i){\n            for(int j = 0; j < tmp.columns; ++j){\n                for(int k = 0; k < this->columns; ++k){\n                    tmp.values[i][j] += this->values[i][k] * m.values[k][j];\n                }\n            }\n        }\n        return tmp;\n    }\n\n    Matrix operator * (int n){\n        Matrix tmp(this->rows, this->columns);\n        for(int i = 0; i < tmp.rows; ++i){\n            for(int j = 0; j < tmp.columns; ++j){\n                tmp.values[i][j] = this->values[i][j] * n;\n                \n            }\n        }\n        return tmp;\n    }\n\n    Matrix max() const{\n        if(this->rows > 1){\n            Matrix tmp(1, this->columns);\n            int i, j; int k = 0; \n            for(i = 0; i < this->columns; ++i){\n                int max = -1;\n                for(j = 0; j < this->rows; ++j){\n                    if(this->values[j][i] > max){\n                        max = values[j][i];\n                    }\n                }\n                tmp.values[0][k++] = max;\n            }\n            return tmp;\n        }\n        else{\n            Matrix tmp(1,1); int max = -1;\n            for(int k = 0; k < this->columns; ++k){\n                if(this->values[0][k] > max){\n                    max = this->values[0][k];\n                }\n            }\n\n            tmp.values[0][0] = max;\n            return tmp;\n        }\n    }\n\n    Matrix min() const{\n        if(this->rows > 1){\n            Matrix tmp(1, this->columns);\n            int i, j; int k = 0;\n            for(i = 0; i < this->columns; ++i){\n                int min = 0x7fffffff;\n                for(j = 0; j < this->rows; ++j){\n                    if(this->values[j][i] < min){\n                        min = values[j][i];\n                    }\n                }\n                tmp.values[0][k++] = min;\n            }\n\n            return tmp;\n        }\n        else{\n            Matrix tmp(1,1); int min = 0x7fffffff;\n            for(int k = 0; k < this->columns; ++k){\n                if(this->values[0][k] < min){\n                    min = this->values[0][k];\n                }\n            }\n            tmp.values[0][0] = min;\n            return tmp;\n        }\n    }\n\n    Matrix sum() const{\n        if(this->rows > 1){\n            Matrix tmp(1, this->columns);\n            int i, j, k;\n\n            for(i = 0; i < this->columns; ++i){\n                for(j = 0; j < this->rows; ++j){\n                    tmp.values[0][k] += this->values[j][i];\n                }\n                ++k;\n            }\n\n            return tmp;\n        }\n        else{\n            Matrix tmp(1, 1); int sum = 0;\n            for(int i = 0; i < this->columns; ++i){\n                sum += this->values[0][i];\n            }\n\n            tmp.values[0][0] = sum;\n            return tmp;\n        }\n    }\n};",
            1590218885.9124088,
            100,
            "# 答案正确"
        ],
        [
            "6.2 (C++)",
            "覃浩南",
            "#include <iostream>\nusing namespace std;\n\ntemplate <typename T>\nclass Matrix{\nprivate:\n    int rows;\n    int columns;\n    T * values;\npublic:\n    Matrix(int r, int c): rows(r), columns(c){\n        values = new T[rows * columns];\n        for(int i = 0; i != rows * columns; ++i){\n            values[i] = 0;\n        }\n    }\n\n    ~Matrix(){\n        delete [] values;\n    }\n\n    void print() const{\n        for(int i = 0; i != rows; ++i){\n            for(int j = 0; j != columns; ++j){\n                cout << \"    \" << values[i];\n            }\n            cout << endl;\n        }\n    }\n};",
            1590632735.8806162,
            100,
            "# 答案正确"
        ],
        [
            "7.1 (C++)",
            "覃浩南",
            "#include <cmath>\n\nclass Triangle : public GeometricObject\n{\nprivate:\n    double side1 = 1.0;\n    double side2 = 1.0;\n    double side3 = 1.0;\npublic:\n    Triangle(): side1(1.0), side2(1.0), side3(1.0) {}\n    Triangle(double a, double b, double c): side1(a), side2(b), side3(c) {}\n    \n    double getSide1() const{\n        return side1;\n    }\n\n    double getSide2() const{\n        return side2;\n    }\n\n    double getSide3() const{\n        return side3;\n    }\n\n    double getArea() const{\n        double s = (side1 + side2 + side3) / 2;\n        return ::sqrt(s * (s - side1) * (s - side2) * (s - side3));\n    }\n\n    double getPerimeter() const{\n        return side1 + side2 + side3;\n    }\n};",
            1590722457.340568,
            100,
            "# 答案正确"
        ],
        [
            "7.3 (C++)",
            "覃浩南",
            "template <typename A>\nvector<A> map2(const vector<A> & x, const vector<A> & y, A(*map2_func)(const A &, const A &)){\n    vector<A> res;\n    for(int i = 0; i < x.size(); ++ i){\n        res.push_back(map2_func(x[i], y[i]));\n    }\n    return res;\n}\n\ntemplate <typename A>\nvector<A> map2(const vector<A> & x, int y, A(*map2_func)(const A &, const A &)){\n    vector<A> res;\n    for(int i = 0; i < x.size(); ++ i){\n        res.push_back(map2_func(x[i], y));\n    }\n    return res;\n}\n",
            1590753183.198188,
            100,
            "# 答案正确"
        ],
        [
            "7.2 (C++)",
            "覃浩南",
            "#include<string>\n#include<vector>\nusing namespace std;\n\nvector<string> split(const string& str){\n    vector<string> res; int end, start;\n    for(start = 0; start != str.size();){\n        end = str.find(' ', start);\n        if(end == start){\n            ++start;\n        }\n        else if(end == -1){\n            res.push_back(str.substr(start));\n            break;\n        }\n        else{\n            res.push_back(str.substr(start, end - start));\n            start = end + 1;\n        }\n    }\n\n    return res;\n}",
            1591238132.7283747,
            100,
            "# 答案正确"
        ],
        [
            "8.1 (C++)",
            "覃浩南",
            "#include <vector>\nclass Full :public Matrix\n{\nprivate:\n    int row;\n    int column;\n    vector<vector<double>> space;\npublic:\n    Full(int rows, int columns){\n        row = rows; column = columns;\n        for(int i = 0; i != row; ++ i){\n            space.push_back(vector<double>());\n            for(int j = 0; j != column; ++ j){\n                space[i].push_back(0);\n            }\n        }\n    }\n    Full(int rows, int columns, double values[]){\n        row = rows; column = columns;\n        for(int i = 0; i != row; ++ i){\n            space.push_back(vector<double>());\n            for(int j = 0; j != column; ++ j){\n                space[i].push_back(values[i * column + j]);\n            }\n        }\n    }\n    Full(const Matrix& matrix2){\n        row = dynamic_cast <const Full&> (matrix2).row; column = dynamic_cast <const Full&> (matrix2).column;\n        for(int i = 0; i != row; ++ i){\n            space.push_back(vector<double>());\n            for(int j = 0; j != column; ++ j){\n                space[i].push_back(dynamic_cast <const Full&> (matrix2).space[i][j]);\n            }\n        }\n    }\n    ~Full(){}\n\n    int size(int dimension) const{\n        return row * column;\n    }\n\n    void set(int row, int column, double value){\n        space[row - 1][column - 1] = value;\n    }\n\n    double get(int row, int column) const{\n        return space[row - 1][column - 1];\n    }\n\n    void print() const{\n        for(int i = 0; i != row; ++ i){\n            for(int j = 0; j != column; ++ j){\n                cout << \"    \" << space[i][j];\n            }\n            cout << endl;\n        }\n    }\n\n    Matrix & operator = (const Matrix & matrix2){\n        row = dynamic_cast <const Full&> (matrix2).row; column = dynamic_cast <const Full&> (matrix2).column;\n        space.resize(row);\n        for(int i = 0; i != row; ++ i){\n            space[i].resize(column);\n        }\n\n        for(int i = 0; i != row; ++ i){\n            for(int j = 0; j != column; ++ j){\n                space[i][j] = dynamic_cast <const Full&> (matrix2).space[i][j];\n            }\n        }\n\n        return *this;\n    }\n};",
            1591329353.8932884,
            100,
            "# 答案正确"
        ],
        [
            "8.3 (C++)",
            "覃浩南",
            "#include <iostream>\n#include <vector>\nusing namespace std;\nclass Sparse :public Matrix\n{\nprivate:\n    vector<Entry> information;\n    int total_row;\n    int total_column;\npublic:\n    Sparse(int rows, int columns) : total_row(rows), total_column(columns){}\n    int size(int dimension) const{\n        return total_row * total_column;\n    }\n\n    void set(int row, int column, double value){\n        Entry tmp; tmp.column = column; tmp.row = row; tmp.value = value;\n        information.push_back(tmp);\n\t\tint i, j;\n\t\tfor(i = 0; i != information.size() - 1; ++ i){\n\t\t\tint key = i;\n\t\t\tfor(j = i + 1; j != information.size(); ++ j){\n\t\t\t\tif(information[j].row < information[key].row){\n\t\t\t\t\tkey = j;\n\t\t\t\t}\n\t\t\t\telse if(information[j].row == information[key].row){\n\t\t\t\t\tif(information[j].column < information[key].column){\n\t\t\t\t\t\tkey = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(key != j){\n\t\t\t\tEntry tmp = information[i];\n\t\t\t\tinformation[i] = information[key];\n\t\t\t\tinformation[key] = tmp;\n\t\t\t}\n\t\t}\n    }\n\n    double get(int row, int column) const{\n        for(int i = 0; i != information.size(); ++ i){\n\t\t\tif(row == information[i].row && column == information[i].column){\n\t\t\t\treturn information[i].value;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n    }\n\n\tvoid print(){\n\t\tfor(auto i : information){\n\t\t\tcout << \"(\" << i.row << \",\" \n\t\t\t<< i.column << \",\" << i.value << \")\" << endl;\n\t\t}\n\t}\n\n\tSparse operator + (const Sparse & sp){\n\t\tSparse tmp(this->total_row, this->total_column);\n\t\tfor(int i = 0; i != information.size(); ++ i){\n\t\t\tif(information[i].row == sp.information[i].row && information[i].column == sp.information[i].column){\n\t\t\t\tEntry n;\n\t\t\t\tn.value = this->information[i].value + sp.information[i].value;\n\t\t\t\tif(n.value == 0) continue;\n\t\t\t\tn.row = this->information[i].row;\n\t\t\t\tn.column = this->information[i].column;\n\t\t\t\ttmp.information.push_back(n);\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttmp.information.push_back(information[i]);\n\t\t\t\ttmp.information.push_back(sp.information[i]);\n\t\t\t}\n\t\t}\n\n\t\tint i, j;\n\t\tfor(i = 0; i != tmp.information.size() - 1; ++ i){\n\t\t\tint key = i;\n\t\t\tfor(j = i + 1; j != tmp.information.size(); ++ j){\n\t\t\t\tif(tmp.information[j].row < tmp.information[key].row){\n\t\t\t\t\tkey = j;\n\t\t\t\t}\n\t\t\t\telse if(tmp.information[j].row == tmp.information[key].row){\n\t\t\t\t\tif(tmp.information[j].column < tmp.information[key].column){\n\t\t\t\t\t\tkey = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(key != j){\n\t\t\t\tEntry t = tmp.information[i];\n\t\t\t\ttmp.information[i] = tmp.information[key];\n\t\t\t\ttmp.information[key] = t;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn tmp;\n\n\t}\n\n\tSparse & operator = (const Sparse & sp){\n\t\tthis->total_row = sp.total_row; \n\t\tthis->total_column = sp.total_column;\n\t\tthis->information = sp.information;\n\t\treturn *this;\n\t}\n};",
            1591411874.6500537,
            100,
            "# 答案正确"
        ],
        [
            "8.4 (C++)",
            "覃浩南",
            "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Sparse :public Matrix\n{\nprivate:\n    vector<Entry> information;\n    int total_row;\n    int total_column;\npublic:\n    Sparse(int rows, int columns) : total_row(rows), total_column(columns){}\n    int size(int dimension) const{\n        return total_row * total_column;\n    }\n\n    void set(int row, int column, double value){\n        Entry tmp; tmp.column = column; tmp.row = row; tmp.value = value;\n        information.push_back(tmp);\n\t\tint i, j;\n\t\tfor(i = 0; i != information.size() - 1; ++ i){\n\t\t\tint key = i;\n\t\t\tfor(j = i + 1; j != information.size(); ++ j){\n\t\t\t\tif(information[j].row < information[key].row){\n\t\t\t\t\tkey = j;\n\t\t\t\t}\n\t\t\t\telse if(information[j].row == information[key].row){\n\t\t\t\t\tif(information[j].column < information[key].column){\n\t\t\t\t\t\tkey = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(key != j){\n\t\t\t\tEntry tmp = information[i];\n\t\t\t\tinformation[i] = information[key];\n\t\t\t\tinformation[key] = tmp;\n\t\t\t}\n\t\t}\n    }\n\n    double get(int row, int column) const{\n        for(int i = 0; i != information.size(); ++ i){\n\t\t\tif(row == information[i].row && column == information[i].column){\n\t\t\t\treturn information[i].value;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n    }\n\n\tvoid print(){\n\t\tfor(auto i : information){\n\t\t\tcout << \"(\" << i.row << \",\" \n\t\t\t<< i.column << \",\" << i.value << \")\" << endl;\n\t\t}\n\t}\n\n\tSparse & operator = (const Sparse & sp){\n\t\tthis->total_row = sp.total_row; \n\t\tthis->total_column = sp.total_column;\n\t\tthis->information = sp.information;\n\t\treturn *this;\n\t}\n\n    Sparse operator * (const Sparse & sp){\n\t\tvoid sort_Sparse(vector<Entry> &a);\n        \n        Sparse tmp(this->total_row, sp.total_column);\n\t\tvector<Entry> save1;\n\t\tfor(int i = 0; i != information.size(); ++ i){\n\t\t\tfor(int j = 0; j != sp.information.size(); ++ j){\n\t\t\t\tif(information[i].column == sp.information[j].row){\n\t\t\t\t\tEntry k; k.row = information[i].row; k.column = sp.information[j].column;\n\t\t\t\t\tk.value = information[i].value * sp.information[j].value;\n                    save1.push_back(k);\n                }\n\t\t\t}\n\t\t}\n\t\t\n\t\tsort_Sparse(save1);\n\t\tfor(int i = 0; i != save1.size(); ++ i){\n\t\t\tif(i == 0) tmp.information.push_back(save1[i]);\n\t\t\telse{\n\t\t\t\tif(save1[i].row == tmp.information[i - 1].row\n\t\t\t\t&& save1[i].column == tmp.information[i - 1].column)\n\t\t\t\ttmp.information[i - 1].value += save1[i].value;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttmp.information.push_back(save1[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsort_Sparse(tmp.information);\n\t\treturn tmp;\n\t}\n};\n\n\nvoid sort_Sparse(vector<Entry> &a){\n\tint i, j;\n\tfor(i = 0; i < a.size() - 1; ++ i){\n\t\tint key = i;\n\t\tfor(j = i + 1; j < a.size(); ++ j){\n\t\t\tif(a[j].row < a[key].row){\n\t\t\t\tkey = j;\n\t\t\t}\n\t\t\telse if(a[j].row == a[key].row){\n\t\t\t\tif(a[j].column < a[key].column){\n\t\t\t\t\tkey = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(key != j){\n\t\t\tEntry t = a[i];\n\t\t\ta[i] = a[key];\n\t\t\ta[key] = t;\n\t\t}\n\t}\n}",
            1591491016.8895862,
            100,
            "# 答案正确"
        ],
        [
            "8.5 (C++)",
            "覃浩南",
            "class Point3D : public Point2D{\nprivate:\n    double z;\npublic:\n    Point3D() : z(0){}\n    Point3D(double x1, double y1, double z1) : z(z1){setX(x1); setY(y1);}\n\n    double getZ(){return z;}\n\n    double distance(Point2D & point2) {\n\t\t\n        double x1 = getX(); double x2 = point2.getX();\n        double y1 = getY(); double y2 = point2.getY();\n        double z1 = z; double z2 = dynamic_cast<Point3D &>(point2).getZ();\n        double dx = x1 - x2;\n\t\tdouble dy = y1 - y2;\n        double dz = z1 - z2;\n\t\treturn sqrt(dx * dx + dy * dy + dz * dz);\n\t}\n};",
            1591844695.9213216,
            100,
            "# 答案正确"
        ],
        [
            "8.6 (C++)",
            "覃浩南",
            "#include <iostream>\nclass MyTensor: public Tensor<double>\n{\nprivate:\n    double * save;\npublic:\n    MyTensor(vector<int> v) :Tensor(v) \n    {\n        int numel = 1;\n        for(auto i: v){numel *= i;}\n        save = new double[numel];\n    }\n\n\t~MyTensor(){\n\t\tdelete [] save;\n\t}\n\n    double & get(const vector<int> & indexes){\n        int index = 0;\n        for(int i = 0; i != indexes.size(); ++ i)\n\t\t{\n\t\t\tif(i > 0){\n\t\t\t\tindex += indexes[i] * sizes[i - 1];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tindex += indexes[i];\n\t\t\t}\n\t\t}\n        return save[index];\n    }\n};\n",
            1592449465.892025,
            100,
            "# 答案正确"
        ],
        [
            "9.1 (C++)",
            "覃浩南",
            "class Circle {\nprivate:\n    double radii;\npublic:\n    Circle(double r): radii(r){}\n    \n    bool operator < (Circle c){\n        if(radii < c.radii)\n            return true;\n        else\n            return false;\n    }\n\n    bool operator <= (Circle c){\n        if(radii <= c.radii)\n            return true;\n        else\n            return false;\n    }\n\n    bool operator == (Circle c){\n        if(radii == c.radii)\n            return true;\n        else\n            return false;\n    }\n\n    bool operator != (Circle c){\n        if(radii != c.radii)\n            return true;\n        else\n            return false;\n    }\n\n    bool operator > (Circle c){\n        if(radii > c.radii)\n            return true;\n        else\n            return false;\n    }\n\n    bool operator >= (Circle c){\n        if(radii >= c.radii)\n            return true;\n        else\n            return false;\n    }\n\n\n};",
            1592634645.9543233,
            100,
            "# 答案正确"
        ],
        [
            "9.2 (C++)",
            "覃浩南",
            "class I: public vector<int>\n{\npublic:\n    I(int i1 = 1, int i2 = -1, int i3 = -1, int i4 = -1){\n\t\tthis->push_back(i1);\n\t\tif (i2 != -1) this->push_back(i2);\n\t\tif (i3 != -1) this->push_back(i3);\n\t\tif (i4 != -1) this->push_back(i4);\n    }\n};",
            1592640500.018133,
            100,
            "# 答案正确"
        ],
        [
            "9.3 (C++)",
            "覃浩南",
            "class Complex{\nprivate:\n    double r; double i;\npublic:\n    Complex(int x = 0, int y = 0): r(x), i(y){}\n    double & real(){\n        return r;\n    }\n    double & imag(){\n        return i;\n    }\n\n    Complex &operator += (Complex x){\n        this->real() += x.real();\n        this->imag() += x.imag();\n        return *this;\n    }\n\n    Complex &operator -= (Complex x){\n        this->real() -= x.real();\n        this->imag() -= x.imag();\n        return *this;\n    }\n\n    Complex &operator *= (Complex x){\n        int a = this->real(); int b = this->imag();\n        this->real() = a * x.real() - b * x.imag();\n        this->imag() = a * x.imag() + b * x.real();\n        return *this;\n    }\n\n    Complex &operator /= (Complex x){\n         double a = this->real(), b = this->imag(), c = x.real(), d = x.imag();\n        this->real() = (a*c + b*d) / (c*c + d*d);\n        this->imag() = (b*c - a*d) / (c*c + d*d);\n        return *this;\n    }\n\n    bool operator == (Complex x){\n        if(this->i == x.i && this->r == x.r)\n            return true;\n        else\n            return false;\n    }\n\n    bool operator != (Complex x){\n        if(this->i != x.i && this->r != x.r)\n            return true;\n        else\n            return false;\n    }\n};\n\nComplex operator + (Complex a, Complex b){\n    Complex res;\n    res.real() = a.real() + b.real();\n    res.imag() = a.imag() + b.imag();\n    return res;\n}\n\nComplex operator - (Complex a, Complex b){\n    Complex res;\n    res.real() = a.real() - b.real();\n    res.imag() = a.imag() - b.imag();\n    return res;\n}\n\nComplex operator * (Complex a, Complex b){\n    Complex res;\n    res.real() = a.real() * b.real() - a.imag() * b.imag();\n    res.imag() = a.real() * b.imag() + a.imag() * b.real();\n    return res;\n}\n\nComplex operator / (Complex x, Complex y){\n    Complex res;\n    double a = x.real(), b = x.imag(), c = y.real(), d = y.imag();\n    res.real() = (a*c + b*d) / (c*c + d*d);\n    res.imag() = (b*c - a*d) / (c*c + d*d);\n    return res;\n}",
            1592643728.0127141,
            100,
            "# 答案正确"
        ],
        [
            "9.4 (C++)",
            "覃浩南",
            "class Complex{\nprivate:\n    double r; double i;\npublic:\n    Complex(int x = 0, int y = 0): r(x), i(y){}\n    double & real(){\n        return r;\n    }\n    double & imag(){\n        return i;\n    }\n\n    Complex &operator += (Complex x){\n        this->real() += x.real();\n        this->imag() += x.imag();\n        return *this;\n    }\n\n    Complex &operator -= (Complex x){\n        this->real() -= x.real();\n        this->imag() -= x.imag();\n        return *this;\n    }\n\n    Complex &operator *= (Complex x){\n        int a = this->real(); int b = this->imag();\n        this->real() = a * x.real() - b * x.imag();\n        this->imag() = a * x.imag() + b * x.real();\n        return *this;\n    }\n\n    Complex &operator /= (Complex x){\n         double a = this->real(), b = this->imag(), c = x.real(), d = x.imag();\n        this->real() = (a*c + b*d) / (c*c + d*d);\n        this->imag() = (b*c - a*d) / (c*c + d*d);\n        return *this;\n    }\n\n    bool operator == (Complex x){\n        if(this->i == x.i && this->r == x.r)\n            return true;\n        else\n            return false;\n    }\n\n    bool operator != (Complex x){\n        if(this->i != x.i && this->r != x.r)\n            return true;\n        else\n            return false;\n    }\n};\n\nComplex operator + (Complex a, Complex b){\n    Complex res;\n    res.real() = a.real() + b.real();\n    res.imag() = a.imag() + b.imag();\n    return res;\n}\n\nComplex operator - (Complex a, Complex b){\n    Complex res;\n    res.real() = a.real() - b.real();\n    res.imag() = a.imag() - b.imag();\n    return res;\n}\n\nComplex operator * (Complex a, Complex b){\n    Complex res;\n    res.real() = a.real() * b.real() - a.imag() * b.imag();\n    res.imag() = a.real() * b.imag() + a.imag() * b.real();\n    return res;\n}\n\nComplex operator / (Complex x, Complex y){\n    Complex res;\n    double a = x.real(), b = x.imag(), c = y.real(), d = y.imag();\n    res.real() = (a*c + b*d) / (c*c + d*d);\n    res.imag() = (b*c - a*d) / (c*c + d*d);\n    return res;\n}\n\nostream & operator << (ostream & out, Complex & x){\n    out << x.real() << \" \" << \"+\" << \" \" << x.imag() << \" i\" ;\n    return out;\n}\n\nistream & operator >> (istream & in, Complex & x){\n    in >> x.real() >> x.imag();\n    return in;\n}",
            1592644109.4620726,
            100,
            "# 答案正确"
        ],
        [
            "9.5 (C++)",
            "覃浩南",
            "class Complex{\nprivate:\n    double r; double i;\npublic:\n    Complex(int x = 0, int y = 0): r(x), i(y){}\n    double & real(){\n        return r;\n    }\n    double & imag(){\n        return i;\n    }\n\n    Complex &operator += (Complex x){\n        this->real() += x.real();\n        this->imag() += x.imag();\n        return *this;\n    }\n\n    Complex &operator -= (Complex x){\n        this->real() -= x.real();\n        this->imag() -= x.imag();\n        return *this;\n    }\n\n    Complex &operator *= (Complex x){\n        int a = this->real(); int b = this->imag();\n        this->real() = a * x.real() - b * x.imag();\n        this->imag() = a * x.imag() + b * x.real();\n        return *this;\n    }\n\n    Complex &operator /= (Complex x){\n         double a = this->real(), b = this->imag(), c = x.real(), d = x.imag();\n        this->real() = (a*c + b*d) / (c*c + d*d);\n        this->imag() = (b*c - a*d) / (c*c + d*d);\n        return *this;\n    }\n\n    bool operator == (Complex x){\n        if(this->i == x.i && this->r == x.r)\n            return true;\n        else\n            return false;\n    }\n\n    bool operator != (Complex x){\n        if(this->i != x.i && this->r != x.r)\n            return true;\n        else\n            return false;\n    }\n\n    Complex & operator++ (){\n        ++this->r;\n        return *this;\n    }\n\n    Complex operator++ (int){\n        Complex tmp;\n        tmp.r = this->r;\n        tmp.i = this->i;\n        ++this->r;\n        return tmp;\n    }\n\n    operator double() const{\n        return this->r;\n    }\n};\n\nComplex operator + (Complex a, Complex b){\n    Complex res;\n    res.real() = a.real() + b.real();\n    res.imag() = a.imag() + b.imag();\n    return res;\n}\n\nComplex operator - (Complex a, Complex b){\n    Complex res;\n    res.real() = a.real() - b.real();\n    res.imag() = a.imag() - b.imag();\n    return res;\n}\n\nComplex operator * (Complex a, Complex b){\n    Complex res;\n    res.real() = a.real() * b.real() - a.imag() * b.imag();\n    res.imag() = a.real() * b.imag() + a.imag() * b.real();\n    return res;\n}\n\nComplex operator / (Complex x, Complex y){\n    Complex res;\n    double a = x.real(), b = x.imag(), c = y.real(), d = y.imag();\n    res.real() = (a*c + b*d) / (c*c + d*d);\n    res.imag() = (b*c - a*d) / (c*c + d*d);\n    return res;\n}\n\nostream & operator << (ostream & out, Complex x){\n    out << x.real() << \" \" << \"+\" << \" \" << x.imag() << \" i\" ;\n    return out;\n}\n\nistream & operator >> (istream & in, Complex & x){\n    in >> x.real() >> x.imag();\n    return in;\n}",
            1592723144.4539843,
            100,
            "# 答案正确"
        ],
        [
            "9.6 (C++)",
            "覃浩南",
            "class Tensor{\nprivate:\n\tint a, b, c, d, size;\n\tvector<double> save;\npublic:\n\tTensor(int x = 0, int y = 0, int z = 0, int w = 0)\n\t: a(x), b(y), c(z), d(w)\n\t{\n\t\tsize = 1;\n\t\tif(a != 0) size *= a;\n\t\tif(b != 0) size *= b;\n\t\tif(c != 0) size *= c;\n\t\tif(d != 0) size *= d;\n\t\tsave.resize(size);\n\t}\n\n\tdouble & operator() (int x = 0, int y = 0, int z = 0, int w = 0){\n\t\treturn save[x + y*a + z*a*b + w*a*b*c];\n\t}\n\n\tconst double & operator() (int x = 0, int y = 0, int z = 0, int w = 0) const{\n\t\treturn save[x + y*a + z*a*b + w*a*b*c];\n\t}\n};\n",
            1592723999.7940762,
            100,
            "# 答案正确"
        ],
        [
            "9.7 (C++)",
            "覃浩南",
            "class Tensor{\nfriend istream & operator >> (istream & in, Tensor & m);\nfriend ostream & operator << (ostream & in, Tensor & m);\nprivate:\n\tint dimention;\n\tint sizes;\n\tvector<int> size;\n\tvector<double> save;\npublic:\n\tTensor(int x = 0, int y = 0, int z = 0, int w = 0)\n\t{\n\t\tsize.resize(4); dimention = 0;\n\t\tsizes = 1;\n\t\tif(x != 0) {sizes *= x; size[0] = x; dimention++;}\n\t\tif(y != 0) {sizes *= y; size[0] = y; dimention++;}\n\t\tif(z != 0) {sizes *= z; size[0] = z; dimention++;}\n\t\tif(w != 0) {sizes *= w; size[0] = w; dimention++;}\n\t\tsave.resize(sizes);\n\t}\n\n};\n\nistream & operator >> (istream & in, Tensor & m){\n\tin >> m.dimention;\n\tfor(int i = 0; i < m.dimention; ++i){\n\t\tin >> m.size[i];\n\t}\n\tcin.ignore();\n\tm.sizes = 1;\n\tfor(int i = 0; i < m.dimention; ++i){\n\t\tif(m.size[i] != 0){\n\t\t\tm.sizes *= m.size[i];\n\t\t}\n\t\telse{\n\t\t\tbreak;\n\t\t}\n\t}\n\tm.save.resize(m.sizes);\n\n\tfor(int i = 0; i < m.sizes; ++i){\n\t\tdouble tmp;\n\t\tin >> tmp; m.save[i] = tmp;\n\t}\n\n\treturn in;\n}\n\nostream & operator << (ostream & out, Tensor & m){\n\tout << m.dimention << endl;\n\tfor(int i = 0; i < m.dimention; ++ i){\n\t\tif(m.size[i] != 0)\n\t\t\tout << m.size[i] << \" \";\n\t\telse\n\t\t\tbreak;\n\t}\n\tout << endl << endl;\n\n\tfor(int i = 0; i < m.sizes; ++ i){\n\t\tout << m.save[i] << \" \";\n\t\tif((i + 1) % m.size[m.dimention - 1] == 0) out << endl;\n\t\tif((i + 1) % (m.size[m.dimention - 1] * m.size[m.dimention - 2]) == 0) out << endl;\n\t}\n\t\n\treturn out;\n}\n",
            1592728634.845266,
            100,
            "# 答案正确"
        ],
        [
            "10.1 (C++)",
            "覃浩南",
            "#include <stdexcept>\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass MatrixSizesDoNotMatchException{\npublic:\n    MatrixSizesDoNotMatchException(){}\n};\n\ndouble Matrix::get(int row, int column) const{\n    if(row > rows || column > columns){\n        const string err;\n        throw out_of_range(err);\n    }\n    return elements[(row-1) * columns + column-1];        \n}\n\nvoid Matrix::set(int row, int column, double value){\n    if(row > rows || column > columns){\n        const string err;\n        throw out_of_range(err);\n    }\n    elements[(row-1) * columns + column-1] = value;\n}\n\nMatrix Matrix::operator + (const Matrix & matrix2) const{\n    if(this->rows != matrix2.rows || this->columns != matrix2.columns){\n        throw MatrixSizesDoNotMatchException();\n    }\n\n    Matrix res(this->rows, this->columns);\n    for(int i = 0; i < this->rows; ++i){\n        for(int j = 0; j < this->columns; ++j){\n            res.set(i+1, j+1, this->get(i+1, j+1) + matrix2.get(i+1, j+1));\n        }\n    }\n\n    return res;\n}",
            1593346893.8896,
            100,
            "# 答案正确"
        ],
        [
            "10.2 (C++)",
            "覃浩南",
            "catch(NonPositiveValueException &){\n\t\t\tcout << \"caught:NonPositiveValueException\" << endl;\n\t\t}\n\t\tcatch(out_of_range &){\n\t\t\tcout << \"caught: out_of_range\" << endl;\n\t\t}",
            1593659244.3902946,
            100,
            "# 答案正确"
        ],
        [
            "15.1 (C++)",
            "覃浩南",
            "#include <vector>\n#include <string>\n#include <iostream>\n#include <sstream>\nusing namespace std;\n\nclass Table{\nprivate:\n    vector<string> header;\n    vector<vector<string>> contents;\npublic:\n    void addCol(const char * s){\n        header.push_back(s);\n    }\n\n    vector<string>& operator [] (int n){\n        contents.resize(n + 1);\n        return contents[n];\n    }\n\n    string json() const{\n        stringstream ss;\n        ss << \"{\" << endl;\n        ss << \"\theaders: [\";\n        for(auto s1 : header){\n            ss << \"'\" << s1 << \"',\";\n        }\n        ss << \"],\" << endl;\n\n        ss << \"\trows: [\" << endl;\n        for(auto s2: contents){\n            ss << \"\t\t[\";\n            for(auto s3: s2){\n                ss << \"'\" << s3 << \"',\";\n            }\n            ss << \"],\" << endl;\n        }\n        ss << \"\t],\" << endl;\n        ss << \"}\" << endl;\n\n        return ss.str();\n    }\n};\n",
            1593770477.051465,
            100,
            "# 答案正确"
        ],
        [
            "2020-07-09 LAB",
            "覃浩南",
            "#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Integer{\nprivate:\n    int value;\npublic:\n    static int add;\n    Integer(int v = 0) : value(v){}\n    int & set(){ return value;}\n    int get(){ return value;}\n\n    static void increase_all(int a){\n        add = a;\n    }\n\n    static void increase_all(Integer & num){\n        add = num.value;\n    }\n};\n\nint Integer::add = 0;\n\nistream & operator >> (istream & in, Integer & num){\n    in >> num.set();\n    return in;\n}\n\nostream & operator << (ostream & out, Integer & num){\n    num.set() = num.get() + Integer::add;\n    int res = num.get();\n    out << res;\n    return out;\n}",
            1594262321.0622203,
            100,
            "# 答案正确"
        ],
        [
            "A.1 (C++)",
            "覃浩南",
            "private:\n\tNode<E> * get_node(int index) const {\n        if(index == -1 || index == _size) return NULL;\n        if (index == 0) return head;\n        if (index < _size / 2) {\n\t\t\tNode<E> * pre = head;\n\t\t\tNode<E> * cur = pre->next_node(NULL);\n            \n            I(i, index - 1) {\n                Node<E> * tmp = cur;\n                cur = cur->next_node(pre);\n                pre = tmp;\n            }\n\t\t\treturn cur;\n\t\t}\n\n\t\tif (index == _size - 1) return tail;\n        if (index >= _size / 2) {\n\t\t\tNode<E> * late = tail;\n\t\t\tNode<E> * cur = late->prev_node(NULL);\n            \n            I(i, _size - index - 2) {\n                Node<E> * tmp = cur;\n                cur = cur->prev_node(late);\n                late = tmp;\n            }\n\t\t\treturn cur;\n\t\t}\n\t}\n\npublic:\n    void add(int index, const E & e) {\n\t\tif (index < 0 || index > _size) \n\t\t\tthrow NotSuchElementException();\n\t\tNode<E> * node = new Node<E>();\n\t\tnode->element = e;\n\n\t\tNode<E> * next_node = (index == _size) ? 0 : get_node(index);\n\t\tNode<E> * prev_node = (next_node == 0) ? tail : get_node(index - 1);\n\n        node->update_prev_and_next_node(prev_node, next_node);\n\t\tif (prev_node != 0) prev_node->update_next_node(next_node, node);\n\t\tif (next_node != 0) next_node->update_prev_node(prev_node, node);\n\t\t\n        if (prev_node == 0) head = node;\n\t\tif (next_node == 0) tail = node;\n\t\t++ _size;\n\t}\n\n    void addFirst (const E & e) {\n\t\tadd(0, e);\n\t}\n\n\tvoid addLast (const E & e) {\n\t\tadd(_size, e);\n\t}\n\n    void remove (int index) {\n\t\tNode<E> * node = get_node(index);\n\t\tNode<E> * next_node = get_node(index + 1);\n\t\tNode<E> * prev_node = get_node(index - 1);\n        if (prev_node != 0) prev_node->update_next_node(node, next_node);\n\t\tif (next_node != 0) next_node->update_prev_node(node, prev_node);\n\t\tif (prev_node == 0) head = next_node;\n\t\tif (next_node == 0) tail = prev_node;\n\t\tdelete node;\n\t\t-- _size;\n\t}\n\n    void removeFirst () {\n\t\tremove(0);\n\t}\n\n\tvoid removeLast () {\n\t\tremove(_size-1);\n\t}\n\n    E & get(int index) const {\n\t\tNode<E> * node = get_node(index);\n\t\treturn node->element;\n\t}\n\n    int indexOf(const E & e) const {\n\t    Node<E> * node = head;\n\t    I(i, _size) {\n\t    \tnode = get_node(i);\n            if (node->element == e) return i;\n\t    }\n\t    return -1;\n\t}\n    \n    void removeFirstOccurrence(const E & e) {\n\t\tint index = indexOf(e);\n\t\tif (index == -1)\n\t\t\tthrow NotSuchElementException();\n\t\tremove(index);\n\t}",
            1594373733.050429,
            100,
            "# 答案正确"
        ],
        [
            "A.2 (C++)",
            "覃浩南",
            "#include <vector>\ntemplate <typename E>\nvoid LinkedList<E>::removeAll(const E & e){\n    int i, j; vector<int> save;\n    for(i = 0; i < this->_size; ++ i){\n        int v = this->get(i);\n        if(e == v){\n            save.push_back(i);\n        }\n    }\n\n    for(j = 0; j < save.size(); ++j){\n        this->remove(save[j] - j);\n    }\n}",
            1594867454.3093677,
            100,
            "# 答案正确"
        ],
        [
            "A.4 (C++)",
            "覃浩南",
            "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <stdexcept>\nusing namespace std;\n\n#define I(i,n) for (size_t i = 0; i < n; ++ i)\n\nclass NoSuchKeyException {};\n\nclass Mix\n{\npublic:\n    int x = 0;\n\tstring y = \"\";\n\t\n\tMix() {}\n\tMix(const int a) : x(a) {}\n\tMix(const string b) : y(b) {}\n\n\texplicit operator int () const{\n\t\treturn x;\n\t}\n\n\texplicit operator string () const{\n\t\treturn y;\n\t}\n};\n\nsize_t hash_function(const Mix & key) {\n\tif(key.x != 0){\n        size_t code = key.x;\n\t    return code;\n    }\n    else{\n        size_t code = stoi(key.y) + key.y.size();\n\t    return code;\n    }\n}\n\nclass HT\n{\n    class Tuple\n\t{\n\tpublic:\n\t\tMix key;\n        Mix val;\n        bool in_use;\n\n        Tuple() : in_use(false){}\n\t};\n\n    vector<Tuple> tuples;\n    size_t _size;\n\n\tsize_t indexOfKey(const Mix & key) const {\n\t\treturn hash_function(key);\n\t}\n\npublic:\n\tHT() : _size(0) {\n\t\ttuples.resize(200);\n\t}\n\n\tbool containsKey(const int & key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\treturn tuples[index].in_use;\n\t}\n\n   \tMix & operator [] (const Mix & key){\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples[index].val;\n\t}\n\n\tvoid put(const Mix & key, const Mix & val) {\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].key = key;\n\t\ttuples[index].val = val;\n\t\tif (tuples[index].in_use) return;\n\t\ttuples[index].in_use = true;\n\t\t++ _size;\n\t\t// make sure empty > size / 2\n\t\tif (2 * _size > tuples.size())\n\t\t\t_double_tuples();\n\t}\n\n    size_t size(){\n        return _size;\n    }\n\n    void clear() {\n\t\tI(i, tuples.size())\n\t\t\ttuples[i].in_use = false;\n\t\t_size = 0;\n\t}\n\n\n\tvoid _double_tuples() {\n\t\tvector<Tuple> non_empty_tuples;\n\t\tI(i, tuples.size())\n\t\t\tif (tuples[i].in_use)\n\t\t\t\tnon_empty_tuples.push_back(tuples[i]);\n\t\tclear();\n\t\ttuples.resize(tuples.size() * 2);\n\t\tI(i, non_empty_tuples.size())\n\t\t\tput(non_empty_tuples[i].key, non_empty_tuples[i].val);\n\t}\n\n};",
            1595403156.886147,
            100,
            "# 答案正确"
        ],
        [
            "A.5 (C++)",
            "覃浩南",
            "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <stdexcept>\nusing namespace std;\n\n#define I(i,n) for (size_t i = 0; i < n; ++ i)\n\nclass NoSuchKeyException {};\n\nclass Mix\n{\npublic:\n    int x = 0;\n\tstring y = \"\";\n\t\n\tMix() {}\n\tMix(const int a) : x(a) {}\n\tMix(const string b) : y(b) {}\n\n\texplicit operator int () const{\n\t\treturn x;\n\t}\n\n\texplicit operator string () const{\n\t\treturn y;\n\t}\n};\n\nsize_t hash_function(const Mix & key) {\n\tif(key.x != 0){\n        size_t code = key.x;\n\t    return code;\n    }\n    else{\n        size_t code = stoi(key.y) + 5*key.y.size();\n\t    return code;\n    }\n}\n\nclass HT\n{\n    class Tuple\n\t{\n\tpublic:\n\t\tMix key;\n        Mix val;\n        bool in_use;\n\n        Tuple() : in_use(false){}\n\t};\n\n    vector<Tuple> tuples;\n    size_t _size;\n\n\tsize_t indexOfKey(const Mix & key) const {\n\t\treturn hash_function(key);\n\t}\n\npublic:\n\tHT() : _size(0) {\n\t\ttuples.resize(200);\n\t}\n\n\tbool containsKey(const int & key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\treturn tuples[index].in_use;\n\t}\n\n   \tMix & operator [] (const Mix & key){\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) {\n            tuples[index].key = key;\n            tuples[index].in_use = true;\n\t\t    ++ _size;\n            if (2 * _size > tuples.size())\n\t\t\t    _double_tuples();\n        }\n\t\treturn tuples[index].val;\n\t}\n\n\tvoid put(const Mix & key, const Mix & val) {\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].key = key;\n\t\ttuples[index].val = val;\n\t\tif (tuples[index].in_use) return;\n\t\ttuples[index].in_use = true;\n\t\t++ _size;\n\t\t// make sure empty > size / 2\n\t\tif (2 * _size > tuples.size())\n\t\t\t_double_tuples();\n\t}\n\n    size_t size(){\n        return _size;\n    }\n\n    void clear() {\n\t\tI(i, tuples.size())\n\t\t\ttuples[i].in_use = false;\n\t\t_size = 0;\n\t}\n\n\n\tvoid _double_tuples() {\n\t\tvector<Tuple> non_empty_tuples;\n\t\tI(i, tuples.size())\n\t\t\tif (tuples[i].in_use)\n\t\t\t\tnon_empty_tuples.push_back(tuples[i]);\n\t\tclear();\n\t\ttuples.resize(tuples.size() * 2);\n\t\tI(i, non_empty_tuples.size())\n\t\t\tput(non_empty_tuples[i].key, non_empty_tuples[i].val);\n\t}\n\n};",
            1595467417.8042173,
            100,
            "# 答案正确"
        ],
        [
            "A.3 (C++)",
            "覃浩南",
            "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <stdexcept>\nusing namespace std;\n\n#define I(i,n) for (size_t i = 0; i < n; ++ i)\n\nclass NoSuchKeyException {};\n\n\n\nsize_t hash_function(const int & key) {\n\tsize_t code = key/10;\n\treturn code;\n}\n\ntemplate <typename E>\nclass HT\n{\n\tclass Tuple\n\t{\n\tpublic:\n\t\tint key;\n\t\tE val;\n\t\tbool in_use;\n\n\t\tTuple() : in_use(false) {}\n\t};\n\n\tvector<Tuple> tuples;\n\tsize_t _size;\n\n\t// the returned tuple is either empty or with the same key\n\tsize_t indexOfKey(const int & key) const {\n\t\treturn hash_function(key);\n\t}\n\npublic:\n\tHT() : _size(0) {\n\t\ttuples.resize(2000);\n\t}\n\n\tbool containsKey(const int & key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\treturn tuples[index].in_use;\n\t}\n\n\tconst E & operator [] (const int & key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples[index].val;\n\t}\n\n\tE & operator [] (const int & key) {\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples[index].val;\n\t}\n\n\tvoid put(const int & key, const E & val) {\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].key = key;\n\t\ttuples[index].val = val;\n\t\tif (tuples[index].in_use) return;\n\t\ttuples[index].in_use = true;\n\t\t++ _size;\n\t\t// make sure empty > size / 2\n\t\tif (2 * _size > tuples.size())\n\t\t\t_double_tuples();\n\t}\n\n\tvoid _double_tuples() {\n\t\tvector<Tuple> non_empty_tuples;\n\t\tI(i, tuples.size())\n\t\t\tif (tuples[i].in_use)\n\t\t\t\tnon_empty_tuples.push_back(tuples[i]);\n\t\tclear();\n\t\ttuples.resize(tuples.size() * 2);\n\t\tI(i, non_empty_tuples.size())\n\t\t\tput(non_empty_tuples[i].key, non_empty_tuples[i].val);\n\t}\n\n\tvoid remove(const int & key) { \n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\ttuples[index].in_use = false;\n\t\t-- _size;\n\t}\n\n\tsize_t size() const { return _size; }\n\n\tvoid clear() {\n\t\tI(i, tuples.size())\n\t\t\ttuples[i].in_use = false;\n\t\t_size = 0;\n\t}\n\n\tvector<int> getKeys(){\n\t\tvector<int> res;\n\t\tfor(int i = 0; i != tuples.size(); ++i){\n\t\t\tif(tuples[i].in_use){\n\t\t\t\tres.push_back(tuples[i].key);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};",
            1595472426.7941296,
            100,
            "# 答案正确"
        ]
    ],
    "table_name": "答案"
}