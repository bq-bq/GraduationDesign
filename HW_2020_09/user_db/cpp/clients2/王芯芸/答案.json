{
    "__update_time__": 1594870247.5365753,
    "field_names": [
        "题目名",
        "用户名",
        "答案",
        "提交时间",
        "分数",
        "评语"
    ],
    "field_types": [
        "text",
        "text",
        "text",
        "time",
        "number",
        "text"
    ],
    "foreign_keys": {},
    "primary_keys": [],
    "rows": [
        [
            "测试1",
            "王芯芸",
            "#include <iostream>\nusing namespace std;\n\nint main(){\n    string str1, str2, str3;\n    cin >> str1 >> str2 >> str3;\n    cout << str3 << \" \" << str2 << \" \" << str1;\n    return 0;\n}",
            1587517243.0,
            100,
            "# 答案正确"
        ],
        [
            "测试2",
            "王芯芸",
            "#include <iostream>\nusing namespace std;\n\nint main(){\n    string str[10];\n    string mid;\n    for(int i = 0; i < 10; i++)cin >> str[i];\n    for(int i = 0; i < 9; i++)for(int j = i + 1; j < 10; j++){\n        if(str[i] > str[j]){\n            mid = str[i];\n            str[i] = str[j];\n            str[j] = mid;\n        }\n    }\n    for(int i = 0; i < 10; i++)cout << str[i] << \" \";\n    return 0;\n}",
            1587609458.308631,
            100,
            "# 答案正确"
        ],
        [
            "1.1 (C++)",
            "王芯芸",
            "class Matrix5x5\n{\nprivate:\n\tdouble r[5][5] = {{0}, {0}, {0}, {0}, {0}};\n\npublic:\n\tdouble get(int i, int j){\n\t\treturn r[i][j];\n\t}\n\n\tvoid set(int i, int j, double val){\n\t\tr[i][j] = val;\n\t}\n\n\tMatrix5x5 operator + (const Matrix5x5 &m1){\n\t\tMatrix5x5 temp;\n\t\tfor(int i = 0; i < 5; i++)for (int j = 0; j < 5; j++)temp.r[i][j] = this->r[i][j] + m1.r[i][j];\n\t\treturn temp;\n\t}\n};\n\n",
            1588070518.1193829,
            100,
            "# 答案正确"
        ],
        [
            "2.1 (C++)",
            "王芯芸",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble *values;\npublic:\n\tMatrix(int rows, int columns){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tthis->values = new double[rows * (columns + 1)];\n\t\tfor(int i = 0; i < rows * columns; i++)this->values[i] = 0;\n\t}\n\n\t~Matrix(){\n\t\tdelete [] values;\n\t}\n\n\tvoid print(){\n\t\tfor(int i = 0; i < rows; i++){\n\t\t\tfor(int j = 0; j < columns; j++)cout << \"    \" << values[i * columns + j];\n\t\t\tcout << endl;\n\t\t}\n\t}\n};",
            1588832550.6528323,
            100,
            "# 答案正确"
        ],
        [
            "2.2 (C++)",
            "王芯芸",
            "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble *values;\npublic:\n\tMatrix(int rows, int columns,double values[]){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tthis->values = new double[rows * (columns + 1)];\n\t\tfor(int i = 0; i < rows * columns; i++)this->values[i] = values[i];\n\t}\n\n\t~Matrix(){\n\t\tdelete [] values;\n\t}\n\n\tvoid print(){\n\t\tfor(int i = 0; i < rows; i++){\n\t\t\tfor(int j = 0; j < columns; j++)cout << setw(5) << values[i * columns + j];\n\t\t\tcout << endl;\n\t\t}\n\t}\n};",
            1588832501.2681537,
            100,
            "# 答案正确"
        ],
        [
            "2.3 (C++)",
            "王芯芸",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble *values;\npublic:\n\tMatrix(int rows, int columns,double values[]){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tthis->values = new double[rows * (columns + 1)];\n\t\tfor(int i = 0; i < rows * columns; i++)this->values[i] = values[i];\n\t}\n\n\tMatrix(const Matrix & Matrix2){\n\t\trows = Matrix2.rows;\n\t\tcolumns = Matrix2.columns;\n\t\tthis->values = new double[rows * (columns + 1)];\n\t\tfor(int i = 0; i < rows * columns; i++)values[i] = Matrix2.values[i];\n\t}\n\n\t~Matrix(){\n\t\tdelete [] values;\n\t}\n\n\tvoid print(){\n\t\tfor(int i = 0; i < rows; i++){\n\t\t\tfor(int j = 0; j < columns; j++)cout << \"    \" << values[i * columns + j];\n\t\t\tcout << endl;\n\t\t}\n\t}\n};",
            1588832816.9687777,
            100,
            "# 答案正确"
        ],
        [
            "2.5 (C++)",
            "王芯芸",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble *values;\npublic:\n\tMatrix(int rows, int columns){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tthis->values = new double[rows * (columns + 1)];\n\t\tfor(int i = 0; i < rows * columns; i++)this->values[i] = 0;\n\t}\n\n\tMatrix(int rows, int columns,double values[]){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tthis->values = new double[rows * (columns + 1)];\n\t\tfor(int i = 0; i < rows * columns; i++)this->values[i] = values[i];\n\t}\n\n\t~Matrix(){\n\t\tdelete [] values;\n\t}\n\n\tvoid print(){\n\t\tfor(int i = 0; i < rows; i++){\n\t\t\tfor(int j = 0; j < columns; j++)cout << \"    \" << values[i * columns + j];\n\t\t\tcout << endl;\n\t\t}\n\t}\n\n\tMatrix getRow(int row){\n\t\tMatrix newmatrix(1, this->columns);\n\t\tfor(int i = 0; i < newmatrix.columns; i++)newmatrix.values[i] = this->values[i + (row - 1) * this->columns];\n\t\treturn newmatrix;\n\t}\n\n\tMatrix getColumn(int row){\n\t\tMatrix newmatrix(this->rows, 1);\n\t\tfor(int i = 0; i < newmatrix.rows; i++)newmatrix.values[i] = this->values[i * this->columns + row - 1];\n\t\treturn newmatrix;\n\t}\n};",
            1588834687.0011663,
            100,
            "# 答案正确"
        ],
        [
            "2.6 (C++)",
            "王芯芸",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble *values;\npublic:\n\tMatrix(int rows, int columns){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tthis->values = new double[rows * (columns + 1)];\n\t\tfor(int i = 0; i < rows * columns; i++)this->values[i] = 0;\n\t}\n\n\tMatrix(int rows, int columns,double values[]){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tthis->values = new double[rows * (columns + 1)];\n\t\tfor(int i = 0; i < rows * columns; i++)this->values[i] = values[i];\n\t}\n\n\tMatrix(const Matrix & Matrix2){\n\t\trows = Matrix2.rows;\n\t\tcolumns = Matrix2.columns;\n\t\tthis->values = new double[rows * (columns + 1)];\n\t\tfor(int i = 0; i < rows * columns; i++)values[i] = Matrix2.values[i];\n\t}\n\n\t~Matrix(){\n\t\tdelete [] values;\n\t}\n\n\tvoid print(){\n\t\tfor(int i = 0; i < rows; i++){\n\t\t\tfor(int j = 0; j < columns; j++)cout << \"    \" << values[i * columns + j];\n\t\t\tcout << endl;\n\t\t}\n\t}\n\n\tMatrix concatenateRows(const Matrix & matrix2){\n\t\tMatrix newmatrix(this->rows + matrix2.rows, matrix2.columns);\n\t\tfor(int i = 0; i < this->rows * this->columns; i++)newmatrix.values[i] = this->values[i];\n\t\tfor(int i = 0; i < matrix2.rows * matrix2.columns; i++)newmatrix.values[i + this->rows * this->columns] = matrix2.values[i];\n\t\treturn newmatrix;\n\t}\n\n\tMatrix concatenateColumns(const Matrix & matrix2){\n\t\tMatrix newmatrix(matrix2.rows, matrix2.columns + matrix2.columns);\n\t\tfor(int i = 0; i < this->rows + matrix2.rows; i++){\n\t\t\tif(i % 2 == 0)for(int j = 0; j < this->columns; j++)newmatrix.values[j + i * this->columns] = this->values[j + (i / 2) * this->columns];\n\t\t\telse for(int j = 0; j < matrix2.columns; j++)newmatrix.values[j + i * this->columns] = matrix2.values[j + (i / 2) * matrix2.columns];\n\t\t}\n\t\treturn newmatrix;\n\t}\n};",
            1588836396.696969,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/08",
            "王芯芸",
            "double & Tensor_get(int dim, int size[], double * data, int x0, int x1=-1, int x2=-1, int x3=-1){\n\tif (dim == 2) data[1] = x0 * 10 + x1;\n\telse if (dim == 3) data[2] = x0 * 100 + x1 * 10 + x2;\n\telse if (dim == 4)data[3] = x0 * 1000 + x1 * 100 + x2 * 10 + x3;\n\treturn data[dim - 1];\n}",
            1588907327.0714517,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/14",
            "王芯芸",
            "#include <iostream>\nusing namespace std;\n\nvoid Tensor_print (int dimension,const int size[],const double * data)\n{\n\tif (dimension == 1){\n\t\tcout << \"Tensor of \" << size[0] << endl;\n\t\tfor(int i = 0; i < size[0]; i++)cout << data[i] << endl;\n\t}\n\telse if (dimension == 2){\n\t\tcout << \"Tensor of \" << size[0] << \"x\" << size[1] << endl;\n\t\tfor(int i = 0; i < size[0]; i++){\n\t\t\tfor(int j = 0; j < size[1]; j++)cout << \"    \" << data[i * size[1] + j];\n\t\t\tcout << endl;\n\t\t}\n\t}\n\telse if (dimension == 3){\n\t\tcout << \"Tensor of \" << size[0] << \"x\" << size[1] << \"x\" << size[2] << endl;\n\t\tfor(int i = 0; i < size[0]; i++){\n\t\t\tcout << \"data[\" << i << \"]\" << endl;\n\t\t\tfor(int j = 0; j < size[1]; j++){\n\t\t\t\tfor(int m = 0; m < size[2]; m++)cout << \"    \" << data[i * size[2] * size[1] + j * size[1] + m];\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t}\n\telse if (dimension == 4){\n\t\tcout << \"Tensor of \" << size[0] << \"x\" << size[1] << \"x\" << size[2] << \"x\" << size[3] << endl;\n\t\tfor(int i = 0; i < size[0]; i++)for(int j = 0; j < size[1]; j++){\n\t\t\tcout << \"data[\" << i << \"][\" << j << \"]\" << endl;\n\t\t\tfor(int m = 0; m < size[2]; m++){\n\t\t\t\tfor(int n = 0; n < size[3]; n++)cout << \"    \" << data[i * i * size[2] * size[1] * size[3] + j * size[1] * size[2] + m * size[1] + n];\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t}\n}",
            1589425901.054736,
            100,
            "# 答案正确"
        ],
        [
            "2.4 (C++)",
            "王芯芸",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble *values;\npublic:\n\tMatrix(int row, int column){\n\t\trows = row;\n\t\tcolumns = column;\n\t\tvalues = new double[row * column];\n\t\tfor(int i = 0; i < row * column; i++)values[i] = 0;\n\t}\n\tMatrix(int row, int column, double value[]){\n\t\trows = row;\n\t\tcolumns = column;\n\t\tvalues = new double[row * column];\n\t\tfor(int i = 0; i < row * column; i++)values[i] = value[i];\n\t}\n\t~Matrix(){\n\t\tdelete [] values;\n\t}\n\tvoid print(){\n\t\tfor(int i = 0; i < rows; i++){\n\t\t\tfor(int j = 0; j < columns; j++)cout << \"    \" << values[i * columns + j];\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tvoid set(int row, int column, double value){\n\t\tvalues[(row - 1) * columns + column - 1] = value;\n\t}\n\tdouble *operator =(Matrix & matrix){\n\t\trows = matrix.rows;\n\t\tcolumns = matrix.columns;\n\t\tdelete [] values;\n\t\tvalues = new double[rows * columns];\n\t\tfor(int i = 0; i < rows * columns; i++)values[i] = matrix.values[i];\n\t}\n};",
            1589519818.7300248,
            100,
            "# 答案正确"
        ],
        [
            "2.7 (C++)",
            "王芯芸",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble *values;\npublic:\n\tMatrix(int row, int column){\n\t\trows = row;\n\t\tcolumns = column;\n\t\tvalues = new double[row * column];\n\t\tfor(int i = 0; i < row * column; i++)values[i] = 0;\n\t}\n\tMatrix(int row, int column, double value[]){\n\t\trows = row;\n\t\tcolumns = column;\n\t\tvalues = new double[row * column];\n\t\tfor(int i = 0; i < row * column; i++)values[i] = value[i];\n\t}\n\tMatrix(const Matrix & matrix){\n\t\trows = matrix.rows;\n\t\tcolumns = matrix.columns;\n\t\tvalues = new double[rows * columns];\n\t\tfor(int i = 0; i < rows * columns; i++)values[i] = matrix.values[i];\n\t}\n\t~Matrix(){\n\t\tdelete [] values;\n\t}\n\tvoid print(){\n\t\tfor(int i = 0; i < rows; i++){\n\t\t\tfor(int j = 0; j < columns; j++)cout << \"    \" << values[i * columns + j];\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tMatrix reshape(int row, int column) const {\n\t\tMatrix matrix1(row, column);\n\t\tdouble *arr = new double[row * column];\n\t\tint n = 0;\n\t\tfor(int i = 0; i < columns; i++)for(int j = 0; j < rows; j++){\n\t\t\tarr[n] = values[i + j * columns];\n\t\t\tn++;\n\t\t}\n\t\tfor(int i = 0; i < row; i++)for(int j = 0; j < column; j++){\n\t\t\tmatrix1.values[i * column + j] = arr[i + j * row];\n\t\t}\n\t\tdelete [] arr;\n\t\treturn matrix1;\n\t}\n};",
            1589527747.2777464,
            100,
            "# 答案正确"
        ],
        [
            "2.8 (C++)",
            "王芯芸",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble *values;\npublic:\n\tMatrix(int row, int column){\n\t\trows = row;\n\t\tcolumns = column;\n\t\tvalues = new double[row * column];\n\t\tfor(int i = 0; i < row * column; i++)values[i] = 0;\n\t}\n\tMatrix(int row, int column, double value[]){\n\t\trows = row;\n\t\tcolumns = column;\n\t\tvalues = new double[row * column];\n\t\tfor(int i = 0; i < row * column; i++)values[i] = value[i];\n\t}\n\tMatrix(const Matrix & matrix){\n\t\trows = matrix.rows;\n\t\tcolumns = matrix.columns;\n\t\tvalues = new double[rows * columns];\n\t\tfor(int i = 0; i < rows * columns; i++)values[i] = matrix.values[i];\n\t}\n\t~Matrix(){\n\t\tdelete [] values;\n\t}\n\tvoid print(){\n\t\tfor(int i = 0; i < rows; i++){\n\t\t\tfor(int j = 0; j < columns; j++)cout << \"    \" << values[i * columns + j];\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tMatrix transpose(){\n\t\tMatrix matrix1(columns, rows);\n\t\tfor(int i = 0; i < columns; i++)for(int j = 0; j < rows; j++){\n\t\t\tmatrix1.values[i * rows + j] = values[i + j * columns];\n\t\t}\n\t\treturn matrix1;\n\t}\n};",
            1589528165.1750484,
            100,
            "# 答案正确"
        ],
        [
            "2.10 (C++)",
            "王芯芸",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble *values;\npublic:\n\tMatrix(int row, int column){\n\t\trows = row;\n\t\tcolumns = column;\n\t\tvalues = new double[row * column];\n\t\tfor(int i = 0; i < row * column; i++)values[i] = 0;\n\t}\n\tMatrix(int row, int column, double value[]){\n\t\trows = row;\n\t\tcolumns = column;\n\t\tvalues = new double[row * column];\n\t\tfor(int i = 0; i < row * column; i++)values[i] = value[i];\n\t}\n\tMatrix(const Matrix & matrix){\n\t\trows = matrix.rows;\n\t\tcolumns = matrix.columns;\n\t\tvalues = new double[rows * columns];\n\t\tfor(int i = 0; i < rows * columns; i++)values[i] = matrix.values[i];\n\t}\n\t~Matrix(){\n\t\tdelete [] values;\n\t}\n\tvoid print(){\n\t\tfor(int i = 0; i < rows; i++){\n\t\t\tfor(int j = 0; j < columns; j++)cout << \"    \" << values[i * columns + j];\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tMatrix operator * (const Matrix & matrix2) const{\n\t\tMatrix newmatrix(rows, matrix2.columns);\n\t\tfor(int i = 0; i < newmatrix.rows; i++)for(int j = 0; j < newmatrix.columns; j++){\n\t\t\tfor(int k = 0; k < columns; k++)newmatrix.values[i * newmatrix.columns + j] += values[i * columns + k] * matrix2.values[k * matrix2.columns + j];\n\t\t}\n\t\treturn newmatrix;\n\t}\n\tMatrix operator * (double value) const{\n\t\tfor(int i = 0; i < rows; i++)for(int j = 0; j < columns; j++)values[i * columns + j] *= value;\n\t\treturn *this;\n\t}\n};",
            1589529006.0803945,
            100,
            "# 答案正确"
        ],
        [
            "2.11 (C++)",
            "王芯芸",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble *values;\npublic:\n\tMatrix(int row, int column){\n\t\trows = row;\n\t\tcolumns = column;\n\t\tvalues = new double[row * column];\n\t\tfor(int i = 0; i < row * column; i++)values[i] = 0;\n\t}\n\tMatrix(int row, int column, double value[]){\n\t\trows = row;\n\t\tcolumns = column;\n\t\tvalues = new double[row * column];\n\t\tfor(int i = 0; i < row * column; i++)values[i] = value[i];\n\t}\n\tMatrix(const Matrix & matrix){\n\t\trows = matrix.rows;\n\t\tcolumns = matrix.columns;\n\t\tvalues = new double[rows * columns];\n\t\tfor(int i = 0; i < rows * columns; i++)values[i] = matrix.values[i];\n\t}\n\t~Matrix(){\n\t\tdelete [] values;\n\t}\n\tvoid print(){\n\t\tfor(int i = 0; i < rows; i++){\n\t\t\tfor(int j = 0; j < columns; j++)cout << \"    \" << values[i * columns + j];\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tMatrix max() const {\n\t\tif(rows != 1){\n\t\t\tMatrix newmatrix(1, columns);\n\t\t\tfor(int i = 0; i < columns; i++){\n\t\t\t\tdouble maximum = values[i];\n\t\t\t\tfor(int j = 1; j < rows; j++)if(values[i + j * columns] > maximum)maximum = values[i + j * columns];\n\t\t\t\tnewmatrix.values[i] = maximum;\n\t\t\t}\n\t\t\treturn newmatrix;\n\t\t}\n\t\telse{\n\t\t\tMatrix newmatrix(1, 1);\n\t\t\tnewmatrix.values[0] = values[0];\n\t\t\tfor(int i = 1; i < columns; i++)if(values[i] > newmatrix.values[0])newmatrix.values[0] = values[i];\n\t\t\treturn newmatrix;\n\t\t}\n\t}\n\tMatrix min() const {\n\t\tif(rows != 1){\n\t\t\tMatrix newmatrix(1, columns);\n\t\t\tfor(int i = 0; i < columns; i++){\n\t\t\t\tdouble minimum = values[i];\n\t\t\t\tfor(int j = 1; j < rows; j++)if(values[i + j * columns] < minimum)minimum = values[i + j * columns];\n\t\t\t\tnewmatrix.values[i] = minimum;\n\t\t\t}\n\t\t\treturn newmatrix;\n\t\t}\n\t\telse{\n\t\t\tMatrix newmatrix(1, 1);\n\t\t\tnewmatrix.values[0] = values[0];\n\t\t\tfor(int i = 1; i < columns; i++)if(values[i] < newmatrix.values[0])newmatrix.values[0] = values[i];\n\t\t\treturn newmatrix;\n\t\t}\n\t}\n\tMatrix sum() const {\n\t\tif(rows != 1){\n\t\t\tMatrix newmatrix(1, columns);\n\t\t\tfor(int i = 0; i < columns; i++)for(int j = 0; j < rows; j++)newmatrix.values[i] += values[i + j * columns];\n\t\t\treturn newmatrix;\n\t\t}\n\t\telse{\n\t\t\tMatrix newmatrix(1, 1);\n\t\t\tfor(int i = 0; i < columns; i++)newmatrix.values[0] += values[i];\n\t\t\treturn newmatrix;\n\t\t}\n\t}\n};",
            1589530124.0619845,
            100,
            "# 答案正确"
        ],
        [
            "2.12 (C++)",
            "王芯芸",
            "#include <iostream>\nusing namespace std;\n\ndouble p(double x, double y){\n\tdouble res = 1;\n\tfor(double i = 0; i < y; i++)res *= x;\n\treturn res;\n}\n\ndouble g(double x){\n\tdouble res = 1;\n\twhile(x >= 1){\n\t\tres *= x;\n\t\tx--;\n\t}\n\treturn res;\n}\n\ndouble e(double x){\n\tdouble res = 1;\n\tfor(double i = 1; i <= 100; i++){\n\t\tres += p(x, i) / g(i);\n\t}\n\treturn res;\n}\n\n\ndouble MYLOG(double a)\n{\n    int N = 100;\n    int k,nk;\n    double x,xx,y;\n    x = (a-1)/(a+1);\n    xx = x*x;\n    nk = 2*N+1;\n    y = 1.0/nk;\n    for(k=N;k>0;k--)\n    {\n        nk = nk - 2;\n        y = 1.0/nk+xx*y;\n    }\n    return 2.0*x*y;\n}\n\n\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble *values;\npublic:\n\tMatrix(int row, int column){\n\t\trows = row;\n\t\tcolumns = column;\n\t\tvalues = new double[row * column];\n\t\tfor(int i = 0; i < row * column; i++)values[i] = 0;\n\t}\n\tMatrix(int row, int column, double value[]){\n\t\trows = row;\n\t\tcolumns = column;\n\t\tvalues = new double[row * column];\n\t\tfor(int i = 0; i < row * column; i++)values[i] = value[i];\n\t}\n\tMatrix(const Matrix & matrix){\n\t\trows = matrix.rows;\n\t\tcolumns = matrix.columns;\n\t\tvalues = new double[rows * columns];\n\t\tfor(int i = 0; i < rows * columns; i++)values[i] = matrix.values[i];\n\t}\n\t~Matrix(){\n\t\tdelete [] values;\n\t}\n\tvoid print(){\n\t\tfor(int i = 0; i < rows; i++){\n\t\t\tfor(int j = 0; j < columns; j++)cout << \"    \" << values[i * columns + j];\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tMatrix pow(double exponent){\n\t\tMatrix newmatrix(*this);\n\t\tfor(int i = 0; i < columns * rows; i++)newmatrix.values[i] = p(values[i], exponent);\n\t\treturn newmatrix;\n\t}\n\tMatrix exp(){\n\t\tMatrix newmatrix(*this);\n\t\tfor(int i = 0; i < columns * rows; i++)newmatrix.values[i] = e(values[i]);\n\t\treturn newmatrix;\n\t}\n\tMatrix log(){\n\t\tMatrix newmatrix(*this);\n\t\tfor(int i = 0; i < columns * rows; i++)newmatrix.values[i] = MYLOG(values[i]);\n\t\treturn newmatrix;\n\t}\n\tMatrix abs(){\n\t\tMatrix newmatrix(*this);\n\t\tfor(int i = 0; i < columns * rows; i++)newmatrix.values[i] = (values[i] >= 0 ? values[i] : -values[i]);\n\t\treturn newmatrix;\n\t}\n};",
            1589542594.7407715,
            100,
            "# 答案正确"
        ],
        [
            "2.9 (C++)",
            "王芯芸",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble *values;\npublic:\n\tMatrix(int row, int column){\n\t\trows = row;\n\t\tcolumns = column;\n\t\tvalues = new double[row * column];\n\t\tfor(int i = 0; i < row * column; i++)values[i] = 0;\n\t}\n\tMatrix(int row, int column, double value[]){\n\t\trows = row;\n\t\tcolumns = column;\n\t\tvalues = new double[row * column];\n\t\tfor(int i = 0; i < row * column; i++)values[i] = value[i];\n\t}\n\tMatrix(const Matrix & matrix){\n\t\trows = matrix.rows;\n\t\tcolumns = matrix.columns;\n\t\tvalues = new double[rows * columns];\n\t\tfor(int i = 0; i < rows * columns; i++)values[i] = matrix.values[i];\n\t}\n\t~Matrix(){\n\t\tdelete [] values;\n\t}\n\tvoid print(){\n\t\tfor(int i = 0; i < rows; i++){\n\t\t\tfor(int j = 0; j < columns; j++)cout << \"    \" << values[i * columns + j];\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tMatrix operator +(const Matrix & matrix)const{\n\t\tMatrix newmatrix(*this);\n\t\tfor(int i = 0; i < rows * columns; i++)newmatrix.values[i] += matrix.values[i];\n\t\treturn newmatrix;\n\t}\n\tMatrix operator +(double value)const{\n\t\tMatrix newmatrix(*this);\n\t\tfor(int i = 0; i < rows * columns; i++)newmatrix.values[i] += value;\n\t\treturn newmatrix;\n\t}\n\tMatrix operator -(const Matrix & matrix)const{\n\t\tMatrix newmatrix(*this);\n\t\tfor(int i = 0; i < rows * columns; i++)newmatrix.values[i] -= matrix.values[i];\n\t\treturn newmatrix;\n\t}\n\tMatrix operator -(double value)const{\n\t\tMatrix newmatrix(*this);\n\t\tfor(int i = 0; i < rows * columns; i++)newmatrix.values[i] -= value;\n\t\treturn newmatrix;\n\t}\n};",
            1590028668.5419214,
            100,
            "# 答案正确"
        ],
        [
            "6.1 (C++)",
            "王芯芸",
            "#include <cstring>\n\ntemplate <typename T>\n\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tT *values;\npublic:\n\tMatrix(int row, int column){\n\t\trows = row;\n\t\tcolumns = column;\n\t\tvalues = new T[row * column];\n\t\tmemset(values, 0, row * column * sizeof(T));\n\t}\n\tMatrix(int row, int column, const T value[]){\n\t\trows = row;\n\t\tcolumns = column;\n\t\tvalues = new T[row * column];\n\t\tfor(int i = 0; i < row * column; i++)values[i] = value[i];\n\t}\n\tMatrix(const Matrix & matrix){\n\t\trows = matrix.rows;\n\t\tcolumns = matrix.columns;\n\t\tvalues = new T[rows * columns];\n\t\tfor(int i = 0; i < rows * columns; i++)values[i] = matrix.values[i];\n\t}\n\tT & get(int x, int y){\n\t\treturn values[(x - 1) * columns + y - 1];\n\t}\n\t~Matrix(){\n\t\tdelete [] values;\n\t}\n\tvoid print(){\n\t\tfor(int i = 0; i < rows; i++){\n\t\t\tfor(int j = 0; j < columns; j++)cout << \"    \" << values[i * columns + j];\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tMatrix operator = (Matrix matrix){\n\t\trows = matrix.rows;\n\t\tcolumns = matrix.columns;\n\t\tfor(int i = 0; i < rows * columns; i++)values[i] = matrix.values[i];\n\t\treturn *this;\n\t}\n};",
            1590311206.3976915,
            100,
            "# 答案正确"
        ],
        [
            "6.3 (C++)",
            "王芯芸",
            "#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate <typename T>\n\nclass Matrix\n{\nprivate:\n\tint rows, columns;\n\tvector<T> values;\npublic:\n\tMatrix(int row, int column){\n\t\trows = row;\n\t\tcolumns = column;\n\t\tfor(int i = 0; i < row * column; i++)values.push_back(0);\n\t}\n\tMatrix(int row, int column, const vector<T> value){\n\t\trows = row;\n\t\tcolumns = column;\n\t\tfor(int i = 0; i < row * column; i++)values.push_back(value[i]);\n\t}\n\tMatrix(int row, int column, T *value){\n\t\trows = row;\n\t\tcolumns = column;\n\t\tfor(int i = 0; i < row * column; i++)values.push_back(value[i]);\n\t}\n\tMatrix getColumn(int column){\n\t\tT mat[rows];\n\t\tfor(int i = 0; i < rows; i++)mat[i] = values[i * columns + column - 1];\n\t\tMatrix newmatrix(rows, 1, mat);\n\t\treturn newmatrix;\n\t}\n\n\tMatrix operator + (const Matrix & matrix){\n\t\tT mat[rows * columns];\n\t\tfor(int i = 0; i < rows * columns; i++)mat[i] = values[i] + matrix.values[i];\n\t\tMatrix newmatrix(rows, columns, mat);\n\t\treturn newmatrix;\n\t}\n\tMatrix operator + (T value){\n\t\tT mat[rows * columns];\n\t\tfor(int i = 0; i < rows * columns; i++)mat[i] = values[i] + value;\n\t\tMatrix newmatrix(rows, columns, mat);\n\t\treturn newmatrix;\n\t}\n\tMatrix operator - (const Matrix & matrix){\n\t\tT mat[rows * columns];\n\t\tfor(int i = 0; i < rows * columns; i++)mat[i] = values[i] - matrix.values[i];\n\t\tMatrix newmatrix(rows, columns, mat);\n\t\treturn newmatrix;\n\t}\n\tMatrix operator - (T value){\n\t\tT mat[rows * columns];\n\t\tfor(int i = 0; i < rows * columns; i++)mat[i] = values[i] - value;\n\t\tMatrix newmatrix(rows, columns, mat);\n\t\treturn newmatrix;\n\t}\n\tMatrix operator * (const Matrix & matrix){\n\t\tT mat[rows * matrix.columns];\n\t\tfor(int i = 0; i < rows; i++)for(int j = 0; j < matrix.columns; j++)for(int k = 0; k < columns; k++)mat[i * matrix.columns + j] += values[i * columns + k] * matrix.values[k * matrix.columns + j];\n\t\tMatrix newmatrix(rows, matrix.columns, mat);\n\t\treturn newmatrix;\n\t}\n\tMatrix operator * (T value){\n\t\tT mat[rows * columns];\n\t\tfor(int i = 0; i < rows * columns; i++)mat[i] = values[i] * value;\n\t\tMatrix newmatrix(rows, columns, mat);\n\t\treturn newmatrix;\n\t}\n\tMatrix getRow(int row){\n\t\tT mat[columns];\n\t\tfor(int i = 0; i < columns; i++)mat[i] = values[(row - 1) * columns + i];\n\t\tMatrix newmatrix(1, columns, mat);\n\t\treturn newmatrix;\n\t}\n\tMatrix concatenateRows(Matrix & matrix){\n\t\tT mat[(rows + matrix.rows) * columns];\n\t\tfor(int i = 0; i < (rows + matrix.rows) * columns; i++){\n\t\t\tif(i < rows * columns)mat[i] = values[i];\n\t\t\telse mat[i] = matrix.values[i - rows * columns];\n\t\t}\n\t\tMatrix newmatrix(rows + matrix.rows, columns, mat);\n\t\treturn newmatrix;\n\t}\n\tMatrix concatenateColumns(Matrix & matrix){\n\t\tT mat[rows * (columns + matrix.columns)];\n\t\tint n = 0;\n\t\tfor(int i = 0; i < rows; i++){\n\t\t\tfor(int j = 0; j < columns; j++)mat[n++] = values[i * columns + j];\n\t\t\tfor(int j = 0; j < matrix.columns; j++)mat[n++] = matrix.values[i * matrix.columns + j];\n\t\t}\n\t\tMatrix newmatrix(rows, columns + matrix.columns, mat);\n\t\treturn newmatrix;\n\t}\n\tMatrix reshape(int row, int column){\n\t\tint n = 0;\n\t\tT mat1[row * column];\n\t\tfor(int j = 0; j < columns; j++)for(int i = 0; i < rows; i++)mat1[n++] = values[i * columns + j];\n\t\tT mat2[row][column];\n\t\tn = 0;\n\t\tfor(int j = 0; j < column; j++)for(int i = 0; i < row; i++)mat2[i][j] = mat1[n++];\n\t\tT mat3[row * column];\n\t\tn = 0;\n\t\tfor(int i = 0; i < row; i++)for(int j = 0; j < column; j++)mat3[n++] = mat2[i][j];\n\t\tMatrix newmatrix(columns, rows, mat3);\n\t\treturn newmatrix;\n\t}\n\tMatrix transpose(){\n\t\tT mat1[rows][columns];\n\t\tfor(int i = 0; i < rows; i++)for(int j = 0; j < columns; j++)mat1[i][j] = values[i * columns + j];\n\t\tT mat2[rows * columns];\n\t\tint n = 0;\n\t\tfor(int i = 0; i < columns; i++)for(int j = 0; j < rows; j++)mat2[n++] = mat1[j][i];\n\t\tMatrix newmatrix(columns, rows, mat2);\n\t\treturn newmatrix;\n\t}\n\tMatrix max(){\n\t\tif(rows == 1){\n\t\t\tT mat[1];\n\t\t\tmat[0] = values[0];\n\t\t\tfor(int i = 1; i < columns; i++)if(mat[0] < values[i])mat[0] = values[i];\n\t\t\tMatrix newmatrix(1, 1, mat);\n\t\t\treturn newmatrix;\n\t\t}\n\t\telse{\n\t\t\tT mat[columns];\n\t\t\tfor(int i = 0; i < columns; i++){\n\t\t\t\tmat[i] = values[i];\n\t\t\t\tfor(int j = 1; j < rows; j++)if(mat[i] < values[j * columns + i])mat[i] = values[j * columns + i];\n\t\t\t}\n\t\t\tMatrix newmatrix(1, columns, mat);\n\t\t\treturn newmatrix;\n\t\t}\n\t}\n\tMatrix min(){\n\t\tif(rows == 1){\n\t\t\tT mat[1];\n\t\t\tmat[0] = values[0];\n\t\t\tfor(int i = 1; i < columns; i++)if(mat[0] > values[i])mat[0] = values[i];\n\t\t\tMatrix newmatrix(1, 1, mat);\n\t\t\treturn newmatrix;\n\t\t}\n\t\telse{\n\t\t\tT mat[columns];\n\t\t\tfor(int i = 0; i < columns; i++){\n\t\t\t\tmat[i] = values[i];\n\t\t\t\tfor(int j = 1; j < rows; j++)if(mat[i] > values[j * columns + i])mat[i] = values[j * columns + i];\n\t\t\t}\n\t\t\tMatrix newmatrix(1, columns, mat);\n\t\t\treturn newmatrix;\n\t\t}\n\t}\n\tMatrix sum(){\n\t\tif(rows == 1){\n\t\t\tT mat[1];\n\t\t\tmat[0] = values[0];\n\t\t\tfor(int i = 1; i < columns; i++)mat[0] += values[i];\n\t\t\tMatrix newmatrix(1, 1, mat);\n\t\t\treturn newmatrix;\n\t\t}\n\t\telse{\n\t\t\tT mat[columns];\n\t\t\tfor(int i = 0; i < columns; i++){\n\t\t\t\tmat[i] = values[i];\n\t\t\t\tfor(int j = 1; j < rows; j++)mat[i] += values[j * columns + i];\n\t\t\t}\n\t\t\tMatrix newmatrix(1, columns, mat);\n\t\t\treturn newmatrix;\n\t\t}\n\t}\n\tvoid print(){\n\t\tfor(int i = 0; i < rows; i++){\n\t\t\tfor(int j = 0; j < columns; j++)cout << \"    \" << values[i * columns + j];\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tT & get(int x, int y){\n\t\treturn values[(x - 1) * columns + y - 1];\n\t}\n};",
            1590414801.9049003,
            100,
            "# 答案正确"
        ],
        [
            "6.2 (C++)",
            "王芯芸",
            "#include <iostream>\n#include <cstring>\nusing namespace std;\n\ntemplate <typename T>\n\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tT *values;\npublic:\n\tMatrix(int row, int column){\n\t\trows = row;\n\t\tcolumns = column;\n\t\tvalues = new T[row * column];\n\t\tmemset(values, 0, row * column * sizeof(T));\n\t}\n\t~Matrix(){\n\t\tdelete [] values;\n\t}\n\tvoid print(){\n\t\tfor(int i = 0; i < rows; i++){\n\t\t\tfor(int j = 0; j < columns; j++)cout << \"    \" << values[i * columns + j];\n\t\t\tcout << endl;\n\t\t}\n\t}\n};",
            1590633731.0473871,
            100,
            "# 答案正确"
        ],
        [
            "7.2 (C++)",
            "王芯芸",
            "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nvector<string> split(const string & line, const string & delimiter=\" \"){\n\tvector<string> words;\n\tint st = 0;\n\twhile (st < line.size())\n\t{\n\t\tint end = line.find(delimiter, st);\n\t\tif(end == st)st += delimiter.size();\n\t\telse{\n\t\t\tif(end == -1){\n\t\t\t\twords.push_back(line.substr(st));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse{\n\t\t\t\twords.push_back(line.substr(st, end - st));\n\t\t\t\tst = end + delimiter.size();\n\t\t\t}\n\t\t}\n\t}\n\treturn words;\n}",
            1591239585.2212276,
            100,
            "# 答案正确"
        ],
        [
            "7.1 (C++)",
            "王芯芸",
            "#include <cmath>\n\nclass Triangle : public GeometricObject\n{\nprivate:\n\tdouble side1, side2, side3;\n\npublic:\n\tTriangle(){\n\t\tside1 = 1.0;\n\t\tside2 = 1.0;\n\t\tside3 = 1.0;\n\t}\n\tTriangle(double side1, double side2, double side3){\n\t\tthis->side1 = side1;\n\t\tthis->side2 = side2;\n\t\tthis->side3 = side3;\n\t}\n\tdouble getSide1(){\n\t\treturn side1;\n\t}\n\tdouble getSide2(){\n\t\treturn side2;\n\t}\n\tdouble getSide3(){\n\t\treturn side3;\n\t}\n\tdouble getArea(){\n\t\tdouble s = (side1 + side2 + side3) / 2;\n\t\treturn sqrt(s * (s - side1) * (s - side2) * (s - side3));\n\t}\n\tdouble getPerimeter(){\n\t\treturn side1 + side2 + side3;\n\t}\n};",
            1591241362.8448346,
            100,
            "# 答案正确"
        ],
        [
            "7.3 (C++)",
            "王芯芸",
            "template <typename A>\nvector<A> map2(const vector<A> & x, const vector<A> & y, A (*map_func)(const A &, const A &)){\n\tvector<A> res;\n\tfor (int i = 0; i < x.size(); ++ i)res.push_back(map_func(x[i], y[i]));\n\treturn res;\n}\n\ntemplate <typename A>\nvector<A> map2(const vector<A> & x, int y, A (*map_func)(const A &, const A &)){\n\tvector<A> res;\n\tfor (int i = 0; i < x.size(); ++ i)res.push_back(map_func(x[i], y));\n\treturn res;\n}",
            1591247248.9307592,
            100,
            "# 答案正确"
        ],
        [
            "8.5 (C++)",
            "王芯芸",
            "#include <iostream>\nusing namespace std;\n\nclass Point3D : public Point2D\n{\nprivate:\n    double z;\n\npublic:\n    Point3D(){\n        setX(0);\n        setY(0);\n        z = 0;\n    }\n    Point3D(double x, double y, double z){\n        setX(x);\n        setY(y);\n        this->z = z;\n    }\n    double getZ(){\n        return z;\n    }\n    double distance(Point2D & point2){\n        Point3D & a = dynamic_cast<Point3D &>(point2);\n        double dx = getX() - a.getX();\n\t\tdouble dy = getY() - a.getY();\n        double dz = getZ() - a.getZ();\n\t\treturn sqrt(dx * dx + dy * dy + dz * dz);\n    }\n};",
            1591845178.0318816,
            100,
            "# 答案正确"
        ],
        [
            "8.1 (C++)",
            "王芯芸",
            "class Full : public Matrix\n{ \npublic:\n\tvirtual int size(int dimension)const{\n\t\tif(dimension == 1)return rows;\n\t\telse return columns;\n\t}\n\tvirtual void set(int row, int column, double value){\n\t\tval[(row - 1) * columns + column - 1] = value;\n\t}\n\tvirtual double get(int row, int column) const{\n\t\treturn val[row * columns + column];\n\t}\n\tvirtual void print() const{\n\t\tfor(int i = 0;i < rows;i++){\n\t\t\tfor(int j = 0;j < columns;j++)cout<<\"    \"<<val[i*columns+j];\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tvirtual Matrix & operator = (const Matrix & matrix2){\n\t\trows = matrix2.size(1);\n\t\tcolumns = matrix2.size(2);\n\t\tfor(int i = 0; i < rows; i++)for(int j = 0; j < columns; j++)val[i * columns + j] = matrix2.get(i, j);\n\t\treturn *this;\n\t}\n\tFull(int row, int column){\n\t\trows = row;\n\t\tcolumns = column;\n\t\tval = new double [rows * columns];\n\t\tfor (int i = 0; i < rows * columns; ++ i)val[i] = 0;\n\t}\n\tFull(int row, int column, double values[]){\n\t\trows = row;\n\t\tcolumns = column;\n\t\tval = new double [rows * columns];\n\t\tfor (int i = 0; i < rows * columns; i++)val[i] = values[i];\n\t}\n\tFull(const Matrix & matrix2){\n\t\trows = matrix2.size(1);\n\t\tcolumns = matrix2.size(2);\n\t\tval = new double[rows * columns];\n\t\tfor(int i = 0; i < rows; i++)for(int j = 0; j < columns; j++)val[i * columns + j] = matrix2.get(i, j);\n\t}\n\t~Full(){\n\t\tdelete [] val;\n\t}\nprivate:\n\tint rows , columns;\n\tdouble *val;\n};",
            1591875082.163255,
            100,
            "# 答案正确"
        ],
        [
            "8.3 (C++)",
            "王芯芸",
            "#include <iostream>\n#include<vector>\nusing namespace std;\n\nclass Sparse : public Matrix\n{\nprivate:\n    int rows, columns;\n    vector<Entry> ans;\npublic:\n    virtual int size(int dimension)const{\n\t\tif(dimension == 1)return rows;\n\t\telse return columns;\n\t}\n\tvirtual void set(int Row, int Column, double value){\n        if(value == 0)return;\n\t\tEntry ent;\n        ent.row = Row, ent.column = Column, ent.value = value;\n        for(int i = 0; i < ans.size(); i++){\n            if(Row == ans[i].row && Column == ans[i].column){\n                ans[i] = ent;\n                return;\n            }\n            if(Row < ans[i].row || (Row == ans[i].row && Column < ans[i].column)){\n                ans.push_back(ent);\n                for(int j = ans.size() - 1; j > i; j--)ans[j] = ans[j - 1];\n                ans[i] = ent;\n                return;\n            }\n        }\n        ans.push_back(ent);\n\t}\n\tvirtual double get(int Row, int Column) const{\n\t\tfor(int i = 0; i < ans.size(); i++)if(ans[i].row == Row && ans[i].column == Column)return ans[i].value;\n        return 0;\n\t}\n\tvirtual void print(){\n\t\tfor(int i = 0; i < ans.size(); i++)cout << \"(\" << ans[i].row << \",\" << ans[i].column << \",\" << ans[i].value << \")\" << endl;\n\t}\n    Sparse(int Row, int Column){\n        rows = Row;\n        columns = Column;\n    }\n    Sparse operator + (Sparse & sparse2){\n        vector<Entry> newEnt = ans;\n        for(int i = 0; i < sparse2.ans.size(); i++){\n            int flag = 1;\n            for(int j = 0; j < ans.size(); j++){\n                if(sparse2.ans[i].row == ans[j].row && sparse2.ans[i].column == ans[j].column){\n                    newEnt[j].value += sparse2.ans[i].value;\n                    flag = 0;\n                }\n            }\n            if(flag == 1)newEnt.push_back(sparse2.ans[i]);\n        }\n        Sparse res(sparse2.size(1), sparse2.size(2));\n        for (int i = 0; i < newEnt.size(); i++){\n\t\t\tres.set(newEnt[i].row, newEnt[i].column, newEnt[i].value);\n\t\t}\n\t\treturn res;\n    }\n};",
            1591877880.1780367,
            100,
            "# 答案正确"
        ],
        [
            "8.4 (C++)",
            "王芯芸",
            "#define f(i,start,n) for(int i = start;i < n;i++)\n#include<vector>\n#include<iostream>\nusing namespace std;\nclass Sparse:public Matrix{\nprivate:\n    int rows;\n    int columns;\n    vector<Entry> entry;\npublic:\n    Sparse(int row, int column): rows(row),columns(column){}\n    Sparse(const Sparse& other){\n        rows = other.rows;\n        columns = other.columns;\n        entry = other.entry;\n    }\n    int find(const int row,const int column,const vector<Entry> entry) const{\n        f(i,0,entry.size()){\n            if(row == entry[i].row && column == entry[i].column) return i;\n        }\n        return -1;\n    }\n    int finnd(const int row,const vector<Entry> entry,const int start) const{\n        f(i,start,entry.size()){\n            if(row == entry[i].row) return i;\n        }\n        return -1;\n    }\n    Sparse operator + (Sparse & sparse2){\n        Sparse ans(rows,columns);\n        f(i,0,entry.size()){\n            Entry temp = entry[i];\n            int index = find(entry[i].row,entry[i].column,sparse2.entry);\n            if(index != -1){\n                temp.value += sparse2.entry[index].value;\n            }\n            if(temp.value != 0) ans.entry.push_back(temp);\n        }\n        f(i,0,sparse2.entry.size()){\n            if(find(sparse2.entry[i].row,sparse2.entry[i].column,entry) == -1) ans.entry.push_back(sparse2.entry[i]);\n        }\n        return ans;\n    }\n    Sparse operator * (Sparse & sparse2){\n        Sparse ans(rows,sparse2.columns);\n        f(i,0,entry.size()){\n            int index = -1;\n            while(index < (int)sparse2.entry.size()){\n                index = finnd(entry[i].column,sparse2.entry,index + 1);\n                if(index == -1){\n                    break;\n                }\n                Entry temp;\n                temp.row = entry[i].row;\n                temp.column = sparse2.entry[index].column;\n                temp.value = entry[i].value * sparse2.entry[index].value;\n                int iindex = find(temp.row,temp.column,ans.entry);\n                if(iindex == -1) ans.entry.push_back(temp);\n                else ans.entry[iindex].value += temp.value;\n            }\n        }\n        return ans;\n    }\n    virtual int size(int dimension) const{\n        if(dimension == 1) return rows;\n        else return columns;\n    }\n    virtual void set(int row, int column, double value){\n        int index = find(row,column,entry);\n        if(index == -1){\n            Entry temp{row,column,value};\n            entry.push_back(temp);\n        }\n        else{\n            entry[index].value = value;\n        }\n    }\n\tvirtual double get(int row, int column) const{\n\t\tint index = find(row,column,entry);\n\t\treturn entry[index].value;\n\t}\n\tvirtual void print(){\n        f(i,0,(int)entry.size() - 1){\n            f(j,i+1,(int)entry.size()){\n                if(entry[i].row > entry[j].row || (entry[i].row == entry[j].row && entry[i].column > entry[j].column)){\n                    Entry temp;\n                    temp = entry[i];\n                    entry[i] = entry[j];\n                    entry[j] = temp;\n                }\n            }\n        }\n        f(i,0,(int)entry.size()){\n            cout << \"(\" << entry[i].row << \",\" << entry[i].column << \",\" << entry[i].value << \")\" << endl;\n        }\n\t}\n};",
            1591879422.7290902,
            100,
            "# 答案正确"
        ],
        [
            "8.6 (C++)",
            "王芯芸",
            "#include <iostream>\nusing namespace std;\n\nclass MyTensor:public Tensor<double>{\n private:\n  vector<double>nums;\n public:\n  MyTensor(vector<int>sizes):Tensor<double>(sizes){\n   int total=1;\n   for(int i=0;i<sizes.size();++i) total*=sizes[i];\n   for(int i=0;i<total;++i) nums.push_back(double());\n  };\n  double&get(const vector<int>&indexes){\n   int index=0;\n   for(int i=0;i<indexes.size();++i){\n    int temp=indexes[i];\n    for(int j=i+1;j<indexes.size();++j) temp*=indexes[j];\n    index+=temp;\n   }\n   return nums[index];\n  }\n \n}; ",
            1592451446.7499168,
            100,
            "# 答案正确"
        ],
        [
            "9.1 (C++)",
            "王芯芸",
            "class Circle\n{\nprivate:\n\tdouble data;\npublic:\n\tCircle(double num){\n\t\tdata = num;\n\t}\n\tbool operator < (Circle x){\n\t\treturn data < x.data;\n\t}\n\tbool operator <= (Circle x){\n\t\treturn data <= x.data;\n\t}\n\tbool operator == (Circle x){\n\t\treturn data == x.data;\n\t}\n\tbool operator != (Circle x){\n\t\treturn data != x.data;\n\t}\n\tbool operator > (Circle x){\n\t\treturn data > x.data;\n\t}\n\tbool operator >= (Circle x){\n\t\treturn data >= x.data;\n\t}\n};",
            1593080579.4494674,
            100,
            "# 答案正确"
        ],
        [
            "9.2 (C++)",
            "王芯芸",
            "class I\n{\nprivate:\n\tvector <int> dim;\npublic:\n\tI(int a, int b, int c){\n\t\tdim.push_back(a);\n\t\tdim.push_back(b);\n\t\tdim.push_back(c);\n\t}\n\tI(int a, int b, int c, int d){\n\t\tdim.push_back(a);\n\t\tdim.push_back(b);\n\t\tdim.push_back(c);\n\t\tdim.push_back(d);\n\t}\n\toperator vector<int>(){\n\t\treturn dim;\n\t}\n};",
            1593081090.518079,
            100,
            "# 答案正确"
        ],
        [
            "9.3 (C++)",
            "王芯芸",
            "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nclass Complex\n{\nprivate:\n\tdouble r_num;\n\tdouble i_num;\npublic:\n\tdouble real(){\n\t\treturn r_num;\n\t}\n\tdouble imag(){\n\t\treturn i_num;\n\t}\n\tComplex(double a, double b){\n\t\tr_num = a;\n\t\ti_num = b;\n\t}\n\tComplex(double a):r_num(a), i_num(0){\n\t}\n\tComplex(int a):r_num(a), i_num(0){\n\t}\n\tComplex operator += (Complex & a){\n\t\treturn *this + a;\n\t}\n\tComplex operator -= (Complex & a){\n\t\treturn *this -a;\n\t}\n\tComplex operator *= (Complex & a){\n\t\treturn *this * a;\n\t}\n\tComplex operator /= (Complex & a){\n\t\treturn *this / a;\n\t}\n\tbool operator == (Complex & a){\n\t\tif(a.real() != r_num || a.imag != i_num)return false;\n\t\treturn true;\n\t}\n\tbool operator != (Complex & a){\n\t\tif(a.real() != r_num || a.imag != i_num)return true;\n\t\treturn false;\n\t}\n};\nComplex operator + (Complex & a, Complex & b){\n\tComplex ans(a.real() + b.real(), a.imag() + b.imag());\n\treturn ans;\n}\nComplex operator - (Complex & a, Complex & b){\n\tComplex ans(a.real() - b.real(), a.imag() - b.imag());\n\treturn ans;\n}\nComplex operator * (Complex & a, Complex & b){\n\tdouble real = a.real() * b.real() - a.imag() * b.imag();\n\tdoubel imag = a.real() * b.imag() + a.imag() * b.real();\n\tComplex ans(real, imag);\n\treturn ans;\n}\nComplex operator + (Complex & a, Complex & b){\n\tdouble real = (a.real() * b.real() + a.imag() * b.imag()) / (b.real() * b.real + b.imag() * b.imag());\n\tdoubel imag = (a.imag() * b.real() - a.real() * b.imag()) / (b.real() * b.real + b.imag() * b.imag());\n\tComplex ans(real, imag);\n\treturn ans;\n}",
            1593082230.7160072,
            0,
            "In file included from main.cpp:5:0:\nsource.cpp: In member function ‘Complex Complex::operator+=(Complex&)’:\nsource.cpp:26:16: error: no match for ‘operator+’ (operand types are ‘Complex’ and ‘Complex’)\n   return *this + a;\n                ^\nIn file included from /usr/include/c++/5/bits/stl_algobase.h:67:0,\n                 from /usr/include/c++/5/bits/char_traits.h:39,\n                 from /usr/include/c++/5/ios:40,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/stl_iterator.h:334:5: note: candidate: template<class _Iterator> std::reverse_iterator<_Iterator> std::operator+(typename std::reverse_iterator<_Iterator>::difference_type, const std::reverse_iterator<_Iterator>&)\n     operator+(typename reverse_iterator<_Iterator>::difference_type __n,\n     ^\n/usr/include/c++/5/bits/stl_iterator.h:334:5: note:   template argument deduction/substitution failed:\nIn file included from main.cpp:5:0:\nsource.cpp:26:18: note:   ‘Complex’ is not derived from ‘const std::reverse_iterator<_Iterator>’\n   return *this + a;\n                  ^\nIn file included from /usr/include/c++/5/bits/stl_algobase.h:67:0,\n                 from /usr/include/c++/5/bits/char_traits.h:39,\n                 from /usr/include/c++/5/ios:40,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/stl_iterator.h:1152:5: note: candidate: template<class _Iterator> std::move_iterator<_Iterator> std::operator+(typename std::move_iterator<_Iterator>::difference_type, const std::move_iterator<_Iterator>&)\n     operator+(typename move_iterator<_Iterator>::difference_type __n,\n     ^\n/usr/include/c++/5/bits/stl_iterator.h:1152:5: note:   template argument deduction/substitution failed:\nIn file included from main.cpp:5:0:\nsource.cpp:26:18: note:   ‘Complex’ is not derived from ‘const std::move_iterator<_Iterator>’\n   return *this + a;\n                  ^\nIn file included from /usr/include/c++/5/string:52:0,\n                 from /usr/include/c++/5/bits/locale_classes.h:40,\n                 from /usr/include/c++/5/bits/ios_base.h:41,\n                 from /usr/include/c++/5/ios:42,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/basic_string.h:4783:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> std::__cxx11::basic_string<_CharT, _Traits, _Alloc> std::operator+(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)\n     operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n     ^\n/usr/include/c++/5/bits/basic_string.h:4783:5: note:   template argument deduction/substitution failed:\nIn file included from main.cpp:5:0:\nsource.cpp:26:18: note:   ‘Complex’ is not derived from ‘const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>’\n   return *this + a;\n                  ^\nIn file included from /usr/include/c++/5/string:53:0,\n                 from /usr/include/c++/5/bits/locale_classes.h:40,\n                 from /usr/include/c++/5/bits/ios_base.h:41,\n                 from /usr/include/c++/5/ios:42,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/basic_string.tcc:1151:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> std::__cxx11::basic_string<_CharT, _Traits, _Alloc> std::operator+(const _CharT*, const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)\n     operator+(const _CharT* __lhs,\n     ^\n/usr/include/c++/5/bits/basic_string.tcc:1151:5: note:   template argument deduction/substitution failed:\nIn file included from main.cpp:5:0:\nsource.cpp:26:18: note:   mismatched types ‘const _CharT*’ and ‘Complex’\n   return *this + a;\n                  ^\nIn file included from /usr/include/c++/5/string:53:0,\n                 from /usr/include/c++/5/bits/locale_classes.h:40,\n                 from /usr/include/c++/5/bits/ios_base.h:41,\n                 from /usr/include/c++/5/ios:42,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/basic_string.tcc:1167:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> std::__cxx11::basic_string<_CharT, _Traits, _Alloc> std::operator+(_CharT, const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)\n     operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n     ^\n/usr/include/c++/5/bits/basic_string.tcc:1167:5: note:   template argument deduction/substitution failed:\nIn file included from main.cpp:5:0:\nsource.cpp:26:18: note:   ‘Complex’ is not derived from ‘const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>’\n   return *this + a;\n                  ^\nIn file included from /usr/include/c++/5/string:52:0,\n                 from /usr/include/c++/5/bits/locale_classes.h:40,\n                 from /usr/include/c++/5/bits/ios_base.h:41,\n                 from /usr/include/c++/5/ios:42,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/basic_string.h:4820:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> std::__cxx11::basic_string<_CharT, _Traits, _Alloc> std::operator+(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)\n     operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n     ^\n/usr/include/c++/5/bits/basic_string.h:4820:5: note:   template argument deduction/substitution failed:\nIn file included from main.cpp:5:0:\nsource.cpp:26:18: note:   ‘Complex’ is not derived from ‘const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>’\n   return *this + a;\n                  ^\nIn file included from /usr/include/c++/5/string:52:0,\n                 from /usr/include/c++/5/bits/locale_classes.h:40,\n                 from /usr/include/c++/5/bits/ios_base.h:41,\n                 from /usr/include/c++/5/ios:42,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/basic_string.h:4836:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> std::__cxx11::basic_string<_CharT, _Traits, _Alloc> std::operator+(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, _CharT)\n     operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)\n     ^\n/usr/include/c++/5/bits/basic_string.h:4836:5: note:   template argument deduction/substitution failed:\nIn file included from main.cpp:5:0:\nsource.cpp:26:18: note:   ‘Complex’ is not derived from ‘const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>’\n   return *this + a;\n                  ^\nIn file included from /usr/include/c++/5/string:52:0,\n                 from /usr/include/c++/5/bits/locale_classes.h:40,\n                 from /usr/include/c++/5/bits/ios_base.h:41,\n                 from /usr/include/c++/5/ios:42,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/basic_string.h:4848:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> std::__cxx11::basic_string<_CharT, _Traits, _Alloc> std::operator+(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&&, const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)\n     operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,\n     ^\n/usr/include/c++/5/bits/basic_string.h:4848:5: note:   template argument deduction/substitution failed:\nIn file included from main.cpp:5:0:\nsource.cpp:26:18: note:   ‘Complex’ is not derived from ‘std::__cxx11::basic_string<_CharT, _Traits, _Alloc>’\n   return *this + a;\n                  ^\nIn file included from /usr/include/c++/5/string:52:0,\n                 from /usr/include/c++/5/bits/locale_classes.h:40,\n                 from /usr/include/c++/5/bits/ios_base.h:41,\n                 from /usr/include/c++/5/ios:42,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/basic_string.h:4854:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> std::__cxx11::basic_string<_CharT, _Traits, _Alloc> std::operator+(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&&)\n     operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n     ^\n/usr/include/c++/5/bits/basic_string.h:4854:5: note:   template argument deduction/substitution failed:\nIn file included from main.cpp:5:0:\nsource.cpp:26:18: note:   ‘Complex’ is not derived from ‘const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>’\n   return *this + a;\n                  ^\nIn file included from /usr/include/c++/5/string:52:0,\n                 from /usr/include/c++/5/bits/locale_classes.h:40,\n                 from /usr/include/c++/5/bits/ios_base.h:41,\n                 from /usr/include/c++/5/ios:42,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/basic_string.h:4860:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> std::__cxx11::basic_string<_CharT, _Traits, _Alloc> std::operator+(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&&, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&&)\n     operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,\n     ^\n/usr/include/c++/5/bits/basic_string.h:4860:5: note:   template argument deduction/substitution failed:\nIn file included from main.cpp:5:0:\nsource.cpp:26:18: note:   ‘Complex’ is not derived from ‘std::__cxx11::basic_string<_CharT, _Traits, _Alloc>’\n   return *this + a;\n                  ^\nIn file included from /usr/include/c++/5/string:52:0,\n                 from /usr/include/c++/5/bits/locale_classes.h:40,\n                 from /usr/include/c++/5/bits/ios_base.h:41,\n                 from /usr/include/c++/5/ios:42,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/basic_string.h:4872:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> std::__cxx11::basic_string<_CharT, _Traits, _Alloc> std::operator+(const _CharT*, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&&)\n     operator+(const _CharT* __lhs,\n     ^\n/usr/include/c++/5/bits/basic_string.h:4872:5: note:   template argument deduction/substitution failed:\nIn file included from main.cpp:5:0:\nsource.cpp:26:18: note:   mismatched types ‘const _CharT*’ and ‘Complex’\n   return *this + a;\n                  ^\nIn file included from /usr/include/c++/5/string:52:0,\n                 from /usr/include/c++/5/bits/locale_classes.h:40,\n                 from /usr/include/c++/5/bits/ios_base.h:41,\n                 from /usr/include/c++/5/ios:42,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/basic_string.h:4878:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> std::__cxx11::basic_string<_CharT, _Traits, _Alloc> std::operator+(_CharT, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&&)\n     operator+(_CharT __lhs,\n     ^\n/usr/include/c++/5/bits/basic_string.h:4878:5: note:   template argument deduction/substitution failed:\nIn file included from main.cpp:5:0:\nsource.cpp:26:18: note:   ‘Complex’ is not derived from ‘std::__cxx11::basic_string<_CharT, _Traits, _Alloc>’\n   return *this + a;\n                  ^\nIn file included from /usr/include/c++/5/string:52:0,\n                 from /usr/include/c++/5/bits/locale_classes.h:40,\n                 from /usr/include/c++/5/bits/ios_base.h:41,\n                 from /usr/include/c++/5/ios:42,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/basic_string.h:4884:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> std::__cxx11::basic_string<_CharT, _Traits, _Alloc> std::operator+(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&&, const _CharT*)\n     operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,\n     ^\n/usr/include/c++/5/bits/basic_string.h:4884:5: note:   template argument deduction/substitution failed:\nIn file included from main.cpp:5:0:\nsource.cpp:26:18: note:   ‘Complex’ is not derived from ‘std::__cxx11::basic_string<_CharT, _Traits, _Alloc>’\n   return *this + a;\n                  ^\nIn file included from /usr/include/c++/5/string:52:0,\n                 from /usr/include/c++/5/bits/locale_classes.h:40,\n                 from /usr/include/c++/5/bits/ios_base.h:41,\n                 from /usr/include/c++/5/ios:42,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/basic_string.h:4890:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> std::__cxx11::basic_string<_CharT, _Traits, _Alloc> std::operator+(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&&, _CharT)\n     operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,\n     ^\n/usr/include/c++/5/bits/basic_string.h:4890:5: note:   template argument deduction/substitution failed:\nIn file included from main.cpp:5:0:\nsource.cpp:26:18: note:   ‘Complex’ is not derived from ‘std::__cxx11::basic_string<_CharT, _Traits, _Alloc>’\n   return *this + a;\n                  ^\nsource.cpp: In member function ‘Complex Complex::operator-=(Complex&)’:\nsource.cpp:29:16: error: no match for ‘operator-’ (operand types are ‘Complex’ and ‘Complex’)\n   return *this -a;\n                ^\nIn file included from /usr/include/c++/5/bits/stl_algobase.h:67:0,\n                 from /usr/include/c++/5/bits/char_traits.h:39,\n                 from /usr/include/c++/5/ios:40,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/stl_iterator.h:328:5: note: candidate: template<class _Iterator> typename std::reverse_iterator<_Iterator>::difference_type std::operator-(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)\n     operator-(const reverse_iterator<_Iterator>& __x,\n     ^\n/usr/include/c++/5/bits/stl_iterator.h:328:5: note:   template argument deduction/substitution failed:\nIn file included from main.cpp:5:0:\nsource.cpp:29:17: note:   ‘Complex’ is not derived from ‘const std::reverse_iterator<_Iterator>’\n   return *this -a;\n                 ^\nIn file included from /usr/include/c++/5/bits/stl_algobase.h:67:0,\n                 from /usr/include/c++/5/bits/char_traits.h:39,\n                 from /usr/include/c++/5/ios:40,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/stl_iterator.h:380:5: note: candidate: template<class _IteratorL, class _IteratorR> decltype ((__y.base() - __x.base())) std::operator-(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)\n     operator-(const reverse_iterator<_IteratorL>& __x,\n     ^\n/usr/include/c++/5/bits/stl_iterator.h:380:5: note:   template argument deduction/substitution failed:\nIn file included from main.cpp:5:0:\nsource.cpp:29:17: note:   ‘Complex’ is not derived from ‘const std::reverse_iterator<_Iterator>’\n   return *this -a;\n                 ^\nIn file included from /usr/include/c++/5/bits/stl_algobase.h:67:0,\n                 from /usr/include/c++/5/bits/char_traits.h:39,\n                 from /usr/include/c++/5/ios:40,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/stl_iterator.h:1138:5: note: candidate: template<class _IteratorL, class _IteratorR> decltype ((__x.base() - __y.base())) std::operator-(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)\n     operator-(const move_iterator<_IteratorL>& __x,\n     ^\n/usr/include/c++/5/bits/stl_iterator.h:1138:5: note:   template argument deduction/substitution failed:\nIn file included from main.cpp:5:0:\nsource.cpp:29:17: note:   ‘Complex’ is not derived from ‘const std::move_iterator<_Iterator>’\n   return *this -a;\n                 ^\nIn file included from /usr/include/c++/5/bits/stl_algobase.h:67:0,\n                 from /usr/include/c++/5/bits/char_traits.h:39,\n                 from /usr/include/c++/5/ios:40,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/stl_iterator.h:1145:5: note: candidate: template<class _Iterator> decltype ((__x.base() - __y.base())) std::operator-(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)\n     operator-(const move_iterator<_Iterator>& __x,\n     ^\n/usr/include/c++/5/bits/stl_iterator.h:1145:5: note:   template argument deduction/substitution failed:\nIn file included from main.cpp:5:0:\nsource.cpp:29:17: note:   ‘Complex’ is not derived from ‘const std::move_iterator<_Iterator>’\n   return *this -a;\n                 ^\nsource.cpp: In member function ‘Complex Complex::operator*=(Complex&)’:\nsource.cpp:32:16: error: no match for ‘operator*’ (operand types are ‘Complex’ and ‘Complex’)\n   return *this * a;\n                ^\nsource.cpp: In member function ‘Complex Complex::operator/=(Complex&)’:\nsource.cpp:35:16: error: no match for ‘operator/’ (operand types are ‘Complex’ and ‘Complex’)\n   return *this / a;\n                ^\nsource.cpp: In member function ‘bool Complex::operator==(Complex&)’:\nsource.cpp:38:37: error: invalid use of member function (did you forget the ‘()’ ?)\n   if(a.real() != r_num || a.imag != i_num)return false;\n                                     ^\nsource.cpp: In member function ‘bool Complex::operator!=(Complex&)’:\nsource.cpp:42:37: error: invalid use of member function (did you forget the ‘()’ ?)\n   if(a.real() != r_num || a.imag != i_num)return true;\n                                     ^\nsource.cpp: In function ‘Complex operator*(Complex&, Complex&)’:\nsource.cpp:56:2: error: ‘doubel’ was not declared in this scope\n  doubel imag = a.real() * b.imag() + a.imag() * b.real();\n  ^\nsource.cpp:57:20: error: ‘imag’ was not declared in this scope\n  Complex ans(real, imag);\n                    ^\nsource.cpp: In function ‘Complex operator+(Complex&, Complex&)’:\nsource.cpp:60:9: error: redefinition of ‘Complex operator+(Complex&, Complex&)’\n Complex operator + (Complex & a, Complex & b){\n         ^\nsource.cpp:46:9: note: ‘Complex operator+(Complex&, Complex&)’ previously defined here\n Complex operator + (Complex & a, Complex & b){\n         ^\nsource.cpp:61:76: error: invalid use of member function (did you forget the ‘()’ ?)\n  double real = (a.real() * b.real() + a.imag() * b.imag()) / (b.real() * b.real + b.imag() * b.imag());\n                                                                            ^\nsource.cpp:62:2: error: ‘doubel’ was not declared in this scope\n  doubel imag = (a.imag() * b.real() - a.real() * b.imag()) / (b.real() * b.real + b.imag() * b.imag());\n  ^\nsource.cpp:63:20: error: ‘imag’ was not declared in this scope\n  Complex ans(real, imag);\n                    ^\nmain.cpp: In function ‘int main()’:\nmain.cpp:18:22: error: no match for ‘operator/’ (operand types are ‘Complex’ and ‘Complex’)\n     Complex c10 = c1 / c2;\n                      ^\nmain.cpp:19:22: error: no match for ‘operator+’ (operand types are ‘int’ and ‘Complex’)\n     Complex c11 = 10 + c2;\n                      ^\nIn file included from main.cpp:5:0:\nsource.cpp:46:9: note: candidate: Complex operator+(Complex&, Complex&) <near match>\n Complex operator + (Complex & a, Complex & b){\n         ^\nsource.cpp:46:9: note:   conversion of argument 1 would be ill-formed:\nmain.cpp:19:24: error: invalid initialization of non-const reference of type ‘Complex&’ from an rvalue of type ‘Complex’\n     Complex c11 = 10 + c2;\n                        ^\nIn file included from main.cpp:5:0:\nsource.cpp:23:2: note:   after user-defined conversion: Complex::Complex(int)\n  Complex(int a):r_num(a), i_num(0){\n  ^\nIn file included from /usr/include/c++/5/string:52:0,\n                 from /usr/include/c++/5/bits/locale_classes.h:40,\n                 from /usr/include/c++/5/bits/ios_base.h:41,\n                 from /usr/include/c++/5/ios:42,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/basic_string.h:4890:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> std::__cxx11::basic_string<_CharT, _Traits, _Alloc> std::operator+(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&&, _CharT)\n     operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,\n     ^\n/usr/include/c++/5/bits/basic_string.h:4890:5: note:   template argument deduction/substitution failed:\nmain.cpp:19:24: note:   mismatched types ‘std::__cxx11::basic_string<_CharT, _Traits, _Alloc>’ and ‘int’\n     Complex c11 = 10 + c2;\n                        ^\nIn file included from /usr/include/c++/5/string:52:0,\n                 from /usr/include/c++/5/bits/locale_classes.h:40,\n                 from /usr/include/c++/5/bits/ios_base.h:41,\n                 from /usr/include/c++/5/ios:42,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/basic_string.h:4884:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> std::__cxx11::basic_string<_CharT, _Traits, _Alloc> std::operator+(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&&, const _CharT*)\n     operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,\n     ^\n/usr/include/c++/5/bits/basic_string.h:4884:5: note:   template argument deduction/substitution failed:\nmain.cpp:19:24: note:   mismatched types ‘std::__cxx11::basic_string<_CharT, _Traits, _Alloc>’ and ‘int’\n     Complex c11 = 10 + c2;\n                        ^\nIn file included from /usr/include/c++/5/string:52:0,\n                 from /usr/include/c++/5/bits/locale_classes.h:40,\n                 from /usr/include/c++/5/bits/ios_base.h:41,\n                 from /usr/include/c++/5/ios:42,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/basic_string.h:4878:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> std::__cxx11::basic_string<_CharT, _Traits, _Alloc> std::operator+(_CharT, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&&)\n     operator+(_CharT __lhs,\n     ^\n/usr/include/c++/5/bits/basic_string.h:4878:5: note:   template argument deduction/substitution failed:\nmain.cpp:19:24: note:   ‘Complex’ is not derived from ‘std::__cxx11::basic_string<_CharT, _Traits, _Alloc>’\n     Complex c11 = 10 + c2;\n                        ^\nIn file included from /usr/include/c++/5/string:52:0,\n                 from /usr/include/c++/5/bits/locale_classes.h:40,\n                 from /usr/include/c++/5/bits/ios_base.h:41,\n                 from /usr/include/c++/5/ios:42,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/basic_string.h:4872:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> std::__cxx11::basic_string<_CharT, _Traits, _Alloc> std::operator+(const _CharT*, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&&)\n     operator+(const _CharT* __lhs,\n     ^\n/usr/include/c++/5/bits/basic_string.h:4872:5: note:   template argument deduction/substitution failed:\nmain.cpp:19:24: note:   mismatched types ‘const _CharT*’ and ‘int’\n     Complex c11 = 10 + c2;\n                        ^\nIn file included from /usr/include/c++/5/string:52:0,\n                 from /usr/include/c++/5/bits/locale_classes.h:40,\n                 from /usr/include/c++/5/bits/ios_base.h:41,\n                 from /usr/include/c++/5/ios:42,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/basic_string.h:4860:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> std::__cxx11::basic_string<_CharT, _Traits, _Alloc> std::operator+(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&&, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&&)\n     operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,\n     ^\n/usr/include/c++/5/bits/basic_string.h:4860:5: note:   template argument deduction/substitution failed:\nmain.cpp:19:24: note:   mismatched types ‘std::__cxx11::basic_string<_CharT, _Traits, _Alloc>’ and ‘int’\n     Complex c11 = 10 + c2;\n                        ^\nIn file included from /usr/include/c++/5/string:52:0,\n                 from /usr/include/c++/5/bits/locale_classes.h:40,\n                 from /usr/include/c++/5/bits/ios_base.h:41,\n                 from /usr/include/c++/5/ios:42,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/basic_string.h:4854:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> std::__cxx11::basic_string<_CharT, _Traits, _Alloc> std::operator+(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&&)\n     operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n     ^\n/usr/include/c++/5/bits/basic_string.h:4854:5: note:   template argument deduction/substitution failed:\nmain.cpp:19:24: note:   mismatched types ‘const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>’ and ‘int’\n     Complex c11 = 10 + c2;\n                        ^\nIn file included from /usr/include/c++/5/string:52:0,\n                 from /usr/include/c++/5/bits/locale_classes.h:40,\n                 from /usr/include/c++/5/bits/ios_base.h:41,\n                 from /usr/include/c++/5/ios:42,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/basic_string.h:4848:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> std::__cxx11::basic_string<_CharT, _Traits, _Alloc> std::operator+(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&&, const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)\n     operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,\n     ^\n/usr/include/c++/5/bits/basic_string.h:4848:5: note:   template argument deduction/substitution failed:\nmain.cpp:19:24: note:   mismatched types ‘std::__cxx11::basic_string<_CharT, _Traits, _Alloc>’ and ‘int’\n     Complex c11 = 10 + c2;\n                        ^\nIn file included from /usr/include/c++/5/string:52:0,\n                 from /usr/include/c++/5/bits/locale_classes.h:40,\n                 from /usr/include/c++/5/bits/ios_base.h:41,\n                 from /usr/include/c++/5/ios:42,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/basic_string.h:4836:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> std::__cxx11::basic_string<_CharT, _Traits, _Alloc> std::operator+(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, _CharT)\n     operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)\n     ^\n/usr/include/c++/5/bits/basic_string.h:4836:5: note:   template argument deduction/substitution failed:\nmain.cpp:19:24: note:   mismatched types ‘const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>’ and ‘int’\n     Complex c11 = 10 + c2;\n                        ^\nIn file included from /usr/include/c++/5/string:52:0,\n                 from /usr/include/c++/5/bits/locale_classes.h:40,\n                 from /usr/include/c++/5/bits/ios_base.h:41,\n                 from /usr/include/c++/5/ios:42,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/basic_string.h:4820:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> std::__cxx11::basic_string<_CharT, _Traits, _Alloc> std::operator+(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)\n     operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n     ^\n/usr/include/c++/5/bits/basic_string.h:4820:5: note:   template argument deduction/substitution failed:\nmain.cpp:19:24: note:   mismatched types ‘const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>’ and ‘int’\n     Complex c11 = 10 + c2;\n                        ^\nIn file included from /usr/include/c++/5/string:53:0,\n                 from /usr/include/c++/5/bits/locale_classes.h:40,\n                 from /usr/include/c++/5/bits/ios_base.h:41,\n                 from /usr/include/c++/5/ios:42,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/basic_string.tcc:1167:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> std::__cxx11::basic_string<_CharT, _Traits, _Alloc> std::operator+(_CharT, const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)\n     operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n     ^\n/usr/include/c++/5/bits/basic_string.tcc:1167:5: note:   template argument deduction/substitution failed:\nmain.cpp:19:24: note:   ‘Complex’ is not derived from ‘const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>’\n     Complex c11 = 10 + c2;\n                        ^\nIn file included from /usr/include/c++/5/string:53:0,\n                 from /usr/include/c++/5/bits/locale_classes.h:40,\n                 from /usr/include/c++/5/bits/ios_base.h:41,\n                 from /usr/include/c++/5/ios:42,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/basic_string.tcc:1151:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> std::__cxx11::basic_string<_CharT, _Traits, _Alloc> std::operator+(const _CharT*, const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)\n     operator+(const _CharT* __lhs,\n     ^\n/usr/include/c++/5/bits/basic_string.tcc:1151:5: note:   template argument deduction/substitution failed:\nmain.cpp:19:24: note:   mismatched types ‘const _CharT*’ and ‘int’\n     Complex c11 = 10 + c2;\n                        ^\nIn file included from /usr/include/c++/5/string:52:0,\n                 from /usr/include/c++/5/bits/locale_classes.h:40,\n                 from /usr/include/c++/5/bits/ios_base.h:41,\n                 from /usr/include/c++/5/ios:42,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/basic_string.h:4783:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> std::__cxx11::basic_string<_CharT, _Traits, _Alloc> std::operator+(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)\n     operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n     ^\n/usr/include/c++/5/bits/basic_string.h:4783:5: note:   template argument deduction/substitution failed:\nmain.cpp:19:24: note:   mismatched types ‘const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>’ and ‘int’\n     Complex c11 = 10 + c2;\n                        ^\nIn file included from /usr/include/c++/5/bits/stl_algobase.h:67:0,\n                 from /usr/include/c++/5/bits/char_traits.h:39,\n                 from /usr/include/c++/5/ios:40,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/stl_iterator.h:1152:5: note: candidate: template<class _Iterator> std::move_iterator<_Iterator> std::operator+(typename std::move_iterator<_Iterator>::difference_type, const std::move_iterator<_Iterator>&)\n     operator+(typename move_iterator<_Iterator>::difference_type __n,\n     ^\n/usr/include/c++/5/bits/stl_iterator.h:1152:5: note:   template argument deduction/substitution failed:\nmain.cpp:19:24: note:   ‘Complex’ is not derived from ‘const std::move_iterator<_Iterator>’\n     Complex c11 = 10 + c2;\n                        ^\nIn file included from /usr/include/c++/5/bits/stl_algobase.h:67:0,\n                 from /usr/include/c++/5/bits/char_traits.h:39,\n                 from /usr/include/c++/5/ios:40,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/stl_iterator.h:334:5: note: candidate: template<class _Iterator> std::reverse_iterator<_Iterator> std::operator+(typename std::reverse_iterator<_Iterator>::difference_type, const std::reverse_iterator<_Iterator>&)\n     operator+(typename reverse_iterator<_Iterator>::difference_type __n,\n     ^\n/usr/include/c++/5/bits/stl_iterator.h:334:5: note:   template argument deduction/substitution failed:\nmain.cpp:19:24: note:   ‘Complex’ is not derived from ‘const std::reverse_iterator<_Iterator>’\n     Complex c11 = 10 + c2;\n                        ^\nmain.cpp:20:22: error: no match for ‘operator-’ (operand types are ‘Complex’ and ‘int’)\n     Complex c12 = c2 - 20;\n                      ^\nIn file included from main.cpp:5:0:\nsource.cpp:50:9: note: candidate: Complex operator-(Complex&, Complex&) <near match>\n Complex operator - (Complex & a, Complex & b){\n         ^\nsource.cpp:50:9: note:   conversion of argument 2 would be ill-formed:\nmain.cpp:20:24: error: invalid initialization of non-const reference of type ‘Complex&’ from an rvalue of type ‘Complex’\n     Complex c12 = c2 - 20;\n                        ^\nIn file included from main.cpp:5:0:\nsource.cpp:23:2: note:   after user-defined conversion: Complex::Complex(int)\n  Complex(int a):r_num(a), i_num(0){\n  ^\nIn file included from /usr/include/c++/5/bits/stl_algobase.h:67:0,\n                 from /usr/include/c++/5/bits/char_traits.h:39,\n                 from /usr/include/c++/5/ios:40,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/stl_iterator.h:1145:5: note: candidate: template<class _Iterator> decltype ((__x.base() - __y.base())) std::operator-(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)\n     operator-(const move_iterator<_Iterator>& __x,\n     ^\n/usr/include/c++/5/bits/stl_iterator.h:1145:5: note:   template argument deduction/substitution failed:\nmain.cpp:20:24: note:   ‘Complex’ is not derived from ‘const std::move_iterator<_Iterator>’\n     Complex c12 = c2 - 20;\n                        ^\nIn file included from /usr/include/c++/5/bits/stl_algobase.h:67:0,\n                 from /usr/include/c++/5/bits/char_traits.h:39,\n                 from /usr/include/c++/5/ios:40,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/stl_iterator.h:1138:5: note: candidate: template<class _IteratorL, class _IteratorR> decltype ((__x.base() - __y.base())) std::operator-(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)\n     operator-(const move_iterator<_IteratorL>& __x,\n     ^\n/usr/include/c++/5/bits/stl_iterator.h:1138:5: note:   template argument deduction/substitution failed:\nmain.cpp:20:24: note:   ‘Complex’ is not derived from ‘const std::move_iterator<_Iterator>’\n     Complex c12 = c2 - 20;\n                        ^\nIn file included from /usr/include/c++/5/bits/stl_algobase.h:67:0,\n                 from /usr/include/c++/5/bits/char_traits.h:39,\n                 from /usr/include/c++/5/ios:40,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/stl_iterator.h:380:5: note: candidate: template<class _IteratorL, class _IteratorR> decltype ((__y.base() - __x.base())) std::operator-(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)\n     operator-(const reverse_iterator<_IteratorL>& __x,\n     ^\n/usr/include/c++/5/bits/stl_iterator.h:380:5: note:   template argument deduction/substitution failed:\nmain.cpp:20:24: note:   ‘Complex’ is not derived from ‘const std::reverse_iterator<_Iterator>’\n     Complex c12 = c2 - 20;\n                        ^\nIn file included from /usr/include/c++/5/bits/stl_algobase.h:67:0,\n                 from /usr/include/c++/5/bits/char_traits.h:39,\n                 from /usr/include/c++/5/ios:40,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/stl_iterator.h:328:5: note: candidate: template<class _Iterator> typename std::reverse_iterator<_Iterator>::difference_type std::operator-(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)\n     operator-(const reverse_iterator<_Iterator>& __x,\n     ^\n/usr/include/c++/5/bits/stl_iterator.h:328:5: note:   template argument deduction/substitution failed:\nmain.cpp:20:24: note:   ‘Complex’ is not derived from ‘const std::reverse_iterator<_Iterator>’\n     Complex c12 = c2 - 20;\n                        ^\n"
        ],
        [
            "9.4 (C++)",
            "王芯芸",
            "#include <iostream>\nusing namespace std;\nclass Complex{\n\tprivate:\n\t\tdouble real;\n\t\tdouble imag;\n\tpublic:\n\t\tComplex (double a,double b){\n\t\t\treal = a;\n\t\t\timag = b;\n\t\t}\n\t\tComplex(){\n\t\t\treal = 0;\n\t\t\timag = 0;\n\t\t}\n\t\tComplex operator+(Complex a){\n\t\t\tComplex ans(real+a.get_real(),imag+a.get_imag());\n\t\t\treturn ans;\n\t\t}\n\t\tComplex operator-(Complex a){\n\t\t\tComplex ans(real-a.get_real(),imag-a.get_imag());\n\t\t\treturn ans;\n\t\t}\n\t\tdouble get_real(){\n\t\t\treturn real;\n\t\t}\n\t\tdouble get_imag(){\n\t\t\treturn imag;\n\t\t}\n};\nostream &operator<<(ostream &out,Complex &a){\n\tout<<a.get_real()<<\" \"<<\"+\"<<\" \"<<a.get_imag()<<\" i\";\n\treturn out;\n}\nistream &operator>>(istream &in,Complex &a){\n\tdouble x,y;\n\tin>>x>>y;\n\tComplex temp(x,y);\n\ta = temp;\n\treturn in;\n}",
            1593083120.150251,
            100,
            "# 答案正确"
        ],
        [
            "9.5 (C++)",
            "王芯芸",
            "#include <iostream>\nusing namespace std;\n\nclass Complex\n{\nprivate:\n\tdouble r_num;\n\tdouble i_num;\npublic:\n\tComplex(){\n\t\tr_num = 0;\n\t\ti_num = 0;\n\t}\n\tComplex(double a, double b){\n\t\tr_num = a;\n\t\ti_num = b;\n\t}\n\tComplex & operator ++ (){\n\t\tr_num = r_num + 1;\n\t\treturn *this;\n\t}\n\tComplex operator ++ (int){\n\t\tComplex temp = *this;\n\t\tr_num = r_num + 1;\n\t\treturn temp;\n\t}\n\tdouble get_real(){\n\t\treturn r_num;\n\t}\n\tdouble get_imag(){\n\t\treturn i_num;\n\t}\n\toperator double(){\n\t\treturn r_num;\n\t}\n};\nostream & operator << (ostream & out, Complex a){\n\tout << a.get_real() << \" \" << \"+\" << \" \" << a.get_imag() << \" i\";\n\treturn out;\n}\nistream & operator >> (istream & in,Complex & a){\n\tdouble x, y;\n\tin >> x >> y;\n\tComplex temp(x, y);\n\ta = temp;\n\treturn in;\n}",
            1593083531.6299186,
            100,
            "# 答案正确"
        ],
        [
            "9.6 (C++)",
            "王芯芸",
            "class Tensor\n{\n\tvector <int> sizes;\n\tvector <double> values;\n\tint _index (const vector <int> & indexes) const {\n\t\tint index = 0;\n\t\tfor(int i = 0; i < this->sizes.size(); i++){\n\t\t\tindex *= sizes[i];\n\t\t\tindex += indexes[i];\n\t\t}\n\t\treturn index;\n\t}\npublic:\n\tint numel () const {\n\t\tif(this->sizes.size() == 0)return 0;\n\t\tint size = 1;\n\t\tfor(int i = 0; i < this->sizes.size(); i++)size *= sizes[i];\n\t\treturn size;\n\t}\n\tTensor (int a, int b, int c) {\n\t\tsizes.push_back(a);\n\t\tsizes.push_back(b);\n\t\tsizes.push_back(c);\n\t\tvalues.resize(this->numel());\n\t}\n\tTensor (int a, int b, int c, int d) {\n\t\tsizes.push_back(a);\n\t\tsizes.push_back(b);\n\t\tsizes.push_back(c);\n\t\tsizes.push_back(d);\n\t\tvalues.resize(this->numel());\n\t}\n\tdouble & operator () (int a, int b, int c) {\n\t\tvector <int> temp;\n\t\ttemp.push_back(a);\n\t\ttemp.push_back(b);\n\t\ttemp.push_back(c);\n\t\tint pos = _index(temp);\n\t\treturn values[pos];\n\t}\n\tdouble & operator () (int a, int b, int c, int d) {\n\t\tvector <int> temp;\n\t\ttemp.push_back(a);\n\t\ttemp.push_back(b);\n\t\ttemp.push_back(c);\n\t\ttemp.push_back(d);\n\t\tint pos = _index(temp);\n\t\treturn values[pos];\n\t}\n};",
            1593084379.2582204,
            100,
            "# 答案正确"
        ],
        [
            "9.7 (C++)",
            "王芯芸",
            "class Tensor\n{\npublic:\n\tint dim;\n\tvector <int> sizes;\n\tvector <double> values;\n\tint _index (const vector <int> & indexes) const {\n\t\tint index = 0;\n\t\tfor(int i = 0; i < this->sizes.size(); i++){\n\t\t\tindex *= sizes[i];\n\t\t\tindex += indexes[i];\n\t\t}\n\t\treturn index;\n\t}\n\tint numel () const {\n\t\tif(this->sizes.size() == 0)return 0;\n\t\tint size = 1;\n\t\tfor(int i = 0; i < this->sizes.size(); i++)size *= sizes[i];\n\t\treturn size;\n\t}\n\tTensor () {\n\t\tdim = 0;\n\t}\n};\nistream & operator >> (istream & in, Tensor & a) {\n\tin >> a.dim;\n\ta.sizes.resize(a.dim);\n\tfor(int i = 0; i < a.sizes.size(); i++)in >> a.sizes[i];\n\ta.values.resize(a.numel());\n\tfor(int i = 0; i < a.values.size(); i++)in >> a.values[i];\n\treturn in;\n}\nostream & operator << (ostream & out, Tensor a) {\n\tout << a.dim << endl;\n\tfor(int i = 0; i < a.sizes.size(); i++)out << a.sizes[i] << \" \";\n\tout << endl << endl;\n\tint x = a.sizes.size() - 1;\n\tint y = a.sizes.size() - 2;\n\tfor(int i = 0; i < a.values.size(); i++){\n\t\tout << a.values[i] << \" \";\n\t\tif((i + 1) % a.sizes[x] == 0) out << endl;\n\t\tif((i + 1) % (a.sizes[x] * a.sizes[y]) == 0)out << endl;\n\t}\n\treturn out;\n}",
            1593085205.389221,
            100,
            "# 答案正确"
        ],
        [
            "10.2 (C++)",
            "王芯芸",
            "catch (NonPositiveValueException & ex) {\n cout << \"caught: NonPositiveValueException\" << endl;\n}\ncatch (out_of_range & ex) {\n cout << \"caught: out_of_range\" << endl;\n}\n",
            1593660043.2727377,
            100,
            "# 答案正确"
        ],
        [
            "10.1 (C++)",
            "王芯芸",
            "#include <iostream>\n#include<stdexcept>\nusing namespace std;\nclass MatrixSizesDoNotMatchException{\n\tpublic:\n\t\tMatrixSizesDoNotMatchException(){\n\t\t}\n};\ndouble Matrix:: get(int row,int column)const{\n\tif(row<0||row>rows)throw out_of_range(\"haha\");\n\tif(column<0||column>columns)throw out_of_range(\"haha\");\n\tint pos = (row-1)*columns + column - 1;\n\treturn elements[pos];\n}\nvoid Matrix:: set(int row,int column,double value){\n\tif(row<0||row>rows)throw out_of_range(\"haha\");\n\tif(column<0||column>columns)throw out_of_range(\"haha\");\n\tint pos = (row-1)*columns + column - 1;\n\telements[pos] = value;\n}\nMatrix Matrix::operator+(const Matrix&matrix2)const{\n\tif(rows!=matrix2.size(1)||columns!=matrix2.size(2))\n\t\tthrow MatrixSizesDoNotMatchException();\n\tMatrix ans(rows,columns);\n\tfor(int i = 1;i <= rows;i++){\n\t\tfor(int j = 1;j <= columns;j++){\n\t\t\tdouble ans1 = (*this).get(i,j) + matrix2.get(i,j);\n\t\t\tans.set(i,j,ans1);\n\t\t}\n\t}\n\treturn ans;\n}",
            1593689967.7615447,
            100,
            "# 答案正确"
        ],
        [
            "2020-07-09 LAB",
            "王芯芸",
            "#include<iostream>\n#include<vector>\nusing namespace std;\n\nclass Integer{\nprivate:\n    int num;\n    static vector<Integer*> index;\npublic:\n    Integer(): num(0){\n        index.push_back(this);\n    }\n    Integer(int x): num(x){\n        index.push_back(this);\n    }\n    void change_value(const int& x){num = x;}\n    int get_value()const{return num;}\n    static void increase_all(const Integer& x){\n        for(int i = 0;i < index.size();i++){\n            index[i]->change_value(index[i]->get_value()+x.get_value());\n        }\n    }\n};\nvector<Integer*> Integer::index = vector<Integer*>();\n\nistream& operator >> (istream& in,Integer& x){\n    int num;\n    in >> num;\n    x.change_value(num);\n    return in;\n}\nostream& operator << (ostream& out,Integer& x){\n    out << x.get_value();\n    return out;\n}",
            1594264544.5742538,
            100,
            "# 答案正确"
        ],
        [
            "A.2 (C++)",
            "王芯芸",
            "template <typename E>\nvoid LinkedList<E>::removeAll(const E & e){\n\tfor(int i=0;;i++){\n\t\tint index=indexOf(e);\n\t\tif(index==-1) break;\n\t\telse removeFirstOccurrence(e);\n\t}\n}\n",
            1594870246.7221806,
            100,
            "# 答案正确"
        ]
    ],
    "table_name": "答案"
}