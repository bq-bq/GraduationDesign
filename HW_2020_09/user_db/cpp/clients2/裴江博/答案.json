{
    "__update_time__": 1596124259.4549263,
    "field_names": [
        "题目名",
        "用户名",
        "答案",
        "提交时间",
        "分数",
        "评语"
    ],
    "field_types": [
        "text",
        "text",
        "text",
        "time",
        "number",
        "text"
    ],
    "foreign_keys": {},
    "primary_keys": [],
    "rows": [
        [
            "测试2",
            "裴江博",
            "#include <iostream>\n#include <string>\nusing namespace std;\nint main(){\n    string str[10];\n    for(int i=0;i < 10;++i){\n      cin >> str[i]; \n    }\n    for(int i=0;i<9;++i){\n        for(int j=0;j<9-i;++j){\n            if(str[j] > str[j+1]){\n                string temp = str[j];\n                str[j] = str[j+1];\n                str[j+1] = temp;\n            }\n        }\n    }\n    for(int i=0;i < 10;++i){\n      cout << str[i] << \" \";\n      if(i == 9) cout << endl; \n    }\n}",
            1587609730.9074318,
            100,
            "# 答案正确"
        ],
        [
            "1.1 (C++)",
            "裴江博",
            "class Matrix5x5{\n    public:\n        double Matrix[5][5];\n        Matrix5x5(){\n            for (int row = 0; row < 5; ++ row) {\n\t\t        for (int col = 0; col < 5; ++ col) {\n\t\t\t       Matrix[row][col] = 0;   \n\t\t        }\n\t        }\n        }\n        double get(int a, int b){ return Matrix[a][b]; }\n        void set(int a, int b, double value){ Matrix[a][b] = value; }\n        Matrix5x5 operator + (Matrix5x5 & m1);\n        ~Matrix5x5(){\n\t\t\tfor (int row = 0; row < 5; ++ row) {\n\t\t        for (int col = 0; col < 5; ++ col) {\n\t\t\t       Matrix[row][col] = 0;   \n\t\t        }\n\t        }\n\t\t}\n};\nMatrix5x5 Matrix5x5::operator + (Matrix5x5 & m1){\n    Matrix5x5 result;\n    for (int row = 0; row < 5; ++ row) {\n        for (int col = 0; col < 5; ++ col) {\n\t\t\tresult.Matrix[row][col] = this->Matrix[row][col] + m1.Matrix[row][col];   \n\t\t}\n    }\n    return result;\n}",
            1587990999.8275037,
            100,
            "# 答案正确"
        ],
        [
            "1.2 (C++)",
            "裴江博",
            "class School{\n\tpublic:\n\t\tchar name[10];\n\t\tint age;\n\t\tSchool(){\n\t\t\tchar a[8] = \"NO_NAME\";\n\t\t\tfor(int i=0;i<8;++i){\n\t\t\t\tname[i] = a[i];\n\t\t\t}\n\t\t\tthis->age = 0;\n\t\t}\n\t\tvoid setName(char name[]){\n\t\t\tfor (int i = 0; i < 10; ++ i){\n\t\t\t\tif(name[i] == '\\0') {\n\t\t\t\t\tthis->name[i] = name[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse this->name[i] = name[i];\n\t\t\t} \n\t\t}\n\t\tvoid setAge(int year){\n\t\t\tthis->age = year;\n\t\t}\n\t\tvoid operator ++ (){\n\t\t\tthis->age++;\n\t\t}\n\t\t~School(){\n\t\t\tchar a[8] = \"NO_NAME\";\n\t\t\tfor(int i=0;i<8;++i){\n\t\t\t\tname[i] = a[i];\n\t\t\t}\n\t\t\tthis->age = 0;\n\t\t}\n};",
            1588213030.6091597,
            100,
            "# 答案正确"
        ],
        [
            "2.1 (C++)",
            "裴江博",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix{\n\tprivate:\n\t\tint rows;\n \t\tint columns;\n\t\tdouble * values;\n\tpublic:\n\t\tMatrix(int rows,int columns){\n\t\t\tthis->rows = rows;\n\t\t\tthis->columns = columns;\n\t\t\tvalues = new double[rows*columns];\n\t\t\tfor(int i=0;i<rows*columns;++i){\n\t\t\t\tvalues[i] = 0;\n\t\t\t}\n\t\t}\n\t\t~Matrix(){\n\t\t\tdelete []values;\n\t\t\tthis->values = 0;\n\t\t\tthis->columns = 0;\n\t\t}\n\t\tvoid print(){\n\t\t\tfor(int i=0;i<rows*columns;++i){\n\t\t\t\tif( (i+1) % columns == 0) cout << values[i] << endl;\n\t\t\t\telse cout << values[i] << \"    \";\n\t\t\t}\n\t\t}\n};\n",
            1588856904.4012654,
            100,
            "# 答案正确"
        ],
        [
            "2.2 (C++)",
            "裴江博",
            "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nclass Matrix{\n\tprivate:\n\t\tint rows;\n \t\tint columns;\n\t\tdouble * values;\n\tpublic:\n\t\tMatrix(int rows,int columns,double values[]){\n\t\t\tthis->rows = rows;\n\t\t\tthis->columns = columns;\n\t\t\tthis->values = new double[rows*columns];\n\t\t\tfor(int i=0;i<rows*columns;++i){\n\t\t\t\tthis->values[i] = values[i];\n\t\t\t}\n\t\t}\n\t\t~Matrix(){\n\t\t\tdelete []values;\n\t\t\tthis->values = 0;\n\t\t\tthis->columns = 0;\n\t\t}\n\t\tvoid print(){\n\t\t\tfor(int i=0;i<rows*columns;++i){\n\t\t\t\tif( (i+1) % columns == 0) cout << setw(5) << values[i] << endl;\n\t\t\t\telse cout << setw(5) << values[i];\n\t\t\t}\n\t\t}\n};\n",
            1588859592.783455,
            100,
            "# 答案正确"
        ],
        [
            "2.3 (C++)",
            "裴江博",
            "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nclass Matrix{\n\tprivate:\n\t\tint rows;\n \t\tint columns;\n\t\tdouble * values;\n\tpublic:\n\t\tMatrix(int rows,int columns,double values[]){\n\t\t\tthis->rows = rows;\n\t\t\tthis->columns = columns;\n\t\t\tthis->values = new double[rows*columns];\n\t\t\tfor(int i=0;i<rows*columns;++i){\n\t\t\t\tthis->values[i] = values[i];\n\t\t\t}\n\t\t}\n\t\t~Matrix(){\n\t\t\tdelete []values;\n\t\t\tthis->values = 0;\n\t\t\tthis->columns = 0;\n\t\t}\n\t\tMatrix(const Matrix & matrix2){\n\t\t\tthis->rows = matrix2.rows;\n\t\t\tthis->columns = matrix2.columns;\n\t\t\tthis->values = new double[this->rows*this->columns];\n\t\t\tfor(int i=0;i<rows*columns;++i){\n\t\t\t\tthis->values[i] = matrix2.values[i];\n\t\t\t}\n\t\t}\n\t\tvoid print(){\n\t\t\tfor(int i=0;i<rows*columns;++i){\n\t\t\t\tif( (i+1) % columns == 0) cout << \"    \" << values[i] << endl;\n\t\t\t\telse cout << \"    \" << values[i];\n\t\t\t}\n\t\t}\n};\n",
            1588859942.844894,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/08",
            "裴江博",
            "double & Tensor_get(int dimensions,int sizes[], double data[], int x0, int x1, int x2, int x3){\n\tint index = -1;\n\tif(dimensions == 2) index = x0 * sizes[1] + x1;\n\tif(dimensions == 3) index = x0 * sizes[1] * sizes[2 ]+ x1 * sizes[2] + x2;\n\tif(dimensions == 4) index = x0 * sizes[1] * sizes[2] * sizes[3] + x1 * sizes[2] * sizes[3] + x2 * sizes[3] + x3;\n\treturn data[index];\n}",
            1588907431.172718,
            100,
            "# 答案正确"
        ],
        [
            "2.5 (C++)",
            "裴江博",
            "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nclass Matrix{\n\tprivate:\n\t\tint rows;\n \t\tint columns;\n\t\tdouble * values;\n\tpublic:\n\t\tMatrix(int rows, int columns){\n\t\t\tthis->rows = rows;\n\t\t\tthis->columns = columns;\n\t\t\tthis->values = new double[rows*columns];\n\t\t\tfor(int i=0;i<rows*columns;i++){\n\t\t\t\tvalues[i] = 0;\n\t\t\t}\n\t\t}\n\t\tMatrix(int rows,int columns,double values[]){\n\t\t\tthis->rows = rows;\n\t\t\tthis->columns = columns;\n\t\t\tthis->values = new double[rows*columns];\n\t\t\tfor(int i=0;i<rows*columns;++i){\n\t\t\t\tthis->values[i] = values[i];\n\t\t\t}\n\t\t}\n\t\t~Matrix(){\n\t\t\tdelete []values;\n\t\t\tthis->values = 0;\n\t\t\tthis->columns = 0;\n\t\t}\n\t\tvoid print(){\n\t\t\tfor(int i=0;i<rows*columns;++i){\n\t\t\t\tif( (i+1) % columns == 0) cout << \"    \" << values[i] << endl;\n\t\t\t\telse cout << \"    \" << values[i];\n\t\t\t}\n\t\t}\n\t\tMatrix getRow(int row){\n\t\t\tMatrix m2(1,this->columns);\n\t\t\tfor(int i=0;i < this->columns;++i){\n\t\t\t\tm2.values[i] = this->values[(row-1)*this->columns + i];\n\t\t\t}\n\t\t\treturn m2;\n\t\t}\n\t\tMatrix getColumn(int column){\n\t\t\tMatrix m3(this->rows,1);\n\t\t\tfor(int i=0;i< this->rows;++i){\n\t\t\t\tm3.values[i] = this->values[i*this->columns + column - 1];\n\t\t\t}\n\t\t\treturn m3;\n\t\t}\n};\n",
            1589435648.0264466,
            100,
            "# 答案正确"
        ],
        [
            "2.6 (C++)",
            "裴江博",
            "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nclass Matrix{\n\tprivate:\n\t\tint rows;\n \t\tint columns;\n\t\tdouble * values;\n\tpublic:\n\t\tMatrix(int rows,int columns,double values[]){\n\t\t\tthis->rows = rows;\n\t\t\tthis->columns = columns;\n\t\t\tthis->values = new double[rows*columns];\n\t\t\tfor(int i=0;i<rows*columns;++i){\n\t\t\t\tthis->values[i] = values[i];\n\t\t\t}\n\t\t}\n\t\tMatrix(const Matrix & matrix2){\n\t\t\tthis->rows = matrix2.rows;\n\t\t\tthis->columns = matrix2.columns;\n\t\t\tthis->values = new double[this->rows*this->columns];\n\t\t\tfor(int i=0;i<rows*columns;++i){\n\t\t\t\tthis->values[i] = matrix2.values[i];\n\t\t\t}\n\t\t}\n     ~Matrix(){\n\t\t\tdelete []values;\n\t\t\tthis->values = 0;\n\t\t\tthis->columns = 0;\n\t\t}\n\t\tvoid print(){\n\t\t\tfor(int i=0;i<rows*columns;++i){\n\t\t\t\tif( (i+1) % columns == 0) cout << \"    \" << values[i] << endl;\n\t\t\t\telse cout << \"    \" << values[i];\n\t\t\t}\n\t\t }\n      Matrix concatenateRows(const Matrix & matrix2){\n            int total = this->rows*this->columns + matrix2.rows*matrix2.columns;\n            double value[total];\n            for(int i=0;i<total;++i){\n                if(i < this->rows*this->columns) value[i] = this->values[i];\n                else value[i] = matrix2.values[i-this->rows*this->columns];\n            }\n            Matrix m1(this->rows+matrix2.rows,this->columns,value);\n            return m1;\n        }\n       Matrix concatenateColumns(const Matrix & matrix2){\n            int total = this->rows*this->columns + matrix2.rows*matrix2.columns;\n            double value[total];\n            for(int i=0; i < this->rows;++i){\n\t\t\t\t\t for(int j=0;j < this->columns*2;++j){\n\t\t\t\t\t\tif(j < this->columns) value[i*this->columns*2+j] = this->values[i*this->columns+j];\n\t\t\t\t\t\telse value[i*this->columns*2+j] = matrix2.values[i*this->columns+j - this->columns];\n\t\t\t\t\t }\t\t\t\t\n\t\t\t\t  }\n            Matrix m2(this->rows,this->columns+matrix2.columns,value);\n            return m2; \n       }\n};\n",
            1589436811.93917,
            100,
            "# 答案正确"
        ],
        [
            "2.4 (C++)",
            "裴江博",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix{\n\tprivate:\n\t\tint rows;\n\t\tint columns;\n\t\tdouble * values;\n\tpublic:\n\t\tMatrix(int rows, int columns){\n\t\t\tthis->values = new double[rows*columns];\n\t\t\tthis->rows = rows;\n\t\t\tthis->columns = columns;\n\t\t\tfor(int i=0; i < rows*columns;++i) this->values[i] = 0;\n\t\t}\n\t\tMatrix(int rows, int columns, double values[]){\n\t\t\tthis->rows = rows;\n\t\t\tthis->columns = columns;\n\t\t\tthis->values = new double[rows*columns];\n\t\t\tfor(int i=0;i<rows*columns;++i){\n\t\t\t\tthis->values[i] = values[i];\n\t\t\t}\n\t\t}\t\t\n\t\t~Matrix(){\n\t\t\tdelete []this->values;\n\t\t\tthis->rows = 0;\n\t\t\tthis->columns = 0;\n\t\t}\n\t\tvoid print(){\n\t\t\tfor(int i=0;i < this->rows;++i){\n\t\t\t\tfor(int j=0;j < this->columns;++j){\n\t\t\t\t\tcout << \"    \" << this->values[i*columns+j];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t\tvoid set(int row, int column, double value){\n\t\t\trow--;\n\t\t\tcolumn--;\n\t\t\tthis->values[row*this->columns + column] = value;\n\t\t}\n\t\tMatrix & operator = (const Matrix & m1){\n\t\t\tthis->rows = m1.rows;\n\t\t\tthis->columns = m1.columns;\n\t\t\tdelete []this->values;\n\t\t\tthis->values = new double[m1.rows*m1.columns];\n\t\t\tfor(int i=0;i < m1.rows*m1.columns;++i){\n\t\t\t\tthis->values[i] = m1.values[i];\n\t\t\t}\n\t\t\treturn(*this);\n\t\t}\t\t\n};",
            1589887073.829543,
            100,
            "# 答案正确"
        ],
        [
            "2.7 (C++)",
            "裴江博",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix{\n\tprivate:\n\t\tint rows;\n\t\tint columns;\n\t\tdouble * values;\n\tpublic:\n\t\tMatrix(int rows, int columns, double values[]){\n\t\t\tthis->rows = rows;\n\t\t\tthis->columns = columns;\n\t\t\tthis->values = new double[rows*columns];\n\t\t\tfor(int i=0;i<rows*columns;++i){\n\t\t\t\tthis->values[i] = values[i];\n\t\t\t}\n\t\t}\n\t\tMatrix(const Matrix & matrix2){\n\t\t\tthis->rows = matrix2.rows;\n\t\t\tthis->columns = matrix2.columns;\n\t\t\tthis->values = new double[matrix2.rows * matrix2.columns];\n\t\t\tfor(int i=0;i < matrix2.rows * matrix2.columns;++i){\n\t\t\t\tthis->values[i] = matrix2.values[i];\n\t\t\t}\n\t\t}\t\t\n\t\t~Matrix(){\n\t\t\tdelete []this->values;\n\t\t\tthis->rows = 0;\n\t\t\tthis->columns = 0;\n\t\t}\n\t\tvoid print(){\n\t\t\tfor(int i=0;i < this->rows;++i){\n\t\t\t\tfor(int j=0;j < this->columns;++j){\n\t\t\t\t\tcout << \"    \" << this->values[i*columns+j];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t\tMatrix reshape(int rows, int columns) const;\n};\nMatrix Matrix::reshape(int rows, int columns) const{\n\tMatrix m1(rows,columns,this->values);\n\t\t\tint r=0,c=0;\n\t\t\tfor(int i = 0;i < columns;++i){\n\t\t\t\tfor(int j=0; j < rows;++j){\n\t\t\t\t\tif(r == this->rows){\n\t\t\t\t\t\tr=0;\n\t\t\t\t\t\tc++;\n\t\t\t\t\t}\n\t\t\t\t\tm1.values[j*columns+i] = this->values[r*this->columns+c];\n\t\t\t\t\tr++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn m1;\n}",
            1589892081.046482,
            100,
            "# 答案正确"
        ],
        [
            "2.8 (C++)",
            "裴江博",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix{\n\tprivate:\n\t\tint rows;\n\t\tint columns;\n\t\tdouble * values;\n\tpublic:\n\t\tMatrix(int rows, int columns, double values[]){\n\t\t\tthis->rows = rows;\n\t\t\tthis->columns = columns;\n\t\t\tthis->values = new double[rows*columns];\n\t\t\tfor(int i=0;i<rows*columns;++i){\n\t\t\t\tthis->values[i] = values[i];\n\t\t\t}\n\t\t}\n\t\tMatrix(const Matrix & matrix2){\n\t\t\tthis->rows = matrix2.rows;\n\t\t\tthis->columns = matrix2.columns;\n\t\t\tthis->values = new double[matrix2.rows * matrix2.columns];\n\t\t\tfor(int i=0;i<matrix2.rows * matrix2.columns;++i){\n\t\t\t\tthis->values[i] = matrix2.values[i];\n\t\t\t}\n\t\t}\t\t\n\t\t~Matrix(){\n\t\t\tdelete []this->values;\n\t\t\tthis->rows = 0;\n\t\t\tthis->columns = 0;\n\t\t}\n\t\tvoid print(){\n\t\t\tfor(int i=0;i < this->rows;++i){\n\t\t\t\tfor(int j=0;j < this->columns;++j){\n\t\t\t\t\tcout << \"    \" << this->values[i*columns+j];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t\tMatrix transpose(){\n\t\t\tMatrix m1(this->columns,this->rows,this->values);\n\t\t\tint r=0,c=0;\n\t\t\tfor(int i=0;i < this->columns;++i){\n\t\t\t\tfor(int j=0;j < this->rows;++j){\n\t\t\t\t\tif(r == this->columns){\n\t\t\t\t\t\tr=0;\n\t\t\t\t\t\tc++;\n\t\t\t\t\t}\n\t\t\t\t\tm1.values[i*this->rows+j] = this->values[r*this->columns+c];\n\t\t\t\t\tr++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn m1;\n\t\t}\n};\n",
            1589893149.479508,
            100,
            "# 答案正确"
        ],
        [
            "2.10 (C++)",
            "裴江博",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix{\n\tprivate:\n\t\tint rows;\n\t\tint columns;\n\t\tdouble * values;\n\tpublic:\n\t\tMatrix(int rows, int columns, double values[]){\n\t\t\tthis->rows = rows;\n\t\t\tthis->columns = columns;\n\t\t\tthis->values = new double[rows*columns];\n\t\t\tfor(int i=0;i<rows*columns;++i){\n\t\t\t\tthis->values[i] = values[i];\n\t\t\t}\n\t\t}\n\t\tMatrix(const Matrix & matrix2){\n\t\t\tthis->rows = matrix2.rows;\n\t\t\tthis->columns = matrix2.columns;\n\t\t\tthis->values = new double[matrix2.rows * matrix2.columns];\n\t\t\tfor(int i=0;i<matrix2.rows * matrix2.columns;++i){\n\t\t\t\tthis->values[i] = matrix2.values[i];\n\t\t\t}\n\t\t}\t\t\n\t\t~Matrix(){\n\t\t\tdelete []this->values;\n\t\t\tthis->rows = 0;\n\t\t\tthis->columns = 0;\n\t\t}\n\t\tvoid print(){\n\t\t\tfor(int i=0;i < this->rows;++i){\n\t\t\t\tfor(int j=0;j < this->columns;++j){\n\t\t\t\t\tcout << \"    \" << this->values[i*columns+j];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t\tMatrix operator * (const Matrix & matrix2) const{\n\t\t\tdouble values[this->rows*matrix2.columns];\n\t\t\tfor(int i=0;i<this->rows*matrix2.columns;++i) values[i] = 0;\n\t\t\tMatrix m1(this->rows,matrix2.columns,values);\n\t\t\tint r1=0,c1=0,r2=0,c2=0;\n\t\t\tfor(int i=0;i < m1.rows;++i){\n\t\t\t\tfor(int j=0;j < m1.columns;++j){\n\t\t\t\t\tint num = this->columns;\n\t\t\t\t\twhile(num--){\n\t\t\t\t\t\tm1.values[i*m1.columns+j] += (this->values[i*this->columns+c1] * matrix2.values[r2*matrix2.columns+j]);\n\t\t\t\t\t\tc1++;\n\t\t\t\t\t\tr2++;\n\t\t\t\t\t}\t\n\t\t\t\t\tif(c1 == this->columns){\n\t\t\t\t\t\tc1 = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif(r2 == matrix2.rows){\n\t\t\t\t\t\tr2 = 0;\n\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn m1;\n\t\t}\n\t\tMatrix operator * (double value) const{\n\t\t\tMatrix m1(*this);\n\t\t\tfor(int i=0;i < m1.rows;++i){\n\t\t\t\tfor(int j=0;j<m1.columns;++j){\n\t\t\t\t\tm1.values[i*m1.columns+j] *= value;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn m1;\n\t\t}\n};",
            1589903149.5431368,
            100,
            "# 答案正确"
        ],
        [
            "2.11 (C++)",
            "裴江博",
            "#include <iostream>\nusing namespace std;\n#define Max 100000;\n\nclass Matrix{\n\tprivate:\n\t\tint rows;\n\t\tint columns;\n\t\tdouble * values;\n\tpublic:\n\t\tMatrix(int rows, int columns, double values[]){\n\t\t\tthis->rows = rows;\n\t\t\tthis->columns = columns;\n\t\t\tthis->values = new double[rows*columns];\n\t\t\tfor(int i=0;i<rows*columns;++i){\n\t\t\t\tthis->values[i] = values[i];\n\t\t\t}\n\t\t}\n\t\tMatrix(const Matrix & matrix2){\n\t\t\tthis->rows = matrix2.rows;\n\t\t\tthis->columns = matrix2.columns;\n\t\t\tthis->values = new double[matrix2.rows * matrix2.columns];\n\t\t\tfor(int i=0;i<matrix2.rows * matrix2.columns;++i){\n\t\t\t\tthis->values[i] = matrix2.values[i];\n\t\t\t}\n\t\t}\t\t\n\t\t~Matrix(){\n\t\t\tdelete []this->values;\n\t\t\tthis->rows = 0;\n\t\t\tthis->columns = 0;\n\t\t}\n\t\tvoid print(){\n\t\t\tfor(int i=0;i < this->rows;++i){\n\t\t\t\tfor(int j=0;j < this->columns;++j){\n\t\t\t\t\tcout << \"    \" << this->values[i*columns+j];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t    Matrix max() const{\n\t\t\tif(this->rows == 1){\n\t\t\t\tMatrix m1(1,1,this->values);\n\t\t\t\tfor(int i=0;i<this->columns;++i){\n\t\t\t\t\tif(this->values[i] > m1.values[0]) m1.values[0] = this->values[i]; \n\t\t\t\t}\n\t\t\t\treturn m1;\n\t\t\t}\n\t\t\tMatrix m1(1,this->columns,this->values);\n\t\t\tint count = 0;\n\t\t\tfor(int i=0;i<this->columns;++i){\n\t\t\t\tdouble max = 0;\n\t\t\t\tfor(int j=0;j < this->rows;++j){\n\t\t\t\t\tif(this->values[j*this->columns+i] > max) max = this->values[j*this->columns+i];\n\t\t\t\t}\n\t\t\t\tm1.values[count++] = max;\n\t\t\t}\n\t\t\treturn m1;\n\t\t}\n\t\tMatrix min() const{\n\t\t\tif(this->rows == 1){\n\t\t\t\tMatrix m1(1,1,this->values);\n\t\t\t\tfor(int i=0;i<this->columns;++i){\n\t\t\t\t\tif(this->values[i] < m1.values[0]) m1.values[0] = this->values[i]; \n\t\t\t\t}\n\t\t\t\treturn m1;\n\t\t\t}\n\t\t\tMatrix m1(1,this->columns,this->values);\n\t\t\tint count = 0;\n\t\t\tfor(int i=0;i<this->columns;++i){\n\t\t\t\tdouble min = Max;\n\t\t\t\tfor(int j=0;j < this->rows;++j){\n\t\t\t\t\tif(this->values[j*this->columns+i] < min) min = this->values[j*this->columns+i];\n\t\t\t\t}\n\t\t\t\tm1.values[count++] = min;\n\t\t\t}\n\t\t\treturn m1;\n\t\t}\n\t\tMatrix sum() const{\n\t\t\tif(this->rows == 1){\n\t\t\t\tMatrix m1(1,1,this->values);\n\t\t\t\tm1.values[0] = 0;\n\t\t\t\tfor(int i=0;i<this->columns;++i){\n\t\t\t\t\tm1.values[0] += this->values[i];\n\t\t\t\t}\n\t\t\t\treturn m1;\n\t\t\t}\n\t\t\tMatrix m1(1,this->columns,this->values);\n\t\t\tint count = 0;\n\t\t\tfor(int i=0;i<this->columns;++i){\n\t\t\t\tdouble result = 0;\n\t\t\t\tfor(int j=0;j < this->rows;++j){\n\t\t\t\t\tresult += this->values[j*this->columns+i];\n\t\t\t\t}\n\t\t\t\tm1.values[count++] = result;\n\t\t\t}\n\t\t\treturn m1;\n\t\t}\n};",
            1589986100.0116622,
            100,
            "# 答案正确"
        ],
        [
            "2.12 (C++)",
            "裴江博",
            "#include <iostream>\n#include <stdlib.h>\n#include <cmath>\nusing namespace std;\n#define Max 100000;\n\nclass Matrix{\n\tprivate:\n\t\tint rows;\n\t\tint columns;\n\t\tdouble * values;\n\tpublic:\n\t\tMatrix(int rows, int columns, double values[]){\n\t\t\tthis->rows = rows;\n\t\t\tthis->columns = columns;\n\t\t\tthis->values = new double[rows*columns];\n\t\t\tfor(int i=0;i<rows*columns;++i){\n\t\t\t\tthis->values[i] = values[i];\n\t\t\t}\n\t\t}\n\t\tMatrix(const Matrix & matrix2){\n\t\t\tthis->rows = matrix2.rows;\n\t\t\tthis->columns = matrix2.columns;\n\t\t\tthis->values = new double[matrix2.rows * matrix2.columns];\n\t\t\tfor(int i=0;i<matrix2.rows * matrix2.columns;++i){\n\t\t\t\tthis->values[i] = matrix2.values[i];\n\t\t\t}\n\t\t}\t\t\n\t\t~Matrix(){\n\t\t\tdelete []this->values;\n\t\t\tthis->rows = 0;\n\t\t\tthis->columns = 0;\n\t\t}\n\t\tvoid print(){\n\t\t\tfor(int i=0;i < this->rows;++i){\n\t\t\t\tfor(int j=0;j < this->columns;++j){\n\t\t\t\t\tcout << \"    \" << this->values[i*columns+j];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t    Matrix pow(double exponent){\n\t\t\tMatrix m1(*this);\n\t\t\tfor(int i=0;i < this->rows*this->columns;++i){\n\t\t\t\tm1.values[i] = std::pow(m1.values[i],exponent);\n\t\t\t}\n\t\t\treturn m1;\n\t\t}\n\t\tMatrix exp(){\n\t\t\tMatrix m1(*this);\n\t\t\tfor(int i=0;i < this->rows*this->columns;++i){ \n\t\t\t\tm1.values[i] = std::exp(m1.values[i]);\n\t\t\t}\n\t\t\treturn m1;\n\t\t}\n\t\tMatrix log(){\n\t\t\tMatrix m1(*this);\n\t\t\tfor(int i=0;i < this->rows*this->columns;++i){\n\t\t\t\tm1.values[i] = std::log(m1.values[i]);\n\t\t\t}\n\t\t\treturn m1;\n\t\t}\n\t\tMatrix abs(){\n\t\t\tMatrix m1(*this);\n\t\t\tfor(int i=0;i < this->rows*this->columns;++i){\n\t\t\t\tm1.values[i] = std::abs(m1.values[i]);\n\t\t\t}\n\t\t\treturn m1;\n\t\t}\n};",
            1590030479.9002495,
            100,
            "# 答案正确"
        ],
        [
            "2.9 (C++)",
            "裴江博",
            "#include <iostream>\nusing namespace std;\n#define Max 100000;\n\nclass Matrix{\n\tprivate:\n\t\tint rows;\n\t\tint columns;\n\t\tdouble * values;\n\tpublic:\n\t\tMatrix(int rows, int columns, double values[]){\n\t\t\tthis->rows = rows;\n\t\t\tthis->columns = columns;\n\t\t\tthis->values = new double[rows*columns];\n\t\t\tfor(int i=0;i<rows*columns;++i){\n\t\t\t\tthis->values[i] = values[i];\n\t\t\t}\n\t\t}\n\t\tMatrix(const Matrix & matrix2){\n\t\t\tthis->rows = matrix2.rows;\n\t\t\tthis->columns = matrix2.columns;\n\t\t\tthis->values = new double[matrix2.rows * matrix2.columns];\n\t\t\tfor(int i=0;i<matrix2.rows * matrix2.columns;++i){\n\t\t\t\tthis->values[i] = matrix2.values[i];\n\t\t\t}\n\t\t}\t\t\n\t\t~Matrix(){\n\t\t\tdelete []this->values;\n\t\t\tthis->rows = 0;\n\t\t\tthis->columns = 0;\n\t\t}\n\t\tvoid print(){\n\t\t\tfor(int i=0;i < this->rows;++i){\n\t\t\t\tfor(int j=0;j < this->columns;++j){\n\t\t\t\t\tcout << \"    \" << this->values[i*columns+j];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n        Matrix operator + (const Matrix & matrix2) const{\n            Matrix m1(*this);\n            for(int i=0;i < m1.rows;i++){\n                for(int j=0;j < m1.columns;++j){\n                    m1.values[i*m1.columns+j] += matrix2.values[i*matrix2.columns+j];  \n                }\n            }\n            return m1;\n        }\n        Matrix operator + (double value) const{\n            Matrix m1(*this);\n            for(int i=0;i < m1.rows;i++){\n                for(int j=0;j < m1.columns;++j){\n                    m1.values[i*m1.columns+j] += value;\n                }\n            }\n            return m1;\n        }\n        Matrix operator - (const Matrix & matrix2) const{\n            Matrix m1(*this);\n            for(int i=0;i < m1.rows;i++){\n                for(int j=0;j < m1.columns;++j){\n                    m1.values[i*m1.columns+j] -= matrix2.values[i*matrix2.columns+j];  \n                }\n            }\n            return m1;\n        }\n        Matrix operator - (double value) const{\n            Matrix m1(*this);\n            for(int i=0;i < m1.rows;i++){\n                for(int j=0;j < m1.columns;++j){\n                    m1.values[i*m1.columns+j] -= value;\n                }\n            }\n            return m1;\n        }\n}; ",
            1590027446.3216927,
            100,
            "# 答案正确"
        ],
        [
            "6.1 (C++)",
            "裴江博",
            "#include <string.h>\n\ntemplate <typename T>\nclass Matrix{\n\tprivate:\n\t\tint rows;\n\t\tint columns;\n\t\tT * values;\n\tpublic:\n\t\tMatrix(int r,int c){\n\t\t\tthis->rows = r;\n\t\t\tthis->columns = c;\n\t\t\tthis->values = new T[this->rows*this->columns];\n\t\t\tmemset(this->values,0,sizeof(T)*this->rows*this->columns);\n\t\t}\n\t\tMatrix(int r, int c,const T vec[]){\n\t\t\tthis->rows = r;\n\t\t\tthis->columns = c;\n\t\t\tvalues = new T[this->rows*this->columns];\n\t\t\tfor(int i=0;i< this->rows*this->columns;++i){\n\t\t\t\tvalues[i] = vec[i];\n\t\t\t}\n\t\t}\n\t\t~Matrix(){\n\t\t\tdelete [] values;\n\t\t}\n\t\tMatrix & operator = (const Matrix & m1){\n\t\t\tthis->rows = m1.rows;\n\t\t\tthis->columns = m1.columns;\n\t\t\tdelete [] this->values;\n\t\t\tthis->values = new T[this->rows*this->columns];\n\t\t\tfor(int i=0;i < this->rows*this->columns;++i){\n\t\t\t\tthis->values[i] = m1.values[i];\n\t\t\t}\n\t\t\treturn *this;\n\t\t}\n\t\tvoid print(){\n\t\t\tfor(int i=0;i < this->rows;++i){\n\t\t\t\tfor(int j=0;j < this->columns;++j){\n\t\t\t\t\tcout << \"    \" << this->values[i*this->columns+j];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t\tT & get(int row,int column){\n\t\t\treturn this->values[(row-1)*this->columns+column-1];\n\t\t}\n};\n",
            1590634787.8630762,
            0,
            "=================================================================\n==19775==ERROR: AddressSanitizer: heap-use-after-free on address 0x60700000df40 at pc 0x564da5d7fbcf bp 0x7ffef6f77880 sp 0x7ffef6f77870\nREAD of size 8 at 0x60700000df40 thread T0\n    #0 0x564da5d7fbce in Matrix<double>::operator=(Matrix<double> const&) /home/裴江博/source.cpp:33\n    #1 0x564da5d7fbce in main4double() /home/裴江博/main.cpp:30\n    #2 0x564da5d81a05 in main /home/裴江博/main.cpp:62\n    #3 0x7ff4317cc82f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2082f)\n    #4 0x564da5d7eaa8 in _start (/home/裴江博/main.out+0x1aa8)\n\n0x60700000df40 is located 0 bytes inside of 72-byte region [0x60700000df40,0x60700000df88)\nfreed by thread T0 here:\n    #0 0x7ff4321a7caa in operator delete[](void*) (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x99caa)\n    #1 0x564da5d7fb8f in Matrix<double>::operator=(Matrix<double> const&) /home/裴江博/source.cpp:30\n    #2 0x564da5d7fb8f in main4double() /home/裴江博/main.cpp:30\n    #3 0x564da5d81a05 in main /home/裴江博/main.cpp:62\n    #4 0x7ff4317cc82f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2082f)\n\npreviously allocated by thread T0 here:\n    #0 0x7ff4321a76b2 in operator new[](unsigned long) (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x996b2)\n    #1 0x564da5d7f12a in Matrix<double>::Matrix(int, int, double const*) /home/裴江博/source.cpp:19\n    #2 0x564da5d7f12a in main4double() /home/裴江博/main.cpp:18\n    #3 0x564da5d81a05 in main /home/裴江博/main.cpp:62\n    #4 0x7ff4317cc82f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2082f)\n\nSUMMARY: AddressSanitizer: heap-use-after-free /home/裴江博/source.cpp:33 Matrix<double>::operator=(Matrix<double> const&)\nShadow bytes around the buggy address:\n  0x0c0e7fff9b90: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c0e7fff9ba0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c0e7fff9bb0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c0e7fff9bc0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c0e7fff9bd0: fa fa fa fa fa fa fa fa fa fa 00 00 00 00 00 00\n=>0x0c0e7fff9be0: 00 00 00 fa fa fa fa fa[fd]fd fd fd fd fd fd fd\n  0x0c0e7fff9bf0: fd fa fa fa fa fa 00 00 00 00 00 00 00 00 00 fa\n  0x0c0e7fff9c00: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c0e7fff9c10: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c0e7fff9c20: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c0e7fff9c30: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Heap right redzone:      fb\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack partial redzone:   f4\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n==19775==ABORTING\n"
        ],
        [
            "6.3 (C++)",
            "裴江博",
            "#include <iostream>\n#include <vector>\n#include <string.h>\nusing namespace std;\n\ntemplate <typename T>\nclass Matrix{\n    private:\n        int rows;\n        int columns;\n        vector<T> values;\n    public:\n        Matrix(int r,int c){\n            rows = r;\n            columns = c;\n            for(int i=0;i < rows*columns;++i){\n                values.push_back(0);\n            }\n        }    \n        Matrix(int r,int c,vector<T> vec){\n            rows = r;\n            columns = c;\n            for(int i=0;i < r*c;++i){\n                values.push_back(vec[i]);\n            }\n        }\n        void print(){\n\t\t\t\tfor(int i=0;i < rows;++i){\n\t\t\t\t\tfor(int j=0;j < columns;++j){\n\t\t\t\t\t\tcout << \"    \" << values[i*columns+j];\n\t\t\t\t\t}\n\t\t\t\t\tcout << endl;\n\t\t\t\t}\n\t\t   }\n        T & get(int r,int c){\n            return values[(r-1)*columns+c-1];\n        }\n        Matrix getColumn(int c){\n            Matrix m1(rows,1);\n            for(int i=0;i < rows;++i){\n                m1.values[i] = values[i*columns+c-1];\n            }\n            return m1;\n\t\t\t\n        }\n        Matrix getRow(int r){\n            Matrix m1(1,columns);\n            for(int i=0;i < columns;++i){\n                m1.values[i] = values[(r-1)*columns+i];\n            }\n            return m1;\n        }\n        Matrix concatenateRows(const Matrix & m){\n            Matrix m1(rows+m.rows,columns);\n            for(int i=0;i < m1.rows;++i){\n                for(int j=0;j < m1.columns;++j){\n                    if(i >= rows){\n                        m1.values[i*m1.columns+j] = m.values[(i-rows)*m.columns+j];\n                    }\n                    else m1.values[i*m1.columns+j] = values[i*columns+j];\n                }\n            }\n            return m1;\n        }\n        Matrix concatenateColumns(const Matrix & m){\n            Matrix m1(rows,columns+m.columns);\n            for(int i=0;i < m1.rows;++i){\n                for(int j=0;j < m1.columns;++j){\n                    if(j >= columns){\n                        m1.values[i*m1.columns+j] = m.values[i*m.columns+j-m.columns];\n                    }\n                    else m1.values[i*m1.columns+j] = values[i*columns+j];\n                }\n            }\n            return m1;\n        }\n        Matrix reshape(int r,int c){\n            Matrix m1(r,c);\n            int count = 0;\n            for(int i=0;i < r;++i){\n                if(i < rows) count =0;\n                else count = 1;\n                for(int j=0;j < c;++j){\n                    if(i < rows){\n                        m1.values[i*c+j] = values[i*columns+count];\n                        count += 2;\n                    }\n                    else{\n                        m1.values[i*c+j] = values[(i-rows)*columns+count];\n                        count += 2;\n                    }\n                }\n            }\n            return m1;\n        }\n        Matrix transpose(){\n            Matrix m1(columns,rows);\n            for(int i=0;i < m1.rows;++i){\n                for(int j=0;j < m1.columns;++j){\n                    m1.values[i*m1.columns+j] = values[j*columns+i];\n                }\n            }\n        }\n        Matrix operator +(const Matrix & m){\n            Matrix m1(rows,columns);\n            for(int i=0;i < m1.rows*m1.columns;++i){\n                 m1.values[i] = values[i] + m.values[i];\n            }\n            return m1;\n        }  \n        Matrix operator +(int value){\n            Matrix m1(rows,columns);\n            for(int i=0;i < m1.rows*m1.columns;++i){\n                m1.values[i] = values[i] + value;\n            }\n            return m1;\n        }  \n        Matrix operator -(const Matrix & m){\n            Matrix m1(rows,columns);\n            for(int i=0;i < m1.rows*m1.columns;++i){\n                 m1.values[i] = values[i] - m.values[i];\n            }\n            return m1;\n        }\n        Matrix operator -(int value){\n            Matrix m1(rows,columns);\n            for(int i=0;i > m1.rows*m1.columns;++i){\n                m1.values[i] = values[i] - value;\n            }\n            return m1;\n        }\n        Matrix operator *(const Matrix & m){\n            Matrix m1(rows,columns);\n            for(int i=0;i < m1.rows;++i){\n                for(int j=0;j < m1.columns;++j){\n                    for(int k=0;k < columns;++k){\n                        m1.values[i*m1.columns+j] += (values[i*columns+k] * m.values[k*m.columns+i]); \n                    } \n                }\n            }\n            return m1;\n        }\n        Matrix operator *(int value){\n            Matrix m1(rows,columns);\n            for(int i=0;i < m1.rows*m1.columns;++i){\n                m1.values[i] = values[i] * value;\n            }\n            return m1;\n        }\n        Matrix max(){\n            Matrix m1(1,1);\n            if(rows == 1 && columns == 1){\n                m1.values[0] = values[0];\n                return m1;\n            }\n            for(int i=0;i < rows*columns;++i){\n                if(values[i] > m1.values[0]) m1.values[0] = values[i];\n            }\n            return m1;\n        }\n        Matrix min(){\n            Matrix m1(1,1);\n            if(rows == 1 && columns == 1){\n                m1.values[0] = values[0];\n                return m1;\n            }\n            m1.values[0] = values[0];\n            for(int i=0;i < rows*columns;++i){\n                if(values[i] < m1.values[0]) m1.values[0] = values[i];\n            }\n            return m1;\n        }\n        Matrix sum(){\n            Matrix m1(1,1);\n            if(rows == 1 && columns == 1){\n                m1.values[0] = values[0];\n                return m1;\n            }\n            for(int i=0;i < rows*columns;++i){\n                m1.values[0] += values[i];\n            }\n            return m1;\n        }\n};",
            1590636017.151523,
            54,
            "Bus error (core dumped)\n"
        ],
        [
            "6.2 (C++)",
            "裴江博",
            "#include <string.h>\n#include <iostream>\nusing namespace std;\n\ntemplate <typename T>\nclass Matrix{\n\tprivate:\n\t\tint rows;\n\t\tint columns;\n\t\tT* values;\n\tpublic:\n\t\tMatrix(int r,int c){\n\t\t\tthis->rows = r;\n\t\t\tthis->columns = c;\n\t\t\tthis->values = new T[this->rows*this->columns];\n\t\t\tfor(int i=0;i < this->rows*this->columns;++i){\n                values[i] = 0;\n        }\n\t\t}\n\t\t~Matrix(){\n\t\t\tdelete [] values;\n\t\t}\n\t\tvoid print(){\n\t\t\tfor(int i=0;i < this->rows;++i){\n\t\t\t\tfor(int j=0;j < this->columns;++j){\n\t\t\t\t\tcout << \"    \" << values[i*this->columns+j];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n};",
            1590634084.111638,
            100,
            "# 答案正确"
        ],
        [
            "7.2 (C++)",
            "裴江博",
            "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nvector<string> split(const string & line,const string & delimiter = \" \"){\n\tvector<string> words;\n\tint st=0;\n\tfor(int i=0;i < line.size();++i){\n\t\tif(line[i] == ' ' && i == st) st += 1;\n\t\tif(line[i] != ' ' && (line[i+1] == ' ' || line[i+1] == '\\n') ){\n\t\t\twords.push_back(line.substr(st,i-st+1));\n\t\t\tst = i+1;\n\t\t}\n\t}\n\treturn words;\n} ",
            1591239486.4313087,
            100,
            "# 答案正确"
        ],
        [
            "7.1 (C++)",
            "裴江博",
            "#include <iostream>\n#include <math.h>\nusing namespace std;\nclass Triangle : public GeometricObject{\n\tprivate:\n\t \tdouble side1,side2,side3;\n\tpublic:\n\t\tTriangle(){\n\t\t\tside1=side2=side3=1.0;\n\t\t}\n\t\tTriangle(double s1,double s2,double s3){\n\t\t\tside1 = s1;\n\t\t\tside2 = s2;\n\t\t\tside3 = s3;\n\t\t}\n\t\tdouble getSide1(){\n\t\t\treturn side1;\n\t\t}\n\t\tdouble getSide2(){\n\t\t\treturn side2;\n\t\t}\n\t\tdouble getSide3(){\n\t\t\treturn side3;\n\t\t}\t\n\t\tdouble getArea(){\n\t\t\tdouble s = (side1 + side2 + side3) / 2;\n\t\t\tdouble area = sqrt(s * (s - side1) * (s - side2) * (s - side3));\n\t\t\treturn area;\n\t\t}\n\t\tdouble getPerimeter(){\n\t\t\tdouble perimeter = side1 + side2 + side3;\n\t\t\treturn perimeter;\n\t\t}\n};",
            1591240723.23232,
            100,
            "# 答案正确"
        ],
        [
            "7.3 (C++)",
            "裴江博",
            "template <typename A, typename R>\nvector<R> map2(const vector<A> & x,const vector<A> & y, R (*map_func)(const A &,const A &)) {\n\tvector<R> res;\n\tfor (int i = 0; i < x.size(); ++ i)\n\t\tres.push_back(map_func(x[i],y[i]));\n\treturn res;\n}\ntemplate <typename A, typename R>\nvector<R> map2(const vector<A> & x,A  data2, R (*map_func)(const A &,const A &)) {\n\tvector<R> res;\n\tfor (int i = 0; i < x.size(); ++ i)\n\t\tres.push_back(map_func(x[i],data2));\n\treturn res;\n}\n",
            1591245224.184956,
            100,
            "# 答案正确"
        ],
        [
            "8.1 (C++)",
            "裴江博",
            "class Full : public Matrix{\n    private:\n        int rows;\n        int columns;\n        double *values;\n    public:\n        Full(int r,int c){\n            rows = r;\n            columns = c;\n            values = new double [r*c];\n            for(int i=0;i < r*c;++i){\n                values[i] = 0;\n            }\n        }\n        Full(int r,int c,double v[]){\n            rows = r;\n            columns = c;\n            values = new double [r*c];\n            for(int i=0; i < r*c;++i){\n                values[i] = v[i];\n            }\n        }\n        Full(const Matrix & m2){\n            rows = m2.size(1);\n            columns = m2.size(2);\n            values = new double [rows*columns];\n            for(int i=0;i < rows;++i){\n                for(int j=0;j < columns;++j){\n                    values[i*columns + j] = m2.get(i+1,j+1);\n                }\n            }\n        }\n        ~Full(){\n            delete []values;\n            rows = columns =0;\n        }\n        void print() const{\n            for(int i=0;i < rows;++i){\n                for(int j=0;j < columns;++j){\n                    cout << \"    \" << values[i*columns + j];\n                }\n                cout << endl;\n            }\n        }\n        int size(int dimension) const {\n            if(dimension == 1) return rows;\n            else if(dimension == 2) return columns;\n        }\n\t    void set(int row, int column, double value){\n            values[(row-1)*columns + column-1] = value;\n        }\n\t\t double get(int row, int column) const {\n            return values[(row-1)*columns + column-1];\n        }\n\t    Matrix & operator = (const Matrix & matrix2) {\n            rows = matrix2.size(1);\n            columns = matrix2.size(2);\n            if(values == NULL) values = new double [rows*columns];\n            for(int i=0;i < rows;++i){\n                for(int j=0;j < columns;++j){\n                    values[i*columns + j] = matrix2.get(i+1,j+1);\n                }\n            }\n\t\t\t   return *this;\n        }\n\n};",
            1591838184.477422,
            100,
            "# 答案正确"
        ],
        [
            "8.5 (C++)",
            "裴江博",
            "#include <iostream>\n#include <cmath>\n\nusing namespace std;\nclass Point3D : public Point2D{\n    private:\n        double z;\n    public:\n        Point3D(){\n           setX(0);\n           setY(0);\n           z = 0;\n        }\n        Point3D(double X,double Y,double Z){\n            setX(X);\n            setY(Y);\n            z = Z;\n        }\n        double getZ(){\n            return z;\n        }\n        virtual double distance(Point2D & point2){\n            double dx = getX() - point2.getX();\n            double dy = getY() - point2.getY();\n            Point3D * p1= dynamic_cast<Point3D *> (this);\n            Point3D * p2= dynamic_cast<Point3D *> (&point2);\n            double dz = p1->getZ() - p2->getZ();\n            return sqrt(dx*dx + dy*dy + dz*dz);\n        }\n};",
            1591844542.9295862,
            100,
            "# 答案正确"
        ],
        [
            "8.3 (C++)",
            "裴江博",
            "#include <iostream>\n#include <vector>\n#include <string.h>\nusing namespace std;\n\nclass Sparse : public Matrix{\n    private:\n        int rows;\n        int columns;\n        vector<Entry> m;\n    public:\n        Sparse(int r,int c){\n            rows = r;\n            columns = c;\n        }\n        Sparse operator +(Sparse & sparse2){\n            for(int i=0;i < sparse2.m.size();++i){\n                int flag = 0;\n                for(int j=0;j < m.size();++j){\n                    if(sparse2.m[i].row == m[j].row && sparse2.m[i].column == m[j].column){\n                        m[j].value += sparse2.m[i].value;\n                        flag = 1; \n                        break;\n                    }\n                }\n                if(flag == 0) m.push_back(sparse2.m[i]);\n            }\n            Sparse result(rows,columns);\n            for(int i=0;i < m.size();++i){\n                if(m[i].value != 0) result.m.push_back(m[i]);\n            }\n            return result;\n        }\n        virtual int size(int dimension) const {\n            if(dimension == 1) return rows;\n            else if(dimension == 2) return columns;\n        }\n\t    virtual void set(int r, int c, double value){\n            Entry num;\n            num.row = r;\n            num.column = c;\n            num.value = value;\n            m.push_back(num);\n        }\n\t    virtual double get(int row, int column) const {\n            for(int i=0;i < m.size();++i){\n                if(m[i].row == row && m[i].column == column) return m[i].value;\n            }\n            return 0;\n        }\n\t    virtual void print(){\n            for(int i=0;i < m.size();++i){\n                for(int j=0;j < m.size()-i-1;++j){\n                    if(m[j].row > m[j+1].row || \n                       (m[j].row == m[j+1].row && m[j].column > m[j+1].column) ){\n                        Entry temp = m[j];\n                        m[j] = m[j+1];\n                        m[j+1] = temp;\n                    }\n                }\n            }\n            for(int i=0;i < m.size();++i){\n                cout << '(' << m[i].row << ',' << m[i].column << ',' << m[i].value << ')' <<  endl;\n            }\n        }\n};",
            1591857399.1881318,
            100,
            "# 答案正确"
        ],
        [
            "8.4 (C++)",
            "裴江博",
            "#include <iostream>\n#include <vector>\n#include <string.h>\nusing namespace std;\n\nclass Sparse : public Matrix{\n    private:\n        int rows;\n        int columns;\n        vector<Entry> m;\n    public:\n        Sparse(int r,int c){\n            rows = r;\n            columns = c;\n        }\n        Sparse operator *(Sparse & sparse2){\n            Sparse result(rows,columns);\n            for(int i=0;i < m.size();++i){\n                for(int j=0;j < sparse2.m.size();++j){\n                    if(m[i].column == sparse2.m[j].row){\n                        Entry num;\n                        num.row = m[i].row;\n                        num.column = sparse2.m[j].column;\n                        num.value = m[i].value * sparse2.m[j].value;\n                        if(result.m.size() == 0) result.m.push_back(num);\n                        else{\n                            int flag = 0;\n                            for(int k=0;k < result.m.size();++k){\n                                if(num.row == result.m[k].row && num.column == result.m[k].column){\n                                    result.m[k].value += num.value;\n                                    flag = 1;\n                                    break;\n                                }\n                            }\n                            if(flag == 0) result.m.push_back(num);\n                        }\n                    }\n                }\n            }\n\t\t\t\t return result;\n        }\n        virtual int size(int dimension) const {\n            if(dimension == 1) return rows;\n            else if(dimension == 2) return columns;\n        }\n\t    virtual void set(int r, int c, double value){\n            Entry num;\n            num.row = r;\n            num.column = c;\n            num.value = value;\n            m.push_back(num);\n        }\n\t    virtual double get(int row, int column) const {\n            for(int i=0;i < m.size();++i){\n                if(m[i].row == row && m[i].column == column) return m[i].value;\n            }\n            return 0;\n        }\n\t    virtual void print(){\n            for(int i=0;i < m.size();++i){\n                for(int j=0;j < m.size()-i-1;++j){\n                    if(m[j].row > m[j+1].row || \n                       (m[j].row == m[j+1].row && m[j].column > m[j+1].column) ){\n                        Entry temp = m[j];\n                        m[j] = m[j+1];\n                        m[j+1] = temp;\n                    }\n                }\n            }\n            for(int i=0;i < m.size();++i){\n                cout << '(' << m[i].row << ',' << m[i].column << ',' << m[i].value << ')' <<  endl;\n            }\n        }\n};",
            1591874252.0381782,
            100,
            "# 答案正确"
        ],
        [
            "8.6 (C++)",
            "裴江博",
            "#include <iostream>\nusing namespace std;\nclass MyTensor : public Tensor<double>{\n    public:\n        double *data;\n        MyTensor(vector<int> sizes):Tensor(sizes){\n            int size=1;\n            for(int i=0;i < sizes.size();++i){\n                size *= sizes[i];\n            }\n            data = new double[size];\n            for(int i=0;i < size;++i){\n                data[i] = 0;\n            }\n        }\n        ~MyTensor(){\n            delete [] data;\n        }\n        double & get(const vector<int> & indexes){\n            int index=0;\n            for(int i=0;i < indexes.size();++i){\n                int num = indexes[i];\n                for(int j=i+1;j < sizes.size();++j){\n                    num *= sizes[j];\n                }\n                index += num;\n            }\n            return data[index];\n        }\n};",
            1592450823.1314192,
            100,
            "# 答案正确"
        ],
        [
            "9.1 (C++)",
            "裴江博",
            "class Circle{\n    private:\n        double r;\n    public:\n        Circle(double r1): r(r1) {}\n        bool operator < (const Circle m){\n            return (r < m.r);\n        }\n        bool operator <= (const Circle m){\n            if(r == m.r) return 1;\n            else if(r < m.r) return 1;\n            else return 0;\n        }    \n        bool operator == (const Circle m){\n            if(r == m.r) return 1;\n            else return 0;\n        }    \n        bool operator != (const Circle m){\n            if(r != m.r) return 1;\n            else return 0;\n        }\n        bool operator > (const Circle m){\n            return (r > m.r);\n        }\n        bool operator >= (const Circle m){\n            if(r == m.r) return 1;\n            else if(r > m.r) return 1;\n            else return 0;\n        }\n};",
            1592839519.5301137,
            100,
            "# 答案正确"
        ],
        [
            "9.2 (C++)",
            "裴江博",
            "class I{\n    private:\n        vector<int> data;\n    public:\n        I(int n1,int n2=-1,int n3=-1,int n4=-1){\n            data.push_back(n1);\n            if(n2 != -1) data.push_back(n2);\n            if(n3 != -1) data.push_back(n3);\n            if(n4 != -1) data.push_back(n4);\n        }\n        \n\t\t  operator vector<int>() const{\n\t\t\t  return data;\n\t\t  }\n};",
            1592888502.74051,
            100,
            "# 答案正确"
        ],
        [
            "9.3 (C++)",
            "裴江博",
            "class Complex{\n    private:\n        double r;\n        double i;\n    public:\n        Complex(double r1,double i1){\n            r = r1;\n            i = i1;\n        }    \n        Complex(double r1){\n            r = r1;\n            i = 0;\n        }    \n        double real() const { return r; }\n        double imag() const { return i; }\n        Complex operator + (const Complex m){\n            Complex result(r,i);\n            result.r = r + m.r;\n            result.i = i + m.i;         \n            return result; \n        }\n        Complex operator - (const Complex m){\n            Complex result(r,i);\n            result.r = r - m.r;\n            result.i = i - m.i;          \n            return result; \n        }\n        Complex operator * (const Complex m){\n            Complex result(r,i);\n            result.r = r * m.r - i * m.i;\n            result.i = i * m.r + r * m.i;       \n            return result; \n        }\n        Complex operator / (const Complex m){\n            Complex result(r,i);\n            result.r = (r * m.r + i * m.i) / ( pow(m.r,2) + pow(m.i,2) ); \n            result.i = (i * m.r - r * m.i) / ( pow(m.r,2) + pow(m.i,2) );           \n            return result; \n        }\n        Complex & operator = (const Complex m){\n            r = m.r;\n            i = m.i;\n            return *this; \n        }\n        Complex & operator += (const Complex m){\n            *this = *this + m;\n            return *this;\n        }\n        Complex & operator -= (const Complex m){\n           *this = *this - m;\n           return *this;\n        }\n        Complex & operator *= (const Complex m){\n            *this = *this * m;\n            return *this;\n        }\n        Complex & operator /= (const Complex m){\n            *this = *this / m;\n            return *this;\n        }\n        bool operator == (const Complex m){\n            if(r == m.r && i == m.i) return 1;\n            else return 0;\n        }\n        bool operator != (const Complex m){\n            if(r != m.r || i != m.i) return 1;\n            else return 0;\n        }\n};\nComplex operator + (const Complex & x,const Complex & y){\n        double r = x.real() + y.real();\n        double i = x.imag() + y.imag();\n        Complex result(r,i);\n        return result; \n}\nComplex operator - (const Complex & x,const Complex & y){\n        double r = x.real() - y.real();\n        double i = x.imag() - y.imag();\n        Complex result(r,i);\n        return result;  \n}",
            1592914503.9421656,
            100,
            "# 答案正确"
        ],
        [
            "9.4 (C++)",
            "裴江博",
            "class Complex{\n    private:\n        double r;\n        double i;\n    public:\n        Complex(){\n            r = 0;\n            i = 0;\n        }\n       Complex operator + (const Complex m){\n            Complex result;\n            result.r = r + m.r;\n            result.i = i + m.i;         \n            return result; \n        }\n        Complex operator - (const Complex m){\n            Complex result;\n            result.r = r - m.r;\n            result.i = i - m.i;          \n            return result; \n        }\n        Complex & operator = (const Complex m){\n            r = m.r;\n            i = m.i;\n            return *this; \n        } \n        double & real() { return r; }\n        double & imag() { return i; }\n        const double & real() const { return r; }\n        const double & imag() const { return i; }\n};\nistream & operator >> (istream & in,Complex & m){\n    in >> m.real() >> m.imag();\n    return in;\n}\nostream & operator << (ostream & out,const Complex & m){\n    out << m.real() << \" + \" << m.imag() << \" i\";\n    return out;\n}\n",
            1592926353.9083471,
            100,
            "# 答案正确"
        ],
        [
            "9.5 (C++)",
            "裴江博",
            "class Complex{\n    private:\n        double r;\n        double i;\n    public:\n        Complex(){\n            r = 0;\n            i = 0;\n        }\n        Complex(const Complex & m){\n            r = m.r;\n            i = m.i;\n        }\n       Complex & operator ++ (){\n            ++r;       \n            return *this; \n        }\n        Complex operator ++ (int){\n            Complex prev_value(*this);\n            r++;          \n            return prev_value; \n        }\n        operator double() const { return r; }\n        double & real() { return r; }\n        double & imag() { return i; }\n        const double & real() const { return r; }\n        const double & imag() const { return i; }\n};\nistream & operator >> (istream & in,Complex & m){\n    in >> m.real() >> m.imag();\n    return in;\n}\nostream & operator << (ostream & out,const Complex & m){\n    out << m.real() << \" + \" << m.imag() << \" i\";\n    return out;\n}\n",
            1592926979.0713093,
            100,
            "# 答案正确"
        ],
        [
            "9.6 (C++)",
            "裴江博",
            "class Tensor{\n    private:\n        vector<double> data;\n        vector<int> sizes;\n    public:\n        Tensor(int n1,int n2=-1,int n3=-1,int n4=-1){\n            sizes.push_back(n1);\n            if(n2 != -1) sizes.push_back(n2);\n            if(n3 != -1) sizes.push_back(n3);\n            if(n4 != -1) sizes.push_back(n4);\n            data.resize(numl());\n        }    \n        int numl(){\n            int size = 1;\n            for(int i = 0;i < sizes.size();++i) size *= sizes[i];\n            return size;\n        }\n        int _index(int *n){\n            int index = 0;\n            for(int i=0; i < sizes.size(); ++i){\n                index *= sizes[i];\n\t\t\t    index += n[i];\n            }\n            return index;\n        }\n        double & operator () (int n1,int n2=0,int n3=0,int n4=0){\n            int n[sizes.size()];\n\t\t\t\t for(int i=0;i < sizes.size();++i){\n\t\t\t\t\t if(i == 0) n[i] = n1;\n\t\t\t\t\t if(i == 1) n[i] = n2;\n\t\t\t\t\t if(i == 2) n[i] = n3;\n\t\t\t\t\t if(i == 3) n[i] = n4;\n\t\t\t\t }\n            return data[_index(n)];\n        }\n        const double & operator () (int n1,int n2=0,int n3=0,int n4=0) const{\n            int n[sizes.size()];\n\t\t\t\t for(int i=0;i < sizes.size();++i){\n\t\t\t\t\t if(i == 0) n[i] = n1;\n\t\t\t\t\t if(i == 1) n[i] = n2;\n\t\t\t\t\t if(i == 2) n[i] = n3;\n\t\t\t\t\t if(i == 3) n[i] = n4;\n\t\t\t\t }\n            int index = 0;\n            for(int i=0; i < sizes.size(); ++i){\n                index *= sizes[i];\n\t\t\t    index += n[i];\n            }\n            return data[index];\n        }\n};",
            1592978487.8741577,
            100,
            "# 答案正确"
        ],
        [
            "9.7 (C++)",
            "裴江博",
            "class Tensor{\n    private:\n        vector<int> sizes;\n        vector<double> values;\n    public:\n\t\t\tTensor(){ }\n        Tensor(vector<int> _sizes,vector<double> _values){\n            sizes = _sizes;\n            values = _values;\n        }   \n        Tensor & operator =(const Tensor m){\n            sizes = m.sizes;\n            values = m.values;\n            return *this;\n        }\n        int get_sizes(int index) const{ return sizes[index]; } \n        double get_values(int d1,int d2,int d3,int d4=-1) const{\n            int n[sizes.size()-1];\n\t\t\t\t for(int i=0;i < sizes.size()-1;++i){\n\t\t\t\t\t if(i == 0) n[i] = d1;\n\t\t\t\t\t if(i == 1) n[i] = d2;\n\t\t\t\t\t if(i == 2) n[i] = d3;\n\t\t\t\t\t if(i == 3) n[i] = d4;\n\t\t\t\t }\n            int index = 0;\n            for(int i=1; i < sizes.size(); ++i){\n                index *= sizes[i];\n\t\t\t    \t  index += n[i-1];\n            }\n            return values[index];\n        }\n};\nistream & operator >> (istream & in,Tensor & m){\n    int dim,size=1;\n    vector<int> _sizes;\n    vector<double> _values;\n    in >> dim;\n    _sizes.push_back(dim);\n    for(int i=0;i < dim;i++){\n        int dim1;\n        in >> dim1;\n        size *= dim1;\n        _sizes.push_back(dim1);\n    }\n    _values.resize(size);\n    for(int i=0;i < size;++i){\n        in >> _values[i];\n    }\n    Tensor temp(_sizes,_values);\n    m = temp;\n\t return in;\n}\nostream & operator << (ostream & out,const Tensor m){\n    out << m.get_sizes(0) << endl;\n\t for (int i = 1; i <= m.get_sizes(0); ++ i){\n\t\t out << m.get_sizes(i) << \" \";\n\t } \n\t out << endl << endl;\n    if(m.get_sizes(0) == 3){\n        for(int i=0;i < m.get_sizes(1);++i){\n            for(int j=0;j < m.get_sizes(2);++j){\n                for(int k=0;k < m.get_sizes(3);++k){\n                    out << m.get_values(i,j,k) << \" \";\n                }\n                out << endl;\n            }\n            out << endl;\n        }\n    }\n    else if(m.get_sizes(0) == 4){\n        for(int i=0;i < m.get_sizes(1);++i){\n            for(int j=0;j < m.get_sizes(2);++j){\n                for(int k=0;k < m.get_sizes(3);++k){\n                    for(int l=0;l < m.get_sizes(4);++l){\n                        out << m.get_values(i,j,k,l) << \" \";\n                    }\n                    out << endl;\n                }\n                out << endl;\n            }         \n        }\n    }\n\t return out;\n}",
            1593089343.634314,
            100,
            "# 答案正确"
        ],
        [
            "10.1 (C++)",
            "裴江博",
            "#include <stdexcept>\n\nclass MatrixSizesDoNotMatchException {};\n\n\ndouble Matrix :: get(int row,int column) const{\n\tif(row > rows || column > columns){\n\t\tthrow out_of_range(\" \");\n\t}\n\treturn elements[(row-1) * columns + column - 1];\n}\nvoid Matrix :: set(int row, int column, double value){\n\tif(row > size(1) || column > size(2)){\n\t\tthrow out_of_range(\" \");\n\t}\n\telements[(row-1) * size(2) + column - 1] = value;\n}\n\t\nMatrix Matrix :: operator + (const Matrix & matrix2) const {\n\tif(rows != matrix2.rows || columns != matrix2.columns){\n\t\tthrow MatrixSizesDoNotMatchException();\n\t}\n\tMatrix m(rows,columns);\n\tfor(int i=0;i < m.rows * m.columns; ++i){\n\t\tm.elements[i] = elements[i] + matrix2.elements[i];\n\t}\n\treturn m;\n}",
            1593493180.9055064,
            100,
            "# 答案正确"
        ],
        [
            "10.2 (C++)",
            "裴江博",
            "catch( NonPositiveValueException & ex){\n\tcout << \"caught: NonPositiveValueException\" << endl;\n}\ncatch(out_of_range & ex){\n\tcout << \"caught: out_of_range\" << endl;\n}",
            1593657242.3604176,
            100,
            "# 答案正确"
        ],
        [
            "15.1 (C++)",
            "裴江博",
            "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nclass Table{\n\tprivate:\n\t \tvector<string> cols;\n\t\tvector<string> *rows;\n\tpublic:\n\t\tTable(){\n\t\t\trows = new vector<string> [2];\n\t\t}\n\t\t~Table(){\n\t\t\tdelete [] rows;\n\t\t}\n\t\tvoid addCol(const string str){\n\t\t\tcols.push_back(str);\n\t\t}\n\t\tvector<string> & operator [] (int index){\n\t\t\treturn rows[index];\t\t\t\n\t\t} \n\t\tstring & json() const {\n\t\t\tstatic string str = \"\";\n\t\t\tstr += \"{\\n\\theaders: ['\";\n\t\t\tstr += cols[0];\n\t\t\tstr += \"','\";\n\t\t\tstr += cols[1];\n\t\t\tstr += \"',],\\n\\trows: [\\n\\t\\t['\";\n\t\t\tstr += rows[0][0];\n\t\t\tstr += \"','\";\n\t\t\tstr += rows[0][1];\n\t\t\tstr += \"',],\\n\\t\\t['\";\n\t\t\tstr += rows[1][0];\n\t\t\tstr += \"','\";\n\t\t\tstr += rows[1][1];\n\t\t\tstr += \"',],\\n\\t],\\n}\\n\";\n\t\t\treturn str;\n\t\t}\n};",
            1594259845.095661,
            100,
            "# 答案正确"
        ],
        [
            "2020-07-09 LAB",
            "裴江博",
            "#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Integer{\n\tprivate:\n\t\tint id;\n\t\tstatic int count;\n\t\tstatic Integer * integers[10];\n\t\tfriend istream & operator >> (istream & in,Integer & m);\n\t\tfriend ostream & operator << (ostream & out,const Integer & m);\n\tpublic:\n\t\tInteger(){\n\t\t\tid = 0;\n\t\t\tintegers[count++] = this;\n\t\t}\n\t\tInteger(int n){\n\t\t\tid = n;\n\t\t\tintegers[count++] = this;\n\t\t}\n\t\tvoid increase_one(int value){\n\t\t\tid += value;\n\t\t}\n\t\tstatic void increase_all(Integer m){\n\t\t\tfor(int i=0;i < count;++i){\n\t\t\t\tintegers[i] -> increase_one(m.id);\n\t\t\t}\n\t\t}\n};\nInteger * Integer::integers[10];\nint Integer:: count = 0;\nistream & operator >> (istream & in,Integer & m){\n\tint n;\n\tin >> n;\n\tm.id = n;\n\treturn in;\n}\nostream & operator << (ostream & out,const Integer & m){\n\tout << m.id;\n\treturn out;\n}",
            1594264431.5602393,
            100,
            "# 答案正确"
        ],
        [
            "A.1 (C++)",
            "裴江博",
            "\tprivate:\n\t\tNode<E> * get_node(int index) const {\n\t\t\tif (index < -1 || index > _size) \n\t\t\t\tthrow NotSuchElementException();\n\t\t\tif (index == -1 || index == _size){\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (index < _size / 2) {\n\t\t\t\tNode<E> * node = head;\n\t\t\t\tNode<E> * prev_node = NULL;\n\t\t\t\tNode<E> * next_node = NULL;\n\t\t\t\tI(i, index){\n\t\t\t\t\tnext_node = node->next_node(prev_node);\n\t\t\t\t\tprev_node = node;\n\t\t\t\t\tnode = next_node;\n\t\t\t\t}\n\t\t\t\treturn node;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tNode<E> * node = tail;\n\t\t\t\tNode<E> * prev_node = NULL;\n\t\t\t\tNode<E> * next_node = NULL;\n\t\t\t\tI(i, (_size-1-index)){\n\t\t\t\t\tprev_node = node->prev_node(next_node);\n\t\t\t\t\tnext_node = node;\n\t\t\t\t\tnode = prev_node;\n\t\t\t\t}\n\t\t\t\treturn node;\n\t\t\t}\n\t\t}\n\tpublic:\n\t\tE & get(int index) const {\n\t\t\tNode<E> * node = get_node(index);\n\t\t\treturn node->element;\n\t\t}\n\t\tvoid remove (int index) {\n\t\t\tNode<E> * node = get_node(index);\n\t\t\tNode<E> * prev_node = get_node(index-1);\n\t\t\tNode<E> * next_node = get_node(index+1);\n\t\t\tif (prev_node != 0) prev_node->update_next_node(node,next_node);\n\t\t\tif (next_node != 0) next_node->update_prev_node(node,prev_node);\n\t\t\tif (prev_node == 0) head = next_node;\n\t\t\tif (next_node == 0) tail = prev_node;\n\t\t\tdelete node;\n\t\t\t-- _size;\n\t\t}\n\n\tvoid removeFirst () {\n\t\tremove(0);\n\t}\n\n\tvoid removeLast () {\n\t\tremove(_size-1);\n\t}\n\n\tvoid add(int index, const E & e) {\n\t\tif (index < 0 || index > _size) \n\t\t\tthrow NotSuchElementException();\n\t\tNode<E> * node = new Node<E>();\n\t\tnode->element = e;\n\t\tNode<E> * next_node = (index == _size ? 0 : get_node(index));\n\t\tNode<E> * prev_node = (next_node == 0 ? tail : get_node(index-1));\n\t\tnode->update_prev_and_next_node(prev_node,next_node);\n\t\tif (prev_node != 0) prev_node->update_next_node(next_node,node);\n\t\tif (next_node != 0) next_node->update_prev_node(prev_node,node);\n\t\tif (prev_node == 0) head = node;\n\t\tif (next_node == 0) tail = node;\n\t\t++ _size;\n\t}\n\n\tvoid addFirst (const E & e) {\n\t\tadd(0, e);\n\t}\n\n\tvoid addLast (const E & e) {\n\t\tadd(_size, e);\n\t}\n\tvoid clear() {\n\t\twhile (_size > 0) removeFirst();\n\t}\n\n\tvoid addAll(const LinkedList & list, int index=-1) {\n\t\tif (index == -1) index = _size;\n\t\tI(i, list._size) {\n\t\t\tNode<E> * node = list.get_node(i);\n\t\t\tadd(index + i, node->element);\n\t\t}\n\t}\n\n\tLinkedList(const LinkedList & list) : _size(0), head(0), tail(0) {\n\t\taddAll(list);\n\t}\n\n\tLinkedList & operator = (const LinkedList & list) {\n\t\tclear();\n\t\taddAll(list);\n\t\treturn *this;\n\t}\n\n\t~LinkedList() {\n\t\tclear();\n\t}\n\n\tint indexOf(const E & e) const {\n\t\tNode<E> * node = head;\n\t\tNode<E> * prev_node = NULL;\n\t\tNode<E> * next_node = NULL;\n\t\tI(i, _size) {\n\t\t\tif (node->element == e) return i;\n\t\t\tnext_node = node->next_node(prev_node);\n\t\t\tprev_node = node;\n\t\t\tnode = next_node;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tint lastIndexOf(const E & e) const {\n\t\tNode<E> * node = tail;\n\t\tNode<E> * prev_node = NULL;\n\t\tNode<E> * next_node = NULL;\n\t\tI(i, _size) {\n\t\t\tif (node->element == e) return i;\n\t\t\tprev_node = node->prev_node(next_node);\n\t\t\tnext_node = node;\n\t\t\tnode = prev_node;\t\n\t\t}\n\t\treturn -1;\n\t}\n\n\tbool contains(const E & e) const {\n\t\treturn indexOf(e) >= 0;\n\t}\n\n\tvoid removeFirstOccurrence(const E & e) {\n\t\tint index = indexOf(e);\n\t\tif (index == -1)\n\t\t\tthrow NotSuchElementException();\n\t\tremove(index);\n\t}\n\n\tvoid removeLastOccurrence(const E & e) {\n\t\tint index = lastIndexOf(e);\n\t\tif (index == -1)\n\t\t\tthrow NotSuchElementException();\n\t\tremove(index);\n\t}",
            1594819033.1333635,
            100,
            "# 答案正确"
        ],
        [
            "A.2 (C++)",
            "裴江博",
            "template <typename E>\nvoid LinkedList<E>::removeAll(const E & e){\n\tint index = -1;\n\twhile( (index = indexOf(e)) != -1){\n\t\tremove(index);\n\t}\n}",
            1594865762.2128427,
            100,
            "# 答案正确"
        ],
        [
            "A.3 (C++)",
            "裴江博",
            "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <stdexcept>\nusing namespace std;\n\n#define I(i,n) for (size_t i = 0; i < n; ++ i)\n\nclass NoSuchKeyException {};\n\nsize_t circular_shift(size_t bits, int shift_bits) {\n\tconst int num_bits = 8 * sizeof(size_t);\n\tshift_bits = shift_bits % num_bits;\n\treturn bits << shift_bits | bits >> (num_bits - shift_bits);\n}\n\nsize_t hash_function(const int & key) {\n\tsize_t code = 0;\n\tint num = key;\n\tfor(int i=0;num != 0;++i){\n\t\tcode ^= circular_shift(num%10, i * 5);\n\t\tnum /= 10;\n\t}\t\n\treturn code;\n}\n\ntemplate <typename V>\nclass HT\n{\n\tclass Tuple\n\t{\n\tpublic:\n\t    int key;\n\t\tV val;\n\t\tbool in_use;\n\n\t\tTuple() : in_use(false) {}\n\t};\n\n\tvector<Tuple> tuples;\n\tsize_t _size;\n\n\tsize_t canonical_index(const int & key) const {\n\t\tsize_t hash_code = hash_function(key); // needs hash_function(K)\n\t\treturn hash_code % tuples.size();\n\t}\n\n\t// the returned tuple is either empty or with the same key\n\tsize_t indexOfKey(const int & key) const {\n\t\tsize_t index = canonical_index(key);\n\t\twhile (true) { // will enter a dead loop if there is not empty tuple\n\t\t\tif (! tuples[index].in_use) return index;\n\t\t\tif (tuples[index].key == key) return index;\n\t\t\tindex = (index + 1) % tuples.size();\n\t\t}\n\t}\n\npublic:\n\tHT() : _size(0) {\n\t\ttuples.resize(2000);\n\t}\n\n\tbool containsKey(const int & key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\treturn tuples[index].in_use;\n\t}\n\n\tconst V & operator [] (const int & key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples[index].val;\n\t}\n\n\tV & operator [] (const int & key) {\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples[index].val;\n\t}\n\n\tvoid put(const int & key, const V & val) {\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].key = key;\n\t\ttuples[index].val = val;\n\t\tif (tuples[index].in_use) return;\n\t\ttuples[index].in_use = true;\n\t\t++ _size;\n\t\t// make sure empty > size / 2\n\t\tif (2 * _size > tuples.size())\n\t\t\t_double_tuples();\n\t}\n\n\tvoid _double_tuples() {\n\t\tvector<Tuple> non_empty_tuples;\n\t\tI(i, tuples.size())\n\t\t\tif (tuples[i].in_use)\n\t\t\t\tnon_empty_tuples.push_back(tuples[i]);\n\t\tclear();\n\t\ttuples.resize(tuples.size() * 2);\n\t\tI(i, non_empty_tuples.size())\n\t\t\tput(non_empty_tuples[i].key, non_empty_tuples[i].val);\n\t}\n\n\tstatic bool _between(size_t hole, size_t canonical, size_t tuple_index) {\n\t\tif (hole < tuple_index)\n\t\t\treturn canonical > hole && canonical <= tuple_index;\n\t\telse\n\t\t\treturn canonical > hole || canonical <= tuple_index;\n\t}\n\n\tvoid remove(const int & key) { \n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\ttuples[index].in_use = false;\n\t\t-- _size;\n\t\t// if there is a hole between a tuple and its canonical position\n\t\t// move the tuple to the hole\n\t\tsize_t hole = index;\n\t\tsize_t tuple_index = hole;\n\t\twhile (true) {\n\t\t\ttuple_index = (tuple_index + 1) % tuples.size();\n\t\t\tif (! tuples[tuple_index].in_use) return;\n\t\t\tsize_t canonical = canonical_index(tuples[tuple_index].key);\n\t\t\tif (_between(hole, canonical, tuple_index)) continue;\n\t\t\ttuples[hole] = tuples[tuple_index];\n\t\t\thole = tuple_index;\n\t\t\ttuples[hole].in_use = false;\n\t\t}\n\t}\n\n\tsize_t size() const { return _size; }\n\n\tvoid clear() {\n\t\tI(i, tuples.size())\n\t\t\ttuples[i].in_use = false;\n\t\t_size = 0;\n\t}\n\tvector<int> getKeys(){\n\t\tvector<int> keys;\n\t\tfor(int i=0;i < tuples.size();++i){\n\t\t\tif(tuples[i].in_use){\n\t\t\t\tkeys.push_back(tuples[i].key);\n\t\t\t}\n\t\t}\n\t\treturn keys;\n\t}\n};",
            1595471370.3606436,
            100,
            "# 答案正确"
        ],
        [
            "A.4 (C++)",
            "裴江博",
            "#include <iostream>\n#include <string>\n#include <vector>\n#include <typeinfo>\nusing namespace std;\n\nconst int initial_size = 40;\n\nclass NoSuchKeyException {};\nclass NoSuchValueException {};\n\nsize_t circular_shift(size_t bits, int shift_bits) {\n\tconst int num_bits = 8 * sizeof(size_t);\n\tshift_bits = shift_bits % num_bits;\n\treturn bits << shift_bits | bits >> (num_bits - shift_bits);\n}\n\nsize_t hash_function(const string & key) {\n\tsize_t code = 0;\n\tfor(int i = 0; i < key.size(); i ++) {\n\t\tcode ^= circular_shift(key[i], i * 5);\n\t}\n\treturn code;\n}\n\nsize_t hash_function(const int & key) {\n\tsize_t code = 0;\n\tint tmp = key;\n\tfor(int i = 0; tmp > 0; tmp /= 10, i ++) {\n\t\tcode ^= circular_shift(tmp % 10, i * 5);\n\t}\n\treturn code;\n}\n\nclass HT {\n\tclass Tuple {\n\tpublic:\n\t\tstring key_string;\n\t\tint key_int;\n\t\tstring value_string;\n\t\tint value_int;\n\t\tbool string_in_use;\n\t\tbool int_in_use;\n\n\t\tTuple(): string_in_use(false), int_in_use(false), value_int(0) {}\n\t};\n\n\tclass RefTuple {\n\tpublic:\n\t\tHT * hash_table;\n\t\tTuple * tuple;\n\t\tstring key_string;\n\t\tint key_int;\n\n\t\tRefTuple(HT * ht, Tuple * tp, string key_string): hash_table(ht), tuple(tp), key_string(key_string) {}\n\n\t\tRefTuple(HT * ht, Tuple * tp, int key_int): hash_table(ht), tuple(tp), key_int(key_int) {}\n\n\t\toperator string() {\n\t\t\tif(tuple == NULL) throw NoSuchKeyException();\n\t\t\treturn tuple -> value_string;\n\t\t}\n\n\t\toperator int() {\n\t\t\tif(tuple == NULL) throw NoSuchValueException();\n\t\t\treturn tuple -> value_int;\n\t\t}\n\t};\n\n\tvector<Tuple> tuples;\n\tsize_t _size;\npublic:\n\tHT() {\n\t\t_size = 0;\n\t\ttuples.resize(initial_size);\n\t}\n\n\tsize_t size() {return _size;}\n\n\ttemplate <typename K>\n\tsize_t canonical_index(const K & key) const {\n\t\tsize_t hash_code = hash_function(key);\n\t\treturn hash_code % tuples.size();\n\t}\n\n\tsize_t indexOfKey(const string & key) const {\n\t\tsize_t index = canonical_index(key);\n\t\twhile(true) {\n\t\t\tif(!tuples[index].string_in_use) return index;\n\t\t\tif(tuples[index].key_string == key) return index;\n\t\t\tindex = (index + 1) % tuples.size();\n\t\t}\n\t}\n\n\tsize_t indexOfKey(const int & key) const {\n\t\tsize_t index = canonical_index(key);\n\t\twhile(true) {\n\t\t\tif(!tuples[index].int_in_use) return index;\n\t\t\tif(tuples[index].key_int == key) return index;\n\t\t\tindex = (index + 1) % tuples.size();\n\t\t}\n\t}\n\n\tstring To_string(int value) {\n\t\tint temp = value;\n\t\tstring s;\n\t\tfor(int i = 0; temp > 0; temp /= 10, i ++) {\n\t\t\ts += temp % 10;\n\t\t}\n\t\treturn s;\n\t}\n\n\tvoid put(const string & key, string & value) {\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].key_string = key;\n\t\ttuples[index].value_string = value;\n\t\tif(tuples[index].string_in_use) return;\n\t\ttuples[index].string_in_use = true;\n\t\t_size ++;\n\t\tif(2 * _size > tuples.size()) _double_tuples();\n\t}\n\n\tvoid put(const string & key, int & value) {\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].key_string = key;\n\t\ttuples[index].value_int = value;\n\t\ttuples[index].value_string = To_string(value);\n\t\tif(tuples[index].string_in_use) return;\n\t\ttuples[index].string_in_use = true;\n\t\t_size ++;\n\t\tif(2 * _size > tuples.size()) _double_tuples();\n\t}\n\n\tvoid put(int key, string & value) {\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].key_int = key;\n\t\ttuples[index].value_string = value;\n\t\tif(tuples[index].int_in_use) return;\n\t\ttuples[index].int_in_use = true;\n\t\t_size ++;\n\t\tif(2 * _size > tuples.size()) _double_tuples();\n\t}\n\n\tvoid put(int key, int & value) {\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].key_int = key;\n\t\ttuples[index].value_int = value;\n\t\ttuples[index].value_string = To_string(value);\n\t\tif(tuples[index].int_in_use) return;\n\t\ttuples[index].int_in_use = true;\n\t\t_size ++;\n\t\tif(2 * _size > tuples.size()) _double_tuples();\n\t}\n\n\tvoid _double_tuples() {\n\t\tvector<Tuple> non_empty_tuples;\n\t\tfor(int i = 0; i < tuples.size(); i ++) {\n\t\t\tif(tuples[i].string_in_use || tuples[i].int_in_use) {\n\t\t\t\tnon_empty_tuples.push_back(tuples[i]);\n\t\t\t}\n\t\t\ttuples[i].string_in_use = false;\n\t\t\ttuples[i].int_in_use = false;\n\t\t}\n\t\ttuples.resize(2 * tuples.size());\n\t\tfor(int i = 0; i < non_empty_tuples.size(); i ++) {\n\t\t\tif(non_empty_tuples[i].string_in_use) {\n\t\t\t\tput(non_empty_tuples[i].key_string, non_empty_tuples[i].value_string);\n\t\t\t}\n\t\t\tif(non_empty_tuples[i].int_in_use) {\n\t\t\t\tput(non_empty_tuples[i].key_int, non_empty_tuples[i].value_int);\n\t\t\t}\n\t\t}\n\t}\n\n\ttemplate <typename K>\n\tRefTuple operator[] (const K & key) {\n\t\tsize_t index = indexOfKey(key);\n\t\tif(!tuples[index].int_in_use && !tuples[index].string_in_use) return RefTuple(this, NULL, key);\n\t\treturn RefTuple(this, &tuples[index], key);\n\t}\n\n\ttemplate <typename K>\n\tconst RefTuple operator[] (const K & key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\tif(!tuples[index].int_in_use && !tuples[index].string_in_use) return RefTuple(this, NULL, key);\n\t\treturn RefTuple(this, &tuples[index], key);\n\t}\n};",
            1595832658.9886498,
            100,
            "# 答案正确"
        ],
        [
            "A.5 (C++)",
            "裴江博",
            "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <stdexcept>\nusing namespace std;\n\nclass NoSuchKeyException {};\nclass NoSuchValueException {};\n\nsize_t circular_shift(size_t bits, int shift_bits){\n\tconst int num_bits = 8 * sizeof(size_t);\n\tshift_bits = shift_bits % num_bits;\n\treturn bits << shift_bits | bits >> (num_bits - shift_bits);\n}\n\nsize_t hash_funtion(const string & key){\n\tsize_t code = 0;\n\tfor(int i = 0; i <  key.size(); i++){\n\t\tcode ^= circular_shift(key[i], i * 5);\n\t}\n\treturn code;\n}\n\nsize_t hash_funtion(const int & key){\n\tsize_t code = 0;\n\tint num = key;\n\tfor(int i = 0; num > 0; i++){\n\t\tcode ^= circular_shift(num % 10, i * 5);\n\t\tnum /= 10; \n\t}\n\treturn code;\n}\n\nclass HT\n{\n\tclass Tuple\n\t{\n\tpublic:\n\t\tstring str_key;\n\t\tstring str_val;\n\t\tbool str_use;\n\n\t\tint int_key;\n\t\tint int_val;\n\t\tint int_use;\n\n\t\tTuple() : str_use(false), int_use(false) {}\n\t};\n\n\tclass TupleRef {\n\tpublic:\n\t\tHT * ht;\n\t\tTuple * tp;\n\t\tstring str_key;\n\t\tint int_key;\n\n\t\tTupleRef(HT * ht, Tuple * tp, string str_key): ht(ht), tp(tp), str_key(str_key) {}\n\n\t\tTupleRef(HT * ht, Tuple * tp, int int_key): ht(ht), tp(tp), int_key(int_key) {}\n\n\t\toperator string() {\n\t\t\tif(tp == NULL) throw NoSuchKeyException();\n\t\t\treturn tp->str_val;\n\t\t}\n\n\t\toperator int() {\n\t\t\tif(tp == NULL) throw NoSuchValueException();\n\t\t\treturn tp->int_val;\n\t\t}\n\n\t\tTupleRef & operator= (const int & val){\n\t\t\ttp->int_val = val;\n\t\t\treturn *this;\n\t\t}\n\t\tTupleRef & operator= (const string & val){\n\t\t\ttp->str_val = val;\n\t\t\treturn *this;\n\t\t}\n\t};\n\n\tvector<Tuple> tuples;\n\tsize_t _size;\n\n\ttemplate <typename K>\n\tsize_t canonical_index(const K & key) const{\n\t\tsize_t hash_code = hash_funtion(key);\n\t\treturn hash_code % tuples.size();\n\t}\n\n\tsize_t indexOfKey(const string & key) const{\n\t\tsize_t index = canonical_index(key);\n\t\twhile (true){\n\t\t\tif(!tuples[index].str_use) return index;\n\t\t\tif(tuples[index].str_key == key) return index;\n\t\t\tindex = (index + 1) % tuples.size();\n\t\t}\n\t}\n\n\tsize_t indexOfKey(const int & key) const{\n\t\tsize_t index = canonical_index(key);\n\t\twhile(true){\n\t\t\tif(!tuples[index].str_use) return index;\n\t\t\tif(tuples[index].int_key == key) return index;\n\t\t\tindex = (index + 1) % tuples.size();\n\t\t}\n\t}\n\npublic:\n\tHT() : _size(0) {\n\t\ttuples.resize(40);\n\t}\n\n\tsize_t size() {return _size; }\n\n\tvoid put(const string & key, string & val){\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].str_key = key;\n\t\ttuples[index].str_val = val;\n\t\tif(tuples[index].str_use) return;\n\t\ttuples[index].str_use = true;\n\t\t_size++;\n\t\tif(2 * _size > tuples.size()) _double_tuples(); \n \t}\n\tvoid put(const string & key, int & val){\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].str_key = key;\n\t\ttuples[index].int_val = val;\n\t\tif(tuples[index].str_use) return;\n\t\ttuples[index].str_use = true;\n\t\t_size++;\n\t\tif(2 * _size > tuples.size()) _double_tuples(); \n \t}\n\tvoid put(const int & key, string & val){\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].int_key = key;\n\t\ttuples[index].str_val = val;\n\t\tif(tuples[index].int_use) return;\n\t\ttuples[index].int_use = true;\n\t\t_size++;\n\t\tif(2 * _size > tuples.size()) _double_tuples(); \n \t}\n\tvoid put(const int & key, int & val){\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].int_key = key;\n\t\ttuples[index].int_val = val;\n\t\tif(tuples[index].int_use) return;\n\t\ttuples[index].int_use = true;\n\t\t_size++;\n\t\tif(2 * _size > tuples.size()) _double_tuples(); \n \t}\n\t\n\tTupleRef operator[] (int key) {\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].int_key = key;\n\t\tif(tuples[index].int_use) return TupleRef(this, &tuples[index], key);\n\t\ttuples[index].int_use = true;\n\t\t_size ++;\n\t\tif(2 * _size > tuples.size()) _double_tuples();\n\t\treturn TupleRef(this, &tuples[index], key);\n\t}\n\tTupleRef operator[] (string key) {\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].str_key = key;\n\t\tif(tuples[index].str_use) return TupleRef(this, &tuples[index], key);\n\t\ttuples[index].str_use = true;\n\t\t_size ++;\n\t\tif(2 * _size > tuples.size()) _double_tuples();\n\t\treturn TupleRef(this, &tuples[index], key);\n\t}\n\n\tvoid _double_tuples() {\n\t\tvector<Tuple> non_empty_tuples;\n\t\tfor(int i = 0; i < tuples.size(); i++){\n\t\t\tif(tuples[i].str_use || tuples[i].int_use){\n\t\t\t\tnon_empty_tuples.push_back(tuples[i]);\n\t\t\t}\n\t\t}\n\t\tclear();\n\t\ttuples.resize(2 * tuples.size());\n\t\tfor(int i = 0; i < non_empty_tuples.size(); i++){\n\t\t\tif(non_empty_tuples[i].str_use) {\n\t\t\t\tput(non_empty_tuples[i].str_key, non_empty_tuples[i].str_val);\n\t\t\t}\n\t\t\tif(non_empty_tuples[i].int_use) {\n\t\t\t\tput(non_empty_tuples[i].int_key, non_empty_tuples[i].int_val);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid clear(){\n\t\tfor(int i = 0; i < tuples.size(); i++){\n\t\t\ttuples[i].str_use = false;\n\t\t\ttuples[i].int_use = false;\n\t\t}\n\t\t_size = 0;\n\t}\n};",
            1596124257.3342667,
            100,
            "# 答案正确"
        ]
    ],
    "table_name": "答案"
}