{
    "__update_time__": 1596194039.2901492,
    "field_names": [
        "题目名",
        "问题",
        "主程序",
        "答案",
        "评语",
        "开始时间",
        "截止时间",
        "分数",
        "提交时间"
    ],
    "field_types": [
        "text",
        "text",
        "text",
        "text",
        "text",
        "time",
        "time",
        "number",
        "time"
    ],
    "rows": [
        [
            "A.5 (C++)",
            "<p>写出一个键和值的类型都可以是string或int的哈希表类, HT。<br>本题难度大，参考答案有270行，截止时间延长8天。<br>注意<br></p><ol><li>HT不是一个模版类，但是HT的一个对象可以同时使用int和string的对象作为键。</li><li>HT中去掉了put函数，HT的[]操作符同时具有get和put的功能。</li></ol><p><span style=\"font-weight: bolder;\">EXAMPLE INPUT</span></p><pre style=\"font-size: 14px;\">1 2 3 4 5 6 7 8\n</pre><p><span style=\"font-weight: bolder;\">EXAMPLE OUTPUT</span></p><pre style=\"font-size: 14px;\">4\n2\n4\n6\n8</pre>",
            "#include \"source.cpp\"\n\n#include <iostream>\n#include <sstream>\nusing namespace std;\n\nint main() {\n\tHT map;\n\t\n\tint key1;\n\tint value1;\n\tcin >> key1 >> value1;\n\tmap[key1] = value1;\n\t\n\tstring key2;\n\tstring value2;\n\tcin >> key2 >> value2;\n\tmap[key2] = value2;\n\t\n\tint key3;\n\tstring value3;\n\tcin >> key3 >> value3;\n\tmap[key3] = value3;\n\t\n\tstring key4;\n\tint value4;\n\tcin >> key4 >> value4;\n\tmap[key4] = value4;\n\t\n\tcout << map.size() << endl;\n\tcout << (int)map[key1] << endl;\n\tcout << (string)map[key2] << endl;\n\tcout << (string)map[key3] << endl;\n\tcout << (int)map[key4] << endl;\n}",
            "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <stdexcept>\n#include <cstdlib>\nusing namespace std;\n\n#define I(i,n) for (size_t i = 0; i < n; ++ i)\n\nclass NoSuchKeyException {};\n\nsize_t circular_shift(size_t bits, int shift_bits) {\n    const int num_bits = 8 * sizeof(size_t);\n    shift_bits = shift_bits % num_bits;\n    return bits << shift_bits | bits >> (num_bits - shift_bits);\n}\n\nsize_t hash_function(const string & key) {\n    size_t code = 0;\n    I(i, key.size())\n        code ^= circular_shift(key[i], i * 5);\n    return code;\n}\n\nstring intToString(int num){\n    int flag = 1;\n    int i = 0,j = 0;\n    string tmp;char res[100] = \"\";\n    char buf[100] = \"\";\n    if(num < 0)\n        res[i++] = '-';\n    num = abs(num);\n    while(num){\n        buf[j++] = num%10 +'0';\n        num /= 10;\n    }\n    j--;\n    while(j>=0)\n        res[i++] = buf[j--];\n\n    tmp = res;\n    return tmp;\n}\n\n\nclass String{\npublic:\n    string str;\n    String(){}\n    String(int a){\n        str = intToString(a);\n    }\n    String(string a){\n        str = a;\n    }\n\n    operator string(){\n        return str;\n    }\n    operator int() {\n        return atoi(str.c_str());\n    }\n    String &operator = (const String & val){\n        this->str = val.str;\n        //cout<<\"this:\"<<this<<endl;\n        return *this;\n    }\n};\n\nclass HT\n{\n    class Tuple\n    {\n    public:\n        String key;\n        String val;\n        bool in_use;\n\n        Tuple() : in_use(false) {}\n        //operator int(){return atoi(val.c_str());}\n    };\n\n    vector<Tuple> tuples;\n    size_t _size;\n\n    size_t canonical_index(const string & key) const {\n        size_t hash_code = hash_function(key); // needs hash_function(K)\n        return hash_code % tuples.size();\n    }\n\n    // the returned tuple is either empty or with the same key\n    size_t indexOfKey(const string & key) const {\n        size_t index = canonical_index(key);\n        while (true) { // will enter a dead loop if there is not empty tuple\n            if (! tuples[index].in_use) return index;\n            if (tuples[index].key.str == key) return index;\n            index = (index + 1) % tuples.size();\n        }\n    }\n\npublic:\n    HT() : _size(0) {\n        tuples.resize(2);\n    }\n\n    bool containsKey(const string & key) const{\n        size_t index = indexOfKey(key);\n        return tuples[index].in_use;\n    }\n\n    const string & operator[] (const string & key) const {\n        size_t index = indexOfKey(key);\n        if(! tuples[index].in_use){\n            throw NoSuchKeyException();\n        }\n        return tuples[index].val.str;\n    }\n\n    String & operator[] (const string & key) {\n        size_t index = indexOfKey(key);\n        if(! tuples[index].in_use){\n            //throw NoSuchKeyException();\n            tuples[index].in_use = true;\n            tuples[index].key = key;\n            ++_size;\n            if(2 * _size > tuples.size())\n                _double_tuples();\n            index = indexOfKey(key);\n        }\n        return tuples[index].val;\n    }\n    String & operator[] (const int & key1) {\n        string key  = to_string(key1);\n        size_t index = indexOfKey(key);\n        if(! tuples[index].in_use){\n            //throw NoSuchKeyException();\n            tuples[index].in_use = true;\n            tuples[index].key = key;\n            ++_size;\n            if(2 * _size > tuples.size())\n                _double_tuples();\n            index = indexOfKey(key);\n        }\n        return tuples[index].val;\n    }\n    const String & operator[] (const int & key1) const{\n        string key  = to_string(key1);\n        size_t index = indexOfKey(key);\n        if(! tuples[index].in_use){\n            throw NoSuchKeyException();\n        }\n        return tuples[index].val;\n    }\n\n\n    void put(const String &key, const String & val){\n        size_t index = indexOfKey(key.str);\n        tuples[index].key = key;\n        tuples[index].val = val;\n        if(tuples[index].in_use) return;\n        tuples[index].in_use = true;\n        ++_size;\n        if(2 * _size > tuples.size())\n            _double_tuples();\n    }\n\n    void _double_tuples(){\n        vector<Tuple> non_empty_tuples;\n        I(i, tuples.size())\n            if(tuples[i].in_use)\n                non_empty_tuples.push_back(tuples[i]);\n        clear();\n        tuples.resize(tuples.size() * 2);\n        I(i, non_empty_tuples.size())\n            put(non_empty_tuples[i].key, non_empty_tuples[i].val);\n    }\n\n    static bool _between(size_t hole, size_t canonical, size_t tuple_index) {\n        if (hole < tuple_index)\n            return canonical > hole && canonical <= tuple_index;\n        else\n            return canonical > hole || canonical <= tuple_index;\n    }\n\n    void remove(const string & key) {\n        size_t index = indexOfKey(key);\n        if (! tuples[index].in_use){\n            throw NoSuchKeyException();\n        }\n        tuples[index].in_use = false;\n        -- _size;\n        // if there is a hole between a tuple and its canonical position\n        // move the tuple to the hole\n        size_t hole = index;\n        size_t tuple_index = hole;\n        while (true) {\n            tuple_index = (tuple_index + 1) % tuples.size();\n            if (! tuples[tuple_index].in_use) return;\n            size_t canonical = canonical_index(tuples[tuple_index].key);\n            if (_between(hole, canonical, tuple_index)) continue;\n            tuples[hole] = tuples[tuple_index];\n            hole = tuple_index;\n            tuples[hole].in_use = false;\n        }\n    }\n\n    size_t  size() const {return _size;}\n\n    void clear(){\n        I(i, tuples.size())\n            tuples[i].in_use = false;\n        _size = 0;\n    }\n\n//    friend ostream & operator << (ostream & out, const HT & dict);\n//    friend istream & operator >> (istream & in, HT & dict);\n\n};\n",
            "main.cpp: In function ‘int main()’:\nmain.cpp:7:5: error: redefinition of ‘int main()’\n int main() {\n     ^\nIn file included from main.cpp:1:0:\nsource.cpp:204:5: note: ‘int main()’ previously defined here\n int main() {\n     ^\nmain.cpp:8:2: error: ‘HT’ was not declared in this scope\n  HT map;\n  ^\nmain.cpp:13:2: error: ‘map’ was not declared in this scope\n  map[key1] = value1;\n  ^\n",
            1594951200,
            1596200400,
            100,
            1595476154.1582162
        ]
    ]
}