{
    "__update_time__": 1596194041.5120819,
    "field_names": [
        "题目名",
        "用户名",
        "答案",
        "提交时间",
        "分数",
        "评语"
    ],
    "field_types": [
        "text",
        "text",
        "text",
        "time",
        "number",
        "text"
    ],
    "foreign_keys": {},
    "primary_keys": [],
    "rows": [
        [
            "测试1",
            "向鼎",
            "#include <iostream>\nusing namespace std;\n\nint main() {\n\tchar a[20],b[20],c[20];\n\tcin >> a>>b>>c;\n    cout<< c<<' '<<b<<' '<<a<<endl;\n\treturn 0;\n}",
            1587607827.5034425,
            100,
            "# 答案正确"
        ],
        [
            "测试2",
            "向鼎",
            "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint main() {\n    char words[10][20];\n    for(int i = 0; i < 10; ++i) {\n        cin>>words[i];\n    }\n    for (int j = 0; j < 10; ++j) {\n        for (int i = j; i < 10; ++i) {\n            if(strcmp(words[j],words[i]) >= 1){\n                char temp[20];\n                strcpy(temp,words[j]);\n                strcpy(words[j],words[i]);\n                strcpy(words[i],temp);\n\n            }\n        }\n    }\n    for (int k = 0; k < 10; ++k) {\n        cout<<words[k]<<' ';\n    }cout<<endl;\n    return 0;\n}",
            1587608602.753219,
            100,
            "# 答案正确"
        ],
        [
            "1.1 (C++)",
            "向鼎",
            "class Matrix5x5 {\npublic:\n    int matrix[5][5];\n\n    Matrix5x5(){\n        for (int row = 0; row < 5; ++row) {\n            for (int col = 0; col < 5; ++col) {\n                matrix[row][col] = 0;\n            }\n        }\n    }\n\n    double get(int row,int col){\n        return matrix[row][col];\n    }\n\n    void set(int row,int col,double value){\n        matrix[row][col] = value;\n    }\n\n};\n    Matrix5x5 operator +(Matrix5x5 & Ma, Matrix5x5 & Mb){\n        Matrix5x5 mc;\n        for (int row = 0; row < 5; ++row) {\n            for (int col = 0; col < 5; ++col) {\n                mc.matrix[row][col] = Ma.matrix[row][col] + Mb.matrix[row][col];\n            }\n        }\n        return mc;\n    }\n",
            1587696593.772524,
            100,
            "# 答案正确"
        ],
        [
            "1.2 (C++)",
            "向鼎",
            "#include <cstring>\nclass School{\npublic:\n    char name[30];\n    int age;\n\n\n    School(){\n        strcpy(this->name,\"NO_NAME\");\n        this->age = 0;\n    }\n    void setName(char name1[]){\n        strcpy(this->name , name1);\n    }\n    void setAge(int year1){\n        this->age = year1;\n    }\n    void operator ++(){\n        this->age++;\n    }\n};\n",
            1588212703.337156,
            100,
            "# 答案正确"
        ],
        [
            "2.1 (C++)",
            "向鼎",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix{\nprivate:\n    int rows;\n    int columns;\n    double *values;\npublic:\n    Matrix(int rows,int columns){\n        values = new double[rows * columns];\n        this->rows = rows;\n        this->columns = columns;\n        for (int i = 0; i < rows * columns; ++i) {\n            values[i] = 0;\n        }\n    }\n\n    ~Matrix(){\n        delete []values;\n    }\n\n    void print(){\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < columns; ++j) {\n                cout<<\"    \"<<values[i * columns + j];\n            }\n            cout<<endl;\n        }\n    }\n};",
            1588828646.0418117,
            100,
            "# 答案正确"
        ],
        [
            "2.2 (C++)",
            "向鼎",
            "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nclass Matrix{\nprivate:\n    int rows;\n    int columns;\n    double *values;\npublic:\n    Matrix(int rows,int columns,double values[]){\n        this->values = new double[rows * columns];\n        this->rows = rows;\n        this->columns = columns;\n        for (int i = 0; i < rows * columns; ++i) {\n            this->values[i] = values[i];\n        }\n    }\n\n    ~Matrix(){\n        delete []values;\n    }\n\n    void print(){\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < columns; ++j) {\n                cout<<setw(5)<<values[i * columns + j];\n            }\n            cout<<endl;\n        }\n    }\n};\n",
            1588828915.404901,
            100,
            "# 答案正确"
        ],
        [
            "2.3 (C++)",
            "向鼎",
            "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nclass Matrix{\nprivate:\n    int rows;\n    int columns;\n    double *values;\npublic:\n    Matrix(int rows,int columns,double values[]){\n        this->values = new double[rows * columns];\n        this->rows = rows;\n        this->columns = columns;\n        for (int i = 0; i < rows * columns; ++i) {\n            this->values[i] = values[i];\n        }\n    }\n\n    Matrix(const Matrix &matrix2){\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        this->values = new double[rows * columns];\n        for (int i = 0; i < rows*columns; ++i) {\n            this->values[i] = matrix2.values[i];\n        }\n    }\n\n    ~Matrix(){\n        delete []values;\n    }\n\n    void print(){\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < columns; ++j) {\n                cout<<\"    \"<<values[i * columns + j];\n            }\n            cout<<endl;\n        }\n    }\n};",
            1588829091.1758118,
            100,
            "# 答案正确"
        ],
        [
            "2.5 (C++)",
            "向鼎",
            "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nclass Matrix{\nprivate:\n    int rows;\n    int columns;\n    double *values;\npublic:\n\n    Matrix(int rows,int columns){\n        this->values = new double[rows * columns];\n        this->rows = rows;\n        this->columns = columns;\n        for (int i = 0; i < rows * columns; ++i) {\n            values[i] = 0;\n        }\n    }\n\n    Matrix(int rows,int columns,double values[]){\n        this->values = new double[rows * columns];\n        this->rows = rows;\n        this->columns = columns;\n        for (int i = 0; i < rows * columns; ++i) {\n            this->values[i] = values[i];\n        }\n    }\n\n    Matrix(const Matrix &matrix2){\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        this->values = new double[rows * columns];\n        for (int i = 0; i < rows*columns; ++i) {\n            this->values[i] = matrix2.values[i];\n        }\n    }\n\n    ~Matrix(){\n        delete []values;\n    }\n\n    void print(){\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < columns; ++j) {\n                cout<<\"    \"<<values[i * columns + j];\n            }\n            cout<<endl;\n        }\n    }\n\n    Matrix getRow(int row){\n        Matrix a(1,this->columns,this->values + (row-1) * this->columns);\n        return a;\n    }\n\n    Matrix getColumn(int column){\n        Matrix a(this->rows,1);\n        for (int i = 0; i < this->rows; ++i) {\n            a.values[i] = this->values[column - 1 + i * columns];\n        }\n        return a;\n    }\n};",
            1588829985.2923164,
            100,
            "# 答案正确"
        ],
        [
            "2.6 (C++)",
            "向鼎",
            "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nclass Matrix{\nprivate:\n    int rows;\n    int columns;\n    double *values;\npublic:\n    Matrix(int rows,int columns){\n        this->values = new double[rows * columns];\n        this->rows = rows;\n        this->columns = columns;\n        for (int i = 0; i < rows * columns; ++i) {\n            values[i] = 0;\n        }\n    }\n    Matrix(int rows,int columns,double values[]){\n        this->values = new double[rows * columns];\n        this->rows = rows;\n        this->columns = columns;\n        for (int i = 0; i < rows * columns; ++i) {\n            this->values[i] = values[i];\n        }\n    }\n\n    Matrix(const Matrix &matrix2){\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        this->values = new double[rows * columns];\n        for (int i = 0; i < rows*columns; ++i) {\n            this->values[i] = matrix2.values[i];\n        }\n    }\n\n    ~Matrix(){\n        delete []values;\n    }\n\n    void print(){\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < columns; ++j) {\n                cout<<\"    \"<<values[i * columns + j];\n            }\n            cout<<endl;\n        }\n    }\n\n    Matrix concatenateColumns(const Matrix &matrix2){\n        int len = this->columns + matrix2.columns;\n        Matrix a(this->rows,len);\n        for (int i = 0; i < this->rows; ++i) {\n            for (int j = 0; j < this->columns; ++j) {\n                a.values[i * len + j] = this->values[i * this->columns + j];\n            }\n            for (int k = 0; k < matrix2.columns; ++k) {\n                a.values[i * len + this->columns + k] = matrix2.values[i * this->columns + k];\n            }\n        }\n        return a;\n    }\n    Matrix concatenateRows(const Matrix &matrix2){\n        Matrix a(this->rows + matrix2.rows,this->columns,this->values);\n        for (int i = this->rows * this->columns; i < this->rows * this->columns + matrix2.rows * matrix2.columns; ++i) {\n            a.values[i] = matrix2.values[i-this->rows * this->columns];\n        }\n        return a;\n    }\n};",
            1588831171.6796315,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/08",
            "向鼎",
            "    double & Tensor_get(int dimensions, const int sizes[],double data[], int x0, int x1, int x2, int x3){\n        if(dimensions == 2){\n            return data[x0 * sizes[1] + x1];\n        }\n        if(dimensions == 3){\n            return data[x0 * sizes[1] * sizes[2] + x1 * sizes[2] + x2];\n        }\n        if(dimensions == 4){\n            return data[x0 * sizes[1] * sizes[2] * sizes[3] + x1 * sizes[2] * sizes[3] + x2 * sizes[3] + x3];\n        }\n    }\n\n",
            1588906498.6457748,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/14",
            "向鼎",
            "#include <iostream>\nusing namespace std;\n\nvoid Tensor_print(int dimensions, const int sizes[], const double data[]){\n    cout<<\"Tensor of \"<<sizes[0];\n    for(int i = 1;i < dimensions;i++){cout<<\"x\"<<sizes[i];}\n    cout<<endl;\n\n    int a = 0,b = 1,c = 2,d = 3;\n    for (int j = 0; j < sizes[a]; ++j) {\n        if(dimensions <= 3) {j = sizes[a] - 1;b--;c--;d--;}\n\n        for (int i = 0; i < sizes[b]; ++i) {\n            if(dimensions <= 2) {i = sizes[b] - 1;c--;d--;}\n            else if(dimensions == 3) cout<<\"data[\"<<i<<']'<<endl;\n            else if(dimensions == 4) cout<<\"data[\"<<j<<']'<<'['<<i<<']'<<endl;\n\n            for (int k = 0; k < sizes[c]; ++k) {\n                if(dimensions == 1) {k = sizes[c] - 1;d--;}\n                for (int l = 0; l < sizes[d]; ++l) {\n                    if(dimensions > 1)cout<<\"    \"<<data[0];\n                    else cout<<data[0]<<endl;\n                }\n                if(dimensions != 1)cout<<endl;\n            }\n        }\n    }\n}",
            1589423865.4058537,
            100,
            "# 答案正确"
        ],
        [
            "2.4 (C++)",
            "向鼎",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix{\nprivate:\n    int rows;\n    int columns;\n    double * values;\n\npublic:\n    Matrix(int rows, int columns){\n        this->rows = rows;this->columns = columns;\n        int len = rows * columns;\n        values = new double[len];\n        for (int i = 0; i < len; ++i) {\n            values[i] = 0;\n        }\n    }\n\n    Matrix(int rows, int columns,const double values[]){\n        this->rows = rows;this->columns = columns;\n        int len = rows * columns;\n        this->values = new double[len];\n        for (int i = 0; i < len; ++i) {\n            this->values[i] = values[i];\n        }\n    }\n\n    ~Matrix(){\n        delete []values;\n    }\n\n    void print(){\n        int len = rows * columns;\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < columns; ++j) {\n                cout<<\"    \"<<values[i * columns + j];\n            }\n            cout<<endl;\n        }\n    }\n\n    void set(int row,int column,double value){\n        values[(row-1) * columns + (column - 1)] = value;\n    }\n\n    Matrix &operator = (Matrix & str){\n        this->rows = str.rows;\n        this->columns = str.columns;\n        int len = str.rows * str.columns;\n        if(values != NULL){\n            delete []values;\n            values = NULL;\n        }\n        values  = new double[len];\n        for (int i = 0; i < len; ++i) {\n            values[i] = str.values[i];\n        }\n\n        return *this;\n    }\n};",
            1589514734.3390367,
            100,
            "# 答案正确"
        ],
        [
            "2.7 (C++)",
            "向鼎",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix{\nprivate:\n    int rows;\n    int columns;\n    double * values;\n\npublic:\n    Matrix(int rows, int columns){\n        this->rows = rows;this->columns = columns;\n        int len = rows * columns;\n        values = new double[len];\n        for (int i = 0; i < len; ++i) {\n            values[i] = 0;\n        }\n    }\n\n    Matrix(int rows, int columns,const double values[]){\n        this->rows = rows;this->columns = columns;\n        int len = rows * columns;\n        this->values = new double[len];\n        for (int i = 0; i < len; ++i) {\n            this->values[i] = values[i];\n        }\n    }\n\n    Matrix(const Matrix &matrix2){\n        this->rows = matrix2.rows;this->columns = matrix2.columns;\n        int len = rows * columns;\n        this->values = new double[len];\n        for (int i = 0; i < len; ++i) {\n            values[i] = matrix2.values[i];\n        }\n    }\n\n    ~Matrix(){\n        delete []values;\n    }\n\n    void print(){\n        int len = rows * columns;\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < columns; ++j) {\n                cout<<\"    \"<<values[i * columns + j];\n            }\n            cout<<endl;\n        }\n    }\n\n    void set(int row,int column,double value){\n        values[(row-1) * columns + (column - 1)] = value;\n    }\n\n    Matrix &operator = (Matrix & str){\n        this->rows = str.rows;\n        this->columns = str.columns;\n        int len = str.rows * str.columns;\n\n        if(values != NULL){\n            //cout<<\"values is NULL\"<<endl;\n            delete []values;\n            values = NULL;\n        }\n        values  = new double[len];\n        for (int i = 0; i < len; ++i) {\n            values[i] = str.values[i];\n        }\n\n        return *this;\n    }\n\n    Matrix reshape(int row,int column) const{\n        Matrix devil(column,row);\n        int k = 0;\n        for (int i = 0; i < columns; ++i) {\n            for (int j = 0; j < rows; ++j) {\n                devil.values[k++] = values[j * columns + i];\n            }\n        }\n\n        Matrix anger(row,column);\n        int t = 0;\n        for (int l = 0; l < row; ++l) {\n            for (int i = 0; i < column; ++i) {\n                anger.values[t++] = devil.values[i * row + l];\n            }\n        }\n        return anger;\n    }\n};",
            1589517739.0657554,
            100,
            "# 答案正确"
        ],
        [
            "2.8 (C++)",
            "向鼎",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix{\nprivate:\n    int rows;\n    int columns;\n    double * values;\n\npublic:\n    Matrix(int rows, int columns){\n        this->rows = rows;this->columns = columns;\n        int len = rows * columns;\n        values = new double[len];\n        for (int i = 0; i < len; ++i) {\n            values[i] = 0;\n        }\n    }\n\n    Matrix(int rows, int columns,const double values[]){\n        this->rows = rows;this->columns = columns;\n        int len = rows * columns;\n        this->values = new double[len];\n        for (int i = 0; i < len; ++i) {\n            this->values[i] = values[i];\n        }\n    }\n\n    Matrix(const Matrix &matrix2){\n        this->rows = matrix2.rows;this->columns = matrix2.columns;\n        int len = rows * columns;\n        this->values = new double[len];\n        for (int i = 0; i < len; ++i) {\n            values[i] = matrix2.values[i];\n        }\n    }\n\n    ~Matrix(){\n        delete []values;\n    }\n\n    void print(){\n        int len = rows * columns;\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < columns; ++j) {\n                cout<<\"    \"<<values[i * columns + j];\n            }\n            cout<<endl;\n        }\n    }\n\n    void set(int row,int column,double value){\n        values[(row-1) * columns + (column - 1)] = value;\n    }\n\n    Matrix &operator = (Matrix & str){\n        this->rows = str.rows;\n        this->columns = str.columns;\n        int len = str.rows * str.columns;\n\n        if(values != NULL){\n            //cout<<\"values is NULL\"<<endl;\n            delete []values;\n            values = NULL;\n        }\n        values  = new double[len];\n        for (int i = 0; i < len; ++i) {\n            values[i] = str.values[i];\n        }\n\n        return *this;\n    }\n\n    Matrix reshape(int row,int column) const{\n        Matrix devil(column,row);\n        int k = 0;\n        for (int i = 0; i < columns; ++i) {\n            for (int j = 0; j < rows; ++j) {\n                devil.values[k++] = values[j * columns + i];\n            }\n        }\n\n        Matrix anger(row,column);\n        int t = 0;\n        for (int l = 0; l < row; ++l) {\n            for (int i = 0; i < column; ++i) {\n                anger.values[t++] = devil.values[i * row + l];\n            }\n        }\n        return anger;\n    }\n\t\n\tMatrix transpose(){\n\t\tMatrix devil(columns,rows);\n\t\tint k = 0;\n\t\tfor(int i = 0; i < columns; i++){\n\t\t\tfor (int j = 0; j < rows; j++){\n\t\t\t\tdevil.values[k++] = values[j * columns + i];\n\t\t\t} \n\t\t}\n\t\treturn devil;\n\t}\n};",
            1589518047.1726458,
            100,
            "# 答案正确"
        ],
        [
            "2.10 (C++)",
            "向鼎",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix{\nprivate:\n    int rows;\n    int columns;\n    double * values;\n\npublic:\n    Matrix(int rows, int columns){\n        this->rows = rows;this->columns = columns;\n        int len = rows * columns;\n        values = new double[len];\n        for (int i = 0; i < len; ++i) {\n            values[i] = 0;\n        }\n    }\n\n    Matrix(int rows, int columns,const double values[]){\n        this->rows = rows;this->columns = columns;\n        int len = rows * columns;\n        this->values = new double[len];\n        for (int i = 0; i < len; ++i) {\n            this->values[i] = values[i];\n        }\n    }\n\n    Matrix(const Matrix &matrix2){\n        this->rows = matrix2.rows;this->columns = matrix2.columns;\n        int len = rows * columns;\n        this->values = new double[len];\n        for (int i = 0; i < len; ++i) {\n            values[i] = matrix2.values[i];\n        }\n    }\n\n    ~Matrix(){\n        delete []values;\n    }\n\n    void print(){\n        int len = rows * columns;\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < columns; ++j) {\n                cout<<\"    \"<<values[i * columns + j];\n            }\n            cout<<endl;\n        }\n    }\n\n    void set(int row,int column,double value){\n        values[(row-1) * columns + (column - 1)] = value;\n    }\n\n    Matrix &operator = (Matrix & str){\n        this->rows = str.rows;\n        this->columns = str.columns;\n        int len = str.rows * str.columns;\n\n        if(values != NULL){\n            //cout<<\"values is NULL\"<<endl;\n            delete []values;\n            values = NULL;\n        }\n        values  = new double[len];\n        for (int i = 0; i < len; ++i) {\n            values[i] = str.values[i];\n        }\n\n        return *this;\n    }\n\n    Matrix reshape(int row,int column) const{\n        Matrix devil(column,row);\n        int k = 0;\n        for (int i = 0; i < columns; ++i) {\n            for (int j = 0; j < rows; ++j) {\n                devil.values[k++] = values[j * columns + i];\n            }\n        }\n\n        Matrix anger(row,column);\n        int t = 0;\n        for (int l = 0; l < row; ++l) {\n            for (int i = 0; i < column; ++i) {\n                anger.values[t++] = devil.values[i * row + l];\n            }\n        }\n        return anger;\n    }\n\n    Matrix transpose(){\n        Matrix devil(columns,rows);\n        int k = 0;\n        for(int i = 0; i < columns; i++){\n            for (int j = 0; j < rows; j++){\n                devil.values[k++] = values[j * columns + i];\n            }\n        }\n        return devil;\n    }\n\n    Matrix operator *(const Matrix & matrix2) const{\n        Matrix res(rows,matrix2.columns);\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < matrix2.columns; ++j) {\n\n                double result = 0;\n                for (int k = 0; k < columns; ++k) {\n                    result+= values[i * columns + k] * matrix2.values[k * matrix2.columns + j];\n                }\n                res.values[i * matrix2.columns + j] = result;\n            }\n        }\n        return res;\n    }\n\n    Matrix operator *(double value)const{\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < columns; ++j) {\n                values[i * columns + j] *= value;\n            }\n        }\n        return *this;\n    }\n};\n",
            1589539973.4726768,
            100,
            "# 答案正确"
        ],
        [
            "2.11 (C++)",
            "向鼎",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix{\nprivate:\n    int rows;\n    int columns;\n    double * values;\n\npublic:\n    Matrix(int rows, int columns){\n        this->rows = rows;this->columns = columns;\n        int len = rows * columns;\n        values = new double[len];\n        for (int i = 0; i < len; ++i) {\n            values[i] = 0;\n        }\n    }\n\n    Matrix(int rows, int columns,const double values[]){\n        this->rows = rows;this->columns = columns;\n        int len = rows * columns;\n        this->values = new double[len];\n        for (int i = 0; i < len; ++i) {\n            this->values[i] = values[i];\n        }\n    }\n\n    Matrix(const Matrix &matrix2){\n        this->rows = matrix2.rows;this->columns = matrix2.columns;\n        int len = rows * columns;\n        this->values = new double[len];\n        for (int i = 0; i < len; ++i) {\n            values[i] = matrix2.values[i];\n        }\n    }\n\n    ~Matrix(){\n        delete []values;\n    }\n\n    void print(){\n        int len = rows * columns;\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < columns; ++j) {\n                cout<<\"    \"<<values[i * columns + j];\n            }\n            cout<<endl;\n        }\n    }\n\n    void set(int row,int column,double value){\n        values[(row-1) * columns + (column - 1)] = value;\n    }\n\n    Matrix &operator = (Matrix & str){\n        this->rows = str.rows;\n        this->columns = str.columns;\n        int len = str.rows * str.columns;\n\n        if(values != NULL){\n            //cout<<\"values is NULL\"<<endl;\n            delete []values;\n            values = NULL;\n        }\n        values  = new double[len];\n        for (int i = 0; i < len; ++i) {\n            values[i] = str.values[i];\n        }\n\n        return *this;\n    }\n\n    Matrix reshape(int row,int column) const{\n        Matrix devil(column,row);\n        int k = 0;\n        for (int i = 0; i < columns; ++i) {\n            for (int j = 0; j < rows; ++j) {\n                devil.values[k++] = values[j * columns + i];\n            }\n        }\n\n        Matrix anger(row,column);\n        int t = 0;\n        for (int l = 0; l < row; ++l) {\n            for (int i = 0; i < column; ++i) {\n                anger.values[t++] = devil.values[i * row + l];\n            }\n        }\n        return anger;\n    }\n\n    Matrix transpose(){\n        Matrix devil(columns,rows);\n        int k = 0;\n        for(int i = 0; i < columns; i++){\n            for (int j = 0; j < rows; j++){\n                devil.values[k++] = values[j * columns + i];\n            }\n        }\n        return devil;\n    }\n\n    Matrix operator *(const Matrix & matrix2) const{\n        Matrix res(rows,matrix2.columns);\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < matrix2.columns; ++j) {\n\n                double result = 0;\n                for (int k = 0; k < columns; ++k) {\n                    result+= values[i * columns + k] * matrix2.values[k * matrix2.columns + j];\n                }\n                res.values[i * matrix2.columns + j] = result;\n            }\n        }\n        return res;\n    }\n\n    Matrix operator *(double value)const{\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < columns; ++j) {\n                values[i * columns + j] *= value;\n            }\n        }\n        return *this;\n    }\n\n    Matrix max()const{\n        if(rows > 1){\n            double max[columns];\n            for (int i = 0; i < columns; ++i) {\n                max[i] = 0;\n                for (int j = 0; j < rows; ++j) {\n                    if(values[j * columns + i] > max[i])max[i] = values[j * columns +i];\n                }\n            }\n            Matrix a(1,columns,max);\n            return a;\n        }else{\n            double max = values[0];\n            for (int i = 0; i < rows * columns; ++i) {\n                if(values[i] > max)max = values[i];\n            }\n            Matrix a(1,1,&max);\n            return a;\n        }\n    }\n\n    Matrix min()const{\n        if(rows > 1){\n            double min[columns];\n            for (int i = 0; i < columns; ++i) {\n                min[i] = 99999;\n                for (int j = 0; j < rows; ++j) {\n                    if(values[j * columns + i] < min[i])min[i] = values[j * columns +i];\n                }\n            }\n            Matrix a(1,columns,min);\n            return a;\n        }else{\n            double min = values[0];\n            for (int i = 0; i < rows * columns; ++i) {\n                if(values[i] < min)min = values[i];\n            }\n            Matrix a(1,1,&min);\n            return a;\n        }\n    }\n\n    Matrix sum()const{\n        double *sum;\n        sum = new double[columns];\n        for (int i = 0; i < columns; ++i){\n            sum[i] = 0;\n            for (int j = 0; j < rows; ++j) {\n                sum[i] += values[j * columns + i];\n            }\n        }\n        if(rows > 1){Matrix a(1,columns,sum); delete []sum;return a;}\n        else {\n            double temp = 0;\n            for (int i = 0; i < columns ;++i) temp += values[i];\n            Matrix a(1,1,&temp);\n            delete []sum;\n            return a;\n        }\n    }\n};\n\n\n",
            1589542036.8609557,
            100,
            "# 答案正确"
        ],
        [
            "2.12 (C++)",
            "向鼎",
            "#include <iostream>\n#include <cmath>\nusing namespace std;\nusing :: exp;\nusing :: log;\nusing :: abs;\n\nclass Matrix{\nprivate:\n    int rows;\n    int columns;\n    double * values;\n\npublic:\n    Matrix(int rows, int columns){\n        this->rows = rows;this->columns = columns;\n        int len = rows * columns;\n        values = new double[len];\n        for (int i = 0; i < len; ++i) {\n            values[i] = 0;\n        }\n    }\n\n    Matrix(int rows, int columns,const double values[]){\n        this->rows = rows;this->columns = columns;\n        int len = rows * columns;\n        this->values = new double[len];\n        for (int i = 0; i < len; ++i) {\n            this->values[i] = values[i];\n        }\n    }\n\n    Matrix(const Matrix &matrix2){\n        this->rows = matrix2.rows;this->columns = matrix2.columns;\n        int len = rows * columns;\n        this->values = new double[len];\n        for (int i = 0; i < len; ++i) {\n            values[i] = matrix2.values[i];\n        }\n    }\n\n    ~Matrix(){\n        delete []values;\n    }\n\n    void print(){\n        int len = rows * columns;\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < columns; ++j) {\n                cout<<\"    \"<<values[i * columns + j];\n            }\n            cout<<endl;\n        }\n    }\n\n    void set(int row,int column,double value){\n        values[(row-1) * columns + (column - 1)] = value;\n    }\n\n    Matrix &operator = (Matrix & str){\n        this->rows = str.rows;\n        this->columns = str.columns;\n        int len = str.rows * str.columns;\n\n        if(values != NULL){\n            //cout<<\"values is NULL\"<<endl;\n            delete []values;\n            values = NULL;\n        }\n        values  = new double[len];\n        for (int i = 0; i < len; ++i) {\n            values[i] = str.values[i];\n        }\n\n        return *this;\n    }\n\n    Matrix reshape(int row,int column) const{\n        Matrix devil(column,row);\n        int k = 0;\n        for (int i = 0; i < columns; ++i) {\n            for (int j = 0; j < rows; ++j) {\n                devil.values[k++] = values[j * columns + i];\n            }\n        }\n\n        Matrix anger(row,column);\n        int t = 0;\n        for (int l = 0; l < row; ++l) {\n            for (int i = 0; i < column; ++i) {\n                anger.values[t++] = devil.values[i * row + l];\n            }\n        }\n        return anger;\n    }\n\n    Matrix transpose(){\n        Matrix devil(columns,rows);\n        int k = 0;\n        for(int i = 0; i < columns; i++){\n            for (int j = 0; j < rows; j++){\n                devil.values[k++] = values[j * columns + i];\n            }\n        }\n        return devil;\n    }\n\n    Matrix operator *(const Matrix & matrix2) const{\n        Matrix res(rows,matrix2.columns);\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < matrix2.columns; ++j) {\n\n                double result = 0;\n                for (int k = 0; k < columns; ++k) {\n                    result+= values[i * columns + k] * matrix2.values[k * matrix2.columns + j];\n                }\n                res.values[i * matrix2.columns + j] = result;\n            }\n        }\n        return res;\n    }\n\n    Matrix operator *(double value)const{\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < columns; ++j) {\n                values[i * columns + j] *= value;\n            }\n        }\n        return *this;\n    }\n\n    Matrix max()const{\n        if(rows > 1){\n            double max[columns];\n            for (int i = 0; i < columns; ++i) {\n                max[i] = 0;\n                for (int j = 0; j < rows; ++j) {\n                    if(values[j * columns + i] > max[i])max[i] = values[j * columns +i];\n                }\n            }\n            Matrix a(1,columns,max);\n            return a;\n        }else{\n            double max = values[0];\n            for (int i = 0; i < rows * columns; ++i) {\n                if(values[i] > max)max = values[i];\n            }\n            Matrix a(1,1,&max);\n            return a;\n        }\n    }\n\n    Matrix min()const{\n        if(rows > 1){\n            double min[columns];\n            for (int i = 0; i < columns; ++i) {\n                min[i] = 99999;\n                for (int j = 0; j < rows; ++j) {\n                    if(values[j * columns + i] < min[i])min[i] = values[j * columns +i];\n                }\n            }\n            Matrix a(1,columns,min);\n            return a;\n        }else{\n            double min = values[0];\n            for (int i = 0; i < rows * columns; ++i) {\n                if(values[i] < min)min = values[i];\n            }\n            Matrix a(1,1,&min);\n            return a;\n        }\n    }\n\n    Matrix sum()const{\n        double *sum;\n        sum = new double[columns];\n        for (int i = 0; i < columns; ++i){\n            sum[i] = 0;\n            for (int j = 0; j < rows; ++j) {\n                sum[i] += values[j * columns + i];\n            }\n        }\n        if(rows > 1){Matrix a(1,columns,sum); delete []sum;return a;}\n        else {\n            double temp = 0;\n            for (int i = 0; i < columns ;++i) temp += values[i];\n            Matrix a(1,1,&temp);\n            delete []sum;\n            return a;\n        }\n    }\n\n    Matrix pow(double exponent){\n        Matrix res(rows,columns);\n        for (int i = 0; i < rows * columns; ++i) {\n            res.values[i]  = values[i] * values[i];\n        }\n        return res;\n    }\n\n    Matrix exp(void){\n        Matrix res(rows,columns);\n        for (int i = 0; i < rows * columns; ++i) {\n            res.values[i]  = ::exp(values[i]);\n        }\n        return res;\n    }\n\n    Matrix log(void){\n        Matrix res(rows,columns);\n        for (int i = 0; i < rows * columns; ++i) {\n            res.values[i]  = ::log(values[i]);\n        }\n        return res;\n    }\n\n    Matrix abs(void){\n        Matrix res(rows,columns);\n        for (int i = 0; i < rows * columns; ++i) {\n            res.values[i]  = ::abs(values[i]);\n        }\n        return res;\n    }\n};\n",
            1589542893.7135522,
            100,
            "# 答案正确"
        ],
        [
            "2.9 (C++)",
            "向鼎",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix{\nprivate:\n    int rows;\n    int columns;\n    double * values;\n\npublic:\n    Matrix(int rows, int columns){\n        this->rows = rows;this->columns = columns;\n        int len = rows * columns;\n        values = new double[len];\n        for (int i = 0; i < len; ++i) {\n            values[i] = 0;\n        }\n    }\n\n    Matrix(int rows, int columns,const double values[]){\n        this->rows = rows;this->columns = columns;\n        int len = rows * columns;\n        this->values = new double[len];\n        for (int i = 0; i < len; ++i) {\n            this->values[i] = values[i];\n        }\n    }\n\n    Matrix(const Matrix &matrix2){\n        this->rows = matrix2.rows;this->columns = matrix2.columns;\n        int len = rows * columns;\n        this->values = new double[len];\n        for (int i = 0; i < len; ++i) {\n            values[i] = matrix2.values[i];\n        }\n    }\n\n    ~Matrix(){\n        delete []values;\n    }\n\n    void print(){\n        int len = rows * columns;\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < columns; ++j) {\n                cout<<\"    \"<<values[i * columns + j];\n            }\n            cout<<endl;\n        }\n    }\n\n    Matrix operator +(const Matrix &matrix2)const {\n        Matrix temp(rows,columns);\n        for (int i = 0; i < rows * columns; ++i) {\n            temp.values[i] = this->values[i] + matrix2.values[i];\n        }\n        return temp;\n    }\n\n    Matrix operator +(double value)const {\n        Matrix temp(rows,columns);\n        for (int i = 0; i < rows * columns; ++i) {\n            temp.values[i] = this->values[i] + value;\n        }\n        return temp;\n    }\n\n    Matrix operator -(const Matrix &matrix2)const {\n        Matrix temp(rows,columns);\n        for (int i = 0; i < rows * columns; ++i) {\n            temp.values[i] = this->values[i] - matrix2.values[i];\n        }\n        return temp;\n    }\n\n    Matrix operator -(double value)const {\n        Matrix temp(rows,columns);\n        for (int i = 0; i < rows * columns; ++i) {\n            temp.values[i] = this->values[i] - value;\n        }\n        return temp;\n    }\n};",
            1590028120.7599785,
            100,
            "# 答案正确"
        ],
        [
            "6.1 (C++)",
            "向鼎",
            "#include <iostream>\n#include <string>\n#include <cstring>\nusing namespace std;\n\ntemplate <typename T>\nclass Matrix{\nprivate:\n\tT *values;\n    int rows;\n    int columns;\n\n//    int capacity;\n//\n    void copy0(T to[],const T from[],int num)const {\n        for (int i = 0; i < num; ++i) {\n            to[i] = from[i];\n        }\n    }\n\n    void assign0(const Matrix &matrix2){\n        if(values != 0){\n            delete []values;\n        }\n        int len = matrix2.rows * matrix2.columns;\n        values = new T[len];\n        copy0(values,matrix2.values,len);\n    }\n\npublic:\n    Matrix(){\n        values = new T[1];\n        rows = 0;\n        columns = 0;\n        //capacity = 0;\n    }\n\n    Matrix(int rows,int columns){\n        int len = rows * columns;\n        this->rows = rows;\n        this->columns = columns;\n        //this->capacity = len;\n        values = new T[len];\n        memset(values,'\\0',len * sizeof(T));\n\t\t//for (int i = 0; i < len; ++ i) values[i] = '\\0';\n    }\n\n    Matrix(int rows,int columns,const T value[]){\n        this->rows = rows;\n        this->columns = columns;\n        values = new T[rows * columns];\n        for (int i = 0; i < rows* columns; ++i) {\n            this->values[i] = value[i];\n        }\n    }\n\n    Matrix(const Matrix &matrix2){\n        this->rows = matrix2.rows;this->columns = matrix2.columns;\n        int len = rows * columns;\n        values = 0;\n        assign0(matrix2);\n    }\n\n    ~Matrix()\n    {\n        delete []values;\n    }\n\n    T & get(int row,int col){\n        return values[(row-1) * columns + col-1];\n    }\n\n    void print(){\n        int len = rows * columns;\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < columns; ++j) {\n                cout<<\"    \"<<values[i * columns + j];\n            }\n            cout<<endl;\n        }\n    }\n\n    Matrix &operator =(const Matrix& matrix2){\n        assign0(matrix2);\n        return *this;\n    }\n};\n",
            1590124602.5703993,
            100,
            "# 答案正确"
        ],
        [
            "6.3 (C++)",
            "向鼎",
            "#include <iostream>\n#include <string>\n#include <cstring>\n#include <vector>\n#define inf 9999\nusing namespace std;\n\ntemplate <typename T>\nclass Matrix{\nprivate:\n    int rows;\n    int columns;\n    vector<T> values;\n\n//    void copy0(T to[],const T from[],int num)const {\n//        for (int i = 0; i < num; ++i) {\n//            to[i] = from[i];\n//        }\n//    }\n\n    void assign0(const Matrix &matrix2){\n        int len = matrix2.rows * matrix2.columns;\n        for (int i = 0; i < len; ++i) {\n            this->values[i] = matrix2.values[i];\n        }\n    }\n\npublic:\n    Matrix(){\n        rows = 0;\n        columns = 0;\n    }\n\n    Matrix(int rows,int columns){\n        if(rows == 0 || columns == 0) exit(0);\n        int len = rows * columns;\n        this->rows = rows;\n        this->columns = columns;\n        for (int i = 0; i < len; ++i) {\n            values.push_back(0);\n        }\n    }\n\n    Matrix(int rows,int columns,const T value[]){\n        if(rows == 0 || columns == 0) exit(0);\n        this->rows = rows;\n        this->columns = columns;\n        for (int i = 0; i < rows* columns; ++i) {\n            values.push_back(value[i]);\n        }\n    }\n\n    Matrix(int rows,int columns,const vector<T> &value){\n        if(rows == 0 || columns == 0) exit(0);\n        this->rows = rows;\n        this->columns = columns;\n        for (int i = 0; i < rows* columns; ++i) {\n            values.push_back(value[i]);\n        }\n    }\n\n//    Matrix(const Matrix &matrix2){\n//        this->rows = matrix2.rows;this->columns = matrix2.columns;\n//        int len = rows * columns;\n//        assign0(matrix2);\n//    }\n\n    T & get(int row,int col){\n        return values[(row-1) * columns + (col-1)];\n    }\n\n    void print(){\n        int len = rows * columns;\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < columns; ++j) {\n                cout<<\"    \"<<values[i * columns + j];\n            }\n            cout<<endl;\n        }\n    }\n\n    Matrix & operator =(const Matrix & matrix2) {\n        if(this != &matrix2){\n            assign0(matrix2);\n        }\n        return *this;\n    }\n\n\n    Matrix operator +(const Matrix &matrix2)const {\n        Matrix temp(rows,columns);\n        for (int i = 0; i < rows * columns; ++i) {\n            temp.values[i] = this->values[i] + matrix2.values[i];\n        }\n        return temp;\n    }\n\n    Matrix operator +(T value)const {\n        Matrix temp(rows,columns);\n        for (int i = 0; i < rows * columns; ++i) {\n            temp.values[i] = this->values[i] + value;\n        }\n        return temp;\n    }\n\n    Matrix operator -(const Matrix &matrix2)const {\n        Matrix temp(rows,columns);\n        for (int i = 0; i < rows * columns; ++i) {\n            temp.values[i] = this->values[i] - matrix2.values[i];\n        }\n        return temp;\n    }\n\n    Matrix operator -(T value)const {\n        Matrix temp(rows,columns);\n        for (int i = 0; i < rows * columns; ++i) {\n            temp.values[i] = this->values[i] - value;\n        }\n        return temp;\n    }\n\n    Matrix operator *(T value)const {\n        Matrix temp(rows,columns);\n        for (int i = 0; i < rows * columns; ++i) {\n            temp.values[i] = this->values[i] * value;\n        }\n        return temp;\n    }\n\n    Matrix operator *(const Matrix &matrix2)const {\n        Matrix temp(rows,columns);\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < columns; ++j) {\n                for (int k = 0; k < columns; ++k) {\n                    temp.values[i * columns + j] += this->values[i * columns + k] * matrix2.values[k * matrix2.columns + j];\n                }\n            }\n        }\n        return temp;\n    }\n\n    Matrix getColumn(int column){\n        Matrix a(rows,1);\n        for (int i = 0; i < rows; ++i) {\n            a.values[i] = this->values[i * columns + column-1];\n        }\n        return a;\n    }\n\n    Matrix getRow(int row){\n        Matrix a(1,columns);\n        for (int i = 0; i < columns; ++i) {\n            a.values[i] = this->values[(row-1) * columns + i];\n        }\n        return a;\n    }\n\n    Matrix concatenateRows(Matrix &matrix2){\n        int len = rows * columns + matrix2.rows * matrix2.columns;\n        Matrix a(rows + matrix2.rows,columns);\n        for (int i = 0; i < rows * columns; ++i) {\n            a.values[i] = this->values[i];\n        }\n        for (int j = rows * columns; j < len; ++j) {\n            a.values[j] = matrix2.values[j - rows * columns];\n        }\n        return a;\n    }\n\n    Matrix concatenateColumns(Matrix & matrix2){\n        int sumcol = columns + matrix2.columns;\n         Matrix a(rows,sumcol);\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < columns; ++j) {\n                a.values[i * sumcol + j] = values[i * columns +j];\n            }\n            for (int k = columns; k < sumcol; ++k) {\n                a.values[i * sumcol + k] = matrix2.values[i * matrix2.columns + k-columns];\n            }\n        }\n        return a;\n    }\n\n    Matrix reshape(int rs,int cs){\n        Matrix a(rs,cs);\n        Matrix b(cs,rs);\n        int k = 0;\n        for (int i = 0; i < columns; ++i) {\n            for (int j = 0; j < rows; ++j) {\n                b.values[k++] = values[j * columns + i];\n            }\n        }\n//        puts(\"***************\");\n//        this->print();\n//        puts(\"**********\");\n//        b.print();\n//        puts(\"***************\");\n        k = 0;\n        for (int i = 0; i < cs; ++i) {\n            for (int j = 0; j < rs; ++j) {\n                a.values[j * cs + i] = b.values[k++];\n            }\n        }\n        return a;\n    }\n\n    Matrix transpose(){\n        Matrix a(columns,rows);\n        int k = 0;\n        for (int i = 0; i < columns; ++i) {\n            for (int j = 0; j < rows; ++j) {\n                a.values[k++] = values[j * columns + i];\n            }\n        }\n        return a;\n    }\n\n    Matrix max(){\n        if(rows == 1){\n            Matrix a(1,1);\n            T Max = values[0];\n            for (int i = 0; i < columns; ++i)\n                if(values[i] > Max) Max = values[i];\n            a.values[0] = Max;\n            return a;\n        }\n        T Max[columns];\n        for (int i = 0; i < columns; ++i) {\n            Max[i] = 0;\n            for (int j = 0; j < rows; ++j) {\n                if(values[i * rows + j] > Max[i]) Max[i] = values[i * rows + j];\n            }\n        }\n        Matrix a(1,columns,Max);\n        return a;\n    }\n\n    Matrix min(){\n        if(rows == 1){\n            Matrix a(1,1);\n            T Min = values[0];\n            for (int i = 0; i < columns; ++i)\n                if(values[i] < Min) Min = values[i];\n            a.values[0] = Min;\n            return a;\n        }\n        T Min[columns];\n        for (int i = 0; i < columns; ++i) {\n            Min[i] = inf;\n            for (int j = 0; j < rows; ++j) {\n                if(values[i * rows + j] < Min[i]) Min[i] = values[i * rows + j];\n            }\n        }\n        Matrix a(1,columns,Min);\n        return a;\n    }\n\n    Matrix sum(){\n        if(rows == 1){\n            Matrix a(1,1);\n            T Sum = 0;\n            for (int i = 0; i < columns; ++i)\n                Sum += values[i];\n            a.values[0] = Sum;\n            return a;\n        }\n        T Sum[columns];\n        for (int i = 0; i < columns; ++i) {\n            Sum[i] = 0;\n            for (int j = 0; j < rows; ++j) {\n                Sum[i] += values[i * rows + j];\n            }\n        }\n        Matrix a(1,columns,Sum);\n        return a;\n    }\n};",
            1590630749.2303061,
            100,
            "# 答案正确"
        ],
        [
            "6.2 (C++)",
            "向鼎",
            "#include <iostream>\n#include <string>\n#include <cstring>\nusing namespace std;\n\ntemplate <typename T>\nclass Matrix{\nprivate:\n\tT *values;\n    int rows;\n    int columns;\n\n\n    void copy0(T to[],const T from[],int num)const {\n        for (int i = 0; i < num; ++i) {\n            to[i] = from[i];\n        }\n    }\n\n    void assign0(const Matrix &matrix2){\n        if(values != 0){\n            delete []values;\n        }\n        int len = matrix2.rows * matrix2.columns;\n        values = new T[len];\n        copy0(values,matrix2.values,len);\n    }\n\npublic:\n    Matrix(){\n        values = new T[1];\n        rows = 0;\n        columns = 0;\n    }\n\n    Matrix(int rows,int columns){\n        int len = rows * columns;\n        this->rows = rows;\n        this->columns = columns;\n        //this->capacity = len;\n        values = new T[len];\n        memset(values,'\\0',len * sizeof(T));\n\t\t//for (int i = 0; i < len; ++ i) values[i] = '\\0';\n    }\n\n    Matrix(int rows,int columns,const T value[]){\n        this->rows = rows;\n        this->columns = columns;\n        values = new T[rows * columns];\n        for (int i = 0; i < rows* columns; ++i) {\n            this->values[i] = value[i];\n        }\n    }\n\n    Matrix(const Matrix &matrix2){\n        this->rows = matrix2.rows;this->columns = matrix2.columns;\n        int len = rows * columns;\n        values = 0;\n        assign0(matrix2);\n    }\n\n    ~Matrix()\n    {\n        delete []values;\n    }\n\n\n    void print(){\n        int len = rows * columns;\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < columns; ++j) {\n                cout<<\"    \"<<values[i * columns + j];\n            }\n            cout<<endl;\n        }\n    }\n\n};\n",
            1590631692.4292455,
            100,
            "# 答案正确"
        ],
        [
            "7.1 (C++)",
            "向鼎",
            "#include <cmath>\n\nclass Triangle :public GeometricObject\n{\nprivate:\n    double side1,side2,side3;\n\npublic:\n    Triangle(){\n        side1 = 1.0;side2 = 1.0;side3 = 1.0;\n    }\n\n    Triangle(double a,double b,double c){\n        side1 = a;side2 = b;side3 = c;\n    }\n\n    double getSide1(){\n        return side1;\n    }\n    double getSide2(){\n        return side2;\n    }\n    double getSide3(){\n        return side3;\n    }\n\n    double getArea(){\n        double s = (side1 + side2 + side3)/2;\n        double area = sqrt(s * (s - side1) * (s - side2) * (s - side3));\n        return area;\n    }\n\n    double getPerimeter(){\n        return side1 + side2 + side3;\n    }\n};",
            1590721484.678435,
            100,
            "# 答案正确"
        ],
        [
            "7.3 (C++)",
            "向鼎",
            "template <typename A, typename R>\nvector<R> map2(const vector<A> & x,const vector<A> &y, R (*map_func)(const A &,const A &)) {\n    vector<R> res;\n    for (int i = 0; i < x.size(); ++ i)\n        res.push_back(map_func(x[i],y[i]));\n    return res;\n}\n\ntemplate <typename A, typename R>\nvector<R> map2(const vector<A> & x,const int y, R (*map_func)(const A &,const A &)) {\n    vector<R> res;\n    for (int i = 0; i < x.size(); ++ i)\n        res.push_back(map_func(x[i],y));\n    return res;\n}\n",
            1590728033.5434947,
            100,
            "# 答案正确"
        ],
        [
            "7.2 (C++)",
            "向鼎",
            "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nvector<string> split(const string &line){\n    vector<string> words;\n    int site = 0;\n    while(site < line.size()) {\n        int end = line.find(' ',site);\n        if(end == site) site++;\n        else{\n            if(end == -1){\n                words.push_back(line.substr(site));\n                break;\n            }\n            words.push_back(line.substr(site,end-site));\n            site = end + 1;\n        }\n    }\n    return words;\n}\n",
            1591239463.038349,
            100,
            "# 答案正确"
        ],
        [
            "8.1 (C++)",
            "向鼎",
            "class Full : public Matrix{\nprivate:\n    int cols;\n    int rows;\n    double *values;\n\npublic:\n    virtual int size(int dimension) const {\n        return dimension == 1?rows:cols;\n    }\n\n    virtual void set(int row, int column, double value){\n        values[row * cols + column] = value;\n    }\n\n    virtual double get(int row, int column) const {\n        return values[row * cols + column];\n    }\n\n    virtual void print() const{\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < cols; ++j) {\n                cout<<\"    \"<<values[i * cols + j];\n            }\n            cout<<endl;\n        }\n    }\n\n    virtual Matrix & operator = (const Matrix & matrix2) {\n        if(this != &matrix2){\n            if(values != NULL){\n                delete []values;\n                values = NULL;\n            }\n            rows = matrix2.size(1);\n            cols = matrix2.size(2);\n            values = new double[rows * cols];\n            for (int i = 0; i < rows; ++i) {\n                for (int j = 0; j < cols; ++j) {\n                    values[i * cols + j] = matrix2.get(i,j);\n                }\n            }\n        }\n\n        return *this;\n    }\n\n\n    Full(int row,int col){\n        cols = col;rows = row;\n        values = new double[col * row];\n        for (int i = 0; i < col * row; ++i) {\n            values[i] = 0;\n        }\n    }\n\n    Full(int row,int col,double value[]){\n        cols = col;rows = row;\n        values = new double[col * row];\n        for (int i = 0; i < col * row; ++i) {\n            values[i] = value[i];\n        }\n    }\n\n    Full(const Matrix &matrix2){\n        rows = matrix2.size(1);\n        cols = matrix2.size(2);\n        values = new double[cols * rows];\n        for (int i = 0; i < rows;++i) {\n            for (int j = 0; j < cols; ++j) {\n                values[i * cols + j] = matrix2.get(i,j);\n            }\n        }\n    }\n\n    ~Full(){\n        delete []values;\n    }\n\n};",
            1591347610.5212624,
            100,
            "# 答案正确"
        ],
        [
            "8.3 (C++)",
            "向鼎",
            "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nclass Sparse : public Matrix{\nprivate:\n    int rows;\n    int cols;\n    vector<Entry> V;\n\npublic:\n    virtual int size(int dimension) const {\n        return dimension==1?rows:cols;\n    }\n\n    virtual void set(int row, int column,double value){\n        Entry temp = {row,column,value};\n        V.push_back(temp);\n    }\n\n    virtual double get(int row, int column)const {\n        for (int i = 0; i < V.size(); ++i) {\n            if(V[i].row == row && V[i].column == column)return V[i].value;\n        }\n        return 0;\n    }\n\n    static bool mycmp(Entry a,Entry b){\n        if(a.row < b.row)return 1;\n        else if(a.row == b.row){\n            if(a.column < b.column) return 1;\n            else if(a.column == b.column){\n                if(a.value < b.value) return 1;\n                else return 0;\n            }else return 0;\n        }else return 0;\n    }\n\n    virtual void print(){\n        sort(V.begin(),V.end(),mycmp);\n        for (int i = 0; i < V.size(); ++i) {\n            cout<<'('<<V[i].row<<','<<V[i].column<<','<<V[i].value<<')'<<endl;\n        }\n    }\n\n    Sparse(int row, int column){\n        rows = row;\n        cols = column;\n    }\n\n//    Sparse(const Sparse & sparse2){\n//        rows = sparse2.rows;\n//        cols = sparse2.cols;\n//        V = sparse2.V;\n//    }\n\n    Sparse operator +(Sparse & sparse2) const{\n        if(this->V.size() != sparse2.V.size())\n            exit(0);\n        Sparse res(*this);\n        int n = V.size();\n        for (int j = 0; j < n; ++j) {\n            int flag = 0;\n            for (int i = 0; i < n; ++i) {\n                if(res.V[i].row == sparse2.V[j].row && res.V[i].column == sparse2.V[j].column){\n                    flag = 1;\n                    res.V[i].value += sparse2.V[j].value;\n                }\n                if(res.V[i].value == 0) {\n                    for(vector<Entry>::iterator it=res.V.begin();it < res.V.end();){\n                        Entry temp = *it;\n                        if(temp.value == 0){\n                            it = res.V.erase(it);\n                        }\n                        else ++it;\n                    }\n                }\n            }\n            if(flag == 0){\n                res.V.push_back(sparse2.V[j]);\n            }\n        }\n        return res;\n    }\n};\n",
            1591357863.3444335,
            100,
            "# 答案正确"
        ],
        [
            "8.4 (C++)",
            "向鼎",
            "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\n\nclass Sparse : public Matrix{\nprivate:\n    int rows;\n    int cols;\n    vector<Entry> V;\n\npublic:\n    virtual int size(int dimension) const {\n        return dimension==1?rows:cols;\n    }\n\n    virtual void set(int row, int column,double value){\n        Entry temp = {row,column,value};\n        V.push_back(temp);\n    }\n\n    virtual double get(int row, int column)const {\n        for (int i = 0; i < V.size(); ++i) {\n            if(V[i].row == row && V[i].column == column)return V[i].value;\n        }\n        return 0;\n    }\n\n    static bool mycmp(Entry a,Entry b){\n        if(a.row < b.row)return 1;\n        else if(a.row == b.row){\n            if(a.column < b.column) return 1;\n            else if(a.column == b.column){\n                if(a.value < b.value) return 1;\n                else return 0;\n            }else return 0;\n        }else return 0;\n    }\n\n    virtual void print(){\n        sort(V.begin(),V.end(),mycmp);\n        for (int i = 0; i < V.size(); ++i) {\n            cout<<'('<<V[i].row<<','<<V[i].column<<','<<V[i].value<<')'<<endl;\n        }\n    }\n\n    Sparse(int row, int column){\n        rows = row;\n        cols = column;\n    }\n\n//    Sparse(const Sparse & sparse2){\n//        rows = sparse2.rows;\n//        cols = sparse2.cols;\n//        V = sparse2.V;\n//    }\n\n    Sparse operator +(Sparse & sparse2) const{\n        if(this->V.size() != sparse2.V.size())\n            exit(0);\n        Sparse res(*this);\n        int n = V.size();\n        for (int j = 0; j < n; ++j) {\n            int flag = 0;\n            for (int i = 0; i < n; ++i) {\n                if(res.V[i].row == sparse2.V[j].row && res.V[i].column == sparse2.V[j].column){\n                    flag = 1;\n                    res.V[i].value += sparse2.V[j].value;\n                }\n                if(res.V[i].value == 0) {//迭代器的使用，重点！！！！！！！\n                    for(vector<Entry>::iterator it=res.V.begin();it < res.V.end();){\n                        Entry temp = *it;\n                        if(temp.value == 0){\n                            it = res.V.erase(it);\n                        }\n                        else ++it;\n                    }\n                }\n            }\n            if(flag == 0){\n                res.V.push_back(sparse2.V[j]);\n            }\n        }\n        return res;\n    }\n\n    Sparse operator *(Sparse &sparse2){\n        Sparse res(rows,sparse2.cols);\n        for (int i = 0; i < V.size(); ++i) {\n\n            for (int j = 0; j < sparse2.V.size(); ++j) {\n\n                if(V[i].column == sparse2.V[j].row){\n\n                    Entry temp = {V[i].row, sparse2.V[j].column, V[i].value * sparse2.V[j].value};\n                    bool exist = 0;\n                    for (int k = 0; k < res.V.size(); ++k) {\n                        if(res.V[k].row == temp.row && res.V[k].column == temp.column){\n                            res.V[k].value += temp.value;\n                            exist = 1;\n                            break;\n                        }\n                    }\n                    if(exist == 0)\n                        res.V.push_back(temp);\n\n                }\n            }\n        }\n        return res;\n    }\n};",
            1591405169.5176315,
            100,
            "# 答案正确"
        ],
        [
            "8.5 (C++)",
            "向鼎",
            "\n#include <iostream>\nusing namespace std;\n\nclass Point3D : public Point2D\n{\nprivate:\n    double z;\npublic:\n    Point3D(){\n        setX(0);setY(0);\n        z = 0;\n    }\n\n    Point3D(double a,double b,double c){\n        setX(a),setY(b);\n        z = c;\n    }\n\n    double getZ(){\n        return z;\n    }\n\n    virtual double distance(Point2D & point2) override {\n        double dx = this->getX() - point2.getX();\n        double dy = this->getY() - point2.getY();\n        Point3D * p = dynamic_cast<Point3D *>(&point2);\n        double dz = z - p->getZ();\n        return sqrt(dx * dx + dy * dy + dz * dz);\n    }\n};\n",
            1591843079.2953804,
            100,
            "# 答案正确"
        ],
        [
            "8.6 (C++)",
            "向鼎",
            "#include <iostream>\nusing namespace std;\nclass MyTensor : public Tensor<double>{\nprivate:\n     double *data;\n     int sizes[4];\n     int dimensions;\npublic:\n    MyTensor (vector<int> I):Tensor(I){\n        dimensions = I.size();\n        int len = 1;\n        for (int i = 0; i < dimensions; ++i) {\n            sizes[i] = I[i];\n            len *= sizes[i];\n        }\n        data = new double[len];\n        for (int j = 0; j < len; ++j) {\n            data[j] = 0;\n        }\n    }\n\t\n\t~MyTensor(){\n\t\tdelete []data;\n\t}\n\n    double & get(const vector<int> & indexes) {\n        if(indexes.size() == 3){\n            return data[indexes[0] * sizes[2] * sizes[1] + indexes[1] * sizes[2] + indexes[2]];\n        }\n        if(indexes.size() == 4){\n            return data[indexes[0] *sizes[3] * sizes[2] * sizes[1] + indexes[1] * sizes[3] * sizes[2] + indexes[2] * sizes[3] + indexes[3]];\n        }\n    }\n};\n",
            1592449255.7224846,
            100,
            "# 答案正确"
        ],
        [
            "9.1 (C++)",
            "向鼎",
            "class Circle{\n    double radius;\npublic:\n    Circle(double radius){\n        this->radius = radius;\n    }\n\n    bool operator < (Circle &circle2){\n        return radius < circle2.radius? 1:0;\n    }\n    bool operator <= (Circle &circle2){\n        return radius <= circle2.radius? 1:0;\n    }\n    bool operator == (Circle &circle2){\n        return radius == circle2.radius? 1:0;\n    }\n    bool operator != (Circle &circle2){\n        return radius != circle2.radius? 1:0;\n    }\n    bool operator > (Circle &circle2){\n        return radius > circle2.radius? 1:0;\n    }\n    bool operator >= (Circle &circle2){\n        return radius >= circle2.radius? 1:0;\n    }\n};",
            1592535348.8089297,
            100,
            "# 答案正确"
        ],
        [
            "9.2 (C++)",
            "向鼎",
            "class I\n{\n    vector<int> data;\npublic:\n    I(int i1,int i2 = -1,int i3 = -1,int i4 = -1){\n        data.push_back(i1);\n        if(i2 != -1)data.push_back(i2);\n        if(i3 != -1)data.push_back(i3);\n        if(i4 != -1)data.push_back(i4);\n    }\n    I(const vector<int> &data):data(data){}\n\n    operator vector<int>()const{return data;}\n\n};",
            1592536285.4580815,
            100,
            "# 答案正确"
        ],
        [
            "9.3 (C++)",
            "向鼎",
            "class Complex{\npublic:\n    double r;\n    double i;\n\n    Complex(double real,double imag) { r = real;i = imag; }\n\n    double & real() { return r; }\n\n    double & imag() { return i; }\n\n    Complex operator * (Complex & complex2) {\n        double new_r = r * complex2.r - i * complex2.i;\n        double new_i = r * complex2.i + i * complex2.r;\n        Complex res(new_r,new_i);\n        return res;\n    }\n\n    Complex operator / (Complex & complex2) {\n        double tmp = complex2.r * complex2.r + complex2.i * complex2.i;\n        double new_r = (r * complex2.r + i * complex2.i) / tmp;\n        double new_i = (i * complex2.r - r * complex2.i) / tmp;\n        Complex res(new_r,new_i);\n        return res;\n    }\n\n    Complex & operator *= (Complex & complex2){\n        *this = *this * complex2;\n        return *this;\n    }\n    Complex & operator /= (Complex & complex2){\n        *this = *this / complex2;\n        return *this;\n    }\n\n    bool operator == (Complex &complex2){\n        return (r == complex2.r) && (i == complex2.i) ? 1 : 0;\n    }\n\n    bool operator != (Complex &complex2){\n        return (r == complex2.r) && (i == complex2.i) ? 0 : 1;\n    }\n\n};\n\nComplex operator +(Complex & complex1,Complex & complex2){\n    Complex res(complex1.r + complex2.r,complex1.i + complex2.i);\n    return res;\n}\nComplex operator -(Complex & complex1,Complex & complex2){\n    Complex res(complex1.r - complex2.r,complex1.i - complex2.i);\n    return res;\n}\nComplex operator +(double a,Complex & complex2){\n    Complex res(a + complex2.r,complex2.i);\n    return res;\n}\nComplex operator -(Complex & complex1,double a){\n    Complex res(complex1.r - a,complex1.i);\n    return res;\n}\nComplex & operator += (Complex & complex1,Complex & complex2){\n    complex1 = complex1 + complex2;\n    return complex1;\n}\nComplex & operator -= (Complex & complex1,Complex & complex2){\n    complex1 = complex1 - complex2;\n    return complex1;\n}\n\n",
            1592541479.636279,
            100,
            "# 答案正确"
        ],
        [
            "9.4 (C++)",
            "向鼎",
            "class Complex{\n    double r;\n    double i;\npublic:\n    Complex() { r = 0;i = 0; }\n\n    Complex(double a,double b):r(a),i(b){}\n\n    double &real(){return r;}\n    double &imag(){return i;}\n\n    const double &real() const{return r;}\n    const double &imag() const{return i;}\n\n    Complex operator +(Complex & x){\n        Complex res(r + x.r, i + x.i);\n        return res;\n    }\n\n    Complex operator -(Complex & x){\n        Complex res(r - x.r, i - x.i);\n        return res;\n    }\n\n};\n    ostream &operator << (ostream & out,const Complex &x){\n        out<<x.real()<<\" + \"<<x.imag()<<\" i\";\n        return out;\n    }\n\n    istream & operator >> (istream & in,Complex & x){\n        in >> x.real() >> x.imag();\n        return in;\n    }\n",
            1592542351.9221034,
            100,
            "# 答案正确"
        ],
        [
            "9.5 (C++)",
            "向鼎",
            "class Complex{\n    double r;\n    double i;\npublic:\n    Complex() { r = 0;i = 0; }\n\n    Complex(double a,double b):r(a),i(b){}\n\n    double &real(){return r;}\n    double &imag(){return i;}\n\n    const double &real() const{return r;}\n    const double &imag() const{return i;}\n\n    Complex operator +(Complex & x){\n        Complex res(r + x.r, i + x.i);\n        return res;\n    }\n\n    Complex operator -(Complex & x){\n        Complex res(r - x.r, i - x.i);\n        return res;\n    }\n\n    Complex operator ++(){\n        r++;\n        return *this;\n    }\n\n    Complex operator ++(int){\n        Complex tmp(r,i);\n        r++;\n        return tmp;\n    }\n\n    operator double() const{return r;}\n\n    double & operator = (Complex & x){\n        return x.real();\n    }\n};\n\n    ostream &operator << (ostream & out,const Complex &x){\n        out<<x.real()<<\" + \"<<x.imag()<<\" i\";\n        return out;\n    }\n\n    istream & operator >> (istream & in,Complex & x){\n        in >> x.real() >> x.imag();\n        return in;\n    }\n",
            1592542872.0862405,
            100,
            "# 答案正确"
        ],
        [
            "9.6 (C++)",
            "向鼎",
            "class Tensor{\n    vector<int> sizes;\n    vector<double> values;\npublic:\n    int numel() const{\n        if(this->sizes.size() == 0) return 0;\n        int size = 1;\n        for (int i = 0; i < this->sizes.size(); ++i) size *= sizes[i];\n        return size;\n\n    }\n\n    Tensor(int i1,int i2 = -1,int i3 = -1,int i4 = -1) {\n        sizes.push_back(i1);\n        if (i2 != -1)sizes.push_back(i2);\n        if (i3 != -1)sizes.push_back(i3);\n        if (i4 != -1)sizes.push_back(i4);\n        this->values.resize(this->numel());\n        for (int i = 0; i < this->numel(); ++ i) this->values[i] = 0;\n    }\n\n    int _index(int i1,int i2=-1,int i3=-1,int i4=-1){\n        int index = 0;\n        if(i4 != -1){\n            index = i1 * sizes[3] * sizes[2] * sizes[1] + i2 * sizes[3] * sizes[2] + i3 + sizes[3] + i4;\n        }else{\n            index = i1  * sizes[2] * sizes[1] + i2 * sizes[2] + i3;\n        }\n        return index;\n    }\n\n    double & operator ()(int i1,int i2=-1,int i3=-1,int i4=-1){\n        return values[_index(i1,i2,i3,i4)];\n    }\n\n};\n",
            1592829452.3723106,
            100,
            "# 答案正确"
        ],
        [
            "9.7 (C++)",
            "向鼎",
            "class Tensor{\npublic:\n    vector<int> sizes;\n    vector<double> values;\n};\n\nistream & operator >> (istream & in, Tensor & x){\n    int dimension;\n    in >> dimension;\n    x.sizes.resize(dimension);\n    int size[dimension];\n    int sumsize = 1;\n    for (int i = 0; i < dimension; ++i) {\n        in >> size[i];\n        x.sizes[i] = size[i];//!1\n        sumsize *= size[i];\n    }\n    x.values.resize(sumsize);\n    for (int j = 0; j < sumsize; ++j) {\n        double tmp;\n        in >> tmp;\n        x.values[j] = tmp;\n    }\n    return in;\n}\n\nostream & operator << (ostream & out, Tensor &x){\n    out << x.sizes.size()<< endl;\n    for (int i = 0; i < x.sizes.size(); ++i) {\n        out<<x.sizes[i]<<' ';\n    }out<<endl<<endl;\n\n    for (int j = 0; j < x.values.size(); ++j) {\n        out << x.values[j]<<' ';\n        if((j+1) % x.sizes.back() == 0)out<<endl;\n        if((j+1) % (x.sizes.back() * x.sizes[x.sizes.size() - 2]) == 0) out<<endl;\n    }\n    return out;\n}",
            1592830812.8335638,
            100,
            "# 答案正确"
        ],
        [
            "10.1 (C++)",
            "向鼎",
            "\n#include <stdexcept>\ndouble Matrix::get(int row,int column) const{\n    if(row > this->rows || column > this->columns){\n        //out_of_range a(\"out_of_range\");\n        throw out_of_range(\" \");\n    }\n    return this->elements[(row-1) * (column-1)];\n}\n\nvoid Matrix::set(int row,int column, double value){\n    if(row > this->rows || column > this->columns){\n        out_of_range a(\" \");\n        throw a;\n    }\n    this->elements[(row-1) * (column-1)] = value;\n}\n\nclass MatrixSizesDoNotMatchException{};\nMatrix Matrix:: operator + (const Matrix & matrix2) const{\n    if(matrix2.rows != this->rows || matrix2.columns != this->columns){\n        MatrixSizesDoNotMatchException a;\n        throw a;\n    }\n    Matrix res(*this);\n    for (int i = 0; i < matrix2.elements.size(); ++i) {\n        res.elements[i] += matrix2.elements[i];\n    }\n    return res;\n}",
            1593312678.6143286,
            100,
            "# 答案正确"
        ],
        [
            "10.2 (C++)",
            "向鼎",
            "catch (NonPositiveValueException & ex){\n            cout<<\"caught: NonPositiveValueException\"<<endl;\n        }catch (out_of_range & ex) {\n            cout << \"caught: out_of_range\" << endl;\n        }",
            1593655758.5677018,
            100,
            "# 答案正确"
        ],
        [
            "15.1 (C++)",
            "向鼎",
            "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nclass Table{\n    vector<string> col;\n    vector<vector<string>> row;\n\npublic:\n    Table(){}\n\n    void addCol(const string & ss){\n        col.push_back(ss);\n    }\n\n    vector<string> & operator[](int index) {\n        if(index >= row.size()){\n            row.resize(index+1);\n        }\n        return row[index];\n    }\n\n    string json() const{\n        cout<<'{'<<endl;\n        cout<<\"\\theaders: [\";\n        for (int i = 0; i < col.size(); ++i) {\n            cout<<\"'\"<<col[i]<<\"',\";\n        }cout<<\"],\"<<endl;\n        cout<<\"\\trows: [\"<<endl;\n        for (int j = 0; j < row.size(); ++j) {\n            cout<<\"\\t\\t[\";\n            for (int i = 0; i < row[j].size(); ++i) {\n                cout<<\"'\"<<row[j][i]<<\"',\";\n            }\n            cout<<\"],\"<<endl;\n        }\n        cout<<\"\\t],\"<<endl;\n        cout<<'}';\n        return string(\"\\n\");\n    }\n\n};",
            1593751062.6770747,
            100,
            "# 答案正确"
        ],
        [
            "2020-07-09 LAB",
            "向鼎",
            "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Integer{\npublic:\n    static int add;\n    int num;\n    Integer(){\n        num = 0;\n    }\n    Integer(int value){\n        num = value;\n    }\n\n    void static increase_all(int tmp){\n        add += tmp;\n    }\n    void static increase_all(Integer &y){\n        add = y.num;\n    }\n};\nint Integer:: add = 0;\n\nostream &operator <<(ostream & out, Integer & x){\n    x.num += x.add;\n    out<<x.num;\n    return out;\n}\n\nistream &operator >>(istream & in, Integer & x){\n    in>>x.num;\n    return in;\n}\n",
            1594262417.592793,
            100,
            "# 答案正确"
        ],
        [
            "A.1 (C++)",
            "向鼎",
            "private:\n    Node<E> * get_node(int index) const {\n        if (index < 0 || index >= _size)\n            throw NotSuchElementException();\n        if (index < _size / 2) {\n            Node<E> * node = head;\n            Node<E> * prev_node = NULL;\n            Node<E> * next_node = node->next_node(prev_node);\n            I(i, index){\n                prev_node = node;\n                node = next_node;\n                next_node = node->next_node(prev_node);\n            }\n            return node;\n        }\n        else {\n            Node<E> * node = tail;\n            Node<E> * next_node = NULL;\n            Node<E> * prev_node = node->prev_node(next_node);\n            I(i, (_size-1-index)) {\n                next_node = node;\n                node = prev_node;\n                prev_node = node->prev_node(next_node);\n            }\n            return node;\n        }\n    }\n\n    Node<E> * getprev_node(int index) const{\n        if (index < 0 || index >= _size)\n            throw NotSuchElementException();\n        if (index < _size / 2) {\n            Node<E> * node = head;\n            Node<E> * prev_node = NULL;\n            Node<E> * next_node = node->next_node(prev_node);\n            I(i, index){\n                prev_node = node;\n                node = next_node;\n                next_node = node->next_node(prev_node);\n            }\n            return prev_node;\n        }\n        else {\n            Node<E> * node = tail;\n            Node<E> * next_node = NULL;\n            Node<E> * prev_node = node->prev_node(next_node);\n            I(i, (_size-1-index)) {\n                next_node = node;\n                node = prev_node;\n                prev_node = node->prev_node(next_node);\n            }\n            return prev_node;\n        }\n    }\n\n    Node<E> * getnext_node(int index) const{\n        if (index < 0 || index >= _size)\n            throw NotSuchElementException();\n        if (index < _size / 2) {\n            Node<E> * node = head;\n            Node<E> * prev_node = NULL;\n            Node<E> * next_node = node->next_node(prev_node);\n            I(i, index){\n                prev_node = node;\n                node = next_node;\n                next_node = node->next_node(prev_node);\n            }\n            return next_node;\n        }\n        else {\n            Node<E> * node = tail;\n            Node<E> * next_node = NULL;\n            Node<E> * prev_node = node->prev_node(next_node);\n            I(i, (_size-1-index)) {\n                next_node = node;\n                node = prev_node;\n                prev_node = node->prev_node(next_node);\n            }\n            return next_node;\n        }\n    }\n\npublic:\n    E & get(int index) const {\n        Node<E> * node = get_node(index);\n        return node->element;\n    }\n    void set(int index, const E & e) {\n        Node<E> * node = get_node(index);\n        node->element = e;\n    }\n\n    E & getFirst() const {\n        return get(0);\n    }\n\n    E & getLast() const {\n        return get(_size - 1);\n    }\n\n    void remove (int index) {\n        Node<E> * node = get_node(index);//cout<<\"\\tremove: node  \"<<node<<endl;\n        Node<E> * prev_node = getprev_node(index);//cout<<\"\\tprev_node:  \"<<prev_node<<endl;\n        Node<E> * next_node = getnext_node(index);\n        if (prev_node != 0) prev_node->update_next_node(node,next_node);\n        if (next_node != 0) next_node->update_prev_node(node,prev_node);\n        if (prev_node == 0) {head = next_node;}\n        if (next_node == 0) {tail = prev_node;}\n        delete node;\n        -- _size;\n    }\n\n    void removeFirst () {\n        remove(0);\n    }\n\n    void removeLast () {\n        remove(_size-1);\n    }\n\n    void add(int index, const E & e) {\n        if (index < 0 || index > _size)\n            throw NotSuchElementException();\n        Node<E> * node = new Node<E>();\n        node->element = e;\n        Node<E> * next_node = (index == _size ? 0 : get_node(index));\n        Node<E> * prev_node = (next_node == 0 ? tail : getprev_node(index));\n        node->update_prev_and_next_node(prev_node,next_node);\n        if (prev_node != 0) prev_node->update_next_node(next_node,node);\n        if (next_node != 0) next_node->update_prev_node(prev_node,node);\n        if (prev_node == 0) head = node;\n        if (next_node == 0) tail = node;\n        ++ _size;\n    }\n\n    void addFirst (const E & e) {\n        add(0, e);\n    }\n\n    void addLast (const E & e) {\n        add(_size, e);\n    }\n\n    // copy and clear\n\n    void clear() {\n        while (_size > 0) removeFirst();\n    }\n\n    void addAll(const LinkedList & list, int index = -1) {\n        if (index == -1) index = _size;\n        I(i, list._size) {\n            Node<E> * node = list.get_node(i);\n            add(index + i, node->element);\n        }\n    }\n\n    LinkedList(const LinkedList & list) : _size(0), head(0), tail(0) {\n        addAll(list);\n    }\n\n    LinkedList & operator = (const LinkedList & list) {\n        clear();\n        addAll(list);\n        return *this;\n    }\n\n    ~LinkedList() {\n        clear();\n    }\n\n    int indexOf(const E & e) const {\n        Node<E> * node = head;\n        Node<E> * prev_node = NULL;\n        Node<E> * next_node = node->next_node(prev_node);\n        I(i, _size) {\n            //cout<<\"index:\"<<i<<endl;\n            if (node->element == e){\n                //cout<<\"index:\"<<i<<'\\t'<<e<<node<<endl;\n                return i;\n            }\n            prev_node = node;\n            node = next_node;\n            next_node = node->next_node(prev_node);\n        }\n        return -1;\n    }\n\n    int lastIndexOf(const E & e) const {\n        Node<E> * node = tail;\n        I(i, _size) {\n            if (node->element == e) return i;\n            node = node->prev_node;\n        }\n        return -1;\n    }\n\n    bool contains(const E & e) const {\n        return indexOf(e) >= 0;\n    }\n\n    void removeFirstOccurrence(const E & e) {\n        int index = indexOf(e);\n        if (index == -1)\n            throw NotSuchElementException();\n        remove(index);\n    }\n\n    void removeLastOccurrence(const E & e) {\n        int index = lastIndexOf(e);\n        if (index == -1)\n            throw NotSuchElementException();\n        remove(index);\n    }",
            1594900343.671514,
            100,
            "# 答案正确"
        ],
        [
            "A.2 (C++)",
            "向鼎",
            "template <typename E>\nvoid LinkedList<E>::removeAll(const E & e){\n\tint size = _size;\n\tfor (int i = 0; i < size; ++ i) {\n\t\tNode<E> * node = head;\n\t\tfor (int i = 0; i < _size; ++ i) {\n\t\t\tif (node->element == e) {remove(i);break;}\n\t\t\tnode = node->next_node;\n\t\t}\n\t}\n}",
            1594866660.448899,
            100,
            "# 答案正确"
        ],
        [
            "A.4 (C++)",
            "向鼎",
            "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <stdexcept>\n#include <cstdlib>\nusing namespace std;\n\n#define I(i,n) for (size_t i = 0; i < n; ++ i)\n\nclass NoSuchKeyException {};\n\nsize_t circular_shift(size_t bits, int shift_bits) {\n    const int num_bits = 8 * sizeof(size_t);\n    shift_bits = shift_bits % num_bits;\n    return bits << shift_bits | bits >> (num_bits - shift_bits);\n}\n\nsize_t hash_function(const string & key) {\n    size_t code = 0;\n    I(i, key.size())\n        code ^= circular_shift(key[i], i * 5);\n    return code;\n}\n\nstring intToString(int num){\n    int flag = 1;\n    int i = 0,j = 0;\n    string tmp;char res[100] = \"\";\n    char buf[100] = \"\";\n    if(num < 0)\n        res[i++] = '-';\n    num = abs(num);\n    while(num){\n        buf[j++] = num%10 +'0';\n        num /= 10;\n    }\n    j--;\n    while(j>=0)\n        res[i++] = buf[j--];\n\n    tmp = res;\n    return tmp;\n}\n\n\nclass String{\npublic:\n    string str;\n    String(){}\n    String(int a){\n        str = intToString(a);\n    }\n    String(string a){\n        str = a;\n    }\n\n    operator string(){\n        return str;\n    }\n    operator int() {\n        return atoi(str.c_str());\n    }\n};\n\nclass HT\n{\n    class Tuple\n    {\n    public:\n        String key;\n        String val;\n        bool in_use;\n\n        Tuple() : in_use(false) {}\n        //operator int(){return atoi(val.c_str());}\n    };\n\n    vector<Tuple> tuples;\n    size_t _size;\n\n    size_t canonical_index(const string & key) const {\n        size_t hash_code = hash_function(key); // needs hash_function(K)\n        return hash_code % tuples.size();\n    }\n\n    // the returned tuple is either empty or with the same key\n    size_t indexOfKey(const string & key) const {\n        size_t index = canonical_index(key);\n        while (true) { // will enter a dead loop if there is not empty tuple\n            if (! tuples[index].in_use) return index;\n            if (tuples[index].key.str == key) return index;\n            index = (index + 1) % tuples.size();\n        }\n    }\n\npublic:\n    HT() : _size(0) {\n        tuples.resize(2);\n    }\n\n    bool containsKey(const string & key) const{\n        size_t index = indexOfKey(key);\n        return tuples[index].in_use;\n    }\n\n    const string & operator[] (const string & key) const {\n        size_t index = indexOfKey(key);\n        if(! tuples[index].in_use)\n            throw NoSuchKeyException();\n        return tuples[index].val.str;\n    }\n\n    String & operator[] (const string & key) {\n        size_t index = indexOfKey(key);\n        if(! tuples[index].in_use)\n            throw NoSuchKeyException();\n        return tuples[index].val;\n    }\n    String & operator[] (const int & key1) {\n        string key  = to_string(key1);\n        size_t index = indexOfKey(key);\n        if(! tuples[index].in_use)\n            throw NoSuchKeyException();\n        return tuples[index].val;\n    }\n\n    void put(const String &key, const String & val){\n        size_t index = indexOfKey(key.str);\n        tuples[index].key = key;\n        tuples[index].val = val;\n        if(tuples[index].in_use) return;\n        tuples[index].in_use = true;\n        ++_size;\n        if(2 * _size > tuples.size())\n            _double_tuples();\n    }\n\n    void _double_tuples(){\n        vector<Tuple> non_empty_tuples;\n        I(i, tuples.size())\n            if(tuples[i].in_use)\n                non_empty_tuples.push_back(tuples[i]);\n        clear();\n        tuples.resize(tuples.size() * 2);\n        I(i, non_empty_tuples.size())\n            put(non_empty_tuples[i].key, non_empty_tuples[i].val);\n    }\n\n    static bool _between(size_t hole, size_t canonical, size_t tuple_index) {\n        if (hole < tuple_index)\n            return canonical > hole && canonical <= tuple_index;\n        else\n            return canonical > hole || canonical <= tuple_index;\n    }\n\n    void remove(const string & key) {\n        size_t index = indexOfKey(key);\n        if (! tuples[index].in_use)\n            throw NoSuchKeyException();\n        tuples[index].in_use = false;\n        -- _size;\n        // if there is a hole between a tuple and its canonical position\n        // move the tuple to the hole\n        size_t hole = index;\n        size_t tuple_index = hole;\n        while (true) {\n            tuple_index = (tuple_index + 1) % tuples.size();\n            if (! tuples[tuple_index].in_use) return;\n            size_t canonical = canonical_index(tuples[tuple_index].key);\n            if (_between(hole, canonical, tuple_index)) continue;\n            tuples[hole] = tuples[tuple_index];\n            hole = tuple_index;\n            tuples[hole].in_use = false;\n        }\n    }\n\n    size_t  size() const {return _size;}\n\n    void clear(){\n        I(i, tuples.size())\n            tuples[i].in_use = false;\n        _size = 0;\n    }\n\n//    friend ostream & operator << (ostream & out, const HT & dict);\n//    friend istream & operator >> (istream & in, HT & dict);\n\n};\n\n",
            1595412809.867867,
            100,
            "# 答案正确"
        ],
        [
            "A.3 (C++)",
            "向鼎",
            "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <stdexcept>\n#include <sstream>\n\nusing namespace std;\n\n#define I(i,n) for (size_t i = 0; i < n; ++ i)\n\nclass NoSuchKeyException {};\n\nstring intToString(int num){\n    int flag = 1;\n    int i = 0,j = 0;\n    string tmp;char res[100] = \"\";\n    char buf[100] = \"\";\n    if(num < 0)\n        res[i++] = '-';\n    num = abs(num);\n    while(num){\n        buf[j++] = num%10 +'0';\n        num /= 10;\n    }\n    j--;\n    while(j>=0)\n        res[i++] = buf[j--];\n\n    tmp = res;\n    return tmp;\n}\n\nsize_t circular_shift(size_t bits, int shift_bits) {\n    const int num_bits = 8 * sizeof(size_t);\n    shift_bits = shift_bits % num_bits;\n    return bits << shift_bits | bits >> (num_bits - shift_bits);\n}\n\nsize_t hash_function(const int & key) {\n    size_t code = 0;\n    string tmp = intToString(key);\n    I(i, tmp.size())\n        code ^= circular_shift(tmp[i], i * 5);\n    return code;\n}\n\ntemplate <typename V>\nclass HT\n{\n    class Tuple\n    {\n    public:\n        int key;\n        V val;\n        bool in_use;\n\n        Tuple() : in_use(false) {}\n    };\n\n    vector<Tuple> tuples;\n    size_t _size;\n\n    size_t canonical_index(const int & key) const {\n        size_t hash_code = hash_function(key); // needs hash_function(K)\n        return hash_code % tuples.size();\n    }\n\n    // the returned tuple is either empty or with the same key\n    size_t indexOfKey(const int & key) const {\n        size_t index = canonical_index(key);\n        while (true) { // will enter a dead loop if there is not empty tuple\n            if (! tuples[index].in_use) return index;\n            if (tuples[index].key == key) return index;\n            index = (index + 1) % tuples.size();\n        }\n    }\n\npublic:\n    HT() : _size(0) {\n        tuples.resize(2);\n    }\n\n    bool containsKey(const int & key) const {\n        size_t index = indexOfKey(key);\n        return tuples[index].in_use;\n    }\n\n    const V & operator [] (const int & key) const {\n        size_t index = indexOfKey(key);\n        if (! tuples[index].in_use)\n            throw NoSuchKeyException();\n        return tuples[index].val;\n    }\n\n    V & operator [] (const int & key) {\n        size_t index = indexOfKey(key);\n        if (! tuples[index].in_use)\n            throw NoSuchKeyException();\n        return tuples[index].val;\n    }\n\n    void put(const int & key, const V & val) {\n        size_t index = indexOfKey(key);\n        tuples[index].key = key;\n        tuples[index].val = val;\n        if (tuples[index].in_use) return;\n        tuples[index].in_use = true;\n        ++ _size;\n        // make sure empty > size / 2\n        if (2 * _size > tuples.size())\n            _double_tuples();\n    }\n\n    void _double_tuples() {\n        vector<Tuple> non_empty_tuples;\n        I(i, tuples.size())\n            if (tuples[i].in_use)\n                non_empty_tuples.push_back(tuples[i]);\n        clear();\n        tuples.resize(tuples.size() * 2);\n        I(i, non_empty_tuples.size())\n            put(non_empty_tuples[i].key, non_empty_tuples[i].val);\n    }\n\n    static bool _between(size_t hole, size_t canonical, size_t tuple_index) {\n        if (hole < tuple_index)\n            return canonical > hole && canonical <= tuple_index;\n        else\n            return canonical > hole || canonical <= tuple_index;\n    }\n\n    void remove(const int & key) {\n        size_t index = indexOfKey(key);\n        if (! tuples[index].in_use)\n            throw NoSuchKeyException();\n        tuples[index].in_use = false;\n        -- _size;\n        // if there is a hole between a tuple and its canonical position\n        // move the tuple to the hole\n        size_t hole = index;\n        size_t tuple_index = hole;\n        while (true) {\n            tuple_index = (tuple_index + 1) % tuples.size();\n            if (! tuples[tuple_index].in_use) return;\n            size_t canonical = canonical_index(tuples[tuple_index].key);\n            if (_between(hole, canonical, tuple_index)) continue;\n            tuples[hole] = tuples[tuple_index];\n            hole = tuple_index;\n            tuples[hole].in_use = false;\n        }\n    }\n\n    size_t size() const { return _size; }\n\n    void clear() {\n        I(i, tuples.size())\n            tuples[i].in_use = false;\n        _size = 0;\n    }\n\n    template <typename V2>\n    friend ostream & operator << (ostream & out, const HT<V2> & dict);\n\n    template <typename V2>\n    friend istream & operator >> (istream & in, HT<V2> & dict);\n\n    void _inspect() const {\n        I(i, tuples.size())\n            if (tuples[i].in_use)\n                cout << \"#\" << i << \" C\" << canonical_index(tuples[i].key)\n                     << \" \" << tuples[i].key << \" \" << tuples[i].val << endl;\n    }\n\n    vector<int> getKeys() {\n        vector<int> Keys;\n        //Keys.resize(tuples.size());\n        I(i, tuples.size()){\n           if(tuples[i].in_use)\n               Keys.push_back(tuples[i].key);\n        }\n        return Keys;\n    }\n};\n\ntemplate < typename V>\nostream & operator << (ostream & out, const HT<V> & dict) {\n    out << dict.size() << endl;\n    I(i, dict.tuples.size())\n        if (dict.tuples[i].in_use)\n            out << dict.tuples[i].key << \"\\t\" << dict.tuples[i].val << endl;\n    return out;\n}\n\ntemplate <typename V>\nistream & operator >> (istream & in, HT<V> & dict) {\n    dict.clear();\n    size_t size;\n    in >> size;\n    I(i, size) {\n        int key;\n        V val;\n        in >> key >> val;\n        dict.put(key, val);\n    }\n    return in;\n}\n\ninline HT< string> load_dict() {\n    HT<string> dict;\n    ifstream in(\"my_dict.txt\");\n    if (in.fail())\n        throw runtime_error(\"Failed to load dictionary\");\n    in >> dict;\n    in.close();\n    return dict;\n}\n\ninline void save_dict(const HT<string> & dict) {\n    ofstream out(\"my_dict.txt\");\n    if (out.fail())\n        throw runtime_error(\"Failed to save dictionary\");\n    out << dict;\n    out.close();\n}\n",
            1595471794.2178328,
            100,
            "# 答案正确"
        ],
        [
            "A.5 (C++)",
            "向鼎",
            "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <stdexcept>\n#include <cstdlib>\nusing namespace std;\n\n#define I(i,n) for (size_t i = 0; i < n; ++ i)\n\nclass NoSuchKeyException {};\n\nsize_t circular_shift(size_t bits, int shift_bits) {\n    const int num_bits = 8 * sizeof(size_t);\n    shift_bits = shift_bits % num_bits;\n    return bits << shift_bits | bits >> (num_bits - shift_bits);\n}\n\nsize_t hash_function(const string & key) {\n    size_t code = 0;\n    I(i, key.size())\n        code ^= circular_shift(key[i], i * 5);\n    return code;\n}\n\nstring intToString(int num){\n    int flag = 1;\n    int i = 0,j = 0;\n    string tmp;char res[100] = \"\";\n    char buf[100] = \"\";\n    if(num < 0)\n        res[i++] = '-';\n    num = abs(num);\n    while(num){\n        buf[j++] = num%10 +'0';\n        num /= 10;\n    }\n    j--;\n    while(j>=0)\n        res[i++] = buf[j--];\n\n    tmp = res;\n    return tmp;\n}\n\n\nclass String{\npublic:\n    string str;\n    String(){}\n    String(int a){\n        str = intToString(a);\n    }\n    String(string a){\n        str = a;\n    }\n\n    operator string(){\n        return str;\n    }\n    operator int() {\n        return atoi(str.c_str());\n    }\n    String &operator = (const String & val){\n        this->str = val.str;\n        //cout<<\"this:\"<<this<<endl;\n        return *this;\n    }\n};\n\nclass HT\n{\n    class Tuple\n    {\n    public:\n        String key;\n        String val;\n        bool in_use;\n\n        Tuple() : in_use(false) {}\n        //operator int(){return atoi(val.c_str());}\n    };\n\n    vector<Tuple> tuples;\n    size_t _size;\n\n    size_t canonical_index(const string & key) const {\n        size_t hash_code = hash_function(key); // needs hash_function(K)\n        return hash_code % tuples.size();\n    }\n\n    // the returned tuple is either empty or with the same key\n    size_t indexOfKey(const string & key) const {\n        size_t index = canonical_index(key);\n        while (true) { // will enter a dead loop if there is not empty tuple\n            if (! tuples[index].in_use) return index;\n            if (tuples[index].key.str == key) return index;\n            index = (index + 1) % tuples.size();\n        }\n    }\n\npublic:\n    HT() : _size(0) {\n        tuples.resize(2);\n    }\n\n    bool containsKey(const string & key) const{\n        size_t index = indexOfKey(key);\n        return tuples[index].in_use;\n    }\n\n    const string & operator[] (const string & key) const {\n        size_t index = indexOfKey(key);\n        if(! tuples[index].in_use){\n            throw NoSuchKeyException();\n        }\n        return tuples[index].val.str;\n    }\n\n    String & operator[] (const string & key) {\n        size_t index = indexOfKey(key);\n        if(! tuples[index].in_use){\n            //throw NoSuchKeyException();\n            tuples[index].in_use = true;\n            tuples[index].key = key;\n            ++_size;\n            if(2 * _size > tuples.size())\n                _double_tuples();\n            index = indexOfKey(key);\n        }\n        return tuples[index].val;\n    }\n    String & operator[] (const int & key1) {\n        string key  = to_string(key1);\n        size_t index = indexOfKey(key);\n        if(! tuples[index].in_use){\n            //throw NoSuchKeyException();\n            tuples[index].in_use = true;\n            tuples[index].key = key;\n            ++_size;\n            if(2 * _size > tuples.size())\n                _double_tuples();\n            index = indexOfKey(key);\n        }\n        return tuples[index].val;\n    }\n    const String & operator[] (const int & key1) const{\n        string key  = to_string(key1);\n        size_t index = indexOfKey(key);\n        if(! tuples[index].in_use){\n            throw NoSuchKeyException();\n        }\n        return tuples[index].val;\n    }\n\n\n    void put(const String &key, const String & val){\n        size_t index = indexOfKey(key.str);\n        tuples[index].key = key;\n        tuples[index].val = val;\n        if(tuples[index].in_use) return;\n        tuples[index].in_use = true;\n        ++_size;\n        if(2 * _size > tuples.size())\n            _double_tuples();\n    }\n\n    void _double_tuples(){\n        vector<Tuple> non_empty_tuples;\n        I(i, tuples.size())\n            if(tuples[i].in_use)\n                non_empty_tuples.push_back(tuples[i]);\n        clear();\n        tuples.resize(tuples.size() * 2);\n        I(i, non_empty_tuples.size())\n            put(non_empty_tuples[i].key, non_empty_tuples[i].val);\n    }\n\n    static bool _between(size_t hole, size_t canonical, size_t tuple_index) {\n        if (hole < tuple_index)\n            return canonical > hole && canonical <= tuple_index;\n        else\n            return canonical > hole || canonical <= tuple_index;\n    }\n\n    void remove(const string & key) {\n        size_t index = indexOfKey(key);\n        if (! tuples[index].in_use){\n            throw NoSuchKeyException();\n        }\n        tuples[index].in_use = false;\n        -- _size;\n        // if there is a hole between a tuple and its canonical position\n        // move the tuple to the hole\n        size_t hole = index;\n        size_t tuple_index = hole;\n        while (true) {\n            tuple_index = (tuple_index + 1) % tuples.size();\n            if (! tuples[tuple_index].in_use) return;\n            size_t canonical = canonical_index(tuples[tuple_index].key);\n            if (_between(hole, canonical, tuple_index)) continue;\n            tuples[hole] = tuples[tuple_index];\n            hole = tuple_index;\n            tuples[hole].in_use = false;\n        }\n    }\n\n    size_t  size() const {return _size;}\n\n    void clear(){\n        I(i, tuples.size())\n            tuples[i].in_use = false;\n        _size = 0;\n    }\n\n//    friend ostream & operator << (ostream & out, const HT & dict);\n//    friend istream & operator >> (istream & in, HT & dict);\n\n};\n",
            1596194039.2901702,
            100,
            "# 答案正确"
        ]
    ],
    "table_name": "答案"
}