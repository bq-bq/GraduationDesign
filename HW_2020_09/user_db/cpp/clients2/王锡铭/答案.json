{
    "__update_time__": 1596183101.3979802,
    "field_names": [
        "题目名",
        "用户名",
        "答案",
        "提交时间",
        "分数",
        "评语"
    ],
    "field_types": [
        "text",
        "text",
        "text",
        "time",
        "number",
        "text"
    ],
    "foreign_keys": {},
    "primary_keys": [],
    "rows": [
        [
            "测试1",
            "王锡铭",
            "#include <iostream>\nusing namespace std;\n\nint main(){\n\tstring a,b,c;\n\tcin >> a >> b >> c;\n\t\n\tcout << c << ' ' << b << ' ' << a << endl;\n}",
            1587605524.2264829,
            100,
            "# 答案正确"
        ],
        [
            "测试2",
            "王锡铭",
            "#include <iostream>\nusing namespace std;\n\nint main(){\n\tstring a[10];\n\tfor (int i = 0; i < 10; ++ i) {\n\t\tcin >> a[i];\n\t}\n\tfor (int i = 0; i < 10; ++ i) {\n\t\tfor (int j = i; j < 10; ++ j) {\n\t\t\tif(a[i] > a[j]){\n\t\t\t\tstring t;\n\t\t\t\tt = a[i];\n\t\t\t\ta[i] = a[j];\n\t\t\t\ta[j] = t;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < 10; ++ i){\n\t\tcout << a[i] << ' ';\n\t} \n\tcout << endl;\n}",
            1587608815.383431,
            100,
            "# 答案正确"
        ],
        [
            "1.1 (C++)",
            "王锡铭",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix5x5{\n public:\n  double get(int row, int col){\n \t\treturn array[row][col];\n  }\n  void set(int row, int col, double num){\n  \t\tarray[row][col] = num;\n  }\n  friend Matrix5x5 operator + (Matrix5x5 & a, Matrix5x5 & b){\n   \t\tMatrix5x5 c;\n   \t\tfor (int i = 0; i < 5; ++ i){\n    \t\tfor (int j = 0;j < 5; ++j){\n     \t\tc.array[i][j] = a.array[i][j] + b.array[i][j];\n    \t\t}\n  \t\t }\n   \t\treturn c;\n  \t\t}\n private:\n  int array[6][6];\n};",
            1587703026.399417,
            100,
            "# 答案正确"
        ],
        [
            "1.2 (C++)",
            "王锡铭",
            "class School{\n\tpublic:\n\t\tchar name[10] = \"NO_NAME\";\n\t\tint age = 0;\n\t\tvoid setName(char name[]){\n\t\t\tfor(int i = 0;i < 10;i ++){\n\t\t\t\tthis->name[i] = name[i];\n\t\t\t}\n\t\t}\n\t\tvoid setAge(int year){\n\t\t\tthis->age = year;\n\t\t}\n\t\tvoid operator ++ (){\n\t\t\tthis->age ++;\n\t\t}\n};",
            1588215967.7912965,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/08",
            "王锡铭",
            "double & Tensor_get(int dimensions, int sizes[], double data[], int x0 , int x1 = -1, int x2 = -1, int x3 = -1){\n \tdata[0] = x0;\n \tdata[1] = data[0] * 10 + x1;\n \tdata[2] = data[1] * 10 + x2;\n \tdata[3] = data[2] * 10 + x3;\n \tif(x1 == -1)\n\t \treturn data[0];\n\telse if(x2 == -1)\n\t \treturn data[1];\n \telse if(x3 == -1)\n\t \treturn data[2];\n \telse \n\t \treturn data[3];\n}",
            1588908352.5052016,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/14",
            "王锡铭",
            "#include <iostream>\nusing namespace std;\n\nvoid Tensor_print(int dimensions, const int sizes[], const double data[]){\n\tif (dimensions == 1){\n  \t\tcout << \"Tensor of \" << sizes[0] << endl;\n  \t\tfor (int i = 0; i < sizes[0]; i ++){\n   \t\t\tcout << data[i] << endl;\n  \t\t}\n \t}\n \tif (dimensions == 2){\n  \t\tcout << \"Tensor of \" << sizes[0] << \"x\" << sizes[1] << endl;\n  \t\tfor (int i = 0; i < sizes[0]; i ++){\n   \t\t\tfor (int j = 0; j < sizes[1]; j ++){\n    \t\t\tcout << \"    \" << data[sizes[1] * i + j];\n   \t\t\t}\n   \t\t\tcout << endl;\n  \t\t}\n \t}\n \tif (dimensions == 3){\n  \t\tcout << \"Tensor of \" << sizes[0] << \"x\" << sizes[1] << \"x\" << sizes[2] << endl;\n  \t\tfor (int i = 0; i < sizes[0]; i ++){\n   \t\t\tcout << \"data\" << \"[\" << i << \"]\" << endl;\n   \t\t\tfor (int m = 0; m < sizes[1]; m ++){\n    \t\t\tfor (int n = 0; n < sizes[2]; n ++){\n     \t\t\t\tcout << \"    \" << data[m * sizes[2] + n];\n    \t\t\t}\n    \t\t\tcout << endl;\n   \t\t\t}\n  \t\t}\n \t}\n \tif (dimensions == 4){\n  \t\tcout << \"Tensor of \" << sizes[0] << \"x\" << sizes[1] << \"x\" << sizes[2] << \"x\" << sizes[3] << endl;\n  \t\tfor (int i = 0; i < sizes[0]; i ++){\n   \t\t\tfor (int j = 0; j < sizes[1]; j ++){\n    \t\t\tcout << \"data\" << \"[\" << i << \"]\" << \"[\" << j << \"]\" << endl;\n    \t\t\tfor (int m = 0; m < sizes[2]; m ++){\n     \t\t\t\tfor (int n = 0; n < sizes[3]; n ++){\n      \t\t\t\t\tcout << \"    \" << data[m * sizes[3] + n];\n     \t\t\t\t}\n     \t\t\t\tcout << endl;\n    \t\t\t}\n   \t\t\t}\n  \t\t}\n \t}\n}",
            1589425844.546827,
            100,
            "# 答案正确"
        ],
        [
            "2.1 (C++)",
            "王锡铭",
            "#include<iostream>\nusing namespace std;\nclass Matrix{\n\tprivate:\n\t\tint rows;\n\t\tint columns;\n\t\tdouble *values;\n\tpublic:\n\t\tMatrix(int rows,int columns){\n\t\t\tthis -> rows = rows;\n\t\t\tthis -> columns = columns;\n\t\t\tthis -> values = new double[rows * columns + 1];\n\t\t\tfor(int i = 0;i < rows;i ++){\n\t\t\t\tfor(int j = 0;j < columns;j ++){\n\t\t\t\t\tvalues[i * columns + j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t~Matrix(){\n\t\t\tdelete []this -> values;\n\t\t}\n\t\tvoid print(){\n\t\t\tfor(int i = 0;i < this -> rows;i ++){\n\t\t\t\tfor(int j = 0;j < this -> columns;j ++){\n\t\t\t\t\tcout << \"    \" << values[i * this -> columns + j];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n};",
            1589426622.9302952,
            100,
            "# 答案正确"
        ],
        [
            "2.2 (C++)",
            "王锡铭",
            "#include<iostream>\n#include<iomanip>\nusing namespace std;\nclass Matrix{\n\tprivate:\n\t\tint rows;\n\t\tint columns;\n\t\tdouble *values;\n\tpublic:\n\t\tMatrix(int rows,int columns,double values[]){\n\t\t\tthis -> rows = rows;\n\t\t\tthis -> columns = columns;\n\t\t\tthis -> values = new double[rows * columns + 1];\n\t\t\tfor(int i = 0;i < rows;i ++){\n\t\t\t\tfor(int j = 0 ;j < columns;j ++){\n\t\t\t\t\tthis -> values[i * columns + j] = values[i * columns + j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t~Matrix(){\n\t\t\tdelete []this -> values;\n\t\t}\n\t\tvoid print(){\n\t\t\tfor(int i = 0;i < this -> rows;i ++){\n\t\t\t\tfor(int j = 0;j < this -> columns;j ++){\n\t\t\t\t\tcout << setw(5) << this -> values[i * this -> columns + j];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n};",
            1589426740.9742599,
            100,
            "# 答案正确"
        ],
        [
            "2.3 (C++)",
            "王锡铭",
            "#include<iostream>\nusing namespace std;\n\nclass Matrix{\n\tprivate:\n\t\tint rows;\n\t\tint columns;\n\t\tdouble *values;\n\tpublic:\n\t\tMatrix(int rows,int columns,double values[]){\n\t\t\tthis -> rows = rows;\n\t\t\tthis -> columns = columns;\n\t\t\tthis -> values = new double[rows*columns+1];\n\t\t\tfor(int i = 0 ;i < rows;i ++){\n\t\t\t\tfor(int j = 0;j < columns;j ++){\n\t\t\t\t\tthis -> values[i * columns + j]=values[i * columns + j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tMatrix(const Matrix & matrix2){\n\t\t\tthis -> rows = matrix2.rows;\n\t\t\tthis -> columns = matrix2.columns;\n\t\t\tthis -> values=new double[this -> rows * this -> columns + 1];\n\t\t\tfor(int i = 0;i < this -> rows;i ++){\n\t\t\t\tfor(int j = 0;j < this -> columns;j ++){\n\t\t\t\t\tthis -> values[i * this -> columns + j] = matrix2.values[i * this -> columns + j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t~Matrix(){\n\t\t\tdelete []this -> values;\n\t\t}\n\t\tvoid print(){\n\t\t\tfor(int i=0;i<this->rows;i++){\n\t\t\t\tfor(int j=0;j<this->columns;j++){\n\t\t\t\t\tcout<<\"    \"<<this->values[i*this->columns+j];\n\t\t\t\t}\n\t\t\t\tcout<<endl;\n\t\t\t}\n\t\t}\n};",
            1589426911.4445236,
            100,
            "# 答案正确"
        ],
        [
            "2.5 (C++)",
            "王锡铭",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tdouble mat[50][50];\n\tMatrix(int rows, int columns){\n\t\tthis -> rows = rows;\n\t\tthis -> columns = columns;\n\t\tfor(int i = 0; i < rows; ++i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tmat [i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tMatrix(int rows, int columns, double values[]){\n\t\tthis -> rows = rows;\n\t\tthis -> columns = columns;\n\t\tfor(int i = 0; i < rows;i ++){\n\t\t\tfor(int j = 0; j < columns;j ++){\n\t\t\t\tint count;\n\t\t\t\tcount = i * columns + j;\n\t\t\t\tmat [i][j] = values[count];\n\t\t\t}\n\t\t}\n\t}\n\tvoid print(){\n\t\tfor(int i = 0; i < rows; ++i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tcout << mat[i][j] << \"    \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tMatrix getRow(int row){\n\t\tMatrix matr(1,columns);\n\t\tfor(int i = 0; i < columns; ++i){\n\t\t\tmatr.mat[0][i] = mat[row-1][i];\n\t\t}\n\t\treturn matr;\n\t}\n\tMatrix getColumn(int column){\n\t\tMatrix matr(rows,1);\n\t\tfor(int i = 0; i < rows; ++i){\n\t\t\tmatr.mat[i][0] = mat[i][column-1];\n\t\t}\n\t\treturn matr;\n\t}\n\t~Matrix(){\n\t\t\n\t}\n};",
            1589447849.8515933,
            100,
            "# 答案正确"
        ],
        [
            "2.6 (C++)",
            "王锡铭",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tdouble mat[50][50];\n\tMatrix(int rows, int columns){\n\t\tthis -> rows = rows;\n\t\tthis -> columns = columns;\n\t\tfor(int i = 0; i < rows; ++i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tmat [i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tMatrix(int rows, int columns, double values[]){\n\t\tthis -> rows = rows;\n\t\tthis -> columns = columns;\n\t\tfor(int i = 0; i < rows; ++i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tint count;\n\t\t\t\tcount = i * columns + j;\n\t\t\t\tmat [i][j] = values[count];\n\t\t\t}\n\t\t}\n\t}\n\tvoid print(){\n\t\tfor(int i = 0; i < rows; ++i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tcout << mat[i][j] << \"    \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tMatrix concatenateRows(const Matrix & matrix2) const{\n\t\tMatrix m(this->rows + matrix2.rows,this->columns);\n\t\tfor(int i = 0; i < this->rows + matrix2.rows; ++i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tif(i < this->rows){\n\t\t\t\t\tm.mat[i][j] = this->mat[i][j];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tm.mat[i][j] = matrix2.mat[i-this->rows][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn m;\n\t}\n\tMatrix concatenateColumns(const Matrix & matrix2) const{\n\t\tMatrix m(this->rows ,this->columns + matrix2.columns);\n\t\tfor(int i = 0; i < this->rows; i ++){\n\t\t\tfor(int j = 0; j < columns+ matrix2.columns;j ++){\n\t\t\t\tif(j < this->columns){\n\t\t\t\t\tm.mat[i][j] = this->mat[i][j];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tm.mat[i][j] = matrix2.mat[i][j - this-> columns];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn m;\n\t}\n\t~Matrix(){\n\t\t\n\t}\n};",
            1589447885.2343218,
            100,
            "# 答案正确"
        ],
        [
            "2.9 (C++)",
            "王锡铭",
            "#include <iostream>\nusing namespace std;\nclass Matrix{\n\tprivate:\n\t\tint rows;\n\t\tint columns;\n\t\tdouble * values;\n\tpublic:\n\t\tMatrix(int rows, int column, double values[])\n\t\t{\n\t\t\tthis->rows = rows;\n\t\t\tthis->columns = column;\n\t\t\tthis->values = new double [rows * columns + 1];\n\t\t\tfor (int i = 0; i < this->rows * this->columns; ++ i)\n\t\t\t{\n\t\t\t\tthis->values[i] = values[i]; \n\t\t\t}\n\t\t}\n\tMatrix(const Matrix & matrix2)\n\t\t{\n\t\t\tthis->rows = matrix2.rows;\n\t\t\tthis->columns = matrix2.columns;\n\t\t\tthis->values = new double [rows * columns + 1];\n\t\t\tfor (int i = 0; i < this->rows; ++ i)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < this->columns; ++ j) values[i * this->columns + j] = matrix2.values[i * this->columns + j]; \n\t\t\t}\n\t\t}\n\t\t~Matrix()\n\t\t{\n\t\t\tdelete [] this->values;\n\t\t}\n\tvoid print()\n\t\t{\n\t\t\tfor (int i = 0; i < this->rows; ++ i)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < this->columns; ++ j) cout << \"    \" << values[i * this->columns + j];\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\tMatrix operator + (const Matrix &matrix2) {\n\t\tdouble p[this->rows*this->columns+1];\n\t\tfor(int i=0;i<this->rows;i++){\n\t\t\tfor(int j=0;j<this->columns;j++){\n\t\t\t\tp[i*this->columns+j]=this->values[i*this->columns+j] + matrix2.values[i*this->columns+j];\n\t\t\t}\n\t\t}\n\t\treturn Matrix(this->rows,this->columns,p);\n\t}\n\tMatrix operator + (double value) {\n\t\tdouble p[this->rows*this->columns+1];\n\t\tfor(int i=0;i<this->rows;i++){\n\t\t\tfor(int j=0;j<this->columns;j++){\n\t\t\t\tp[i*this->columns+j]=this->values[i*this->columns+j] + value;\n\t\t\t}\n\t\t}\n\t\treturn Matrix(this->rows,this->columns,p);\n\t}\n\tMatrix operator - (const Matrix &matrix2) {\n\t\tdouble p[this->rows*this->columns+1];\n\t\tfor(int i=0;i<this->rows;i++){\n\t\t\tfor(int j=0;j<this->columns;j++){\n\t\t\t\tp[i*this->columns+j]=this->values[i*this->columns+j] - matrix2.values[i*this->columns+j];\n\t\t\t}\n\t\t}\n\t\treturn Matrix(this->rows,this->columns,p);\n\t}\n\tMatrix operator - (double value) {\n\t\tdouble p[this->rows*this->columns+1];\n\t\tfor(int i=0;i<this->rows;i++){\n\t\t\tfor(int j=0;j<this->columns;j++){\n\t\t\t\tp[i*this->columns+j]=this->values[i*this->columns+j] - value;\n\t\t\t}\n\t\t}\n\t\treturn Matrix(this->rows,this->columns,p);\n\t}\n};",
            1590030429.7953775,
            100,
            "# 答案正确"
        ],
        [
            "2.7 (C++)",
            "王锡铭",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tdouble mat[20][20];\n\tMatrix(int rows, int columns){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tfor (int i = 0; i < rows; ++ i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tmat[i][j] = 0;\n\t\t\t}\n\t\t} \n\t}\n\tMatrix(int rows, int columns, double values[]){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tint count = 0;\n\t\tfor (int i = 0; i < rows; ++ i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tmat[i][j] = values[count];\n\t\t\t\t++count;\n\t\t\t}\n\t\t} \n\t}\n\tMatrix(const Matrix & matrix2){\n\t\tthis->rows = matrix2.rows;\n\t\tthis->columns = matrix2.columns;\n\t\tfor (int i = 0; i < rows; ++ i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\t this->mat[i][j]= matrix2.mat[i][j];\n\t\t\t}\n\t\t} \n\t}\n\tvoid print(){\n\t\tfor(int i = 0; i < rows; ++i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tcout << \"    \" << mat[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tMatrix reshape(int rows, int columns)const{\n\t\tMatrix ma(rows,columns);\n\t\tdouble arr[100];\n\t\tint count = 0;\n\t\tfor(int i = 0; i < this->columns; ++i){\n\t\t\tfor(int j = 0; j < this-> rows; ++j){\n\t\t\t\tarr[count] = mat[j][i];\n\t\t\t\t++count;\n\t\t\t}\n\t\t}\n\t\tcount = 0;\n\t\tfor(int i = 0; i < columns; ++i){\n\t\t\tfor(int j = 0; j < rows; ++j){\n\t\t\t\tma.mat[j][i] = arr[count];\n\t\t\t\t++count;\n\t\t\t}\n\t\t}\n\t\treturn ma;\n\t}\n\t~Matrix(){\n\t\t\n\t}\n};",
            1590041061.8811865,
            100,
            "# 答案正确"
        ],
        [
            "2.4 (C++)",
            "王锡铭",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tdouble mat[10][10];\n\tMatrix(int rows, int columns){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tfor (int i = 0; i < rows; ++ i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tmat[i][j] = 0;\n\t\t\t}\n\t\t} \n\t}\n\tMatrix(int rows, int columns, double values[]){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tint count = 0;\n\t\tfor (int i = 0; i < rows; ++ i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tmat[i][j] = values[count];\n\t\t\t\t++count;\n\t\t\t}\n\t\t} \n\t}\n\tvoid set(int row, int column, double value){\n\t\tmat[row-1][column-1] = value;\n\t}\n\tvoid print(){\n\t\tfor(int i = 0; i < rows; ++i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tcout << mat[i][j] << \"    \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tMatrix operator =(Matrix & ma){\n\t\tthis->rows = ma.rows;\n\t\tthis->columns = ma.columns;\n\t\tfor (int i = 0; i < rows; ++ i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tthis-> mat[i][j] = ma.mat[i][j];\n\t\t\t}\n\t\t}\n\t}\n\t~Matrix(){\n\t\t\n\t}\n};",
            1590041039.0512555,
            100,
            "# 答案正确"
        ],
        [
            "2.8 (C++)",
            "王锡铭",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tdouble mat[20][20];\n\tMatrix(int rows, int columns){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tfor (int i = 0; i < rows; ++ i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tmat[i][j] = 0;\n\t\t\t}\n\t\t} \n\t}\n\tMatrix(int rows, int columns, double values[]){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tint count = 0;\n\t\tfor (int i = 0; i < rows; ++ i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tmat[i][j] = values[count];\n\t\t\t\t++count;\n\t\t\t}\n\t\t} \n\t}\n\tMatrix(const Matrix & matrix2){\n\t\tthis->rows = matrix2.rows;\n\t\tthis->columns = matrix2.columns;\n\t\tfor (int i = 0; i < rows; ++ i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\t this->mat[i][j]= matrix2.mat[i][j];\n\t\t\t}\n\t\t} \n\t}\n\tvoid print(){\n\t\tfor(int i = 0; i < rows; ++i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tcout << \"    \" << mat[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tMatrix transpose(){\n\t\tMatrix ma(this->columns,this->rows);\n\t\tfor(int i = 0; i < this->columns; ++i){\n\t\t\tfor(int j = 0; j < this->rows;++j){\n\t\t\t\tma.mat[i][j] = this->mat[j][i];\n\t\t\t}\n\t\t}\n\t\treturn ma;\n\t}\n\t~Matrix(){\n\t\t\n\t}\n};",
            1590041077.377349,
            100,
            "# 答案正确"
        ],
        [
            "2.10 (C++)",
            "王锡铭",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tdouble mat[20][20];\n\tMatrix(int rows, int columns){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tfor (int i = 0; i < rows; ++ i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tmat[i][j] = 0;\n\t\t\t}\n\t\t} \n\t}\n\tMatrix(int rows, int columns, double values[]){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tint count = 0;\n\t\tfor (int i = 0; i < rows; ++ i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tmat[i][j] = values[count];\n\t\t\t\t++count;\n\t\t\t}\n\t\t} \n\t}\n\tMatrix(const Matrix & matrix2){\n\t\tthis->rows = matrix2.rows;\n\t\tthis->columns = matrix2.columns;\n\t\tfor (int i = 0; i < rows; ++ i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\t this->mat[i][j]= matrix2.mat[i][j];\n\t\t\t}\n\t\t} \n\t}\n\tvoid print(){\n\t\tfor(int i = 0; i < rows; ++i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tcout << \"    \" << mat[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tMatrix operator * (const Matrix & matrix2) const{\n\t\tMatrix ma(this->rows, matrix2.columns);\n\t\tfor(int i = 0; i < this->rows; ++i){\n\t\t\tfor(int j = 0; j < matrix2.columns; ++j){\n\t\t\t\tdouble sum = 0;\n\t\t\t\tfor(int k = 0; k < this->columns; ++k){\n\t\t\t\t\tsum = sum + this->mat[i][k] * matrix2.mat[k][j];\n\t\t\t\t}\n\t\t\t\tma.mat[i][j] = sum;\n\t\t\t}\n\t\t}\n\t\treturn ma;\n\t}\n\tMatrix operator * (double value) const{\n\t\tMatrix ma(this->rows,this->columns);\n\t\tfor(int i = 0; i < rows;++i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tma.mat[i][j] = this->mat[i][j] * value;\n\t\t\t}\n\t\t}\n\t\treturn ma;\n\t}\n\t~Matrix(){\n\t\t\n\t}\n};",
            1590041094.034331,
            100,
            "# 答案正确"
        ],
        [
            "2.11 (C++)",
            "王锡铭",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tdouble mat[20][20];\n\tMatrix(int rows, int columns){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tfor (int i = 0; i < rows; ++ i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tmat[i][j] = 0;\n\t\t\t}\n\t\t} \n\t}\n\tMatrix(int rows, int columns, double values[]){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tint count = 0;\n\t\tfor (int i = 0; i < rows; ++ i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tmat[i][j] = values[count];\n\t\t\t\t++count;\n\t\t\t}\n\t\t} \n\t}\n\tMatrix(const Matrix & matrix2){\n\t\tthis->rows = matrix2.rows;\n\t\tthis->columns = matrix2.columns;\n\t\tfor (int i = 0; i < rows; ++ i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\t this->mat[i][j]= matrix2.mat[i][j];\n\t\t\t}\n\t\t} \n\t}\n\tvoid print(){\n\t\tfor(int i = 0; i < rows; ++i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tcout << \"    \" << mat[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tMatrix max() const{\n\t\tif(this->rows == 1){\n\t\t\tMatrix ma(1,1);\n\t\t\tdouble max = 0;\n\t\t\tfor(int i = 0; i < this->columns; ++i){\n\t\t\t\tif(this->mat[0][i] > max)max = this->mat[0][i];\n\t\t\t}\n\t\t\tma.mat[0][0] = max;\n\t\t\treturn ma;\n\t\t}\n\t\telse{\n\t\t\tMatrix ma(1,this->columns);\n\t\t\tfor(int i = 0; i < columns; ++i){\n\t\t\t\tdouble max = 0;\n\t\t\t\tfor(int j = 0; j < this-> rows; ++j){\n\t\t\t\t\tif(this->mat[j][i] > max)max = this->mat[j][i];\n\t\t\t\t}\n\t\t\t\tma.mat[0][i] = max;\n\t\t\t}\n\t\t\treturn ma;\n\t\t}\n\t}\n\tMatrix min() const{\n\t\tif(this->rows == 1){\n\t\t\tMatrix ma(1,1);\n\t\t\tdouble min = 10000;\n\t\t\tfor(int i = 0; i < this->columns; ++i){\n\t\t\t\tif(this->mat[0][i] < min)min = this->mat[0][i];\n\t\t\t}\n\t\t\tma.mat[0][0] = min;\n\t\t\treturn ma;\n\t\t}\n\t\telse{\n\t\t\tMatrix ma(1,this->columns);\n\t\t\tfor(int i = 0; i < columns; ++i){\n\t\t\t\tdouble min = 10000;\n\t\t\t\tfor(int j = 0; j < this-> rows; ++j){\n\t\t\t\t\tif(this->mat[j][i] < min)min = this->mat[j][i];\n\t\t\t\t}\n\t\t\t\tma.mat[0][i] = min;\n\t\t\t}\n\t\t\treturn ma;\n\t\t}\n\t}\n\tMatrix sum() const{\n\t\tif(this->rows == 1){\n\t\t\tMatrix ma(1,1);\n\t\t\tdouble sum = 0;\n\t\t\tfor(int i = 0; i < this->columns; ++i){\n\t\t\t\tsum = sum + this->mat[0][i];\n\t\t\t}\n\t\t\tma.mat[0][0] = sum;\n\t\t\treturn ma;\n\t\t}\n\t\telse{\n\t\t\tMatrix ma(1,this->columns);\n\t\t\tfor(int i = 0; i < columns; ++i){\n\t\t\t\tdouble sum = 0;\n\t\t\t\tfor(int j = 0; j < this-> rows; ++j){\n\t\t\t\t\tsum = sum + this->mat[j][i];\n\t\t\t\t}\n\t\t\t\tma.mat[0][i] = sum;\n\t\t\t}\n\t\t\treturn ma;\n\t\t}\n\t}\n\t~Matrix(){\n\t\t\n\t}\n};",
            1590041108.6182125,
            100,
            "# 答案正确"
        ],
        [
            "2.12 (C++)",
            "王锡铭",
            "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tdouble mat[20][20];\n\tMatrix(int rows, int columns){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tfor (int i = 0; i < rows; ++ i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tmat[i][j] = 0;\n\t\t\t}\n\t\t} \n\t}\n\tMatrix(int rows, int columns, double values[]){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tint count = 0;\n\t\tfor (int i = 0; i < rows; ++ i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tmat[i][j] = values[count];\n\t\t\t\t++count;\n\t\t\t}\n\t\t} \n\t}\n\tMatrix(const Matrix & matrix2){\n\t\tthis->rows = matrix2.rows;\n\t\tthis->columns = matrix2.columns;\n\t\tfor (int i = 0; i < rows; ++ i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\t this->mat[i][j]= matrix2.mat[i][j];\n\t\t\t}\n\t\t} \n\t}\n\tvoid print(){\n\t\tfor(int i = 0; i < rows; ++i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tcout << \"    \" << mat[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tMatrix pow(double exponent){\n\t\tMatrix ma(this->rows,this->columns);\n\t\tfor(int i = 0; i < this->rows; ++i){\n\t\t\tfor(int j = 0; j < this->columns; ++j){\n\t\t\t\tdouble value;\n\t\t\t\tma.mat[i][j] = std:: pow(this->mat[i][j],exponent);\n\t\t\t}\n\t\t}\n\t\treturn ma;\n\t}\n\tMatrix exp(){\n\t\tMatrix ma(this->rows,this->columns);\n\t\tfor(int i = 0; i < this->rows; ++i){\n\t\t\tfor(int j = 0; j < this->columns; ++j){\n\t\t\t\tdouble value;\n\t\t\t\tma.mat[i][j] = std:: exp(this->mat[i][j]);\n\t\t\t}\n\t\t}\n\t\treturn ma;\n\t}\n\tMatrix log(){\n\t\tMatrix ma(this->rows,this->columns);\n\t\tfor(int i = 0; i < this->rows; ++i){\n\t\t\tfor(int j = 0; j < this->columns; ++j){\n\t\t\t\tdouble value;\n\t\t\t\tma.mat[i][j] = std:: log(this->mat[i][j]);\n\t\t\t}\n\t\t}\n\t\treturn ma;\n\t}\n\tMatrix abs(){\n\t\tMatrix ma(this->rows,this->columns);\n\t\tfor(int i = 0; i < this->rows; ++i){\n\t\t\tfor(int j = 0; j < this->columns; ++j){\n\t\t\t\tdouble value;\n\t\t\t\tma.mat[i][j] = std:: abs(this->mat[i][j]);\n\t\t\t}\n\t\t}\n\t\treturn ma;\n\t}\n\t~Matrix(){\n\t\t\n\t}\n};",
            1590041123.9432042,
            100,
            "# 答案正确"
        ],
        [
            "6.2 (C++)",
            "王锡铭",
            "#include<iostream>\nusing namespace std;\n#include<string>\n\ntemplate<class T>\nclass Matrix {\nprivate:\n int rows;\n int columns;\n T * values;\npublic:\n Matrix(int rows, int column) {\n  this->rows = rows;\n  this->columns = column;\n  this->values = new T[this->rows*this->columns];\n  for (int i = 0;i < this->rows;i++) {\n   for (int j = 0;j < this->columns;j++) {\n    values[i*this->columns + j] = 0;\n   }\n  }\n }\n ~Matrix() {\n  delete[]values;\n }\n void print() {\n  for (int i = 0;i < this->rows;i++) {\n   for (int j = 0;j < this->columns;j++) {\n    cout << \"    \" << values[i*this->columns + j];\n   }\n\t  cout << endl;\n  }\n }\n};",
            1590633830.105386,
            100,
            "# 答案正确"
        ],
        [
            "6.1 (C++)",
            "王锡铭",
            "#include<bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nclass Matrix{\n\tprivate:\n\t\tint rows;\n\t\tint col;\n\t\tT*val;\n\t\tvoid assign(){\n\t\t\tif(val!=0)\n\t\t\tdelete[]val;\n\t\t\tval=0;\n\t\t}\n\tpublic:\n\t\tMatrix(int r,int c):rows(r),col(c){\n\t\t\tval=new T[rows*col];\n\t\t\tmemset(val,0,sizeof(T)*rows*col);\n\t\t}\n\t\tMatrix(int r,int c,const T* v):rows(r),col(c){\n\t\t\tval=new T[rows*col];\n\t\t\tfor(int i=0;i<rows*col;i++){\n\t\t\t\tval[i]=v[i];\n\t\t\t}\n\t\t}\n\t\tvoid print(){\n\t\t\tfor(int i=0;i<rows;i++){\n\t\t\t\tfor(int j=0;j<col;j++){\n\t\t\t\t\tcout<<\"    \"<<val[i*col+j];\n\t\t\t\t}cout<<endl;\n\t\t\t}\n\t\t}\n\t\tMatrix& operator=(Matrix& a){\n\t\t\tassign();\n\t\t\trows=a.rows;\n\t\t\tcol=a.col;\n\t\t\tval=new T[rows*col];\n\t\t\tfor(int i=0;i<rows*col;i++)\n\t\t\tval[i]=a.val[i];\n\t\t\treturn *this;\n\t\t}\n\t\tMatrix(Matrix & a):rows(a.rows),col(a.col){\n\t\t\tval=new T[rows*col];\n\t\t\tfor(int i=0;i<rows*col;i++)\n\t\t\tval[i]=a.val[i];\n\t\t}\n\t\tT& get(int i,int j){\n\t\t\treturn val[(i-1)*col+j-1];\n\t\t}\n\t~Matrix(){\n\t\tassign();\n}\n}; ",
            1590647064.4469202,
            100,
            "# 答案正确"
        ],
        [
            "6.3 (C++)",
            "王锡铭",
            "#include<bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nclass Matrix{\n\tprivate:\n\t\tint rows;\n\t\tint col;\n\t\tvector <T> val;\n\t\tvoid assign(){\n\t\t\tval.clear();\n\t\t}\n\tpublic:\n\t\tMatrix(int r,int c):rows(r),col(c){\n\t\t\tfor(int i=0;i<rows*col;i++)\n\t\t\tval.push_back(0);\n\t\t}\n\t\tMatrix(int r,int c,vector <T> v):rows(r),col(c){\n\t\t\tfor(int i=0;i<rows*col;i++)\n\t\t\tval.push_back(v[i]);\n\t\t}\n\t\tvoid print(){\n\t\t\tfor(int i=0;i<rows;i++){\n\t\t\t\tfor(int j=0;j<col;j++){\n\t\t\t\t\tcout<<\"    \"<<val[i*col+j];\n\t\t\t\t}cout<<endl;\n\t\t\t}\n\t\t}\n\t\tT& get(int i,int j){\n\t\t\treturn val[(i-1)*col+j-1];\n\t\t}\n\t\tMatrix getColumn(int a){\n\t\t\tvector<T> temp;\n\t\t\tfor(int i=0;i<rows;i++){\n\t\t\t\ttemp.push_back(val[i*col+(a-1)]);\n\t\t\t}\n\t\t\tMatrix b(rows,1,temp);\n\t\t\treturn b;\n\t\t}\n\t\tMatrix getRow(int a){\n\t\t\tvector<T> temp;\n\t\t\tfor(int i=0;i<col;i++){\n\t\t\t\ttemp.push_back(val[i+(a-1)*rows]);\n\t\t\t}\n\t\t\tMatrix b(1,col,temp);\n\t\t\treturn b;\n\t\t}\n\t\tMatrix concatenateRows(Matrix a){\n\t\t\tvector <T> temp;\n\t\t\tfor(int i=0;i<rows*col;i++)\n\t\t\ttemp.push_back(val[i]);\n\t\t\tfor(int i=0;i<a.col*a.rows;i++){\n\t\t\t\ttemp.push_back(a.val[i]);\n\t\t\t}\n\t\t\tMatrix b(rows+a.rows,col,temp);\n\t\t\treturn b;\n\t\t}\n\t\tMatrix concatenateColumns(Matrix a){\n\t\t\tvector <T> temp;\n\t\t\tfor(int i=0;i<rows;i++)\n\t\t\t{\n\t\t\t\tfor(int j=0;j<col;j++){\n\t\t\t\t\ttemp.push_back(val[i*col+j]);\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<a.col;j++)\n\t\t\t\ttemp.push_back(a.val[i*a.col+j]);\n\t\t\t}\n\t\t\tMatrix b(rows,col+a.col,temp);\n\t\t\treturn b;\n\t\t}\n\t\tMatrix reshape(int r,int c){\n\t\t\tvector <T> temp(rows*col);\n\t\t\tvector<T> t1(rows*col);\n\t\t\tint k=0;\n\t\t\tfor(int i=0;i<col;i++){\n\t\t\t\tfor(int j=0;j<rows;j++){\n\t\t\t\t\tt1[k++]=val[i+j*col];\n\t\t\t\t}\n\t\t\t}\n\t\t\tk=0;\n\t\t\tfor(int i=0;i<c;i++){\n\t\t\t\tfor(int j=0;j<r;j++){\n\t\t\t\t\ttemp[i+j*c]=t1[k++];\n\t\t\t\t}\n\t\t\t}\n\t\t\tMatrix b(r,c,temp);\n\t\t\treturn b;\n\t\t}\n\t\tMatrix transpose(){\n\t\t\tvector<T> t1(rows*col);\n\t\t\tint k=0;\n\t\t\tfor(int i=0;i<col;i++){\n\t\t\t\tfor(int j=0;j<rows;j++){\n\t\t\t\t\tt1[k++]=val[i+j*col];\n\t\t\t\t}\n\t\t\t}\n\t\t\tMatrix b(rows,col,t1);\n\t\t\treturn b;\n\t\t}\n\t\tMatrix operator +(Matrix a){\n\t\t\tvector <T> temp;\n\t\t\tfor(int i=0;i<rows*col;i++)\n\t\t\ttemp.push_back(val[i]+a.val[i]);\n\t\t\tMatrix b(rows,col,temp);\n\t\t\treturn b;\n\t\t}\n\t\tMatrix operator +(T a){\n\t\t\tvector <T> temp;\n\t\t\tfor(int i=0;i<rows*col;i++)\n\t\t\ttemp.push_back(val[i]+a);\n\t\t\tMatrix b(rows,col,temp);\n\t\t\treturn b;\n\t\t}\n\t\tMatrix operator -(Matrix a){\n\t\t\tvector <T> temp;\n\t\t\tfor(int i=0;i<rows*col;i++)\n\t\t\ttemp.push_back(val[i]-a.val[i]);\n\t\t\tMatrix b(rows,col,temp);\n\t\t\treturn b;\n\t\t}\n\t\tMatrix operator -(T a){\n\t\t\tvector <T> temp;\n\t\t\tfor(int i=0;i<rows*col;i++)\n\t\t\ttemp.push_back(val[i]-a);\n\t\t\tMatrix b(rows,col,temp);\n\t\t\treturn b;\n\t\t}\n\t\tMatrix operator *(Matrix a){\n\t\t\tvector <T> temp(rows*a.col,0);\n\t\t\tfor(int i=0;i<rows;i++){\n\t\t\t\tfor(int j=0;j<a.col;j++){\n\t\t\t\t\tfor(int k=0;k<col;k++){\n\t\t\t\t\t\ttemp[i*a.col+j]+=val[i*col+k]*a.val[k*a.col+j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tMatrix b(rows,col,temp);\n\t\t\treturn b;\n\t\t}\n\t\tMatrix operator *(T a){\n\t\t\tvector <T> temp(rows*col);\n\t\t\tfor(int i=0;i<rows*col;i++){\n\t\t\t\ttemp[i]=val[i]*a;\n\t\t\t}\n\t\t\tMatrix b(rows,col,temp);\n\t\t\treturn b;\n\t\t}\n\t\t\tMatrix max(){\n\t\t\tvector <T> temp;\n\t\t\tT max=val[0];\n\t\t\tint maxrow=0;\n\t\t\t\tfor(int i=0;i<rows*col;i++){\n\t\t\t\t\t\n\t\t\t\t\tif(max<val[i]){\n\t\t\t\t\t\tmax=val[i];\n\t\t\t\t\t\tmaxrow=i/col;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(rows==1){\n\t\t\t\ttemp.push_back(max);\n\t\t\t\treturn Matrix(1,1,temp);\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\telse{\n\t\t\t\tfor(int i=0;i<col;i++){\n\t\t\t\t\ttemp.push_back(val[i+maxrow*col]);\n\t\t\t\t\t//cout<<\"  \"<<\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn Matrix(1,col,temp);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\n\t\tMatrix min(){\n\t\t\tvector <T> temp;\n\t\t\tT max=val[0];\n\t\t\tint maxrow=0;\n\t\t\t\tfor(int i=0;i<rows*col;i++){\n\t\t\t\t\t\n\t\t\t\t\tif(max>val[i]){\n\t\t\t\t\t\tmax=val[i];\n\t\t\t\t\t\tmaxrow=i/col;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(rows==1){\n\t\t\t\ttemp.push_back(max);\n\t\t\t\treturn Matrix(1,1,temp);\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\telse{\n\t\t\t\tfor(int i=0;i<col;i++)\n\t\t\t\ttemp.push_back(val[i+maxrow*col]);\n\t\t\t\treturn Matrix(1,col,temp);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\tMatrix sum(){\n\t\t\tvector <T> temp;\n\t\t\tint sum=0;\n\t\t\tif(rows==1){\n\t\t\t\tfor(int i=0;i<col;i++)\n\t\t\t\tsum+=val[i];\n\t\t\t\t\n\t\t\t\ttemp.push_back(sum);\n\t\t\t\treturn Matrix(1,1,temp);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int i=0;i<rows;i++){\n\t\t\t\t\tsum=0;\n\t\t\t\t\tfor(int j=0;j<col;j++){\n\t\t\t\t\t\tsum+=val[i*col+j];\n\t\t\t\t\t}\n\t\t\t\t\ttemp.push_back(sum);\n\t\t\t\t}\n\t\t\t\t\n\t\t\treturn Matrix(1,col,temp);\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n};\n",
            1590647092.120591,
            100,
            "# 答案正确"
        ],
        [
            "7.2 (C++)",
            "王锡铭",
            "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nvector<string> split(string line){\n vector<string> words;\n string delimiter = \" \";\n int st = 0;\n while (st < line.size()){\n  int end = line.find(delimiter, st);\n  if (end == st) st += 1;\n  else{\n   if (end == -1){\n    words.push_back(line.substr(st));\n    break;\n   }\n   words.push_back(line.substr(st, end - st));\n   st = end + 1;\n  }\n }\n return words;\n}",
            1591240702.1311285,
            100,
            "# 答案正确"
        ],
        [
            "7.1 (C++)",
            "王锡铭",
            "#include <cmath>\nusing namespace std;\n\nclass Triangle : public GeometricObject\n{\nprivate:\n\tdouble side1;\n\tdouble side2;\n\tdouble side3;\npublic:\n\tTriangle(){\n\t\tside1 = side2 = side3 = 1.0;\n\t}\n\tTriangle(double a, double b, double c){\n\t\tside1 = a;\n\t\tside2 = b;\n\t\tside3 = c;\n\t}\n\tdouble getSide1(){\n\t\treturn side1;\n\t}\n\tdouble getSide2(){\n\t\treturn side2;\n\t}\n\tdouble getSide3(){\n\t\treturn side3;\n\t}\n\tdouble getArea(){\n\t\tdouble s = (side1 + side2 + side3) / 2;\n\t\treturn sqrt(s * (s - side1) * (s - side2) * (s - side3));\n\t}\n\tdouble getPerimeter(){\n\t\treturn side1+side2+side3;\n\t}\n};",
            1591245944.632261,
            100,
            "# 答案正确"
        ],
        [
            "7.3 (C++)",
            "王锡铭",
            "template <typename A>\nvector<A> map2(const vector<A> & x, const vector<A> &y, A (*map_func)(const A &, const A &)){\n\tvector<A>res ;\n\tfor (int i = 0; i < x.size(); ++ i){\n\t\tres.push_back(map_func(x[i],y[i]));\n\t} \n\treturn res;\n}\ntemplate <typename A>\nvector<A> map2(const vector<A> & x, int y, A (*map_func)(const A &, const A &)){\n\tvector<A>res ;\n\tfor (int i = 0; i < x.size(); ++ i){\n\t\tres.push_back(map_func(x[i],y));\n\t} \n\treturn res;\n}",
            1591245961.8223126,
            100,
            "# 答案正确"
        ],
        [
            "8.5 (C++)",
            "王锡铭",
            "#include <cmath>\nclass Point3D: public Point2D\n{\nprivate:\n\tdouble z;\npublic:\n\tPoint3D(){\n\t\tsetX(0);\n\t\tsetY(0);\n\t\tz = 0;\n\t}\n\tPoint3D(double a, double b, double c){\n\t\tsetX(a);\n\t\tsetY(b);\n\t\tz = c;\n\t}\n\tdouble getZ(){\n\t\treturn z;\n\t}\n\tdouble distance(Point2D & point2){\n\t\tPoint3D & a = dynamic_cast<Point3D &> (point2);\n\t\tdouble dx, dy, dz;\n\t\tdx = getX() - a.getX();\n\t\tdy = getY() - a.getY();\n\t\tdz = this->z - a.getZ();\n\t\treturn sqrt(dx * dx + dy * dy + dz * dz);\n\t}\n};",
            1591844536.9815981,
            100,
            "# 答案正确"
        ],
        [
            "8.1 (C++)",
            "王锡铭",
            "#include<bits/stdc++.h>\nusing namespace std;\nclass Full: public Matrix\n{\nprivate:\n\tint rows;\n\tint column;\n\tdouble * values;\npublic:\n\tFull(int rows, int column){\n\t\tthis->rows = rows;\n\t\tthis->column = column;\n\t\tthis->values = new double[rows*column+1];\n\t\tfor(int i = 0; i < rows*column; ++i){\n\t\t\tthis->values[i] = 0;\n\t\t}\n\t}\n\tFull(int rows, int column, double values[]){\n\t\tthis->rows = rows;\n\t\tthis->column = column;\n\t\tthis->values = new double[rows*column+1];\n\t\tfor(int i = 0; i < rows*column; ++i){\n\t\t\tthis->values[i] = values[i];\n\t\t}\n\t}\n\tFull(const Matrix & matrix2){\n\t\tthis->rows = matrix2.size(1);\n\t\tthis->column = matrix2.size(2);\n\t\tthis->values = new double[rows*column+1];\n\t\tfor(int i = 0; i < rows; ++i){\n\t\t\tfor(int j = 0; j < column; ++j){\n\t\t\t\tthis->values[i*column+j] = matrix2.get(i,j);\n\t\t\t}\n\t\t}\n\t}\n\t~Full(){\n\t\tdelete []this->values;\n\t}\n\tint size(int dimension) const{\n\t\tif(dimension == 1)return rows;\n\t\telse return column;\n\t}\n\tvoid set(int row, int column, double value){\n\t\tthis->values[(row-1)*this->column + column-1] = value;\n\t}\n\tdouble get(int row, int column) const{\n\t\treturn this->values[row*this->column + column];\n\t}\n\tvoid print() {\n\t\tint count = 0;\n\t\tfor(int i = 0; i < rows; ++i){\n\t\t\tfor(int j = 0; j < column; ++j){\n\t\t\t\tcout << \"    \" <<values[count];\n\t\t\t\t++count;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tvoid print() const{\n\t\tint count = 0;\n\t\tfor(int i = 0; i < rows; ++i){\n\t\t\tfor(int j = 0; j < column; ++j){\n\t\t\t\tcout << \"    \" <<values[count];\n\t\t\t\t++count;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tMatrix & operator = (const Matrix & matrix2){\n\t\tif(this->values){\n\t\t\tdelete []values;\n\t\t}\n\t\tthis->rows = matrix2.size(1);\n\t\tthis->column = matrix2.size(2);\n\t\tthis->values = new double[rows*column+1];\n\t\tfor(int i = 0; i < rows; ++i){\n\t\t\tfor(int j = 0; j < column; ++j){\n\t\t\t\tthis->values[i*column+j] = matrix2.get(i,j);\n\t\t\t}\n\t\t}\n\t\treturn *this;\n\t}\n};",
            1591844582.0511181,
            100,
            "# 答案正确"
        ],
        [
            "8.3 (C++)",
            "王锡铭",
            "#include <iostream>\n#include<vector>\nusing namespace std;\n\nclass Sparse: public Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tvector<Entry> values;\npublic:\n\tSparse(int rows, int columns){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t}\n\tint size(int dimension) const{\n\t\tif(dimension == 1)return rows;\n\t\telse return columns;\n\t}\n\tvoid set(int row, int column, double value){\n\t\t\tEntry *a = new Entry;\t\n\t\t\ta[0].row = row;\n\t\t\ta[0].column = column;\n\t\t\ta[0].value = value;\n\t\t\tthis->values.push_back(a[0]);\n\t\t\tdelete a;\n\t\t\t\n\t\t//}\n\t}\n\tdouble get(int row, int column) const{\n\t\tint i = 0;\n\t\twhile(i < this->values.size()){\n\t\t\tif(values[i].row == row && values[i].column == column){\n\t\t\t\treturn values[i].value;\n\t\t\t}\n\t\t\t++i;\n\t\t}\n\t\treturn 0;\n\t}\n\tvoid print(){\n\t\tint i = 0;\n\t\twhile(i <  this->values.size()){\n\t\t\tfor(int j = i + 1; j < this->values.size(); ++j){\n\t\t\t\tif(values[i].row > values[j].row){\n\t\t\t\t\tswap(this->values[i],this->values[j]);\n\t\t\t\t}\n\t\t\t\telse if(values[i].row == values[j].row){\n\t\t\t\t\tif(values[i].column > values[j].column){\n\t\t\t\t\t\tswap(this->values[i],this->values[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t++i;\n\t\t}\n\t\ti = 0;\n\t\twhile(i < this->values.size() ){\n\t\t\tcout << \"(\" << values[i].row << \",\" << values[i].column << \",\" << values[i].value << \")\" << endl;\n\t\t\t++i;\n\t\t}\n\t}\n\tSparse & operator + (Sparse & sparse2){\n\t\tint len1 = this->values.size();\n\t\tint len2 = sparse2.values.size();\n\t\tint c = len1;\n\t\tfor(int i = 0; i < len2; ++i){\n\t\t\tint flag = 0;\n\t\t\tfor(int j = 0; j < len1; ++j){\n\t\t\t\tif(sparse2.values[i].row == this->values[j].row && sparse2.values[i].column == this->values[j].column){\n\t\t\t\t\tif(this->values[j].value + sparse2.values[i].value == 0){\n\t\t\t\t\t\tthis->values.erase(this->values.begin()+j);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tthis->values[j].value = this->values[j].value + sparse2.values[i].value;\n\t\t\t\t\t}\n\t\t\t\t\tflag = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag == 0){\n\t\t\t\tset(sparse2.values[i].row,sparse2.values[i].column,sparse2.values[i].value);\n\t\t\t}\n\t\t}\n\t\treturn *this;\n\t}\n};",
            1591844618.6649861,
            100,
            "# 答案正确"
        ],
        [
            "8.4 (C++)",
            "王锡铭",
            "#include <iostream>\n#include<vector>\nusing namespace std;\n\nclass Sparse: public Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tvector<Entry> values;\npublic:\n\tSparse(int rows, int columns){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t}\n\tint size(int dimension) const{\n\t\tif(dimension == 1)return rows;\n\t\telse return columns;\n\t}\n\tvoid set(int row, int column, double value){\n\t\t\tEntry *a = new Entry;\t\n\t\t\ta[0].row = row;\n\t\t\ta[0].column = column;\n\t\t\ta[0].value = value;\n\t\t\tthis->values.push_back(a[0]);\n\t\t\tdelete a;\n\t}\n\tdouble get(int row, int column) const{\n\t\tint i = 0;\n\t\twhile(i < this->values.size()){\n\t\t\tif(values[i].row == row && values[i].column == column){\n\t\t\t\treturn values[i].value;\n\t\t\t}\n\t\t\t++i;\n\t\t}\n\t\treturn 0;\n\t}\n\tint getp(int row, int column){\n\t\tint i = 0;\n\t\twhile(i < this->values.size()){\n\t\t\tif(values[i].row == row && values[i].column == column){\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\t++i;\n\t\t}\n\t\treturn -1;\n\t}\n\tvoid print(){\n\t\tint i = 0;\n\t\twhile(i <  this->values.size()){\n\t\t\tfor(int j = i + 1; j < this->values.size(); ++j){\n\t\t\t\tif(values[i].row > values[j].row){\n\t\t\t\t\tswap(this->values[i],this->values[j]);\n\t\t\t\t}\n\t\t\t\telse if(values[i].row == values[j].row){\n\t\t\t\t\tif(values[i].column > values[j].column){\n\t\t\t\t\t\tswap(this->values[i],this->values[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t++i;\n\t\t}\n\t\ti = 0;\n\t\twhile(i < this->values.size() ){\n\t\t\tcout << \"(\" << values[i].row << \",\" << values[i].column << \",\" << values[i].value << \")\" << endl;\n\t\t\t++i;\n\t\t}\n\t}\n\tSparse & operator * (Sparse & sparse2){\n\t\tvector<Entry> ans;\n\t\tint len1 = this->values.size();\n\t\tint len2 = sparse2.values.size();\n\t\tint i = 0;\n\t\tfor(int i = 0; i < len1; ++i){\n\t\t\tfor(int j = 0; j < len2; ++j){\n\t\t\t\tint f = this->values[i].row;\n\t\t\t\tint b = this->values[i].column;\n\t\t\t\tdouble c = this->values[i].value;\n\t\t\t\tif(b == sparse2.values[j].row){\n\t\t\t\t\tdouble sum = this->values[i].value * sparse2.values[j].value;\n\t\t\t\t\tint flag = 0;\n\t\t\t\t\tint k = 0;\n\t\t\t\t\twhile(k < ans.size()){\n\t\t\t\t\t\tif(ans[k].row == f && ans[k].column == sparse2.values[j].column){\n\t\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t++k;\n\t\t\t\t\t}\n\t\t\t\t\tif(flag == 1){\n\t\t\t\t\t\tans[k].value = ans[k].value + sum;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tEntry *a = new Entry;\t\n\t\t\t\t\t\ta[0].row = f;\n\t\t\t\t\t\ta[0].column = sparse2.values[j].column;\n\t\t\t\t\t\ta[0].value = sum;\n\t\t\t\t\t\tans.push_back(a[0]);\n\t\t\t\t\t\tdelete a;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tthis->values = ans;\n\t\treturn *this;\n\t}\n};",
            1591844636.2045014,
            100,
            "# 答案正确"
        ],
        [
            "8.6 (C++)",
            "王锡铭",
            "#include<vector>\n#include<iostream>\nusing namespace std;\nclass MyTensor : public Tensor<double>\n{\nprivate:\n    vector<double> cap;\n\npublic:\n    MyTensor(vector<int> indexes) : Tensor(indexes)\n    {\n        int num = 1;\n        for (int i = 0; i < indexes.size(); i++)\n        {\n            num *= indexes[i];\n        }\n        cap.resize(num);\n    }\n    ~MyTensor(){};\n    double &get(const vector<int> &indexes)\n    {\n        int pos = 0;\n        for (int i = 0; i < indexes.size(); i++)\n        {\n            if (i == indexes.size() - 1)\n            {\n                pos += indexes[i];\n                break;\n            }\n            int temp = indexes[i];\n            for (int j = i + 1; j < indexes.size(); j++)\n            {\n                temp *= sizes[j];\n            }\n            pos += temp;\n        }\n        return cap[pos];\n    }\n};",
            1592451250.763112,
            100,
            "# 答案正确"
        ],
        [
            "9.1 (C++)",
            "王锡铭",
            "class Circle{\npublic:\n\tCircle(double radius){\n\t\tthis->m_radius = radius;\n\t}\n\tint operator<(Circle &p){\n\t\tif(this->m_radius < p.m_radius){\n\t\t\treturn 1;\n\t\t}\n\t\telse{\n\t\t\treturn 0;\n\t\t}\n\t}\n\tint operator<=(Circle &p){\n\t\tif(this->m_radius < p.m_radius || this->m_radius == p.m_radius){\n\t\t\treturn 1;\n\t\t}\n\t\telse{\n\t\t\treturn 0;\n\t\t}\n\t}\n\tint operator==(Circle &p){\n\t\tif(this->m_radius == p.m_radius){\n\t\t\treturn 1;\n\t\t}\n\t\telse{\n\t\t\treturn 0;\n\t\t}\n\t}\n\tint operator!=(Circle &p){\n\t\tif(this->m_radius != p.m_radius){\n\t\t\treturn 1;\n\t\t}\n\t\telse{\n\t\t\treturn 0;\n\t\t}\n\t}\n\tint operator>(Circle &p){\n\t\tif(this->m_radius > p.m_radius){\n\t\t\treturn 1;\n\t\t}\n\t\telse{\n\t\t\treturn 0;\n\t\t}\n\t}\n\tint operator>=(Circle &p){\n\t\tif(this->m_radius > p.m_radius || this->m_radius == p.m_radius){\n\t\t\treturn 1;\n\t\t}\n\t\telse{\n\t\t\treturn 0;\n\t\t}\n\t}\nprivate:\n\tdouble m_radius;\n};",
            1592977950.3261027,
            100,
            "# 答案正确"
        ],
        [
            "9.3 (C++)",
            "王锡铭",
            "class Complex{\npublic:\n\tComplex(float real,float imag){\n\t\tthis->m_real = real;\n\t\tthis->m_imag = imag;\n\t}\n\tComplex operator*(const Complex &p){\n\t\tComplex temp(0,0);\n\t\ttemp.m_real = (this->m_real * p.m_real) - (this->m_imag * p.m_imag);\n\t\ttemp.m_imag = (this->m_real * p.m_imag) + (this->m_imag * p.m_real);\n\t\treturn temp;\n\t}\n\tComplex operator/(const Complex &p){\n\t\tfloat real = ((this->m_real * p.m_real) + (this->m_imag * p.m_imag)) / ((p.m_real * p.m_real) + (p.m_imag * p.m_imag));\n\t\tfloat imag = ((this->m_imag * p.m_real) - (this->m_real * p.m_imag)) / ((p.m_real * p.m_real) + (p.m_imag * p.m_imag));\n\t\tComplex temp(real,imag);\n\t\treturn temp;\n\t}\n\tComplex operator+=(const Complex &p){\n\t\tthis->m_real = this->m_real + p.m_real;\n\t\tthis->m_imag = this->m_imag + p.m_imag;\n\t}\n\tComplex operator-=(const Complex &p){\n\t\tthis->m_real = this->m_real - p.m_real;\n\t\tthis->m_imag = this->m_imag - p.m_imag;\n\t}\n\tComplex operator*=(const Complex &p){\n\t\tfloat real = (this->m_real * p.m_real) - (this->m_imag * p.m_imag);\n\t\tfloat imag = (this->m_real * p.m_imag) + (this->m_imag * p.m_real);\n\t\tthis->m_real = real;\n\t\tthis->m_imag = imag;\n\t\treturn *this;\n\t}\n\tComplex operator/=(const Complex &p){\n\t\tfloat real = ((this->m_real * p.m_real) + (this->m_imag * p.m_imag)) / ((p.m_real * p.m_real) + (p.m_imag * p.m_imag));\n\t\tfloat imag = ((this->m_imag * p.m_real) - (this->m_real * p.m_imag)) / ((p.m_real * p.m_real) + (p.m_imag * p.m_imag));\n\t\tthis->m_real = real;\n\t\tthis->m_imag = imag;\n\t\treturn *this;\t\n\t}\n\tfloat real(){\n\t\treturn this->m_real;\n\t}\n\tfloat imag(){\n\t\treturn this->m_imag;\n\t}\nprivate:\n\tfloat m_real;\n\tfloat m_imag;\n};\nComplex operator+(Complex &a,Complex &b){\n\tfloat real = a.real() + b.real();\n\tfloat imag = a.imag() + b.imag();\n\tComplex temp(real,imag);\n\treturn temp;\n}\nComplex operator+(int a,Complex &p){\n\tfloat real = p.real() + a;\n\tfloat imag = p.imag();\n\tComplex temp(real,imag);\n\treturn temp;\n}\nComplex operator-(Complex &a,Complex &b){\n\tfloat real = a.real() - b.real();\n\tfloat imag = a.imag() - b.imag();\n\tComplex temp(real,imag);\n\treturn temp;\n\t}\nComplex operator-(Complex &p,int a){\n\tfloat real = p.real() - a;\n\tfloat imag = p.imag();\n\tComplex temp(real,imag);\n\treturn temp;\n}\nint operator==(Complex &a,Complex &b){\n\tif(a.real() == b.real() && a.imag() == b.imag()){\n\t\treturn 1;\n\t}\n\telse{\n\t\treturn 0;\n\t}\n}\nint operator!=(Complex &a,Complex &b){\n\tif(a.real() != b.real() || a.imag() != b.imag()){\n\t\treturn 1;\n\t}\n\telse{\n\t\treturn 0;\n\t}\n}",
            1593066095.4961028,
            100,
            "# 答案正确"
        ],
        [
            "9.2 (C++)",
            "王锡铭",
            "class I{\nprivate:\n\tvector<int> x;\npublic:\n\tI(int a = -1, int b = -1, int c = -1, int d = -1){\n\t\tif(a != -1)x.push_back(a);\n\t\tif(b != -1)x.push_back(b);\n\t\tif(c != -1)x.push_back(c);\n\t\tif(d != -1)x.push_back(d);\n\t}\n\toperator vector<int>(){\n\t\treturn x;\n\t}\n};",
            1593059116.7861595,
            100,
            "# 答案正确"
        ],
        [
            "9.4 (C++)",
            "王锡铭",
            "class Complex{\nprivate:\n\tfloat rea;\n\tfloat ima;\npublic:\n\tComplex(){\n\t\tthis->rea = 0;\n\t\tthis->ima = 0;\n\t}\n\tvoid set(float a, float b){\n\t\trea = a;\n\t\tima = b;\n\t}\n\tfloat real(){\n\t\treturn this->rea;\n\t}\n\tfloat imag(){\n\t\treturn this->ima;\n\t}\n};\nComplex operator + (Complex a, Complex b){\n\tfloat re = a.real() + b.real();\n\tfloat im = a.imag() + b.imag();\n\tComplex c;\n\tc.set(re,im);\n\treturn c;\n}\nComplex operator - (Complex a, Complex b){\n\tfloat re = a.real() - b.real();\n\tfloat im = a.imag() - b.imag();\n\tComplex c;\n\tc.set(re,im);\n\treturn c;\n}\nistream & operator >>(istream & in, Complex & m){\n\tfloat a,b;\n\tin >> a >> b;\n\tm.set(a,b);\n\treturn in;\n}\nostream & operator <<(ostream & out, Complex & m){\n\tout << m.real()<<\" \" << \"+\" << \" \"<<m.imag() << \" \"<< \"i\" ;\n\treturn out;\n}",
            1593059132.8701427,
            100,
            "# 答案正确"
        ],
        [
            "9.5 (C++)",
            "王锡铭",
            "#include <iostream>\n\nusing namespace std;\n\nclass Complex\n{\n\tprivate:\n\t\tdouble real;\n\t\tdouble imag;\n\tpublic:\n\t\tfriend istream & operator >> (istream & in, Complex & c);\n\t\tfriend ostream & operator << (ostream & out,const Complex & c);\n\t\tComplex ()\n\t\t{ \n\t\t\tthis->real = 0;\n\t\t\tthis->imag = 0;\n\t\t}\n\t\tComplex(Complex & c)\n\t\t{\n\t\t\tthis->real = c.real;\n\t\t\tthis->imag = c.imag;\n\t\t}\n\t\toperator double() \n\t\t{\n\t\t\treturn this->real;\n\t\t}\n\t\tComplex operator ++ (int)\n\t\t{\n\t\t\tComplex c(*this);\n\t\t\t\n\t\t\tthis->real ++;\n\t\t\treturn c;\n\t\t}\n\t\tComplex & operator ++()\n\t\t{\n\t\t\tthis->real ++;\n\t\t\treturn (*this);\n\t\t}\n\t\t\n};\nistream & operator >> (istream & in, Complex & c)\n{\n\tin >> c.real >> c.imag;\n\treturn in;\n}\nostream & operator << (ostream & out,const Complex & c)\n{\n\tout << c.real << \" + \" << c.imag << \" i\" ;\n\treturn out;\n}\n",
            1593062071.5661724,
            100,
            "# 答案正确"
        ],
        [
            "9.6 (C++)",
            "王锡铭",
            "#include <iostream>\n\nusing namespace std;\n\nclass Tensor\n{\n\tprivate:\n\t\tint sizes[4];\n\t\tdouble * data;\n\t\tint num;\n\n\tpublic:\n\t\tTensor(int a, int b = -1, int c = -1, int d = -1)\n\t\t{\n\t\t\tint count = 1;\n\t\t\tint sum = a;\n\t\t\tthis->sizes[0] = a;\n\t\t\tif(b!= -1)\n\t\t\t{\n\t\t\t\tcount ++;\n\t\t\t\tthis->sizes[1] = b;\n\t\t\t\tsum *= b;\n\t\t\t}\n\t\t\tif(c != -1)\n\t\t\t{\n\t\t\t\tcount ++;\n\t\t\t\tthis->sizes[2] = c;\n\t\t\t\tsum *= c;\n\t\t\t}\n\t\t\tif(d!=-1)\n\t\t\t{\n\t\t\t\tcount ++;\n\t\t\t\tthis->sizes[3] = d;\n\t\t\t\tsum *= d;\n\t\t\t}\n\t\t\tthis->num = count;\n\t\t\tdata = new double[sum];\n\t\t}\n\t\t~Tensor()\n\t\t{\n\t\t\tdelete[] data;\n\t\t}\n\t\tdouble & operator() (int a, int b = -1, int c = -1, int d =- 1)\n\t\t{\n\t\t\tint index = a;\n\t\t\tif(b != -1)\n\t\t\t{\n\t\t\t\tindex += b * this->sizes[0];\n\t\t\t}\n\t\t\tif(c != -1)\n\t\t\t{\n\t\t\t\tindex += c * this->sizes[0] * this->sizes[1];\n\t\t\t}if(d != -1)\n\t\t\t{\n\t\t\t\tindex += d * this->sizes[0] * this->sizes[1] * this->sizes[2];\n\t\t\t}\n\t\t\treturn data[index];\n\t\t}\n};\n",
            1593062086.5145125,
            100,
            "# 答案正确"
        ],
        [
            "9.7 (C++)",
            "王锡铭",
            "#include <iostream>\n\nusing namespace std;\n\nclass Tensor\n{\n\tprivate:\n\t\tint num;\n\t\tint size[4];\n\t\tdouble * value;\n\tpublic:\n\t\tfriend istream & operator>>(istream & in, Tensor & tensor);\n    \tfriend ostream & operator<<(ostream & out, Tensor & tensor);\n\t\tTensor() {}\n\t\t~Tensor()\n\t\t{\n\t\t\tdelete[] value;\n\t\t}\n};\nistream & operator >> (istream & in, Tensor & tensor)\n{\n\tin >> tensor.num;\n\tint sum = 1;\n\tfor (int i = 0; i < tensor.num; i ++)\n\t{\n\t\tin >> tensor.size[i];\n\t\tsum *= tensor.size[i];\n\t}\n\ttensor.value = new double[sum + 1];\n\tfor (int i = 0; i < sum; i ++) in >> tensor.value[i];\n\treturn in;\n}\nostream & operator << (ostream & out, Tensor & tensor)\n{\n\tout << tensor.num;\n\tint sum = 1;\n\tout << endl;\n\tfor (int i = 0; i < tensor.num; i ++)\n\t{\n\t\tout << tensor.size[i] << \" \";\n\t\tsum *= tensor.size[i];\n\t}\n\tout << endl << endl;\n\tswitch (tensor.num)\n\t{\n\t\tcase 2:\n\t\t\tfor (int a = 0; a < tensor.size[0]; a++)\n\t\t\t{\n\t\t\t\tfor (int b = 0; b < tensor.size[1]; b++)\n\t\t\t\t{\n\t\t\t\t\tout << tensor.value[a * tensor.size[2] + b] << \" \";\n\t\t\t\t}\n\t\t\t\tout << endl;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tfor (int a = 0; a < tensor.size[0]; a++)\n\t\t\t{\n\t\t\t\tfor (int b = 0; b < tensor.size[1]; b++)\n\t\t\t\t{\n\t\t\t\t\tfor (int c = 0; c < tensor.size[2]; c++)\n\t\t\t\t\t{\n\t\t\t\t\t\tout << tensor.value[a * tensor.size[2] * tensor.size[1] + b * tensor.size[0] + c] << \" \";\n\t\t\t\t\t}\n\t\t\t\t\tout << endl;\n\t\t\t\t}\n\t\t\t\tout << endl;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tfor (int a = 0; a < tensor.size[0]; a++)\n\t\t\t{\n\t\t\t\tfor (int b = 0; b < tensor.size[1]; b++)\n\t\t\t\t{\n\t\t\t\t\tfor (int c = 0; c < tensor.size[2]; c++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int d = 0; d < tensor.size[3]; d++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tout << tensor.value[a * tensor.size[3] * tensor.size[2] * tensor.size[1] + b * tensor.size[3] * tensor.size[2] + c * tensor.size[3] + d] << \" \";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tout << endl;\n\t\t\t\t\t}\n\t\t\t\t\tout << endl;\n\t\t\t\t}\n\t\t\t\n\t\t\t}\n\t\t\tout << endl;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\treturn out;\n}\n",
            1593062152.1719942,
            0,
            "=================================================================\n==12252==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x611000009fc8 at pc 0x5582ae81bf48 bp 0x7ffeafaefa10 sp 0x7ffeafaefa00\nREAD of size 8 at 0x611000009fc8 thread T0\n    #0 0x5582ae81bf47 in operator<<(std::ostream&, Tensor&) /home/王锡铭/source.cpp:63\n    #1 0x5582ae81c8a6 in main /home/王锡铭/main.cpp:12\n    #2 0x7f73cd10482f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2082f)\n    #3 0x5582ae81b3b8 in _start (/home/王锡铭/main.out+0x13b8)\n\n0x611000009fc8 is located 0 bytes to the right of 200-byte region [0x611000009f00,0x611000009fc8)\nallocated by thread T0 here:\n    #0 0x7f73cdadf6b2 in operator new[](unsigned long) (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x996b2)\n    #1 0x5582ae81b5a5 in operator>>(std::istream&, Tensor&) /home/王锡铭/source.cpp:29\n    #2 0x5582ae81c893 in main /home/王锡铭/main.cpp:11\n    #3 0x7f73cd10482f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2082f)\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /home/王锡铭/source.cpp:63 operator<<(std::ostream&, Tensor&)\nShadow bytes around the buggy address:\n  0x0c227fff93a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c227fff93b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c227fff93c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c227fff93d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c227fff93e0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n=>0x0c227fff93f0: 00 00 00 00 00 00 00 00 00[fa]fa fa fa fa fa fa\n  0x0c227fff9400: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c227fff9410: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c227fff9420: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c227fff9430: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c227fff9440: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Heap right redzone:      fb\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack partial redzone:   f4\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n==12252==ABORTING\n"
        ],
        [
            "10.1 (C++)",
            "王锡铭",
            "#include<stdexcept>\nclass MatrixSizesDoNotMatchException{};\ndouble Matrix::get(int row, int column)const{\n\treturn elements[(row-1) * size(2)+column-1];\n}\nvoid Matrix::set(int row, int column, double value){\n\telements[(row-1) * size(2)+column-1] = value;\n}\nMatrix Matrix::operator + (const Matrix & matrix2)const{\n\tif(this->size(1) != matrix2.size(1) || this->size(2) != matrix2.size(2)){\n\t\tthrow MatrixSizesDoNotMatchException();\n\t}\n\tMatrix ans(matrix2.size(1),matrix2.size(2));\n\tfor (int i = 0; i < rows * columns;  ++ i) {\n\t\t\tans.elements[i] = this->elements[i] + matrix2.elements[i];\n\t}\n\treturn ans;\n}",
            1593654875.3371038,
            100,
            "# 答案正确"
        ],
        [
            "10.2 (C++)",
            "王锡铭",
            "catch(NonPositiveValueException & er){\n\tcout << \"caught: NonPositiveValueException\" << endl;\n}\ncatch(std::out_of_range & er){\n\tcout << \"caught: out_of_range\"<<endl;\n}",
            1593658018.3099966,
            100,
            "# 答案正确"
        ],
        [
            "2020-07-09 LAB",
            "王锡铭",
            "#include<iostream>\n#include<vector>\nusing namespace std;\n\nclass Integer{\nprivate:\n    int num;\n    static vector<Integer*> index;\npublic:\n    Integer(): num(0){\n        index.push_back(this);\n    }\n    Integer(int x): num(x){\n        index.push_back(this);\n    }\n    void change_value(const int& x){num = x;}\n    int get_value()const{return num;}\n    static void increase_all(const Integer& x){\n        for(int i = 0;i < index.size();i++){\n            index[i]->change_value(index[i]->get_value()+x.get_value());\n        }\n    }\n};\nvector<Integer*> Integer::index = vector<Integer*>();\n\nistream& operator >> (istream& in,Integer& x){\n    int num;\n    in >> num;\n    x.change_value(num);\n    return in;\n}\nostream& operator << (ostream& out,Integer& x){\n    out << x.get_value();\n    return out;\n}",
            1594265159.1241589,
            100,
            "# 答案正确"
        ],
        [
            "15.1 (C++)",
            "王锡铭",
            "#include <string>\n#include <vector>\nusing namespace std;\nstring tostr(vector<string> value){\n \tstring tmp;\n \tstring result;\n \tresult.push_back('\\t');\n \tresult.push_back('\\t');\n \tresult.push_back('[');\n for (int i = 0; i < value.size(); i++){\n  \ttmp = value[i];\n  \tresult.push_back('\\'');\n  \tfor (int j = 0; j < tmp.size(); j++)\n  \t\t result.push_back(tmp[j]);\n  \t\tresult.push_back('\\'');\n  \t\tresult.push_back(',');\n }\n \tresult.insert(result.size(), \"],\\n\");\n \treturn result;\n}\n\nclass Table{\n \n \tvector<string> head;\n\t vector<vector<string>> value;\n\n\tpublic:\n \tvoid addCol(string str){\n  \thead.push_back(str);\n };\n Table(){\n  \thead.resize(0);\n  \tvalue.resize(0);\n }\n string json()const{\n  \tstring result;\n  \tresult = \"{\\n\\theaders: [\";\n  \tstring tmp;\n for (int i = 0; i < head.size();i++){\n  \t tmp = head[i];\n   \tresult.push_back('\\'');\n   \tfor (int j = 0; j < tmp.size();j++)\n    \tresult.push_back(tmp[j]);\n  \t\t result.push_back('\\'');\n   \n   result.push_back(',');\n  }\n  result.insert(result.size(), \"],\\n\\trows: [\\n\");\n  for (int i = 0; i < value.size();i++)\n   result.insert(result.size(), tostr(value[i]));\n\n  result.insert(result.size(), \"\\t],\\n}\");\n\n  return result;\n }\n vector<string> & operator[](int index)\n {\n  \n  if(index < value.size())\n  {\n   \n  }\n  else\n  {\n   value.resize(index+1); \n  }\n  return value[index];\n }\n};",
            1594295553.126199,
            100,
            "# 答案正确"
        ],
        [
            "A.2 (C++)",
            "王锡铭",
            "template <typename E>\nvoid LinkedList<E>:: removeAll(const E & e){\n  if(contains( e)==false) return;\n  removeFirstOccurrence(e);\n  removeAll(e);\n}",
            1594869234.022243,
            100,
            "# 答案正确"
        ],
        [
            "A.1 (C++)",
            "王锡铭",
            "LinkedList(const LinkedList &o) : _size(0), head(0), tail(0)\n{\n\taddAll(o);\n}\nLinkedList & operator= (const LinkedList & o)\n{\n\tclear();\n\taddAll(o);\n}\n~LinkedList()\n{\n\tclear();\n}\nvoid clear()\n{\n\twhile(_size > 0) removeFirst();\n}\nvoid addAll(const LinkedList & o)\n{\n\tNode<E> *temp = o.head;\n\tNode<E> *prev = 0;\n\tNode<E> *next = temp->next_node(prev);\n\tfor (int i = 0; i < o._size-1;i++)\n\t{\n\t\tadd( i, temp->element);\n\t\tprev = temp;\n\t\ttemp = next;\n\t\tnext = next->next_node(prev);\n\t}\n\tadd(o._size, temp->element);\n}\nvoid print(const LinkedList &o)\n{\n\tNode<E> *temp = o.head;\n\tNode<E> *prev = 0;\n\tNode<E> *next = temp->next_node(prev);\n\tfor (int i = 0; i < o._size-1;i++)\n\t{\n\t\tcout << temp->element << \" \";\n\t\tprev = temp;\n\t\ttemp = next;\n\t\tnext = next->next_node(prev);\n\t}\n\tcout <<temp->element<< endl;\n}\nvoid add(int index,const E o)\n{\n\tNode<E> *node = new Node<E>();\n\tnode->element = o;\n\tif(this->head == 0)\n\t{\n\t\tthis->head = node;\n\t\tthis->tail = this->head;\n\t}\n\telse if(index==0 && this->head != 0)\n\t{\n\t\thead->update_prev_node(0, node);\n\t\tnode->update_next_node(0, head);\n\t\thead = node;\n\t}\n\telse if(index=this->_size)\n\t{\n\t\tNode<E> *temp = this->tail;\n\t\tNode<E> *next = 0;\n\t\tnext = node;\n\t\tnode->update_prev_node(0, temp);\n\t\ttemp->update_next_node(0, next);\n\t\ttail = node;\n\t}\n\t++_size;\n}\nvoid remove(int index)\n{\n\tif(index==0)\n\t{\n\t\tNode<E> *temp = this->head;\n\t\tNode<E> *next = temp->next_node(0);\n\t\tNode<E> *prev = 0;\n\t\tif(next!=0)\n\t\t{\n\t\t\tnext->update_prev_node(head,0);\n\t\t}\n\t\thead = next;\n\t\tdelete temp;\n\t}\n\telse\n\t{\n\t\tNode<E> *temp = this->tail;\n\t\tNode<E> *prev = temp->prev_node(0);\n\t\tthis->tail = prev;\n\t\tprev->update_next_node(temp, 0);\n\t\tdelete temp;\n\t}\n\tthis->_size--;\n}\nvoid addFirst(E val)\n{\n\tadd(0, val);\n}\nvoid addLast(E val)\n{\n\tadd(_size, val);\n}\nvoid removeFirstOccurrence(int val)\n{\n\tNode<E> *temp = this->head;\n\tNode<E> *next = temp->next_node(0);\n\tNode<E> *prev = 0;\n\tif(this->tail->element == val)\n\t{\n\t\tremoveLast();\n\t\treturn;\n\t}\n\telse if(this->head->element==val)\n\t{\n\t\tremoveFirst();\n\t\treturn;\n\t}\n\tfor (int i = 0; i < this->_size-1;i++)\n\t{\n\t\tprev = temp, temp = next;\n\t\tnext = temp->next_node(prev);\n\t\tif (temp->element == val) break;\n\t}\n\tprev->update_next_node(temp, next);\n\tnext->update_prev_node(temp, prev);\n\tdelete temp;\n\tthis->_size--;\n}\nint get(int index)\n{\n\tNode<E> *temp = this->head;\n\tNode<E> *prev = 0;\n\tNode<E> *next = temp->next_node(prev);\n\tif(index==this->_size-1) return this->tail->element;\n\telse if(index==0)\n\t{\n\t\treturn temp->element;\n\t}\n\treturn temp->element;\n}\nvoid removeLast()\n{\n\tremove(this->_size);\n}\nvoid removeFirst()\n{\n\tremove(0);\n}\n",
            1594869402.5612435,
            100,
            "# 答案正确"
        ],
        [
            "A.3 (C++)",
            "王锡铭",
            "#include <vector>\nusing namespace std;\n\ntemplate <typename E>\nclass Tuple\n{\npublic:\n int key;\n E val;\n bool in_use;\n Tuple()\n {\n  in_use = false;\n }\n};\n\ntemplate <typename E>\nclass HT\n{\nprivate:\n vector<Tuple<E>> tuples;\n int _size;\n\npublic:\n HT()\n {\n  tuples.resize(4000);\n  _size = 0;\n }\n int hashfunction(int key)\n {\n  int hashcode = 0;\n  while (key)\n  {\n   hashcode = (hashcode << 5) + (key % 10);\n   key /= 10;\n  }\n  return hashcode % tuples.size();\n }\n int indexofkey(int key)\n {\n  int index = hashfunction(key);\n  while (true)\n  {\n   if (tuples[index].in_use == false)\n    return index;\n   if (tuples[index].key == key)\n    return index;\n   index = (index + 1) % tuples.size();\n  }\n }\n void put(int key, E val)\n {\n  int index = indexofkey(key);\n  tuples[index].val = val;\n  tuples[index].key = key;\n  if (tuples[index].in_use == false)\n  {\n   tuples[index].in_use = true;\n   _size++;\n  }\n }\n int size()\n {\n  return _size;\n }\n bool containsKey(int key)\n {\n  int index = indexofkey(key);\n  return tuples[index].in_use == true;\n }\n E operator[](int key)\n {\n  int index = indexofkey(key);\n  return tuples[index].val;\n }\n vector<int> getKeys()\n {\n  vector<int> ans;\n  for (int i = 0; i < tuples.size(); i++)\n  {\n   if (tuples[i].in_use)\n   {\n    ans.push_back(tuples[i].key);\n   }\n  }\n  return ans;\n }\n void remove(int key)\n {\n  int index = indexofkey(key);\n  tuples[index].in_use = false;\n  _size--;\n }\n};",
            1595473855.714073,
            100,
            "# 答案正确"
        ],
        [
            "A.4 (C++)",
            "王锡铭",
            "#include <iostream>\n#include <sstream>\n#include <string>\nusing namespace std;\nclass Tuple\n{\n\tpublic:\n\t\tint key;\n\t\tint value;\n\t\tTuple() {}\n\t\tTuple(int key, int value)\n\t\t{\n\t\t\tthis->key = key;\n\t\t\tthis->value = value;\n\t\t}\n\t\toperator int()\n\t\t{\n\t\t\treturn this->value;\n\t\t}\n\t\toperator string()\n\t\t{\n\t\t\tstring result;\n\t\t\tstringstream s_s;\n\t\t\ts_s << this->value;\n\t\t\ts_s >> result;\n\t\t\treturn result;\n\t\t}\n};\nclass HT\n{\n\tprivate:\n\t\tTuple dict[10];\n\t\tint _size;\n\tpublic:\n\t\tHT(): _size(0) {}\n\t\t~HT(){}\n\t\ttemplate<typename K,typename V>\n\t\tvoid put(K key,V value)\n\t\t{\n\t\t\tint k;\n\t\t\tint val;\n\t\t\tk = str_to_int(key);\n\t\t\tval = str_to_int(value);\n\t\t\tTuple ling(k, val);\n\t\t\tdict[this->_size] = ling;\n\t\t\tthis->_size ++;\n\t\t}\n\t\tint size()\n\t\t{\n\t\t\treturn this->_size;\n\t\t}\n\t\tint str_to_int(int str)\n\t\t{\n\t\t\treturn str;\n\t\t}\n\t\tint str_to_int(string str)\n\t\t{\n\t\t\tstringstream s_s;\n\t\t\ts_s << str;\n\t\t\tint res;\n\t\t\ts_s >> res;\n\t\t\treturn res;\n\t\t}\n\t\tstring int_to_str(string v)\n\t\t{\n\t\t\treturn v;\n\t\t}\n\t\tstring int_to_str(int v)\n\t\t{\n\t\t\tstring result;\n\t\t\tstringstream s_s;\n\t\t\ts_s << v;\n\t\t\ts_s >> result;\n\t\t\treturn result;\n\t\t}\n\t\ttemplate < typename V>\n\t\tTuple operator[](const V &index)\n\t\t{\n\t\t\tint ling;\n\t\t\tling = str_to_int(index);\n\t\t\tfor (int i = 0; i <= 10;i++)\n\t\t\t{\n\t\t\t\tif(dict[i].key == ling)\n\t\t\t\t{\n\t\t\t\t\treturn dict[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n};",
            1595851494.2901256,
            100,
            "# 答案正确"
        ],
        [
            "A.5 (C++)",
            "王锡铭",
            "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <map> \n#include <algorithm>\nusing namespace std;\nint total = 0;\nclass V {\npublic:\n string s;\n int i;\n V(int _i) :i(_i) {\n }\n V(string _s) :s(_s) {\n }\n operator string() {\n  return s;\n }\n operator int() {\n  return i;\n }\n V& operator=(int val){\n   i=val;\n   return *this;\n }\n V& operator=(string val){\n  s=val;\n  return *this;\n }\n};\n\nclass HT {\n class Tuple1 {\n public:\n  int key;\n  V value;\n  Tuple1(int _key, int _value) :key(_key), value(_value) { total++; };\n  Tuple1(int _key, string _value) :key(_key), value(_value) { total++; };\n };\n class Tuple2 {\n public:\n  string key;\n  V value;\n  Tuple2(string _key, string _value) :key(_key), value(_value) { total++; };\n  Tuple2(string _key, int _value) :key(_key), value(_value) { total++; };\n  void operator=(int val){\n   value=val;\n  }\n  void operator=(string val){\n   value=val;\n  }\n };\n vector<Tuple1>t1;\n vector<Tuple2>t2;\n\npublic:\n int size() { return total; }\n void put(int _key, int _value) {\n  t1.push_back(Tuple1(_key, _value));\n }\n void put(int _key, string _value) {\n  t1.push_back(Tuple1(_key, _value));\n }\n void put(string _key, int _value) {\n  t2.push_back(Tuple2(_key, _value));\n }\n void put(string _key, string _value) {\n  t2.push_back(Tuple2(_key, _value));\n }\n V& operator [] (const int& key) {\n  for (int i = 0; i < t1.size(); ++i) {\n   if (t1[i].key == key) return t1[i].value;\n  }\n  put(key,5);\n  for (int i = 0; i < t1.size(); ++i) {\n   if (t1[i].key == key) {\n    return t1[i].value;\n   }\n  }\n }\n V& operator [] (const string& key) {\n  for (int i = 0; i < t2.size(); ++i) {\n   if (t2[i].key == key) return t2[i].value;\n  }\n  put(key,5);\n  for (int i = 0; i < t2.size(); ++i) {\n   if (t2[i].key == key) {\n    return t2[i].value;\n   }\n  }\n }\n\n};",
            1596183099.0203245,
            100,
            "# 答案正确"
        ]
    ],
    "table_name": "答案"
}