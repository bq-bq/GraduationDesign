{
    "__update_time__": 1595837847.7948847,
    "field_names": [
        "题目名",
        "用户名",
        "答案",
        "提交时间",
        "分数",
        "评语"
    ],
    "field_types": [
        "text",
        "text",
        "text",
        "time",
        "number",
        "text"
    ],
    "foreign_keys": {},
    "primary_keys": [],
    "rows": [
        [
            "测试1",
            "肖翎予",
            "#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n\tint judge = 0, n = 0;\n\tchar str[1000], s[40][25] = {0},c;\n\tint i,j;\n\tcin.get(str,1000);\n\tfor(i = 0; (c = str[i]) != '\\0'; i++) {\n\t\tif(c == ' ') judge = 0;\n\t\telse {\n\t\t\t if(judge == 0) {\n\t\t\t\tj = 0;\n\t\t\t\tn++;\n\t\t\t\tjudge = 1;\n\t\t\t }\n\t\t\t s[n][j] = c;\n\t\t\t j++;\n\t\t}\n\t}\n\tfor(i = n; i > 0; i--) {\n\t\tcout << s[i] << \" \";\n\t}\n}\n",
            1587609240.2627769,
            100,
            "# 答案正确"
        ],
        [
            "测试2",
            "肖翎予",
            "#include <iostream>\n#include <string>\n#include <cstring>\nusing namespace std;\n\nint main() {\n\tint judge = 0, n = 0;\n\tchar str[1000], s[40][25] = {0},temp[25],c;\n\tint i,j;\n\tcin.get(str,1000);\n\tfor(i = 0; (c = str[i]) != '\\0'; i++) {\n\t\tif(c == ' ') judge = 0;\n\t\telse {\n\t\t\t if(judge == 0) {\n\t\t\t\tj = 0;\n\t\t\t\tn++;\n\t\t\t\tjudge = 1;\n\t\t\t }\n\t\t\t s[n][j] = c;\n\t\t\t j++;\n\t\t}\n\t}\n\tfor(i = 1; i < n + 1; i++) {\n\t    for(j = 2; j < n - i + 1; j++) {\n\t\t\tif(strcmp(s[j],s[j - 1]) < 1) {\n\t\t\t   strcpy(temp, s[j - 1]);\n\t\t\t   strcpy(s[j - 1], s[j]);\n\t\t\t   strcpy(s[j], temp);\n\t\t\t}\n\t\t}\n\t}\n\tfor(i = 1; i < n + 1; i++) {\n\t\tcout << s[i] << \" \";\n\t}\n}",
            1587612447.5154932,
            100,
            "# 答案正确"
        ],
        [
            "1.1 (C++)",
            "肖翎予",
            "class Matrix5x5{\npublic:\n\tdouble ans[5][5];\n    Matrix5x5(){\n        for(int i = 0;i < 5;i++){\n            for(int j = 0;j < 5;j++){\n                ans[i][j] = 0;\n            }\n        }\n    }\n\tdouble get(int i, int j){\n        return ans[i][j];\n    }\n    void set(int i, int j, double num){\n        ans[i][j] = num;\n    }\n    friend Matrix5x5 operator + (Matrix5x5& m1,Matrix5x5& m2){\n        Matrix5x5 ans;\n        for(int i = 0;i < 5;i++){\n            for(int j = 0;j < 5;j++){\n                ans.set(i,j,m1.get(i,j) + m2.get(i,j)); \n            }\n        }\n        return ans;\n    } \n};",
            1587887587.1853147,
            100,
            "# 答案正确"
        ],
        [
            "1.2 (C++)",
            "肖翎予",
            "class School {\npublic:\t\n\tint age = 0;\n\tchar name[10] = \"NO_NAME\";\n\tvoid setName(char Name[]) {\n\t\tfor(int i = 0; i < 10; i++) {\n\t\t\tif(Name[i] == 0) name[i] = 0;\n\t\t\telse name[i] = Name[i];\t\t\t\n\t\t}\n\t}\n\tvoid setAge(int year) {\n\t\tage = year;\n\t}\t\n\tvoid operator ++ () {\n\t\tage++;\n\t}\n};",
            1588215022.775639,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/08",
            "肖翎予",
            "double & Tensor_get(int dimensions, const int sizes[], double data[], int x0, int x1, int x2, int x3){\n    int sum[4] = {1,1,1,1};\n    for(int i = 0; i < dimensions; i++){\n        for(int j = i + 1; j < dimensions; j++){\n            sum[i] *= sizes[j];\n        }\n    }\n    int cnt = 0;\n    int di[4] = {x0,x1,x2,x3};\n    for(int i = 0; i < dimensions; i++){\n        cnt += di[i] * sum[i];\n    }\n    return data[cnt];\n}",
            1588908816.5379272,
            100,
            "# 答案正确"
        ],
        [
            "2.1 (C++)",
            "肖翎予",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix {\nprivate:\n\tint row;\n\tint col;\npublic:\n\tMatrix(){\n\t\trow = 0;\n\t\tcol = 0;\n\t}\n\tMatrix(int inrow,int incol) {\n\t\trow = inrow;\n\t\tcol = incol;\n\t}\n\tvoid print() {\n\t\tfor(int i = 0; i < this->row; i++) {\n\t\t\tfor(int k = 0 ; k < this->col; k++) {\n\t\t\t\tcout << \"    0\";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\t~Matrix(){}\n};\n",
            1589419011.7404695,
            100,
            "# 答案正确"
        ],
        [
            "2.2 (C++)",
            "肖翎予",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix {\nprivate:\n\tint rows;\n\tint cols;\n\tdouble values[1000];\npublic:\n\tMatrix() {\n\t\trows = 0;\n\t\tcols = 0;\n\t\tvalues[0] = 0;\n\t}\n\tMatrix(int inrows, int incols, double invalues[]) {\n\t\trows = inrows;\n\t\tcols = incols;\n\t\tfor(int i = 0 ; i < this->rows; i++) {\n\t\t\tfor(int k = 0 ; k < this->cols; k++) {\n\t\t\t\tvalues[i * cols + k] = invalues[i * cols + k];\n\t\t\t}\n\t\t}\n\t}\n\tvoid print() {\n\t\tfor(int i = 0; i < this->rows; i++) {\n\t\t\tfor(int k = 0; k < this->cols; k++) {\n\t\t\t\tif(values[i * cols + k] < 10) cout << \"    \"<<values[i * cols + k];\n\t\t\t\telse cout << \"   \"<<values[i * cols + k];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\t~Matrix(){}\n};",
            1589419665.9560964,
            100,
            "# 答案正确"
        ],
        [
            "2.3 (C++)",
            "肖翎予",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix{\nprivate:\n\tint rows;\n\tint cols;\n\tdouble values[1000];\n\tpublic:\n\tMatrix() {\n\t\trows = 0;\n\t\tcols = 0;\n\t\tvalues[0] = 0;\n\t}\n\tMatrix(int inrows, int incols, double invalues[]) {\n\t\trows = inrows;\n\t\tcols = incols;\n\t\tfor(int i = 0 ; i < this->rows; i++) {\n\t\t\tfor(int k = 0 ; k < this->cols; k++) {\n\t\t\t\tvalues[i * cols + k] = invalues[i * cols + k];\n\t\t\t}\n\t\t}\n\t}\n\tMatrix(const Matrix &matrix2) {\n\t\tthis->rows = matrix2.rows;\n\t\tthis->cols = matrix2.cols;\n\t\tfor(int i = 0; i < this->rows; i++) {\n\t\t\tfor(int k = 0; k < this->cols; k++) {\n\t\t\t\tthis->values[i * cols + k] = matrix2.values[i * cols + k];\n\t\t\t}\n\t\t}\n\t}\n\tvoid print() {\n\t\tfor(int i = 0; i < this->rows; i++) {\n\t\t\tfor(int k = 0; k < this->cols; k++) {\n\t\t\t\tcout<< \"    \"<<values[i * cols + k];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\t~Matrix(){}\n};\n\n\n",
            1589421069.9523838,
            100,
            "# 答案正确"
        ],
        [
            "2.5 (C++)",
            "肖翎予",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix{\nprivate:\n\tint rows;\n\tint cols;\n\tdouble values[100][100];\npublic:\n\tMatrix() {\n\t\trows = 0;\n\t\tcols = 0;\n\t\tvalues[0][0] = 0;\n\t}\n\tMatrix(int inrows,int incols) {\n\t\trows = inrows;\n\t\tcols = incols;\n\t\tfor(int i = 0; i < this->rows; i++) {\n\t\t\tfor(int k = 0; k < this->cols; k++) {\n\t\t\t\tvalues[k][i] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tMatrix(int inrows, int incols, double invalues[]) {\n\t\trows = inrows;\n\t\tcols = incols;\n\t\tfor(int i = 0 ; i < this->rows; i++) {\n\t\t\tfor(int k = 0 ; k < this->cols; k++) {\n\t\t\t\tvalues[k][i] = invalues[i * cols + k];\n\t\t\t}\n\t\t}\n\t}\n\tMatrix(const Matrix &matrix2) {\n\t\tthis->rows = matrix2.rows;\n\t\tthis->cols = matrix2.cols;\n\t\tfor(int i = 0; i < this->rows; i++) {\n\t\t\tfor(int k = 0; k < this->cols; k++) {\n\t\t\t\tthis->values[k][i] = matrix2.values[k][i];\n\t\t\t}\n\t\t}\n\t}\n\tMatrix getRow(int rows) {\n\t\tMatrix matrix3(1,this->cols);\n\t\tfor(int i = 0; i < this->cols; i++) {\n\t\t\tmatrix3.values[i][0] = values[i][rows - 1];\n\t\t}\n\t\treturn matrix3;\n\t}\n\tMatrix getColumn(int cols) {\n\t\tMatrix matrix4(this->rows,1);\n\t\tfor(int i = 0; i < this->rows; i++) {\n\t\t\tmatrix4.values[0][i] = values[cols - 1][i];\n\t\t}\n\t\treturn matrix4;\n\t}\n\tvoid print() {\n\t\tfor(int i = 0; i < this->rows; i++) {\n\t\t\tfor(int k = 0; k < this->cols; k++) {\n\t\t\t\tcout<< \"    \" << values[k][i];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\t~Matrix(){}\n};",
            1589422118.1033866,
            100,
            "# 答案正确"
        ],
        [
            "2.6 (C++)",
            "肖翎予",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix{\nprivate:\n\tint rows;\n\tint cols;\n\tdouble values[100][100];\npublic:\n\tMatrix() {\n\t\trows = 0;\n\t\tcols = 0;\n\t\tvalues[0][0] = 0;\n\t}\n\tMatrix(int inrows,int incols) {\n\t\trows = inrows;\n\t\tcols = incols;\n\t\tfor(int i = 0; i < this->rows; i++) {\n\t\t\tfor(int k = 0; k < this->cols; k++) {\n\t\t\t\tvalues[k][i] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tMatrix(int inrows, int incols, double invalues[]) {\n\t\trows = inrows;\n\t\tcols = incols;\n\t\tfor(int i = 0 ; i < this->rows; i++) {\n\t\t\tfor(int k = 0 ; k < this->cols; k++) {\n\t\t\t\tvalues[k][i] = invalues[i * cols + k];\n\t\t\t}\n\t\t}\n\t}\n\tMatrix(const Matrix &matrix2) {\n\t\tthis->rows = matrix2.rows;\n\t\tthis->cols = matrix2.cols;\n\t\tfor(int i = 0; i < this->rows; i++) {\n\t\t\tfor(int k = 0; k < this->cols; k++) {\n\t\t\t\tthis->values[k][i] = matrix2.values[k][i];\n\t\t\t}\n\t\t}\n\t}\n\tMatrix concatenateRows(const Matrix & matrix2) {\n\t\tMatrix matrix3(rows * 2,cols);\n\t\tfor(int i = 0; i < rows; i++) {\n\t\t\tfor(int k = 0; k < cols; k++) {\n\t\t\t\tmatrix3.values[k][i] = this->values[k][i];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i < rows ; i++ ) {\n\t\t\tfor(int k = 0; k < cols; k++) {\n\t\t\t\tmatrix3.values[k][i + rows] = matrix2.values[k][i];\n\t\t\t}\n\t \t}\n\t\treturn matrix3;\n\t}\n\tMatrix concatenateColumns(const Matrix & matrix2) {\n\t\tMatrix matrix4(rows,cols * 2);\n\t\tfor(int i = 0; i < rows; i++) {\n\t\t\tfor(int k = 0; k < cols; k++) {\n\t\t\t\tmatrix4.values[k][i] =  this->values[k][i];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < rows; i++) {\n\t\t\tfor(int k = 0; k < cols; k++) {\n\t\t\t\tmatrix4.values[k + cols][i] = matrix2.values[k][i];\n\t\t\t}\n\t\t}\n\t\treturn matrix4;\n\t}\n\tvoid print() {\n\t\tfor(int i = 0; i < this->rows; i++) {\n\t\t\tfor(int k = 0; k < this->cols; k++) {\n\t\t\t\tcout<< \"    \" << values[k][i];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\t~Matrix(){}\n};",
            1589423685.8391876,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/14",
            "肖翎予",
            "#include <iostream>\nusing namespace std;\n\nvoid Tensor_print(int dimensions, const int sizes[], const double data[]) {\n\tif(dimensions == 1) {\n\t\tcout << \"Tensor of \" << sizes[0] << endl;\n\t\tfor(int i = 0; i < sizes[0]; i++) cout<< data[i] << endl;\n\t}\n\tif(dimensions == 2) {\n\t\tcout << \"Tensor of \" << sizes[0] << \"x\" << sizes[1] << endl;\n\t\tfor(int i = 0; i < sizes[0]; i++) {\n\t\t\tfor(int k = 0; k < sizes[1]; k++) {\n\t\t\t\tcout << \"    \" << data[sizes[1] * i + k];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tif(dimensions == 3) {\n\t\tcout << \"Tensor of \" << sizes[0] << \"x\" << sizes[1] << 'x' << sizes[2] << endl;\n\t\tfor(int z = 0; z < sizes[0]; z++) {\n\t\t\tcout << \"data[\"<<z<<\"]\" << endl;\n\t\t\tfor(int i = 0; i < sizes[1]; i++) {\n\t\t\t\tfor(int k = 0; k < sizes[2] ; k++) {\n\t\t\t\t\tcout << \"    \" << data[sizes[2] * i + k];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t}\n\tif(dimensions == 4) {\n\t\tcout << \"Tensor of \"<< sizes[0] << \"x\" << sizes[1] << \"x\" << sizes[2] << \"x\" << sizes[3] << endl;\n\t\tfor(int y = 0; y < sizes[0]; y++) {\n\t\t\tfor(int z = 0; z < sizes[1]; z++) {\n\t\t\t\tcout << \"data[\"<<y<<\"][\"<<z<<\"]\" << endl;\n\t\t\t\tfor(int i = 0; i < sizes[2]; i++) {\n\t\t\t\t\tfor(int k = 0; k < sizes[3]; k++ ) {\n\t\t\t\t\t\tcout << \"    \" << data[sizes[3] * i + k];\n\t\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\t\n}",
            1589427439.055772,
            100,
            "# 答案正确"
        ],
        [
            "2.9 (C++)",
            "肖翎予",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix {\nprivate:\n    int rows;\n    int cols;\n    double values[1000];\npublic:\n    Matrix(int inrows = 0,int incols = 0) {\n        this->rows = rows;\n        this->cols = cols;\n        for(int i = 0; i < rows; i++) {\n            for(int j = 0; j < cols; j++) {\n                this->values[i * cols + j] = 0;\n            }\n        }\n    }\n    Matrix(int inrows, int incols, double invalues[]) {\n        this->rows = inrows;\n        this->cols = incols;\n        for(int i = 0; i < rows; i++) {\n            for(int j = 0; j < cols; j++) {\n                this->values[i * cols + j] = invalues[i * cols + j];\n            }\n        }\n    }\n    ~Matrix() {}\n    void print() {\n        for(int i = 0; i < rows; i++) {\n            for(int j = 0; j < cols; j++) {\n                cout << \"    \" << values[i * cols + j];\n            }\n            cout << endl;\n        }\n    }\n    void set(int row, int col, double invalue) {\n        values[(row - 1) * cols + col - 1] = invalue;\n    }\n    Matrix &operator = (Matrix matrix2) {\n        this->rows = matrix2.rows;\n        this->cols = matrix2.cols;\n        for(int i = 0; i < rows; i++) {\n            for(int j = 0; j < cols; j++) {\n                this->values[i * cols + j] = matrix2.values[i * cols+j];\n            }\n        }\n    }\n\tMatrix operator +(Matrix matrix2) {\n\t\tdouble temp[1000];\n\t\tfor(int i = 0; i < rows; i++) {\n            for(int j = 0; j < cols; j++) {\n                temp[i * cols + j] = this->values[i * cols + j] + matrix2.values[i * cols + j];\n            }\n        }\n\t\tMatrix matrix3(rows, cols, temp);\n\t\treturn matrix3;\n\t}\n\tMatrix operator +(double invalue) {\n\t\tdouble temp[1000];\n\t\tfor(int i = 0; i < rows;i ++) {\n            for(int j = 0; j < cols; j++) {\n                temp[i * cols + j] = this->values[i * cols + j] + invalue;\n            }\n        }\n\t\tMatrix matrix2(rows, cols, temp);\n\t\treturn matrix2;\n\t}\n\tMatrix operator -(Matrix matrix2) {\n\t\tdouble temp[1000];\n\t\tfor(int i = 0; i < rows; i++) {\n            for(int j = 0; j < cols; j++) {\n                temp[i * cols + j] = this->values[i * cols + j] - matrix2.values[i * cols + j];\n            }\n        }\n\t\tMatrix matrix3(rows, cols,temp);\n\t\treturn matrix3;\n\t}\n\tMatrix operator -(double invalue) {\n\t\tdouble temp[1000];\n\t\tfor(int i = 0; i < rows; i++) {\n            for(int j = 0; j < cols; j++) {\n                temp[i * cols + j] = this->values[i * cols + j] - invalue;\n            }\n        }\n\t\tMatrix matrix2(rows,cols,temp);\n\t\treturn matrix2;\n\t}\n};",
            1590031719.449179,
            100,
            "# 答案正确"
        ],
        [
            "2.4 (C++)",
            "肖翎予",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix {\nprivate:\n    int rows;\n    int cols;\n    double values[1000];\npublic:\n    Matrix(int inrows = 0,int incols = 0) {\n        this->rows = rows;\n        this->cols = cols;\n        for(int i = 0; i < rows; i++) {\n            for(int j = 0; j < cols; j++) {\n                this->values[i * cols + j] = 0;\n            }\n        }\n    }\n    Matrix(int inrows, int incols, double invalues[]) {\n        this->rows = inrows;\n        this->cols = incols;\n        for(int i = 0; i < rows; i++) {\n            for(int j = 0; j < cols; j++) {\n                this->values[i * cols + j] = invalues[i * cols + j];\n            }\n        }\n    }\n    ~Matrix() {}\n    void print() {\n        for(int i = 0; i < rows; i++) {\n            for(int j = 0; j < cols; j++) {\n                cout << \"    \" << values[i * cols + j];\n            }\n            cout << endl;\n        }\n    }\n    void set(int row, int col, double invalue) {\n        values[(row - 1) * cols + col - 1] = invalue;\n    }\n    Matrix &operator = (Matrix matrix2) {\n        this->rows = matrix2.rows;\n        this->cols = matrix2.cols;\n        for(int i = 0; i < rows; i++) {\n            for(int j = 0; j < cols; j++) {\n                this->values[i * cols + j] = matrix2.values[i * cols+j];\n            }\n        }\n    }\n} ;\n",
            1590053467.4224398,
            100,
            "# 答案正确"
        ],
        [
            "2.7 (C++)",
            "肖翎予",
            " #include <iostream>\nusing namespace std;\n\nclass Matrix {\nprivate:\n    int rows;\n    int cols;\n    double values[1000];\npublic:\n    Matrix(int inrows = 0,int incols = 0) {\n        this->rows = rows;\n        this->cols = cols;\n        for(int i = 0; i < rows; i++) {\n            for(int j = 0; j < cols; j++) {\n                this->values[i * cols + j] = 0;\n            }\n        }\n    }\n    Matrix(int inrows, int incols, double invalues[]) {\n        this->rows = inrows;\n        this->cols = incols;\n        for(int i = 0; i < rows; i++) {\n            for(int j = 0; j < cols; j++) {\n                this->values[i * cols + j] = invalues[i * cols + j];\n            }\n        }\n    }\n    ~Matrix() {}\n    void print() {\n        for(int i = 0; i < rows; i++) {\n            for(int j = 0; j < cols; j++) {\n                cout << \"    \" << values[i * cols + j];\n            }\n            cout << endl;\n        }\n    }\n    void set(int row, int col, double invalue) {\n        values[(row - 1) * cols + col - 1] = invalue;\n    }\n    Matrix &operator = (Matrix matrix2) {\n        this->rows = matrix2.rows;\n        this->cols = matrix2.cols;\n        for(int i = 0; i < rows; i++) {\n            for(int j = 0; j < cols; j++) {\n                this->values[i * cols + j] = matrix2.values[i * cols+j];\n            }\n        }\n    }\n    Matrix reshape(int row, int col){\n        double temp[1000];\n        for(int i = 0;  i < rows;i++) {\n            for(int j = 0; j < cols; j++) {\n                temp[j * rows + i] = values[i * cols + j];\n            }\n        }\n        double temp2[1000];\n        int k = 0;\n        for(int j = 0; j < col; j++) {\n            for(int i = 0; i < row; i++) {\n                temp2[j + i * col] = temp[k++];\n            }\n        }\n        Matrix matrix2(row, col, temp2);\n        return matrix2;\n    }\n};\n",
            1590054861.4242232,
            100,
            "# 答案正确"
        ],
        [
            "2.8 (C++)",
            "肖翎予",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix {\nprivate:\n    int rows;\n    int cols;\n    double values[1000];\npublic:\n    Matrix(int inrows = 0,int incols = 0) {\n        this->rows = rows;\n        this->cols = cols;\n        for(int i = 0; i < rows; i++) {\n            for(int j = 0; j < cols; j++) {\n                this->values[i * cols + j] = 0;\n            }\n        }\n    }\n    Matrix(int inrows, int incols, double invalues[]) {\n        this->rows = inrows;\n        this->cols = incols;\n        for(int i = 0; i < rows; i++) {\n            for(int j = 0; j < cols; j++) {\n                this->values[i * cols + j] = invalues[i * cols + j];\n            }\n        }\n    }\n    ~Matrix() {}\n    void print() {\n        for(int i = 0; i < rows; i++) {\n            for(int j = 0; j < cols; j++) {\n                cout << \"    \" << values[i * cols + j];\n            }\n            cout << endl;\n        }\n    }\n    void set(int row, int col, double invalue) {\n        values[(row - 1) * cols + col - 1] = invalue;\n    }\n    Matrix &operator = (Matrix matrix2) {\n        this->rows = matrix2.rows;\n        this->cols = matrix2.cols;\n        for(int i = 0; i < rows; i++) {\n            for(int j = 0; j < cols; j++) {\n                this->values[i * cols + j] = matrix2.values[i * cols+j];\n            }\n        }\n    }\n    Matrix transpose() {\n        double temp[1000];\n        for(int i = 0; i < rows; i++) {\n            for(int j = 0; j < cols; j++) {\n                temp[j * rows + i] = values[i * cols + j];\n            }\n        }\n        Matrix matrix2(cols, rows, temp) ;\n        return matrix2;\n    }\n};",
            1590063419.7147894,
            100,
            "# 答案正确"
        ],
        [
            "2.10 (C++)",
            "肖翎予",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix {\nprivate:\n    int rows;\n    int cols;\n    double values[1000];\npublic:\n    Matrix(int inrows = 0,int incols = 0) {\n        this->rows = rows;\n        this->cols = cols;\n        for(int i = 0; i < rows; i++) {\n            for(int j = 0; j < cols; j++) {\n                this->values[i * cols + j] = 0;\n            }\n        }\n    }\n    Matrix(int inrows, int incols, double invalues[]) {\n        this->rows = inrows;\n        this->cols = incols;\n        for(int i = 0; i < rows; i++) {\n            for(int j = 0; j < cols; j++) {\n                this->values[i * cols + j] = invalues[i * cols + j];\n            }\n        }\n    }\n    ~Matrix() {}\n    void print() {\n        for(int i = 0; i < rows; i++) {\n            for(int j = 0; j < cols; j++) {\n                cout << \"    \" << values[i * cols + j];\n            }\n            cout << endl;\n        }\n    }\n    void set(int row, int col, double invalue) {\n        values[(row - 1) * cols + col - 1] = invalue;\n    }\n    Matrix &operator = (Matrix matrix2) {\n        this->rows = matrix2.rows;\n        this->cols = matrix2.cols;\n        for(int i = 0; i < rows; i++) {\n            for(int j = 0; j < cols; j++) {\n                this->values[i * cols + j] = matrix2.values[i * cols+j];\n            }\n        }\n    }\n    Matrix operator * (const Matrix & matrix2) {\n        double temp[1000];\n         for(int i = 0; i < rows; i++) {\n            for(int j = 0; j < matrix2.cols; j++) {\n                temp[i * matrix2.cols + j] = 0;\n            }\n        }\n        for(int i = 0; i < rows; i ++) {\n            for(int j = 0; j < matrix2.cols; j++) {\n                for (int k = 0; k < cols; k++) {\n                    temp[i * matrix2.cols + j] += values[i * cols + k] * matrix2.values[j + k * matrix2.cols];\n                } \n            }\n        }\n        Matrix matrix3(rows, matrix2.cols, temp);\n        return matrix3;\n    }\n    Matrix operator * (double value) {\n        double temp[1000];\n        for(int i = 0; i < rows; i++) {\n            for(int j = 0; j < cols; j++) {\n                temp[i * cols + j] = values[i * cols + j] * value;\n            }\n        }\n        Matrix matrix2(rows,cols,temp);\n        return matrix2;\n    }\n};",
            1590064602.1958153,
            100,
            "# 答案正确"
        ],
        [
            "2.11 (C++)",
            "肖翎予",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix {\nprivate:\n    int rows;\n    int cols;\n    double values[1000];\npublic:\n    Matrix(int inrows = 0,int incols = 0) {\n        this->rows = rows;\n        this->cols = cols;\n        for(int i = 0; i < rows; i++) {\n            for(int j = 0; j < cols; j++) {\n                this->values[i * cols + j] = 0;\n            }\n        }\n    }\n    Matrix(int inrows, int incols, double invalues[]) {\n        this->rows = inrows;\n        this->cols = incols;\n        for(int i = 0; i < rows; i++) {\n            for(int j = 0; j < cols; j++) {\n                this->values[i * cols + j] = invalues[i * cols + j];\n            }\n        }\n    }\n    ~Matrix() {}\n    void print() {\n        for(int i = 0; i < rows; i++) {\n            for(int j = 0; j < cols; j++) {\n                cout << \"    \" << values[i * cols + j];\n            }\n            cout << endl;\n        }\n    }\n    void set(int row, int col, double invalue) {\n        values[(row - 1) * cols + col - 1] = invalue;\n    }\n    Matrix &operator = (Matrix matrix2) {\n        this->rows = matrix2.rows;\n        this->cols = matrix2.cols;\n        for(int i = 0; i < rows; i++) {\n            for(int j = 0; j < cols; j++) {\n                this->values[i * cols + j] = matrix2.values[i * cols+j];\n            }\n        }\n    }\n    Matrix max() {\n        if(rows != 1) {\n        double temp = 0;\n        for(int j = 0; j < cols;  j++) {\n            for(int i = 0; i < rows; i++) {\n                for(int k = 0 ; k < rows - 1; k++) {\n                    if(values[k * cols + j] < values[(k + 1) * cols + j]) {\n                       temp = values[(k + 1) * cols + j];\n                       values[(k + 1) * cols + j] = values[k * cols + j];\n                       values[k * cols + j] = temp;\n                    }\n                }\n            }\n        }\n        double temp2[30];\n        for(int j = 0; j < cols; j++) {\n            temp2[j] = values[j];\n        }\n        Matrix matrix2(1, cols, temp2);\n        return matrix2;\n        }\n        else {\n            double jud = 0;\n            for(int i = 0; i < cols; i++) {\n                if(values[i] > jud) {\n                    jud = values[i];\n                }\n            }\n            double temp2[1];\n            temp2[0] = jud;\n            Matrix matrix2(1, 1, temp2);\n            return matrix2;\n         }\n    }\n    Matrix min();\n    Matrix sum();\n};\n\nMatrix Matrix::sum() {\n    if(rows != 1) {\n        double temp[30];\n        for(int i = 0; i < cols; i++) temp[i] = 0;\n        for(int i = 0 ; i < rows; i++) {\n            for(int k = 0 ; k < cols; k++) {\n                temp[k] += values[i * cols + k];\n            }\n        }\n        Matrix matrix2(1,cols,temp);\n        return matrix2;\n    }\n    else {\n        double temp[1] = {0};\n        for(int i = 0; i < cols; i++) {\n            temp[0] += values[i];\n        }\n        Matrix matrix2(1, 1, temp);\n        return matrix2;\n    }\n}\n\nMatrix Matrix::min() {\n        if(rows != 1) {\n        double temp = 0;\n        for(int k = 0; k < cols; k ++) {\n            for(int i = 0; i < rows; i++) {\n                for(int j = 0; j < rows - 1; j++) {\n                    if(values[j * cols + k] > values[(j + 1) * cols + k]) {\n                       temp = values[(j + 1) * cols + k];\n                       values[(j + 1) * cols + k] = values[j * cols + k];\n                       values[j * cols + k] = temp;\n                    }\n                }\n            }\n        }\n        double temp2[30];\n        for(int k = 0; k < cols; k++) {\n            temp2[k] = values[k];\n        }\n        Matrix matrix2(1, cols, temp2);\n        return matrix2;\n        }\n        else {\n            double jud = 100000;\n            for(int i = 0; i < cols; i++) {\n                if(values[i] < jud) {\n                    jud = values[i];\n                }\n            }\n            double temp2[1];\n            temp2[0] = jud;\n            Matrix matrix2(1, 1, temp2);\n            return matrix2;\n         }\n    }\n",
            1590065532.8067572,
            100,
            "# 答案正确"
        ],
        [
            "2.12 (C++)",
            "肖翎予",
            "#include <iostream>\n#include <cmath>\nusing namespace std;\nclass Matrix\n{\nprivate:\n    int row ;\n    int col ;\n    double val[1000];\npublic:\n    Matrix(int row_ = 0,int col_= 0)\n    {\n        this->row = row_ ;\n        this->col = col_ ;\n        for(int i = 0 ; i < row ; i ++)\n        {\n            for(int k = 0 ; k < col ; k ++)\n            {\n                this->val[i*col+k] =0 ;\n            }\n        }\n    }\n    Matrix(int row_, int col_, double val_[])\n    {\n        this->row = row_ ;\n        this->col = col_ ;\n        for(int i = 0 ; i < row ; i ++)\n        {\n            for(int k = 0 ; k < col ; k ++)\n            {\n                this->val[i*col+k] =val_[i*col+k] ;\n            }\n        }\n    }\n    ~Matrix() {\t}\n    void print()\n    {\n        for(int i = 0 ; i < row ; i ++)\n        {\n            for(int k = 0 ; k < col ; k ++)\n            {\n                cout << \"    \"<<val[i*col+k] ;\n            }\n            cout << endl ;\n        }\n    }\n    void set(int r, int c, double val_)\n    {\n        val[(r-1)*col+c-1] = val_ ;\n    }\n    Matrix &operator =(Matrix m1)\n    {\n        this->row =m1.row;\n        this->col =m1.col;\n        for(int i = 0 ; i < row ; i ++)\n        {\n            for(int k = 0 ; k < col ; k ++)\n            {\n                this->val[i*col+k] =m1.val[i*col+k] ;\n            }\n        }\n    }\n    Matrix exp() ;\n    Matrix log() ;\n    Matrix abs() ;\n    Matrix pow(double ex) ;\n} ;\n\n\nMatrix Matrix::pow(double ex)  {\n    double t2[1000] ;\n    for(int i = 0 ; i < col*row ; i ++) {\n        t2[i] = std::pow(val[i],ex) ;\n    }\n    Matrix m1(row,col,t2) ;\n    return m1 ;\n}\n\nMatrix Matrix::exp() {\n    double t2[1000] ;\n    for(int i = 0 ; i < col*row ; i ++) {\n        t2[i] = std::exp(val[i]) ;\n    }\n    Matrix m1(row,col,t2);\n    return m1 ;\n}\nMatrix Matrix::log()  {\n    double t2[1000];\n    for(int i = 0; i < col*row; i ++) {\n        t2[i] = std::log(val[i]);\n    }\n    Matrix m1(row,col,t2);\n    return m1;\n}\nMatrix Matrix::abs() {\n    double t2[1000];\n    for(int i = 0; i < col*row; i++) {\n        t2[i] = std::abs(val[i]);\n    }\n    Matrix m1(row,col,t2);\n    return m1;\n}\n\n",
            1590065938.3909044,
            100,
            "# 答案正确"
        ],
        [
            "6.1 (C++)",
            "肖翎予",
            "#include <iostream>\n#include <string>\n#include <cstring>\nusing namespace std;\n\ntemplate <typename T>\nclass Matrix {\nprivate:\n    int rows;\n    int cols;\n    T *values;\npublic:\n    Matrix(int inrows = 0, int incols= 0) {\n        this->rows = inrows;\n        this->cols = incols;\n\t\tthis -> values = new T[rows * cols];\n        memset(values, 0, rows * cols * sizeof(T));\n    }\n    Matrix(int inrows, int incols, const T invalues[]) {\n        this->rows = inrows;\n        this->cols = incols;\n        this->values = new T[rows * cols];\n        for(int i = 0; i < rows; i++) {\n            for(int k = 0; k < cols; k++) {\n                this->values[i * cols + k] = invalues[i * cols + k];\n            }\n        }\n    }\n    ~Matrix() {\n\t\tdelete[] values;\n    }\n    void print() {\n        for(int i = 0; i < rows; i++) {\n            for(int k = 0; k < cols; k++) {\n                cout << \"    \" << values[i * cols + k];\n            }\n            cout << endl;\n        }\n    }\n    Matrix &operator =(const Matrix &matrix2) {\n\t\tdelete[]values;                       \n        this->rows = matrix2.rows;\n        this->cols = matrix2.cols;\n\t\tthis->values = new T[rows * cols];\n        for(int i = 0; i < rows; i++) {\n            for(int k = 0; k < cols; k++) {\n                this->values[i * cols + k] = matrix2.values[i * cols + k];\n            }\n        }\n\t\treturn *this;\n    }\n\tMatrix (Matrix &matrix2) {                   \n\t\tthis->rows = matrix2.rows;\n     \tthis->cols = matrix2.cols;\n\t\tvalues = new T[rows * cols];\n        for(int i = 0; i < rows; i++) {\n            for(int k = 0; k < cols; k++) {\n                values[i * cols + k] = matrix2.values[i * cols + k];\n            }\n        }\n\t}\n    T &get(int x, int y) {\n        return this->values[(y - 1) * cols + x - 1];\n    }\n};\n",
            1590633499.619589,
            100,
            "# 答案正确"
        ],
        [
            "6.2 (C++)",
            "肖翎予",
            "#include <iostream>\n#include <string>\n#include <cstring>\nusing namespace std;\n\ntemplate <typename T>\nclass Matrix {\nprivate:\n    int rows;\n    int cols;\n    T *values;\npublic:\n    Matrix(int inrows = 0, int incols= 0) {\n        this->rows = inrows;\n        this->cols = incols;\n\t\tthis -> values = new T[rows * cols];\n        memset(values, 0, rows * cols * sizeof(T));\n    }\n    Matrix(int inrows, int incols, const T invalues[]) {\n        this->rows = inrows;\n        this->cols = incols;\n        this->values = new T[rows * cols];\n        for(int i = 0; i < rows; i++) {\n            for(int k = 0; k < cols; k++) {\n                this->values[i * cols + k] = invalues[i * cols + k];\n            }\n        }\n    }\n    ~Matrix() {\n\t\tdelete[] values;\n    }\n    void print() {\n        for(int i = 0; i < rows; i++) {\n            for(int k = 0; k < cols; k++) {\n                cout << \"    \" << values[i * cols + k];\n            }\n            cout << endl;\n        }\n    }\n    Matrix &operator =(const Matrix &matrix2) {\n\t\tdelete[]values;                       \n        this->rows = matrix2.rows;\n        this->cols = matrix2.cols;\n\t\tthis->values = new T[rows * cols];\n        for(int i = 0; i < rows; i++) {\n            for(int k = 0; k < cols; k++) {\n                this->values[i * cols + k] = matrix2.values[i * cols + k];\n            }\n        }\n\t\treturn *this;\n    }\n\tMatrix (Matrix &matrix2) {                   \n\t\tthis->rows = matrix2.rows;\n     \tthis->cols = matrix2.cols;\n\t\tvalues = new T[rows * cols];\n        for(int i = 0; i < rows; i++) {\n            for(int k = 0; k < cols; k++) {\n                values[i * cols + k] = matrix2.values[i * cols + k];\n            }\n        }\n\t}\n    T &get(int x, int y) {\n        return this->values[(y - 1) * cols + x - 1];\n    }\n};\n",
            1590633520.9595287,
            100,
            "# 答案正确"
        ],
        [
            "6.3 (C++)",
            "肖翎予",
            "#include <iostream>\n#include <string>\n#include <cstring>\n#include <vector>\nusing namespace std;\n\ntemplate <typename T>\nclass Matrix {\nprivate:\n    int row;\n    int col;\n    vector <T> val;\npublic:\n    Matrix(int row_ = 1, int col_= 1) {\n        this->row = row_;\n        this->col = col_;\n        for(int i =0; i < row*col; i++) val.push_back(0);\n    }\n    Matrix(int row_, int col_, const vector<T> val_) {\n        this->row = row_;\n        this->col = col_;\n        for(int i = 0; i < row; i++) {\n            for(int k = 0; k < col; k++) {\n                val.push_back(val_[i*col+k]);\n            }\n        }\n    }\n    ~Matrix() {\n    }\n    void print() {\n        for(int i = 0; i < row; i++) {\n            for(int k = 0; k < col; k++) {\n                cout << \"    \" << val[i*col+k];\n            }\n            cout << endl ;\n        }\n    }\n    Matrix &operator =(const Matrix &m2) {\n        val.clear() ;\n        this->row =m2.row;\n        this->col =m2.col;\n        for(int i = 0 ; i < row ; i ++) {\n            for(int k = 0 ; k < col ; k ++) {\n                val.push_back(m2.val[i*col+k]) ;\n            }\n        }\n        return *this ;\n    }\n    Matrix (Matrix &m2) {\n        this->row =m2.row;\n        this->col =m2.col;\n        for(int i = 0 ; i < row ; i ++) {\n            for(int k = 0 ; k < col ; k ++) {\n                val.push_back(m2.val[i*col+k]) ;\n            }\n        }\n    }\n    T &get(int x, int y) {\n        return this->val[(y-1)*col+x-1] ;\n    }\n    Matrix getColumn(int x) {\n        int r = row;\n        int c = 1 ;\n        vector<T> t;\n        for(int i = 0 ; i < row ; i ++) {\n            t.push_back( val[i*col+x-1]) ;\n        }\n        Matrix m1(r,c,t) ;\n        return m1 ;\n    }\n    Matrix getRow(int x) {\n        int r = 1;\n        int c = col ;\n        vector<T> t;\n        for(int i = 0 ; i < row ; i ++) {\n            t.push_back( val[(x-1)*row+i]) ;\n        }\n        Matrix m1(r,c,t) ;\n        return m1 ;\n    }\n    Matrix concatenateRows(Matrix m2) {\n        int r = row+m2.row;\n        int c = col ;\n        vector<T> t;\n        for(int i = 0 ; i < row ; i ++) {\n            for(int k = 0 ; k < col ; k ++) {\n                t.push_back(val[i*col+k]) ;\n            }\n        }\n        for(int i = 0 ; i < row ; i ++) {\n            for(int k = 0 ; k < col ; k ++) {\n                t.push_back(m2.val[i*col+k]) ;\n            }\n        }\n        Matrix m1(r,c,t) ;\n        return m1 ;\n    }\n    Matrix concatenateColumns(Matrix m2) {\n        int r = row;\n        int c = col+m2.col ;\n        vector<T> t;\n        for(int i = 0 ; i < c ; i ++) {\n            for(int k = 0 ; k < c ; k ++) {\n                t.push_back(0) ;\n            }\n        }\n        for(int k = 0 ; k < col ; k ++){\n        for(int i = 0 ; i < row ; i ++)\n             {\n                t[i*c+k] = val[i*col+k] ;\n            }\n        }\n        for(int i = 0 ; i < row ; i ++) {\n            for(int k = 0 ; k < col ; k ++) {\n                t[i*c+k+col] = m2.val[i*col+k] ;\n            }\n        }\n        Matrix m1(r,c,t) ;\n        return m1 ;\n    }\n    Matrix reshape(int row_ ,int col_) {\n        int r = row_;\n        int c = col_ ;\n        vector<T> t1;\n        vector<T> t2;\n        for(int i = 0 ; i < r ; i ++) {\n            for(int k = 0 ; k < c ; k ++) {\n                t1.push_back(1) ;\n                t2.push_back(1) ;\n            }\n        }\n        int y = 0 ;\n        for(int k = 0 ; k < col ; k ++) {\n            for(int i = 0 ; i < row ; i ++) {\n                t2[y++] = val[i*col+k] ;\n            }\n        }\n        int z = 0 ;\n        for(int k = 0 ; k < c ; k ++) {\n            for(int i = 0 ; i < r ; i ++) {\n                t1[i*c+k] = t2[z++] ;\n            }\n        }\n        Matrix m1(r,c,t1) ;\n        return m1 ;\n    }\n    Matrix transpose(){\n        vector<T> t;\n        for(int i = 0 ; i < row ; i ++) {\n            for(int k = 0 ; k < col ; k ++) {\n                t.push_back(1) ;\n            }\n        }\n        int y = 0 ;\n        for(int k = 0 ; k < col ; k ++) {\n            for(int i = 0 ; i < row ; i ++) {\n                t[y++] = val[i*col+k] ;\n            }\n        }\n        Matrix m1(col,row,t) ;\n        return m1 ;\n    }\n    Matrix operator + (Matrix m2) {\n        vector<T> t;\n        for(int i = 0 ; i < row ; i ++) {\n            for(int k = 0 ; k < col ; k ++) {\n                t.push_back(m2.val[i*col+k]+val[i*col+k]) ;\n            }\n        }\n        Matrix m1(row,col,t) ;\n        return m1 ;\n    }\n    Matrix operator + (T n) {\n        vector<T> t;\n        for(int i = 0 ; i < row ; i ++) {\n            for(int k = 0 ; k < col ; k ++) {\n                t.push_back(n+val[i*col+k]) ;\n            }\n        }\n        Matrix m1(row,col,t) ;\n        return m1 ;\n    }\n    Matrix operator - (Matrix m2) {\n        vector<T> t;\n        for(int i = 0 ; i < row ; i ++) {\n            for(int k = 0 ; k < col ; k ++) {\n                t.push_back(-m2.val[i*col+k]+val[i*col+k]) ;\n            }\n        }\n        Matrix m1(row,col,t) ;\n        return m1 ;\n    }\n    Matrix operator - (T n) {\n        vector<T> t;\n        for(int i = 0 ; i < row ; i ++) {\n            for(int k = 0 ; k < col ; k ++) {\n                t.push_back(-n+val[i*col+k]) ;\n            }\n        }\n        Matrix m1(row,col,t) ;\n        return m1 ;\n    }\n    Matrix operator * (Matrix m2) {\n        vector<T> t;\n        for(int i = 0 ; i < row ; i ++) {\n            for(int k = 0 ; k < m2.col ; k ++) {\n                t.push_back(0) ;\n            }\n        }\n        for(int i = 0 ; i < row ; i ++) {\n            for(int k = 0 ; k < m2.col ; k ++) {\n                for(int z = 0 ; z < col ; z ++) t[i*m2.col+k] += val[i*col+z]*m2.val[k+z*m2.col] ;\n            }\n        }\n        Matrix m1(row,m2.col,t) ;\n        return m1 ;\n    }\n    Matrix operator * (T n) {\n        vector<T> t;\n        for(int i = 0 ; i < row ; i ++) {\n            for(int k = 0 ; k < col ; k ++) {\n                t.push_back(val[i*col+k]*n) ;\n            }\n        }\n        Matrix m1(row,col,t) ;\n        return m1 ;\n    }\n    Matrix max() {\n        vector<T> t;\n        if(col == 1) {\n            t.push_back(0) ;\n            T now = val[0] ;\n            for(int i = 0 ;i < row ; i ++) {\n                if(val[i]>now) now = val[i] ;\n            }\n            t[0] = now ;\n            Matrix m1(1,1,t) ;\n            return m1 ;\n        }\n        else{\n            for(int i = 0 ; i < row ; i ++) {\n                t.push_back(0) ;\n                T now = val[i*col] ;\n                for(int k = 0 ;k < col ; k ++) {\n                if(val[i*col+k]>now) now = val[i*col+k] ;\n                }\n                t[i] = now ;\n            }\n            Matrix m1(row,1,t) ;\n            return m1 ;\n        }\n    }\n    Matrix min() {\n        vector<T> t;\n        if(col == 1) {\n            t.push_back(0) ;\n            T now = val[0] ;\n            for(int i = 0 ;i < row ; i ++) {\n                if(val[i]<now) now = val[i] ;\n            }\n            t[0] = now ;\n            Matrix m1(1,1,t) ;\n            return m1 ;\n        }\n        else{\n            for(int i = 0 ; i < row ; i ++) {\n                t.push_back(0) ;\n                T now = val[i*col] ;\n                for(int k = 0 ;k < col ; k ++) {\n                if(val[i*col+k]<now) now = val[i*col+k] ;\n                }\n                t[i] = now;\n            }\n            Matrix m1(row,1,t);\n            return m1;\n        }\n    }\n    Matrix sum() {\n        vector<T> t;\n        if(col == 1) {\n            t.push_back(0) ;\n            for(int i = 0 ;i < row; i++) {\n                t[0]+=val[i];\n            }\n            Matrix m1(1,1,t);\n            return m1;\n        }\n        else{\n            for(int i = 0 ; i < row; i++) {\n                t.push_back(0);\n                for(int k = 0; k < col; k++) {\n                t[i] += val[i*col+k];\n                }\n            }\n            Matrix m1(row,1,t);\n            return m1;\n        }\n    }\n};\n",
            1590634477.798071,
            100,
            "# 答案正确"
        ],
        [
            "7.2 (C++)",
            "肖翎予",
            "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nvector <string> split(const string &line ,const string &de = \" \" ) {\n\tvector <string> mm;\n\tint now = 0;\n\tint end;\n\twhile(now < line.size()) {\n\t\tend = line.find(de,now);\n\t\tif(now == end) now += de.size();\n\t\telse {\n\t\t\tif(end == -1) {\n\t\t\t\tmm.push_back(line.substr(now));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmm.push_back(line.substr(now,end-now));\n\t\t\tnow = end += de.size();\n\t\t}\n\t}\n\treturn mm;\n}",
            1591239838.1949878,
            100,
            "# 答案正确"
        ],
        [
            "7.1 (C++)",
            "肖翎予",
            "#include <cmath>\nclass Triangle:public GeometricObject\n{\nprivate :\n    double side1, side2, side3;\npublic :\n    Triangle() {\n        side1 = 1.0;\n        side2 = 1.0;\n        side3 = 1.0;\n    }\n    Triangle(double side1_,double side2_,double side3_) {\n        side1 =  side1_ ;\n        side2 = side2_ ;\n        side3 = side3_ ;\n    }\n    double getSide1() {\n        return side1;\n    }\n    double getSide2() {\n        return side2;\n    }\n    double getSide3() {\n        return side3;\n    }\n    double getPerimeter() {\n        return (side1+side2+side3) ;\n    }\n    double getArea() {\n        double s = (side1 + side2 + side3) / 2;\n        return sqrt(s * (s - side1) * (s - side2) * (s - side3));\n    }\n};\n",
            1591272149.8823633,
            100,
            "# 答案正确"
        ],
        [
            "7.3 (C++)",
            "肖翎予",
            "template <typename A, typename R>\nvector<R> map2(const vector<A> & x, const vector<A> & y,R (*map_func)(const A &,const A &)) {\n\tvector<R> res;\n\tfor (int i = 0; i < x.size(); ++ i)\n\t\tres.push_back(map_func(x[i],y[i]));\n\treturn res;\n}\ntemplate <typename A, typename R>\nvector<R> map2(const vector<A> & x, const A & y,R (*map_func)(const A &,const A &)) {\n\tvector<R> res;\n\tfor (int i = 0; i < x.size(); ++ i)\n\t\tres.push_back(map_func(x[i],y));\n\treturn res;\n}\n\n\n",
            1591274347.6380692,
            100,
            "# 答案正确"
        ],
        [
            "8.5 (C++)",
            "肖翎予",
            "#include <iostream>\nusing namespace std;\n\nclass Point3D:public Point2D {\n    private:\n    double z;\n    public:\n    double getZ() {\n        return z;\n    }\n    Point3D() {\n        setX(0);\n        setY(0);\n        z = 0;\n    }\n    Point3D(double inx,double iny,double inz) {\n        setX(inx);\n        setY(iny);\n        z = inz;\n    }\n    virtual double distance(Point2D & point2) {\n        Point3D *p = dynamic_cast<Point3D *> (&point2);\n\t\tdouble dx = getX() -p->getX();\n\t\tdouble dy = getY() -p->getY();\n\t\tdouble dz = z - p->z;\n\t\treturn sqrt(dx * dx + dy * dy + dz * dz);\n\t}\n} ;\n\n",
            1591844826.0654342,
            100,
            "# 答案正确"
        ],
        [
            "8.1 (C++)",
            "肖翎予",
            "class Full:public Matrix {\n    private:\n    int r;\n    int c;\n    double *val;\n    public:\n    int size(int dimension) const {\n        if(dimension == 1) return r;\n        else return c;\n    }\n\tFull (int row, int column) {\n        val = new double[row*column] ;\n        r = row;\n        c = column;\n        for(int i = 0; i < r*c; i++) {\n            val[i] = 0;\n        }\n\t}\n\tFull (const Matrix & matrix2) {\n        r = matrix2.size(1);\n        c = matrix2.size(2);\n        val = new double[r*c];\n        for(int i = 0; i < r; i++) {\n            for(int k = 0; k < c; k ++) {\n                val[i*c+k] = matrix2.get(i,k);\n            }\n        }\n\t}\n\tFull (int row , int column,double value[]) {\n        val = new double[row*column];\n        r = row;\n        c = column;\n        for(int i = 0; i < r*c; i ++) {\n            val[i] = value[i];\n        }\n\t}\n\tvoid set(int row, int column, double value) {\n        val[row*c+column] = value;\n\t}\n\n\tdouble get(int row, int column) const {\n        return val[row*c+column];\n\t}\n\n\tvoid print() const {\n        for(int i = 0; i < r; i++) {\n            for(int k = 0; k < c; k++) {\n                cout <<\"    \"<< val[i*c+k];\n            }\n            cout << endl;\n        }\n\t}\n\t~Full() {\n        delete[]val;\n\t}\n\tMatrix & operator = (const Matrix & matrix2) {\n        if(val != NULL) delete[]val;\n        r = matrix2.size(1);\n        c = matrix2.size(2);\n        val = new double[r*c];\n        for(int i = 0; i < r; i++) {\n            for(int k = 0; k < c; k++) {\n                val[i*c+k] = matrix2.get(i,k);\n            }\n        }\n\t}\n};\n\n",
            1591845704.0454693,
            100,
            "# 答案正确"
        ],
        [
            "8.3 (C++)",
            "肖翎予",
            "\n#include <iostream>\nusing namespace std;\n#include <vector>\n\nclass Sparse:public Matrix {\nprivate:\n    vector <Entry> w;\n    int r;\n    int c;\npublic:\n    Sparse (int row, int col) {\n        r = row;\n        c = col;\n    }\n    int size(int dimension) const {\n        if(dimension == 1) return r;\n        else return c;\n    }\n    void set(int row, int column, double value) {\n        for(int i = 0; i < w.size(); i++) {\n            if(w[i].row == row && w[i].column==column) {\n                w[i].value =value;\n                return;\n            }\n        }\n        Entry tmp;\n        tmp.row = row;\n        tmp.column = column;\n        tmp.value = value;\n        w.push_back(tmp);\n    }\n    void add(int row, int column,double value) {\n        for(int i = 0; i < w.size(); i++) {\n            if(w[i].row == row && w[i].column==column) {\n                w[i].value +=value;\n                return;\n            }\n        }\n        Entry tmp;\n        tmp.row = row;\n        tmp.column = column;\n        tmp.value = value;\n        w.push_back(tmp);\n    }\n    ~Sparse() {}\n    double get(int row, int column) const {\n        for(int i = 0; i < w.size(); i++) {\n            if(w[i].row == row && w[i].column==column) {\n                return w[i].value;\n            }\n        }\n        return -1;\n    }\n    virtual void print() {\n        for(int i = 0; i < w.size(); i++) {\n            if(get(w[i].row,w[i].column) != 0)cout << \"(\" << w[i].row << \",\" << w[i].column << \",\" << get(w[i].row,w[i].column) << \")\" << endl;\n        }\n    }\n    Sparse operator + (const Sparse s2)\n    {\n        Sparse s3(r,c);\n        Entry ww[10];\n        int z = 0;\n        for(int i = 0; i < w.size(); i++)\n        {\n            s3.add(w[i].row,w[i].column,w[i].value);\n        }\n        for(int k = 0 ; k < s2.w.size(); k ++)\n        {\n            {\n                s3.add(s2.w[k].row,s2.w[k].column,s2.w[k].value);\n            }\n        }\n        return s3;\n    }\n    Sparse operator * (const Sparse s2) {\n        Sparse s3(r,s2.c);\n        for(int i = 0; i <w.size(); i++) {\n            for(int k = 0 ; k < s2.w.size(); k++) {\n                if(w[i].column == s2.w[k].row)s3.add(w[i].row, s2.w[k].column, w[i].value * s2.w[k].value);\n            }\n        }\n        for(int i = 0; i < s3.w.size(); i++) {\n            for(int k = 0; k < s3.w.size() - 1; k++) {\n                if(s3.w[k].row > s3.w[k+1].row||(s3.w[k].row == s3.w[k+1].row && s3.w[k].column > s3.w[k+1].column)) {\n                    Entry tmp = s3.w[k];\n                    s3.w[k] = s3.w[k+1];\n                    s3.w[k+1] = tmp;\n                }\n            }\n        }\n        return s3;\n    }\n};\n\n",
            1591846098.603003,
            100,
            "# 答案正确"
        ],
        [
            "8.4 (C++)",
            "肖翎予",
            "#include <iostream>\nusing namespace std;\n#include <vector>\n\nclass Sparse:public Matrix {\nprivate:\n    vector <Entry> w;\n    int r;\n    int c;\npublic:\n    Sparse (int row, int col) {\n        r = row;\n        c = col;\n    }\n    int size(int dimension) const {\n        if(dimension == 1) return r;\n        else return c;\n    }\n    void set(int row, int column, double value) {\n        for(int i = 0 ; i < w.size(); i++){\n            if(w[i].row == row && w[i].column == column) {\n                w[i].value =value;\n                return;\n            }\n        }\n        Entry tmp;\n        tmp.row = row;\n        tmp.column = column;\n        tmp.value = value;\n        w.push_back(tmp);\n    }\n    void add(int row, int column,double value) {\n        for(int i = 0; i < w.size(); i++){\n            if(w[i].row == row && w[i].column == column) {\n                w[i].value +=value;\n                return;\n            }\n        }\n        Entry tmp;\n        tmp.row = row;\n        tmp.column = column;\n        tmp.value = value;\n        w.push_back(tmp);\n    }\n    ~Sparse() {}\n    double get(int row, int column) const {\n        for(int i = 0; i < w.size(); i++){\n            if(w[i].row == row && w[i].column == column) {\n                return w[i].value;\n            }\n        }\n        return -1;\n    }\n    virtual void print() {\n        for(int i = 0; i < w.size(); i++) {\n            if(get(w[i].row,w[i].column) != 0)cout << \"(\" << w[i].row << \",\" << w[i].column << \",\" << get(w[i].row,w[i].column) << \")\" << endl;\n        }\n    }\n    Sparse operator + (const Sparse s2) {\n        Sparse s3(r,c);\n        Entry ww[10];\n        int z = 0;\n        for(int i = 0; i < w.size(); i ++) {\n            for(int k = 0; k < s2.w.size(); k ++) {\n            {\n                    s3.add(s2.w[k].row, s2.w[k].column, s2.w[k].value + w[i].value);\n                }\n            }\n        }\n        return s3;\n    }\n    Sparse operator * (const Sparse s2) {\n        Sparse s3(r,s2.c);\n        for(int i = 0; i < w.size(); i++) {\n            for(int k = 0; k < s2.w.size(); k++) {\n                if(w[i].column == s2.w[k].row)s3.add(w[i].row, s2.w[k].column,w[i].value * s2.w[k].value);\n            }\n        }\n        for(int i = 0; i < s3.w.size(); i++) {\n            for(int k = 0; k < s3.w.size() - 1; k++) {\n                if(s3.w[k].row > s3.w[k + 1].row||(s3.w[k].row == s3.w[k + 1].row && s3.w[k].column > s3.w[k + 1].column)) {\n                    Entry tmp = s3.w[k];\n                    s3.w[k] = s3.w[k + 1];\n                    s3.w[k + 1] = tmp;\n                }\n            }\n        }\n        return s3;\n    }\n};\n\n",
            1591846762.9129026,
            100,
            "# 答案正确"
        ],
        [
            "8.6 (C++)",
            "肖翎予",
            "#include <iostream>\nusing namespace std;\n\nclass MyTensor :public Tensor<double> {\nprivate:\n    double *data;\npublic:\n    virtual double & get(const vector<int> & indexes) {\n        if(sizes.size() == 1) return data[indexes[0]];\n        if(sizes.size() == 2) return data[indexes[0] + sizes[0] * indexes[1]];\n        if(sizes.size() == 3) return data[indexes[0] + sizes[0] * indexes[1] + sizes[0] * sizes[1] * indexes[2]];\n        if(sizes.size() == 4) return data[indexes[0] + sizes[0] * indexes[1] + sizes[0] * sizes[1] * indexes[2] + sizes[0] * sizes[1] * sizes[2] * indexes[3]];\n    }\n    MyTensor(vector<int>s):Tensor<double> (s) {\n        int total = 1;\n        for(int i = 0; i<s.size(); i++) total *= s[i];\n        data = new double[total];\n    }\n    ~MyTensor() {\n        delete[]data;\n    }\n};\n",
            1592450831.6033723,
            100,
            "# 答案正确"
        ],
        [
            "9.1 (C++)",
            "肖翎予",
            "#include <iostream>\nusing namespace std;\n\nclass Circle {\nprivate:\n    double x;\npublic:\n    Circle() {\n        x = 0;\n    }\n    Circle(double x_) {\n        x = x_;\n    }\n    bool operator >(Circle m) {\n        return (x>m.x);\n    }\n    bool operator ==(Circle m) {\n        return (x==m.x);\n    }\n    bool operator >=(Circle m) {\n        return (x>=m.x);\n    }\n    bool operator <=(Circle m) {\n        return (x<=m.x);\n    }\n    bool operator <(Circle m) {\n        return (x<m.x);\n    }\n    bool operator !=(Circle m) {\n        return (x!=m.x);\n    }\n};\n",
            1593083022.4621525,
            100,
            "# 答案正确"
        ],
        [
            "9.2 (C++)",
            "肖翎予",
            "class I:public Tensor {\n\tprivate:\n    vector <int>index;\n    vector<int> turn(int i1, int i2=-1, int i3=-1, int i4=-1) {\n\tvector<int> indexes;\n\tindexes.push_back(i1);\n\tif (i2 != -1) indexes.push_back(i2);\n\tif (i3 != -1) indexes.push_back(i3);\n\tif (i4 != -1) indexes.push_back(i4);\n\treturn indexes;\n    };\npublic:\n    I(int i1, int i2=-1, int i3=-1, int i4=-1):Tensor (turn(i1,i2,i3,i4)) {\n        index = turn(i1,i2,i3,i4);\n    }\n    operator vector<int> () {\n        return index;\n    }\n};\n",
            1593083421.8339117,
            100,
            "# 答案正确"
        ],
        [
            "9.3 (C++)",
            "肖翎予",
            "#include <iostream>\nusing namespace std;\nclass Complex;\nComplex operator+(const Complex&,const Complex&);\nComplex operator-(const Complex&,const Complex&);\nComplex operator*(Complex&,Complex&);\nComplex operator/(Complex&,Complex&);\nclass Complex{\n private:\n  double shi;\n  double xu;\n public:\n  double real()const{\n   return shi;\n  }\n  double imag()const{\n   return xu;\n  }\n  Complex(double a,double b){\n   shi = a;\n   xu = b;\n  }\n  Complex (int a):shi(a),xu(0){\n   \n  }\n  Complex operator +=(const Complex &a){\n   *this = *this + a;\n   return *this;\n  }\n  Complex operator -=(const Complex &a){\n   *this = *this - a;\n   return *this;\n  }\n  Complex operator *=(Complex &a){\n   *this = *this * a;\n   return *this;\n  }\n  Complex operator /=(Complex &a){\n   *this = *this / a;\n   return *this;\n  }\n  bool operator ==(Complex &a){\n   if(a.real()!=shi)return false;\n   if(a.imag()!=xu)return false;\n   return true;\n  }\n  bool operator !=(Complex &a){\n   if(a.real()!=shi)return true;\n   if(a.imag()!=xu)return true;\n   return false;\n  }\n};\nComplex operator+(const Complex& a,const Complex& b){\n Complex ans(a.real()+b.real(),a.imag()+b.imag());\n return ans;\n}\nComplex operator-(const Complex& a,const Complex& b){\n Complex ans(a.real()-b.real(),a.imag()-b.imag());\n return ans;\n}\nComplex operator*(Complex& a,Complex& b){\n double real = a.real()*b.real() - a.imag()*b.imag();\n double imag = a.real()*b.imag() + a.imag()*b.real();\n Complex ans(real,imag);\n return ans;\n}\nComplex operator / (Complex& a,Complex& b){\n double real = (a.real()*b.real() + a.imag()*b.imag())/(b.real()*b.real()+b.imag()*b.imag());\n double imag = (a.imag()*b.real() - a.real()*b.imag())/(b.real()*b.real()+b.imag()*b.imag());\n Complex ans(real,imag);\n return ans;\n}",
            1593087145.343342,
            100,
            "# 答案正确"
        ],
        [
            "9.4 (C++)",
            "肖翎予",
            "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nclass Complex {\n    private:\n    double r;\n    double i ;\n    public:\n    Complex(double x = 0,double y = 0) {\n        r = x ;\n        i = y ;\n    }\n    double real() const {\n        return r ;\n    }\n    double imag() const {\n        return i ;\n    }\n    Complex &operator +=(Complex &m2) {\n    r += m2.real() ;\n    i += m2.imag() ;\n    }\n\n    Complex &operator -=(Complex &m2) {\n    r -= m2.real() ;\n    i -= m2.imag() ;\n    }\n    Complex &operator *=(Complex &m2) {\n    double r_ = r*m2.real() - i * m2. imag() ;\n    double i_ = r*m2.imag() + i * m2. real() ;\n    r = r_ ;\n    i = i_ ;\n    }\n    Complex &operator /=(Complex &m2) {\n    double a = r ;\n    double b = i ;\n    double c = m2.real() ;\n    double d = m2. imag() ;\n    r = (a*c + b *d)/(c*c+d*d) ;\n    i = (b*c -a*d) / (c*c + d*d) ;\n    }\n    Complex &operator ++() {\n        r ++ ;\n\t\treturn *this ;\n    }\n    Complex operator ++(int) {\n        Complex tmp(r,i) ;\n        r ++ ;\n        return tmp ;\n    }\n    operator double() {return r ;}\n};\n\nComplex operator +(Complex m1,Complex m2) {\n    Complex m(m2.real() + m1.real(),m2.imag() + m1.imag()) ;\n    return m ;\n}\n\nComplex operator -(Complex m1,Complex m2) {\n    Complex m(m1.real() - m2.real(),m1.imag() - m2.imag()) ;\n    return m ;\n}\n\nComplex operator /(Complex m1,Complex m2) {\n    double a = m1.real() ;\n    double b = m1.imag() ;\n    double c = m2.real() ;\n    double d = m2. imag() ;\n    double r = (a*c + b *d)/(c*c+d*d) ;\n    double i = (b*c -a*d) / (c*c + d*d) ;\n    Complex m(r,i) ;\n    return m ;\n}\n\nComplex operator *(Complex m1,Complex m2) {\n    double r = m1.real()*m2.real() - m1.imag() * m2. imag() ;\n    double i = m1.real()*m2.imag() + m1.imag() * m2. real() ;\n    Complex m(r,i) ;\n    return m ;\n}\n\nbool operator ==(Complex m1,Complex m2) {\n    if(m1.real() == m2.real() && m1.imag() == m2.imag()) return 1 ;\n    else return 0 ;\n}\n\nbool operator !=(Complex m1,Complex m2) {\n    if(m1.real() == m2.real() && m1.imag() == m2.imag()) return 0 ;\n    else return 1 ;\n}\n\nostream &operator << (ostream &out,const Complex &m) {\n    out << m.real() << \" + \" << m.imag() << \" i \" ;\n    return out ;\n}\n\nistream &operator >> (istream &in , Complex &m) {\n    double r ;\n    double i ;\n    in >> r >> i ;\n    Complex tmp(r,i) ;\n    m = tmp ;\n    return in ;\n}\n",
            1593085664.353795,
            100,
            "# 答案正确"
        ],
        [
            "9.5 (C++)",
            "肖翎予",
            "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nclass Complex {\n    private:\n    double r;\n    double i ;\n    public:\n    Complex(double x = 0,double y = 0) {\n        r = x ;\n        i = y ;\n    }\n    double real() const {\n        return r ;\n    }\n    double imag() const {\n        return i ;\n    }\n    Complex &operator +=(Complex &m2) {\n    r += m2.real() ;\n    i += m2.imag() ;\n    }\n\n    Complex &operator -=(Complex &m2) {\n    r -= m2.real() ;\n    i -= m2.imag() ;\n    }\n    Complex &operator *=(Complex &m2) {\n    double r_ = r*m2.real() - i * m2. imag() ;\n    double i_ = r*m2.imag() + i * m2. real() ;\n    r = r_ ;\n    i = i_ ;\n    }\n    Complex &operator /=(Complex &m2) {\n    double a = r ;\n    double b = i ;\n    double c = m2.real() ;\n    double d = m2. imag() ;\n    r = (a*c + b *d)/(c*c+d*d) ;\n    i = (b*c -a*d) / (c*c + d*d) ;\n    }\n    Complex &operator ++() {\n        r ++ ;\n\t\treturn *this ;\n    }\n    Complex operator ++(int) {\n        Complex tmp(r,i) ;\n        r ++ ;\n        return tmp ;\n    }\n    operator double() {return r ;}\n};\n\nComplex operator +(Complex m1,Complex m2) {\n    Complex m(m2.real() + m1.real(),m2.imag() + m1.imag()) ;\n    return m ;\n}\n\nComplex operator -(Complex m1,Complex m2) {\n    Complex m(m1.real() - m2.real(),m1.imag() - m2.imag()) ;\n    return m ;\n}\n\nComplex operator /(Complex m1,Complex m2) {\n    double a = m1.real() ;\n    double b = m1.imag() ;\n    double c = m2.real() ;\n    double d = m2. imag() ;\n    double r = (a*c + b *d)/(c*c+d*d) ;\n    double i = (b*c -a*d) / (c*c + d*d) ;\n    Complex m(r,i) ;\n    return m ;\n}\n\nComplex operator *(Complex m1,Complex m2) {\n    double r = m1.real()*m2.real() - m1.imag() * m2. imag() ;\n    double i = m1.real()*m2.imag() + m1.imag() * m2. real() ;\n    Complex m(r,i) ;\n    return m ;\n}\n\nbool operator ==(Complex m1,Complex m2) {\n    if(m1.real() == m2.real() && m1.imag() == m2.imag()) return 1 ;\n    else return 0 ;\n}\n\nbool operator !=(Complex m1,Complex m2) {\n    if(m1.real() == m2.real() && m1.imag() == m2.imag()) return 0 ;\n    else return 1 ;\n}\n\nostream &operator << (ostream &out,const Complex &m) {\n    out << m.real() << \" + \" << m.imag() << \" i \" ;\n    return out ;\n}\n\nistream &operator >> (istream &in , Complex &m) {\n    double r ;\n    double i ;\n    in >> r >> i ;\n    Complex tmp(r,i) ;\n    m = tmp ;\n    return in ;\n}",
            1593086020.073465,
            100,
            "# 答案正确"
        ],
        [
            "9.6 (C++)",
            "肖翎予",
            "#include <vector>\n#include <iostream>\nusing namespace std;\n\n#include <vector>\n#include <iostream>\nusing namespace std;\n\nclass Tensor\n{\n\tvector<int> sizes;\n\tvector<double> values;\n\n\tint _index(const vector<int> & indexes) const {\n\t\tint index = 0;\n\t\tfor (int i = 0; i < this->sizes.size(); ++ i) {\n\t\t\tindex *= sizes[i];\n\t\t\tindex += indexes[i];\n\t\t}\n\t\treturn index;\n\t}\n\npublic:\n\tint numel() const {\n\t\tif (this->sizes.size() == 0) return 0;\n\t\tint size = 1;\n\t\tfor (int i = 0; i < this->sizes.size(); ++ i) size *= sizes[i];\n\t\treturn size;\n\t}\n    vector<int> s() {\n        return sizes ;\n    }\n\tTensor(vector<int> sizes) {\n\t\tthis->sizes = sizes;\n\t\tthis->values.resize(this->numel());\n\t\tfor (int i = 0; i < this->numel(); ++ i) this->values[i] = 0;\n\t}\n\n\tdouble & get(const vector<int> & indexes)  {\n\t\treturn values[this->_index(indexes)];\n\t}\n\tTensor(int t1 = -1 ,int t2 = -1 ,int t3 = -1 ,int t4 = -1) {\n        sizes.push_back(t1);\n        if (t2 != -1) sizes.push_back(t2);\n        if (t3 != -1) sizes.push_back(t3);\n        if (t4 != -1) sizes.push_back(t4);\n        this->values.resize(this->numel());\n    }\n    double & operator ()(int i1 = -1 ,int i2 = -1 ,int i3 = -1 ,int i4 = -1)  {\n        vector<int> indexes;\n        indexes.push_back(i1);\n        if (i2 != -1) indexes.push_back(i2);\n        if (i3 != -1) indexes.push_back(i3);\n        if (i4 != -1) indexes.push_back(i4);\n\t\treturn values[this->_index(indexes)];\n\t}\n};\n",
            1593087743.1021605,
            100,
            "# 答案正确"
        ],
        [
            "9.7 (C++)",
            "肖翎予",
            "#include <vector>\n#include <iostream>\n#include <fstream>\nusing namespace std;\n\nclass Tensor {\n    private:\n    vector <double> value ;\n    int dim ;\n    vector <int> sizes ;\n    int _index(const vector<int> & indexes) const {\n\t\tint index = 0;\n\t\tfor (int i = 0; i < this->sizes.size(); ++ i) {\n\t\t\tindex *= sizes[i];\n\t\t\tindex += indexes[i];\n\t\t}\n\t\treturn index;\n\t}\n    public:\n    int di() {\n        return dim ;\n    }\n    int s(int i) {\n        return sizes[i] ;\n    }\n    Tensor() {\n        dim = 0 ;\n    }\n    int numel() {\n        int lar = 1 ;\n        for(int i = 0 ;i < sizes.size() ; i ++) {\n            lar *= sizes[i] ;\n        }\n        return lar ;\n    }\n    Tensor(vector <int> size_) {\n        dim = size_.size() ;\n        sizes = size_ ;\n        value.resize(numel()) ;\n        for (int i = 0; i < this->numel(); ++ i) this->value[i] = 0;\n    }\n    Tensor(vector <int> size_,vector <double> val_) {\n        dim = size_.size() ;\n        sizes = size_ ;\n        value.resize(numel()) ;\n        for (int i = 0; i < this->numel(); ++ i) this->value[i] = val_[i];\n    }\n    double & get(const vector<int> & indexes) {\n\t\treturn value[this->_index(indexes)];\n\t}\n\tdouble & get(int index) {\n\t\treturn value[index];\n\t}\n} ;\n\n\nint onumel(vector <int> sizes) {\n        int lar = 1 ;\n        for(int i = 0 ;i < sizes.size() ; i ++) {\n            lar *= sizes[i] ;\n        }\n        return lar ;\n}\n\nistream &operator >> (istream &in , Tensor & t) {\n    int lar ;\n    vector <int> sizes ;\n    int nows ;\n    double nowv;\n    vector <double> value ;\n    in >> lar ;\n    for(int i = 0 ; i < lar ;i ++) {\n        in >> nows ;\n        sizes.push_back(nows) ;\n    }\n    for(int i = 0 ; i < onumel(sizes);i ++){\n        in >> nowv ;\n        value.push_back(nowv) ;\n    }\n    Tensor tmp(sizes,value) ;\n    t = tmp ;\n    return in ;\n}\n\nostream &operator << (ostream &out , Tensor & t) {\n    out << t.di() << endl;\n    for(int i = 0 ; i < t.di() ; i ++) out << t.s(i) << \" \" ;\n    out << endl <<endl;\n    if(t.di() > 2){\n        int dim = t.di() ;\n        int bid =t.numel()/(t.s(dim-1)*t.s(dim-2)) ;\n        int row = t.s(dim-2) ;\n        int col =  t.s(dim-1);\n        for(int j = 0 ; j < bid ; j ++) {\n            for(int i = 0 ; i < row; i ++) {\n                for(int k = 0 ; k < col; k ++) {\n                    out << t.get(k+col*i+j*col*row) << \" \" ;\n                }\n                out << endl ;\n            }\n            out << endl ;\n        }\n    }\n    return out ;\n}\n",
            1593088580.2785277,
            100,
            "# 答案正确"
        ],
        [
            "10.2 (C++)",
            "肖翎予",
            "catch (NonPositiveValueException &ex) {\n    cout << \"caught: NonPositiveValueException\" << endl;\n    }\n\ncatch (out_of_range &ex){\n    cout << \"caught: out_of_range\" << endl;\n    }",
            1593659321.5818186,
            100,
            "# 答案正确"
        ],
        [
            "10.1 (C++)",
            "肖翎予",
            "#include <iostream>\n#include<stdexcept>\nusing namespace std;\n\nclass MatrixSizesDoNotMatchException {\npublic:\n    MatrixSizesDoNotMatchException(){\n    }\n};\n\ndouble Matrix:: get(int row, int column)const {\n    if(row < 0 || row > rows)throw out_of_range(\"dev\");\n    if(column < 0 || column > columns)throw out_of_range(\"dev\");\n    int pos = (row - 1) * columns + column - 1;\n    return elements[pos];\n}\n\nvoid Matrix:: set(int row, int column, double value) {\n    if(row < 0 || row > rows)throw out_of_range(\"dev\");\n    if(column < 0 || column > columns)throw out_of_range(\"dev\");\n    int pos = (row - 1) * columns + column - 1;\n    elements[pos] = value;\n}\n\nMatrix Matrix::operator+(const Matrix &matrix2)const {\n   if(rows != matrix2.size(1) || columns != matrix2.size(2))\n   throw MatrixSizesDoNotMatchException();\n   Matrix ans(rows,columns);\n   for(int i = 1; i <= rows; i++) {\n       for(int j = 1; j <= columns; j++) {\n           double ans1 = (*this).get(i,j) + matrix2.get(i,j);\n           ans.set(i,j,ans1);\n       }\n   }\n   return ans;\n}",
            1593662947.5501947,
            100,
            "# 答案正确"
        ],
        [
            "2020-07-09 LAB",
            "肖翎予",
            "#include<iostream>\n#include<vector>\nusing namespace std;\n\nclass Integer{\nprivate:\n    int num;\n    static vector<Integer*> index;\npublic:\n    Integer(): num(0){\n        index.push_back(this);\n    }\n    Integer(int x): num(x){\n        index.push_back(this);\n    }\n    void change_value(const int& x){num = x;}\n    int get_value()const{return num;}\n    static void increase_all(const Integer& x){\n        for(int i = 0;i < index.size();i++){\n            index[i]->change_value(index[i]->get_value()+x.get_value());\n        }\n    }\n};\nvector<Integer*> Integer::index = vector<Integer*>();\n\nistream& operator >> (istream& in,Integer& x){\n    int num;\n    in >> num;\n    x.change_value(num);\n    return in;\n}\nostream& operator << (ostream& out,Integer& x){\n    out << x.get_value();\n    return out;\n}",
            1594264773.2900224,
            100,
            "# 答案正确"
        ],
        [
            "15.1 (C++)",
            "肖翎予",
            "#include <iostream>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n\nclass Table {\n    private:\n    string head;\n    vector <string> s[3];\n    int r;\npublic:\n    Table() {\n        head = \"[]\";\n        r = 0;\n    }\n    void addCol(string a) {\n        head.pop_back();\n        head.push_back('\\'');\n        head+=a;\n        head += \"\\',]\";\n    }\n    vector <string>  & operator [] (int a){\n        r++;\n        return s[a];\n    }\n    string json() const{\n        string io;\n        io+= \"{\";\n        io += \"\\n\\t\";\n        io += \"headers: \";\n        io += head;\n        io += \",\\n\\trows: [\";\n        for(int i = 0; i < r; i++) {\n            io+=\"\\n\\t\\t[]\";\n            for(int k = 0; k < s[i].size(); k++){\n            io.pop_back();\n            io.push_back('\\'');\n            io +=s[i][k];\n            io += \"\\',]\";\n            }\n\t\t\tio.push_back(',');\n        }\n        io +=\"\\n\\t],\";\n        io +=\"\\n}\";\n        return io;\n    }\n};",
            1594267400.1358454,
            100,
            "# 答案正确"
        ],
        [
            "A.2 (C++)",
            "肖翎予",
            "template <typename E>\nvoid LinkedList<E>:: removeAll(const E &e) {\n    if (indexOf(e) == -1)\n        throw NotSuchElementException();\n        int index;\n        while(1) {\n            index = indexOf(e);\n            if(indexOf(e) == -1) return;\n            remove(index);\n        }\n}\n",
            1594868374.4901774,
            100,
            "# 答案正确"
        ],
        [
            "A.1 (C++)",
            "肖翎予",
            "Node <E> * get_next(Node <E> *node) const {\n    if(node == tail) return NULL;\n    Node <E> * prev = head;\n    Node <E> * now  = head;\n    Node <E> * ge  =  head -> next_node(NULL);\n    if(node == head) return ge ;\n    while(1) {\n        if(ge == NULL) return NULL ;\n        prev = ge ;\n        ge = ge -> next_node(now) ;\n        if(prev == node) return ge ;\n        now = prev ;\n    }\n}\n\nNode <E> *get_prev(Node <E> *node) const {\n    if(node == head) return NULL ;\n    Node <E> * next = tail;\n    Node <E> * now  = tail;\n        Node <E> * ge  =  tail -> prev_node(NULL);\n        if(node == tail) return ge ;\n        while(1) {\n            if(ge == NULL ) return NULL ;\n            next = ge ;\n            ge = ge -> prev_node(now) ;\n            if(next == node) return ge ;\n            now = next ;\n        }\n    }\n\nNode<E> * get_node(int index) const {\n\tif (index < 0 || index >= _size)\n\t\tthrow NotSuchElementException();\n\t\tif (index < _size / 2) {\n\t\t\tNode<E> * node = head;\n\t\t\tI(i, index) node = get_next(node);\n\t\t\treturn node;\n\t\t}\n\t\telse {\n\t\t\tNode<E> * node = tail;\n\t\t\tI(i, (_size-1-index)) {\n                node = get_prev(node);\n\t\t\t}\n\t\treturn node;\n\t}\n}\n\nE & get(int index) const {\n\tNode<E> * node = get_node(index);\n\treturn node->element;\n}\n\nvoid set(int index, const E & e) {\n\tNode<E> * node = get_node(index);\n\tnode->element = e;\n}\n\nE & getFirst() const {\n\treturn get(0);\n}\n\nE & getLast() const {\n\treturn get(_size - 1);\n}\nvoid remove (int index) {\n\tNode<E> * node = get_node(index);\n\tNode<E> * prev_node = get_prev(node);\n\tNode<E> * next_node = get_next(node) ;\n\tif (prev_node != 0) prev_node->update_next_node(node, next_node);\n\tif (next_node != 0) next_node->update_prev_node(node,prev_node);\n\tif (prev_node == 0) head = next_node;\n\tif (next_node == 0) tail = prev_node;\n\tdelete node;\n\t--_size;\n}\n\nvoid removeFirst () {\n\tremove(0);\n}\n\nvoid removeLast () {\n\tremove(_size-1);\n}\nvoid add(int index, const E & e) {\n\tif (index < 0 || index > _size)\n\tthrow NotSuchElementException();\n\tNode<E> * node = new Node<E>();\n\tnode->element = e;\n\tNode<E> * next_node = (index == _size ? 0 : get_node(index));\n\tNode<E> * prev_node ;\n\tif(index >= 1)prev_node = (next_node == 0 ? tail : get_node(index-1));\n\telse prev_node = (next_node == 0 ? tail : NULL);\n\tnode -> update_prev_and_next_node(next_node,prev_node) ;\n\tif (prev_node != 0) prev_node->update_next_node(next_node,node);\n\tif (next_node != 0) next_node->update_prev_node(prev_node,node);\n\tif (prev_node == 0) head = node;\n\tif (next_node == 0) tail = node;\n\t++ _size;\n}\n\nvoid addFirst (const E & e) {\n\tadd(0, e);\n}\n\nvoid addLast (const E & e) {\n\tadd(_size, e);\n}\n\nvoid print() {\n    Node <E> *node = head;\n    I(i, _size){\n       cout << node -> element  << \" \" << get_node(i) -> element<<endl ;\n       node =  get_next(node) ;\n    }\n}\n\nvoid clear() {\n\twhile (_size > 0) removeFirst();\n}\n\nvoid addAll(const LinkedList & list, int index=-1) {\n\tif (index == -1) index = _size;\n\tI(i, list._size) {\n\t\tNode<E> * node = list.get_node(i);\n\t\tadd(index + i, node->element);\n\t}\n}\n\nLinkedList(const LinkedList & list) : _size(0), head(0), tail(0) {\n\taddAll(list);\n}\n\nLinkedList & operator = (const LinkedList & list) {\n\tclear();\n\taddAll(list);\n\treturn list;\n}\n\n~LinkedList() {\n\tclear();\n}\n\nint indexOf(const E & e) const {\n\tNode<E> * node = head;\n\tI(i, _size) {\n\t\tif (node->element == e) return i;\n\t\tnode = get_next(node);\n\t}\n\treturn -1;\n}\n\nint lastIndexOf(const E & e) const {\n\tNode<E> * node = tail;\n\tI(i, _size) {\n\t\tif (node->element == e) return i;\n\t\tnode = get_prev(node);\n\t}\n\treturn -1;\n}\n\nbool contains(const E & e) const {\n\treturn indexOf(e) >= 0;\n}\n\nvoid removeFirstOccurrence(const E & e) {\n\tint index = indexOf(e);\n\tif (index == -1)\n\t\tthrow NotSuchElementException();\n\t    remove(index);\n}\n\nvoid removeLastOccurrence(const E & e) {\n\tint index = lastIndexOf(e);\n\tif (index == -1)\n\t\tthrow NotSuchElementException();\n\t    remove(index);\n}",
            1594871970.5342414,
            100,
            "# 答案正确"
        ],
        [
            "A.3 (C++)",
            "肖翎予",
            "#include <string>\n#include <iostream>\n#include<vector>\nusing namespace std;\n#define I(i,n) for (size_t i = 0; i < n; ++ i)\ntemplate <typename E> \nclass HT\n{\n\tclass Tuple\n\t{\n\tpublic:\n\t\tint key;\n\t\tE val;\n\t\tbool in_use;\n\t\tTuple() : in_use(false) {}\n\t};\n\n\tvector<Tuple> tuples; \n\tsize_t _size;\n\n\tsize_t canonical_index(const int & key) const { \n\t\treturn key % tuples.size();\n\t}\n\n\t\n\tsize_t indexOfKey(const int & key) const {\n\t\tsize_t index = canonical_index(key);\n\t\twhile (true) { \n\t\t\tif (! tuples[index].in_use) return index; \n\t\t\tif (tuples[index].key == key) return index;\n\t\t\tindex = (index + 1) % tuples.size();\n\t\t}\n\t}\n\npublic:\n\tHT() : _size(0) {\n\t\ttuples.resize(2);\n\t}\n\n\tbool containsKey(const int & key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\treturn tuples[index].in_use;\n\t}\n\n\tconst E & operator [] (const int & key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\treturn tuples[index].val;\n\t}\n\n\tE & operator [] (const int & key) {\n\t\tsize_t index = indexOfKey(key);\n\t\treturn tuples[index].val;\n\t}\n\n\tvoid put(const int & key, const E & val) {\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].key = key;\n\t\ttuples[index].val = val;\n\t\tif (tuples[index].in_use) return;\n\t\ttuples[index].in_use = true;\n\t\t++ _size;\n\t\tif (2 * _size > tuples.size())\n\t\t\t_double_tuples();\n\t}\n\n\tvoid _double_tuples() {\n\t\tvector<Tuple> non_empty_tuples;\n\t\tI(i, tuples.size())\n\t\t\tif (tuples[i].in_use)\n\t\t\t\tnon_empty_tuples.push_back(tuples[i]);\n\t\tclear();\n\t\ttuples.resize(tuples.size() * 2);\n\t\tI(i, non_empty_tuples.size())\n\t\t\tput(non_empty_tuples[i].key, non_empty_tuples[i].val);\n\t}\n\n\tstatic bool _between(size_t hole, size_t canonical, size_t tuple_index) {\n\t\tif (hole < tuple_index)\n\t\t\treturn canonical > hole && canonical <= tuple_index;\n\t\telse\n\t\t\treturn canonical > hole || canonical <= tuple_index;\n\t}\n\n\tvoid remove(const int & key) { \n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].in_use = false;\n\t\t-- _size;\n\t\t// if there is a hole between a tuple and its canonical position\n\t\t// move the tuple to the hole\n\t\tsize_t hole = index;\n\t\tsize_t tuple_index = hole;\n\t\twhile (true) {\n\t\t\ttuple_index = (tuple_index + 1) % tuples.size();\n\t\t\tif (! tuples[tuple_index].in_use) return;\n\t\t\tsize_t canonical = canonical_index(tuples[tuple_index].key);\n\t\t\tif (_between(hole, canonical, tuple_index)) continue;\n\t\t\ttuples[hole] = tuples[tuple_index];\n\t\t\thole = tuple_index;\n\t\t\ttuples[hole].in_use = false;\n\t\t}\n\t}\n\n\tsize_t size() const { return _size; }\n\n\tvoid clear() {\n\t\tI(i, tuples.size())\n\t\t\ttuples[i].in_use = false;\n\t\t_size = 0;\n\t}\n\tvector<int> getKeys()const{\n\t\tvector<int> ans;\n\t\tfor (int i = 0; i < tuples.size(); ++ i){\n\t\t\tif(tuples[i].in_use){\n\t\t\t\tans.push_back(i);\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n};\n",
            1595471624.7901964,
            100,
            "# 答案正确"
        ],
        [
            "A.4 (C++)",
            "肖翎予",
            "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <stdexcept>\n#include <cstring>\nusing namespace std;\n\n#define I(i,n) for (size_t i = 0; i < n; ++ i)\n\nclass NoSuchKeyException {};\n\nsize_t circular_shift(size_t bits, int shift_bits) {\n\tconst int num_bits = 8 * sizeof(size_t);\n\tshift_bits = shift_bits % num_bits;\n\treturn bits << shift_bits | bits >> (num_bits - shift_bits);\n}\n\nsize_t hash_function(const string & key) {\n\tsize_t code = 0;\n\tI(i, key.size())\n\t\tcode ^= circular_shift(key[i], i * 5);\n\treturn code;\n}\n\nclass turn {\n    string val ;\n    public:\n    turn(string val_) {\n        val = val_ ;\n    }\n    turn (int val_) {\n        val = to_string(val_) ;\n    }\n    operator int() {\n    int get = 0;\n    for(int i = 0 ; i < val.size() ; i ++) {\n        get *= 10 ;\n        get += val[i] - '0';\n    }\n    return get ;\n    }\n    operator string() {\n        return val ;\n    }\n} ;\n\nclass HT\n{\n\tclass Tuple\n\t{\n\tpublic:\n\t\tstring key;\n\t\tstring val;\n\t\tbool in_use;\n\n\t\tTuple() : in_use(false) {}\n\t};\n\n\tvector<Tuple> tuples;\n\tsize_t _size;\n\n\tsize_t canonical_index(const string & key) const {\n\t\tsize_t hash_code = hash_function(key); \n\t\treturn hash_code % tuples.size();\n\t}\n\n\tsize_t indexOfKey(const string & key) const {\n\t\tsize_t index = canonical_index(key);\n\t\twhile (true) { \n\t\t\tif (! tuples[index].in_use) return index;\n\t\t\tif (tuples[index].key == key) return index;\n\t\t\tindex = (index + 1) % tuples.size();\n\t\t}\n\t}\n\npublic:\n\tHT() : _size(0) {\n\t\ttuples.resize(2);\n\t}\n\n\n\tturn  operator [] (const string & key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use)\n\t\t\tthrow NoSuchKeyException();\n\t\tturn now(tuples[index].val);\n\t    return now ;\n\t}\n\t\n\tturn  operator [] (const int & key_) const {\n        string key = to_string(key_) ;\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use)\n\t\t\tthrow NoSuchKeyException();\n\t\tturn now(tuples[index].val);\n\t\treturn now ;\n\t}\n\n\tvoid put(const string & key, const string & val) {\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].key = key;\n\t\ttuples[index].val = val;\n\t\tif (tuples[index].in_use) return;\n\t\ttuples[index].in_use = true;\n\t\t++ _size;\n\t\tif (2 * _size > tuples.size())\n\t\t\t_double_tuples();\n\t}\n\tvoid put(const int & key, const int & val) {\n        string key_ = to_string (key) ;\n        string val_ = to_string (val) ;\n\t\tsize_t index = indexOfKey(key_);\n\t\ttuples[index].key = key_;\n\t\ttuples[index].val = val_;\n\t\tif (tuples[index].in_use) return;\n\t\ttuples[index].in_use = true;\n\t\t++ _size;\n\t\tif (2 * _size > tuples.size())\n\t\t\t_double_tuples();\n\t}\n\tvoid put(const string & key, const int & val) {\n        string val_ = to_string (val) ;\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].key = key;\n\t\ttuples[index].val = val_;\n\t\tif (tuples[index].in_use) return;\n\t\ttuples[index].in_use = true;\n\t\t++ _size;\n\t\tif (2 * _size > tuples.size())\n\t\t\t_double_tuples();\n\t}\n\tvoid put(const int & key, const string & val) {\n        string key_ = to_string (key) ;\n\t\tsize_t index = indexOfKey(key_);\n\t\ttuples[index].key = key_;\n\t\ttuples[index].val = val;\n\t\tif (tuples[index].in_use) return;\n\t\ttuples[index].in_use = true;\n\t\t++ _size;\n\t\tif (2 * _size > tuples.size())\n\t\t\t_double_tuples();\n\t}\n\n\tvoid _double_tuples() {\n\t\tvector<Tuple> non_empty_tuples;\n\t\tI(i, tuples.size())\n\t\t\tif (tuples[i].in_use)\n\t\t\t\tnon_empty_tuples.push_back(tuples[i]);\n\t\tclear();\n\t\ttuples.resize(tuples.size() * 2);\n\t\tI(i, non_empty_tuples.size())\n\t\t\tput(non_empty_tuples[i].key, non_empty_tuples[i].val);\n\t}\n\n\tsize_t size() const { return _size; }\n\n\tvoid clear() {\n\t\tI(i, tuples.size())\n\t\t\ttuples[i].in_use = false;\n\t\t_size = 0;\n\t}\n};\n\n",
            1595834223.676057,
            100,
            "# 答案正确"
        ],
        [
            "A.5 (C++)",
            "肖翎予",
            "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <stdexcept>\n#include <cstring>\nusing namespace std;\n\n#define I(i,n) for (size_t i = 0; i < n; ++ i)\nclass NO {} ;\n\nclass Tuple {\n    public:\n    int key2 ;\n    string val ;\n};\n\nint turn(const string &val){\n        int get = 0;\n        for(int i = 0 ; i < val.size() ; i ++) {\n            get *= 10 ;\n            get += val[i] - '0';\n        }\n        return get ;\n}\n\nclass HT {\n    vector<Tuple> tuples;\n\n    size_t indexof(const int &key) const {\n        I(i , tuples.size()) if(tuples[i].key2 == key) return i ;\n        return -1 ;\n    }\n    size_t indexof(const string &key) const {\n        int key2 = turn(key) ;\n        I(i , tuples.size()) if(tuples[i].key2 == key2) return i ;\n        return -1 ;\n    }\n    public:\n\n    bool constains(const int  &key) const {\n        return indexof(key) != -1 ;\n    }\n    void put(const int &key , const string & val) {\n        size_t index = indexof(key) ;\n        if(index == -1) {\n            Tuple tuple ;\n            tuple.key2 = key ;\n            tuple.val =val ;\n            tuples.push_back(tuple) ;\n        }\n        else {\n            tuples[index].val = val ;\n        }\n    }\n    void put(const string &key_ , const string & val) {\n        int key = turn(key_) ;\n        size_t index = indexof(key) ;\n        if(index == -1) {\n            Tuple tuple ;\n            tuple.key2 = key ;\n            tuple.val =val ;\n            tuples.push_back(tuple) ;\n        }\n        else {\n            tuples[index].val = val ;\n        }\n    }\n    class TupleRef {\n        public :\n        HT *ht ;\n        Tuple * tu ;\n        int key2 ;\n\n        TupleRef(HT *ht , Tuple * tu  ,int key2) : ht(ht) , tu(tu) ,  key2(key2) {};\n\n        operator string() const {\n            if(tu == 0) throw NO() ;\n            return tu -> val ;\n        }\n\n        operator int() const{\n            if(tu == 0) throw NO() ;\n            int get = 0;\n            for(int i = 0 ; i < tu -> val.size() ; i ++) {\n            get *= 10 ;\n            get += tu -> val[i] - '0';\n            }\n            return get ;\n        }\n\n        TupleRef & operator = (const string & val) {\n            if(tu== 0) ht -> put(key2,val) ;\n            else tu-> val = val ;\n            return *this ;\n        }\n        TupleRef & operator = (const int & val_) {\n            const string &val = to_string(val_) ;\n            if(tu== 0) ht -> put(key2,val) ;\n            else tu-> val = val ;\n            return *this ;\n        }\n        };\n        TupleRef operator [] (const int &key) {\n            size_t index = indexof(key) ;\n            if(index == -1) {\n                return TupleRef(this , 0 ,key) ;\n            }\n            return TupleRef(this, &tuples[index],key) ;\n        }\n         TupleRef operator [] (const string &key_) {\n            int key = turn(key_) ;\n            size_t index = indexof(key) ;\n            if(index == -1) {\n                return TupleRef(this , 0 ,key) ;\n            }\n            return TupleRef(this, &tuples[index],key) ;\n        }\n        size_t size() const{\n        return tuples.size() ;\n        }\n} ;",
            1595837845.9942164,
            100,
            "# 答案正确"
        ]
    ],
    "table_name": "答案"
}