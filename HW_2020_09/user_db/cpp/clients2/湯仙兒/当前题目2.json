{
    "__update_time__": 1596199959.693972,
    "field_names": [
        "题目名",
        "问题",
        "主程序",
        "答案",
        "评语",
        "开始时间",
        "截止时间",
        "分数",
        "提交时间"
    ],
    "field_types": [
        "text",
        "text",
        "text",
        "text",
        "text",
        "time",
        "time",
        "number",
        "time"
    ],
    "rows": [
        [
            "A.5 (C++)",
            "<p>写出一个键和值的类型都可以是string或int的哈希表类, HT。<br>本题难度大，参考答案有270行，截止时间延长8天。<br>注意<br></p><ol><li>HT不是一个模版类，但是HT的一个对象可以同时使用int和string的对象作为键。</li><li>HT中去掉了put函数，HT的[]操作符同时具有get和put的功能。</li></ol><p><span style=\"font-weight: bolder;\">EXAMPLE INPUT</span></p><pre style=\"font-size: 14px;\">1 2 3 4 5 6 7 8\n</pre><p><span style=\"font-weight: bolder;\">EXAMPLE OUTPUT</span></p><pre style=\"font-size: 14px;\">4\n2\n4\n6\n8</pre>",
            "#include \"source.cpp\"\n\n#include <iostream>\n#include <sstream>\nusing namespace std;\n\nint main() {\n\tHT map;\n\t\n\tint key1;\n\tint value1;\n\tcin >> key1 >> value1;\n\tmap[key1] = value1;\n\t\n\tstring key2;\n\tstring value2;\n\tcin >> key2 >> value2;\n\tmap[key2] = value2;\n\t\n\tint key3;\n\tstring value3;\n\tcin >> key3 >> value3;\n\tmap[key3] = value3;\n\t\n\tstring key4;\n\tint value4;\n\tcin >> key4 >> value4;\n\tmap[key4] = value4;\n\t\n\tcout << map.size() << endl;\n\tcout << (int)map[key1] << endl;\n\tcout << (string)map[key2] << endl;\n\tcout << (string)map[key3] << endl;\n\tcout << (int)map[key4] << endl;\n}",
            "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <stdexcept>\nusing namespace std;\n\n#define I(i,n) for (size_t i = 0; i < n; ++ i)\n\nclass NoSuchKeyException {};\n\nsize_t circular_shift(size_t bits, int shift_bits) {\n\tconst int num_bits = 8 * sizeof(size_t);\n\tshift_bits = shift_bits % num_bits;\n\treturn bits << shift_bits | bits >> (num_bits - shift_bits);\n}\n\nsize_t hash_function(const string & key) {\n\tsize_t code = 0;\n\tI(i, key.size())\n\t\tcode ^= circular_shift(key[i], i * 5);\n\treturn code;\n}\n\nclass HT\n{\n\tclass Tuple\n\t{\n\tpublic:\n\t\tstring key;\n\t\tstring val;\n\t\tbool in_use;\n\n\t\tTuple() : in_use(false) {}\n\t};\n\n\tvector<Tuple> tuples;\n\tsize_t _size;\n\n\tsize_t canonical_index(const string & key) const {\n\t\tsize_t hash_code = hash_function(key); // needs hash_function(K)\n\t\treturn hash_code % tuples.size();\n\t}\n\n\t// the returned tuple is either empty or with the same key\n\tsize_t indexOfKey(const string & key) const {\n\t\tsize_t index = canonical_index(key);\n\t\twhile (true) { // will enter a dead loop if there is not empty tuple\n\t\t\tif (! tuples[index].in_use) return index;\n\t\t\tif (tuples[index].key == key) return index;\n\t\t\tindex = (index + 1) % tuples.size();\n\t\t}\n\t}\n\npublic:\n\tHT() : _size(0) {\n\t\ttuples.resize(2);\n\t}\n\n\tbool containsKey(const string & key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\treturn tuples[index].in_use;\n\t}\n\t\n\tvoid put(const string & key, const int & val) {\n\t\tstd::string v = std::to_string(val);\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].key = key;\n\t\ttuples[index].val = v;\n\t\tif (tuples[index].in_use) return;\n\t\ttuples[index].in_use = true;\n\t\t++ _size;\n\t\t// make sure empty > size / 2\n\t\tif (2 * _size > tuples.size())\n\t\t\t_double_tuples();\n\t}\n\t\n\tvoid put(const int & key, const int & val) {\n\t\tstd::string v = std::to_string(val);\n\t\tstd::string k = std::to_string(key);\n\t\tsize_t index = indexOfKey(k);\n\t\ttuples[index].key = k;\n\t\ttuples[index].val = v;\n\t\tif (tuples[index].in_use) return;\n\t\ttuples[index].in_use = true;\n\t\t++ _size;\n\t\t// make sure empty > size / 2\n\t\tif (2 * _size > tuples.size())\n\t\t\t_double_tuples();\n\t}\n\t\n\tvoid put(const int & key, const string & val) {\n\t\tstd::string k = std::to_string(key);\n\t\tsize_t index = indexOfKey(k);\n\t\ttuples[index].key = k;\n\t\ttuples[index].val = val;\n\t\tif (tuples[index].in_use) return;\n\t\ttuples[index].in_use = true;\n\t\t++ _size;\n\t\t// make sure empty > size / 2\n\t\tif (2 * _size > tuples.size())\n\t\t\t_double_tuples();\n\t}\n\t\n\tvoid put(const string & key, const string & val) {\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].key = key;\n\t\ttuples[index].val = val;\n\t\tif (tuples[index].in_use) return;\n\t\ttuples[index].in_use = true;\n\t\t++ _size;\n\t\t// make sure empty > size / 2\n\t\tif (2 * _size > tuples.size())\n\t\t\t_double_tuples();\n\t}\n\t\n\tclass TupleRef\n\t{\n\tpublic:\n\t\tHT * dict;\n\t\tTuple * tuple;\n\t\tconst string & key;\n\t\t\n\t\tTupleRef(HT * dict, Tuple * tuple, const string & key) : dict(dict), tuple(tuple), key(key) {}\n\t\t\n\t\toperator int() const {\n\t\t\tif(tuple == 0) throw NoSuchKeyException();\n\t\t\tint res = std::stoi(tuple->val);\n\t\t\treturn res;\n\t\t}\n\t\t\n\t\toperator string() const {\n\t\t\tif(tuple == 0) throw NoSuchKeyException();\n\t\t\t\treturn tuple->val;\n\t\t}\n\t\t\n\t\tTupleRef & operator = (const string & val) {\n\t\t\tif(tuple == 0) dict->put(key, val);\n\t\t\telse tuple->val = val;\n\t\t\treturn *this;\n\t\t}\n\t\t\n\t\tTupleRef & operator = (const int & val) {\n\t\t\tstd::string v = std::to_string(val);\n\t\t\tif(tuple == 0) dict->put(key, v);\n\t\t\telse tuple->val = v;\n\t\t\treturn *this;\n\t\t}\n\t\t\n\t\tvoid operator ~ () {\n\t\t\tif(tuple == 0) throw NoSuchKeyException();\n\t\t\tdict->remove(key);\n\t\t}\n\t};\n\n\t/*const TupleRef operator [] (const string & key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\treturn TupleRef(this, &tuples[index], key);\n\t}\n\t\n\tconst TupleRef operator [] (const int & key) const {\n\t\tstd::string k = std::to_string(key);\n\t\tsize_t index = indexOfKey(k);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\treturn TupleRef(this, &tuples[index], k);\n\t}*/\n\t\n\tTupleRef operator [] (const string & key) {\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\treturn TupleRef(this, 0, key);\n\t\treturn TupleRef(this, &tuples[index], key);\n\t}\n\n\t\n\tTupleRef operator [] (const int & key) {\n\t\tstd::string k = std::to_string(key);\n\t\tsize_t index = indexOfKey(k);\n\t\tif (! tuples[index].in_use) \n\t\t\treturn TupleRef(this, 0, k);\n\t\treturn TupleRef(this, &tuples[index], k);\n\t}\n\n\t/*void put(const string & key, const string & val) {\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].key = key;\n\t\ttuples[index].val = val;\n\t\tif (tuples[index].in_use) return;\n\t\ttuples[index].in_use = true;\n\t\t++ _size;\n\t\t// make sure empty > size / 2\n\t\tif (2 * _size > tuples.size())\n\t\t\t_double_tuples();\n\t}*/\n\n\tvoid _double_tuples() {\n\t\tvector<Tuple> non_empty_tuples;\n\t\tI(i, tuples.size())\n\t\t\tif (tuples[i].in_use)\n\t\t\t\tnon_empty_tuples.push_back(tuples[i]);\n\t\tclear();\n\t\ttuples.resize(tuples.size() * 3);\n\t\tI(i, non_empty_tuples.size()) {\n\t\t\tTupleRef(this, &non_empty_tuples[i], non_empty_tuples[i].key);\n\t\t\t//tuples[i].key = non_empty_tuples[i].key;\n\t\t\t//tuples[i].val = non_empty_tuples[i].val;\n\t\t}\n\t}\n\n\tstatic bool _between(size_t hole, size_t canonical, size_t tuple_index) {\n\t\tif (hole < tuple_index)\n\t\t\treturn canonical > hole && canonical <= tuple_index;\n\t\telse\n\t\t\treturn canonical > hole || canonical <= tuple_index;\n\t}\n\n\tvoid remove(const string & key) { \n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\ttuples[index].in_use = false;\n\t\t-- _size;\n\t\t// if there is a hole between a tuple and its canonical position\n\t\t// move the tuple to the hole\n\t\tsize_t hole = index;\n\t\tsize_t tuple_index = hole;\n\t\twhile (true) {\n\t\t\ttuple_index = (tuple_index + 1) % tuples.size();\n\t\t\tif (! tuples[tuple_index].in_use) return;\n\t\t\tsize_t canonical = canonical_index(tuples[tuple_index].key);\n\t\t\tif (_between(hole, canonical, tuple_index)) continue;\n\t\t\ttuples[hole] = tuples[tuple_index];\n\t\t\thole = tuple_index;\n\t\t\ttuples[hole].in_use = false;\n\t\t}\n\t}\n\n\tsize_t size() const { return _size; }\n\n\tvoid clear() {\n\t\tI(i, tuples.size())\n\t\t\ttuples[i].in_use = false;\n\t\t_size = 0;\n\t}\n\n\tfriend ostream & operator << (ostream & out, const HT & dict);\n\n\tfriend istream & operator >> (istream & in, HT & dict);\n\n\tvoid _inspect() const {\n\t\tI(i, tuples.size())\n\t\t\tif (tuples[i].in_use)\n\t\t\t\tcout << \"#\" << i << \" C\" << canonical_index(tuples[i].key) \n\t\t\t\t\t<< \" \" << tuples[i].key << \" \" << tuples[i].val << endl;\n\t}\n};\n\nostream & operator << (ostream & out, const HT & dict) {\n\tout << dict.size() << endl;\n\tI(i, dict.tuples.size())\n\t\tif (dict.tuples[i].in_use) {\n\t\t\tout << dict.tuples[i].key << \"\\t\" << dict.tuples[i].val << endl;\n\t\t}\n\treturn out;\n}\n\nistream & operator >> (istream & in, HT & dict) {\n\tdict.clear();\n\tsize_t size;\n\tin >> size;\n\tI(i, size) {\n\t\tstring key;\n\t\tstring val;\n\t\tin >> key >> val;\n\t\tdict.put(key, val);\n\t}\n\treturn in;\n}\n\ninline HT load_dict() {\n\tHT dict;\n\tifstream in(\"my_dict.txt\");\n\tif (in.fail())\n\t\tthrow runtime_error(\"Failed to load dictionary\");\n\tin >> dict;\n\tin.close();\n\treturn dict;\n}\n\ninline void save_dict(const HT & dict) {\n\tofstream out(\"my_dict.txt\");\n\tif (out.fail())\n\t\tthrow runtime_error(\"Failed to save dictionary\");\n\tout << dict;\n\tout.close();\n}",
            "In file included from main.cpp:1:0:\nsource.cpp: In member function ‘HT::TupleRef& HT::TupleRef::operator=(const string&)’:\nsource.cpp:139:34: error: cannot call member function ‘size_t HT::indexOfKey(const string&) const’ without object\n     size_t index = indexOfKey(key);\n                                  ^\nsource.cpp:140:38: error: no matching function for call to ‘HT::TupleRef::TupleRef(HT::TupleRef*, HT::Tuple*, const string&)’\n     TupleRef(this, &tuple[index], key);\n                                      ^\nsource.cpp:124:3: note: candidate: HT::TupleRef::TupleRef(HT*, HT::Tuple*, const string&)\n   TupleRef(HT * dict, Tuple * tuple, const string & key) : dict(dict), tuple(tuple), key(key) {}\n   ^\nsource.cpp:124:3: note:   no known conversion for argument 1 from ‘HT::TupleRef*’ to ‘HT*’\nsource.cpp:117:8: note: candidate: constexpr HT::TupleRef::TupleRef(const HT::TupleRef&)\n  class TupleRef\n        ^\nsource.cpp:117:8: note:   candidate expects 1 argument, 3 provided\nsource.cpp:117:8: note: candidate: constexpr HT::TupleRef::TupleRef(HT::TupleRef&&)\nsource.cpp:117:8: note:   candidate expects 1 argument, 3 provided\n",
            1594951200,
            1596200400,
            0,
            1596199894.4515567
        ]
    ]
}