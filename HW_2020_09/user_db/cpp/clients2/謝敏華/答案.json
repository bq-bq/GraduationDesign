{
    "__update_time__": 1596112018.004375,
    "field_names": [
        "题目名",
        "用户名",
        "答案",
        "提交时间",
        "分数",
        "评语"
    ],
    "field_types": [
        "text",
        "text",
        "text",
        "time",
        "number",
        "text"
    ],
    "foreign_keys": {},
    "primary_keys": [],
    "rows": [
        [
            "测试1",
            "謝敏華",
            "#include<iostream>\nusing namespace std;\nint main()\n{\n\tchar s[3][255];\n\tfor(int i=0; i<3; i++) cin>>s[i];\n\tfor(int i=2; i>=0; i--) cout<<s[i]<<\" \";\n}\n",
            1587608819.1664925,
            100,
            "# 答案正确"
        ],
        [
            "测试2",
            "謝敏華",
            "#include<iostream>\n#include<cstring>\nusing namespace std;\nint main()\n{\n\tchar s[10][255];\n\tfor(int i=0; i<10; i++) cin>>s[i];\n\tfor(int i=0; i<9; i++) \n\t\tfor(int j=i+1; j<10; j++){\n\t\t\tif(strcmp(s[i],s[j])>0){\n\t\t\t\tchar t[255];\n\t\t\t\tstrcpy(t,s[i]);\n\t\t\t\tstrcpy(s[i],s[j]);\n\t\t\t\tstrcpy(s[j],t);\n\t\t\t}\n\t\t}\n\tfor(int i=0; i<10; i++) cout<<s[i]<<\" \";\n}\n",
            1587609580.7506351,
            100,
            "# 答案正确"
        ],
        [
            "1.1 (C++)",
            "謝敏華",
            "#include <iostream>\nusing namespace std;\nclass Matrix5x5{\npublic:\n\tdouble matrix[5][5];\n\tMatrix5x5(){\n\t\tfor(int row=0; row<5; row++)\n\t\tfor(int col=0; col<5; col++) this->matrix[row][col]=0;\n\t}\n\tdouble get(int row,int col){\n\t\treturn this->matrix[row][col];\n\t}\n\tvoid set(int row, int col, double value){\n\t\tthis->matrix[row][col]=value;\n\t}\n\n};\nMatrix5x5 operator + (Matrix5x5 &m1,Matrix5x5 &m2){\n\t\tMatrix5x5 m3;\n\t\tfor(int row=0; row<5; row++)\n\t\tfor(int col=0; col<5; col++) \n\t\t\tm3.matrix[row][col]=m1.matrix[row][col]+m2.matrix[row][col];\n\t\treturn m3;\n}",
            1587697410.587472,
            100,
            "# 答案正确"
        ],
        [
            "1.2 (C++)",
            "謝敏華",
            "#include <iostream>\n#include <cstring>\nusing namespace std;\nclass School{\npublic:\n\tchar name[10];\n\tint age;\n\tSchool(){\n\t\tstrcpy(this->name,\"NO_NAME\");\n\t}\n\tvoid setName(char name[]){\n\t\tstrcpy(this->name,name);\n\t}\t\n\tvoid setAge(int age){\n\t\tthis->age=age;\n\t}\n\t~School(){}\n};\nvoid operator ++(School & school){\n\tschool.age++;\n}",
            1588213208.2599316,
            100,
            "# 答案正确"
        ],
        [
            "2.1 (C++)",
            "謝敏華",
            "#include<iostream>\nusing namespace std;\nclass Matrix{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble *values;\npublic:\n\tMatrix(int rows, int columns){\n\t\tthis->rows=rows;\n\t\tthis->columns=columns;\n\t\tthis->values=new double[rows*columns];\n\t\tfor(int i=0; i<=rows*columns; i++) this->values[i]=0;\n\t}\n\t~Matrix(){\n\t}\n\tvoid print(){\n\t\tfor(int i=0; i<this->rows*this->columns; i++){\n\t\t\tprintf(\"%4.0lf \",this->values[i]);\n\t\t\tif( (i+1)%this->columns==0) putchar('\\n');\n\t\t}\n\t}\n}; ",
            1588827361.4240196,
            100,
            "# 答案正确"
        ],
        [
            "2.2 (C++)",
            "謝敏華",
            "#include<iostream>\nusing namespace std;\nclass Matrix{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble *values;\npublic:\n\tMatrix(int rows, int columns, double *values){\n\t\tthis->rows=rows;\n\t\tthis->columns=columns;\n\t\tthis->values=new double[rows*columns];\n\t\tfor(int i=0; i<=rows*columns; i++) this->values[i]=values[i];\n\t}\n\t~Matrix(){\n\t}\n\tvoid print(){\n\t\tfor(int i=0; i<this->rows*this->columns; i++){\n\t\t\tprintf(\"%4.0lf \",this->values[i]);\n\t\t\tif( (i+1)%this->columns==0) putchar('\\n');\n\t\t}\n\t}\n}; ",
            1588827439.8251073,
            100,
            "# 答案正确"
        ],
        [
            "2.3 (C++)",
            "謝敏華",
            "#include<iostream>\nusing namespace std;\nclass Matrix{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble *values;\npublic:\n\tMatrix(int rows, int columns, double *values){\n\t\tthis->rows=rows;\n\t\tthis->columns=columns;\n\t\tthis->values=new double[rows*columns];\n\t\tfor(int i=0; i<=rows*columns; i++) this->values[i]=values[i];\n\t}\n\tMatrix(Matrix & matrix2){\n\t\tthis->rows=matrix2.rows;\n\t\tthis->columns=matrix2.columns;\n\t\tthis->values=new double[rows*columns];\n\t\tfor(int i=0; i<=this->rows*this->columns; i++) \n\t\t\tthis->values[i]=matrix2.values[i];\n\t}\n\t~Matrix(){\n\t}\n\tvoid print(){\n\t\tfor(int i=0; i<this->rows*this->columns; i++){\n\t\t\tprintf(\"    %.0lf\",this->values[i]);\n\t\t\tif( (i+1)%this->columns==0) putchar('\\n');\n\t\t}\n\t}\n}; \n",
            1588827747.5182817,
            100,
            "# 答案正确"
        ],
        [
            "2.5 (C++)",
            "謝敏華",
            "#include<iostream>\nusing namespace std;\nclass Matrix{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble *values;\npublic:\n\tMatrix(int rows, int columns){\n\t\tthis->rows=rows;\n\t\tthis->columns=columns;\n\t\tthis->values=new double[rows*columns];\n\t\tfor(int i=0; i<=rows*columns; i++) this->values[i]=0;\n\t}\n\tMatrix(int rows, int columns, double *values){\n\t\tthis->rows=rows;\n\t\tthis->columns=columns;\n\t\tthis->values=new double[rows*columns];\n\t\tfor(int i=0; i<=rows*columns; i++) this->values[i]=values[i];\n\t}\n\t~Matrix(){\n\t}\n\tvoid print(){\n\t\tfor(int i=0; i<this->rows*this->columns; i++){\n\t\t\tprintf(\"    %.0lf\",this->values[i]);\n\t\t\tif( (i+1)%this->columns==0) putchar('\\n');\n\t\t}\n\t}\n\tMatrix getRow(int row){\n\t\tMatrix a(1,this->columns);\n\t\tint k=(row-1)*this->columns;\n\t\tfor(int i=0; i<a.columns*a.rows; i++)\n\t\t\ta.values[i]=this->values[k+i];\t\t\n\t\treturn a;\n\t}\n\tMatrix getColumn(int column){\n\t\tMatrix a(this->rows,1);\n\t\tint k=column-1;\n\t\tfor(int i=0; i<a.columns*a.rows; i++){\n\t\t\ta.values[i]=this->values[k];\n\t\t\tk+=this->columns;\t\t\n\t\t}\t\t\t\n\t\treturn a;\n\t}\n}; ",
            1588829184.3807552,
            100,
            "# 答案正确"
        ],
        [
            "2.6 (C++)",
            "謝敏華",
            "#include<iostream>\nusing namespace std;\nclass Matrix{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble *values;\npublic:\n\tMatrix(int rows, int columns){\n\t\tthis->rows=rows;\n\t\tthis->columns=columns;\n\t\tthis->values=new double[rows*columns];\n\t\tfor(int i=0; i<=rows*columns; i++) this->values[i]=0;\n\t}\n\tMatrix(int rows, int columns, double *values){\n\t\tthis->rows=rows;\n\t\tthis->columns=columns;\n\t\tthis->values=new double[rows*columns];\n\t\tfor(int i=0; i<=rows*columns; i++) this->values[i]=values[i];\n\t}\n\tMatrix(const Matrix & matrix2){\n\t\tthis->rows=matrix2.rows;\n\t\tthis->columns=matrix2.columns;\n\t\tthis->values=new double[rows*columns];\n\t\tfor(int i=0; i<=this->rows*this->columns; i++) \n\t\t\tthis->values[i]=matrix2.values[i];\n\t}\n\t~Matrix(){\n\t}\n\tvoid print(){\n\t\tfor(int i=0; i<this->rows*this->columns; i++){\n\t\t\tprintf(\"    %.0lf\",this->values[i]);\n\t\t\tif( (i+1)%this->columns==0) putchar('\\n');\n\t\t}\n\t}\n\tMatrix concatenateRows(const Matrix &matrix2){\n\t\tMatrix t(this->rows+matrix2.rows,this->columns);\n\t\tint k=0;\n\t\tfor(int i=0; i<this->rows*this->columns; i++) t.values[k++]=this->values[i];\n\t\tfor(int i=0; i<matrix2.rows*matrix2.columns; i++) t.values[k+i]=matrix2.values[i];\n\t\treturn t;\n\t}\n\t\n\tMatrix concatenateColumns(const Matrix &matrix2){\n\t\tMatrix t(this->rows,this->columns+matrix2.columns);\n\t\tint k=0;\n\t\tfor(int i=0; i<this->rows; i++){\n\t\t\tint sta1=i*this->columns,sta2=i*matrix2.columns;\n\t\t\tfor(int j=0; j<this->columns; j++)\n\t\t\t\tt.values[k++]=this->values[sta1+j];\n\t\t\tfor(int j=0; j<this->columns; j++)\n\t\t\t\tt.values[k++]=matrix2.values[sta2+j];\t\n\t\t}\n\t\treturn t;\n\t}\n}; ",
            1588831809.7040634,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/08",
            "謝敏華",
            "double & Tensor_get(int dimensions, const int sizes[],double data[], int x0, int x1, int x2, int x3){\n\t\tint ans;\n\t\tif(dimensions==1) ans=x0;\n\t\tif(dimensions==2) ans=x0*sizes[1]+x1;\n\t\tif(dimensions==3) ans=x0*sizes[1]*sizes[2]+x1*sizes[2]+x2;\n\t\tif(dimensions==4) ans=x0*sizes[1]*sizes[2]*sizes[3]+x1*sizes[2]*sizes[3]+x2*sizes[3]+x3;\n\t\treturn data[ans];\n} ",
            1588908157.7426674,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/14",
            "謝敏華",
            "#include <iostream>\nusing namespace std;\t\nvoid Tensor_print(int dimensions, const int sizes[], const double *data){\n\t\tprintf(\"Tensor of %d\",sizes[0]);\n\t\tif(dimensions>1) printf(\"x%d\",sizes[1]); \n\t\tif(dimensions>2) printf(\"x%d\",sizes[2]); \n\t\tif(dimensions>3) printf(\"x%d\",sizes[3]); \n\t\tputchar('\\n');\n\t\t\n\t\tif(dimensions==1){\n\t\t\tfor(int i=0; i<sizes[0]; i++){\n\t\t\t\tcout<<data[i];\n\t\t\t\tputchar('\\n');\n\t\t\t}\n\t\t}\n\t\tif(dimensions==2){\n\t\t\tfor(int i=0; i<sizes[0]; i++){\n\t\t\t\tfor(int j=0; j<sizes[1];j++){\n\t\t\t\t\tint index = i * sizes[1] + j;\n\t\t\t\t\tcout<<\"    \"<<data[index];\n\t\t\t\t}\n\t\t\t\tputchar('\\n');\n\t\t\t}\n\t\t}\n\t\tif(dimensions==3){\n\t\t\tfor(int i=0; i<sizes[0]; i++){\n\t\t\t\tprintf(\"data[%d]\\n\",i);\n\t\t\t\tfor(int j=0; j<sizes[1];j++){\n\t\t\t\t\tfor(int k=0; k<sizes[2];k++){\n\t\t\t\t\t\tint index = (i * sizes[1] + j) * sizes[2] + k;\n\t\t\t\t\t\tcout<<\"    \"<<data[index];\n\t\t\t\t\t}\n\t\t\t\t\tputchar('\\n');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dimensions==4){\n\t\t\tfor(int i=0; i<sizes[0]; i++){\n\t\t\t\tfor(int j=0; j<sizes[1];j++){\n\t\t\t\t\tprintf(\"data[%d][%d]\\n\",i,j);\n\t\t\t\t\tfor(int k=0; k<sizes[2];k++){\n\t\t\t\t\t\tfor(int l=0; l<sizes[3]; l++){\n\t\t\t\t\t\t\tint index = ((i * sizes[1] + j) * sizes[2] + k) * sizes[3] + l;\n\t\t\t\t\t\t\tcout<<\"    \"<<data[index];\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\tputchar('\\n');\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n} ",
            1589424778.9728186,
            100,
            "# 答案正确"
        ],
        [
            "2.4 (C++)",
            "謝敏華",
            "#include<iostream>\nusing namespace std; \nclass Matrix{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble *values;\npublic:\n\tMatrix(int rows, int columns){\n\t\tthis->rows=rows;\n\t\tthis->columns=columns;\n\t\tthis->values=new double[rows*columns];\n\t\tfor(int i=0; i<rows*columns; i++) this->values[i]=0;\n\t}\n\tMatrix(int rows, int columns, double *values){\n\t\tthis->rows=rows;\n\t\tthis->columns=columns;\n\t\tthis->values=new double[rows*columns];\n\t\tfor(int i=0; i<rows*columns; i++) this->values[i]=values[i];\n\t}\n\t~Matrix(){\n\t\tdelete [] this->values;\n\t}\n\tvoid print(){\n\t\tfor(int i=0; i<this->rows*this->columns; i++){\n\t\t\tcout<<\"    \"<<this->values[i];\n\t\t\tif( (i+1)%this->columns==0) putchar('\\n');\n\t\t}\n\t}\n\tvoid set(int row,int column,double value){\n\t\tint index=(row-1)*(this->columns)+column-1;\n\t\tthis->values[index]=value;\n\t}\n\tMatrix & operator = (const Matrix &matrix1){\n\t\tdouble *temp=new double[matrix1.rows*matrix1.columns];\n\t\tfor(int i=0; i<matrix1.rows*matrix1.columns; i++) temp[i]=matrix1.values[i];\n\t\tdelete [] this->values;\n\t\tthis->rows=matrix1.rows;\n\t\tthis->columns=matrix1.columns;\n\t\tthis->values=temp;\n\t\treturn *this;\n\t} \n};",
            1589523558.945813,
            100,
            "# 答案正确"
        ],
        [
            "2.7 (C++)",
            "謝敏華",
            "#include<iostream>\nusing namespace std; \nclass Matrix{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble *values;\npublic:\n\tMatrix(int rows, int columns){\n\t\tthis->rows=rows;\n\t\tthis->columns=columns;\n\t\tthis->values=new double[rows*columns];\n\t\tfor(int i=0; i<rows*columns; i++) this->values[i]=0;\n\t}\n\tMatrix(int rows, int columns, double *values){\n\t\tthis->rows=rows;\n\t\tthis->columns=columns;\n\t\tthis->values=new double[rows*columns];\n\t\tfor(int i=0; i<rows*columns; i++) this->values[i]=values[i];\n\t}\n\t~Matrix(){\n\t\tdelete [] this->values;\n\t}\n\tvoid print(){\n\t\tfor(int i=0; i<this->rows*this->columns; i++){\n\t\t\tcout<<\"    \"<<this->values[i];\n\t\t\tif( (i+1)%this->columns==0) putchar('\\n');\n\t\t}\n\t}\n\tvoid set(int row,int column,double value){\n\t\tint index=(row-1)*(this->columns)+column-1;\n\t\tthis->values[index]=value;\n\t}\n\tMatrix & operator = (const Matrix &matrix1){\n\t\tdouble *temp=new double[matrix1.rows*matrix1.columns];\n\t\tfor(int i=0; i<matrix1.rows*matrix1.columns; i++) temp[i]=matrix1.values[i];\n\t\tdelete [] this->values;\n\t\tthis->rows=matrix1.rows;\n\t\tthis->columns=matrix1.columns;\n\t\tthis->values=temp;\n\t\treturn *this;\n\t} \n\tMatrix(const Matrix &matrix2){\n\t\tthis->rows=matrix2.rows;\n\t\tthis->columns=matrix2.columns;\n\t\tthis->values=new double[rows*columns];\n\t\tfor(int i=0; i<rows*columns; i++) this->values[i]=matrix2.values[i];\n\t}\n\tMatrix reshape(int rows,int columns);\n};\nMatrix Matrix::reshape(int rows,int columns){\n\tMatrix matrix2(rows,columns);\n\tint i,j,x=0,y=0;\n\tfor(j=0; j < matrix2.columns; j++){\n\t\tfor(i=0; i < matrix2.rows; i++){\n\t\t\tint index1=i*matrix2.columns + j;\n\t\t\tint index2=x*this->columns+y;\n\t\t\tmatrix2.values[index1]=this->values[index2];\n\t\t\t++x;\n\t\t\tif(x==this->rows){\n\t\t\t\t++y; \n\t\t\t\tx=0;\n\t\t\t}\n\t\t} \n\t }\n\t return matrix2; \n}",
            1589527465.9546354,
            100,
            "# 答案正确"
        ],
        [
            "2.8 (C++)",
            "謝敏華",
            "#include<iostream>\nusing namespace std; \nclass Matrix{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble *values;\npublic:\n\tMatrix(int rows, int columns){\n\t\tthis->rows=rows;\n\t\tthis->columns=columns;\n\t\tthis->values=new double[rows*columns];\n\t\tfor(int i=0; i<rows*columns; i++) this->values[i]=0;\n\t}\n\tMatrix(int rows, int columns, double *values){\n\t\tthis->rows=rows;\n\t\tthis->columns=columns;\n\t\tthis->values=new double[rows*columns];\n\t\tfor(int i=0; i<rows*columns; i++) this->values[i]=values[i];\n\t}\n\t~Matrix(){\n\t\tdelete [] this->values;\n\t}\n\tvoid print(){\n\t\tfor(int i=0; i<this->rows*this->columns; i++){\n\t\t\tcout<<\"    \"<<this->values[i];\n\t\t\tif( (i+1)%this->columns==0) putchar('\\n');\n\t\t}\n\t}\n\tvoid set(int row,int column,double value){\n\t\tint index=(row-1)*(this->columns)+column-1;\n\t\tthis->values[index]=value;\n\t}\n\tMatrix & operator = (const Matrix &matrix1){\n\t\tdouble *temp=new double[matrix1.rows*matrix1.columns];\n\t\tfor(int i=0; i<matrix1.rows*matrix1.columns; i++) temp[i]=matrix1.values[i];\n\t\tdelete [] this->values;\n\t\tthis->rows=matrix1.rows;\n\t\tthis->columns=matrix1.columns;\n\t\tthis->values=temp;\n\t\treturn *this;\n\t} \n\tMatrix(const Matrix &matrix2){\n\t\tthis->rows=matrix2.rows;\n\t\tthis->columns=matrix2.columns;\n\t\tthis->values=new double[rows*columns];\n\t\tfor(int i=0; i<rows*columns; i++) this->values[i]=matrix2.values[i];\n\t}\n\tMatrix reshape(int rows,int columns);\n\tMatrix transpose();\n};\nMatrix Matrix::reshape(int rows,int columns){\n\tMatrix matrix2(rows,columns);\n\tint i,j,x=0,y=0;\n\tfor(j=0; j < matrix2.columns; j++){\n\t\tfor(i=0; i < matrix2.rows; i++){\n\t\t\tint index1=i*matrix2.columns + j;\n\t\t\tint index2=x*this->columns+y;\n\t\t\tmatrix2.values[index1]=this->values[index2];\n\t\t\t++x;\n\t\t\tif(x==this->rows){\n\t\t\t\t++y; \n\t\t\t\tx=0;\n\t\t\t}\n\t\t} \n\t }\n\t return matrix2; \n}\nMatrix Matrix::transpose(){\n\tMatrix matrix2(columns,rows);\n\tfor(int i=0; i<this->rows; i++){\n\t\tfor(int j=0; j<this->columns; j++){\n\t\t\tint index1=i*this->columns+j;\n\t\t\tint index2=j*this->rows+i;\n\t\t\tmatrix2.values[index2]=this->values[index1];\n\t\t}\n\t}\n\treturn matrix2;\n}",
            1589529091.546494,
            100,
            "# 答案正确"
        ],
        [
            "2.10 (C++)",
            "謝敏華",
            "#include<iostream>\nusing namespace std; \nclass Matrix{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble *values;\npublic:\n\tMatrix(int rows, int columns){\n\t\tthis->rows=rows;\n\t\tthis->columns=columns;\n\t\tthis->values=new double[rows*columns];\n\t\tfor(int i=0; i<rows*columns; i++) this->values[i]=0;\n\t}\n\tMatrix(int rows, int columns, double *values){\n\t\tthis->rows=rows;\n\t\tthis->columns=columns;\n\t\tthis->values=new double[rows*columns];\n\t\tfor(int i=0; i<rows*columns; i++) this->values[i]=values[i];\n\t}\n\t~Matrix(){\n\t\tdelete [] this->values;\n\t}\n\tvoid print(){\n\t\tfor(int i=0; i<this->rows*this->columns; i++){\n\t\t\tcout<<\"    \"<<this->values[i];\n\t\t\tif( (i+1)%this->columns==0) putchar('\\n');\n\t\t}\n\t}\n\tvoid set(int row,int column,double value){\n\t\tint index=(row-1)*(this->columns)+column-1;\n\t\tthis->values[index]=value;\n\t}\n\tMatrix & operator = (const Matrix &matrix1){\n\t\tdouble *temp=new double[matrix1.rows*matrix1.columns];\n\t\tfor(int i=0; i<matrix1.rows*matrix1.columns; i++) temp[i]=matrix1.values[i];\n\t\tdelete [] this->values;\n\t\tthis->rows=matrix1.rows;\n\t\tthis->columns=matrix1.columns;\n\t\tthis->values=temp;\n\t\treturn *this;\n\t} \n\tMatrix(const Matrix &matrix2){\n\t\tthis->rows=matrix2.rows;\n\t\tthis->columns=matrix2.columns;\n\t\tthis->values=new double[rows*columns];\n\t\tfor(int i=0; i<rows*columns; i++) this->values[i]=matrix2.values[i];\n\t}\n\tMatrix operator *(const Matrix & matrix2) const{\n\t\tMatrix temp(this->rows,matrix2.columns);\n\t\tfor(int i=0; i<temp.rows ; i++){\n\t\t\tfor(int j=0; j<temp.columns ; j++){\n\t\t\t\tint val=0,row=i*this->columns,column=j,times=row+this->columns;\n\t\t\t\twhile(row<times){\n\t\t\t\t\tval+=this->values[row]*matrix2.values[column];\n\t\t\t\t\trow++; column+=matrix2.columns;\n\t\t\t\t}\n\t\t\t\tint index=i*temp.columns+j;\n\t\t\t\ttemp.values[index]=val;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\treturn temp;\n\t}\n\tMatrix operator *(double value) const{\n\t\tMatrix temp(this->rows,this->columns,this->values);\n\t\tint ele=rows*columns;\n\t\tfor(int i=0 ; i<ele ; i++) temp.values[i]*=value;\n\t\treturn temp;\n\t}\n\t\n};",
            1589557185.2558959,
            100,
            "# 答案正确"
        ],
        [
            "2.11 (C++)",
            "謝敏華",
            "#include<iostream>\nusing namespace std; \nclass Matrix{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble *values;\npublic:\n\tMatrix(int rows, int columns){\n\t\tthis->rows=rows;\n\t\tthis->columns=columns;\n\t\tthis->values=new double[rows*columns];\n\t\tfor(int i=0; i<rows*columns; i++) this->values[i]=0;\n\t}\n\tMatrix(int rows, int columns, double *values){\n\t\tthis->rows=rows;\n\t\tthis->columns=columns;\n\t\tthis->values=new double[rows*columns];\n\t\tfor(int i=0; i<rows*columns; i++) this->values[i]=values[i];\n\t}\n\t~Matrix(){\n\t\tdelete [] this->values;\n\t}\n\tvoid print(){\n\t\tfor(int i=0; i<this->rows*this->columns; i++){\n\t\t\tcout<<\"    \"<<this->values[i];\n\t\t\tif( (i+1)%this->columns==0) putchar('\\n');\n\t\t}\n\t}\n\tvoid set(int row,int column,double value){\n\t\tint index=(row-1)*(this->columns)+column-1;\n\t\tthis->values[index]=value;\n\t}\n\tMatrix & operator = (const Matrix &matrix1){\n\t\tdouble *temp=new double[matrix1.rows*matrix1.columns];\n\t\tfor(int i=0; i<matrix1.rows*matrix1.columns; i++) temp[i]=matrix1.values[i];\n\t\tdelete [] this->values;\n\t\tthis->rows=matrix1.rows;\n\t\tthis->columns=matrix1.columns;\n\t\tthis->values=temp;\n\t\treturn *this;\n\t} \n\tMatrix(const Matrix &matrix2){\n\t\tthis->rows=matrix2.rows;\n\t\tthis->columns=matrix2.columns;\n\t\tthis->values=new double[rows*columns];\n\t\tfor(int i=0; i<rows*columns; i++) this->values[i]=matrix2.values[i];\n\t}\n\tMatrix max()const{\n\t\tif(this->rows==1)\t{\n\t\t\tMatrix temp(1,1);\n\t\t\tint maxval=0;\n\t\t\tfor(int i=0; i<this->columns; i++){\n\t\t\t\tmaxval=this->values[i] > maxval? this->values[i]:maxval;\n\t\t\t}\n\t\t\ttemp.values[0]=maxval;\n\t\t\treturn temp;\n\t\t}else{\n\t\t\tMatrix temp(1,this->columns);\n\t\t\tfor(int j=0; j<this->columns; j++){\n\t\t\t\tint y=j,times=0,maxval=0;\n\t\t\t\twhile(times<this->rows){\n\t\t\t\t\tmaxval=this->values[y]>maxval? this->values[y]:maxval;\n\t\t\t\t\ty+=this->columns;\n\t\t\t\t\ttimes++;\n\t\t\t\t}\n\t\t\t\ttemp.values[j]=maxval;\n\t\t\t}\n\t\t\treturn temp;\n\t\t}\n\t}\n\tMatrix min()const{\n\t\tif(this->rows==1)\t{\n\t\t\tMatrix temp(1,1);\n\t\t\tint minval=1e9;\n\t\t\tfor(int i=0; i<this->columns; i++){\n\t\t\t\tminval=this->values[i] < minval? this->values[i]:minval;\n\t\t\t}\n\t\t\ttemp.values[0]=minval;\n\t\t\treturn temp;\n\t\t}else{\n\t\t\tMatrix temp(1,this->columns);\n\t\t\tfor(int j=0; j<this->columns; j++){\n\t\t\t\tint y=j,times=0,minval=1e9;\n\t\t\t\twhile(times<this->rows){\n\t\t\t\t\tminval=this->values[y]<minval? this->values[y]:minval;\n\t\t\t\t\ty+=this->columns;\n\t\t\t\t\ttimes++;\n\t\t\t\t}\n\t\t\t\ttemp.values[j]=minval;\n\t\t\t}\n\t\t\treturn temp;\n\t\t}\n\t}\n\n\tMatrix sum(){\n\t\tif(this->rows==1){\n\t\t\tint val=0;\n\t\t\tfor(int i=0; i<this->columns ; i++) \n\t\t\t\t val+=this->values[i];\n\t\t\tMatrix temp(1,1);\n\t\t\ttemp.values[0]=val;\n\t\t\treturn temp;\n\t\t}else{\n\t\t\tMatrix temp(1,this->columns);\n\t\t\tfor(int j=0; j<this->columns; j++){\n\t\t\t\tint y=j,times=0,val=0;\n\t\t\t\twhile(times<this->rows){\n\t\t\t\t\tval+=this->values[y];\n\t\t\t\t\ty+=this->columns;\n\t\t\t\t\ttimes++;\n\t\t\t\t}\n\t\t\t\ttemp.values[j]=val;\n\t\t\t}\t\n\t\t\treturn temp;\n\t\t}\n\t}\n};",
            1589561361.4136307,
            100,
            "# 答案正确"
        ],
        [
            "2.12 (C++)",
            "謝敏華",
            "#include<iostream>\n#include<math.h> \nusing namespace std; \nclass Matrix{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble *values;\npublic:\n\tMatrix(int rows, int columns){\n\t\tthis->rows=rows;\n\t\tthis->columns=columns;\n\t\tthis->values=new double[rows*columns];\n\t\tfor(int i=0; i<rows*columns; i++) this->values[i]=0;\n\t}\n\tMatrix(int rows, int columns, double *values){\n\t\tthis->rows=rows;\n\t\tthis->columns=columns;\n\t\tthis->values=new double[rows*columns];\n\t\tfor(int i=0; i<rows*columns; i++) this->values[i]=values[i];\n\t}\n\t~Matrix(){\n\t\tdelete [] this->values;\n\t}\n\tvoid print(){\n\t\tfor(int i=0; i<this->rows*this->columns; i++){\n\t\t\tcout<<\"    \"<<this->values[i];\n\t\t\tif( (i+1)%this->columns==0) putchar('\\n');\n\t\t}\n\t}\n\tvoid set(int row,int column,double value){\n\t\tint index=(row-1)*(this->columns)+column-1;\n\t\tthis->values[index]=value;\n\t}\n\tMatrix & operator = (const Matrix &matrix1){\n\t\tdouble *temp=new double[matrix1.rows*matrix1.columns];\n\t\tfor(int i=0; i<matrix1.rows*matrix1.columns; i++) temp[i]=matrix1.values[i];\n\t\tdelete [] this->values;\n\t\tthis->rows=matrix1.rows;\n\t\tthis->columns=matrix1.columns;\n\t\tthis->values=temp;\n\t\treturn *this;\n\t} \n\tMatrix(const Matrix &matrix2){\n\t\tthis->rows=matrix2.rows;\n\t\tthis->columns=matrix2.columns;\n\t\tthis->values=new double[rows*columns];\n\t\tfor(int i=0; i<rows*columns; i++) this->values[i]=matrix2.values[i];\n\t}\n\tMatrix pow(double exponent){\n\t\tMatrix t(this->rows,this->columns);\n\t\tfor(int i=0 ; i<this->rows*this->columns ; i++)\n\t\t\tt.values[i]=::pow(this->values[i],exponent);\n\t\treturn t;\t\n\t} \n\tMatrix exp(){\n\t\tMatrix t(this->rows,this->columns);\n\t\tfor(int i=0 ; i<this->rows*this->columns ; i++)\n\t\tt.values[i]=::exp(this->values[i]);\n\t\treturn t;\t\n\t}\n\tMatrix log(){\n\t\tMatrix t(this->rows,this->columns);\n\t\tfor(int i=0 ; i<this->rows*this->columns ; i++)\n\t\tt.values[i]=::log(this->values[i]);\n\t\treturn t;\t\n\t}\n\tMatrix abs(){\n\t\tMatrix t(this->rows,this->columns);\n\t\tfor(int i=0 ; i<this->rows*this->columns ; i++)\n\t\tt.values[i]=::abs(this->values[i]);\n\t\treturn t;\n\t}\n};",
            1589599082.4004834,
            100,
            "# 答案正确"
        ],
        [
            "2.9 (C++)",
            "謝敏華",
            "#include<iostream>\nusing namespace std; \nclass Matrix{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble *values;\npublic:\n\tMatrix(int rows, int columns, double *values){\n\t\tthis->rows=rows;\n\t\tthis->columns=columns;\n\t\tthis->values=new double[rows*columns];\n\t\tfor(int i=0; i<rows*columns; i++) this->values[i]=values[i];\n\t}\n\tMatrix(const Matrix &matrix2){\n\t\tthis->rows=matrix2.rows;\n\t\tthis->columns=matrix2.columns;\n\t\tthis->values=new double[rows*columns];\n\t\tfor(int i=0; i<rows*columns; i++) this->values[i]=matrix2.values[i];\n\t}\n\t~Matrix(){\n\t\tdelete [] this->values;\n\t}\n\tvoid print(){\n\t\tfor(int i=0; i<this->rows*this->columns; i++){\n\t\t\tcout<<\"    \"<<this->values[i];\n\t\t\tif( (i+1)%this->columns==0) putchar('\\n');\n\t\t}\n\t}\n\tMatrix operator + (const Matrix &matrix2) const{\n\t\tdouble v[rows*columns];\n\t\tfor(int i=0; i<rows*columns; i++)\n\t\t\tv[i]=this->values[i]+matrix2.values[i];\n\t\tMatrix temp(this->rows,this->columns,v);\n\t\treturn temp;\t\t\n\t} \n\tMatrix operator -(const Matrix & matrix2) const{\n\t\tdouble v[rows*columns];\n\t\tfor(int i=0; i<rows*columns; i++)\n\t\t\tv[i]=this->values[i]-matrix2.values[i];\n\t\tMatrix temp(this->rows,this->columns,v);\n\t\treturn temp;\n\t}\n\tMatrix operator + (double value) const{\n\t\tdouble v[rows*columns];\n\t\tfor(int i=0; i<rows*columns; i++)\n\t\t\tv[i]=this->values[i]+value;\n\t\tMatrix temp(this->rows,this->columns,v);\n\t\treturn temp;\t\t\n\t} \n\tMatrix operator -(double value) const{\n\t\tdouble v[rows*columns];\n\t\tfor(int i=0; i<rows*columns; i++)\n\t\t\tv[i]=this->values[i]-value;\n\t\tMatrix temp(this->rows,this->columns,v);\n\t\treturn temp;\n\t}\n};",
            1590027529.2076476,
            100,
            "# 答案正确"
        ],
        [
            "6.1 (C++)",
            "謝敏華",
            "#include <iostream>\n#include <string>\n#include<vector>\n#include<memory.h>\nusing namespace std;\ntemplate <typename T>\nclass Matrix{ \nprivate:\n\tint rows;\n\tint columns;\n\tT *values;\npublic:\n\tMatrix(int rows, int columns){\n\t\tthis->rows=rows;\n\t\tthis->columns=columns;\n\t\tthis->values=new T[rows*columns];\n\t\tmemset(this->values,0,sizeof(T)*rows*columns);\n\t}\n\tMatrix(int rows, int columns,const T *values){\n\t\tthis->rows=rows;\n\t\tthis->columns=columns;\n\t\tthis->values=new T[rows*columns];\n\t\tfor(int i=0; i<rows*columns; i++) this->values[i]=values[i];\n\t}\n\t~Matrix(){\n\t\tdelete [] this->values;\n\t}\n\tvoid print(){\n\t\tfor(int i=0; i<this->rows*this->columns; i++){\n\t\t\tcout<<\"    \"<<this->values[i];\n\t\t\tif( (i+1)%this->columns==0) putchar('\\n');\n\t\t}\n\t}\n\n\tMatrix & operator = (const Matrix &matrix1){\n\t\tT *temp=new T[matrix1.rows*matrix1.columns];\n\t\tfor(int i=0; i<matrix1.rows*matrix1.columns; i++) temp[i]=matrix1.values[i];\n\t\tdelete [] this->values;\n\t\tthis->rows=matrix1.rows;\n\t\tthis->columns=matrix1.columns;\n\t\tthis->values=temp;\n\t\treturn *this;\n\t} \n\n\tMatrix(const Matrix &matrix2){\n\t\tthis->rows=matrix2.rows;\n\t\tthis->columns=matrix2.columns;\n\t\tthis->values=new T[rows*columns];\n\t\tfor(int i=0; i<rows*columns; i++) this->values[i]=matrix2.values[i];\n\t}\n\tT &get(int x,int y){\n\t\treturn this->values[(x-1)*columns+y-1];\n\t} \n};",
            1590123559.108888,
            100,
            "# 答案正确"
        ],
        [
            "6.3 (C++)",
            "謝敏華",
            "#include <iostream>\n#include <string>\n#include<vector>\n#include<memory.h>\nusing namespace std;\ntemplate <typename T>\nclass Matrix{ \nprivate:\n\tint rows;\n\tint columns;\n\tvector<T> values;\npublic:\n\tMatrix(int rows, int columns){\n\t\tthis->rows=rows;\n\t\tthis->columns=columns;\n\t\tfor(int i=0; i<rows*columns ;i++) values.push_back(0);\n\t}\n\tMatrix(int rows, int columns,const vector<T> value){\n\t\tthis->rows=rows;\n\t\tthis->columns=columns;\n\t\tfor(int i=0; i<rows*columns; i++) values.push_back(value[i]);\n\t}\n\tvoid print(){\n\t\tfor(int i=0; i<this->rows*this->columns; i++){\n\t\t\tcout<<\"    \"<<this->values[i];\n\t\t\tif( (i+1)%this->columns==0) putchar('\\n');\n\t\t}\n\t}\n\tT & get(int x, int y){\n\t\treturn values[(x-1)*columns+y-1];\n\t}\n\tMatrix getColumn(int col){\n\t\tMatrix t(rows,1);\n\t\tfor(int i=0; i<rows ; i++){\n\t\t\tt.values[i]=this->values[i*columns+col-1];\n\t\t}\n\t\treturn t;\n\t}\n\tMatrix getRow(int row){\n\t\tMatrix t(1,columns);\n\t\tfor(int i=0; i<columns ; i++){\n\t\t\tt.values[i]=this->values[(row-1)*columns+i];\n\t\t}\n\t\treturn t;\n\t}\n\tMatrix concatenateRows(Matrix & matrix2){\n\t\tvector<T> v;\n\t\tfor(int i=0; i<rows*columns ; i++) v.push_back(this->values[i]);\n\t\tfor(int i=0; i<matrix2.rows*matrix2.columns ; i++) v.push_back(matrix2.values[i]);\n\t\tMatrix t(rows+matrix2.rows,columns,v);\n\t\treturn t;\n\t}\n\tMatrix concatenateColumns(Matrix & matrix2){\n\t\tvector<T> v;\n\t\tfor(int i=0 ; i<rows; i++){\n\t\t\tfor(int j=0 ; j<columns ; j++) v.push_back(this->values[i*columns+j]);\n\t\t\tfor(int j=0 ; j<matrix2.columns ; j++) v.push_back(matrix2.values[i*columns+j]);\n\t\t}\n\t\tMatrix t(rows, columns+matrix2.columns,v);\n\t\treturn t;\n\t}\n\tMatrix reshape(int row,int col){\n\t\tMatrix t(row,col);\n\t\tint x=0,y=0;\n\t\tfor(int i=0 ; i<col ; i++){\n\t\t\tfor(int j=0; j<row ; j++){\n\t\t\t\tt.values[j*col+i]=this->values[x*this->columns+y];\n\t\t\t\tx++; \n\t\t\t\tif(x==this->rows){\n\t\t\t\t\tx=0; y++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn t;\n\t}\n\tMatrix transpose(){\n\t\tvector<T> v;\n\t\tfor(int i=0; i<columns ; i++)\n\t\t\tfor(int j=0 ; j<rows ; j++) v.push_back(this->values[j*columns+i]);\n\t\tMatrix t(columns,rows,v);\n\t\treturn t;\t\n\t}\n\tMatrix operator +(const Matrix & matrix2){\n\t\tMatrix t(rows,columns,values);\n\t\tfor(int i=0; i<rows*columns; i++) t.values[i]+=matrix2.values[i];\n\t\treturn t;\n\t}\n\tMatrix operator +(const T val){\n\t\tMatrix t(rows,columns,values);\n\t\tfor(int i=0; i<rows*columns; i++) t.values[i]+=val;\n\t\treturn t;\n\t}\n\tMatrix operator -(const Matrix & matrix2){\n\t\tMatrix t(rows,columns,values);\n\t\tfor(int i=0; i<rows*columns; i++) t.values[i]-=matrix2.values[i];\n\t\treturn t;\n\t}\n\tMatrix operator -(const T val){\n\t\tMatrix t(rows,columns,values);\n\t\tfor(int i=0; i<rows*columns; i++) t.values[i]-=val;\n\t\treturn t;\n\t}\n\tMatrix operator *(const Matrix & matrix2){\n\t\tvector<T> v;\n\t\tfor(int i=0; i<rows ; i++){\n\t\t\tfor(int j=0 ; j<matrix2.columns; j++){\n\t\t\t\tT val=0;\n\t\t\t\tfor(int x=0; x<rows; x++){\n\t\t\t\t\tval+=this->values[i*columns+x]*matrix2.values[x*columns+j];\n\t\t\t\t}\n\t\t\t\tv.push_back(val);\t\t\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tMatrix t(rows, matrix2.columns,v);\n\t\treturn t;\n\t}\n\tMatrix operator *(const T val){\n\t\tMatrix t(rows,columns,values);\n\t\tfor(int i=0; i<rows*columns; i++) t.values[i]*=val;\n\t\treturn t;\n\t}\n\tMatrix max(){\n\t\tif(this->rows==1){\n\t\t\tT maxval=0;\n\t\t\tfor(int i=0; i<columns; i++) maxval=maxval>this->values[i]? maxval : this->values[i];\n\t\t\tMatrix t(1,1);\n\t\t\tt.values[0]=maxval;\n\t\t\treturn t;\n\t\t}\n\t\tvector<T> v;\n\t\tfor(int i=0 ; i<columns ; i++){\n\t\t\tT maxval=0;\n\t\t\tfor(int j=0; j<rows ; j++)\n\t\t\t\tmaxval= maxval>this->values[j*columns+i]? maxval : this->values[j*columns+i];\n\t\t\tv.push_back(maxval);\t\n\t\t}\n\t\tMatrix t(1,columns,v);\n\t\treturn t;\n\t}\n\tMatrix min(){\n\t\tif(this->rows==1){\n\t\t\tT minval=1e9;\n\t\t\tfor(int i=0; i<columns; i++) minval=minval<this->values[i]? minval : this->values[i];\n\t\t\tMatrix t(1,1);\n\t\t\tt.values[0]=minval;\n\t\t\treturn t;\n\t\t}\n\t\tvector<T> v;\n\t\tfor(int i=0 ; i<columns ; i++){\n\t\t\tT minval=1e9;\n\t\t\tfor(int j=0; j<rows ; j++)\n\t\t\t\tminval= minval<this->values[j*columns+i]? minval : this->values[j*columns+i];\n\t\t\tv.push_back(minval);\t\n\t\t}\n\t\tMatrix t(1,columns,v);\n\t\treturn t;\n\t}\n\tMatrix sum(){\n\t\tif(this->rows==1){\n\t\t\tMatrix t(1,1);\n\t\t\tT sumval=0;\n\t\t\tfor(int i=0; i<columns ;i++) sumval+=this->values[i];\n\t\t\tt.values[0]=sumval;\n\t\t\treturn t;\t\n\t\t}\n\t\tvector<T> v;\n\t\tfor(int i=0 ; i<columns ; i++){\n\t\t\tT sumval=0;\n\t\t\tfor(int j=0 ; j<rows ; j++) sumval+=this->values[j*columns+i];\n\t\t\tv.push_back(sumval);\n\t\t}\n\t\tMatrix t(1,columns,v);\n\t\treturn t;\n\t}\n};\n",
            1590137482.1737466,
            100,
            "# 答案正确"
        ],
        [
            "6.2 (C++)",
            "謝敏華",
            "#include<iostream>\n#include<vector>\n#include<memory.h>\nusing namespace std;\n\ntemplate <typename T>\nclass Matrix{\nprivate:\n\tint rows;\n\tint columns;\n\tT *values;\npublic:\n\tMatrix(int rows,int columns){\n\t\tthis->rows=rows;\n\t\tthis->columns=columns;\n\t\tthis->values=new T[rows*columns];\n\t\tmemset(this->values,0,sizeof(T)*rows*columns);\n\t}\n\t~Matrix(){\n\t\tdelete [] this->values;\n\t}\n\tvoid print(){\n\t\tfor(int i=0; i<rows*columns; i++){\n\t\t\tcout<<\"    \"<<this->values[i];\n\t\t\tif((i+1)%columns == 0) cout<<endl;\n\t\t}\n\t}\n};",
            1590632304.3067033,
            100,
            "# 答案正确"
        ],
        [
            "7.1 (C++)",
            "謝敏華",
            "#include <math.h>\nclass Triangle:public GeometricObject{\nprivate:\n\tdouble side1;\n\tdouble side2;\n\tdouble side3;\npublic:\t\n\tTriangle(double side1=1,double side2=1,double side3=1){\n\t\tthis->side1=side1; this->side2=side2; this->side3=side3;\n\t}\n\tdouble getSide1(){\n\t\treturn this->side1;\n\t}\n\tdouble getSide2(){\n\t\treturn this->side2;\n\t}\n\tdouble getSide3(){\n\t\treturn this->side3;\n\t}\n\tdouble getArea(){\n\t\tdouble s=(side1+side2+side3)/2;\n\t\treturn sqrt(s* (s-side1) * (s-side2) * (s-side3) );\n\t}\n\tdouble getPerimeter(){\n\t\treturn side1+side2+side3;\n\t}\n}; ",
            1590728015.4056232,
            100,
            "# 答案正确"
        ],
        [
            "7.3 (C++)",
            "謝敏華",
            "template <typename A, typename R>\nvector<R> map2(const vector<A> & x, const vector<A> & y, R (*map_func)(const A &,const A &)) {\n\tvector<R> res;\n\tfor (int i = 0; i < x.size(); ++ i)\n\t\tres.push_back(map_func(x[i],y[i]));\n\treturn res;\n}\ntemplate <typename A, typename R>\nvector<R> map2(const vector<A> & x, const int y, R (*map_func)(const A &,const A &)) {\n\tvector<R> res;\n\tfor (int i = 0; i < x.size(); ++ i)\n\t\tres.push_back(map_func(x[i],y));\n\treturn res;\n}",
            1590729102.31433,
            100,
            "# 答案正确"
        ],
        [
            "7.2 (C++)",
            "謝敏華",
            "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nvector<string> split(string line){\n\tvector<string> word;\n\tint str=0;\n\twhile(line.find(\" \")!=-1){\n\t\tint end=line.find(\" \");\n\t\tif(str==end){\n\t\t\tline.erase(str,1);\n\t\t\tcontinue;\n\t\t}\n//\t\tcout<<line<<endl;\n\t\tword.push_back(line.substr(str,end));\t\n\t\tline.erase(str,end);\n\t}\n\tif(line.size()!=0) word.push_back(line);\n\treturn word;\n}",
            1591237699.4906175,
            100,
            "# 答案正确"
        ],
        [
            "8.1 (C++)",
            "謝敏華",
            "class Full:public Matrix{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble *values;\npublic:\n\tFull(int row,int column){\n\t\tthis->rows=row;\n\t\tthis->columns=column;\n\t\tthis->values=new double[rows*columns];\n\t\tfor(int i=0; i<rows*columns; i++) values[i]=0;\n\t} \n\t\n\tFull(int row,int column,double *value){\n\t\tthis->rows=row;\n\t\tthis->columns=column;\n\t\tthis->values=new double[rows*columns+1];\n\t\tfor(int i=0; i<rows*columns; i++) values[i]=value[i];\n\t} \n\t\n\tFull(const Matrix & matrix2){\n\t\tthis->rows=matrix2.size(1);\n\t\tthis->columns=matrix2.size(2);\n\t\tthis->values=new double[rows*columns];\n\t\tfor(int i=0 ; i<rows ; i++)\n\t\tfor(int j=0; j<columns ; j++) this->set(i+1,j+1, matrix2.get(i+1,j+1) );\n\t} \n\t\n\t~Full(){\n\t\tdelete [] this->values;\n\t}\n\t\n\tvoid print() const{\n\t\tfor(int i=0; i<rows*columns; i++){\n\t\t\tcout<<\"    \"<<values[i];\n\t\t\tif( (i+1) % columns == 0 ) cout<<endl;\n\t\t}\n\t}\n\t\n\tint size(int dimension) const{\n\t\tif(dimension==1) return rows;\n\t\tif(dimension==2) return columns;\n\t}\n\t\n\tvoid set(int row, int column, double value){\n\t\trow--; column--;\n\t\tint index=row*columns+column;\n\t\tthis->values[index]=value;\n\t}\n\t\n\tdouble get(int row, int column) const{\n\t\trow--; column--;\n\t\tint index=row*columns+column;\t\t\n\t\tdouble target=this->values[index];\n\t\treturn target;\n\t}\n\n\tMatrix & operator = (const Matrix & matrix2){\n\t\tFull temp(rows,columns);\n\t\tfor(int i=0 ; i<rows ; i++)\n\t\tfor(int j=0; j<columns ; j++) this->set(i+1,j+1, matrix2.get(i+1,j+1) );\n\t\tMatrix & t = temp;\n\t\treturn t;\n\t\n\t}\n}; ",
            1591364716.184938,
            100,
            "# 答案正确"
        ],
        [
            "8.3 (C++)",
            "謝敏華",
            "#include <vector>\t\n#include <iostream>\nusing namespace std;\n\nclass Sparse:public Matrix{\nprivate:\n\tint rows;\n\tint columns;\n\tvector<Entry> list;\npublic:\n\tSparse(int row, int column){\n\t\tthis->rows=row;\n\t\tthis->columns=column;\n\t}\n\t\n\tint find(Entry x){\n\t\tfor(int i=0; i<this->list.size() ;i++)\n\t\t\tif(this->list[i].row==x.row && this->list[i].column==x.column) return i;\n\t\t\t\n\t\treturn -1;\t\n\t}\n\t\n\tSparse operator +(const Sparse &sparse2){\n\t\tSparse temp(rows,columns);\n\t\tfor(int i=0; i<list.size() ; i++) temp.list.push_back(this->list[i]);\n\t\tfor(int i=0; i<sparse2.list.size() ; i++)\n\t\t\tif( temp.find(sparse2.list[i])!=-1 ){\n\t\t\t\tint index=temp.find(sparse2.list[i]);\n\t\t\t\ttemp.list[index].value+=sparse2.list[i].value;\n\t\t\t}else\n\t\t\ttemp.list.push_back(sparse2.list[i]);\t\n\t\treturn temp;\t\n\t}\n\t\n\tvoid print(){\n\t\tfor(int i=0; i<list.size()-1; i++)\n\t\tfor(int j=i+1; j<list.size();   j++){\n\t\t\tif(list[i].row>list[j].row){\n\t\t\t\tEntry t=list[i]; list[i]=list[j]; list[j]=t;\n\t\t\t}\n\t\t\tif(list[i].row==list[j].row && list[i].column>list[j].column){\n\t\t\t\tEntry t=list[i]; list[i]=list[j]; list[j]=t;\t\n\t\t\t}\t\t\t\n\t\t}\n\t\tfor(int i=0; i<list.size(); i++)\n\t\t\tif(list[i].value!=0)\n\t\t\tcout<<\"(\"<<list[i].row<<\",\"<<list[i].column<<\",\"<<list[i].value<<\")\"<<endl;\n\t}\n\t\n\tvoid set(int row, int column,double value){\n\t\tEntry t;\n\t\tt.row=row;\n\t\tt.column=column;\n\t\tt.value=value;\n\t\tlist.push_back(t);\t\n\t}\n\t\n\tint size(int dimension) const{\n\t\tif(dimension==1) return rows;\n\t\tif(dimension==2) return columns;\n\t}\n\t\n\tdouble get(int row, int column) const{\n\t\t\n\t}\n};\n",
            1591371602.2100713,
            100,
            "# 答案正确"
        ],
        [
            "8.4 (C++)",
            "謝敏華",
            "#include <vector>\t\n#include <iostream>\nusing namespace std;\n\nclass Sparse:public Matrix{\nprivate:\n\tint rows;\n\tint columns;\n\tvector<Entry> list;\npublic:\n\tSparse(int row, int column){\n\t\tthis->rows=row;\n\t\tthis->columns=column;\n\t}\n\t\n\tint find(Entry x){\n\t\tfor(int i=0; i<list.size() ;i++)\n\t\t\tif(list[i].row==x.row && list[i].column==x.column) return i;\n\t\t\t\n\t\treturn -1;\t\n\t}\n\t\n\tSparse operator +(const Sparse &sparse2){\n\t\tSparse temp(rows,columns);\n\t\tfor(int i=0; i<list.size() ; i++) temp.list.push_back(this->list[i]);\n\t\tfor(int i=0; i<sparse2.list.size() ; i++)\n\t\t\tif( temp.find(sparse2.list[i])!=-1 ){\n\t\t\t\tint index=temp.find(sparse2.list[i]);\n\t\t\t\ttemp.list[index].value+=sparse2.list[i].value;\n\t\t\t}else\n\t\t\ttemp.list.push_back(sparse2.list[i]);\t\n\t\treturn temp;\t\n\t}\n\t\n\tSparse operator *(const Sparse &sparse2){\n\t\tSparse temp(rows,columns);\n\t\tfor(int i=0 ; i<sparse2.list.size(); i++){\n\t\t\tfor(int j=0; j<list.size(); j++){\n\t\t\t\tif(list[j].column==sparse2.list[i].row){\n\t\t\t\t\tEntry p;\n\t\t\t\t\tp.row=list[j].row;\n\t\t\t\t\tp.column=sparse2.list[i].column;\n\t\t\t\t\tint index=temp.find(p);\n\t\t\t\t\tif(index==-1){\n\t\t\t\t\t\tp.value=list[j].value*sparse2.list[i].value;\n\t\t\t\t\t\ttemp.list.push_back(p);\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttemp.list[index].value+=list[j].value*sparse2.list[i].value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn temp;\t\n\t}\n\t\n\tvoid print(){\n\t\tfor(int i=0; i<list.size()-1; i++)\n\t\tfor(int j=i+1; j<list.size();   j++){\n\t\t\tif(list[i].row>list[j].row){\n\t\t\t\tEntry t=list[i]; list[i]=list[j]; list[j]=t;\n\t\t\t}\n\t\t\tif(list[i].row==list[j].row && list[i].column>list[j].column){\n\t\t\t\tEntry t=list[i]; list[i]=list[j]; list[j]=t;\t\n\t\t\t}\t\t\t\n\t\t}\n\t\tfor(int i=0; i<list.size(); i++)\n\t\t\tif(list[i].value!=0)\n\t\t\tcout<<\"(\"<<list[i].row<<\",\"<<list[i].column<<\",\"<<list[i].value<<\")\"<<endl;\n\t}\n\t\n\tvoid set(int row, int column,double value){\n\t\tEntry t;\n\t\tt.row=row;\n\t\tt.column=column;\n\t\tt.value=value;\n\t\tlist.push_back(t);\t\n\t}\n\t\n\tint size(int dimension) const{\n\t\tif(dimension==1) return rows;\n\t\tif(dimension==2) return columns;\n\t}\n\t\n\tdouble get(int row, int column) const{\n\t\t\n\t}\n};\n",
            1591374275.9009428,
            100,
            "# 答案正确"
        ],
        [
            "8.5 (C++)",
            "謝敏華",
            "class Point3D:public Point2D{\nprivate:\n\tdouble z;\npublic:\n\tPoint3D(){\n\t\tPoint2D();\n\t\tz = 0;\n\t}\n\tPoint3D(double x, double y, double z){\n\t\tsetX(x);\n\t\tsetY(y);\n\t\tthis->z=z;\n\t}\t\n\tdouble getZ(){\n\t\treturn z;\n\t}\t\n\t\n\tvirtual double distance(Point2D & point2) {\n\t\tdouble dx =this->getX() - point2.getX();\n\t\tdouble dy =this->getY() - point2.getY();\n\t\tPoint3D *p=dynamic_cast<Point3D*>(&point2);\n\t\tdouble dz =this->z - p->getZ();\n\t\treturn sqrt(dx * dx + dy * dy + dz * dz);\n\t}\n}; ",
            1591843322.014057,
            100,
            "# 答案正确"
        ],
        [
            "8.6 (C++)",
            "謝敏華",
            "#include <vector>\n#include <iostream>\nclass MyTensor:public Tensor<double>\n{\nprivate:\n\tdouble *val;\npublic:\n\tMyTensor(vector<int> size):Tensor(size){\n\t\tint ele=1;\n\t\tfor(int i=0; i<size.size(); i++) ele=(size[i]+1)*ele;\n\t\tval=new double[ele];\t\n\t}\n\t~MyTensor(){\n\t\tdelete [] val;\n\t}\n\tdouble & get(const vector<int> & indexes){\n\t\tint index=indexes[0];\n\t\tfor(int i=1; i<indexes.size() ; i++){\n\t\t\tindex=index*this->sizes[i]+indexes[i];\n\t\t}\n\t\treturn val[index];\n\t}\n};",
            1592449839.8835824,
            100,
            "# 答案正确"
        ],
        [
            "9.1 (C++)",
            "謝敏華",
            "#include <iostream>\nusing namespace std;\n\nclass Circle{\nprivate:\n\tdouble size;\npublic:\n\tCircle(double val){\n\t\tthis->size=val;\n\t}\n\t~Circle(){\n\t}\n\tint operator < (const Circle & circle2){\n\t\tif(this->size < circle2.size) return 1;\n\t\treturn 0;\n\t}\n\t\n\tint operator <= (const Circle & circle2){\n\t\tif(this->size <= circle2.size) return 1;\n\t\treturn 0;\n\t}\n\t\n\tint operator == (const Circle & circle2){\n\t\tif(this->size == circle2.size) return 1;\n\t\treturn 0;\n\t}\n\t\n\tint operator != (const Circle & circle2){\n\t\tif(this->size != circle2.size) return 1;\n\t\treturn 0;\n\t}\n\t\n\tint operator >= (const Circle & circle2){\n\t\tif(this->size >= circle2.size) return 1;\n\t\treturn 0;\n\t}\n\t\n\tint operator > (const Circle & circle2){\n\t\tif(this->size > circle2.size) return 1;\n\t\treturn 0;\n\t}\n}; ",
            1592755362.3081543,
            100,
            "# 答案正确"
        ],
        [
            "9.3 (C++)",
            "謝敏華",
            "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nclass Complex{\nprivate:\n\tdouble r;\n\tdouble i;\npublic:\n\tComplex(double r=0,double i=0):r(r),i(i){}\n\tComplex(int r):r(r),i(0){\n\t}\n\tdouble real(){\n\t\treturn r;\n\t}\n\tdouble imag(){\n\t\treturn i;\n\t}\n\t\t\n\tComplex & operator += (const Complex & c1){\n\t\tr+=c1.r;\n\t\ti+=c1.i;\n\t\treturn *this;\n\t}\t\n\t\n\tComplex & operator -= (const Complex & c1){\n\t\tr-=c1.r;\n\t\ti-=c1.i;\n\t\treturn *this;\n\t}\n\t\n\tComplex & operator *= (const Complex & c1){\n\tComplex temp(this->r,this->i);\n\t\ttemp.r= r * c1.r - i * c1.i;\n\t\ttemp.i= r * c1.i + i * c1.r;\n\t\tr=temp.r; i=temp.i;\n\t\treturn *this;\n\t}\t\n\t\n\tComplex & operator /= (const Complex & c1){\n\t\tComplex temp(this->r,this->i);\n\t\ttemp.r= (r * c1.r + i * c1.i)/(c1.r*c1.r + c1.i*c1.i);\n\t\ttemp.i= (i * c1.r - r * c1.i)/(c1.r*c1.r + c1.i*c1.i);\n\t\tr=temp.r; i=temp.i;\n\t\treturn *this;\n\t}\t\n\t\n\tint operator == (const Complex & c1){\n\t\tif (r==c1.r && i==c1.i) return 1;\n\t\treturn 0;\n\t}\n\t\n\tint operator != (const Complex & c1){\n\t\tif (r==c1.r && i==c1.i) return 0;\n\t\treturn 1;\n\t}\n};\nComplex operator + ( Complex c1, Complex c2){\n\tComplex temp(c1.real()+c2.real(),c1.imag()+c2.imag());\n\treturn temp;\n}\n\nComplex operator - ( Complex c1, Complex c2){\n\tComplex temp(c1.real()-c2.real(),c1.imag()-c2.imag());\n\treturn temp;\n}\n\nComplex operator * (Complex c1, Complex c2){\n\t\tComplex temp(c1.real()*c2.real()-c1.imag()*c2.imag() , c1.real()*c2.imag()+c1.imag()*c2.real());\n\t\treturn temp;\n}\t\n\t\nComplex operator / (Complex c1, Complex c2){\n\t\tdouble r,i;\n\t\tr= (c1.real() * c2.real() + c1.imag() * c2.imag())/(c2.real()*c2.real() + c2.imag()*c2.imag());\n\t\ti= (c1.imag() * c2.real() - c1.real() * c2.imag())/(c2.real()*c2.real() + c2.imag()*c2.imag());\n\t\tComplex temp(r,i);\n\t\treturn temp;\n}",
            1592817180.690115,
            100,
            "# 答案正确"
        ],
        [
            "9.4 (C++)",
            "謝敏華",
            "#include <iostream>\nusing namespace std;\n\nclass Complex{\nprivate:\n\tdouble r;\n\tdouble i;\npublic:\n\tComplex(double r=0,double i=0):r(r),i(i){}\n\tComplex(int r):r(r),i(0){\n\t}\n\tdouble real(){\n\t\treturn r;\n\t}\n\tdouble imag(){\n\t\treturn i;\n\t}\n\t\t\n\tComplex & operator += (const Complex & c1){\n\t\tr+=c1.r;\n\t\ti+=c1.i;\n\t\treturn *this;\n\t}\t\n\t\n\tComplex & operator -= (const Complex & c1){\n\t\tr-=c1.r;\n\t\ti-=c1.i;\n\t\treturn *this;\n\t}\n\t\n\tComplex & operator *= (const Complex & c1){\n\tComplex temp(this->r,this->i);\n\t\ttemp.r= r * c1.r - i * c1.i;\n\t\ttemp.i= r * c1.i + i * c1.r;\n\t\tr=temp.r; i=temp.i;\n\t\treturn *this;\n\t}\t\n\t\n\tComplex & operator /= (const Complex & c1){\n\t\tComplex temp(this->r,this->i);\n\t\ttemp.r= (r * c1.r + i * c1.i)/(c1.r*c1.r + c1.i*c1.i);\n\t\ttemp.i= (i * c1.r - r * c1.i)/(c1.r*c1.r + c1.i*c1.i);\n\t\tr=temp.r; i=temp.i;\n\t\treturn *this;\n\t}\t\n\t\n\tint operator == (const Complex & c1){\n\t\tif (r==c1.r && i==c1.i) return 1;\n\t\treturn 0;\n\t}\n\t\n\tint operator != (const Complex & c1){\n\t\tif (r==c1.r && i==c1.i) return 0;\n\t\treturn 1;\n\t}\n\t\n};\nComplex operator + ( Complex c1, Complex c2){\n\tComplex temp(c1.real()+c2.real(),c1.imag()+c2.imag());\n\treturn temp;\n}\n\nComplex operator - ( Complex c1, Complex c2){\n\tComplex temp(c1.real()-c2.real(),c1.imag()-c2.imag());\n\treturn temp;\n}\n\nComplex operator * (Complex c1, Complex c2){\n\t\tComplex temp(c1.real()*c2.real()-c1.imag()*c2.imag() , c1.real()*c2.imag()+c1.imag()*c2.real());\n\t\treturn temp;\n}\t\n\t\nComplex operator / (Complex c1, Complex c2){\n\t\tdouble r,i;\n\t\tr= (c1.real() * c2.real() + c1.imag() * c2.imag())/(c2.real()*c2.real() + c2.imag()*c2.imag());\n\t\ti= (c1.imag() * c2.real() - c1.real() * c2.imag())/(c2.real()*c2.real() + c2.imag()*c2.imag());\n\t\tComplex temp(r,i);\n\t\treturn temp;\n}\n\t\nistream & operator >> (istream & in, Complex &c1 ){\n\tdouble real,imag;\n\tin>>real>>imag;\n\tComplex tmp(real,imag);\n\tc1=tmp;\n\treturn in;\n}\nostream & operator << (ostream & out, Complex & c1){\n\tout<<c1.real()<<\" + \"<<c1.imag()<<\" i\";\n\treturn out;\n}",
            1592818017.2978165,
            100,
            "# 答案正确"
        ],
        [
            "9.5 (C++)",
            "謝敏華",
            "#include <iostream>\nusing namespace std;\n\n\nclass Complex{\nprivate:\n\tdouble r;\n\tdouble i;\npublic:\n\tComplex(double r=0,double i=0):r(r),i(i){}\n\tComplex(int r):r(r),i(0){\n\t}\n\tdouble real(){\n\t\treturn r;\n\t}\n\tdouble imag(){\n\t\treturn i;\n\t}\n\n\t\t\n\tComplex & operator += (const Complex & c1){\n\t\tr+=c1.r;\n\t\ti+=c1.i;\n\t\treturn *this;\n\t}\t\n\t\n\tComplex & operator -= (const Complex & c1){\n\t\tr-=c1.r;\n\t\ti-=c1.i;\n\t\treturn *this;\n\t}\n\t\n\tComplex & operator *= (const Complex & c1){\n\tComplex temp(this->r,this->i);\n\t\ttemp.r= r * c1.r - i * c1.i;\n\t\ttemp.i= r * c1.i + i * c1.r;\n\t\tr=temp.r; i=temp.i;\n\t\treturn *this;\n\t}\t\n\t\n\tComplex & operator /= (const Complex & c1){\n\t\tComplex temp(this->r,this->i);\n\t\ttemp.r= (r * c1.r + i * c1.i)/(c1.r*c1.r + c1.i*c1.i);\n\t\ttemp.i= (i * c1.r - r * c1.i)/(c1.r*c1.r + c1.i*c1.i);\n\t\tr=temp.r; i=temp.i;\n\t\treturn *this;\n\t}\t\n\t\n\tint operator == (const Complex & c1){\n\t\tif (r==c1.r && i==c1.i) return 1;\n\t\treturn 0;\n\t}\n\t\n\tint operator != (const Complex & c1){\n\t\tif (r==c1.r && i==c1.i) return 0;\n\t\treturn 1;\n\t}\n\t\n\tComplex & operator ++(){\n\t\t++r;\n\t\treturn *this;\n\t}\n\tComplex operator ++(int){\n\t\tComplex tmp(r,i);\n\t\t++r;\n\t\treturn tmp;\n\t}\n\toperator double() const{\n\t\treturn r;\n\t}\n};\nComplex operator + ( Complex c1, Complex c2){\n\tComplex temp(c1.real()+c2.real(),c1.imag()+c2.imag());\n\treturn temp;\n}\n\nComplex operator - ( Complex c1, Complex c2){\n\tComplex temp(c1.real()-c2.real(),c1.imag()-c2.imag());\n\treturn temp;\n}\n\nComplex operator * (Complex c1, Complex c2){\n\t\tComplex temp(c1.real()*c2.real()-c1.imag()*c2.imag() , c1.real()*c2.imag()+c1.imag()*c2.real());\n\t\treturn temp;\n}\t\n\t\nComplex operator / (Complex c1, Complex c2){\n\t\tdouble r,i;\n\t\tr= (c1.real() * c2.real() + c1.imag() * c2.imag())/(c2.real()*c2.real() + c2.imag()*c2.imag());\n\t\ti= (c1.imag() * c2.real() - c1.real() * c2.imag())/(c2.real()*c2.real() + c2.imag()*c2.imag());\n\t\tComplex temp(r,i);\n\t\treturn temp;\n}\n\t\nistream & operator >> (istream & in, Complex &c1 ){\n\tdouble real,imag;\n\tin>>real>>imag;\n\tComplex tmp(real,imag);\n\tc1=tmp;\n\treturn in;\n}\n\nostream & operator << (ostream & out, Complex c1) {\n\n\tout<<c1.real()<<\" + \"<<c1.imag()<<\" i\";\n\treturn out;\n}\n",
            1592819742.5900805,
            100,
            "# 答案正确"
        ],
        [
            "9.2 (C++)",
            "謝敏華",
            "class I{\n\tvector<int> val;\npublic:\n\tI(int x1=-1, int x2=-1, int x3=-1, int x4=-1){\n\t\tif(x1 != -1 ) val.push_back(x1);\n\t\tif(x2 != -1 ) val.push_back(x2);\n\t\tif(x3 != -1 ) val.push_back(x3);\n\t\tif(x4 != -1 ) val.push_back(x4);\n\t}\n\toperator vector<int>() const{\n\t\treturn val;\n\t}\n};\n",
            1592831289.5461123,
            100,
            "# 答案正确"
        ],
        [
            "9.6 (C++)",
            "謝敏華",
            "class Tensor\n{\n\tvector<int> sizes;\n\tvector<double> values;\n\t\n\tint _index(const vector<int> & indexes) const {\n\t\tint index = 0;\n\t\tfor (int i = 0; i < this->sizes.size(); ++ i) {\n\t\t\tindex *= sizes[i];\n\t\t\tindex += indexes[i];\n\t\t}\n\t\treturn index;\n\t}\n\t\npublic:\n\tint numel() const {\n\t\tif (this->sizes.size() == 0) return 0;\n\t\tint size = 1;\n\t\tfor (int i = 0; i < this->sizes.size(); ++ i) size *= sizes[i];\n\t\treturn size;\n\t}\n\t\n\tTensor(int x1=-1, int x2=-1, int x3=-1, int x4=-1){\n\t\tif(x1 != -1 ) sizes.push_back(x1);\n\t\tif(x2 != -1 ) sizes.push_back(x2);\n\t\tif(x3 != -1 ) sizes.push_back(x3);\n\t\tif(x4 != -1 ) sizes.push_back(x4);\n\t\tthis->values.resize(this->numel());\n\t\tfor (int i = 0; i < this->numel(); ++ i) this->values[i] = 0;\n\t}\n\t\n\toperator vector<int>() const{\n\t\treturn sizes;\n\t}\n\t\n\tdouble & get(const vector<int> & indexes) {\n\t\treturn values[this->_index(indexes)];\n\t}\n\tdouble & operator () (int x1=-1, int x2=-1, int x3=-1, int x4=-1){\n\t\tTensor tmp(x1,x2,x3,x4);\n\t\treturn get(tmp);\n\t}\n};\n",
            1592832226.4613702,
            100,
            "# 答案正确"
        ],
        [
            "9.7 (C++)",
            "謝敏華",
            "class Tensor{\n\tvector<int> sizes;\n\tvector<double> values;\npublic:\n\tint numel() const {\n\t\tif (this->sizes.size() == 0) return 0;\n\t\tint size = 1;\n\t\tfor (int i = 0; i < this->sizes.size(); ++ i) size *= sizes[i];\n\t\treturn size;\n\t}\n\tvector<int> size(){\n\t\treturn sizes;\n\t}\n\tvector<double> value(){\n\t\treturn values;\n\t}\n\tTensor(){\n\t}\n\t\n\tTensor(vector<int> size, vector<double> val){\n\t\tthis->sizes=size;\n\t\tthis->values.resize(this->numel());\n\t\tfor (int i = 0; i < this->numel(); ++ i) this->values[i] = val[i];\n\t}\n\t\n};\nistream & operator >> (istream & in, Tensor & t1){\n\tint n,x;\n\tvector<int> size;\n\tvector<double>val;\n\tin>>n;\n\tfor(int i=0; i<n ;i++){\n\t\tin>>x;\n\t\tsize.push_back(x);\n\t}\n\t\n\tint nul = 1;\n\tfor (int i = 0; i < size.size(); ++ i) nul *= size[i];\n\tval.resize(nul);\n\tfor (int i = 0; i < nul ; i ++) in>>val[i];\n\t\n\tTensor tmp(size,val);\n\tt1=tmp;\n\treturn in;\n}\n\nostream & operator << (ostream & out, Tensor t1){\n\tout<<t1.size().size()<<endl;\n\tfor(int i=0; i<t1.size().size(); i++)\n\t\tout<<t1.size()[i]<<\" \";\n\tout<<endl<<endl;\n\t\n\tfor(int i=0 ; i<t1.numel() ; i++){\n\t\tout<<t1.value()[i]<<\" \";\n\t\tif ((i+1) % t1.size()[0] == 0 ) out<<endl;\n\t\tif (t1.size().size() == 4 && (i+1) % (t1.size()[1]*t1.size()[2]*t1.size()[3]) == 0 ) out<<endl;\n\t\telse\n\t\tif (t1.size().size() >= 3 && (i+1) % (t1.size()[1]*t1.size()[2]) == 0 ) out<<endl;\t\n\t\telse\n\t\tif (t1.size().size() == 2 && (i+1) % t1.size()[1] == 0 ) out<<endl;\t\t\t\n\t}\n\treturn out;\t\n}",
            1592836633.6143095,
            100,
            "# 答案正确"
        ],
        [
            "10.1 (C++)",
            "謝敏華",
            "#include<stdexcept>\nclass MatrixSizesDoNotMatchException{\n};\ndouble Matrix::get(int row,int column) const{\n\t//if(row>this->rows || column>this->columns) throw out_of_range();\n\tint index=(row-1)*this->columns+column-1;\n\treturn this->elements[index];\n}\n\nvoid Matrix::set(int row,int column, double value){\n\t//if(row>this->rows || column>this->columns) throw out_of_range();\n\tint index=(row-1)*this->columns+column-1;\n\tthis->elements[index]=value;\n}\n\nMatrix Matrix::operator +(const Matrix & matrix2) const{\n\tif(this->rows != matrix2.size(1) || this->columns!= matrix2.size(2))\n\t\tthrow MatrixSizesDoNotMatchException();\n\tMatrix temp(rows,columns);\t\n\tfor(int i=1; i<=rows ; i++)\n\t\tfor(int j=1; j<=columns ; j++){\n\t\t\ttemp.set( i , j , this->get(i,j)+matrix2.get(i,j) );\n\t\t}\n\treturn temp;\n}",
            1593576869.5221245,
            100,
            "# 答案正确"
        ],
        [
            "10.2 (C++)",
            "謝敏華",
            "\t\tcatch(NonPositiveValueException &ex){\n\t\t\tcout<<\"caught: NonPositiveValueException\"<<endl;\n\t\t}\n\t\tcatch(out_of_range &ex){\n\t\t\tcout<<\"caught: out_of_range\"<<endl;\n\t\t}",
            1593656813.2462654,
            100,
            "# 答案正确"
        ],
        [
            "15.1 (C++)",
            "謝敏華",
            "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nclass Table{\nprivate:\n\tint rows;\n\tint columns;\n\tvector<string> str[100];\npublic:\n\tTable(){\n\t\trows=0;\n\t\tcolumns=0;\n\t}\n\t\n\tvoid addCol(string s){\n\t\tthis->columns++;\n\t\tstr[rows].push_back(s);\n\t}\n\t\n\t\n\tvector<string> & operator [](int i){\n\t\tif(i==rows) {\n\t\t\trows++;\n\t\t}\n\t\treturn str[i+1]; \n\t}\n\n\tchar json()const{\n\t\tcout<<\"{\"<<endl;\n\t\tcout<<\"\\theaders: [\"; \n\t\tfor(int j=0; j<columns ; j++){\n\t\t\tcout<<\"'\"<<str[0][j]<<\"',\";\n\t\t}\n\t\tcout<<\"],\"<<endl;\n\t\t\n\t\tcout<<\"\\trows: [\"<<endl;\t\n\t\tfor(int i=1; i<=rows ; i++){\n\t\t\tcout<<\"\\t\\t[\";\n\t\t\tfor(int j=0; j<columns ; j++){\n\t\t\t\tcout<<\"'\"<<str[i][j]<<\"',\";\n\t\t\t}\n\t\t\tcout<<\"],\"<<endl;\n\t\t}\n\t\tcout<<\"\\t],\"<<endl;\n\t\tcout<<\"}\";\n\t\treturn '\\n';\n\t}\n\t\n};",
            1593783937.2223837,
            100,
            "# 答案正确"
        ],
        [
            "2020-07-09 LAB",
            "謝敏華",
            "#include <iostream>\nusing namespace std;\n\nclass Integer\n{\npublic:\n    static int val;\n    int a;\n    \n    Integer(int s=0) {\n        a = s;\n    }\n    \n    static void increase_all(Integer x) {\n        val = x.a;\n    }\n    \n};\nint Integer::val = 0;\nistream & operator >> (istream & in, Integer & s) {\n    in >> s.a;\n    return in;\n}\nostream & operator << (ostream & out, Integer & s) {\n    s.a += Integer::val;\n    out << s.a;\n    return out;\n}",
            1594264983.897491,
            100,
            "# 答案正确"
        ],
        [
            "A.1 (C++)",
            "謝敏華",
            "private:\n\tNode<E> * get_node(int index) const {\n\t\tif (index < 0 || index >= _size) \n\t\t\tthrow NotSuchElementException();\n\n\t\tif (index < _size / 2) {\n\t\t\tNode<E> * node = head;\n\t\t\tNode<E> * mempre=NULL;\n\t\t\tI(i, index) {\n\t\t\t\tNode<E> *temp=node;\n\t\t\t\tnode = node->next_node(mempre);\n\t\t\t\tmempre=temp;\n\t\t\t}\n\t\t\treturn node;\n\t\t}\n\t\telse {\n\t\t\tNode<E> * node = tail;\n\t\t\tNode<E> * memnext=NULL;\n\t\t\tI(i, (_size-1-index)) {\n\t\t\t\tNode<E> *temp=node;\n\t\t\t\tnode = node->prev_node(memnext);\n\t\t\t\tmemnext=temp;\n\t\t\t}\n\t\t\treturn node;\n\t\t}\n\t}\n\t\npublic:\n\tE & get(int index) const {\n\t\tNode<E> * node = get_node(index);\n\t\treturn node->element;\n\t}\n\t\n\tvoid set(int index, const E & e) {\n\t\tNode<E> * node = get_node(index);\n\t\tnode->element = e;\n\t}\n\t\n\tE & getFirst() const {\n\t\treturn get(0);\n\t}\n\n\tE & getLast() const {\n\t\treturn get(_size - 1);\n\t}\n\t\n\tvoid remove (int index) {\n\t\tNode<E> * node = get_node(index);\n\t\tNode<E> * p;\n\t\tif( index == _size-1 )\n\t\t\tp=0;\n\t\telse\n\t\t\tp=get_node(index+1);\t\n\t\tNode<E> * prev_node = node->prev_node(p);\n\t\tNode<E> * next_node = node->next_node(prev_node);\n\t\tif (prev_node != 0) prev_node->update_next_node(node,next_node);\n\t\tif (next_node != 0) next_node->update_prev_node(node,prev_node);\n\t\n\t\tif (prev_node == 0) head = next_node;\n\t\tif (next_node == 0) tail = prev_node;\n\t\t\n\t\tdelete node;\n\t\t-- _size;\n\t}\t\n\t\n\tvoid removeFirst () {\n\t\tremove(0);\n\t}\n\n\tvoid removeLast () {\n\t\tremove(_size-1);\n\t}\t\n\t\n\tvoid add(int index, const E & e) {\n\t\tif (index < 0 || index > _size) \n\t\t\tthrow NotSuchElementException();\n\t\tNode<E> * node = new Node<E>();\n\t\tNode<E> * next_node;\n\t\tNode<E> * prev_node;\n\t\tnode->element = e;\n\t\tif(index == _size)\n\t\t\tnext_node = 0;\n\t\telse\n\t\t\tnext_node = (index == _size ? 0 : get_node(index));\n\t\n\t\tif(index == 0)\n\t\t\tprev_node = 0;\t\n\t\telse\n\t\t\tprev_node = (next_node == 0 ? tail : get_node(index-1));\n\t\tnode->update_prev_and_next_node(prev_node,next_node);\n\t\tif (prev_node != 0) prev_node->update_next_node(next_node,node);\n\t\tif (next_node != 0) next_node->update_prev_node(prev_node,node);\n\t\tif (prev_node == 0) head = node;\n\t\tif (next_node == 0) tail = node;\n\t\t++ _size;\n\t}\n\n\tvoid addFirst (const E & e) {\n\t\tadd(0, e);\n\t}\n\n\tvoid addLast (const E & e) {\n\t\tadd(_size, e);\n\t}\t\n\n\tvoid clear() {\n\t\twhile (_size > 0) removeFirst();\n\t}\n\n\tvoid addAll(const LinkedList & list, int index=-1) {\n\t\tif (index == -1) index = _size;\n\t\tI(i, list._size) {\n\t\t\tNode<E> * node = list.get_node(i);\n\t\t\tadd(index + i, node->element);\n\t\t}\n\t}\n\n\tLinkedList(const LinkedList & list) : _size(0), head(0), tail(0) {\n\t\taddAll(list);\n\t}\n\n\tLinkedList & operator = (const LinkedList & list) {\n\t\tclear();\n\t\taddAll(list);\n\t\treturn *this;\n\t}\n\n\t~LinkedList() {\n\t\tclear();\n\t}\t\n\t\n\tint indexOf(const E & e) const {\n\t\tNode<E> * node = head;\n\t\tNode<E> * mem = NULL;\n\t\tI(i, _size) {\n\t\t\tif (node->element == e) return i;\n\t\t\tNode<E> * temp = node;\n\t\t\tnode = node->next_node(mem);\n\t\t\tmem=temp;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tint lastIndexOf(const E & e) const {\n\t\tNode<E> * node = tail;\n\t\tlong mem=0;\n\t\tI(i, _size) {\n\t\t\tif (node->element == e) return i;\n\t\t\tnode = node.prev_node(mem);\n\t\t\tmem=*node;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tbool contains(const E & e) const {\n\t\treturn indexOf(e) >= 0;\n\t}\n\t\n\tvoid removeFirstOccurrence(const E & e) {\n\t\tint index = indexOf(e);\n\t\tif (index == -1)\n\t\t\tthrow NotSuchElementException();\n\t\tremove(index);\n\t}\n\n\tvoid removeLastOccurrence(const E & e) {\n\t\tint index = lastIndexOf(e);\n\t\tif (index == -1)\n\t\t\tthrow NotSuchElementException();\n\t\tremove(index);\n\t}\t",
            1594390779.6366992,
            100,
            "# 答案正确"
        ],
        [
            "A.2 (C++)",
            "謝敏華",
            "template <typename E>\nvoid LinkedList<E>::removeAll(const E & e){\n\tint index=indexOf(e);\n\twhile(index != -1){\n\t\tremove(index);\n\t\tindex=indexOf(e);\n\t}\n}",
            1594865362.114284,
            100,
            "# 答案正确"
        ],
        [
            "A.3 (C++)",
            "謝敏華",
            "#include <iostream>\n#include <sstream>\n#include <vector>\n#define I(i,n) for (size_t i = 0; i < n; ++ i)\nusing namespace std;\nclass NoSuchKeyException{};\n\ntemplate<typename E>\nclass HT{\n\tclass Tuple{\n\tpublic:\n\t\tint key;\n\t\tE val;\n\t\tbool in_use;\n\t\tTuple(): in_use(false){\t}\n\t};\n\t\n\tvector<Tuple> tuples;\n\tsize_t _size;\n\t\n\tsize_t canonical_index(const int & key) const {\n\t\treturn key % tuples.size();\n\t}\n\t\n\tsize_t indexOfKey(const int & key) const {\n\t\tsize_t index = canonical_index(key);\n\t\twhile (true) {\n\t\t\tif (! tuples[index].in_use) return index;\n\t\t\tif (tuples[index].key == key) return index;\n\t\t\tindex = (index + 1) % tuples.size();\n\t\t}\n\t}\t\n\npublic:\t\n\tHT() : _size(0) {\n\t\ttuples.resize(2);\n\t}\n\t\n\tbool containsKey(const int & key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\treturn tuples[index].in_use;\n\t}\t\n\t\n\tconst E & operator [] (const int & key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples[index].val;\n\t}\n\t\n\tE & operator [] (const int & key) {\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples[index].val;\n\t}\t\n\t\n\tvoid put(const int & key, const E & val) {\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].key = key;\n\t\ttuples[index].val = val;\n\t\tif (tuples[index].in_use) return;\n\t\ttuples[index].in_use = true;\n\t\t++ _size;\n\t\tif (2 * _size > tuples.size())\n\t\t\t_double_tuples();\n\t}\t\n\t\n\tvoid _double_tuples() {\n\t\tvector<Tuple> non_empty_tuples;\n\t\tI(i, tuples.size())\n\t\t\tif (tuples[i].in_use)\n\t\t\t\tnon_empty_tuples.push_back(tuples[i]);\n\t\tclear();\n\t\ttuples.resize(tuples.size() * 2);\n\t\tI(i, non_empty_tuples.size())\n\t\t\tput(non_empty_tuples[i].key, non_empty_tuples[i].val);\n\t}\n\t\n\tstatic bool _between(size_t hole, size_t canonical, size_t tuple_index) {\n\t\tif (hole < tuple_index)\n\t\t\treturn canonical > hole && canonical <= tuple_index;\n\t\telse\n\t\t\treturn canonical > hole || canonical <= tuple_index;\n\t}\n\t\n\tvoid remove(const int & key) { \n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\ttuples[index].in_use = false;\n\t\t-- _size;\n\t\tsize_t hole = index;\n\t\tsize_t tuple_index = hole;\n\t\twhile (true) {\n\t\t\ttuple_index = (tuple_index + 1) % tuples.size();\n\t\t\tif (! tuples[tuple_index].in_use) return;\n\t\t\tsize_t canonical = canonical_index(tuples[tuple_index].key);\n\t\t\tif (_between(hole, canonical, tuple_index)) continue;\n\t\t\ttuples[hole] = tuples[tuple_index];\n\t\t\thole = tuple_index;\n\t\t\ttuples[hole].in_use = false;\n\t\t}\n\t}\n\t\n\tvoid clear() {\n\t\tI(i, tuples.size())\n\t\t\ttuples[i].in_use = false;\n\t\t_size = 0;\n\t}\n\tint size(){\n\t\treturn _size;\n\t}\n\t\n\tvector<int> getKeys(){\n\t\tvector<int> keylist;\n\t\tI(i,tuples.size())\n\t\t\tif(tuples[i].in_use == true)\n\t\t\t\tkeylist.push_back(tuples[i].key);\n\t\treturn keylist;\t\n\t}\n};",
            1595471411.4689715,
            100,
            "# 答案正确"
        ],
        [
            "A.4 (C++)",
            "謝敏華",
            "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <stdexcept>\nusing namespace std;\n#define I(i,n) for (size_t i = 0; i < n; ++ i)\n\nclass NoSuchKeyException {};\n\nsize_t circular_shift(size_t bits, int shift_bits) {\n\tconst int num_bits = 8 * sizeof(size_t);\n\tshift_bits = shift_bits % num_bits;\n\treturn bits << shift_bits | bits >> (num_bits - shift_bits);\n}\n\nsize_t hash_function(const string & key) {\n\tsize_t code = 0;\n\tI(i, key.size())\n\t\tcode ^= circular_shift(key[i], i * 5);\n\treturn code;\n}\n\n\tstring tostring(int x){\n\t\tstring ans;\n\t\twhile (x > 0){\n\t\t\tchar c=x%10+48;\n\t\t\tans=c+ans;\n\t\t\tx/=10; \n\t\t}\n\t\treturn ans; \n\t}\t\t\n\n\tint toint(string x){\n\t\tint ans=0;\n\t\tI(i,x.length()){\n\t\t\tans=ans*10+x[i]-'0';\n\t\t}\n\t\treturn ans;\n\t}\n\tclass Tuple_Str\n\t{\n\tpublic:\n\t\tstring key;\n\t\tstring val;\n\t\tbool in_use;\n\n\t\tTuple_Str() : in_use(false) {}\n\t\toperator int(){\n\t\t\treturn toint(val);\n\t\t}\n\t\toperator string(){\n\t\t\treturn val;\n\t\t}\n\t};\n\t\n\tclass Tuple_Int\n\t{\n\tpublic:\n\t\tint key;\n\t\tstring val;\n\t\tbool in_use;\n\n\t\tTuple_Int() : in_use(false) {}\n\t\toperator int(){\n\t\t\t\treturn toint(val);\n\t\t}\n\t\toperator string(){\n\t\t\treturn val;\n\t\t}\n\t};\t\t\nclass HT{\n\n\tvector<Tuple_Str> tuples_str;\n\tvector<Tuple_Int> tuples_int;\t\n\tsize_t _size;\n\t\n\tsize_t canonical_index(const string & key) const {\n\t\tsize_t hash_code = hash_function(key); \n\t\treturn hash_code % tuples_str.size();\n\t}\n\t\n\tsize_t canonical_index(const int & key) const {\n\t\tsize_t hash_code = key; \n\t\treturn hash_code % tuples_int.size();\n\t}\n\t\n\tsize_t indexOfKey(const string & key) const {\n\t\tsize_t index = canonical_index(key);\n\t\twhile (true) { \n\t\t\tif (! tuples_str[index].in_use) return index;\n\t\t\tif (tuples_str[index].key == key) return index;\n\t\t\tindex = (index + 1) % tuples_str.size();\n\t\t}\n\t}\n\t\n\tsize_t indexOfKey(const int & key) const {\n\t\tsize_t index = canonical_index(key);\n\t\twhile (true) { \n\t\t\tif (! tuples_int[index].in_use) return index;\n\t\t\tif (tuples_int[index].key == key) return index;\n\t\t\tindex = (index + 1) % tuples_int.size();\n\t\t}\n\t}\npublic:\n\tHT() : _size(0) {\n\t\ttuples_str.resize(2);\n\t\ttuples_int.resize(2);\n\t}\t\n\t\n\tbool containsKey(const string & key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\treturn tuples_str[index].in_use;\n\t}\n\t\n\tbool containsKey(const int& key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\treturn tuples_int[index].in_use;\n\t}\n\t\n\tconst string & operator [] (const string & key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples_str[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples_str[index].val;\n\t}\n\t\n\tconst string & operator [] (const int & key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples_int[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples_int[index].val;\n\t}\n\n\tTuple_Str & operator [] (const string & key) {\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples_str[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples_str[index];\n\t}\n\t\n\tTuple_Int & operator [] (const int & key) {\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples_int[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples_int[index];\n\t}\n\t\n\t\n\tvoid put(const string & key, const string & val) {\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples_str[index].key = key;\n\t\ttuples_str[index].val = val;\n\t\tif (tuples_str[index].in_use) return;\n\t\ttuples_str[index].in_use = true;\n\t\t++ _size;\n\t\tif (2 * _size > tuples_str.size())\n\t\t\t_double_tuples1();\n\t}\n\t\n\tvoid put(const int & key, const string & val) {\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples_int[index].key = key;\n\t\ttuples_int[index].val = val;\n\t\tif (tuples_int[index].in_use) return;\n\t\ttuples_int[index].in_use = true;\n\t\t++ _size;\n\t\tif (2 * _size > tuples_int.size())\n\t\t\t_double_tuples2();\n\t}\n\t\n\tvoid put(const string & key, const int & val){\n\t\tstring v=tostring(val);\n\t\tput(key,v);\n\t}\n\t\n\tvoid put(const int & key, const int & val){\n\t\tstring v=tostring(val);\n\t\tput(key,v);\t\t\n\t}\n\t\n\tvoid _double_tuples1() {\n\t\tvector<Tuple_Str> non_empty_tuples;\n\t\tI(i, tuples_str.size())\n\t\t\tif (tuples_str[i].in_use)\n\t\t\t\tnon_empty_tuples.push_back(tuples_str[i]);\n\t\tclear1();\n\t\ttuples_str.resize(tuples_str.size() * 2);\n\t\tI(i, non_empty_tuples.size())\n\t\t\tput(non_empty_tuples[i].key, non_empty_tuples[i].val);\n\t}\n\t\n\tvoid _double_tuples2() {\n\t\tvector<Tuple_Int> non_empty_tuples;\n\t\tI(i, tuples_int.size())\n\t\t\tif (tuples_int[i].in_use)\n\t\t\t\tnon_empty_tuples.push_back(tuples_int[i]);\n\t\tclear2();\n\t\ttuples_int.resize(tuples_int.size() * 2);\n\t\tI(i, non_empty_tuples.size())\n\t\t\tput(non_empty_tuples[i].key, non_empty_tuples[i].val);\n\t}\n\t\t\n\tsize_t size() const { return _size; }\n\t\n\tvoid clear1() {\n\t\tI(i, tuples_str.size()){\n\t\t\tif(tuples_str[i].in_use) _size --;\n\t\t\ttuples_str[i].in_use = false;\n\t\t}\n\n\t}\t\n\t\n\tvoid clear2() {\n\t\tI(i, tuples_int.size()){\n\t\t\tif(tuples_int[i].in_use) _size --;\n\t\t\ttuples_int[i].in_use = false;\n\t\t}\n\t}\n\n\tfriend ostream & operator << (ostream & out, const Tuple_Str & dict);\n\tfriend ostream & operator << (ostream & out, const Tuple_Int & dict);\n\n}; \n\nostream & operator << (ostream & out, const Tuple_Str & dict) {\n\tout << dict.val;\n\treturn out;\n}\nostream & operator << (ostream & out, const Tuple_Int & dict) {\n\tout << dict.val;\n\treturn out;\n}",
            1595746726.6462855,
            100,
            "# 答案正确"
        ],
        [
            "A.5 (C++)",
            "謝敏華",
            "#include <iostream>\n#include <sstream>\n#include<vector>\n#include<map> \n#include<algorithm>\nusing namespace std;\nint _size;\nclass V {\npublic:\n\tstring s;\n\tint i;\n\tV(int _i) :i(_i) {}\n\tV(string _s) :s(_s) {}\n\t\n\toperator string() {\n\t\treturn s;\n\t}\n\t\n\toperator int() {\n\t\treturn i;\n\t}\n\t\n\tV& operator=(int val){\n\t\ti=val;\n   \t\treturn *this;\n \t}\n \t\n \tV& operator=(string val){\n\t\ts=val;\n \t \treturn *this;\n \t}\n};\n\nclass HT {\n \tclass Tuple1 {\n \tpublic:\n  \t\tint key;\n  \t\tV value;\n  \t\tTuple1(int _key, int _value) :key(_key), value(_value) { _size++; };\n  \t\tTuple1(int _key, string _value) :key(_key), value(_value) { _size++; };\n \t};\n \t\n \tclass Tuple2 {\n \tpublic:\n  \t\tstring key;\n  \t\tV value;\n  \t\tTuple2(string _key, string _value) :key(_key), value(_value) { _size++; };\n  \t\tTuple2(string _key, int _value) :key(_key), value(_value) { _size++; };\n  \t\tvoid operator=(int val){\n   \t\t\tvalue=val;\n  \t\t}\n  \t\tvoid operator=(string val){\n   \t\t\tvalue=val;\n  \t\t}\n \t};\n \tvector<Tuple1>t1;\n \tvector<Tuple2>t2;\n\t\n\tpublic:\n\tint size() { \n\t\treturn _size; \n\t}\n\t\n \tvoid put(int _key, int _value) {\n\t\tt1.push_back(Tuple1(_key, _value));\n \t}\n \tvoid put(int _key, string _value) {\n \t\tt1.push_back(Tuple1(_key, _value));\n\t}\n \tvoid put(string _key, int _value) {\n \t\tt2.push_back(Tuple2(_key, _value));\n\t}\n \tvoid put(string _key, string _value) {\n\t\tt2.push_back(Tuple2(_key, _value));\n\t}\n \tV& operator [] (const int& key) {\n \t\tfor (int i = 0; i < t1.size(); ++i) {\n  \t\t\tif (t1[i].key == key) return t1[i].value;\n  \t\t}\n \t \tput(key,5);\n \t \tfor (int i = 0; i < t1.size(); ++i) {\n  \t\t\t if (t1[i].key == key) {\n  \t \t\t \treturn t1[i].value;\n   \t\t\t}\n  \t\t}\n \t}\n \t\n \tV& operator [] (const string& key) {\n \t\tfor (int i = 0; i < t2.size(); ++i) {\n\t\t\tif (t2[i].key == key) return t2[i].value;\n \t\t}\n\t\tput(key,5);\n\t\tfor (int i = 0; i < t2.size(); ++i) {\n\t\t\tif (t2[i].key == key) {\n  \t\t\treturn t2[i].value;\n \t\t\t}\n  \t\t}\n\t }\n\n};",
            1596112015.808661,
            100,
            "# 答案正确"
        ]
    ],
    "table_name": "答案"
}