{
    "__update_time__": 1595513462.7338238,
    "field_names": [
        "题目名",
        "用户名",
        "答案",
        "提交时间",
        "分数",
        "评语"
    ],
    "field_types": [
        "text",
        "text",
        "text",
        "time",
        "number",
        "text"
    ],
    "foreign_keys": {},
    "primary_keys": [],
    "rows": [
        [
            "测试1",
            "欧阳蓓",
            "#include <iostream>\n#include <string>\nusing namespace std;\nint main()\n{\n\tstring s1;\n\tstring s2;\n\tstring s3;\n\tcin >> s3;\n\tcin >> s2;\n\tcin >> s1;\n\tcout << s1 << \" \" << s2 << \" \" << s3;\n}",
            1587522673.9416633,
            100,
            "# 答案正确"
        ],
        [
            "测试2",
            "欧阳蓓",
            "#include <iostream>\n#include <string>\n#include<vector>\nusing namespace std;\nint main()\n{\n\tvector<string> v;\n\tstring s;\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tcin >> s;\n\t\tv.push_back(s);\n\t}\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tfor (int j = 0; j < 9; j++)\n\t\t {\n\t\t if (v[j] > v[j + 1])\n\t\t {\n\t\t\t swap(v[j], v[j + 1]);\n\t\t }\n\t\t }\n\t}\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tcout << v[i] << \" \";\n\n\t}\n}",
            1587608849.3329375,
            100,
            "# 答案正确"
        ],
        [
            "1.1 (C++)",
            "欧阳蓓",
            "class Matrix5x5\n{\n    public:\n\t Matrix5x5 ();\n   double get(int a, int b);\n   void  set(int a, int b, double c);\n    \n    private:\n    double matrix [5][5];\n    \n};\n\n Matrix5x5 :: Matrix5x5    ()\n\t {\n\t\tfor (int i = 0; i < 5; i++)\n    {\n        for (int j = 0; j < 5; j++)\n        {\n            set(i,j,0);\n        }\n    }\n\t }\ndouble Matrix5x5 ::  get(int a, int b)\n    {\n        return matrix[a][b];\n    }\n void Matrix5x5 :: set(int a, int b, double c)\n    {\n        matrix [a][b] = c;\n    }\nMatrix5x5 operator + ( Matrix5x5 & a,Matrix5x5 & b)\n{\n    Matrix5x5 c;\n    for (int i = 0; i < 5; i++)\n    {\n        for (int j = 0; j < 5; j++)\n        {\n            double ans = a.get(i,j) + b.get(i,j);\n            c.set(i,j,ans);\n        }\n    }\n    return c;\n}",
            1587745261.1640875,
            100,
            "# 答案正确"
        ],
        [
            "1.2 (C++)",
            "欧阳蓓",
            "\nclass  School \n{\n\tpublic: \n\tSchool()\n\t{\n \n\t\tchar n[10] = \"NO_NAME\";\n\t\tsetName(n);\n\t\tsetAge(0);\n\t\t \n\t}\n\tvoid setName(char  n[])\n\t{\n\t\t int i;\n\t\tfor(  i = 0; n[i] != '\\0'; i++ )\n\t\t\tname[i] = n[i];\n\t\tname[i] = '\\0'; \n\t\t \n\t}\n\tvoid setAge(int year)\n\t{\n\t\tage = year;\n\t}\n\tvoid operator ++ ()\n\t{\n\t\tage++;\n\t}\n\tchar name[10];\n\tint age;\n};",
            1588213399.376839,
            100,
            "# 答案正确"
        ],
        [
            "2.1 (C++)",
            "欧阳蓓",
            "#include<iostream>\nusing namespace std;\nclass Matrix\n{\n    public:\n    Matrix()\n    {\n        rows = 0;\n        columns = 0;\n        values = nullptr;\n    }\n    Matrix(int rows, int columns)\n    {\n        this->rows = rows;\n        this->columns = columns;\n        if (values != nullptr)\n        delete values;\n\t\t\n        values = new  double * [ rows];\n        for(int i = 0; i < rows; i++)\n        {\n            values[i] = new double [columns];\n\t\t\t\t\tfor (int j = 0; j < columns; j++)\n\t\t\t\t\t\tvalues[i][j] = 0;\n        }\n    }\n    ~Matrix()\n    {\n        for  (int i = 0; i < rows; i++)\n\t\t{\n\t\t\tif (values[i] != 0)\n\t\t\t\tdouble values[i];\n\t\t}\n\t\tif (values != 0)\n\t\t\tdouble values;\n    }\n    void print()\n    {\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < columns; j++)\n            {\n                cout<<values[ i][j]<<\"    \";\n \n            }\n            cout << endl;\n        }\n    }\n    private:\n    int rows;\n    int columns;\n    double ** values;\n};",
            1588851192.892372,
            100,
            "# 答案正确"
        ],
        [
            "2.2 (C++)",
            "欧阳蓓",
            "#include<iostream>\n#include <iomanip>\nusing namespace std;\nclass Matrix\n{\n    public:\n    Matrix()\n    {\n        rows = 0;\n        columns = 0;\n        values = nullptr;\n    }\n    Matrix(int rows, int columns)\n    {\n        this->rows = rows;\n        this->columns = columns;\n        if (values != nullptr)\n        delete values;\n\t\t\n        values = new  double * [ rows];\n        for(int i = 0; i < rows; i++)\n        {\n            values[i] = new double [columns];\n\t\t\t\t\tfor (int j = 0; j < columns; j++)\n\t\t\t\t\t\tvalues[i][j] = 0;\n        }\n    }\n\tMatrix(int rows, int columns, double v[] )\n    {\n        this->rows = rows;\n        this->columns = columns;\n        if (values != nullptr)\n        delete values;\n        values = new  double * [ rows];\n        for(int i = 0; i < rows; i++)\n        {\n            values[i] = new double [columns];\n\t\t\t\t\tfor (int j = 0; j < columns; j++)\n\t\t\t\t\t\tthis-> values[i][j] = v[i * columns + j];\n        }\n    }\n    ~Matrix()\n    {\n        for  (int i = 0; i < rows; i++)\n\t\t{\n\t\t\tif (values[i] != 0)\n\t\t\t\tdouble values[i];\n\t\t}\n\t\tif (values != 0)\n\t\t\tdouble values;\n    }\n    void print()\n    {\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < columns; j++)\n            {\n\t\t\t\t\t\t\n                cout<< setw(5) <<values[ i][j] ;\n \n            }\n            cout << endl;\n        }\n    }\n    private:\n    int rows;\n    int columns;\n    double ** values;\n};",
            1588851518.24032,
            100,
            "# 答案正确"
        ],
        [
            "2.3 (C++)",
            "欧阳蓓",
            "#include<iostream>\n#include <iomanip>\nusing namespace std;\nclass Matrix\n{\n    public:\n    Matrix()\n    {\n        rows = 0;\n        columns = 0;\n        values = nullptr;\n    }\n    Matrix(int rows, int columns)\n    {\n        this->rows = rows;\n        this->columns = columns;\n        if (values != nullptr)\n        delete values;\n\t\t\n        values = new  double * [ rows];\n        for(int i = 0; i < rows; i++)\n        {\n            values[i] = new double [columns];\n\t\t\t\t\tfor (int j = 0; j < columns; j++)\n\t\t\t\t\t\tvalues[i][j] = 0;\n        }\n    }\n\tMatrix(int rows, int columns, double v[] )\n    {\n        this->rows = rows;\n        this->columns = columns;\n        if (values != nullptr)\n        delete values;\n        values = new  double * [ rows];\n        for(int i = 0; i < rows; i++)\n        {\n            values[i] = new double [columns];\n\t\t\t\t\tfor (int j = 0; j < columns; j++)\n\t\t\t\t\t\tthis-> values[i][j] = v[i * columns + j];\n        }\n    }\n\t  Matrix(const Matrix & matrix2)\n\t  {\n\t\t\t this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        if (values != nullptr)\n        delete values;\n        values = new  double * [ rows];\n\t\t   for(int i = 0; i < rows; i++)\n        {\n            values[i] = new double [columns];\n\t\t\t\t\tfor (int j = 0; j < columns; j++)\n\t\t\t\t\t\tthis-> values[i][j] = matrix2.values[i][j];\n        }\n\t  }\n    ~Matrix()\n    {\n        for  (int i = 0; i < rows; i++)\n\t\t{\n\t\t\tif (values[i] != 0)\n\t\t\t\tdouble values[i];\n\t\t}\n\t\tif (values != 0)\n\t\t\tdouble values;\n    }\n    void print()\n    {\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < columns; j++)\n            {\n\t\t\t\t\t\t\n                cout<< \"    \"<<values[ i][j] ;\n \n            }\n            cout << endl;\n        }\n    }\n    private:\n    int rows;\n    int columns;\n    double ** values;\n};",
            1588851624.8339987,
            100,
            "# 答案正确"
        ],
        [
            "2.5 (C++)",
            "欧阳蓓",
            "#include<iostream>\n#include <iomanip>\nusing namespace std;\nclass Matrix\n{\n    public:\n    Matrix()\n    {\n        rows = 0;\n        columns = 0;\n        values = nullptr;\n    }\n    Matrix(int rows, int columns)\n    {\n        this->rows = rows;\n        this->columns = columns;\n        if (values != nullptr)\n        delete values;\n\t\t\n        values = new  double * [ rows];\n        for(int i = 0; i < rows; i++)\n        {\n            values[i] = new double [columns];\n\t\t\t\t\tfor (int j = 0; j < columns; j++)\n\t\t\t\t\t\tvalues[i][j] = 0;\n        }\n    }\n\tMatrix(int rows, int columns, double v[] )\n    {\n        this->rows = rows;\n        this->columns = columns;\n        if (values != nullptr)\n        delete values;\n        values = new  double * [ rows];\n        for(int i = 0; i < rows; i++)\n        {\n            values[i] = new double [columns];\n\t\t\t\t\tfor (int j = 0; j < columns; j++)\n\t\t\t\t\t\tthis-> values[i][j] = v[i * columns + j];\n        }\n    }\n\t  Matrix(const Matrix & matrix2)\n\t  {\n\t\t\t this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        if (values != nullptr)\n        delete values;\n        values = new  double * [ rows];\n\t\t   for(int i = 0; i < rows; i++)\n        {\n            values[i] = new double [columns];\n\t\t\t\t\tfor (int j = 0; j < columns; j++)\n\t\t\t\t\t\tthis-> values[i][j] = matrix2.values[i][j];\n        }\n\t  }\n\t Matrix getRow(int row)\n\t {\n\t\tMatrix a (1, columns);\n\t\t for(int i = 0; i < columns; i++)\n\t\t {\n\t\t\ta.values[0][i] = this->values[row - 1][i];\n\t\t }\n\t\t return a;\n\t }\n\t Matrix getColumn(int col)\n\t {\n\t\tMatrix a (rows, 1);\n\t\t for (int i = 0; i < rows; i++)\n\t\t {\n\t\t\ta.values[i][0] = this->values[i][col - 1];\n\t\t }\n\t\t return a;\n\t\t \n\t\t \n\t }\n    ~Matrix()\n    {\n        for  (int i = 0; i < rows; i++)\n\t\t{\n\t\t\tif (values[i] != 0)\n\t\t\t\tdouble values[i];\n\t\t}\n\t\tif (values != 0)\n\t\t\tdouble values;\n    }\n    void print()\n    {\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < columns; j++)\n            {\n\t\t\t\t\t\t\n                cout<< \"    \"<<values[ i][j] ;\n \n            }\n            cout << endl;\n        }\n    }\n    private:\n    int rows;\n    int columns;\n    double ** values;\n};",
            1588851900.1000023,
            100,
            "# 答案正确"
        ],
        [
            "2.6 (C++)",
            "欧阳蓓",
            "#include <iostream>\nusing namespace std;\nclass Matrix\n{\npublic:\n    Matrix()\n    {\n        matrix = nullptr;\n        row = 0;\n        col = 0;\n    }\n    Matrix(int row, int col)\n    {\n        this -> row = row;\n        this -> col = col; \n        matrix = new double*[row];\n        for (int i = 0; i < row; ++i)\n        {\n            matrix[i] = new double [col];\n            for (int j = 0; j < col; ++j)\n            {\n                matrix[i][j] = 0;\n            }\n        }\n    }\n\n    Matrix(int row, int col, const double *value)\n    {\n        this -> row = row;\n        this -> col = col;\n        matrix = new double*[row];\n        for (int i = 0; i < row; ++i)\n        {\n            matrix[i] = new double [col];\n            for (int j = 0; j < col; ++j)\n            {\n                matrix[i][j] = value[i * col + j];\n            }\n        }\n    }\n\n    Matrix (const Matrix & matrix1)\n    {\n        row = matrix1.row;\n        col = matrix1.col;\n        matrix = new double*[row];\n        for (int i = 0; i < row; ++i)\n        {\n            matrix[i] = new double [col];\n            for (int j = 0; j < col; ++j)\n            {\n                matrix[i][j] = matrix1.matrix[i][j];\n            }\n        }\n    }\n\n    ~Matrix()\n    {\n        for (int i = 0; i < row; ++i)\n        {\n            if (matrix[i] != nullptr) delete [] matrix[i];\n        }\n        if (matrix != nullptr) delete [] matrix;\n    }\n\n   \n    Matrix concatenateRows(Matrix & matrix1)\n    {\n        Matrix t(row  * 2 , col);\n        for(int i = 0; i < row * 2; ++i)\n        {\n            for(int j = 0; j < col; ++j)\n            {\n\t\t\t\t\t\tif ( i < row)\n                t.matrix[i][j] = matrix[i][j];\n\t\t\t\telse\n\t\t\t\t\t t.matrix[i][j] = matrix1.matrix[i - row][j];\n            }\n        }\n        \n        return t;\n    }\n\n    Matrix concatenateColumns(Matrix & matrix1)\n    {\n        Matrix t(row, col + matrix1.col);\n        for(int i = 0; i < row ; ++i)\n        {\n            for(int j = 0; j < col * 2; ++j)\n            {\n\t\t\t\t\t\tif (j < col)\n                t.matrix[i][j] = matrix[i][j];\n\t\t\t\t\t\telse\n\t\t\t\t\t  t.matrix[i][j] = matrix1.matrix[i][j - col];\n            }\n        }\n         \n        return t;\n    }\n\n   \n\n    \n    void print()\n    {\n        for (int i = 0; i < row; ++i)\n        {\n            for (int j = 0; j < col; ++j)\n            {\n                cout << \"    \" << matrix[i][j]  ;\n            }\n            cout << endl;\n        }\n    }\n \n   \n     \n \n \n\nprivate:\n    double **matrix;\n    int row;\n    int col;\n};\n",
            1588896275.3768895,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/08",
            "欧阳蓓",
            "double & Tensor_get(int dimensions, const int sizes[],   double data[], int x0, int x1, int x2, int x3)\n{\n\tif (dimensions == 1)\n\t\treturn   data[x0];\n\tif (dimensions == 2)\n\t\treturn data[x0 * sizes[1] +  x1];\n\tif (dimensions == 3)\n\t\treturn data[x0 * sizes[1] * sizes[2] +  x1 * sizes[2] + x2  ];\n\tif (dimensions == 4)\n\t\treturn data[x0 * sizes[1] * sizes[2] * sizes[3]+  x1 * sizes[2]  * sizes[3]+ x2 * sizes[3] + x3  ];\n}",
            1588905869.25102,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/14",
            "欧阳蓓",
            "#include<cstdio>\n#include<iostream>\nusing namespace std;\nvoid Tensor_print(int dimensions, const int sizes[], const double data[])\n{\n\tif (dimensions == 1)\n\t{\n\t\tprintf(\"Tensor of %d\\n\",sizes[0]);\n\t\tfor (int i = 0; i < sizes[0]; i++)\n\t\t{\n\t\t\tcout << data[i] << endl;\n\t\t}\n\t\t\n\t}\n\tif (dimensions == 2)\n\t{\n\t\tprintf(\"Tensor of %dx%d\\n\",sizes[0],sizes[1]);\n\t\tfor (int i = 0; i < sizes[0]; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < sizes[1]; j++)\n\t\t\t{\n\t\t\t\tcout<<\"    \"<<data[i * sizes[1] + j];\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t}\n\tif (dimensions == 3)\n    {\n        printf(\"Tensor of %dx%dx%d\\n\",sizes[0],sizes[1],sizes[2]);\n        for (int i = 0; i < sizes[0]; i++)\n        {\n            printf(\"date[%d]\\n\",i);\n            for (int j = 0; j < sizes[1];j++)\n            {\n                for (int k = 0; k < sizes[2]; k++)\n                {\n                    cout <<\"    \"<< data[i*sizes[1]*sizes[2] + j * sizes[2] + k];\n                }\n                cout << endl;\n            }\n        }\n    }\n    if (dimensions==4)\n    {\n\t\tprintf(\"Tensor of %dx%dx%dx%d\\n\",sizes[0],sizes[1],sizes[2],sizes[3]);\n        for (int i = 0; i < sizes[0];i++)\n        {\n            for (int j = 0; j < sizes[1]; j++)\n            {\n                printf(\"data[%d][%d]\\n\",i,j);\n                for (int k = 0; k < sizes[2]; k++)\n                {\n                    for (int m = 0; m < sizes[3];m++)\n                    {\n                        cout << \"    \" <<data[i*sizes[1]*sizes[2]*sizes[3] + j * sizes[2] * sizes[3] + k * sizes[3] + m];\n                    }\n                    cout << endl;\n                }\n            }\n        }\n    }\n\tcout << endl;\n}",
            1589425962.6375406,
            100,
            "# 答案不正确\n\n# 随机输入:\n3.6\n4.2\n4.8\n4.2\n\n\n# 参考答案:\nTensor of 5\n3.6\n3.6\n3.6\n3.6\n3.6\n\nTensor of 3x4\n    4.2    4.2    4.2    4.2\n    4.2    4.2    4.2    4.2\n    4.2    4.2    4.2    4.2\n\nTensor of 3x4x5\ndata[0]\n    4.8    4.8    4.8    4.8    4.8\n    4.8    4.8    4.8    4.8    4.8\n    4.8    4.8    4.8    4.8    4.8\n    4.8    4.8    4.8    4.8    4.8\ndata[1]\n    4.8    4.8    4.8    4.8    4.8\n    4.8    4.8    4.8    4.8    4.8\n    4.8    4.8    4.8    4.8    4.8\n    4.8    4.8    4.8    4.8    4.8\ndata[2]\n    4.8    4.8    4.8    4.8    4.8\n    4.8    4.8    4.8    4.8    4.8\n    4.8    4.8    4.8    4.8    4.8\n    4.8    4.8    4.8    4.8    4.8\n\nTensor of 2x3x4x5\ndata[0][0]\n    4.2    4.2    4.2    4.2    4.2\n    4.2    4.2    4.2    4.2    4.2\n    4.2    4.2    4.2    4.2    4.2\n    4.2    4.2    4.2    4.2    4.2\ndata[0][1]\n    4.2    4.2    4.2    4.2    4.2\n    4.2    4.2    4.2    4.2    4.2\n    4.2    4.2    4.2    4.2    4.2\n    4.2    4.2    4.2    4.2    4.2\ndata[0][2]\n    4.2    4.2    4.2    4.2    4.2\n    4.2    4.2    4.2    4.2    4.2\n    4.2    4.2    4.2    4.2    4.2\n    4.2    4.2    4.2    4.2    4.2\ndata[1][0]\n    4.2    4.2    4.2    4.2    4.2\n    4.2    4.2    4.2    4.2    4.2\n    4.2    4.2    4.2    4.2    4.2\n    4.2    4.2    4.2    4.2    4.2\ndata[1][1]\n    4.2    4.2    4.2    4.2    4.2\n    4.2    4.2    4.2    4.2    4.2\n    4.2    4.2    4.2    4.2    4.2\n    4.2    4.2    4.2    4.2    4.2\ndata[1][2]\n    4.2    4.2    4.2    4.2    4.2\n    4.2    4.2    4.2    4.2    4.2\n    4.2    4.2    4.2    4.2    4.2\n    4.2    4.2    4.2    4.2    4.2\n\n\n# 我的答案:\nTensor of 5\n3.6\n3.6\n3.6\n3.6\n3.6\n\n\nTensor of 3x4\n    4.2    4.2    4.2    4.2\n    4.2    4.2    4.2    4.2\n    4.2    4.2    4.2    4.2\n\n\nTensor of 3x4x5\ndate[0]\n    4.8    4.8    4.8    4.8    4.8\n    4.8    4.8    4.8    4.8    4.8\n    4.8    4.8    4.8    4.8    4.8\n    4.8    4.8    4.8    4.8    4.8\ndate[1]\n    4.8    4.8    4.8    4.8    4.8\n    4.8    4.8    4.8    4.8    4.8\n    4.8    4.8    4.8    4.8    4.8\n    4.8    4.8    4.8    4.8    4.8\ndate[2]\n    4.8    4.8    4.8    4.8    4.8\n    4.8    4.8    4.8    4.8    4.8\n    4.8    4.8    4.8    4.8    4.8\n    4.8    4.8    4.8    4.8    4.8\n\n\nTensor of 2x3x4x5\ndata[0][0]\n    4.2    4.2    4.2    4.2    4.2\n    4.2    4.2    4.2    4.2    4.2\n    4.2    4.2    4.2    4.2    4.2\n    4.2    4.2    4.2    4.2    4.2\ndata[0][1]\n    4.2    4.2    4.2    4.2    4.2\n    4.2    4.2    4.2    4.2    4.2\n    4.2    4.2    4.2    4.2    4.2\n    4.2    4.2    4.2    4.2    4.2\ndata[0][2]\n    4.2    4.2    4.2    4.2    4.2\n    4.2    4.2    4.2    4.2    4.2\n    4.2    4.2    4.2    4.2    4.2\n    4.2    4.2    4.2    4.2    4.2\ndata[1][0]\n    4.2    4.2    4.2    4.2    4.2\n    4.2    4.2    4.2    4.2    4.2\n    4.2    4.2    4.2    4.2    4.2\n    4.2    4.2    4.2    4.2    4.2\ndata[1][1]\n    4.2    4.2    4.2    4.2    4.2\n    4.2    4.2    4.2    4.2    4.2\n    4.2    4.2    4.2    4.2    4.2\n    4.2    4.2    4.2    4.2    4.2\ndata[1][2]\n    4.2    4.2    4.2    4.2    4.2\n    4.2    4.2    4.2    4.2    4.2\n    4.2    4.2    4.2    4.2    4.2\n    4.2    4.2    4.2    4.2    4.2\n\n"
        ],
        [
            "2.4 (C++)",
            "欧阳蓓",
            "#include<iostream>\n#include <iomanip>\nusing namespace std;\nclass Matrix\n{\npublic:\n    Matrix()\n    {\n        rows = 0;\n        columns = 0;\n        values = 0;\n    }\n    Matrix(int rows, int columns)\n    {\n        this->rows = rows;\n        this->columns = columns;\n        \n        values = new  double[rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            values[i] = 0;\n        }\n    }\n    Matrix(int r, int c, double v[])\n    {\n        this->rows = r;\n        this->columns = c;\n         \n        values = new  double[r * c];\n        for (int i = 0; i < r * c; i++)\n        {\n            values[i] = v[i];\n        }\n    }\n    void set(int r, int c, double v)\n    {\n        values[(r - 1) * columns + c - 1] = v;\n    }\n    Matrix& operator= (const Matrix& matrix2)\n    {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        if (values != nullptr)\n            delete []values;\n\t\t\n        values = new  double[rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            values[i] = matrix2.values[i];\n        }\n        return *this;\n    }\n    Matrix(const Matrix& matrix2)\n    {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n       \n        values = new  double[rows * columns];\n        for (int i = 0; i < rows; i++)\n        {\n            values[i] = matrix2.values[i];\n        }\n    }\n\n    ~Matrix()\n    {\n        if (values != 0)\n            delete []values;\n    }\n    void print()\n    {\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < columns; j++)\n            {\n\n                cout << \"    \" << values[i * columns + j];\n            }\n            cout << endl;\n        }\n    }\nprivate:\n    int rows;\n    int columns;\n    double* values;\n};",
            1589518822.5718746,
            100,
            "# 答案正确"
        ],
        [
            "2.7 (C++)",
            "欧阳蓓",
            "#include<iostream>\n#include <iomanip>\nusing namespace std;\nclass Matrix\n{\npublic:\n    Matrix()\n    {\n        rows = 0;\n        columns = 0;\n        values = 0;\n    }\n    Matrix(int rows, int columns)\n    {\n        this->rows = rows;\n        this->columns = columns;\n        \n        values = new  double[rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            values[i] = 0;\n        }\n    }\n    Matrix(int r, int c, double v[])\n    {\n        this->rows = r;\n        this->columns = c;\n        values = new  double[r * c];\n        for (int i = 0; i < r * c; i++)\n        {\n            values[i] = v[i];\n        }\n    }\n    Matrix(const Matrix& matrix2)\n    {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        values = new  double[rows * columns];\n        for (int i = 0; i < rows; i++)\n        {\n            values[i] = matrix2.values[i];\n        }\n    }\n    void set(int r, int c, double v)\n    {\n        values[(r - 1) * columns + c - 1] = v;\n    }\n    Matrix& operator= (const Matrix& matrix2)\n    {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        if (values != nullptr)\n            delete []values;\n\n        values = new  double[rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            values[i] = matrix2.values[i];\n        }\n        return *this;\n    }\n    Matrix reshape(int r , int c ) const\n    {\n        double * a = new double [r * c];\n        int m = 0;\n        for (int i = 0; i < columns; i++)\n        {\n            for (int j = 0; j < rows; j++)\n            {\n                a[m++] = this->values[j * columns + i];\n            }\n        }\n        m = 0;\n        Matrix temp(r,c);\n        for (int i = 0; i < c; i++)\n        {\n            for(int j = 0; j < r; j++)\n            {\n                temp.values[j * c + i] = a[m++];\n            }\n        }\n        delete []a;\n        return temp;\n\n    }\n    ~Matrix()\n    {\n        if (values != 0)\n            delete []values;\n    }\n    void print()\n    {\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < columns; j++)\n            {\n\n                cout << \"    \" << values[i * columns + j];\n            }\n            cout << endl;\n        }\n    }\nprivate:\n    int rows;\n    int columns;\n    double* values;\n};",
            1589518968.2946215,
            100,
            "# 答案正确"
        ],
        [
            "2.8 (C++)",
            "欧阳蓓",
            "#include<iostream>\n#include <iomanip>\nusing namespace std;\nclass Matrix\n{\npublic:\n    Matrix()\n    {\n        rows = 0;\n        columns = 0;\n        values = 0;\n    }\n    Matrix(int rows, int columns)\n    {\n        this->rows = rows;\n        this->columns = columns;\n        \n        values = new  double[rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            values[i] = 0;\n        }\n    }\n    Matrix(int r, int c, double v[])\n    {\n        this->rows = r;\n        this->columns = c;\n        values = new  double[r * c];\n        for (int i = 0; i < r * c; i++)\n        {\n            values[i] = v[i];\n        }\n    }\n    Matrix(const Matrix& matrix2)\n    {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        values = new  double[rows * columns];\n        for (int i = 0; i < rows; i++)\n        {\n            values[i] = matrix2.values[i];\n        }\n    }\n    void set(int r, int c, double v)\n    {\n        values[(r - 1) * columns + c - 1] = v;\n    }\n    Matrix& operator= (const Matrix& matrix2)\n    {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        if (values != nullptr)\n            delete []values;\n\n        values = new  double[rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            values[i] = matrix2.values[i];\n        }\n        return *this;\n    }\n    Matrix reshape(int r , int c ) const\n    {\n        double * a = new double [r * c];\n        int m = 0;\n        for (int i = 0; i < columns; i++)\n        {\n            for (int j = 0; j < rows; j++)\n            {\n                a[m++] = this->values[j * columns + i];\n            }\n        }\n        m = 0;\n        Matrix temp(r,c);\n        for (int i = 0; i < c; i++)\n        {\n            for(int j = 0; j < r; j++)\n            {\n                temp.values[j * c + i] = a[m++];\n            }\n        }\n        delete []a;\n        return temp;\n    }\n    Matrix transpose()\n    {\n        double * a = new double [rows * columns];\n        int m = 0;\n        for (int i = 0; i < columns; i++)\n        {\n            for (int j = 0; j < rows; j++)\n            {\n                a[m++] = this->values[j * columns + i];\n            }\n        }\n        Matrix temp(columns,rows,a);\n        delete []a;\n        return temp;\n    }\n    ~Matrix()\n    {\n        if (values != 0)\n            delete []values;\n    }\n    void print()\n    {\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < columns; j++)\n            {\n\n                cout << \"    \" << values[i * columns + j];\n            }\n            cout << endl;\n        }\n    }\nprivate:\n    int rows;\n    int columns;\n    double* values;\n};",
            1589519212.0823784,
            100,
            "# 答案正确"
        ],
        [
            "2.10 (C++)",
            "欧阳蓓",
            "#include<iostream>\n#include <iomanip>\nusing namespace std;\nclass Matrix\n{\npublic:\n   Matrix()\n    {\n        rows = 0;\n        columns = 0;\n        values = nullptr;\n    }\n    Matrix(int rows, int columns)\n    {\n        this->rows = rows;\n        this->columns = columns;\n        values = new  double[rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            values[i] = 0;\n        }\n    }\n    Matrix(int r, int c, double v[])\n    {\n        this->rows = r;\n        this->columns = c;\n        values = new  double[r * c];\n        for (int i = 0; i < r * c; i++)\n        {\n            values[i] = v[i];\n        }\n    }\n  Matrix(const Matrix& matrix2)\n    {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        values = new  double[rows * columns];\n        for (int i = 0; i < rows; i++)\n        {\n            values[i] = matrix2.values[i];\n        }\n    }\n   \n    Matrix operator * (const Matrix & matrix2) const\n    {\n        Matrix temp(rows,rows);\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < rows; j++)\n            {\n                double sum = 0;\n                for(int k = 0; k < columns; k++)\n                {\n                    sum += this->values[i * columns + k] * matrix2.values[k * rows + j];\n                }\n                temp.values[i*rows+j] = sum;\n            }\n        }\n        return temp;\n    }\n    Matrix  operator * (double v ) const\n    {\n        double * a = new double[rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = v * values[i];\n        }\n        Matrix temp (rows,columns,a);\n        delete []a;\n        return temp;\n    }\n    Matrix& operator= (const Matrix& matrix2)\n    {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        if (values != nullptr)\n            delete []values;\n\n        values = new  double[rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            values[i] = matrix2.values[i];\n        }\n        return *this;\n    }\n    Matrix reshape(int r , int c ) const\n    {\n        double * a = new double [r * c];\n        int m = 0;\n        for (int i = 0; i < columns; i++)\n        {\n            for (int j = 0; j < rows; j++)\n            {\n                a[m++] = this->values[j * columns + i];\n            }\n        }\n        m = 0;\n        Matrix temp(r,c);\n        for (int i = 0; i < c; i++)\n        {\n            for(int j = 0; j < r; j++)\n            {\n                temp.values[j * c + i] = a[m++];\n            }\n        }\n        delete []a;\n        return temp;\n    }\n    Matrix transpose()\n    {\n        double * a = new double [rows * columns];\n        int m = 0;\n        for (int i = 0; i < columns; i++)\n        {\n            for (int j = 0; j < rows; j++)\n            {\n                a[m++] = this->values[j * columns + i];\n            }\n        }\n        Matrix temp(columns,rows,a);\n        delete []a;\n        return temp;\n    }\n    ~Matrix()\n    {\n        if (values != 0)\n            delete []values;\n    }\n    void print()\n    {\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < columns; j++)\n            {\n\n                cout << \"    \" << values[i * columns + j];\n            }\n            cout << endl;\n        }\n    }\nprivate:\n    int rows;\n    int columns;\n    double* values;\n};",
            1589682384.848221,
            100,
            "# 答案正确"
        ],
        [
            "2.11 (C++)",
            "欧阳蓓",
            "#include <iostream>\n\nusing namespace std;\n\nclass Matrix\n{\npublic:\n    Matrix()\n    {\n        matrix = nullptr;\n        rows = 0;\n        columns = 0;\n    }\n\n    Matrix(int rows, int columns)\n    {\n        this -> rows = rows;\n        this -> columns = columns;\n        matrix = new double*[rows];\n        for (int i = 0; i < rows; ++i)\n        {\n            matrix[i] = new double [columns];\n            for (int j = 0; j < columns; ++j)\n            {\n                matrix[i][j] = 0;\n            }\n        }\n    }\n\n    Matrix(int rows, int columns, const double *value)\n    {\n        this -> rows = rows;\n        this -> columns = columns;\n        matrix = new double*[rows];\n        for (int i = 0; i < rows; ++i)\n        {\n            matrix[i] = new double [columns];\n            for (int j = 0; j < columns; ++j)\n            {\n                matrix[i][j] = value[i * columns + j];\n            }\n        }\n    }\n\n    Matrix (const Matrix & matrix1)\n    {\n        rows = matrix1.rows;\n        columns = matrix1.columns;\n        matrix = new double*[rows];\n        for (int i = 0; i < rows; ++i)\n        {\n            matrix[i] = new double [columns];\n            for (int j = 0; j < columns; ++j)\n            {\n                matrix[i][j] = matrix1.matrix[i][j];\n            }\n        }\n    }\n\n    ~Matrix()\n    {\n        for (int i = 0; i < rows; ++i)\n        {\n            if (matrix[i] != nullptr) delete [] matrix[i];\n        }\n        if (matrix != nullptr) delete [] matrix;\n    }\n\n    Matrix max()\n    {\n        if (rows > 1 && columns > 1)\n        {\n            Matrix t(1, columns);\n            double num_max = 0;\n            for (int i = 0; i < columns; ++i)\n            {\n                for (int j = 0; j < rows; ++j)\n                {\n                    num_max = num_max > matrix[j][i] ? num_max : matrix[j][i];\n                }\n                t[0][i] = num_max;\n                num_max = 0;\n            }\n            return t;\n        }\n        else if (rows == 1 && columns > 1)\n        {\n            double num_max[1] = {0};\n            for (int i = 0; i < columns; ++i)\n            {\n                num_max[0] = num_max[0] > matrix[0][i] ? num_max[0] : matrix[0][i];\n            }\n            Matrix t(1, 1, num_max);\n            return t;\n        }\n        else return *this;\n    }\n\n    Matrix min()\n    {\n        if (rows > 1 && columns > 1)\n        {\n            Matrix t(1, columns);\n            double num_min = 99999999;\n            for (int i = 0; i < columns; ++i)\n            {\n                for (int j = 0; j < rows; ++j)\n                {\n                    num_min = num_min > matrix[j][i] ? matrix[j][i] : num_min;\n                }\n                t[0][i] = num_min;\n                num_min = 99999999;\n            }\n            return t;\n        }\n        else if (rows == 1 && columns > 1)\n        {\n            double num_min[1] = {99999999};\n            for (int i = 0; i < columns; ++i)\n            {\n                num_min[0] = num_min[0] > matrix[0][i] ? matrix[0][i] : num_min[0];\n            }\n            Matrix t(1, 1, num_min);\n            return t;\n        }\n        else return *this;\n    }\n\n    Matrix sum()\n    {\n        if (rows > 1 && columns > 1)\n        {\n            Matrix t(1, columns);\n            double sum = 0;\n            for (int i = 0; i < columns; ++i)\n            {\n                for (int j = 0; j < rows; ++j)\n                {\n                    sum +=  matrix[j][i];\n                }\n                t[0][i] = sum;\n                sum = 0;\n            }\n            return t;\n        }\n        else if (rows == 1 && columns > 1)\n        {\n            double sum[1] = {0};\n            for (int i = 0; i < columns; ++i)\n            {\n                sum[0] += matrix[0][i];\n            }\n            Matrix t(1, 1, sum);\n            return t;\n        }\n        else return *this;\n    }\n\n    double * operator [] (int n)\n    {\n        return matrix[n];\n    }\n\n    void print()\n    {\n        for (int i = 0; i < rows; ++i)\n        {\n            for (int j = 0; j < columns; ++j)\n            {\n                cout << \"    \" << matrix[i][j];\n            }\n            cout << endl;\n        }\n    }\n\nprivate:\n    double **matrix;\n    int rows;\n    int columns;\n};",
            1589684234.978668,
            100,
            "# 答案正确"
        ],
        [
            "2.12 (C++)",
            "欧阳蓓",
            "#include<iostream>\n#include <iomanip>\nusing namespace std;\n#include<cmath>\n\nclass Matrix\n{\npublic:\n    Matrix()\n    {\n        rows = 0;\n        columns = 0;\n        values = 0;\n    }\n    Matrix(int rows, int columns)\n    {\n        this->rows = rows;\n        this->columns = columns;\n        \n        values = new  double[rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            values[i] = 0;\n        }\n    }\n    Matrix(int r, int c, double v[])\n    {\n        this->rows = r;\n        this->columns = c;\n        values = new  double[r * c];\n        for (int i = 0; i < r * c; i++)\n        {\n            values[i] = v[i];\n        }\n    }\n    Matrix(const Matrix& matrix2)\n    {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        values = new  double[rows * columns];\n        for (int i = 0; i < rows; i++)\n        {\n            values[i] = matrix2.values[i];\n        }\n    }\n    void set(int r, int c, double v)\n    {\n        values[(r - 1) * columns + c - 1] = v;\n    }\n    Matrix operator * (const Matrix & matrix2) const\n    {\n        Matrix temp(rows,rows);\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < rows; j++)\n            {\n                double sum = 0;\n                for(int k = 0; k < columns; k++)\n                {\n                    sum += this->values[i * columns + k] * matrix2.values[k * rows + j];\n                }\n                temp.values[i*rows+j] = sum;\n            }\n        }\n        return temp;\n    }\n    Matrix  operator * (double v ) const\n    {\n        double * a = new double[rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = v * values[i];\n        }\n        Matrix temp (rows,columns,a);\n        delete []a;\n        return temp;\n    }\n    Matrix& operator= (const Matrix& matrix2)\n    {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        if (values != nullptr)\n            delete []values;\n\n        values = new  double[rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            values[i] = matrix2.values[i];\n        }\n        return *this;\n    }\n    Matrix reshape(int r , int c ) const\n    {\n        double * a = new double [r * c];\n        int m = 0;\n        for (int i = 0; i < columns; i++)\n        {\n            for (int j = 0; j < rows; j++)\n            {\n                a[m++] = this->values[j * columns + i];\n            }\n        }\n        m = 0;\n        Matrix temp(r,c);\n        for (int i = 0; i < c; i++)\n        {\n            for(int j = 0; j < r; j++)\n            {\n                temp.values[j * c + i] = a[m++];\n            }\n        }\n        delete []a;\n        return temp;\n    }\n    Matrix transpose()\n    {\n        double * a = new double [rows * columns];\n        int m = 0;\n        for (int i = 0; i < columns; i++)\n        {\n            for (int j = 0; j < rows; j++)\n            {\n                a[m++] = this->values[j * columns + i];\n            }\n        }\n        Matrix temp(columns,rows,a);\n        delete []a;\n        return temp;\n    }\n    Matrix  pow(double exponent)\n    {\n        double * a = new double[columns * rows];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] =  std ::pow(values[i],exponent);\n        }\n        Matrix temp (rows,columns,a);\n        delete [] a;\n        return temp;\n    }\n    Matrix  exp()\n    {\n        double * a = new double[columns * rows];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] =  std ::exp(values[i] );\n        }\n        Matrix temp (rows,columns,a);\n        delete [] a;\n        return temp;\n    }\n    Matrix  log()\n    {\n        double * a = new double[columns * rows];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] =  std ::log (values[i]);\n        }\n        Matrix temp (rows,columns,a);\n        delete [] a;\n        return temp;\n    }\n    Matrix  abs()\n    {\n        double * a = new double[columns * rows];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] =  std :: abs (values[i]);\n        }\n        Matrix temp (rows,columns,a);\n        delete [] a;\n        return temp;\n    }\n    ~Matrix()\n    {\n        if (values != 0)\n            delete []values;\n    }\n    void print()\n    {\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < columns; j++)\n            {\n\n                cout << \"    \" << values[i * columns + j];\n            }\n            cout << endl;\n        }\n    }\nprivate:\n    int rows;\n    int columns;\n    double* values;\n};",
            1589705640.814354,
            100,
            "# 答案正确"
        ],
        [
            "2.9 (C++)",
            "欧阳蓓",
            "#include<iostream>\n#include <iomanip>\nusing namespace std;\nclass Matrix\n{\npublic:\n    Matrix()\n    {\n        rows = 0;\n        columns = 0;\n        values = 0;\n    }\n    Matrix(int rows, int columns)\n    {\n        this->rows = rows;\n        this->columns = columns;\n        \n        values = new  double[rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            values[i] = 0;\n        }\n    }\n    Matrix(int r, int c, double v[])\n    {\n        this->rows = r;\n        this->columns = c;\n        values = new  double[r * c];\n        for (int i = 0; i < r * c; i++)\n        {\n            values[i] = v[i];\n        }\n    }\n    Matrix(const Matrix& matrix2)\n    {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        values = new  double[rows * columns];\n        for (int i = 0; i < rows; i++)\n        {\n            values[i] = matrix2.values[i];\n        }\n    }\n\n    Matrix& operator= (const Matrix& matrix2)\n    {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        if (values != nullptr)\n            delete []values;\n\n        values = new  double[rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            values[i] = matrix2.values[i];\n        }\n        return *this;\n    }\n    Matrix operator + (const Matrix & matrix2) const\n    {\n        double * a = new double [this->rows * this->columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = this->values[i] + matrix2.values[i];\n        }\n        Matrix temp(rows,columns,a);\n        delete []a;\n        return temp;\n    }\n    Matrix operator + (double v) const\n    {\n        double * a = new double [this->rows * this->columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = this->values[i] + v;\n        }\n        Matrix temp(rows,columns,a);\n        delete []a;\n        return temp;\n    }\n    Matrix operator - (const Matrix & matrix2) const\n    {\n        double * a = new double [this->rows * this->columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = this->values[i] - matrix2.values[i];\n        }\n        Matrix temp(rows,columns,a);\n        delete []a;\n        return temp;\n    }\n    Matrix operator - (double v) const\n    {\n        double * a = new double [this->rows * this->columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = this->values[i] - v;\n        }\n        Matrix temp(rows,columns,a);\n        delete []a;\n        return temp;\n    }\n    ~Matrix()\n    {\n        if (values != 0)\n            delete []values;\n    }\n    void print()\n    {\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < columns; j++)\n            {\n\n                cout << \"    \" << values[i * columns + j];\n            }\n            cout << endl;\n        }\n    }\nprivate:\n    int rows;\n    int columns;\n    double* values;\n};",
            1590032009.1008797,
            100,
            "# 答案正确"
        ],
        [
            "6.1 (C++)",
            "欧阳蓓",
            "#include<iostream>\n#include <iomanip>\n#include<vector>\n#include<string>\nusing namespace std;\ntemplate < typename T>\nclass Matrix\n{\npublic:\n    Matrix()\n    {\n        rows = 0;\n        columns = 0;\n        values = 0;\n    }\n    Matrix(int r, int c)\n    {\n        this -> rows = r;\n        this -> columns = c;\n        values = new  T [rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            values[i] = T ();\n        }\n    }\n    Matrix(int r, int c, const  T *v)\n    {\n        this->rows = r;\n        this->columns = c;\n        values = new  T [r * c];\n        for (int i = 0; i < r * c; i++)\n        {\n            values[i] = v[i];\n        }\n    }\n    T& get (int r, int c)\n    {\n        return values[(r - 1) * columns + c - 1];\n    }\n    Matrix(const Matrix& matrix2)\n    {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        values = new T [rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            values[i] = matrix2.values[i];\n        }\n    }\n    Matrix& operator= (const Matrix& matrix2)\n    {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        if (values != 0)\n            delete []values;\n        values = new T [rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            values[i] = matrix2.values[i];\n        }\n        return *this;\n    }\n    Matrix operator + (const Matrix & matrix2) const\n    {\n        T* a = new T [this->rows * this->columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = this->values[i] + matrix2.values[i];\n        }\n        Matrix temp(rows,columns,a);\n        delete []a;\n        return temp;\n    }\n    Matrix operator + (double v) const\n    {\n        T * a = new T [this->rows * this->columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = this->values[i] + v;\n        }\n        Matrix temp(rows,columns,a);\n        delete []a;\n        return temp;\n    }\n    Matrix operator - (const Matrix & matrix2) const\n    {\n        T * a = new T [this->rows * this->columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = this->values[i] - matrix2.values[i];\n        }\n        Matrix temp(rows,columns,a);\n        delete []a;\n        return temp;\n    }\n    Matrix operator - (double v) const\n    {\n        T * a = new T [this->rows * this->columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = this->values[i] - v;\n        }\n        Matrix temp(rows,columns,a);\n        delete []a;\n        return temp;\n    }\n    Matrix operator * (const Matrix & matrix2) const\n    {\n        Matrix temp(rows,rows);\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < rows; j++)\n            {\n                T sum = 0;\n                for(int k = 0; k < columns; k++)\n                {\n                    sum += this->values[i * columns + k] * matrix2.values[k * rows + j];\n                }\n                temp.values[i*rows+j] = sum;\n            }\n        }\n        return temp;\n    }\n    Matrix  operator * (double v ) const\n    {\n        T * a = new T [rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = v * values[i];\n        }\n        Matrix temp (rows,columns,a);\n        delete []a;\n        return temp;\n    }\n    Matrix transpose()\n    {\n        T* a = new T [rows * columns];\n        int m = 0;\n        for (int i = 0; i < columns; i++)\n        {\n            for (int j = 0; j < rows; j++)\n            {\n                a[m++] = this->values[j * columns + i];\n            }\n        }\n        Matrix temp(columns,rows,a);\n        delete []a;\n        return temp;\n    }\n    Matrix concatenateRows(Matrix & matrix1)\n    {\n        Matrix t (rows * 2 , columns);\n        for(int i = 0; i < rows * columns; ++i)\n        {\n            t.values[i] = values[i];\n        }\n        for(int i = 0; i < rows * columns; i++)\n        {\n            t.values[ rows * columns + i] = matrix1.values[i];\n        }\n        return t;\n    }\n    Matrix concatenateColumns(Matrix & matrix1)\n    {\n        Matrix t(rows, columns * 2);\n        for(int i = 0; i < rows; ++i)\n        {\n            for(int j = 0; j < columns; ++j)\n            {\n                t.values[i* columns * 2  +  j] = values [ i *columns +  j];\n            }\n        }\n        for(int i = 0; i < rows; ++i)\n        {\n            for(int j = columns; j < columns * 2; ++j)\n            {\n                t.values[i* columns * 2  +  j] = matrix1.values[i * columns +  j - columns];\n            }\n        }\n        return t;\n    }\n    Matrix getRow(int r)\n\t{\n\t\tT * a = new T [columns];\n\t\tfor(int i = 0; i < columns; i++)\n\t\t{\n\t\t\ta[i] = values[(r-1) * columns + i];\n        }\n\t\tMatrix temp (1,columns,a);\n        delete []a;\n\t\treturn temp;\n\t}\n\tMatrix getColumn(int c)\n\t{\n\t\tT * a = new T [columns];\n\t\tfor (int i = 0; i < rows; i++)\n\t\t{\n\t\t\ta[i] = values[i * columns + c - 1];\n\t\t}\n\t\tMatrix temp(rows,1,a);\n        delete []a;\n        return temp;\n\t}\n    Matrix reshape(int r , int c ) const\n    {\n        T * a = new T [r * c];\n        int m = 0;\n        for (int i = 0; i < columns; i++)\n        {\n            for (int j = 0; j < rows; j++)\n            {\n                a[m++] = this->values[j * columns + i];\n            }\n        }\n        m = 0;\n        Matrix temp(r,c);\n        for (int i = 0; i < c; i++)\n        {\n            for(int j = 0; j < r; j++)\n            {\n                temp.values[j * c + i] = a[m++];\n            }\n        }\n        delete []a;\n        return temp;\n    }\n    Matrix max()\n    {\n        if(rows == 1 && columns == 1)\n        return * this;\n        else if (rows == 1 && columns != 1)\n        {\n            T m = values[0];\n            for (int i = 0; i < rows * columns ; i++)\n            {\n                if (values[i] > m)\n                m = values[i];\n            }\n            Matrix temp(1,1);\n            temp.values[0] = m;\n            return temp;\n        }\n        else\n        {\n            T m = values[0];\n            int index = 0;\n            for (int i = 0; i < rows; i++)\n            {\n                for (int j = 0; j < columns; j++)\n                {\n                    if (values[ i * columns + j] > m )\n                    {\n                        m = values[ i * columns + j];\n                        index = i;\n                    }\n                }\n                T * a = new T[columns];\n                for(int i = 0; i < columns; i++)\n                {\n                    a[i] = values[ index * columns + i];\n                }\n                Matrix temp (1,columns,a);\n                return temp;\n            }\n        }\n    }\n    Matrix min()\n    {\n        if(rows == 1 && columns == 1)\n        return * this;\n        else if (rows == 1 && columns != 1)\n        {\n            T m = values[0];\n            for (int i = 0; i < rows * columns ; i++)\n            {\n                if (values[i] < m)\n                m = values[i];\n            }\n            Matrix temp(1,1);\n            temp.values[0] = m;\n            return temp;\n        }\n        else\n        {\n            T m = values[0];\n            int index = 0;\n            for (int i = 0; i < rows; i++)\n            {\n                for (int j = 0; j < columns; j++)\n                {\n                    if (values[ i * columns + j] < m )\n                    {\n                        m = values[ i * columns + j];\n                        index = i;\n                    }\n                }\n                T * a = new T[columns];\n                for(int i = 0; i < columns; i++)\n                {\n                    a[i] = values[ index * columns + i];\n                }\n                Matrix temp (1,columns,a);\n                return temp;\n            }\n        }\n    }\n    Matrix sum()\n    {\n        if (rows == 1 && columns == 1)\n        return * this;\n        else if (rows == 1 && columns != 1)\n        {\n            T m = 0;\n            for (int i = 0; i < columns; i++)\n            m += values[i];\n            Matrix temp(1,1);\n            temp.values[0] = m;\n            return temp;\n        }\n        else\n        {\n            T * a = new T[columns];\n            for (int j = 0; j < columns; j++)\n            {\n                a[j] = 0;\n                for (int i = 0; i < rows; i++)\n                {\n                    a[j] += values[i * columns + j];\n                }\n            }\n            Matrix temp (1,columns,a);\n            return temp;\n        }\n        \n    }\n    ~Matrix()\n    {\n        if (values != 0)\n            delete []values;\n    }\n    void print()\n    {\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < columns; j++)\n            {\n                cout << \"    \" << values[i * columns + j];\n            }\n            cout << endl;\n        }\n    }\nprivate:\n    int rows;\n    int columns;\n    T * values;\n};",
            1590229949.6022108,
            100,
            "# 答案正确"
        ],
        [
            "6.3 (C++)",
            "欧阳蓓",
            "#include<iostream>\n#include <iomanip>\n\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntemplate < typename T>\nclass Matrix\n{\n    public:\n    Matrix()\n    {\n        this->rows = 0;\n        this->columns = 0;\n        values.clear();\n    }\n    Matrix(int r, int c)\n    {\n        this->rows = r;\n        this->columns = c;\n        vector<T> temp ( r*c ,0);\n        values = temp;\n    }\n    Matrix(int r, int c, vector <T>  v)\n    {\n        this->rows = r;\n        this->columns = c;\n        values = v;\n    }\n    Matrix(const Matrix& matrix2)\n    {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        this->values = matrix2.values; \n    }\n    T& get (int r, int c)\n    {\n        return values[(r-1) * columns + c - 1];\n    }\n    Matrix& operator= (const Matrix& matrix2)\n    {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        this->values = matrix2.values; \n        return *this;\n    }\n    Matrix operator * (const Matrix & matrix2) const\n    {\n        Matrix temp(rows,rows);\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < rows; j++)\n            {\n                T sum = 0;\n                for(int k = 0; k < columns; k++)\n                {\n                    sum += this->values[i * columns + k] * matrix2.values[k * rows + j];\n                }\n                temp.values[i*rows+j] = sum;\n            }\n        }\n        return temp;\n    }\n    Matrix  operator * ( T v ) const\n    {\n        vector<T> a (rows * columns, 0);\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = v * values[i];\n        }\n        Matrix temp (rows,columns,a);\n        return temp;\n    }\n    Matrix operator + (const Matrix & matrix2) const\n    {\n        vector <T> a(rows * columns , 0);\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = this->values[i] + matrix2.values[i];\n        }\n        Matrix temp(rows,columns,a);\n        return temp;\n    }\n    Matrix operator + (T v) const\n    {\n        vector <T> a(rows * columns , 0);\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = this->values[i] + v;\n        }\n        Matrix temp(rows,columns,a);\n        return temp;\n    }\n    Matrix operator - (const Matrix & matrix2) const\n    {\n        vector <T> a(rows * columns , 0);\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = this->values[i] - matrix2.values[i];\n        }\n        Matrix temp(rows,columns,a);\n        return temp;\n    }\n    Matrix operator - (T v) const\n    {\n        vector <T> a(rows * columns , 0);\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = this->values[i] - v;\n        }\n        Matrix temp(rows,columns,a);\n        return temp;\n    }\n    Matrix getRow(int r)\n\t{\n\t\tvector <T> a(columns, 0);\n\t\tfor(int i = 0; i < columns; i++)\n\t\t{\n\t\t\ta[i] = this->values[(r-1) * columns + i];\n\t\t}\n\t\treturn Matrix(1,columns,a);\n\t}\n\tMatrix getColumn(int c)\n\t{\n\t\tvector <T> a( 1 * rows, 0);\n\t\tfor (int i = 0; i < rows; i++)\n\t\t{\n\t\t\ta[i] = values[i*columns + c - 1];\n\t\t}\n\t\treturn Matrix(rows, 1, a);\n\t}\n    Matrix concatenateRows(Matrix & matrix1)\n    {\n        Matrix t (rows * 2 , columns);\n        for(int i = 0; i < rows * columns; ++i)\n        {\n            t.values[i] = values[i];\n        }\n        for(int i = 0; i < rows * columns; i++)\n        {\n            t.values[ rows * columns + i] = matrix1.values[i];\n        }\n        return t;\n    }\n    Matrix concatenateColumns(Matrix & matrix1)\n    {\n        Matrix t(rows, columns * 2);\n        for(int i = 0; i < rows; ++i)\n        {\n            for(int j = 0; j < columns; ++j)\n            {\n                t.values[i* columns * 2  +  j] = values [ i *columns +  j];\n            }\n        }\n        for(int i = 0; i < rows; ++i)\n        {\n            for(int j = columns; j < columns * 2; ++j)\n            {\n                t.values[i* columns * 2  +  j] = matrix1.values[i * columns +  j - columns];\n            }\n        }\n        return t;\n    }\n    Matrix reshape(int r , int c ) const\n    {\n        vector<T> a(r * c ,0);\n        int m = 0;\n        for (int i = 0; i < columns; i++)\n        {\n            for (int j = 0; j < rows; j++)\n            {\n                a[m++] = this->values[j * columns + i];\n            }\n        }\n        m = 0;\n        Matrix temp(r,c);\n        for (int i = 0; i < c; i++)\n        {\n            for(int j = 0; j < r; j++)\n            {\n                temp.values[j * c + i] = a[m++];\n            }\n        }\n        return temp;\n    }\n    Matrix transpose()\n    {\n        vector<T> a(rows * columns);\n        int m = 0;\n        for (int i = 0; i < columns; i++)\n        {\n            for (int j = 0; j < rows; j++)\n            {\n                a[m++] = this->values[j * columns + i];\n            }\n        }\n        Matrix temp(columns,rows,a);\n        return temp;\n    }\n    Matrix max()\n    {\n        if(rows == 1 && columns == 1)\n        return * this;\n        else if (rows == 1 && columns != 1)\n        {\n            T m = values[0];\n            for (int i = 0; i < rows * columns ; i++)\n            {\n                if (values[i] > m)\n                m = values[i];\n            }\n            Matrix temp(1,1);\n            temp.values[0] = m;\n            return temp;\n        }\n        else\n        {\n            T m;\n            vector<T> a;\n            for (int j = 0; j < columns; j++)\n            {\n                m = -999;\n                for (int i = 0; i < rows; i++)\n                {\n\t\t\t\t\t\t\tif (values[i * columns + j] > m)\n\t\t\t\t\t\t\t\tm = values[i * columns + j];\n                }\n                a.push_back(m);\n            }\n                Matrix temp (1,columns,a);\n                return temp;\n        }\n    }\n        \n    \n    Matrix min()\n    {\n        if(rows == 1 && columns == 1)\n        return * this;\n        else if (rows == 1 && columns != 1)\n        {\n            T m = values[0];\n            for (int i = 0; i < rows * columns ; i++)\n            {\n                if (values[i] < m)\n                m = values[i];\n            }\n            Matrix temp(1,1);\n            temp.values[0] = m;\n            return temp;\n        }\n        else\n        {\n            T m;\n            vector<T> a;\n            for (int j = 0; j < columns; j++)\n            {\n                m =  999;\n                for (int i = 0; i < rows; i++)\n                {\n\t\t\t\t\t\t\tif (values[i * columns + j] < m)\n\t\t\t\t\t\t\t\tm = values[i * columns + j];\n                }\n                a.push_back(m);\n            }\n                Matrix temp (1,columns,a);\n                return temp;\n        }\n    }\n    Matrix sum()\n    {\n        if (rows == 1 && columns == 1)\n        return * this;\n        else if (rows == 1 && columns != 1)\n        {\n            T m = 0;\n            for (int i = 0; i < columns; i++)\n            m += values[i];\n            Matrix temp(1,1);\n            temp.values[0] = m;\n            return temp;\n        }\n        else\n        {\n            vector <T> a(columns,0);\n            for (int j = 0; j < columns; j++)\n            {\n                for (int i = 0; i < rows; i++)\n                {\n                    a[j] += values[i * columns + j];\n                }\n            }\n            Matrix temp (1,columns,a);\n            return temp;\n        }\n        \n    }\n    void print()\n    {\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < columns; j++)\n            {\n\n                cout << \"    \" << values[i * columns + j];\n            }\n            cout << endl;\n        }\n    }\n    private:\n    int rows;\n    int columns;\n    vector <T> values;\n};",
            1590632386.7434697,
            100,
            "# 答案正确"
        ],
        [
            "6.2 (C++)",
            "欧阳蓓",
            "#include<iostream>\n#include <iomanip>\n#include<vector>\n#include<string>\nusing namespace std;\ntemplate < typename T>\nclass Matrix\n{\npublic:\n    Matrix()\n    {\n        rows = 0;\n        columns = 0;\n        values = 0;\n    }\n    Matrix(int r, int c)\n    {\n        this -> rows = r;\n        this -> columns = c;\n        values = new  T [rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            values[i] = T ();\n        }\n    }\n    Matrix(int r, int c, const  T *v)\n    {\n        this->rows = r;\n        this->columns = c;\n        values = new  T [r * c];\n        for (int i = 0; i < r * c; i++)\n        {\n            values[i] = v[i];\n        }\n    }\n    T& get (int r, int c)\n    {\n        return values[(r - 1) * columns + c - 1];\n    }\n    Matrix(const Matrix& matrix2)\n    {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        values = new T [rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            values[i] = matrix2.values[i];\n        }\n    }\n    Matrix& operator= (const Matrix& matrix2)\n    {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        if (values != 0)\n            delete []values;\n        values = new T [rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            values[i] = matrix2.values[i];\n        }\n        return *this;\n    }\n    Matrix operator + (const Matrix & matrix2) const\n    {\n        T* a = new T [this->rows * this->columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = this->values[i] + matrix2.values[i];\n        }\n        Matrix temp(rows,columns,a);\n        delete []a;\n        return temp;\n    }\n    Matrix operator + (double v) const\n    {\n        T * a = new T [this->rows * this->columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = this->values[i] + v;\n        }\n        Matrix temp(rows,columns,a);\n        delete []a;\n        return temp;\n    }\n    Matrix operator - (const Matrix & matrix2) const\n    {\n        T * a = new T [this->rows * this->columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = this->values[i] - matrix2.values[i];\n        }\n        Matrix temp(rows,columns,a);\n        delete []a;\n        return temp;\n    }\n    Matrix operator - (double v) const\n    {\n        T * a = new T [this->rows * this->columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = this->values[i] - v;\n        }\n        Matrix temp(rows,columns,a);\n        delete []a;\n        return temp;\n    }\n    Matrix operator * (const Matrix & matrix2) const\n    {\n        Matrix temp(rows,rows);\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < rows; j++)\n            {\n                T sum = 0;\n                for(int k = 0; k < columns; k++)\n                {\n                    sum += this->values[i * columns + k] * matrix2.values[k * rows + j];\n                }\n                temp.values[i*rows+j] = sum;\n            }\n        }\n        return temp;\n    }\n    Matrix  operator * (double v ) const\n    {\n        T * a = new T [rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = v * values[i];\n        }\n        Matrix temp (rows,columns,a);\n        delete []a;\n        return temp;\n    }\n    Matrix transpose()\n    {\n        T* a = new T [rows * columns];\n        int m = 0;\n        for (int i = 0; i < columns; i++)\n        {\n            for (int j = 0; j < rows; j++)\n            {\n                a[m++] = this->values[j * columns + i];\n            }\n        }\n        Matrix temp(columns,rows,a);\n        delete []a;\n        return temp;\n    }\n    Matrix concatenateRows(Matrix & matrix1)\n    {\n        Matrix t (rows * 2 , columns);\n        for(int i = 0; i < rows * columns; ++i)\n        {\n            t.values[i] = values[i];\n        }\n        for(int i = 0; i < rows * columns; i++)\n        {\n            t.values[ rows * columns + i] = matrix1.values[i];\n        }\n        return t;\n    }\n  \n    ~Matrix()\n    {\n        if (values != 0)\n            delete []values;\n    }\n    void print()\n    {\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < columns; j++)\n            {\n                cout << \"    \" << values[i * columns + j];\n            }\n            cout << endl;\n        }\n    }\nprivate:\n    int rows;\n    int columns;\n    T * values;\n};",
            1590631480.448676,
            100,
            "# 答案正确"
        ],
        [
            "7.1 (C++)",
            "欧阳蓓",
            "#include <cmath>\nclass Triangle : public GeometricObject\n{\n    public:\n    Triangle()\n    {\n        side1 = side2 = side3 = 1.0;\n      \n    }\n    Triangle(double a, double b, double c)\n    {\n        side1 = a;\n        side2 = b;\n        side3 = c;\n      \n    }\n    double& getSide1()\n    {\n        return side1;\n    }\n    double& getSide2()\n    {\n        return side2;\n    }\n    double& getSide3()\n    {\n        return side3;\n    }\n    double getArea()\n    { \n        double s = this->getPerimeter() / 2;\n        double area = sqrt(s * (s - side1) * (s - side2) * (s - side3) );\n        return area;\n    }\n    double getPerimeter()\n    {\n        return side1 + side2 + side3;\n    }\n\n\n    private:\n    double side1;\n    double side2;\n    double side3;\n};\n\n",
            1590730368.2782454,
            100,
            "# 答案正确"
        ],
        [
            "7.3 (C++)",
            "欧阳蓓",
            "\ntemplate <typename T>\nvector<T> map2(const vector<T> & x,  const T data , T(*map2_func)(const T &, const T &) )\n{\n    vector<T> res;\n    for (int i = 0; i < x.size(); i++)\n    {\n        res.push_back(map2_func(x[i], data));\n    }\n    return res;\n}\ntemplate <typename T>\nvector<T> map2(const vector<T> & x,  const vector<T> & y, T(*map2_func)(const T &, const T &) )\n{\n    vector<T> res;\n    for (int i = 0; i < x.size(); i++)\n    {\n        res.push_back(map2_func(x[i], y[i]));\n    }\n    return res;\n}\n",
            1590730544.902254,
            100,
            "# 答案正确"
        ],
        [
            "7.2 (C++)",
            "欧阳蓓",
            "#include<string>\n#include<vector>\nusing namespace std;\nvector<string> split( const string &line, const string & delimiter = \" \")\n{\n    vector<string> ans;\n    int st = 0;\n    while(st < line.size())\n    {\n        int end = line.find(delimiter, st);\n        if (end == st)\n            st += delimiter.size();\n        else\n        {\n            if (end == -1)\n            {\n                ans.push_back(line.substr(st));\n                break;\n            }\n            ans.push_back(line.substr(st, end - st));\n            st = end + delimiter.size();\n        }\n        \n    }\n    return ans;\n}",
            1591237010.869331,
            100,
            "# 答案正确"
        ],
        [
            "8.1 (C++)",
            "欧阳蓓",
            "\nclass Full : public Matrix\n{\n    public:\n    Full (int r, int c)\n    {\n        this->rows = r;\n        this->columns = c;\n        values = new double [rows * columns];\n        for(int i = 0; i < rows * columns ; i++)\n        values[i] = 0;\n    }\n    Full (int r, int c, double values[])\n    {\n        this->rows = r;\n        this->columns = c;\n        this-> values = new double[rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        this->values[i] = values[i]; \n    }\n    Full(const Matrix & matrix2)\n    {\n        this->rows = matrix2.size(1);\n        this->columns = matrix2.size(2);\n        this->values = new double[this->rows * this-> columns];\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < columns; j++)\n            {\n                values[i * columns + j] = matrix2.get(i,j);\n            }\n        }\n    }\n    ~Full()\n    {\n        if(values != 0)\n        delete [] values;\n    }\n    virtual int size(int dimension) const\n    {\n        if (dimension == 1)\n            return rows;\n        else\n            return columns;\n    }\n\tvirtual void set(int r, int c, double v)\n    {\n        values[r * columns + c ] = v;\n    }\n\tvirtual double get(int r, int c) const \n\t{\n        return values[r * columns + c] ;\n    }\n\tvirtual void print() const\n    {\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < columns; j++)\n            {\n                cout <<\"    \" <<values[i*columns + j] ;\n            }\n            cout << endl;\n        }\n    }\n\tvirtual Matrix&  operator = (const Matrix & matrix2)\n    {\n        this->rows = matrix2.size(1);\n        this->columns = matrix2.size(2);\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j <columns; j++)\n            {\n                set(i,j,matrix2.get(i,j));\n            }\n        }\n        return *this;\n    }\n    private:\n    int rows;\n    int columns;\n    double * values;\n};",
            1591839787.647554,
            100,
            "# 答案正确"
        ],
        [
            "8.3 (C++)",
            "欧阳蓓",
            "#include <iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nbool comp(const Entry& a, const Entry& b)\n{\n    if (a.row == b.row)\n    {\n        return a.column < b.column;\n    }\n    else\n    {\n        return a.row < b.row;\n    }\n}\nclass Sparse : public Matrix\n{\npublic:\n    Sparse(int r, int c)\n    {\n        this->rows = r;\n        this->columns = c ;\n        values.clear();\n    }\n/*Sparse  operator+ (Sparse& sparse2)\n    {\n        Sparse temp(this->rows, this->columns);\n        temp.values = this->values;\n        for (int i = 0; i < sparse2.values.size();i++)\n        {\n            int index = findIndex(sparse2.values[i].row,sparse2.values[i].column );\n            if (index == -1)\n            {\n                temp.values.push_back(sparse2.values[i]);\n            }\n            else\n            {\n                temp.set(sparse2.values[i].row,sparse2.values[i].column,this->values[index ].value + sparse2.values[i].value);\n            }\n        }\n        return temp;\n    }\n*/\n  Sparse  operator+ (Sparse& sparse2)\n    {\n        Sparse temp(this->rows, this->columns);\n        temp.values = this->values;\n\n        for (int i = 0; i < sparse2.values.size();i++)\n        {\n            Entry t = sparse2.values[i];\n            double v = temp.get(t.row, t.column);\n            temp.set(t.row,t.column, sparse2.get(t.row,t.column) + v);\n        }\n        return temp;\n    }\n\n    int findIndex(int r, int c) const\n    {\n        for (int i = 0; i < values.size(); i++)\n        {\n            if (values[i].row == r && values[i].column == c)\n            {\n                return i;\n            }\n        }\n        return -1;\n    }\n    virtual int size(int dimension) const\n    {\n        if (dimension == 1)\n            return rows;\n        else\n        {\n            return columns;\n        }\n    }\n\n\n    virtual void set(int r, int c, double v)\n    {\n        int index = findIndex(r, c);\n        if (index != -1)\n        {\n            if (v == 0)\n            {\n                values.erase(values.begin() + index);\n            }\n            else\n            {\n                values[index].value = v;\n            }\n        }\n        else\n        {\n            if (v != 0)\n            {\n                Entry t;\n                t.row = r;\n                t.column = c;\n                t.value = v;\n                values.push_back(t);\n            }\n        }\n    }\n\n    virtual double get(int r, int c) const\n    {\n        int index = findIndex(r, c);\n        if (index == -1)\n            return 0;\n        else\n        {\n            return values[index].value;\n        }\n    }\n\n    virtual void print()\n    {\n\n        sort(values.begin(), values.end(),comp);\n        for (int i = 0; i < values.size(); i++)\n        {\n            cout << \"(\" << values[i].row << \",\" << values[i].column << \",\" << values[i].value << \")\" << endl;\n        }\n    }\n\nprivate:\n    int rows;\n    int columns;\n    vector<Entry> values;\n};",
            1591457714.6982403,
            100,
            "# 答案正确"
        ],
        [
            "8.4 (C++)",
            "欧阳蓓",
            "#include <iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nbool comp(const Entry& a, const Entry& b)\n{\n    if (a.row == b.row)\n    {\n        return a.column < b.column;\n    }\n    else\n    {\n        return a.row < b.row;\n    }\n}\nclass Sparse : public Matrix\n{\npublic:\n    Sparse(int r, int c)\n    {\n        this->rows = r;\n        this->columns = c ;\n        values.clear();\n    }\n/*Sparse  operator+ (Sparse& sparse2)\n    {\n        Sparse temp(this->rows, this->columns);\n        temp.values = this->values;\n        for (int i = 0; i < sparse2.values.size();i++)\n        {\n            int index = findIndex(sparse2.values[i].row,sparse2.values[i].column );\n            if (index == -1)\n            {\n                temp.values.push_back(sparse2.values[i]);\n            }\n            else\n            {\n                temp.set(sparse2.values[i].row,sparse2.values[i].column,this->values[index ].value + sparse2.values[i].value);\n            }\n        }\n        return temp;\n    }\n*/\n  Sparse  operator+ (Sparse& sparse2)\n    {\n        Sparse temp(this->rows, this->columns);\n        temp.values = this->values;\n\n        for (int i = 0; i < sparse2.values.size();i++)\n        {\n            Entry t = sparse2.values[i];\n            double v = temp.get(t.row, t.column);\n            temp.set(t.row,t.column,t.value+v);\n        }\n        return temp;\n    }\n\n    int findIndex(int r, int c) const\n    {\n        for (int i = 0; i < values.size(); i++)\n        {\n            if (values[i].row == r && values[i].column == c)\n            {\n                return i;\n            }\n        }\n        return -1;\n    }\n    virtual int size(int dimension) const\n    {\n        if (dimension == 1)\n            return rows;\n        else\n        {\n            return columns;\n        }\n    }\n\n\n    virtual void set(int r, int c, double v)\n    {\n        int index = findIndex(r, c);\n        if (index != -1)\n        {\n            if (v == 0)\n            {\n                values.erase(values.begin() + index);\n            }\n            else\n            {\n                values[index].value = v;\n            }\n        }\n        else\n        {\n            if (v != 0)\n            {\n                Entry t;\n                t.row = r;\n                t.column = c;\n                t.value = v;\n                values.push_back(t);\n            }\n        }\n    }\n\n    virtual double get(int r, int c) const\n    {\n        int index = findIndex(r, c);\n        if (index == -1)\n            return 0;\n        else\n        {\n            return values[index].value;\n        }\n    }\nSparse  operator * (Sparse & sparse2)\n    {\n        Sparse temp(this->rows, sparse2.columns);\n        for(int i = 0; i < values.size(); i++)\n        {\n            for(int j = 0; j < sparse2.values.size(); j++)\n            {\n                Entry a = this->values[i];\n                Entry b = sparse2.values[j];\n                if(a.column == b.row)\n                {\n                    double t = a.value * b.value;\n                    temp.set(a.row,b.column, temp.get(a.row,b.column) + t);\n                }\n            }\n        }\n        return temp;\n    }\n    virtual void print()\n    {\n\n        sort(values.begin(), values.end(),comp);\n        for (int i = 0; i < values.size(); i++)\n        {\n            cout << \"(\" << values[i].row << \",\" << values[i].column << \",\" << values[i].value << \")\" << endl;\n        }\n    }\n\nprivate:\n    int rows;\n    int columns;\n    vector<Entry> values;\n};",
            1591432278.0182962,
            100,
            "# 答案正确"
        ],
        [
            "8.5 (C++)",
            "欧阳蓓",
            " \n\n\nclass Point3D : public Point2D \n{\n    public:\n    Point3D()\n    {\n        setX(0);\n        setY(0);\n        setZ(0);\n    }\n    Point3D(double x, double y, double z)\n    {\n        setX(x);\n        setY(y);\n        setZ(z);\n    }\n    void setZ(double z) \n    {\n\t\tthis->z = z;\n\t}\n    double getZ() \n    {\n\t\treturn z;\n\t}\n    virtual double distance(Point2D & point2) \n    {\n        Point3D& a = static_cast <Point3D&>(point2);\n\t\tdouble dx = getX() - a.getX();\n\t\tdouble dy = getY() - a.getY();\n        double dz = getZ() - a.getZ();\n\t\treturn sqrt(dx * dx + dy * dy + dz * dz);\n\t}\n    private:\n    double z;\n};\n\n\n ",
            1591844336.40225,
            100,
            "# 答案正确"
        ],
        [
            "8.6 (C++)",
            "欧阳蓓",
            "#include <iostream>\nclass MyTensor : public Tensor<double>\n{\n    public:\n    MyTensor( vector<int> sizes ): Tensor<double> (sizes) \n    {\n        int total = 1;\n        for (int i = 0; i < sizes.size(); i++)\n        total *= sizes[i];\n        data = new double[total];\n    }\n    \n    virtual double & get(const vector<int> & indexes)\n    {\n        if( sizes.size() == 1)\n        return data[indexes[0]];\n        if(sizes.size() ==2)\n        {\n            return data[indexes[0] * sizes[1] + indexes[1]];\n        }\n        if(sizes.size()  == 3)\n        {\n            return data[ indexes[0] * indexes[1] * sizes[2] + indexes[1] * sizes[2] + indexes[2]   ];\n        }\n        if (sizes.size()  == 4)\n        {\n            return data[ indexes[0] * indexes[1] * indexes[2] * sizes[3] + indexes[1] * indexes[2] * sizes[3] + indexes[2] * sizes[3] + indexes[3] ];  \n        }\n\n    }\n    ~MyTensor()\n    {\n        if(data != nullptr)\n        delete [] data;\n    }\n    private:\n    double * data;\n};\n",
            1592450697.6692402,
            100,
            "# 答案正确"
        ],
        [
            "9.1 (C++)",
            "欧阳蓓",
            "#include <iostream>\nusing namespace std;\nclass Circle\n{\n    friend bool operator<(const Circle&a, const Circle&b);\n    friend bool operator<=(const Circle&a, const Circle&b);\n    friend bool operator==(const Circle&a, const Circle&b);\n    friend bool operator!=(const Circle&a, const Circle&b);\n    friend bool operator>(const Circle&a, const Circle&b);\n    friend bool operator>=(const Circle&a, const Circle&b);\n    public:\n        Circle(double r) : radius(r) {}\n    private:\n        double radius;\n};\nbool operator<(const Circle&a, const Circle&b)\n{\n    return a.radius < b.radius;\n}\nbool operator<=(const Circle&a, const Circle&b)\n{\n    return a.radius <= b.radius;\n}\nbool operator==(const Circle&a, const Circle&b)\n{\n    return a.radius == b.radius;\n}\nbool operator!=(const Circle&a, const Circle&b)\n{\n    return !(a == b);\n}\nbool operator>(const Circle&a, const Circle&b)\n{\n    return !(a<=b);\n}\nbool operator>=(const Circle&a, const Circle&b)\n{\n    return !(a<b);\n}",
            1592643962.014341,
            100,
            "# 答案正确"
        ],
        [
            "9.3 (C++)",
            "欧阳蓓",
            "class Complex\n{\n    friend Complex operator+(Complex & a,Complex &b);\n    friend Complex operator+(Complex & a,int b);\n    friend Complex operator+(int a,Complex & b);\n\n    friend Complex operator-(Complex & a,Complex &b);\n    friend Complex operator-(Complex & a,int b);\n    friend Complex operator-(int a,Complex & b);\n\n    friend Complex operator*(Complex & a,Complex &b);\n    friend Complex operator/(Complex & a,Complex &b);\n    \n    public:\n    Complex(double real, double imag) : m_real(real), m_imag(imag) {}\n    Complex& operator*=(Complex & a);\n    Complex& operator/=(Complex & a);\n    Complex& operator+=(Complex & a);\n    Complex& operator-=(Complex & a);\n    bool operator==(Complex & a);\n    bool operator!=(Complex & a);\n    double real();\n    double imag();\n    private:\n    double m_real;\n    double m_imag;\n};\nComplex& Complex :: operator*=(Complex & a)\n{\n    Complex t = *this * a;\n    *this = t;\n    return *this;\n}\nComplex& Complex :: operator/=(Complex & a)\n{\n    Complex t = *this / a;\n    *this = t;\n    return *this;\n}\nComplex& Complex :: operator+=(Complex & a)\n{\n    Complex t = *this + a;\n    *this = t;\n    return *this;\n}\nComplex& Complex :: operator-=(Complex & a)\n{\n    Complex t = *this - a;\n    *this = t;\n    return *this;\n}\nbool Complex :: operator==(Complex & a)\n{\n    if(m_real == a.real() && m_imag == a.imag())\n    return true;\n    else\n    {\n        return false;\n    }\n    \n}\nbool Complex :: operator!=(Complex & a)\n{\n    return !(*this == a);\n}\n\ndouble Complex ::  real()\n{\n    return m_real;\n}\ndouble Complex ::  imag()\n{\n    return m_imag;\n}\nComplex operator+(Complex & a,Complex &b)\n{\n    return Complex(a.real() + b.real(), a.imag() + b.imag());\n}\nComplex operator+(Complex & a,int b)\n{\n    return Complex(a.real() +b, a.imag());\n}\nComplex operator+(int a,Complex & b)\n{\n    return Complex(a + b.real(), b.imag());\n}\nComplex operator-(Complex & a,Complex &b)\n{\n    return Complex(a.real() - b.real(), a.imag() - b.imag());\n}\nComplex operator-(Complex & a,int b)\n{\n    return Complex(a.real() - b, a.imag());\n}\nComplex operator-(int a,Complex & b)\n{\n    return Complex(a - b.real(), -b.imag());\n}\nComplex operator*(Complex & a,Complex &b)\n{\n    double r = a.real() * b.real() - a.imag() * b.imag();\n    double i = a.real() * b.imag() + a.imag() * b.real();\n    return Complex(r,i);\n}\nComplex operator/(Complex & a,Complex &b)\n{\n    double r =(a.real() * b.real() + a.imag() * b.imag() ) / (b.real() * b.real() + b.imag() * b.imag());\n    double i = ( a.imag() * b.real() - a.real() * b.imag() ) / (b.real() * b.real() + b.imag() * b.imag());\n    return Complex(r,i);\n}",
            1592538155.5570102,
            100,
            "# 答案正确"
        ],
        [
            "9.4 (C++)",
            "欧阳蓓",
            "#include <cmath>\nclass Complex\n{\n    friend Complex operator+(Complex & a,Complex &b);\n    friend Complex operator+(Complex & a,int b);\n    friend Complex operator+(int a,Complex & b);\n    \n    friend Complex operator-(Complex & a,Complex &b);\n    friend Complex operator-(Complex & a,int b);\n    friend Complex operator-(int a,Complex & b);\n\n    friend Complex operator*(Complex & a,Complex &b);\n    friend Complex operator/(Complex & a,Complex &b);\n    friend ostream& operator<<(ostream &out, Complex & a);\n    friend istream& operator>>(istream &in, Complex & a);\n\n    public:\n    Complex(double real, double imag) : m_real(real), m_imag(imag) {}\n    Complex():m_real(0),m_imag(0){}\n\n    Complex& operator*=(Complex & a);\n    Complex& operator/=(Complex & a);\n    Complex& operator+=(Complex & a);\n    Complex& operator-=(Complex & a);\n    Complex& operator++();\n    Complex  operator++(int);\n    bool operator==(Complex & a);\n    bool operator!=(Complex & a);\n    operator double();\n    double real();\n    double imag();\n    private:\n    double m_real;\n    double m_imag;\n};\nComplex& Complex :: operator*=(Complex & a)\n{\n    Complex t = *this * a;\n    *this = t;\n    return *this;\n}\nComplex& Complex :: operator/=(Complex & a)\n{\n    Complex t = *this / a;\n    *this = t;\n    return *this;\n}\nComplex& Complex :: operator+=(Complex & a)\n{\n    Complex t = *this + a;\n    *this = t;\n    return *this;\n}\nComplex& Complex :: operator-=(Complex & a)\n{\n    Complex t = *this - a;\n    *this = t;\n    return *this;\n}\nbool Complex :: operator==(Complex & a)\n{\n    if(m_real == a.real() && m_imag == a.imag())\n    return true;\n    else\n    {\n        return false;\n    }\n    \n}\nbool Complex :: operator!=(Complex & a)\n{\n    return !(*this == a);\n}\nComplex& Complex :: operator++() // 前置\n{\n    this->m_real++;\n    return *this;\n}\nComplex Complex :: operator++(int)\n{\n    Complex temp = *this;\n    this->m_real++;\n    return temp;\n}\ndouble Complex ::  real()\n{\n    return m_real;\n}\ndouble Complex ::  imag()\n{\n    return m_imag;\n}\nComplex :: operator double()\n{\n    return m_real;\n}\nComplex operator+(Complex & a,Complex &b)\n{\n    return Complex(a.real() + b.real(), a.imag() + b.imag());\n}\nComplex operator+(Complex & a,int b)\n{\n    return Complex(a.real() +b, a.imag());\n}\nComplex operator+(int a,Complex & b)\n{\n    return Complex(a + b.real(), b.imag());\n}\nComplex operator-(Complex & a,Complex &b)\n{\n    return Complex(a.real() - b.real(), a.imag() - b.imag());\n}\nComplex operator-(Complex & a,int b)\n{\n    return Complex(a.real() - b, a.imag());\n}\nComplex operator-(int a,Complex & b)\n{\n    return Complex(a - b.real(), -b.imag());\n}\nComplex operator*(Complex & a,Complex &b)\n{\n    double r = a.real() * b.real() - a.imag() * b.imag();\n    double i = a.real() * b.imag() + a.imag() * b.real();\n    return Complex(r,i);\n}\nComplex operator/(Complex & a,Complex &b)\n{\n    double r =(a.real() * b.real() + a.imag() * b.imag() ) / (b.real() * b.real() + b.imag() * b.imag());\n    double i = ( a.imag() * b.real() - a.real() * b.imag() ) / (b.real() * b.real() + b.imag() * b.imag());\n    return Complex(r,i);\n}\n   ostream & operator << (ostream & out, Complex & c)\n    {\n        out << c.real() << \" + \" << c.imag() << \" i\";\n        return out;\n    }\nistream& operator>> (istream &in, Complex & a)\n{\n    double r,i;\n    in >> a.m_real;\n\tin >> a.m_imag;\n    return in;\n}",
            1592668276.989933,
            100,
            "# 答案正确"
        ],
        [
            "9.5 (C++)",
            "欧阳蓓",
            "#include <iostream>\nusing namespace std;\nclass Complex\n{\npublic:\n    Complex(): m_real(0), m_imag(0) {}\n    Complex(double r, double i): m_real(r),  m_imag (i) {}\n\n\n    friend istream & operator >> (istream & in, Complex & c);\n   \n    friend ostream & operator << (ostream & out, const Complex & c);\n    \n\n    double real()\n    {\n        return m_real;\n    }\n\n    double imag()\n    {\n        return m_imag;\n    }\n\n    Complex operator ++(int)\n    {\n        Complex t = *this;\n        m_real++;\n        return t;\n    }\n\n    Complex & operator ++()\n    {\n        m_real++;\n        return *this;\n    }\n\n    operator double ()\n    {\n        return m_real;\n    }\n\nprivate:\n    double m_real;\n    double  m_imag;\n};\n istream & operator >> (istream & in, Complex & c)\n    {\n        \n        in >> c.m_real >> c.m_imag;\n        return in;\n    }\n\n  ostream & operator << (ostream & out, const Complex & c)\n    {\n        out << c.m_real << \" + \" << c.m_imag << \" i\";\n        return out;\n    }",
            1593008403.962189,
            100,
            "# 答案正确"
        ],
        [
            "9.2 (C++)",
            "欧阳蓓",
            "class I\n{\n\tpublic:\n    I(int i1 = -1, int i2=-1, int i3=-1, int i4=-1)\n    {\n\t\tif(i1 != -1)\n            indexes.push_back(i1);\n        if (i2 != -1)\n            indexes.push_back(i2);\n        if (i3 != -1)\n            indexes.push_back(i3);\n        if (i4 != -1)\n            indexes.push_back(i4);\n    };\n\t\n    operator vector<int> ()\n    {\n        return indexes;\n    }\n\n\tprivate:\n    vector<int> indexes;\n};",
            1592644986.1170266,
            100,
            "# 答案正确"
        ],
        [
            "9.6 (C++)",
            "欧阳蓓",
            "class Tensor\n{\n    public:\n    Tensor(int a = -1, int b = -1, int c = -1, int d = -1)\n    {\n        int size = 1;\n        if(a != -1)\n        {\n            sizes.push_back(a);\n            size *= a;\n        }\n        \n        if(b != -1)\n        {\n            sizes.push_back(b);\n            size *= b; \n        }\n        \n        if(c != -1)\n        {\n            sizes.push_back(c);\n            size *= c; \n        }\n        \n        if(d != -1)\n        {\n            sizes.push_back(d);\n            size *= d; \n        }\n        data.resize(size);\n    }\n    double& operator()(int a , int b , int c , int d = 0)\n    {\n        int index = 0;\n        if(sizes.size() == 1)\n        {\n            index = a;\n        }\n        if(sizes.size() == 2)\n        {\n            index = a * sizes[1] + b;\n        }\n        if(sizes.size() == 3)\n        {\n            index = a * sizes[1]* sizes[2] + b * sizes[2] + c;\n        }\n        if(index == 4)\n        {\n            index = a * sizes[1]* sizes[2] * sizes[3] + b *sizes[2] * sizes[3] + c * sizes[3] + d;\n        }\n        return data[index];\n    }\n    private:\n    vector <double> data;\n    vector <int> sizes;\n};\n",
            1592575386.8420732,
            100,
            "# 答案正确"
        ],
        [
            "9.7 (C++)",
            "欧阳蓓",
            "class Tensor\n{\n    friend istream & operator>>(istream &in, Tensor &A);\n    friend ostream & operator<<(ostream &out, Tensor A);\n    public:\n    Tensor()\n    {\n        total = 0;\n        dimention = 0;\n    }\n    private:\n    vector<double> data;\n    vector<int>sizes;\n    int total;\n    int dimention;\n};\nistream & operator>>(istream &in, Tensor &A)\n{\n    in >> A.dimention;\n    int total = 1;\n    for(int i = 0; i < A.dimention; i++)\n    {\n        int t;\n        in >> t;\n        total *= t; \n        A.sizes.push_back(t);\n    }\n    A.total = total;\n    for(int i = 0; i < total; i++)\n    {\n        double t;\n        in >> t;\n        A.data.push_back(t);\n    }\n    return in;\n}\nostream & operator<<(ostream &out, Tensor A)\n{\n        out << A.dimention << endl;\n        if(A.dimention == 3 )\n\t\t{\n\t\t\tout << A.sizes [0] << \" \" << A.sizes[1] <<\" \"<<A.sizes[2] << endl << endl;\n\t\t\t\tfor(int i = 0; i < A.sizes[0]; i++)\n                {\n\t\t\t\t\tfor (int j = 0; j < A.sizes[1]; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int k = 0; k < A.sizes[2]; k++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint index = i * A.sizes[1] * A.sizes[2] + j * A.sizes[2] + k;\n\t\t\t\t\t\t\tout << A.data[index] << \" \";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tout << endl;\n\t\t\t\t\t}\n                    out << endl;\n                }\n\t\t}\n\t\tif(A.dimention == 4 )\n\t\t{\n            out << A.sizes [0] << \" \" << A.sizes[1] <<\" \"<<A.sizes[2] <<\" \"<< A.sizes[3] << endl << endl ;\n            for(int i = 0; i < A.sizes[0] * A.sizes[1]; i++)\n                {\n\t\t\t\t\tfor (int j = 0; j < A.sizes[2]; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int k = 0; k < A.sizes[3]; k++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint index =  i * A.sizes[2] * A.sizes[3] + j * A.sizes[3] + k; \n\t\t\t\t\t\t\tout << A.data[index] << \" \";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tout << endl;\n\t\t\t\t\t}\n                    out << endl;\n                }\n\t\t}\n    return out;\n}\n",
            1592579987.3582518,
            100,
            "# 答案正确"
        ],
        [
            "10.1 (C++)",
            "欧阳蓓",
            "#include <iostream>\n#include <vector>\n#include <stdexcept>\nusing namespace std;\nclass MatrixSizesDoNotMatchException {};\n\ndouble Matrix :: get(int row, int column) const\n      {\n\tif (row >  this->rows || column  >  this->columns)\n        throw out_of_range( \"\");\n\t\t\telse\n      \t return  elements[(row - 1) * columns + column - 1];\n    }\n\nvoid Matrix :: set(int row, int column, double value)\n    {\n        if (row >  this->rows || column  >  this->columns)\n        throw out_of_range( \"\");\n\t\t\telse\n      \telements[(row - 1) * columns + column - 1] = value;\n    }\n\nMatrix Matrix :: operator + (const Matrix & matrix2) const\n{\n    if(this->rows == matrix2.rows && this->columns == matrix2.columns)\n    {\n        Matrix t(rows,columns);\n        for(int i = 0; i < rows; i++)\n        {\n            for(int j = 0; j < columns; j++)\n            {\n                t.set(i,j, this->get(i,j) + matrix2.get(i,j));\n            }\n        }\n        return t;\n    }\n    else\n    {\n        throw MatrixSizesDoNotMatchException();\n    }\n            \n}",
            1593320026.2231026,
            100,
            "=================================================================\n==12104==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x611000009ed0 at pc 0x5641df07cbf7 bp 0x7ffefda9fd90 sp 0x7ffefda9fd80\nREAD of size 8 at 0x611000009ed0 thread T0\n    #0 0x5641df07cbf6 in Matrix::get(int, int) const /home/欧阳蓓/source.cpp:12\n    #1 0x5641df07d602 in Matrix::operator+(Matrix const&) const /home/欧阳蓓/source.cpp:32\n    #2 0x5641df07dc98 in test2(Matrix const&) /home/欧阳蓓/main.cpp:86\n    #3 0x5641df07dea9 in main /home/欧阳蓓/main.cpp:98\n    #4 0x7f9a1f2a982f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2082f)\n    #5 0x5641df07ca18 in _start (/home/欧阳蓓/main.out+0x1a18)\n\n0x611000009ed0 is located 16 bytes to the right of 256-byte region [0x611000009dc0,0x611000009ec0)\nallocated by thread T0 here:\n    #0 0x7f9a1fc84532 in operator new(unsigned long) (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x99532)\n    #1 0x5641df07e061 in __gnu_cxx::new_allocator<double>::allocate(unsigned long, void const*) /usr/include/c++/5/ext/new_allocator.h:104\n    #2 0x5641df07e061 in std::allocator_traits<std::allocator<double> >::allocate(std::allocator<double>&, unsigned long) /usr/include/c++/5/bits/alloc_traits.h:491\n    #3 0x5641df07e061 in std::_Vector_base<double, std::allocator<double> >::_M_allocate(unsigned long) /usr/include/c++/5/bits/stl_vector.h:170\n    #4 0x5641df07e061 in void std::vector<double, std::allocator<double> >::_M_emplace_back_aux<double>(double&&) /usr/include/c++/5/bits/vector.tcc:412\n    #5 0x5641df07e21a in void std::vector<double, std::allocator<double> >::emplace_back<double>(double&&) /usr/include/c++/5/bits/vector.tcc:101\n    #6 0x5641df07da58 in std::vector<double, std::allocator<double> >::push_back(double&&) /usr/include/c++/5/bits/stl_vector.h:932\n    #7 0x5641df07da58 in Matrix::Matrix(int, int) /home/欧阳蓓/main.cpp:16\n    #8 0x5641df07da58 in read() /home/欧阳蓓/main.cpp:44\n    #9 0x5641df07dc82 in test2(Matrix const&) /home/欧阳蓓/main.cpp:84\n    #10 0x5641df07dea9 in main /home/欧阳蓓/main.cpp:98\n    #11 0x7f9a1f2a982f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2082f)\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /home/欧阳蓓/source.cpp:12 Matrix::get(int, int) const\nShadow bytes around the buggy address:\n  0x0c227fff9380: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c227fff9390: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c227fff93a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c227fff93b0: fa fa fa fa fa fa fa fa 00 00 00 00 00 00 00 00\n  0x0c227fff93c0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n=>0x0c227fff93d0: 00 00 00 00 00 00 00 00 fa fa[fa]fa fa fa fa fa\n  0x0c227fff93e0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c227fff93f0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c227fff9400: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c227fff9410: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c227fff9420: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Heap right redzone:      fb\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack partial redzone:   f4\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n==12104==ABORTING\n"
        ],
        [
            "10.2 (C++)",
            "欧阳蓓",
            "   \n        \n        catch(out_of_range&)\n        {\n            cout << \"caught: out_of_range\"<<endl;\n        }\ncatch(NonPositiveValueException &  )\n        {\n            cout << \"caught: NonPositiveValueException\"<<endl;\n        }\n",
            1593656004.0381982,
            100,
            "In file included from main.cpp:101:0:\nsource.cpp: In function ‘int main()’:\nsource.cpp:7:1: warning: exception of type ‘NonPositiveValueException’ will be caught\n catch(NonPositiveValueException &  )\n ^\nsource.cpp:3:9: warning:    by earlier handler for ‘std::out_of_range’\n         catch(out_of_range&)\n         ^\n"
        ],
        [
            "15.1 (C++)",
            "欧阳蓓",
            "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\nclass Table\n{\n    friend ostream & operator << (ostream & out, const Table & table);\n    \n    public:\n  \t Table()\n    {\n        tab.resize(1);\n     \t\t\n    }\n    void addCol(string s)\n    {\n        col.push_back(s); \n    }\n    vector<string>& operator[](int n)\n    {  \n\t \t  \n        if (tab.size() == n + 1 ) \n\t\t{\n\t\t\tvector<string> temp;\n\t\t\ttab.push_back(temp);\n\t\t}\n        return tab[n];\n    }\n    string json()const\n    {\n        string s = \"{\\n    headers: [\";\n        for(int i = 0; i < col.size(); i++)\n        {\n            s += (\"'\" + col[i]+ \"'\" + \",\");\n        }\n        s+=\"],\\n\";\n        s+=\"    rows: [\\n\";\n       for(int i = 0 ; i< tab.size()-1; i++)\n        {\n            string a = \"       [\";\n            for (int j = 0; j < tab[i].size(); j++)\n            {\n                a += (\"'\" + tab[i][j] + \"',\"); \n            }\n            a+=\"],\\n\";\n            s += a;\n        }\n        s += \"    ],\\n}\"; \n        return s; \n    }\n    private:\n \t int row_size;\n    vector< vector <string> > tab;\n    vector<string> col;\n};",
            1593856695.6664164,
            100,
            "# 答案正确"
        ],
        [
            "2020-07-09 LAB",
            "欧阳蓓",
            "#include <iostream>\n#include <string>\nusing namespace std;\nclass Integer\n{\n    friend istream & operator >> (istream& in, Integer&m);\n    friend ostream &  operator << (istream& out,  Integer&m);\n    \n    private:\n    int val;\n    static int  increase;\n    public:\n    Integer()\n    {\n        val = 0;\n    }\n    Integer(int a)\n    {\n        val = a;\n    }\n    static void increase_all(int x)\n    {\n        increase = x;\n    }\n    operator int()\n    {\n        return val;\n    }\n    int getInt()  const\n    {\n        return val;\n    }\n    int& getInt()   \n    {\n        return val;\n    }\n    int getIncrease()\n    {\n        return  Integer :: increase;\n    }\n\tvoid add(int x)\n\t{\n\t\tval+=x;\n\t}\n};\nint Integer :: increase  = 0;\nistream & operator >> (istream& in, Integer&m)\n{\n    in>>m.val;\n    return in;\n}\nostream &  operator << (ostream& out,    Integer&m)\n{\n    m.add(m.getIncrease());\n\tout << m.getInt();\n    return out;\n}",
            1594262813.0662115,
            100,
            "# 答案正确"
        ],
        [
            "A.1 (C++)",
            "欧阳蓓",
            "    void addFirst(const E & e)\n    {\n        Node<E> * node = new Node<E>;\n        node -> element = e;\n        node -> update_prev_and_next_node(nullptr, head);\n        if (head != nullptr) head -> update_prev_node(nullptr, node);\n        head = node;\n        if (tail == nullptr) tail = node;\n        ++_size;\n    }\n\n    void addLast(const E & e)\n    {\n        Node<E> * node = new Node<E>;\n        node -> element = e;\n        node -> update_prev_and_next_node(tail, nullptr);\n        if (tail != nullptr) tail -> update_next_node(nullptr, node);\n        tail = node;\n        if (head == nullptr) head = node;\n        ++_size;\n    }\n\n  void remove (int index) {\n\t\t// Node<E> * node = get_node(index);\n\t\t// Node<E> * prev_node = node->prev_node;\n\t\t// Node<E> * next_node = node->next_node;\n\t\t// if (prev_node != 0) prev_node->next_node = next_node;\n\t\t// if (next_node != 0) next_node->prev_node = prev_node;\n\t\t// if (prev_node == 0) head = next_node;\n\t\t// if (next_node == 0) tail = prev_node;\n\t\t// delete node;\n\t\tif (index < 0 || index >= _size)\n        throw NotSuchElementException();\n\n        Node<E> * node =  get_node(index);\n        Node<E> * nextOfnode;\n\t\tNode<E> * preOfnode;\n        if(index == _size - 1)\n        {\n\t\t\tnextOfnode = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnextOfnode = get_node( index + 1 );\n\t\t}\n        if (index == 0)\n\t\t{\n\t\t\tpreOfnode = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpreOfnode = node->prev_node(nextOfnode);\n\t\t}\n        if(preOfnode != 0)\n        {\n            preOfnode->update_next_node(node,nextOfnode );\n        }\n        if(nextOfnode != 0)\n        {\n            nextOfnode->update_prev_node(node, preOfnode);\n        }\n        if(index == 0)\n        {\n            head = nextOfnode;\n        }\n        if(index == _size - 1)\n        {\n            tail = preOfnode;\n        }\n        delete node;\n\t\t-- _size;\n\t}\n\n\n    void removeFirst()\n    {\n        remove(0);\n    }\n\n    void removeLast()\n    {\n        remove(_size - 1);\n    }\n\n   void removeFirstOccurrence(const E & e) {\n\t\tint index = indexOf(e);\n\t\tif (index == -1)\n\t\t\tthrow NotSuchElementException();\n\t\tremove(index);\n\t}\n\n    E & get(int index)\n    {\n        Node<E> * node = get_node(index);\n        return node -> element;\n    }\n\nprivate:\n   \tNode<E> * get_node(int index) const \n\t{\n\t\tif (index < 0 || index >= _size) \n\t\t\tthrow NotSuchElementException();\n\t\tif (index < _size / 2) \n        {\n\t\t\tNode<E> * node = head;\n            Node<E> * preOfnow = 0;\n            Node<E> * temp = 0;\n\t\t\tI(i, index)\n            {\n                temp = node;\n                node = node -> next_node(preOfnow);\n                preOfnow = temp;\n            }\n\t\t\treturn node;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tNode<E> * node = tail;\n            Node<E> * nextOfnow = 0;\n            Node<E> * temp =0;\n\t\t\tI(i, (_size - 1 - index) )\n            {\n                temp = node;\n                node = node -> prev_node(nextOfnow);\n                nextOfnow = node;\n            }\n\t\t\treturn node;\n\t\t}\n\t}\n\n\tint indexOf(const E & e) const \n    {\n\t\t\n            Node<E> * node = head;\n            Node<E> * preOfnow = 0;\n            Node<E> * temp = 0;\n\t\t\tI(i, _size)\n            {\n                if(node->element == e)\n                return i;\n\n                temp = node;\n                node = node -> next_node(preOfnow);\n                preOfnow = temp;\n            }\n            return -1;\n\t}\n",
            1594788106.1517262,
            100,
            "# 答案正确"
        ],
        [
            "A.2 (C++)",
            "欧阳蓓",
            "template <typename E>\nvoid LinkedList<E> :: removeAll(const E & e)\n{\n\twhile (contains(e))\n\t{\n\t\t  removeFirstOccurrence( e );\n\t}\n}",
            1594867244.8393114,
            100,
            "# 答案正确"
        ],
        [
            "A.4 (C++)",
            "欧阳蓓",
            "#include <iostream>\n#include <sstream>\n#include<map>\n#include<vector>\n#include<string>\nusing namespace std;\n#define I(i,n) for (size_t i = 0; i < n; ++ i)\n\nclass NoSuchKeyException {};\nclass HT{\n    private:\n    class Tuple{\n        public:\n        int int_Key;\n        string string_Key;\n        int int_value;\n        string string_value;\n        bool in_use;\n        bool keyIsInt;\n        bool keyIsString;\n        Tuple() : in_use(false), keyIsInt(false), keyIsString(false) {}\n        Tuple(int key, int val): int_Key(key), int_value(val), in_use(true), keyIsInt(true), keyIsString(false) {}\n        Tuple(int key, string val): int_Key(key),string_value(val), in_use(true),  keyIsInt(true), keyIsString(false){}\n        Tuple(string key, int val): string_Key(key), int_value(val), in_use(true),  keyIsInt(false), keyIsString(true){}\n        Tuple(string key, string val): string_Key(key),string_value(val), in_use(true),keyIsInt(false), keyIsString(true) {}\n        operator int (){\n            return int_value;\n        }\n        operator string(){\n            return string_value;\n        }\n        void operator=(int val){\n            this->int_value = val;\n        }\n        void operator=(string val){\n            this->string_value = val;\n        }\n    };\n   vector<Tuple> tuples;\n\tsize_t _size;\n    size_t indexofKey(const int & key) const {\n        I(i, _size){\n            if(tuples[i].keyIsInt && tuples[i].int_Key == key){\n                return i;\n            }\n        }\n        return -1;\n\t}\n    size_t indexofKey(const string & key) const {\n        I(i, _size){\n            if(tuples[i].keyIsString && tuples[i].string_Key == key){\n                return i;\n           }\n        }\n        return -1;\n\t}\n\n    public:\n    HT() : _size(0){\n        tuples.resize(2);\n    }\n    int size() const{\n        return _size;\n    }\n    Tuple & operator [](int key){\n        int index = indexofKey(key);\n        if (index != -1) \n        \treturn tuples[index];\n        else{\n            tuples[_size].string_Key = key;\n            tuples[_size].keyIsInt = false;\n            tuples[_size].keyIsString = true;\n            _size++;\n            if (_size * 2 > tuples.size()) _double_tuples();\n            return tuples[_size - 1];\n\n        }   \n    }\n    Tuple & operator [](string key){\n        int index = indexofKey(key);\n        if (index != -1) \n        return tuples[index];\n        else{\n            tuples[_size].string_Key = key;\n            tuples[_size].keyIsInt = false;\n            tuples[_size].keyIsString = true;\n            _size++;\n            if (_size * 2 > tuples.size()) _double_tuples();\n            return tuples[_size - 1];\n\n        }  \n    }\n    void _double_tuples(){\n        vector<Tuple> non_empty_tuples;\n        for (int i = 0; i < _size; ++i){\n            if (tuples[i].in_use) non_empty_tuples.push_back(tuples[i]);\n        }\n        tuples.resize(tuples.size() * 2, Tuple());\n        for (int i = 0; i < non_empty_tuples.size(); ++i){\n            tuples[i] = non_empty_tuples[i];\n        }\n    }\n};\n\n\n",
            1595056368.1719122,
            100,
            "main.cpp: In function ‘int main()’:\nmain.cpp:13:6: error: ‘class HT’ has no member named ‘put’\n  map.put(key1, value1);\n      ^\nmain.cpp:18:6: error: ‘class HT’ has no member named ‘put’\n  map.put(key2, value2);\n      ^\nmain.cpp:23:6: error: ‘class HT’ has no member named ‘put’\n  map.put(key3, value3);\n      ^\nmain.cpp:28:6: error: ‘class HT’ has no member named ‘put’\n  map.put(key4, value4);\n      ^\n"
        ],
        [
            "A.5 (C++)",
            "欧阳蓓",
            "#include <iostream>\n#include <sstream>\n#include<map>\n#include<vector>\n#include<string>\nusing namespace std;\n#define I(i,n) for (size_t i = 0; i < n; ++ i)\n\nclass NoSuchKeyException {};\nclass HT\n{\n    private:\n    class Tuple\n    {\n        public:\n        int int_Key;\n        string string_Key;\n        int int_value;\n        string string_value;\n        bool in_use;\n        bool keyIsInt;\n        bool keyIsString;\n        Tuple() : in_use(false), keyIsInt(false), keyIsString(false) {}\n        Tuple(int key, int val): int_Key(key), int_value(val), in_use(true), keyIsInt(true), keyIsString(false) {}\n        Tuple(int key, string val): int_Key(key),string_value(val), in_use(true),  keyIsInt(true), keyIsString(false){}\n        Tuple(string key, int val): string_Key(key), int_value(val), in_use(true),  keyIsInt(false), keyIsString(true){}\n        Tuple(string key, string val): string_Key(key),string_value(val), in_use(true),keyIsInt(false), keyIsString(true) {}\n        operator int ()\n        {\n            return int_value;\n        }\n        operator string()\n        {\n            return string_value;\n        }\n        void operator = (int val)\n        {\n            this->int_value = val;\n        }\n        void operator = (string val)\n        {\n            this->string_value = val;\n        }\n    };\n    vector<Tuple> tuples;\n\tsize_t _size;\n    size_t indexofKey(const int & key) const \n\t{\n        I(i, _size)\n        {\n            if(tuples[i].keyIsInt && tuples[i].int_Key == key)\n            {\n                return i;\n            }\n        }\n        return -1;\n\t}\n    size_t indexofKey(const string & key) const \n\t{\n        I(i, _size)\n        {\n            if(tuples[i].keyIsString && tuples[i].string_Key == key)\n            {\n                return i;\n            }\n        }\n        return -1;\n\t}\n\n    public:\n    HT() : _size(0)\n    {\n        tuples.resize(2);\n    }\n    int size() const\n    {\n        return _size;\n    }\n    Tuple & operator [](int key)\n    {\n        int index = indexofKey(key);\n        if (index != -1) \n        return tuples[index];\n        else\n        {\n            tuples[_size].int_Key = key;\n            tuples[_size].keyIsInt = true;\n            tuples[_size].keyIsString = false;\n            _size++;\n            if (_size * 2 > tuples.size()) \n            _double_tuples();\n            return tuples[_size - 1];\n        }\n        \n    }\n    Tuple & operator [](string key)\n    {\n        int index = indexofKey(key);\n        if (index != -1) \n        return tuples[index];\n        else\n        {\n            tuples[_size].string_Key = key;\n            tuples[_size].keyIsInt = false;\n            tuples[_size].keyIsString = true;\n            _size++;\n            if (_size * 2 > tuples.size()) \n            _double_tuples();\n            return tuples[_size - 1];\n\n        }\n        \n    }\n    void _double_tuples()\n    {\n        vector<Tuple> non_empty_tuples;\n        for (int i = 0; i < _size; ++i)\n        {\n            if (tuples[i].in_use) non_empty_tuples.push_back(tuples[i]);\n        }\n        tuples.resize(tuples.size() * 2, Tuple());\n        for (int i = 0; i < non_empty_tuples.size(); ++i)\n        {\n            tuples[i] = non_empty_tuples[i];\n        }\n    }\n};\n\n\n",
            1595060415.0449743,
            100,
            "# 答案正确"
        ],
        [
            "A.3 (C++)",
            "欧阳蓓",
            "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <stdexcept>\nusing namespace std;\n\n#define I(i,n) for (size_t i = 0; i < n; ++ i)\n\nclass NoSuchKeyException {};\n\n\nint circular_shift(int bits, int shift_bits) {\n\tconst int num_bits = 8 * sizeof(int);\n\tshift_bits = shift_bits % num_bits;\n\treturn bits << shift_bits | bits >> (num_bits - shift_bits);\n}\n\nint hash_function(const int & key) {\n\tint code = 0;\n    code ^= circular_shift(key, 5);\n\treturn code;\n}\n\ntemplate <typename V>\nclass HT\n{\n\tclass Tuple\n\t{\n\tpublic:\n\t\tint key;\n\t\tV val;\n\t\tbool in_use;\n\n\t\tTuple() : in_use(false) {}\n\t};\n\n\tvector<Tuple> tuples;\n\tsize_t _size;\n\n\tsize_t canonical_index(const int & key) const {\n\t\tsize_t hash_code = hash_function(key); // needs hash_function(K)\n\t\treturn hash_code % tuples.size();\n\t}\n\n\t// the returned tuple is either empty or with the same key\n\tsize_t indexOfKey(const int & key) const {\n\t\tsize_t index = canonical_index(key);\n\t\twhile (true) { // will enter a dead loop if there is not empty tuple\n\t\t\tif (! tuples[index].in_use) return index;\n\t\t\tif (tuples[index].key == key) return index;\n\t\t\tindex = (index + 1) % tuples.size();\n\t\t}\n\t}\n\npublic:\n\tHT() : _size(0) {\n\t\ttuples.resize(1000);\n\t}\n\n\tbool containsKey(const int & key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\treturn tuples[index].in_use;\n\t}\n\n\tconst V & operator [] (const int & key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples[index].val;\n\t}\n\n\tV & operator [] (const int & key) {\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples[index].val;\n\t}\n\n\tvoid put(const int & key, const V & val) {\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].key = key;\n\t\ttuples[index].val = val;\n\t\tif (tuples[index].in_use) return;\n\t\ttuples[index].in_use = true;\n\t\t++ _size;\n\t\t// make sure empty > size / 2\n\t\tif (2 * _size > tuples.size())\n\t\t\t_double_tuples();\n\t}\n\n\tvoid _double_tuples() {\n\t\tvector<Tuple> non_empty_tuples;\n\t\tI(i, tuples.size())\n\t\t\tif (tuples[i].in_use)\n\t\t\t\tnon_empty_tuples.push_back(tuples[i]);\n\t\tclear();\n\t\ttuples.resize(tuples.size() * 2);\n\t\tI(i, non_empty_tuples.size())\n\t\t\tput(non_empty_tuples[i].key, non_empty_tuples[i].val);\n\t}\n\n\tstatic bool _between(size_t hole, size_t canonical, size_t tuple_index) {\n\t\tif (hole < tuple_index)\n\t\t\treturn canonical > hole && canonical <= tuple_index;\n\t\telse\n\t\t\treturn canonical > hole || canonical <= tuple_index;\n\t}\n\n\tvoid remove(const int & key) { \n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\ttuples[index].in_use = false;\n\t\t-- _size;\n\t\t// if there is a hole between a tuple and its canonical position\n\t\t// move the tuple to the hole\n\t\tsize_t hole = index;\n\t\tsize_t tuple_index = hole;\n\t\twhile (true) {\n\t\t\ttuple_index = (tuple_index + 1) % tuples.size();\n\t\t\tif (! tuples[tuple_index].in_use) return;\n\t\t\tsize_t canonical = canonical_index(tuples[tuple_index].key);\n\t\t\tif (_between(hole, canonical, tuple_index)) continue;\n\t\t\ttuples[hole] = tuples[tuple_index];\n\t\t\thole = tuple_index;\n\t\t\ttuples[hole].in_use = false;\n\t\t}\n\t}\n\n\tsize_t size() const { return _size; }\n\n\tvoid clear() {\n\t\tI(i, tuples.size())\n\t\t\ttuples[i].in_use = false;\n\t\t_size = 0;\n\t}\n\n    vector<int> getKeys()\n    {\n        vector<int> ans;\n        for(int i = 0; i < _size; i++)\n        {\n            if (tuples[i].in_use)\n            {\n                ans.push_back(tuples[i].key);\n            }\n        }\n        return ans;\n    }\n\ttemplate < typename V2>\n\tfriend ostream & operator << (ostream & out, const HT<V2> & dict);\n\n\ttemplate <typename V2>\n\tfriend istream & operator >> (istream & in, HT<V2> & dict);\n\n\tvoid _inspect() const {\n\t\tI(i, tuples.size())\n\t\t\tif (tuples[i].in_use)\n\t\t\t\tcout << \"#\" << i << \" C\" << canonical_index(tuples[i].key) \n\t\t\t\t\t<< \" \" << tuples[i].key << \" \" << tuples[i].val << endl;\n\t}\n};\n\ntemplate < typename V>\nostream & operator << (ostream & out, const HT<V> & dict) {\n\tout << dict.size() << endl;\n\tI(i, dict.tuples.size())\n\t\tif (dict.tuples[i].in_use)\n\t\t\tout << dict.tuples[i].key << \"\\t\" << dict.tuples[i].val << endl;\n\treturn out;\n}\n\ntemplate < typename V>\nistream & operator >> (istream & in, HT<V> & dict) {\n\tdict.clear();\n\tsize_t size;\n\tin >> size;\n\tI(i, size) {\n\t\tint key;\n\t\tV val;\n\t\tin >> key >> val;\n\t\tdict.put(key, val);\n\t}\n\treturn in;\n}\n\n \n",
            1595472127.2726161,
            96,
            "# 答案不正确\n\n# 随机输入:\n1383\n\n\n# 参考答案:\n1383\ntext51\ntext151\ntext251\ntext351\ntext451\ntext551\ntext651\ntext751\ntext851\ntext951\ntext1051\ntext1151\ntext1251\ntext1351\n0\n\n\n# 我的答案:\n1383\ntext51\ntext151\ntext251\ntext351\ntext451\ntext551\ntext651\ntext751\ntext851\ntext951\ntext1051\ntext1151\ntext1251\ntext1351\n883\n"
        ]
    ],
    "table_name": "答案"
}