{
    "__update_time__": 1595473247.6019502,
    "field_names": [
        "题目名",
        "用户名",
        "答案",
        "提交时间",
        "分数",
        "评语"
    ],
    "field_types": [
        "text",
        "text",
        "text",
        "time",
        "number",
        "text"
    ],
    "foreign_keys": {},
    "primary_keys": [],
    "rows": [
        [
            "测试2",
            "宋力舟",
            "#include <iostream>\n#include <string>\n#include<vector>\nusing namespace std;\nint main() \n{\n\tvector<string> st;\n\tstring s;\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tcin >> s;\n\t\tst.push_back(s);\n\t}\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tfor (int j = 0; j < 9; j++)\n\t\t {\n\t\t if (st[j] > st[j + 1])\n\t\t {\n\t\t\t swap(st[j], st[j + 1]);\n\t\t }\n\t\t }\n\t}\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tcout <<st[i] << \" \";\n\n\t}\n}",
            1587610787.9752107,
            100,
            "# 答案正确"
        ],
        [
            "1.1 (C++)",
            "宋力舟",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix5x5{\n\npublic:\n\t\n\t Matrix5x5(){\n\t\t for (int i = 0; i < 5; ++ i) {\n\t\t\t for(int j = 0 ; j < 5 ; ++j){\n\t\t\t\t set (i , j , 0) ;\n\t\t\t }\n\t\t }\n\t }\n\t\n    double get(int a , int b){\n        return matrix[a][b] ;\n    }\n\n    void set(int a , int b , double c){\n        matrix[a][b] = c ;\n    }\n\t \n\t private:\n\t double matrix[5][5] ;\n};\n\nMatrix5x5 operator + ( Matrix5x5 & a,Matrix5x5 & b)\n{\n    Matrix5x5 c;\n    for (int i = 0; i < 5; i++)\n    {\n        for (int j = 0; j < 5; j++)\n        {\n            double ans = a.get(i,j) + b.get(i,j);\n            c.set(i,j,ans);\n        }\n    }\n    return c;\n}\n\n",
            1587701059.935694,
            100,
            "# 答案正确"
        ],
        [
            "1.2 (C++)",
            "宋力舟",
            "#include <cstring>\n\nclass School{\n\tpublic:\n\tchar name[10]=\"NO_NAME\";\n\tint age=0;\n\tvoid setName(char n[]){\n\t\tint len=strlen(n);\n\t\tfor(int i=0;i<10;i++){\n\t\t\tname[i]='\\0';\n\t\t}\n\t\tfor(int i=0;i<len;i++){\n\t\t\tname[i]=n[i];\n\t\t}\n\t\t\n\t}\n\tvoid setAge(int year){\n\t\tage=year;\n\t}\n\tvoid operator ++ (){\n\t\tage++;\n\t}\n   \n};",
            1588215011.800511,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/08",
            "宋力舟",
            "double & Tensor_get(int dimensions, const int sizes[],   double data[], int x0, int x1, int x2, int x3)\n{\n\tif (dimensions == 1)\n\t\treturn   data[x0];\n\tif (dimensions == 2)\n\t\treturn data[x0 * sizes[1] +  x1];\n\tif (dimensions == 3)\n\t\treturn data[x0 * sizes[1] * sizes[2] +  x1 * sizes[2] + x2  ];\n\tif (dimensions == 4)\n\t\treturn data[x0 * sizes[1] * sizes[2] * sizes[3]+  x1 * sizes[2] * sizes[3]+ x2 * sizes[3] + x3  ];\n}",
            1588905421.565697,
            100,
            "# 答案正确"
        ],
        [
            "2.1 (C++)",
            "宋力舟",
            "#include <iostream>\nusing namespace std; \n\nclass Matrix {\n    private:\n        int rows ;\n        int columns ;\n        double * values;\n\n    public:\n        Matrix(int row , int col);\n\t\t\tvoid print();\n\t\t\t~Matrix();\n};\n\nMatrix::Matrix(int row , int col){\n\trows = row ;\n\tcolumns = col ;\n\tvalues = new double[row*col];\n\tfor(int i = 0 ; i < row*col ; ++i){\n\t\tvalues[i] = 0 ;\n\t}\n}\n\nvoid Matrix::print(){\n\tfor(int i = 0 ; i < rows ; ++i){\n\t\tfor(int j = 0 ; j < columns ; ++j){\n\t\t\tcout<<\"    \"<<values[j];\n\t\t}\n\t\tcout<<endl ;\n\t}\n}\n\nMatrix::~Matrix(){\n\tdelete[]values ;\n}",
            1589251118.6441114,
            100,
            "# 答案正确"
        ],
        [
            "2.2 (C++)",
            "宋力舟",
            "#include <iostream>\nusing namespace std ;\n\nclass Matrix{\n    private:\n        int rows ;\n        int columns ;\n        double * values ;\n\n    public:\n        Matrix(int row , int col , double val[]) ;\n        void print() ;\n        ~Matrix() ;\n};\n\nMatrix::Matrix(int row , int col , double val[]){\n\trows = row ;\n\tcolumns = col ;\n\tvalues = new double[row*col] ;\n\tfor(int i = 0 ; i < row*col ; ++i){\n\t\tvalues[i] = val[i] ;\n\t}\n}\n\nvoid Matrix::print(){\n\tfor(int i = 0 ; i < rows ; ++i){\n\t\tfor(int j = 0 ; j < columns ; ++j){\n\t\t\tif(values[j+columns*i]<10){\n\t\t\t\tcout << \"    \" << values[j+columns*i] ;\n\t\t\t}\n\t\t\tif(values[j+columns*i]>9&&values[j+columns*i]<100){\n\t\t\t\tcout << \"   \" << values[j+columns*i] ;\n\t\t\t}\n\t\t\t\n\t\t\tif(values[j+columns*i]>99&&values[j+columns*i]<1000){\n\t\t\t\tcout << \"  \" << values[j+columns*i] ;\n\t\t\t}\n\t\t\t\n\t\t\tif(values[j+columns*i]>9&&values[j+columns*i]==1000){\n\t\t\t\tcout << \" \" << values[j+columns*i] ;\n\t\t\t}\n\t\t}\n\t\tcout << endl ;\n\t}\n}\n\nMatrix::~Matrix(){\n\tdelete[]values ;\n}",
            1589252882.4650297,
            100,
            "# 答案正确"
        ],
        [
            "2.3 (C++)",
            "宋力舟",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix{\n\tprivate:\n\t\tint rows ;\n\t\tint columns ;\n\t\tdouble * values ;\n\t\n\tpublic:\n\t\tMatrix(int row , int col , double val[]);\n\t\tMatrix(const Matrix & matrix2);\n\t\tvoid print();\n\t\t~Matrix() ;\n};\n\nMatrix::Matrix(int row , int col , double val[]){\n\trows = row ;\n\tcolumns = col ;\n\tvalues = new double[row*col] ;\n\tfor(int i = 0 ; i < row*col ; ++i){\n\t\tvalues[i] = val[i] ;\n\t}\n}\n\nMatrix::Matrix(const Matrix & matrix2){\n\tthis->rows = matrix2.rows ;\n\tthis->columns = matrix2.columns ;\n\tvalues = new double[rows*columns] ;\n\t\n\tfor(int i = 0 ; i < rows*columns ; ++i){\n\t\tthis->values[i] = matrix2.values[i] ;\n\t}\n}\n\nvoid Matrix::print(){\n\tfor(int i = 0 ; i < rows ; ++i){\n\t\tfor(int j = 0 ; j < columns ; ++j){\n\t\t\tcout <<\"    \"<<values[j+i*columns];\n\t\t}\n\t\tcout << endl ;\n\t}\n}\n\nMatrix::~Matrix(){\n\tdelete[]values ;\n}",
            1589255850.2083502,
            100,
            "# 答案正确"
        ],
        [
            "2.5 (C++)",
            "宋力舟",
            "#include <iostream>\nusing namespace std;\nclass Matrix{\n \tprivate:\n \t\tint rows;\n  \t \tint columns;\n \t  \tdouble * values;\n\tpublic:\n \t\tMatrix(int r, int c);\n \t\tMatrix(int r, int c, double *v);\n \t\tvoid print();\n \t\t~Matrix();\n \t\tMatrix getRow(int row);\n\t\tMatrix getColumn(int column);\n};\n \n Matrix::Matrix(int r, int c,double*v){\n  rows=r;\n  columns=c;\n  values=new double[r*c];\n for (int i = 0; i <r *c ; ++ i){\n  values[i]=v[i];\n } }\n\n\n Matrix::Matrix(int r, int c){\n  rows=r;\n  columns=c;\n  values=new double[r*c];\n for (int i = 0; i <r *c ; ++ i){\n  values[i]=0;\n } }\n \n \n Matrix Matrix::getRow(int row){\n  Matrix a(1, columns);\n  for(int i=0;i<columns;i++){\n   int t=columns*(row-1)+i;\n   a.values[i]=values[t];\n  }\n  return a;\n }\n \n Matrix Matrix::getColumn(int column){\n  Matrix a(rows,1);\n  for(int i=0;i<rows;i++){\n   int t=i*columns+column-1;\n    a.values[i]=values[t];\n  }\n  return a;\n }\nvoid Matrix::print(){\n    int count=0;\n    for(int i =0;i<rows;i++){\n     for(int j=0;j<columns;j++){\n      int n=columns*i+j;\n      if(values[n]!=0)count++;\n  }\n }\n    for (int i = 0; i < rows ; ++ i) {\n        for (int j = 0; j < columns ; ++ j) {\n            int m=columns*i+j;\n            \n           cout << \"    \"<<values[m];\n        \n    }cout << endl;}\n}\n      Matrix::~Matrix(){\n  delete[]values;\n }\n ",
            1589369098.4309478,
            100,
            "# 答案正确"
        ],
        [
            "2.6 (C++)",
            "宋力舟",
            "#include <iostream>\nusing namespace std ;\n#include <stdlib.h>\n\nclass Matrix{\n\tprivate:\n\t\tint rows ;\n\t\tint columns ;\n\t\tdouble * values ;\n\t\n\tpublic:\n\t\tMatrix(int r, int c);\n\t\tMatrix(int row , int col , double val[]);\n\t\tMatrix(const Matrix & matrix2);\n\t\tMatrix concatenateRows(const Matrix & matrix2);\n\t\tMatrix concatenateColumns(const Matrix & matrix2);\n\t\tvoid print();\n\t\t~Matrix() ;\n/*\t\tMatrix getRow(int row);\n\t\tMatrix getColumn(int column);  */\n};\n\nMatrix::Matrix(int row , int col , double val[]){\n\trows = row ;\n\tcolumns = col ;\n\tvalues = new double[row*col] ;\n\tfor(int i = 0 ; i < row*col ; ++i){\n\t\tvalues[i] = val[i] ;\n\t}\n}\n\nMatrix::Matrix(const Matrix & matrix2){\n\tthis->rows = matrix2.rows ;\n\tthis->columns = matrix2.columns ;\n\tvalues = new double[rows*columns] ;\n\t\n\tfor(int i = 0 ; i < rows*columns ; ++i){\n\t\tthis->values[i] = matrix2.values[i] ;\n\t}\n}\n\n\nMatrix::Matrix(int r, int c){\n   rows=r;\n   columns=c;\n \tvalues=new double[r*c];\n\tfor (int i = 0; i <r *c ; ++ i){\n  \t\tvalues[i]=0;\n\t}\n}\n \nMatrix Matrix::concatenateRows(const Matrix & matrix2) {\n\tMatrix t(rows * 2 , columns);\n\tint fa ;\n   for(int i = 0 ; i < rows*2*columns ; ++i){\n\t   if(i<rows*columns){\n\t\t   t.values[i] = values[i] ;\n\t\t   fa = i+1 ;\n\t   }\n\t   else{\n\t\t   t.values[i] = matrix2.values[i-fa] ;\n\t   }\n   }      \n        \n   return t;\n}\n\n\nMatrix Matrix::concatenateColumns(const Matrix & matrix2){\n\tMatrix t(rows, columns*2);\n    int fa=0 ;\n    int c1 = 0 ;\n    int c2 = 0 ;\n    for(int i = 0 ; i < rows*2*columns ; ++i){\n\t    if(i%(columns*2)==0&&i!=0){\n            ++fa ;\n        }\n        if(i<columns*(2*fa+1)){\n            t.values[i] = values[c1];\n            ++c1 ;\n        }\n        if(i>=columns*(2*fa+1)){\n            t.values[i] = matrix2.values[c2];\n            ++c2 ;\n        }\n    }    \n         \n    return t;\n}  \n\nvoid Matrix::print(){\n\tfor(int i = 0 ; i < rows ; ++i){\n\t\tfor(int j = 0 ; j < columns ; ++j){\n\t\t\tcout <<\"    \"<<values[j+i*columns];\n\t\t}\n\t\tcout << endl ;\n\t}\n}\n\nMatrix::~Matrix(){\n\tdelete[]values ;\n}",
            1589372936.4872568,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/14",
            "宋力舟",
            "#include<cstdio>\n#include<iostream>\nusing namespace std;\nvoid Tensor_print(int dimensions, const int sizes[], const double data[])\n{\n\tif (dimensions == 1)\n\t{\n\t\tprintf(\"Tensor of %d\\n\",sizes[0]);\n\t\tfor (int i = 0; i < sizes[0]; i++)\n\t\t{\n\t\t\tcout << data[i] << endl;\n\t\t}\n\t\t\n\t}\n\tif (dimensions == 2)\n\t{\n\t\tprintf(\"Tensor of %dx%d\\n\",sizes[0],sizes[1]);\n\t\tfor (int i = 0; i < sizes[0]; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < sizes[1]; j++)\n\t\t\t{\n\t\t\t\tcout<<\"    \"<<data[i * sizes[1] + j];\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t}\n\tif (dimensions == 3)\n    {\n        printf(\"Tensor of %dx%dx%d\\n\",sizes[0],sizes[1],sizes[2]);\n        for (int i = 0; i < sizes[0]; i++)\n        {\n            printf(\"date[%d]\\n\",i);\n            for (int j = 0; j < sizes[1];j++)\n            {\n                for (int k = 0; k < sizes[2]; k++)\n                {\n                    cout <<\"    \"<< data[i*sizes[1]*sizes[2] + j * sizes[2] + k];\n                }\n                cout << endl;\n            }\n        }\n    }\n    if (dimensions==4)\n    {\n\t\tprintf(\"Tensor of %dx%dx%dx%d\\n\",sizes[0],sizes[1],sizes[2],sizes[3]);\n        for (int i = 0; i < sizes[0];i++)\n        {\n            for (int j = 0; j < sizes[1]; j++)\n            {\n                printf(\"data[%d][%d]\\n\",i,j);\n                for (int k = 0; k < sizes[2]; k++)\n                {\n                    for (int m = 0; m < sizes[3];m++)\n                    {\n                        cout << \"    \" <<data[i*sizes[1]*sizes[2]*sizes[3] + j * sizes[2] * sizes[3] + k * sizes[3] + m];\n                    }\n                    cout << endl;\n                }\n            }\n        }\n    }\n}",
            1589427181.4395134,
            95,
            "# 答案不正确\n\n# 随机输入:\n1.3\n8.7\n3.0\n4.6\n\n\n# 参考答案:\nTensor of 5\n1.3\n1.3\n1.3\n1.3\n1.3\n\nTensor of 3x4\n    8.7    8.7    8.7    8.7\n    8.7    8.7    8.7    8.7\n    8.7    8.7    8.7    8.7\n\nTensor of 3x4x5\ndata[0]\n    3    3    3    3    3\n    3    3    3    3    3\n    3    3    3    3    3\n    3    3    3    3    3\ndata[1]\n    3    3    3    3    3\n    3    3    3    3    3\n    3    3    3    3    3\n    3    3    3    3    3\ndata[2]\n    3    3    3    3    3\n    3    3    3    3    3\n    3    3    3    3    3\n    3    3    3    3    3\n\nTensor of 2x3x4x5\ndata[0][0]\n    4.6    4.6    4.6    4.6    4.6\n    4.6    4.6    4.6    4.6    4.6\n    4.6    4.6    4.6    4.6    4.6\n    4.6    4.6    4.6    4.6    4.6\ndata[0][1]\n    4.6    4.6    4.6    4.6    4.6\n    4.6    4.6    4.6    4.6    4.6\n    4.6    4.6    4.6    4.6    4.6\n    4.6    4.6    4.6    4.6    4.6\ndata[0][2]\n    4.6    4.6    4.6    4.6    4.6\n    4.6    4.6    4.6    4.6    4.6\n    4.6    4.6    4.6    4.6    4.6\n    4.6    4.6    4.6    4.6    4.6\ndata[1][0]\n    4.6    4.6    4.6    4.6    4.6\n    4.6    4.6    4.6    4.6    4.6\n    4.6    4.6    4.6    4.6    4.6\n    4.6    4.6    4.6    4.6    4.6\ndata[1][1]\n    4.6    4.6    4.6    4.6    4.6\n    4.6    4.6    4.6    4.6    4.6\n    4.6    4.6    4.6    4.6    4.6\n    4.6    4.6    4.6    4.6    4.6\ndata[1][2]\n    4.6    4.6    4.6    4.6    4.6\n    4.6    4.6    4.6    4.6    4.6\n    4.6    4.6    4.6    4.6    4.6\n    4.6    4.6    4.6    4.6    4.6\n\n\n# 我的答案:\nTensor of 5\n1.3\n1.3\n1.3\n1.3\n1.3\n\nTensor of 3x4\n    8.7    8.7    8.7    8.7\n    8.7    8.7    8.7    8.7\n    8.7    8.7    8.7    8.7\n\nTensor of 3x4x5\ndate[0]\n    3    3    3    3    3\n    3    3    3    3    3\n    3    3    3    3    3\n    3    3    3    3    3\ndate[1]\n    3    3    3    3    3\n    3    3    3    3    3\n    3    3    3    3    3\n    3    3    3    3    3\ndate[2]\n    3    3    3    3    3\n    3    3    3    3    3\n    3    3    3    3    3\n    3    3    3    3    3\n\nTensor of 2x3x4x5\ndata[0][0]\n    4.6    4.6    4.6    4.6    4.6\n    4.6    4.6    4.6    4.6    4.6\n    4.6    4.6    4.6    4.6    4.6\n    4.6    4.6    4.6    4.6    4.6\ndata[0][1]\n    4.6    4.6    4.6    4.6    4.6\n    4.6    4.6    4.6    4.6    4.6\n    4.6    4.6    4.6    4.6    4.6\n    4.6    4.6    4.6    4.6    4.6\ndata[0][2]\n    4.6    4.6    4.6    4.6    4.6\n    4.6    4.6    4.6    4.6    4.6\n    4.6    4.6    4.6    4.6    4.6\n    4.6    4.6    4.6    4.6    4.6\ndata[1][0]\n    4.6    4.6    4.6    4.6    4.6\n    4.6    4.6    4.6    4.6    4.6\n    4.6    4.6    4.6    4.6    4.6\n    4.6    4.6    4.6    4.6    4.6\ndata[1][1]\n    4.6    4.6    4.6    4.6    4.6\n    4.6    4.6    4.6    4.6    4.6\n    4.6    4.6    4.6    4.6    4.6\n    4.6    4.6    4.6    4.6    4.6\ndata[1][2]\n    4.6    4.6    4.6    4.6    4.6\n    4.6    4.6    4.6    4.6    4.6\n    4.6    4.6    4.6    4.6    4.6\n    4.6    4.6    4.6    4.6    4.6\n"
        ],
        [
            "2.9 (C++)",
            "宋力舟",
            "#include<iostream>\n#include <iomanip>\n#include <stdlib.h>\nusing namespace std;\n\n\nclass Matrix{\nprivate:\n    int rows;\n    int columns;\n    double* values;\n\t\n\t\npublic:\n    Matrix()\n    {\n        rows = 0;\n        columns = 0;\n        values = 0;\n    }\n    Matrix(int rows, int columns)\n    {\n        this->rows = rows;\n        this->columns = columns;\n        \n        values = new  double[rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            values[i] = 0;\n        }\n    }\n    Matrix(int r, int c, double v[])\n    {\n        this->rows = r;\n        this->columns = c;\n        values = new  double[r * c];\n        for (int i = 0; i < r * c; i++)\n        {\n            values[i] = v[i];\n        }\n    }\n    Matrix(const Matrix& matrix2)\n    {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        values = new  double[rows * columns];\n        for (int i = 0; i < rows; i++)\n        {\n            values[i] = matrix2.values[i];\n        }\n    }\n    void set(int r, int c, double v)\n    {\n        values[(r - 1) * columns + c - 1] = v;\n    }\n    Matrix& operator= (const Matrix& matrix2)\n    {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        if (values != nullptr)\n            delete []values;\n\n        values = new  double[rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            values[i] = matrix2.values[i];\n        }\n        return *this;\n    }\n    Matrix operator + (const Matrix & matrix2) const\n    {\n        double * a = new double [this->rows * this->columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = this->values[i] + matrix2.values[i];\n        }\n        Matrix temp(rows,columns,a);\n        delete []a;\n        return temp;\n    }\n    Matrix operator + (double v) const\n    {\n        double * a = new double [this->rows * this->columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = this->values[i] + v;\n        }\n        Matrix temp(rows,columns,a);\n        delete []a;\n        return temp;\n    }\n    Matrix operator - (const Matrix & matrix2) const\n    {\n        double * a = new double [this->rows * this->columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = this->values[i] - matrix2.values[i];\n        }\n        Matrix temp(rows,columns,a);\n        delete []a;\n        return temp;\n    }\n    Matrix operator - (double v) const\n    {\n        double * a = new double [this->rows * this->columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = this->values[i] - v;\n        }\n        Matrix temp(rows,columns,a);\n        delete []a;\n        return temp;\n    }\n    ~Matrix()\n    {\n        if (values != 0)\n            delete []values;\n    }\n    void print()\n    {\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < columns; j++)\n            {\n\n                cout << \"    \" << values[i * columns + j];\n            }\n            cout << endl;\n        }\n    }\n};",
            1590029771.299338,
            100,
            "# 答案正确"
        ],
        [
            "2.4 (C++)",
            "宋力舟",
            "#include<iostream>\n#include <iomanip>\nusing namespace std;\nclass Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    double* values;\n\t\n\t\npublic:\n    Matrix()\n    {\n        rows = 0;\n        columns = 0;\n        values = 0;\n    }\n    Matrix(int rows, int columns)\n    {\n        this->rows = rows;\n        this->columns = columns;\n        \n        values = new  double[rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            values[i] = 0;\n        }\n    }\n    Matrix(int r, int c, double v[])\n    {\n        this->rows = r;\n        this->columns = c;\n         \n        values = new  double[r * c];\n        for (int i = 0; i < r * c; i++)\n        {\n            values[i] = v[i];\n        }\n    }\n    void set(int r, int c, double v)\n    {\n        values[(r - 1) * columns + c - 1] = v;\n    }\n    Matrix& operator= (const Matrix& matrix2)\n    {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        if (values != nullptr)\n            delete []values;\n\t\t\n        values = new  double[rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            values[i] = matrix2.values[i];\n        }\n        return *this;\n    }\n    Matrix(const Matrix& matrix2)\n    {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n       \n        values = new  double[rows * columns];\n        for (int i = 0; i < rows; i++)\n        {\n            values[i] = matrix2.values[i];\n        }\n    }\n\n    ~Matrix()\n    {\n        if (values != 0)\n            delete []values;\n    }\n    void print()\n    {\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < columns; j++)\n            {\n\n                cout << \"    \" << values[i * columns + j];\n            }\n            cout << endl;\n        }\n\t}\n};",
            1590059482.4403138,
            100,
            "# 答案正确"
        ],
        [
            "2.7 (C++)",
            "宋力舟",
            "#include<iostream>\n#include <iomanip>\nusing namespace std;\nclass Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    double* values;\npublic:\n    Matrix()\n    {\n        rows = 0;\n        columns = 0;\n        values = 0;\n    }\n    Matrix(int rows, int columns)\n    {\n        this->rows = rows;\n        this->columns = columns;\n        \n        values = new  double[rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            values[i] = 0;\n        }\n    }\n    Matrix(int r, int c, double v[])\n    {\n        this->rows = r;\n        this->columns = c;\n        values = new  double[r * c];\n        for (int i = 0; i < r * c; i++)\n        {\n            values[i] = v[i];\n        }\n    }\n    Matrix(const Matrix& matrix2)\n    {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        values = new  double[rows * columns];\n        for (int i = 0; i < rows; i++)\n        {\n            values[i] = matrix2.values[i];\n        }\n    }\n    void set(int r, int c, double v)\n    {\n        values[(r - 1) * columns + c - 1] = v;\n    }\n    Matrix& operator= (const Matrix& matrix2)\n    {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        if (values != nullptr)\n            delete []values;\n\n        values = new  double[rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            values[i] = matrix2.values[i];\n        }\n        return *this;\n    }\n    Matrix reshape(int r , int c ) const\n    {\n        double * a = new double [r * c];\n        int m = 0;\n        for (int i = 0; i < columns; i++)\n        {\n            for (int j = 0; j < rows; j++)\n            {\n                a[m++] = this->values[j * columns + i];\n            }\n        }\n        m = 0;\n        Matrix temp(r,c);\n        for (int i = 0; i < c; i++)\n        {\n            for(int j = 0; j < r; j++)\n            {\n                temp.values[j * c + i] = a[m++];\n            }\n        }\n        delete []a;\n        return temp;\n\n    }\n    ~Matrix()\n    {\n        if (values != 0)\n            delete []values;\n    }\n    void print()\n    {\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < columns; j++)\n            {\n\n                cout << \"    \" << values[i * columns + j];\n            }\n            cout << endl;\n        }\n    }\n\n};",
            1590059520.8266418,
            100,
            "# 答案正确"
        ],
        [
            "2.8 (C++)",
            "宋力舟",
            "#include<iostream>\n#include <iomanip>\nusing namespace std;\nclass Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    double* values;\npublic:\n    Matrix()\n    {\n        rows = 0;\n        columns = 0;\n        values = 0;\n    }\n    Matrix(int rows, int columns)\n    {\n        this->rows = rows;\n        this->columns = columns;\n        \n        values = new  double[rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            values[i] = 0;\n        }\n    }\n    Matrix(int r, int c, double v[])\n    {\n        this->rows = r;\n        this->columns = c;\n        values = new  double[r * c];\n        for (int i = 0; i < r * c; i++)\n        {\n            values[i] = v[i];\n        }\n    }\n    Matrix(const Matrix& matrix2)\n    {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        values = new  double[rows * columns];\n        for (int i = 0; i < rows; i++)\n        {\n            values[i] = matrix2.values[i];\n        }\n    }\n    void set(int r, int c, double v)\n    {\n        values[(r - 1) * columns + c - 1] = v;\n    }\n    Matrix& operator= (const Matrix& matrix2)\n    {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        if (values != nullptr)\n            delete []values;\n\n        values = new  double[rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            values[i] = matrix2.values[i];\n        }\n        return *this;\n    }\n    Matrix reshape(int r , int c ) const\n    {\n        double * a = new double [r * c];\n        int m = 0;\n        for (int i = 0; i < columns; i++)\n        {\n            for (int j = 0; j < rows; j++)\n            {\n                a[m++] = this->values[j * columns + i];\n            }\n        }\n        m = 0;\n        Matrix temp(r,c);\n        for (int i = 0; i < c; i++)\n        {\n            for(int j = 0; j < r; j++)\n            {\n                temp.values[j * c + i] = a[m++];\n            }\n        }\n        delete []a;\n        return temp;\n    }\n    Matrix transpose()\n    {\n        double * a = new double [rows * columns];\n        int m = 0;\n        for (int i = 0; i < columns; i++)\n        {\n            for (int j = 0; j < rows; j++)\n            {\n                a[m++] = this->values[j * columns + i];\n            }\n        }\n        Matrix temp(columns,rows,a);\n        delete []a;\n        return temp;\n    }\n    \n    void print()\n    {\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < columns; j++)\n            {\n\n                cout << \"    \" << values[i * columns + j];\n            }\n            cout << endl;\n        }\n    }\n~Matrix()\n    {\n        if (values != 0)\n            delete []values;\n    }\n};",
            1590059633.9852712,
            100,
            "# 答案正确"
        ],
        [
            "2.10 (C++)",
            "宋力舟",
            "#include<iostream>\n#include <iomanip>\nusing namespace std;\nclass Matrix{\n\tprivate:\n    int rows;\n    int columns;\n    double* values;\npublic:\n   Matrix()\n    {\n        rows = 0;\n        columns = 0;\n        values = nullptr;\n    }\n    Matrix(int rows, int columns)\n    {\n        this->rows = rows;\n        this->columns = columns;\n        values = new  double[rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            values[i] = 0;\n        }\n    }\n    Matrix(int r, int c, double v[])\n    {\n        this->rows = r;\n        this->columns = c;\n        values = new  double[r * c];\n        for (int i = 0; i < r * c; i++)\n        {\n            values[i] = v[i];\n        }\n    }\n  Matrix(const Matrix& matrix2)\n    {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        values = new  double[rows * columns];\n        for (int i = 0; i < rows; i++)\n        {\n            values[i] = matrix2.values[i];\n        }\n    }\n   \n    Matrix operator * (const Matrix & matrix2) const\n    {\n        Matrix temp(rows,rows);\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < rows; j++)\n            {\n                double sum = 0;\n                for(int k = 0; k < columns; k++)\n                {\n                    sum += this->values[i * columns + k] * matrix2.values[k * rows + j];\n                }\n                temp.values[i*rows+j] = sum;\n            }\n        }\n        return temp;\n    }\n    Matrix  operator * (double v ) const\n    {\n        double * a = new double[rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = v * values[i];\n        }\n        Matrix temp (rows,columns,a);\n        delete []a;\n        return temp;\n    }\n    Matrix& operator= (const Matrix& matrix2)\n    {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        if (values != nullptr)\n            delete []values;\n\n        values = new  double[rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            values[i] = matrix2.values[i];\n        }\n        return *this;\n    }\n    Matrix reshape(int r , int c ) const\n    {\n        double * a = new double [r * c];\n        int m = 0;\n        for (int i = 0; i < columns; i++)\n        {\n            for (int j = 0; j < rows; j++)\n            {\n                a[m++] = this->values[j * columns + i];\n            }\n        }\n        m = 0;\n        Matrix temp(r,c);\n        for (int i = 0; i < c; i++)\n        {\n            for(int j = 0; j < r; j++)\n            {\n                temp.values[j * c + i] = a[m++];\n            }\n        }\n        delete []a;\n        return temp;\n    }\n    Matrix transpose()\n    {\n        double * a = new double [rows * columns];\n        int m = 0;\n        for (int i = 0; i < columns; i++)\n        {\n            for (int j = 0; j < rows; j++)\n            {\n                a[m++] = this->values[j * columns + i];\n            }\n        }\n        Matrix temp(columns,rows,a);\n        delete []a;\n        return temp;\n    }\n    \n    void print()\n    {\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < columns; j++)\n            {\n\n                cout << \"    \" << values[i * columns + j];\n            }\n            cout << endl;\n        }\n    }\n\n\t~Matrix()\n    {\n        if (values != 0)\n            delete []values;\n    }\n};",
            1590059677.138322,
            100,
            "# 答案正确"
        ],
        [
            "2.11 (C++)",
            "宋力舟",
            "#include <iostream>\n\nusing namespace std;\n\nclass Matrix{\nprivate:\n    double **matrix;\n    int rows;\n    int columns;\npublic:\n    Matrix()\n    {\n        matrix = nullptr;\n        rows = 0;\n        columns = 0;\n    }\n\n    Matrix(int rows, int columns)\n    {\n        this -> rows = rows;\n        this -> columns = columns;\n        matrix = new double*[rows];\n        for (int i = 0; i < rows; ++i)\n        {\n            matrix[i] = new double [columns];\n            for (int j = 0; j < columns; ++j)\n            {\n                matrix[i][j] = 0;\n            }\n        }\n    }\n\n    Matrix(int rows, int columns, const double *value)\n    {\n        this -> rows = rows;\n        this -> columns = columns;\n        matrix = new double*[rows];\n        for (int i = 0; i < rows; ++i)\n        {\n            matrix[i] = new double [columns];\n            for (int j = 0; j < columns; ++j)\n            {\n                matrix[i][j] = value[i * columns + j];\n            }\n        }\n    }\n\n    Matrix (const Matrix & matrix1)\n    {\n        rows = matrix1.rows;\n        columns = matrix1.columns;\n        matrix = new double*[rows];\n        for (int i = 0; i < rows; ++i)\n        {\n            matrix[i] = new double [columns];\n            for (int j = 0; j < columns; ++j)\n            {\n                matrix[i][j] = matrix1.matrix[i][j];\n            }\n        }\n    }\n\n    Matrix max()\n    {\n        if (rows > 1 && columns > 1)\n        {\n            Matrix t(1, columns);\n            double num_max = 0;\n            for (int i = 0; i < columns; ++i)\n            {\n                for (int j = 0; j < rows; ++j)\n                {\n                    num_max = num_max > matrix[j][i] ? num_max : matrix[j][i];\n                }\n                t[0][i] = num_max;\n                num_max = 0;\n            }\n            return t;\n        }\n        else if (rows == 1 && columns > 1)\n        {\n            double num_max[1] = {0};\n            for (int i = 0; i < columns; ++i)\n            {\n                num_max[0] = num_max[0] > matrix[0][i] ? num_max[0] : matrix[0][i];\n            }\n            Matrix t(1, 1, num_max);\n            return t;\n        }\n        else return *this;\n    }\n\n    Matrix min()\n    {\n        if (rows > 1 && columns > 1)\n        {\n            Matrix t(1, columns);\n            double num_min = 99999999;\n            for (int i = 0; i < columns; ++i)\n            {\n                for (int j = 0; j < rows; ++j)\n                {\n                    num_min = num_min > matrix[j][i] ? matrix[j][i] : num_min;\n                }\n                t[0][i] = num_min;\n                num_min = 99999999;\n            }\n            return t;\n        }\n        else if (rows == 1 && columns > 1)\n        {\n            double num_min[1] = {99999999};\n            for (int i = 0; i < columns; ++i)\n            {\n                num_min[0] = num_min[0] > matrix[0][i] ? matrix[0][i] : num_min[0];\n            }\n            Matrix t(1, 1, num_min);\n            return t;\n        }\n        else return *this;\n    }\n\n    Matrix sum()\n    {\n        if (rows > 1 && columns > 1)\n        {\n            Matrix t(1, columns);\n            double sum = 0;\n            for (int i = 0; i < columns; ++i)\n            {\n                for (int j = 0; j < rows; ++j)\n                {\n                    sum +=  matrix[j][i];\n                }\n                t[0][i] = sum;\n                sum = 0;\n            }\n            return t;\n        }\n        else if (rows == 1 && columns > 1)\n        {\n            double sum[1] = {0};\n            for (int i = 0; i < columns; ++i)\n            {\n                sum[0] += matrix[0][i];\n            }\n            Matrix t(1, 1, sum);\n            return t;\n        }\n        else return *this;\n    }\n\n    double * operator [] (int n)\n    {\n        return matrix[n];\n    }\n\n    void print()\n    {\n        for (int i = 0; i < rows; ++i)\n        {\n            for (int j = 0; j < columns; ++j)\n            {\n                cout << \"    \" << matrix[i][j];\n            }\n            cout << endl;\n        }\n    }\n\n    ~Matrix()\n    {\n        for (int i = 0; i < rows; ++i)\n        {\n            if (matrix[i] != nullptr) delete [] matrix[i];\n        }\n        if (matrix != nullptr) delete [] matrix;\n    }\n};",
            1590059806.915251,
            100,
            "# 答案正确"
        ],
        [
            "2.12 (C++)",
            "宋力舟",
            "#include<iostream>\n#include <iomanip>\nusing namespace std;\n#include<cmath>\n\nclass Matrix{\n\tprivate:\n    int rows;\n    int columns;\n    double* values;\npublic:\n    Matrix()\n    {\n        rows = 0;\n        columns = 0;\n        values = 0;\n    }\n    Matrix(int rows, int columns)\n    {\n        this->rows = rows;\n        this->columns = columns;\n        \n        values = new  double[rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            values[i] = 0;\n        }\n    }\n    Matrix(int r, int c, double v[])\n    {\n        this->rows = r;\n        this->columns = c;\n        values = new  double[r * c];\n        for (int i = 0; i < r * c; i++)\n        {\n            values[i] = v[i];\n        }\n    }\n    Matrix(const Matrix& matrix2)\n    {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        values = new  double[rows * columns];\n        for (int i = 0; i < rows; i++)\n        {\n            values[i] = matrix2.values[i];\n        }\n    }\n    void set(int r, int c, double v)\n    {\n        values[(r - 1) * columns + c - 1] = v;\n    }\n    Matrix operator * (const Matrix & matrix2) const\n    {\n        Matrix temp(rows,rows);\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < rows; j++)\n            {\n                double sum = 0;\n                for(int k = 0; k < columns; k++)\n                {\n                    sum += this->values[i * columns + k] * matrix2.values[k * rows + j];\n                }\n                temp.values[i*rows+j] = sum;\n            }\n        }\n        return temp;\n    }\n    Matrix  operator * (double v ) const\n    {\n        double * a = new double[rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = v * values[i];\n        }\n        Matrix temp (rows,columns,a);\n        delete []a;\n        return temp;\n    }\n    Matrix& operator= (const Matrix& matrix2)\n    {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        if (values != nullptr)\n            delete []values;\n\n        values = new  double[rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            values[i] = matrix2.values[i];\n        }\n        return *this;\n    }\n    Matrix reshape(int r , int c ) const\n    {\n        double * a = new double [r * c];\n        int m = 0;\n        for (int i = 0; i < columns; i++)\n        {\n            for (int j = 0; j < rows; j++)\n            {\n                a[m++] = this->values[j * columns + i];\n            }\n        }\n        m = 0;\n        Matrix temp(r,c);\n        for (int i = 0; i < c; i++)\n        {\n            for(int j = 0; j < r; j++)\n            {\n                temp.values[j * c + i] = a[m++];\n            }\n        }\n        delete []a;\n        return temp;\n    }\n    Matrix transpose()\n    {\n        double * a = new double [rows * columns];\n        int m = 0;\n        for (int i = 0; i < columns; i++)\n        {\n            for (int j = 0; j < rows; j++)\n            {\n                a[m++] = this->values[j * columns + i];\n            }\n        }\n        Matrix temp(columns,rows,a);\n        delete []a;\n        return temp;\n    }\n    Matrix  pow(double exponent)\n    {\n        double * a = new double[columns * rows];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] =  std ::pow(values[i],exponent);\n        }\n        Matrix temp (rows,columns,a);\n        delete [] a;\n        return temp;\n    }\n    Matrix  exp()\n    {\n        double * a = new double[columns * rows];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] =  std ::exp(values[i] );\n        }\n        Matrix temp (rows,columns,a);\n        delete [] a;\n        return temp;\n    }\n    Matrix  log()\n    {\n        double * a = new double[columns * rows];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] =  std ::log (values[i]);\n        }\n        Matrix temp (rows,columns,a);\n        delete [] a;\n        return temp;\n    }\n    Matrix  abs()\n    {\n        double * a = new double[columns * rows];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] =  std :: abs (values[i]);\n        }\n        Matrix temp (rows,columns,a);\n        delete [] a;\n        return temp;\n    }\n    void print()\n    {\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < columns; j++)\n            {\n\n                cout << \"    \" << values[i * columns + j];\n            }\n            cout << endl;\n        }\n    }\n~Matrix()\n    {\n        if (values != 0)\n            delete []values;\n    }\n};",
            1590059855.8622053,
            100,
            "# 答案正确"
        ],
        [
            "6.3 (C++)",
            "宋力舟",
            "#include<iostream>\n#include <iomanip>\n\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntemplate < typename T>\nclass Matrix\n{\n    public:\n    Matrix()\n    {\n        this->rows = 0;\n        this->columns = 0;\n        values.clear();\n    }\n    Matrix(int r, int c)\n    {\n        this->rows = r;\n        this->columns = c;\n        vector<T> temp ( r*c ,0);\n        values = temp;\n    }\n    Matrix(int r, int c, vector <T>  v)\n    {\n        this->rows = r;\n        this->columns = c;\n        values = v;\n    }\n    Matrix(const Matrix& matrix2)\n    {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        this->values = matrix2.values; \n    }\n    T& get (int r, int c)\n    {\n        return values[(r-1) * columns + c - 1];\n    }\n    Matrix& operator= (const Matrix& matrix2)\n    {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        this->values = matrix2.values; \n        return *this;\n    }\n    Matrix operator * (const Matrix & matrix2) const\n    {\n        Matrix temp(rows,rows);\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < rows; j++)\n            {\n                T sum = 0;\n                for(int k = 0; k < columns; k++)\n                {\n                    sum += this->values[i * columns + k] * matrix2.values[k * rows + j];\n                }\n                temp.values[i*rows+j] = sum;\n            }\n        }\n        return temp;\n    }\n    Matrix  operator * ( T v ) const\n    {\n        vector<T> a (rows * columns, 0);\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = v * values[i];\n        }\n        Matrix temp (rows,columns,a);\n        return temp;\n    }\n    Matrix operator + (const Matrix & matrix2) const\n    {\n        vector <T> a(rows * columns , 0);\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = this->values[i] + matrix2.values[i];\n        }\n        Matrix temp(rows,columns,a);\n        return temp;\n    }\n    Matrix operator + (T v) const\n    {\n        vector <T> a(rows * columns , 0);\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = this->values[i] + v;\n        }\n        Matrix temp(rows,columns,a);\n        return temp;\n    }\n    Matrix operator - (const Matrix & matrix2) const\n    {\n        vector <T> a(rows * columns , 0);\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = this->values[i] - matrix2.values[i];\n        }\n        Matrix temp(rows,columns,a);\n        return temp;\n    }\n    Matrix operator - (T v) const\n    {\n        vector <T> a(rows * columns , 0);\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = this->values[i] - v;\n        }\n        Matrix temp(rows,columns,a);\n        return temp;\n    }\n    Matrix getRow(int r)\n\t{\n\t\tvector <T> a(columns, 0);\n\t\tfor(int i = 0; i < columns; i++)\n\t\t{\n\t\t\ta[i] = this->values[(r-1) * columns + i];\n\t\t}\n\t\treturn Matrix(1,columns,a);\n\t}\n\tMatrix getColumn(int c)\n\t{\n\t\tvector <T> a( 1 * rows, 0);\n\t\tfor (int i = 0; i < rows; i++)\n\t\t{\n\t\t\ta[i] = values[i*columns + c - 1];\n\t\t}\n\t\treturn Matrix(rows, 1, a);\n\t}\n    Matrix concatenateRows(Matrix & matrix1)\n    {\n        Matrix t (rows * 2 , columns);\n        for(int i = 0; i < rows * columns; ++i)\n        {\n            t.values[i] = values[i];\n        }\n        for(int i = 0; i < rows * columns; i++)\n        {\n            t.values[ rows * columns + i] = matrix1.values[i];\n        }\n        return t;\n    }\n    Matrix concatenateColumns(Matrix & matrix1)\n    {\n        Matrix t(rows, columns * 2);\n        for(int i = 0; i < rows; ++i)\n        {\n            for(int j = 0; j < columns; ++j)\n            {\n                t.values[i* columns * 2  +  j] = values [ i *columns +  j];\n            }\n        }\n        for(int i = 0; i < rows; ++i)\n        {\n            for(int j = columns; j < columns * 2; ++j)\n            {\n                t.values[i* columns * 2  +  j] = matrix1.values[i * columns +  j - columns];\n            }\n        }\n        return t;\n    }\n    Matrix reshape(int r , int c ) const\n    {\n        vector<T> a(r * c ,0);\n        int m = 0;\n        for (int i = 0; i < columns; i++)\n        {\n            for (int j = 0; j < rows; j++)\n            {\n                a[m++] = this->values[j * columns + i];\n            }\n        }\n        m = 0;\n        Matrix temp(r,c);\n        for (int i = 0; i < c; i++)\n        {\n            for(int j = 0; j < r; j++)\n            {\n                temp.values[j * c + i] = a[m++];\n            }\n        }\n        return temp;\n    }\n    Matrix transpose()\n    {\n        vector<T> a(rows * columns);\n        int m = 0;\n        for (int i = 0; i < columns; i++)\n        {\n            for (int j = 0; j < rows; j++)\n            {\n                a[m++] = this->values[j * columns + i];\n            }\n        }\n        Matrix temp(columns,rows,a);\n        return temp;\n    }\n    Matrix max()\n    {\n        if(rows == 1 && columns == 1)\n        return * this;\n        else if (rows == 1 && columns != 1)\n        {\n            T m = values[0];\n            for (int i = 0; i < rows * columns ; i++)\n            {\n                if (values[i] > m)\n                m = values[i];\n            }\n            Matrix temp(1,1);\n            temp.values[0] = m;\n            return temp;\n        }\n        else\n        {\n            T m;\n            vector<T> a;\n            for (int j = 0; j < columns; j++)\n            {\n                m = -999;\n                for (int i = 0; i < rows; i++)\n                {\n\t\t\t\t\t\t\tif (values[i * columns + j] > m)\n\t\t\t\t\t\t\t\tm = values[i * columns + j];\n                }\n                a.push_back(m);\n            }\n                Matrix temp (1,columns,a);\n                return temp;\n        }\n    }\n        \n    \n    Matrix min()\n    {\n        if(rows == 1 && columns == 1)\n        return * this;\n        else if (rows == 1 && columns != 1)\n        {\n            T m = values[0];\n            for (int i = 0; i < rows * columns ; i++)\n            {\n                if (values[i] < m)\n                m = values[i];\n            }\n            Matrix temp(1,1);\n            temp.values[0] = m;\n            return temp;\n        }\n        else\n        {\n            T m;\n            vector<T> a;\n            for (int j = 0; j < columns; j++)\n            {\n                m =  999;\n                for (int i = 0; i < rows; i++)\n                {\n\t\t\t\t\t\t\tif (values[i * columns + j] < m)\n\t\t\t\t\t\t\t\tm = values[i * columns + j];\n                }\n                a.push_back(m);\n            }\n                Matrix temp (1,columns,a);\n                return temp;\n        }\n    }\n    Matrix sum()\n    {\n        if (rows == 1 && columns == 1)\n        return * this;\n        else if (rows == 1 && columns != 1)\n        {\n            T m = 0;\n            for (int i = 0; i < columns; i++)\n            m += values[i];\n            Matrix temp(1,1);\n            temp.values[0] = m;\n            return temp;\n        }\n        else\n        {\n            vector <T> a(columns,0);\n            for (int j = 0; j < columns; j++)\n            {\n                for (int i = 0; i < rows; i++)\n                {\n                    a[j] += values[i * columns + j];\n                }\n            }\n            Matrix temp (1,columns,a);\n            return temp;\n        }\n        \n    }\n    void print()\n    {\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < columns; j++)\n            {\n\n                cout << \"    \" << values[i * columns + j];\n            }\n            cout << endl;\n        }\n    }\n    private:\n    int rows;\n    int columns;\n    vector <T> values;\n};",
            1590636265.4755728,
            100,
            "# 答案正确"
        ],
        [
            "6.2 (C++)",
            "宋力舟",
            "#include<iostream>\n#include <iomanip>\n#include<vector>\n#include<string>\nusing namespace std;\ntemplate < typename T>\nclass Matrix\n{\npublic:\n    Matrix()\n    {\n        rows = 0;\n        columns = 0;\n        values = 0;\n    }\n    Matrix(int r, int c)\n    {\n        this -> rows = r;\n        this -> columns = c;\n        values = new  T [rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            values[i] = T ();\n        }\n    }\n    Matrix(int r, int c, const  T *v)\n    {\n        this->rows = r;\n        this->columns = c;\n        values = new  T [r * c];\n        for (int i = 0; i < r * c; i++)\n        {\n            values[i] = v[i];\n        }\n    }\n    T& get (int r, int c)\n    {\n        return values[(r - 1) * columns + c - 1];\n    }\n    Matrix(const Matrix& matrix2)\n    {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        values = new T [rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            values[i] = matrix2.values[i];\n        }\n    }\n    Matrix& operator= (const Matrix& matrix2)\n    {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        if (values != 0)\n            delete []values;\n        values = new T [rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            values[i] = matrix2.values[i];\n        }\n        return *this;\n    }\n    Matrix operator + (const Matrix & matrix2) const\n    {\n        T* a = new T [this->rows * this->columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = this->values[i] + matrix2.values[i];\n        }\n        Matrix temp(rows,columns,a);\n        delete []a;\n        return temp;\n    }\n    Matrix operator + (double v) const\n    {\n        T * a = new T [this->rows * this->columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = this->values[i] + v;\n        }\n        Matrix temp(rows,columns,a);\n        delete []a;\n        return temp;\n    }\n    Matrix operator - (const Matrix & matrix2) const\n    {\n        T * a = new T [this->rows * this->columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = this->values[i] - matrix2.values[i];\n        }\n        Matrix temp(rows,columns,a);\n        delete []a;\n        return temp;\n    }\n    Matrix operator - (double v) const\n    {\n        T * a = new T [this->rows * this->columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = this->values[i] - v;\n        }\n        Matrix temp(rows,columns,a);\n        delete []a;\n        return temp;\n    }\n    Matrix operator * (const Matrix & matrix2) const\n    {\n        Matrix temp(rows,rows);\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < rows; j++)\n            {\n                T sum = 0;\n                for(int k = 0; k < columns; k++)\n                {\n                    sum += this->values[i * columns + k] * matrix2.values[k * rows + j];\n                }\n                temp.values[i*rows+j] = sum;\n            }\n        }\n        return temp;\n    }\n    Matrix  operator * (double v ) const\n    {\n        T * a = new T [rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = v * values[i];\n        }\n        Matrix temp (rows,columns,a);\n        delete []a;\n        return temp;\n    }\n    Matrix transpose()\n    {\n        T* a = new T [rows * columns];\n        int m = 0;\n        for (int i = 0; i < columns; i++)\n        {\n            for (int j = 0; j < rows; j++)\n            {\n                a[m++] = this->values[j * columns + i];\n            }\n        }\n        Matrix temp(columns,rows,a);\n        delete []a;\n        return temp;\n    }\n    Matrix concatenateRows(Matrix & matrix1)\n    {\n        Matrix t (rows * 2 , columns);\n        for(int i = 0; i < rows * columns; ++i)\n        {\n            t.values[i] = values[i];\n        }\n        for(int i = 0; i < rows * columns; i++)\n        {\n            t.values[ rows * columns + i] = matrix1.values[i];\n        }\n        return t;\n    }\n  \n    ~Matrix()\n    {\n        if (values != 0)\n            delete []values;\n    }\n    void print()\n    {\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < columns; j++)\n            {\n                cout << \"    \" << values[i * columns + j];\n            }\n            cout << endl;\n        }\n    }\nprivate:\n    int rows;\n    int columns;\n    T * values;\n};",
            1590636348.0868645,
            100,
            "# 答案正确"
        ],
        [
            "6.1 (C++)",
            "宋力舟",
            "#include<iostream>\n#include <iomanip>\n#include<vector>\n#include<string>\nusing namespace std;\ntemplate < typename T>\nclass Matrix\n{\npublic:\n    Matrix()\n    {\n        rows = 0;\n        columns = 0;\n        values = 0;\n    }\n    Matrix(int r, int c)\n    {\n        this -> rows = r;\n        this -> columns = c;\n        values = new  T [rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            values[i] = T ();\n        }\n    }\n    Matrix(int r, int c, const  T *v)\n    {\n        this->rows = r;\n        this->columns = c;\n        values = new  T [r * c];\n        for (int i = 0; i < r * c; i++)\n        {\n            values[i] = v[i];\n        }\n    }\n    T& get (int r, int c)\n    {\n        return values[(r - 1) * columns + c - 1];\n    }\n    Matrix(const Matrix& matrix2)\n    {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        values = new T [rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            values[i] = matrix2.values[i];\n        }\n    }\n    Matrix& operator= (const Matrix& matrix2)\n    {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        if (values != 0)\n            delete []values;\n        values = new T [rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            values[i] = matrix2.values[i];\n        }\n        return *this;\n    }\n    Matrix operator + (const Matrix & matrix2) const\n    {\n        T* a = new T [this->rows * this->columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = this->values[i] + matrix2.values[i];\n        }\n        Matrix temp(rows,columns,a);\n        delete []a;\n        return temp;\n    }\n    Matrix operator + (double v) const\n    {\n        T * a = new T [this->rows * this->columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = this->values[i] + v;\n        }\n        Matrix temp(rows,columns,a);\n        delete []a;\n        return temp;\n    }\n    Matrix operator - (const Matrix & matrix2) const\n    {\n        T * a = new T [this->rows * this->columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = this->values[i] - matrix2.values[i];\n        }\n        Matrix temp(rows,columns,a);\n        delete []a;\n        return temp;\n    }\n    Matrix operator - (double v) const\n    {\n        T * a = new T [this->rows * this->columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = this->values[i] - v;\n        }\n        Matrix temp(rows,columns,a);\n        delete []a;\n        return temp;\n    }\n    Matrix operator * (const Matrix & matrix2) const\n    {\n        Matrix temp(rows,rows);\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < rows; j++)\n            {\n                T sum = 0;\n                for(int k = 0; k < columns; k++)\n                {\n                    sum += this->values[i * columns + k] * matrix2.values[k * rows + j];\n                }\n                temp.values[i*rows+j] = sum;\n            }\n        }\n        return temp;\n    }\n    Matrix  operator * (double v ) const\n    {\n        T * a = new T [rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = v * values[i];\n        }\n        Matrix temp (rows,columns,a);\n        delete []a;\n        return temp;\n    }\n    Matrix transpose()\n    {\n        T* a = new T [rows * columns];\n        int m = 0;\n        for (int i = 0; i < columns; i++)\n        {\n            for (int j = 0; j < rows; j++)\n            {\n                a[m++] = this->values[j * columns + i];\n            }\n        }\n        Matrix temp(columns,rows,a);\n        delete []a;\n        return temp;\n    }\n    Matrix concatenateRows(Matrix & matrix1)\n    {\n        Matrix t (rows * 2 , columns);\n        for(int i = 0; i < rows * columns; ++i)\n        {\n            t.values[i] = values[i];\n        }\n        for(int i = 0; i < rows * columns; i++)\n        {\n            t.values[ rows * columns + i] = matrix1.values[i];\n        }\n        return t;\n    }\n    Matrix concatenateColumns(Matrix & matrix1)\n    {\n        Matrix t(rows, columns * 2);\n        for(int i = 0; i < rows; ++i)\n        {\n            for(int j = 0; j < columns; ++j)\n            {\n                t.values[i* columns * 2  +  j] = values [ i *columns +  j];\n            }\n        }\n        for(int i = 0; i < rows; ++i)\n        {\n            for(int j = columns; j < columns * 2; ++j)\n            {\n                t.values[i* columns * 2  +  j] = matrix1.values[i * columns +  j - columns];\n            }\n        }\n        return t;\n    }\n    Matrix getRow(int r)\n\t{\n\t\tT * a = new T [columns];\n\t\tfor(int i = 0; i < columns; i++)\n\t\t{\n\t\t\ta[i] = values[(r-1) * columns + i];\n        }\n\t\tMatrix temp (1,columns,a);\n        delete []a;\n\t\treturn temp;\n\t}\n\tMatrix getColumn(int c)\n\t{\n\t\tT * a = new T [columns];\n\t\tfor (int i = 0; i < rows; i++)\n\t\t{\n\t\t\ta[i] = values[i * columns + c - 1];\n\t\t}\n\t\tMatrix temp(rows,1,a);\n        delete []a;\n        return temp;\n\t}\n    Matrix reshape(int r , int c ) const\n    {\n        T * a = new T [r * c];\n        int m = 0;\n        for (int i = 0; i < columns; i++)\n        {\n            for (int j = 0; j < rows; j++)\n            {\n                a[m++] = this->values[j * columns + i];\n            }\n        }\n        m = 0;\n        Matrix temp(r,c);\n        for (int i = 0; i < c; i++)\n        {\n            for(int j = 0; j < r; j++)\n            {\n                temp.values[j * c + i] = a[m++];\n            }\n        }\n        delete []a;\n        return temp;\n    }\n    Matrix max()\n    {\n        if(rows == 1 && columns == 1)\n        return * this;\n        else if (rows == 1 && columns != 1)\n        {\n            T m = values[0];\n            for (int i = 0; i < rows * columns ; i++)\n            {\n                if (values[i] > m)\n                m = values[i];\n            }\n            Matrix temp(1,1);\n            temp.values[0] = m;\n            return temp;\n        }\n        else\n        {\n            T m = values[0];\n            int index = 0;\n            for (int i = 0; i < rows; i++)\n            {\n                for (int j = 0; j < columns; j++)\n                {\n                    if (values[ i * columns + j] > m )\n                    {\n                        m = values[ i * columns + j];\n                        index = i;\n                    }\n                }\n                T * a = new T[columns];\n                for(int i = 0; i < columns; i++)\n                {\n                    a[i] = values[ index * columns + i];\n                }\n                Matrix temp (1,columns,a);\n                return temp;\n            }\n        }\n    }\n    Matrix min()\n    {\n        if(rows == 1 && columns == 1)\n        return * this;\n        else if (rows == 1 && columns != 1)\n        {\n            T m = values[0];\n            for (int i = 0; i < rows * columns ; i++)\n            {\n                if (values[i] < m)\n                m = values[i];\n            }\n            Matrix temp(1,1);\n            temp.values[0] = m;\n            return temp;\n        }\n        else\n        {\n            T m = values[0];\n            int index = 0;\n            for (int i = 0; i < rows; i++)\n            {\n                for (int j = 0; j < columns; j++)\n                {\n                    if (values[ i * columns + j] < m )\n                    {\n                        m = values[ i * columns + j];\n                        index = i;\n                    }\n                }\n                T * a = new T[columns];\n                for(int i = 0; i < columns; i++)\n                {\n                    a[i] = values[ index * columns + i];\n                }\n                Matrix temp (1,columns,a);\n                return temp;\n            }\n        }\n    }\n    Matrix sum()\n    {\n        if (rows == 1 && columns == 1)\n        return * this;\n        else if (rows == 1 && columns != 1)\n        {\n            T m = 0;\n            for (int i = 0; i < columns; i++)\n            m += values[i];\n            Matrix temp(1,1);\n            temp.values[0] = m;\n            return temp;\n        }\n        else\n        {\n            T * a = new T[columns];\n            for (int j = 0; j < columns; j++)\n            {\n                a[j] = 0;\n                for (int i = 0; i < rows; i++)\n                {\n                    a[j] += values[i * columns + j];\n                }\n            }\n            Matrix temp (1,columns,a);\n            return temp;\n        }\n        \n    }\n    ~Matrix()\n    {\n        if (values != 0)\n            delete []values;\n    }\n    void print()\n    {\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < columns; j++)\n            {\n                cout << \"    \" << values[i * columns + j];\n            }\n            cout << endl;\n        }\n    }\nprivate:\n    int rows;\n    int columns;\n    T * values;\n};",
            1590636426.6841054,
            100,
            "# 答案正确"
        ],
        [
            "7.2 (C++)",
            "宋力舟",
            "#include<string>\n#include<vector>\nusing namespace std;\nvector<string> split( const string &line, const string & delimiter = \" \")\n{\n    vector<string> ans;\n    int st = 0;\n    while(st < line.size())\n    {\n        int end = line.find(delimiter, st);\n        if (end == st)\n            st += delimiter.size();\n        else\n        {\n            if (end == -1)\n            {\n                ans.push_back(line.substr(st));\n                break;\n            }\n            ans.push_back(line.substr(st, end - st));\n            st = end + delimiter.size();\n        }\n        \n    }\n    return ans;\n}",
            1591241159.8726482,
            100,
            "# 答案正确"
        ],
        [
            "7.1 (C++)",
            "宋力舟",
            "#include <cmath>\nclass Triangle : public GeometricObject\n{\n    public:\n    Triangle()\n    {\n        side1 = side2 = side3 = 1.0;\n      \n    }\n    Triangle(double a, double b, double c)\n    {\n        side1 = a;\n        side2 = b;\n        side3 = c;\n      \n    }\n    double& getSide1()\n    {\n        return side1;\n    }\n    double& getSide2()\n    {\n        return side2;\n    }\n    double& getSide3()\n    {\n        return side3;\n    }\n    double getArea()\n    { \n        double s = this->getPerimeter() / 2;\n        double area = sqrt(s * (s - side1) * (s - side2) * (s - side3) );\n        return area;\n    }\n    double getPerimeter()\n    {\n        return side1 + side2 + side3;\n    }\n\n\n    private:\n    double side1;\n    double side2;\n    double side3;\n};\n\n",
            1591241193.1565053,
            100,
            "# 答案正确"
        ],
        [
            "7.3 (C++)",
            "宋力舟",
            "\ntemplate <typename T>\nvector<T> map2(const vector<T> & x,  const T data , T(*map2_func)(const T &, const T &) )\n{\n    vector<T> res;\n    for (int i = 0; i < x.size(); i++)\n    {\n        res.push_back(map2_func(x[i], data));\n    }\n    return res;\n}\ntemplate <typename T>\nvector<T> map2(const vector<T> & x,  const vector<T> & y, T(*map2_func)(const T &, const T &) )\n{\n    vector<T> res;\n    for (int i = 0; i < x.size(); i++)\n    {\n        res.push_back(map2_func(x[i], y[i]));\n    }\n    return res;\n}\n",
            1591241263.8934073,
            100,
            "# 答案正确"
        ],
        [
            "8.5 (C++)",
            "宋力舟",
            "class Point3D : public Point2D \n{\n    public:\n    Point3D()\n    {\n        setX(0);\n        setY(0);\n        setZ(0);\n    }\n    Point3D(double x, double y, double z)\n    {\n        setX(x);\n        setY(y);\n        setZ(z);\n    }\n    void setZ(double z) \n    {\n\t\tthis->z = z;\n\t}\n    double getZ() \n    {\n\t\treturn z;\n\t}\n    virtual double distance(Point2D & point2) \n    {\n        Point3D& a = static_cast <Point3D&>(point2);\n\t\tdouble dx = getX() - a.getX();\n\t\tdouble dy = getY() - a.getY();\n        double dz = getZ() - a.getZ();\n\t\treturn sqrt(dx * dx + dy * dy + dz * dz);\n\t}\n    private:\n    double z;\n};",
            1591845153.4456294,
            100,
            "# 答案正确"
        ],
        [
            "8.1 (C++)",
            "宋力舟",
            "class Full : public Matrix\n{\n    public:\n    Full (int r, int c)\n    {\n        this->rows = r;\n        this->columns = c;\n        values = new double [rows * columns];\n        for(int i = 0; i < rows * columns ; i++)\n        values[i] = 0;\n    }\n    Full (int r, int c, double values[])\n    {\n        this->rows = r;\n        this->columns = c;\n        this-> values = new double[rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        this->values[i] = values[i]; \n    }\n    Full(const Matrix & matrix2)\n    {\n        this->rows = matrix2.size(1);\n        this->columns = matrix2.size(2);\n        this->values = new double[this->rows * this-> columns];\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < columns; j++)\n            {\n                values[i * columns + j] = matrix2.get(i,j);\n            }\n        }\n    }\n    ~Full()\n    {\n        if(values != 0)\n        delete [] values;\n    }\n    virtual int size(int dimension) const\n    {\n        if (dimension == 1)\n            return rows;\n        else\n            return columns;\n    }\n\tvirtual void set(int r, int c, double v)\n    {\n        values[r * columns + c ] = v;\n    }\n\tvirtual double get(int r, int c) const \n\t{\n        return values[r * columns + c] ;\n    }\n\tvirtual void print() const\n    {\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < columns; j++)\n            {\n                cout <<\"    \" <<values[i*columns + j] ;\n            }\n            cout << endl;\n        }\n    }\n\tvirtual Matrix&  operator = (const Matrix & matrix2)\n    {\n        this->rows = matrix2.size(1);\n        this->columns = matrix2.size(2);\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j <columns; j++)\n            {\n                set(i,j,matrix2.get(i,j));\n            }\n        }\n        return *this;\n    }\n    private:\n    int rows;\n    int columns;\n    double * values;\n};",
            1591871481.5083468,
            100,
            "# 答案正确"
        ],
        [
            "8.3 (C++)",
            "宋力舟",
            "#include <iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nbool comp(const Entry& a, const Entry& b)\n{\n    if (a.row == b.row)\n    {\n        return a.column < b.column;\n    }\n    else\n    {\n        return a.row < b.row;\n    }\n}\nclass Sparse : public Matrix\n{\npublic:\n    Sparse(int r, int c)\n    {\n        this->rows = r;\n        this->columns = c ;\n        values.clear();\n    }\n  Sparse  operator+ (Sparse& sparse2)\n    {\n        Sparse temp(this->rows, this->columns);\n        temp.values = this->values;\n\n        for (int i = 0; i < sparse2.values.size();i++)\n        {\n            Entry t = sparse2.values[i];\n            double v = temp.get(t.row, t.column);\n            temp.set(t.row,t.column, sparse2.get(t.row,t.column) + v);\n        }\n        return temp;\n    }\n\n    int findIndex(int r, int c) const\n    {\n        for (int i = 0; i < values.size(); i++)\n        {\n            if (values[i].row == r && values[i].column == c)\n            {\n                return i;\n            }\n        }\n        return -1;\n    }\n    virtual int size(int dimension) const\n    {\n        if (dimension == 1)\n            return rows;\n        else\n        {\n            return columns;\n        }\n    }\n\n\n    virtual void set(int r, int c, double v)\n    {\n        int index = findIndex(r, c);\n        if (index != -1)\n        {\n            if (v == 0)\n            {\n                values.erase(values.begin() + index);\n            }\n            else\n            {\n                values[index].value = v;\n            }\n        }\n        else\n        {\n            if (v != 0)\n            {\n                Entry t;\n                t.row = r;\n                t.column = c;\n                t.value = v;\n                values.push_back(t);\n            }\n        }\n    }\n\n    virtual double get(int r, int c) const\n    {\n        int index = findIndex(r, c);\n        if (index == -1)\n            return 0;\n        else\n        {\n            return values[index].value;\n        }\n    }\n\n    virtual void print()\n    {\n\n        sort(values.begin(), values.end(),comp);\n        for (int i = 0; i < values.size(); i++)\n        {\n            cout << \"(\" << values[i].row << \",\" << values[i].column << \",\" << values[i].value << \")\" << endl;\n        }\n    }\n\nprivate:\n    int rows;\n    int columns;\n    vector<Entry> values;\n};\n",
            1591871500.3696468,
            100,
            "# 答案正确"
        ],
        [
            "8.4 (C++)",
            "宋力舟",
            "#include <iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nbool comp(const Entry& a, const Entry& b)\n{\n    if (a.row == b.row)\n    {\n        return a.column < b.column;\n    }\n    else\n    {\n        return a.row < b.row;\n    }\n}\nclass Sparse : public Matrix\n{\npublic:\n    Sparse(int r, int c)\n    {\n        this->rows = r;\n        this->columns = c ;\n        values.clear();\n    }\n\n  Sparse  operator+ (Sparse& sparse2)\n    {\n        Sparse temp(this->rows, this->columns);\n        temp.values = this->values;\n\n        for (int i = 0; i < sparse2.values.size();i++)\n        {\n            Entry t = sparse2.values[i];\n            double v = temp.get(t.row, t.column);\n            temp.set(t.row,t.column,t.value+v);\n        }\n        return temp;\n    }\n\n    int findIndex(int r, int c) const\n    {\n        for (int i = 0; i < values.size(); i++)\n        {\n            if (values[i].row == r && values[i].column == c)\n            {\n                return i;\n            }\n        }\n        return -1;\n    }\n    virtual int size(int dimension) const\n    {\n        if (dimension == 1)\n            return rows;\n        else\n        {\n            return columns;\n        }\n    }\n\n\n    virtual void set(int r, int c, double v)\n    {\n        int index = findIndex(r, c);\n        if (index != -1)\n        {\n            if (v == 0)\n            {\n                values.erase(values.begin() + index);\n            }\n            else\n            {\n                values[index].value = v;\n            }\n        }\n        else\n        {\n            if (v != 0)\n            {\n                Entry t;\n                t.row = r;\n                t.column = c;\n                t.value = v;\n                values.push_back(t);\n            }\n        }\n    }\n\n    virtual double get(int r, int c) const\n    {\n        int index = findIndex(r, c);\n        if (index == -1)\n            return 0;\n        else\n        {\n            return values[index].value;\n        }\n    }\nSparse  operator * (Sparse & sparse2)\n    {\n        Sparse temp(this->rows, sparse2.columns);\n        for(int i = 0; i < values.size(); i++)\n        {\n            for(int j = 0; j < sparse2.values.size(); j++)\n            {\n                Entry a = this->values[i];\n                Entry b = sparse2.values[j];\n                if(a.column == b.row)\n                {\n                    double t = a.value * b.value;\n                    temp.set(a.row,b.column, temp.get(a.row,b.column) + t);\n                }\n            }\n        }\n        return temp;\n    }\n    virtual void print()\n    {\n\n        sort(values.begin(), values.end(),comp);\n        for (int i = 0; i < values.size(); i++)\n        {\n            cout << \"(\" << values[i].row << \",\" << values[i].column << \",\" << values[i].value << \")\" << endl;\n        }\n    }\n\nprivate:\n    int rows;\n    int columns;\n    vector<Entry> values;\n};",
            1591871516.626238,
            100,
            "# 答案正确"
        ],
        [
            "8.6 (C++)",
            "宋力舟",
            "#include <iostream>\nclass MyTensor : public Tensor<double>\n{\n    public:\n    MyTensor( vector<int> sizes ): Tensor<double> (sizes) \n    {\n        int total = 1;\n        for (int i = 0; i < sizes.size(); i++)\n        total *= sizes[i];\n        da = new double[total];\n    }\n    \n    virtual double & get(const vector<int> & indexes)\n    {\n        if( sizes.size() == 1)\n        return da[indexes[0]];\n        if(sizes.size() ==2)\n        {\n            return da[indexes[0] * sizes[1] + indexes[1]];\n        }\n        if(sizes.size()  == 3)\n        {\n            return da[ indexes[0] * indexes[1] * sizes[2] + indexes[1] * sizes[2] + indexes[2]   ];\n        }\n        if (sizes.size()  == 4)\n        {\n            return da[ indexes[0] * indexes[1] * indexes[2] * sizes[3] + indexes[1] * indexes[2] * sizes[3] + indexes[2] * sizes[3] + indexes[3] ];  \n        }\n\n    }\n    ~MyTensor()\n    {\n        if(da != nullptr)\n        delete [] da;\n    }\n    private:\n    double * da;\n};",
            1592451119.4244902,
            100,
            "# 答案正确"
        ],
        [
            "9.1 (C++)",
            "宋力舟",
            "#include <iostream>\nusing namespace std;\nclass Circle\n{\n    friend bool operator<(const Circle&a, const Circle&b);\n    friend bool operator<=(const Circle&a, const Circle&b);\n    friend bool operator==(const Circle&a, const Circle&b);\n    friend bool operator!=(const Circle&a, const Circle&b);\n    friend bool operator>(const Circle&a, const Circle&b);\n    friend bool operator>=(const Circle&a, const Circle&b);\n    public:\n        Circle(double r) : radius(r) {}\n    private:\n        double radius;\n};\nbool operator<(const Circle&a, const Circle&b)\n{\n    return a.radius < b.radius;\n}\nbool operator<=(const Circle&a, const Circle&b)\n{\n    return a.radius <= b.radius;\n}\nbool operator==(const Circle&a, const Circle&b)\n{\n    return a.radius == b.radius;\n}\nbool operator!=(const Circle&a, const Circle&b)\n{\n    return !(a == b);\n}\nbool operator>(const Circle&a, const Circle&b)\n{\n    return !(a<=b);\n}\nbool operator>=(const Circle&a, const Circle&b)\n{\n    return !(a<b);\n}",
            1593041160.606071,
            100,
            "# 答案正确"
        ],
        [
            "9.2 (C++)",
            "宋力舟",
            "class I\n{\n\tpublic:\n    I(int i1 = -1, int i2=-1, int i3=-1, int i4=-1)\n    {\n\t\tif(i1 != -1)\n            indexes.push_back(i1);\n        if (i2 != -1)\n            indexes.push_back(i2);\n        if (i3 != -1)\n            indexes.push_back(i3);\n        if (i4 != -1)\n            indexes.push_back(i4);\n    };\n\t\n    operator vector<int> ()\n    {\n        return indexes;\n    }\n\n\tprivate:\n    vector<int> indexes;\n};",
            1593041174.8341668,
            100,
            "# 答案正确"
        ],
        [
            "9.3 (C++)",
            "宋力舟",
            "class Complex\n{\n    friend Complex operator+(Complex & a,Complex &b);\n    friend Complex operator+(Complex & a,int b);\n    friend Complex operator+(int a,Complex & b);\n\n    friend Complex operator-(Complex & a,Complex &b);\n    friend Complex operator-(Complex & a,int b);\n    friend Complex operator-(int a,Complex & b);\n\n    friend Complex operator*(Complex & a,Complex &b);\n    friend Complex operator/(Complex & a,Complex &b);\n    \n    public:\n    Complex(double real, double imag) : m_real(real), m_imag(imag) {}\n    Complex& operator*=(Complex & a);\n    Complex& operator/=(Complex & a);\n    Complex& operator+=(Complex & a);\n    Complex& operator-=(Complex & a);\n    bool operator==(Complex & a);\n    bool operator!=(Complex & a);\n    double real();\n    double imag();\n    private:\n    double m_real;\n    double m_imag;\n};\nComplex& Complex :: operator*=(Complex & a)\n{\n    Complex t = *this * a;\n    *this = t;\n    return *this;\n}\nComplex& Complex :: operator/=(Complex & a)\n{\n    Complex t = *this / a;\n    *this = t;\n    return *this;\n}\nComplex& Complex :: operator+=(Complex & a)\n{\n    Complex t = *this + a;\n    *this = t;\n    return *this;\n}\nComplex& Complex :: operator-=(Complex & a)\n{\n    Complex t = *this - a;\n    *this = t;\n    return *this;\n}\nbool Complex :: operator==(Complex & a)\n{\n    if(m_real == a.real() && m_imag == a.imag())\n    return true;\n    else\n    {\n        return false;\n    }\n    \n}\nbool Complex :: operator!=(Complex & a)\n{\n    return !(*this == a);\n}\n\ndouble Complex ::  real()\n{\n    return m_real;\n}\ndouble Complex ::  imag()\n{\n    return m_imag;\n}\nComplex operator+(Complex & a,Complex &b)\n{\n    return Complex(a.real() + b.real(), a.imag() + b.imag());\n}\nComplex operator+(Complex & a,int b)\n{\n    return Complex(a.real() +b, a.imag());\n}\nComplex operator+(int a,Complex & b)\n{\n    return Complex(a + b.real(), b.imag());\n}\nComplex operator-(Complex & a,Complex &b)\n{\n    return Complex(a.real() - b.real(), a.imag() - b.imag());\n}\nComplex operator-(Complex & a,int b)\n{\n    return Complex(a.real() - b, a.imag());\n}\nComplex operator-(int a,Complex & b)\n{\n    return Complex(a - b.real(), -b.imag());\n}\nComplex operator*(Complex & a,Complex &b)\n{\n    double r = a.real() * b.real() - a.imag() * b.imag();\n    double i = a.real() * b.imag() + a.imag() * b.real();\n    return Complex(r,i);\n}\nComplex operator/(Complex & a,Complex &b)\n{\n    double r =(a.real() * b.real() + a.imag() * b.imag() ) / (b.real() * b.real() + b.imag() * b.imag());\n    double i = ( a.imag() * b.real() - a.real() * b.imag() ) / (b.real() * b.real() + b.imag() * b.imag());\n    return Complex(r,i);\n}",
            1593041193.277448,
            100,
            "# 答案正确"
        ],
        [
            "9.4 (C++)",
            "宋力舟",
            "#include <cmath>\nclass Complex\n{\n    friend Complex operator+(Complex & a,Complex &b);\n    friend Complex operator+(Complex & a,int b);\n    friend Complex operator+(int a,Complex & b);\n    \n    friend Complex operator-(Complex & a,Complex &b);\n    friend Complex operator-(Complex & a,int b);\n    friend Complex operator-(int a,Complex & b);\n\n    friend Complex operator*(Complex & a,Complex &b);\n    friend Complex operator/(Complex & a,Complex &b);\n    friend ostream& operator<<(ostream &out, Complex & a);\n    friend istream& operator>>(istream &in, Complex & a);\n\n    public:\n    Complex(double real, double imag) : m_real(real), m_imag(imag) {}\n    Complex():m_real(0),m_imag(0){}\n\n    Complex& operator*=(Complex & a);\n    Complex& operator/=(Complex & a);\n    Complex& operator+=(Complex & a);\n    Complex& operator-=(Complex & a);\n    Complex& operator++();\n    Complex  operator++(int);\n    bool operator==(Complex & a);\n    bool operator!=(Complex & a);\n    operator double();\n    double real();\n    double imag();\n    private:\n    double m_real;\n    double m_imag;\n};\nComplex& Complex :: operator*=(Complex & a)\n{\n    Complex t = *this * a;\n    *this = t;\n    return *this;\n}\nComplex& Complex :: operator/=(Complex & a)\n{\n    Complex t = *this / a;\n    *this = t;\n    return *this;\n}\nComplex& Complex :: operator+=(Complex & a)\n{\n    Complex t = *this + a;\n    *this = t;\n    return *this;\n}\nComplex& Complex :: operator-=(Complex & a)\n{\n    Complex t = *this - a;\n    *this = t;\n    return *this;\n}\nbool Complex :: operator==(Complex & a)\n{\n    if(m_real == a.real() && m_imag == a.imag())\n    return true;\n    else\n    {\n        return false;\n    }\n    \n}\nbool Complex :: operator!=(Complex & a)\n{\n    return !(*this == a);\n}\nComplex& Complex :: operator++() // 前置\n{\n    this->m_real++;\n    return *this;\n}\nComplex Complex :: operator++(int)\n{\n    Complex temp = *this;\n    this->m_real++;\n    return temp;\n}\ndouble Complex ::  real()\n{\n    return m_real;\n}\ndouble Complex ::  imag()\n{\n    return m_imag;\n}\nComplex :: operator double()\n{\n    return m_real;\n}\nComplex operator+(Complex & a,Complex &b)\n{\n    return Complex(a.real() + b.real(), a.imag() + b.imag());\n}\nComplex operator+(Complex & a,int b)\n{\n    return Complex(a.real() +b, a.imag());\n}\nComplex operator+(int a,Complex & b)\n{\n    return Complex(a + b.real(), b.imag());\n}\nComplex operator-(Complex & a,Complex &b)\n{\n    return Complex(a.real() - b.real(), a.imag() - b.imag());\n}\nComplex operator-(Complex & a,int b)\n{\n    return Complex(a.real() - b, a.imag());\n}\nComplex operator-(int a,Complex & b)\n{\n    return Complex(a - b.real(), -b.imag());\n}\nComplex operator*(Complex & a,Complex &b)\n{\n    double r = a.real() * b.real() - a.imag() * b.imag();\n    double i = a.real() * b.imag() + a.imag() * b.real();\n    return Complex(r,i);\n}\nComplex operator/(Complex & a,Complex &b)\n{\n    double r =(a.real() * b.real() + a.imag() * b.imag() ) / (b.real() * b.real() + b.imag() * b.imag());\n    double i = ( a.imag() * b.real() - a.real() * b.imag() ) / (b.real() * b.real() + b.imag() * b.imag());\n    return Complex(r,i);\n}\n   ostream & operator << (ostream & out, Complex & c)\n    {\n        out << c.real() << \" + \" << c.imag() << \" i\";\n        return out;\n    }\nistream& operator>> (istream &in, Complex & a)\n{\n    double r,i;\n    in >> a.m_real;\n\tin >> a.m_imag;\n    return in;\n}",
            1593041224.1902764,
            100,
            "# 答案正确"
        ],
        [
            "9.5 (C++)",
            "宋力舟",
            "#include <iostream>\nusing namespace std;\nclass Complex\n{\npublic:\n    Complex(): m_real(0), m_imag(0) {}\n    Complex(double r, double i): m_real(r),  m_imag (i) {}\n\n\n    friend istream & operator >> (istream & in, Complex & c);\n   \n    friend ostream & operator << (ostream & out, const Complex & c);\n    \n\n    double real()\n    {\n        return m_real;\n    }\n\n    double imag()\n    {\n        return m_imag;\n    }\n\n    Complex operator ++(int)\n    {\n        Complex t = *this;\n        m_real++;\n        return t;\n    }\n\n    Complex & operator ++()\n    {\n        m_real++;\n        return *this;\n    }\n\n    operator double ()\n    {\n        return m_real;\n    }\n\nprivate:\n    double m_real;\n    double  m_imag;\n};\n istream & operator >> (istream & in, Complex & c)\n    {\n        \n        in >> c.m_real >> c.m_imag;\n        return in;\n    }\n\n  ostream & operator << (ostream & out, const Complex & c)\n    {\n        out << c.m_real << \" + \" << c.m_imag << \" i\";\n        return out;\n    }",
            1593041300.1412263,
            100,
            "# 答案正确"
        ],
        [
            "9.6 (C++)",
            "宋力舟",
            "class Tensor\n{\n    public:\n    Tensor(int a = -1, int b = -1, int c = -1, int d = -1)\n    {\n        int size = 1;\n        if(a != -1)\n        {\n            sizes.push_back(a);\n            size *= a;\n        }\n        \n        if(b != -1)\n        {\n            sizes.push_back(b);\n            size *= b; \n        }\n        \n        if(c != -1)\n        {\n            sizes.push_back(c);\n            size *= c; \n        }\n        \n        if(d != -1)\n        {\n            sizes.push_back(d);\n            size *= d; \n        }\n        data.resize(size);\n    }\n    double& operator()(int a , int b , int c , int d = 0)\n    {\n        int index = 0;\n        if(sizes.size() == 1)\n        {\n            index = a;\n        }\n        if(sizes.size() == 2)\n        {\n            index = a * sizes[1] + b;\n        }\n        if(sizes.size() == 3)\n        {\n            index = a * sizes[1]* sizes[2] + b * sizes[2] + c;\n        }\n        if(index == 4)\n        {\n            index = a * sizes[1]* sizes[2] * sizes[3] + b *sizes[2] * sizes[3] + c * sizes[3] + d;\n        }\n        return data[index];\n    }\n    private:\n    vector <double> data;\n    vector <int> sizes;\n};\n",
            1593041330.6661081,
            100,
            "# 答案正确"
        ],
        [
            "9.7 (C++)",
            "宋力舟",
            "class Tensor\n{\n    friend istream & operator>>(istream &in, Tensor &A);\n    friend ostream & operator<<(ostream &out, Tensor A);\n    public:\n    Tensor()\n    {\n        total = 0;\n        dimention = 0;\n    }\n    private:\n    vector<double> data;\n    vector<int>sizes;\n    int total;\n    int dimention;\n};\nistream & operator>>(istream &in, Tensor &A)\n{\n    in >> A.dimention;\n    int total = 1;\n    for(int i = 0; i < A.dimention; i++)\n    {\n        int t;\n        in >> t;\n        total *= t; \n        A.sizes.push_back(t);\n    }\n    A.total = total;\n    for(int i = 0; i < total; i++)\n    {\n        double t;\n        in >> t;\n        A.data.push_back(t);\n    }\n    return in;\n}\nostream & operator<<(ostream &out, Tensor A)\n{\n        out << A.dimention << endl;\n        if(A.dimention == 3 )\n\t\t{\n\t\t\tout << A.sizes [0] << \" \" << A.sizes[1] <<\" \"<<A.sizes[2] << endl << endl;\n\t\t\t\tfor(int i = 0; i < A.sizes[0]; i++)\n                {\n\t\t\t\t\tfor (int j = 0; j < A.sizes[1]; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int k = 0; k < A.sizes[2]; k++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint index = i * A.sizes[1] * A.sizes[2] + j * A.sizes[2] + k;\n\t\t\t\t\t\t\tout << A.data[index] << \" \";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tout << endl;\n\t\t\t\t\t}\n                    out << endl;\n                }\n\t\t}\n\t\tif(A.dimention == 4 )\n\t\t{\n            out << A.sizes [0] << \" \" << A.sizes[1] <<\" \"<<A.sizes[2] <<\" \"<< A.sizes[3] << endl << endl ;\n            for(int i = 0; i < A.sizes[0] * A.sizes[1]; i++)\n                {\n\t\t\t\t\tfor (int j = 0; j < A.sizes[2]; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int k = 0; k < A.sizes[3]; k++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint index =  i * A.sizes[2] * A.sizes[3] + j * A.sizes[3] + k; \n\t\t\t\t\t\t\tout << A.data[index] << \" \";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tout << endl;\n\t\t\t\t\t}\n                    out << endl;\n                }\n\t\t}\n    return out;\n}\n",
            1593041351.5621188,
            100,
            "# 答案正确"
        ],
        [
            "10.2 (C++)",
            "宋力舟",
            "catch( NonPositiveValueException & a){\n cout << \"caught: NonPositiveValueException\"<<endl;\n}\n\ncatch(out_of_range & a){\n cout << \"caught: out_of_range\"<<endl;\n}",
            1593660291.8821516,
            100,
            "# 答案正确"
        ],
        [
            "10.1 (C++)",
            "宋力舟",
            "#include <iostream>\n#include<stdexcept>\n#include <vector>\nusing namespace std;\n\n\nclass MatrixSizesDoNotMatchException{\n\tpublic:\n\t\tint a;\n\t\n\tMatrixSizesDoNotMatchException(int x){\n\t\ta=x;\n\t}\n};\n\ndouble  Matrix::get(int row, int column) const{\n\ttry {  \n\t\tint m= (row-1)*(this->columns)+(column-1);\n\t   double t= this->elements.at(m);\n\t   \n\t\treturn t;\n\t   \n\t   }catch (out_of_range & ex) {\n\t\t\tcout << \"caught: out_of_range\" << endl;\n\t\t}\n\t\n}\n\nvoid Matrix::set(int row, int column, double value){\nint m= (row-1)*(this->columns)+(column-1);\n\tthis->elements[m]=value;\n}\n\n Matrix Matrix::operator+ (const Matrix & matrix2) const{\n\ttry{if(this->rows!=matrix2.rows||this->columns!=matrix2.columns){\n\t\tMatrixSizesDoNotMatchException x(1);\n\t\tthrow  x;\n\t}\n\tMatrix a(rows,columns);\n\tfor (int i = 0; i < rows; ++ i){\n\t\tfor(int j=0 ; j< columns; j++){\n\t\t\tint m= i*columns+j;\n\t\t\ta.elements[m]=this->elements[m]+matrix2.elements[m];\n\t\t}\n\t} \n\treturn a;}\n\t catch (MatrixSizesDoNotMatchException & ex) {\n\t\t\tcout << \"caught: MatrixSizesDoNotMatchException\" << endl;\n\t\t}\n}",
            1593660559.962265,
            100,
            "# 答案正确"
        ],
        [
            "15.1 (C++)",
            "宋力舟",
            "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\nclass Table\n{\n    friend ostream & operator << (ostream & out, const Table & table);\n    \n\t  private:\n \t   int row_size;\n      vector< vector <string> > tab;\n      vector<string> col;\n\t\n    public:\n  \t Table()\n    {\n        tab.resize(1);\n     \t\t\n    }\n    void addCol(string s)\n    {\n        col.push_back(s); \n    }\n    vector<string>& operator[](int n)\n    {  \n\t \t  \n        if (tab.size() == n + 1 ) \n\t\t{\n\t\t\tvector<string> temp;\n\t\t\ttab.push_back(temp);\n\t\t}\n        return tab[n];\n    }\n    string json()const\n    {\n        string s = \"{\\n    headers: [\";\n        for(int i = 0; i < col.size(); i++)\n        {\n            s = s + (\"'\" + col[i]+ \"'\" + \",\");\n        }\n        s=s+\"],\\n\";\n        s=s+\"    rows: [\\n\";\n       for(int i = 0 ; i< tab.size()-1; i++)\n        {\n            string a = \"       [\";\n            for (int j = 0; j < tab[i].size(); j++)\n            {\n                a = a + (\"'\" + tab[i][j] + \"',\"); \n            }\n            a=a+\"],\\n\";\n            s =s + a;\n        }\n        s = s + \"    ],\\n}\"; \n        return s; \n    }\n    \n};",
            1594220752.9766932,
            100,
            "# 答案正确"
        ],
        [
            "2020-07-09 LAB",
            "宋力舟",
            "#include <iostream>\n#include <string>\nusing namespace std; \n\nclass Integer{\n\tpublic:\n\tstatic int q;\n\tint data;\n\n\t Integer(int a){data=a;\n\t\t\t\t   }\n\t Integer(){data=0;};\n\n\t\n\t \n\tstatic void increase_all(int a);\n\tstatic void increase_all(Integer a);\n\n};\nint Integer::q=0;\nistream& operator >>(istream &is, Integer &c){\n\t\tis>>c.data;\n\t\treturn is;\n\t}\n\tostream& operator <<(ostream &os, Integer &c){\n\t\tc.data += Integer::q;\n\t\tos<<c.data;\n\t\treturn os;\n\t}\n\n\nvoid Integer::increase_all(int a){\n\tq=a;\n\t\n}\nvoid Integer::increase_all(Integer a){\n\t\tq=a.data;\n\t}\n\n\t",
            1594265674.6142337,
            100,
            "# 答案正确"
        ],
        [
            "A.1 (C++)",
            "宋力舟",
            "    void addFirst(const E & e)\n    {\n        Node<E> * node = new Node<E>;\n        node -> element = e;\n        node -> update_prev_and_next_node(nullptr, head);\n        if (head != nullptr) head -> update_prev_node(nullptr, node);\n        head = node;\n        if (tail == nullptr) tail = node;\n        ++_size;\n    }\n\n    void addLast(const E & e)\n    {\n        Node<E> * node = new Node<E>;\n        node -> element = e;\n        node -> update_prev_and_next_node(tail, nullptr);\n        if (tail != nullptr) tail -> update_next_node(nullptr, node);\n        tail = node;\n        if (head == nullptr) head = node;\n        ++_size;\n    }\n\n  void remove (int index) {\n\t\t\n\t\tif (index < 0 || index >= _size)\n        throw NotSuchElementException();\n\n        Node<E> * node =  get_node(index);\n        Node<E> * nextOfnode;\n\t\t\tNode<E> * preOfnode;\n        if(index == _size - 1)\n        {\n\t\t\tnextOfnode = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnextOfnode = get_node( index + 1 );\n\t\t}\n        if (index == 0)\n\t\t{\n\t\t\tpreOfnode = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpreOfnode = node->prev_node(nextOfnode);\n\t\t}\n        if(preOfnode != 0)\n        {\n            preOfnode->update_next_node(node,nextOfnode );\n        }\n        if(nextOfnode != 0)\n        {\n            nextOfnode->update_prev_node(node, preOfnode);\n        }\n        if(index == 0)\n        {\n            head = nextOfnode;\n        }\n        if(index == _size - 1)\n        {\n            tail = preOfnode;\n        }\n        delete node;\n\t\t-- _size;\n\t}\n\n\n    void removeFirst()\n    {\n        remove(0);\n    }\n\n    void removeLast()\n    {\n        remove(_size - 1);\n    }\n\n   void removeFirstOccurrence(const E & e) {\n\t\tint index = indexOf(e);\n\t\tif (index == -1)\n\t\t\tthrow NotSuchElementException();\n\t\tremove(index);\n\t}\n\n    E & get(int index)\n    {\n        Node<E> * node = get_node(index);\n        return node -> element;\n    }\n\n\tint indexOf(const E & e) const \n    {\n\t\t\n            Node<E> * node = head;\n            Node<E> * preOfnow = 0;\n            Node<E> * temp = 0;\n\t\t\tI(i, _size)\n            {\n                if(node->element == e)\n                return i;\n\n                temp = node;\n                node = node -> next_node(preOfnow);\n                preOfnow = temp;\n            }\n            return EOF;\n\t}\nprivate:\n   \tNode<E> * get_node(int index) const \n\t{\n\t\tif (index < 0 || index >= _size) \n\t\t\tthrow NotSuchElementException();\n\t\tif (index < _size / 2) \n        {\n\t\t\tNode<E> * node = head;\n            Node<E> * preOfnow = 0;\n            Node<E> * temp = 0;\n\t\t\tI(i, index)\n            {\n                temp = node;\n                node = node -> next_node(preOfnow);\n                preOfnow = temp;\n            }\n\t\t\treturn node;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tNode<E> * node = tail;\n            Node<E> * nextOfnow = 0;\n            Node<E> * temp =0;\n\t\t\tI(i, (_size - 1 - index) )\n            {\n                temp = node;\n                node = node -> prev_node(nextOfnow);\n                nextOfnow = node;\n            }\n\t\t\treturn node;\n\t\t}\n\t}\n",
            1594865429.5613077,
            100,
            "# 答案正确"
        ],
        [
            "A.2 (C++)",
            "宋力舟",
            "template <typename E>\nvoid LinkedList<E>::removeAll (const E & x) {\n    int i = 0;\n    while (i < size()) {\n        if (get(i)==x) {\n            remove(i);\n        }\n        else i++;\n    }\n}",
            1594868887.6102629,
            100,
            "# 答案正确"
        ],
        [
            "A.3 (C++)",
            "宋力舟",
            "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <stdexcept>\nusing namespace std;\n\n#define I(i,n) for (int i = 0; i < n; ++ i)\n\nclass NoSuchKeyException {};\n\nint circular_shift(int bits, int shift_bits) {\n\tconst int num_bits = 8 * sizeof(int);\n\tshift_bits = shift_bits % num_bits;\n\treturn bits << shift_bits | bits >> (num_bits - shift_bits);\n}\n\nint hash_function(const int & key) {\n\tint code = 0;\n    code ^= circular_shift(key, 5);\n\treturn code;\n}\n\ntemplate <typename V>\nclass HT\n{\n\tclass Tuple\n\t{\n\tpublic:\n\t\tint key;\n\t\tV val;\n\t\tbool in_use;\n\n\t\tTuple() : in_use(false) {}\n\t};\n\n\tvector<Tuple> tuples;\n\tint _size;\n\n\tint canonical_index(const int & key) const {\n\t\tint hash_code = hash_function(key); // needs hash_function(K)\n\t\treturn hash_code % tuples.size();\n\t}\n\n\t// the returned tuple is either empty or with the same key\n\tint indexOfKey(const int & key) const {\n\t\tint index = canonical_index(key);\n\t\twhile (true) { // will enter a dead loop if there is not empty tuple\n\t\t\tif (! tuples[index].in_use) return index;\n\t\t\tif (tuples[index].key == key) return index;\n\t\t\tindex = (index + 1) % tuples.size();\n\t\t}\n\t}\n\npublic:\n\tHT() : _size(0) {\n\t\ttuples.resize(5000);\n\t}\n\n\tbool containsKey(const int & key) const {\n\t\tint index = indexOfKey(key);\n\t\treturn tuples[index].in_use;\n\t}\n\n\tconst V & operator [] (const int & key) const {\n\t\tint index = indexOfKey(key);\n\t\tif (! tuples[index].in_use)\n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples[index].val;\n\t}\n\n\tV & operator [] (const int & key) {\n\t\tint index = indexOfKey(key);\n\t\tif (! tuples[index].in_use)\n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples[index].val;\n\t}\n\n\tvoid put(const int & key, const V & val) {\n\t\tint index = indexOfKey(key);\n\t\ttuples[index].key = key;\n\t\ttuples[index].val = val;\n\t\tif (tuples[index].in_use) return;\n\t\ttuples[index].in_use = true;\n\t\t++ _size;\n\t\t// make sure empty > size / 2\n\t\tif (2 * _size > tuples.size())\n\t\t\t_double_tuples();\n\t}\n\n\tvoid _double_tuples() {\n\t\tvector<Tuple> non_empty_tuples;\n\t\tI(i, tuples.size())\n\t\t\tif (tuples[i].in_use)\n\t\t\t\tnon_empty_tuples.push_back(tuples[i]);\n\t\tclear();\n\t\ttuples.resize(tuples.size() * 2);\n\t\tI(i, non_empty_tuples.size())\n\t\t\tput(non_empty_tuples[i].key, non_empty_tuples[i].val);\n\t}\n\n\tstatic bool _between(int hole, int canonical, int tuple_index) {\n\t\tif (hole < tuple_index)\n\t\t\treturn canonical > hole && canonical <= tuple_index;\n\t\telse\n\t\t\treturn canonical > hole || canonical <= tuple_index;\n\t}\n\n \n\n\tint size() const { return _size; }\n\n\tvoid clear() {\n\t\tI(i, tuples.size())\n\t\t\ttuples[i].in_use = false;\n\t\t_size = 0;\n\t}\n\n\tvector<int> getKeys()\n\t{\n\t    vector<int> keys;\n\t    for (int i = 0; i < tuples.size(); ++i)\n        {\n            if (tuples[i].in_use == true) keys.push_back(tuples[i].key);\n        }\n        return keys;\n\t}\n\t\tstatic bool _between(size_t hole, size_t canonical, size_t tuple_index) {\n\t\tif (hole < tuple_index)\n\t\t\treturn canonical > hole && canonical <= tuple_index;\n\t\telse\n\t\t\treturn canonical > hole || canonical <= tuple_index;\n\t}\n\t\tvoid remove(const int & key) { \n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\ttuples[index].in_use = false;\n\t\t-- _size;\n\t\t// if there is a hole between a tuple and its canonical position\n\t\t// move the tuple to the hole\n\t\tsize_t hole = index;\n\t\tsize_t tuple_index = hole;\n\t\twhile (true) {\n\t\t\ttuple_index = (tuple_index + 1) % tuples.size();\n\t\t\tif (! tuples[tuple_index].in_use) return;\n\t\t\tsize_t canonical = canonical_index(tuples[tuple_index].key);\n\t\t\tif (_between(hole, canonical, tuple_index)) continue;\n\t\t\ttuples[hole] = tuples[tuple_index];\n\t\t\thole = tuple_index;\n\t\t\ttuples[hole].in_use = false;\n\t\t}\n\t}\n};",
            1595473245.58965,
            100,
            "# 答案正确"
        ]
    ],
    "table_name": "答案"
}