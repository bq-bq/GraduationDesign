{
    "__update_time__": 1595865215.3414001,
    "field_names": [
        "题目名",
        "用户名",
        "答案",
        "提交时间",
        "分数",
        "评语"
    ],
    "field_types": [
        "text",
        "text",
        "text",
        "time",
        "number",
        "text"
    ],
    "foreign_keys": {},
    "primary_keys": [],
    "rows": [
        [
            "测试1",
            "莫振威",
            "#include <iostream>\nusing namespace std;\n\nint main(){\n    string s1, s2, s3;\n    cin >> s1 >> s2 >> s3;\n    cout << s3 << \" \" << s2 << \" \" << s1 << endl;\n}",
            1587524276.9769046,
            100,
            "# 答案正确"
        ],
        [
            "测试2",
            "莫振威",
            "#include <iostream>\nusing namespace std;\n\nint main(){\n    string s[10];\n    for(int i = 0 ; i < 10; i++){\n        cin >> s[i];\n    }\n    for(int i = 0; i < 10; i++){\n        for(int j = i+1; j < 10; j++){\n            if(s[i] > s[j]){\n                string temp = s[i];\n                s[i] = s[j];\n                s[j] = temp;\n            }\n        }\n    }\n    for(int i = 0; i < 10; i++){\n        cout << s[i] << ' ';\n    }\n    cout << endl;\n}",
            1587608566.726575,
            100,
            "# 答案正确"
        ],
        [
            "1.1 (C++)",
            "莫振威",
            "class Matrix5x5\n{\npublic:\n    double a[5][5];\n    Matrix5x5();\n    double get(int row, int col);\n    void set(int row, int col, double value);\n};\n\nMatrix5x5::Matrix5x5(){\n    for(int i = 0; i < 5; i++){\n        for(int j = 0; j < 5; j++){\n            a[i][j] = 0;\n        }\n    }\n}\n\ndouble Matrix5x5::get(int row, int col){\n    return a[row][col];\n}\n\nvoid Matrix5x5::set(int row, int col, double value){\n    a[row][col] = value;\n}\n\nMatrix5x5 operator+(Matrix5x5 &m1, Matrix5x5 &m2){\n    Matrix5x5 temp;\n    for(int i = 0; i < 5; i++){\n        for(int j = 0; j < 5; j++){\n            temp.a[i][j] = m1.a[i][j] + m2.a[i][j];\n        }\n    }\n    return temp;\n}",
            1587697983.7375245,
            100,
            "# 答案正确"
        ],
        [
            "1.2 (C++)",
            "莫振威",
            "#include <cstring>\nclass School{\npublic:\n    char name[10];\n    int age;\n    School(){\n        age = 0;\n        strcpy(name, \"NO_NAME\");\n    }\n    void setName(char name[]){\n        strcpy(this->name, name);\n    }\n    void setAge(int year){\n        age = year;\n    }\n    void operator++(){\n        age++;\n    }\n};",
            1588213647.3939834,
            100,
            "# 答案正确"
        ],
        [
            "2.1 (C++)",
            "莫振威",
            "#include<iostream>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble* values;\npublic:\n\tMatrix(int rows, int columns){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tthis->values = new double[rows * columns];\n\t\tfor(int i = 0; i < rows; i++){\n\t\t\tfor(int j = 0; j < columns; j++){\n\t\t\t\tvalues[i * columns + j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\t~Matrix(){\n\t\tdelete [] values;\n\t}\n\tvoid print(){\n\t\tfor(int i = 0; i < rows; i++){\n\t\t\tfor(int j = 0; j < columns; j++){\n\t\t\t\tcout << \"    \" <<values[i * columns + j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n};",
            1588859187.7858977,
            100,
            "# 答案正确"
        ],
        [
            "2.2 (C++)",
            "莫振威",
            "#include<iostream>\n#include<iomanip>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble* values;\npublic:\n\tMatrix(int rows, int columns, double values[]){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tthis->values = new double[rows * columns];\n\t\tfor(int i = 0; i < rows; i++){\n\t\t\tfor(int j = 0; j < columns; j++){\n\t\t\t\tthis->values[i * columns + j] = values[i * columns + j];\n\t\t\t}\n\t\t}\n\t}\n\t~Matrix(){\n\t\tdelete [] values;\n\t}\n\tvoid print(){\n\t\tfor(int i = 0; i < rows; i++){\n\t\t\tfor(int j = 0; j < columns; j++){\n\t\t\t\tcout << setw(5)<< values[i * columns + j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n};",
            1588859757.9427006,
            100,
            "# 答案正确"
        ],
        [
            "2.3 (C++)",
            "莫振威",
            "#include<iostream>\n#include<iomanip>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble* values;\npublic:\n\tMatrix(int rows, int columns, double values[]){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tthis->values = new double[rows * columns];\n\t\tfor(int i = 0; i < rows; i++){\n\t\t\tfor(int j = 0; j < columns; j++){\n\t\t\t\tthis->values[i * columns + j] = values[i * columns + j];\n\t\t\t}\n\t\t}\n\t}\n\t~Matrix(){\n\t\tdelete [] values;\n\t}\n\tMatrix(const Matrix & m){\n\t\tthis->rows = m.rows;\n\t\tthis->columns = m.columns;\n\t\tthis->values = new double[m.rows * m.columns];\n\t\tfor(int i = 0; i < m.rows; i++){\n\t\t\tfor(int j = 0; j < m.columns; j++){\n\t\t\t\tthis->values[i * m.columns + j] = m.values[i * m.columns + j];\n\t\t\t}\n\t\t}\n\t}\n\tvoid print(){\n\t\tfor(int i = 0; i < rows; i++){\n\t\t\tfor(int j = 0; j < columns; j++){\n\t\t\t\tcout << \"    \"<< values[i * columns + j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n};",
            1588861373.3549168,
            100,
            "# 答案正确"
        ],
        [
            "2.5 (C++)",
            "莫振威",
            "#include<iostream>\n#include<iomanip>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble* values;\npublic:\n\tMatrix(int rows, int columns){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tthis->values = new double[rows * columns];\n\t\tfor(int i = 0; i < rows; i++){\n\t\t\tfor(int j = 0; j < columns; j++){\n\t\t\t\tthis->values[i * columns + j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tMatrix(int rows, int columns, double values[]){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tthis->values = new double[rows * columns];\n\t\tfor(int i = 0; i < rows; i++){\n\t\t\tfor(int j = 0; j < columns; j++){\n\t\t\t\tthis->values[i * columns + j] = values[i * columns + j];\n\t\t\t}\n\t\t}\n\t}\n\t~Matrix(){\n\t\tdelete [] values;\n\t}\n\tMatrix(const Matrix & m){\n\t\tthis->rows = m.rows;\n\t\tthis->columns = m.columns;\n\t\tthis->values = new double[m.rows * m.columns];\n\t\tfor(int i = 0; i < m.rows; i++){\n\t\t\tfor(int j = 0; j < m.columns; j++){\n\t\t\t\tthis->values[i * m.columns + j] = m.values[i * m.columns + j];\n\t\t\t}\n\t\t}\n\t}\n\tvoid print(){\n\t\tfor(int i = 0; i < rows; i++){\n\t\t\tfor(int j = 0; j < columns; j++){\n\t\t\t\tcout << \"    \" << values[i * columns + j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tMatrix getRow(int row){\n\t\tMatrix m1(1, this->columns);\n\t\tfor(int i = 0; i < this->columns; i++){\n\t\t\tm1.values[i] = this->values[i + (row-1) * this->columns];\n\t\t}\n\t\treturn m1;\n\t}\n\tMatrix getColumn(int column){\n\t\tMatrix m2(this->rows, 1);\n\t\tfor(int j = 0; j < this->rows; j++){\n\t\t\tm2.values[j] = this->values[j * this->columns + column - 1];\n\t\t}\n\t\treturn m2;\n\t}\n};",
            1588863390.7233465,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/08",
            "莫振威",
            "double & Tensor_get(int dimensions, const int sizes[], double data[], int x0, int x1, int x2, int x3){\n        int temp = x0;\n        if(dimensions == 2) temp = x1 + x0 * sizes[1];\n        else if(dimensions == 3) temp = x2 + x1 * sizes[1] + x0 * sizes[1] * sizes[2];\n        else if(dimensions == 4) temp = x3 + x2 * sizes[1] + x1 * sizes[1] * sizes[2] + x0 * sizes[1] * sizes[2] * sizes[3];\n        return data[temp];\n    }",
            1588908617.7831736,
            91,
            "# 答案不正确\n\n# 随机输入:\n1 1\n2 1\n2 3\n\n0 0 3\n1 0 0\n2 1 4\n\n0 0 4 3\n1 2 2 1\n1 0 1 4\n\n\n\n# 参考答案:\n11\n21\n23\n\n3\n100\n214\n\n43\n1221\n1014\n\n\n# 我的答案:\n11\n21\n23\n\n3\n100\n220\n\n43\n1221\n1020\n"
        ],
        [
            "2.6 (C++)",
            "莫振威",
            "#include<iostream>\n#include<iomanip>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble* values;\npublic:\n\tMatrix(){\n\t\tthis->rows = 0;\n\t\tthis->columns = 0;\n\t\tthis->values = NULL;\n\t}\n\tMatrix(int rows, int columns, double values[]){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tthis->values = new double[rows * columns];\n\t\tfor(int i = 0; i < rows; i++){\n\t\t\tfor(int j = 0; j < columns; j++){\n\t\t\t\tthis->values[i * columns + j] = values[i * columns + j];\n\t\t\t}\n\t\t}\n\t}\n\t~Matrix(){\n\t\tdelete [] values;\n\t}\n\tMatrix(const Matrix & m){\n\t\tthis->rows = m.rows;\n\t\tthis->columns = m.columns;\n\t\tthis->values = new double[m.rows * m.columns];\n\t\tfor(int i = 0; i < m.rows; i++){\n\t\t\tfor(int j = 0; j < m.columns; j++){\n\t\t\t\tthis->values[i * m.columns + j] = m.values[i * m.columns + j];\n\t\t\t}\n\t\t}\n\t}\n\tvoid print(){\n\t\tfor(int i = 0; i < rows; i++){\n\t\t\tfor(int j = 0; j < columns; j++){\n\t\t\t\tcout << \"    \" << values[i * columns + j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tMatrix concatenateRows(const Matrix & matrix2){\n\t\tMatrix m1;\n\t\tm1.columns = this->columns;\n\t\tm1.rows = this->rows + matrix2.rows;\n\t\tm1.values = new double[m1.columns * m1.rows];\n\t\tfor(int i = 0; i < m1.rows; i++){\n\t\t\tfor(int j = 0; j < m1.columns; j++){\n\t\t\t\tif(i < this->rows) m1.values[i * m1.columns + j] = this->values[i * this->columns + j];\n\t\t\t\telse m1.values[i * m1.columns + j] = matrix2.values[(i - this->rows) * columns + j];\n\t\t\t}\n\t\t}\n\t\treturn m1;\n\t}\n\tMatrix concatenateColumns(const Matrix & matrix2){\n\t\tMatrix m2;\n\t\tm2.columns = this->columns + matrix2.columns;\n\t\tm2.rows = this->rows;\n\t\tm2.values = new double[m2.columns * m2.rows];\n\t\tfor(int i = 0; i < m2.rows; i++){\n\t\t\tfor(int j = 0; j < m2.columns; j++){\n\t\t\t\tif(j < this->columns) m2.values[i * m2.columns + j] = this->values[i * this->columns + j];\n\t\t\t\telse m2.values[i * m2.columns + j] = matrix2.values[(i * this->columns) + j - this->columns];\n\t\t\t}\n\t\t}\n\t\treturn m2;\n\t}\n};",
            1588925890.832501,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/14",
            "莫振威",
            "#include <iostream>\nusing namespace std;\nvoid Tensor_print(int dimensions,const int sizes[], double * data){\n\tif(dimensions == 1){\n\t\tprintf(\"Tensor of %d\\n\", sizes[0]);\n\t\tfor(int i = 0; i < sizes[0]; i++){\n\t\t\tcout << data[i] << endl;\n\t\t}\n\t}\n\telse if(dimensions == 2){\n\t\tprintf(\"Tensor of %dx%d\\n\", sizes[0], sizes[1]);\n\t\tfor(int i = 0; i < sizes[0]; i++){\n\t\t\tfor(int j = 0; j < sizes[1]; j++){\n\t\t\t\tcout << \"    \" << data[i*sizes[1] + j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\telse if(dimensions == 3){\n\t\tprintf(\"Tensor of %dx%dx%d\\n\", sizes[0], sizes[1], sizes[2]);\n\t\tfor(int i = 0; i < sizes[0]; i++){\n\t\t\tprintf(\"data[%d]\\n\", i);\n\t\t\tfor(int j = 0; j < sizes[1]; j++){\n\t\t\t\tfor(int k = 0; k < sizes[2]; k++){\n\t\t\t\t\tcout << \"    \" << data[i*sizes[1]*sizes[2] + j*sizes[2] + k];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t}\n\telse if(dimensions == 4){\n\t\tprintf(\"Tensor of %dx%dx%dx%d\\n\", sizes[0], sizes[1], sizes[2], sizes[3]);\n\t\tfor(int i = 0; i < sizes[0]; i++){\n\t\t\tfor(int j = 0; j < sizes[1]; j++){\n\t\t\t\tprintf(\"data[%d][%d]\\n\", i, j);\n\t\t\t\tfor(int k = 0; k < sizes[2]; k++){\n\t\t\t\t\tfor(int l = 0; l < sizes[3]; l++){\n\t\t\t\t\t\tcout << \"    \" << data[i*sizes[1]*sizes[2]*sizes[3] + j*sizes[2]*sizes[3] + k*sizes[3] + l];\n\t\t\t\t\t}\n\t\t\t\t\tcout << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
            1589423748.400512,
            100,
            "# 答案正确"
        ],
        [
            "2.4 (C++)",
            "莫振威",
            "#include<iostream>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tMatrix(int rows, int columns){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tif(rows == 0 || columns == 0){\n\t\t\tthis->values = NULL;\n\t\t}\n\t\telse{\n\t\t\tthis->values = new double[rows * columns];\n\t\t\tfor(int i = 0; i < rows; i++){\n\t\t\t\tfor(int j = 0; j < columns; j++){\n\t\t\t\t\tvalues[i*columns + j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tMatrix(int rows, int columns, double * values){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tthis->values = new double[rows * columns];\n\t\tfor(int i = 0; i < rows; i++){\n\t\t\tfor(int j = 0; j < columns; j++){\n\t\t\t\tthis->values[i*columns + j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < rows; i++){\n\t\t\tfor(int j = 0; j < columns; j++){\n\t\t\t\tthis->values[i*columns + j] = values[i*columns + j];\n\t\t\t}\n\t\t}\n\t}\n\t~Matrix(){\n\t\tdelete [] values;\n\t}\n\tvoid print(){\n\t\tfor(int i = 0; i < this->rows; i++){\n\t\t\tfor(int j = 0; j < this->columns; j++){\n\t\t\t\tcout << \"    \" << this->values[i * columns + j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tvoid set(int row, int column, double value){\n\t\tvalues[(row-1) * columns + column-1] = value;\n\t}\n\tMatrix & operator = (const Matrix & m){\n\t\tthis->rows = m.rows;\n\t\tthis->columns = m.columns;\n\t\tthis->values = new double[m.rows * m.columns];\n\t\tfor(int i = 0; i < m.rows; i++){\n\t\t\tfor(int j = 0; j < m.columns; j++){\n\t\t\t\tthis->values[i * m.columns + j] = m.values[i * m.columns + j];\n\t\t\t}\n\t\t}\n\t\treturn *this;\n\t}\n};",
            1589518349.5322292,
            100,
            "# 答案正确"
        ],
        [
            "2.7 (C++)",
            "莫振威",
            "#include<iostream>\n#include<cstring>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tMatrix(int rows, int columns){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tthis->values = new double[rows * columns];\n\t\tfor(int i = 0; i < rows; i++){\n\t\t\tfor(int j = 0; j < columns; j++){\n\t\t\t\tthis->values[i * columns + j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tMatrix(int rows, int columns, double * values){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tthis->values = new double[rows * columns];\n\t\tfor(int i = 0; i < rows; i++){\n\t\t\tfor(int j = 0; j < columns; j++){\n\t\t\t\tthis->values[i*columns + j] = values[i*columns + j];\n\t\t\t}\n\t\t}\n\t}\n\tMatrix(const Matrix & matrix2){\n\t\tthis->rows = matrix2.rows;\n\t\tthis->columns = matrix2.columns;\n\t\tthis->values = new double[matrix2.rows * matrix2.columns];\n\t\tfor(int i = 0; i < matrix2.rows; i++){\n\t\t\tfor(int j = 0; j < matrix2.columns; j++){\n\t\t\t\tthis->values[i*matrix2.columns + j] = matrix2.values[i*matrix2.columns + j];\n\t\t\t}\n\t\t}\n\t}\n\t~Matrix(){\n\t\tdelete [] values;\n\t}\n\tvoid print(){\n\t\tfor(int i = 0; i < this->rows; i++){\n\t\t\tfor(int j = 0; j < this->columns; j++){\n\t\t\t\tcout << \"    \" << this->values[i * columns + j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tMatrix reshape(int rows, int columns) const{\n\t\tMatrix m(rows, columns);\n\t\tdouble * temp = new double[rows*columns];\n\t\tint k = 0;\n\t\tfor(int i = 0; i < this->columns; i++){\n\t\t\tfor(int j = 0; j < this->rows; j++){\n\t\t\t\ttemp[k++] = this->values[i + j * this->columns];\n\t\t\t}\n\t\t}\n\t\tk = 0;\n\t\tfor(int i = 0; i < columns; i++){\n\t\t\tfor(int j = 0; j < rows; j++){\n\t\t\t\tm.values[i + j * columns] = temp[k++];\n\t\t\t}\n\t\t}\n\t\tdelete [] temp;\n\t\treturn m;\n\t}\n};",
            1589540388.953313,
            100,
            "# 答案正确"
        ],
        [
            "2.8 (C++)",
            "莫振威",
            "#include<iostream>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tMatrix(int rows, int columns){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tthis->values = new double[rows * columns];\n\t\tfor(int i = 0; i < rows; i++){\n\t\t\tfor(int j = 0; j < columns; j++){\n\t\t\t\tthis->values[i * columns + j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tMatrix(int rows, int columns, double * values){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tthis->values = new double[rows * columns];\n\t\tfor(int i = 0; i < rows; i++){\n\t\t\tfor(int j = 0; j < columns; j++){\n\t\t\t\tthis->values[i*columns + j] = values[i*columns + j];\n\t\t\t}\n\t\t}\n\t}\n\tMatrix(const Matrix & matrix2){\n\t\tthis->rows = matrix2.rows;\n\t\tthis->columns = matrix2.columns;\n\t\tthis->values = new double[matrix2.rows * matrix2.columns];\n\t\tfor(int i = 0; i < matrix2.rows; i++){\n\t\t\tfor(int j = 0; j < matrix2.columns; j++){\n\t\t\t\tthis->values[i*matrix2.columns + j] = matrix2.values[i*matrix2.columns + j];\n\t\t\t}\n\t\t}\n\t}\n\t~Matrix(){\n\t\tdelete [] values;\n\t}\n\tvoid print(){\n\t\tfor(int i = 0; i < this->rows; i++){\n\t\t\tfor(int j = 0; j < this->columns; j++){\n\t\t\t\tcout << \"    \" << this->values[i * columns + j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tMatrix transpose() const{\n\t\tMatrix m(this->columns, this->rows);\n\t\tint k = 0, l = 0;\n\t\tfor(int i = 0; i < m.columns; i++){\n\t\t\tfor(int j = 0; j < m.rows; j++){\n\t\t\t\tm.values[j * m.columns + i] = this->values[k * this->columns + l];\n\t\t\t\tif(l == this->columns - 1) k = (k + 1) % this->rows;\n\t\t\t\tl = (l + 1) % this->columns;\n\t\t\t}\n\t\t}\n\t\treturn m;\n\t}\n};",
            1589545071.7826443,
            100,
            "# 答案正确"
        ],
        [
            "2.10 (C++)",
            "莫振威",
            "#include<iostream>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tMatrix(int rows, int columns){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tthis->values = new double[rows * columns]();\n\t}\n\tMatrix(int rows, int columns, double * values){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tthis->values = new double[rows * columns];\n\t\tfor(int i = 0; i < rows; i++){\n\t\t\tfor(int j = 0; j < columns; j++){\n\t\t\t\tthis->values[i*columns + j] = values[i*columns + j];\n\t\t\t}\n\t\t}\n\t}\n\tMatrix(const Matrix & matrix2){\n\t\tthis->rows = matrix2.rows;\n\t\tthis->columns = matrix2.columns;\n\t\tthis->values = new double[matrix2.rows * matrix2.columns];\n\t\tfor(int i = 0; i < matrix2.rows; i++){\n\t\t\tfor(int j = 0; j < matrix2.columns; j++){\n\t\t\t\tthis->values[i*matrix2.columns + j] = matrix2.values[i*matrix2.columns + j];\n\t\t\t}\n\t\t}\n\t}\n\t~Matrix(){\n\t\tdelete [] values;\n\t}\n\tvoid print(){\n\t\tfor(int i = 0; i < this->rows; i++){\n\t\t\tfor(int j = 0; j < this->columns; j++){\n\t\t\t\tcout << \"    \" << this->values[i * columns + j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tMatrix operator * (const Matrix & matrix2) const{\n\t\tMatrix m(this->rows, matrix2.columns);\n\t\tif(this->columns == matrix2.rows){\n\t\t\tfor(int i = 0; i < this->rows; i++){\n\t\t\t\tfor(int j = 0; j < matrix2.columns; j++){\n\t\t\t\t\tfor(int k = 0; k < this->columns; k++){\n\t\t\t\t\t\tm.values[i*matrix2.columns + j] += this->values[i*this->columns + k] * matrix2.values[k*matrix2.columns + j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn m;\n\t}\n\tMatrix operator * (double value) const{\n\t\tfor(int i = 0; i < this->rows; i++){\n\t\t\tfor(int j = 0; j < this->columns; j++){\n\t\t\t\tthis->values[i*this->columns + j] = this->values[i*this->columns + j] * value;\n\t\t\t}\n\t\t}\n\t\treturn *this;\n\t}\n};",
            1589682740.4497414,
            100,
            "# 答案正确"
        ],
        [
            "2.11 (C++)",
            "莫振威",
            "#include<iostream>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tMatrix(int rows, int columns){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tthis->values = new double[rows * columns]();\n\t}\n\tMatrix(int rows, int columns, double * values){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tthis->values = new double[rows * columns];\n\t\tfor(int i = 0; i < rows; i++){\n\t\t\tfor(int j = 0; j < columns; j++){\n\t\t\t\tthis->values[i*columns + j] = values[i*columns + j];\n\t\t\t}\n\t\t}\n\t}\n\tMatrix(const Matrix & matrix2){\n\t\tthis->rows = matrix2.rows;\n\t\tthis->columns = matrix2.columns;\n\t\tthis->values = new double[matrix2.rows * matrix2.columns]();\n\t\tfor(int i = 0; i < matrix2.rows; i++){\n\t\t\tfor(int j = 0; j < matrix2.columns; j++){\n\t\t\t\tthis->values[i*matrix2.columns + j] = matrix2.values[i*matrix2.columns + j];\n\t\t\t}\n\t\t}\n\t}\n\t~Matrix(){\n\t\tdelete [] values;\n\t}\n\tvoid print(){\n\t\tfor(int i = 0; i < this->rows; i++){\n\t\t\tfor(int j = 0; j < this->columns; j++){\n\t\t\t\tcout << \"    \" << this->values[i * columns + j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tMatrix max() const{\n\t\tif(this->rows != 1){\n\t\t\tMatrix m1(1, this->columns);\n\t\t\tfor(int i = 0; i < this->columns; i++){\n\t\t\t\tdouble max = 0; \n\t\t\t\tfor(int j = 0; j < this->rows; j++){\n\t\t\t\t\tif(max < this->values[j*this->columns + i]){\n\t\t\t\t\t\tmax = this->values[j*this->columns + i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tm1.values[i] = max;\n\t\t\t}\n\t\t\treturn m1;\n\t\t}\n\t\telse{\n\t\t\tMatrix m2(1, 1);\n\t\t\tdouble max = 0;\n\t\t\tfor(int i = 0; i < this->columns; i++){\n\t\t\t\tif(max < this->values[i]) max = this->values[i];\n\t\t\t}\n\t\t\tm2.values[0] = max;\n\t\t\treturn m2;\n\t\t}\n\t}\n\tMatrix min() const{\n\t\tif(this->rows != 1){\n\t\t\tMatrix m1(1, this->columns);\n\t\t\tfor(int i = 0; i < this->columns; i++){\n\t\t\t\tdouble min = 1e5; \n\t\t\t\tfor(int j = 0; j < this->rows; j++){\n\t\t\t\t\tif(min > this->values[j*this->columns + i]){\n\t\t\t\t\t\tmin = this->values[j*this->columns + i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tm1.values[i] = min;\n\t\t\t}\n\t\t\treturn m1;\n\t\t}\n\t\telse{\n\t\t\tMatrix m2(1, 1);\n\t\t\tdouble min = 1e5;\n\t\t\tfor(int i = 0; i < this->columns; i++){\n\t\t\t\tif(min > this->values[i]) min = this->values[i];\n\t\t\t}\n\t\t\tm2.values[0] = min;\n\t\t\treturn m2;\n\t\t}\n\t}\n\tMatrix sum() const{\n\t\tif(this->rows != 1){\n\t\t\tMatrix m1(1, this->columns);\n\t\t\tfor(int i = 0; i < this->columns; i++){\n\t\t\t\tdouble sum = 0; \n\t\t\t\tfor(int j = 0; j < this->rows; j++){\n\t\t\t\t\tsum += this->values[j*this->columns + i];\n\t\t\t\t}\n\t\t\t\tm1.values[i] = sum;\n\t\t\t}\n\t\t\treturn m1;\n\t\t}\n\t\telse{\n\t\t\tMatrix m2(1, 1);\n\t\t\tdouble sum = 0;\n\t\t\tfor(int i = 0; i < this->columns; i++){\n\t\t\t\tsum += this->values[i];\n\t\t\t}\n\t\t\tm2.values[0] = sum;\n\t\t\treturn m2;\n\t\t}\n\t}\n};",
            1589686108.4104228,
            100,
            "# 答案正确"
        ],
        [
            "2.12 (C++)",
            "莫振威",
            "#include<iostream>\n#include<cmath>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tMatrix(int rows, int columns){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tthis->values = new double[rows * columns]();\n\t}\n\tMatrix(int rows, int columns, double * values){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tthis->values = new double[rows * columns];\n\t\tfor(int i = 0; i < rows; i++){\n\t\t\tfor(int j = 0; j < columns; j++){\n\t\t\t\tthis->values[i*columns + j] = values[i*columns + j];\n\t\t\t}\n\t\t}\n\t}\n\tMatrix(const Matrix & matrix2){\n\t\tthis->rows = matrix2.rows;\n\t\tthis->columns = matrix2.columns;\n\t\tthis->values = new double[matrix2.rows * matrix2.columns]();\n\t\tfor(int i = 0; i < matrix2.rows; i++){\n\t\t\tfor(int j = 0; j < matrix2.columns; j++){\n\t\t\t\tthis->values[i*matrix2.columns + j] = matrix2.values[i*matrix2.columns + j];\n\t\t\t}\n\t\t}\n\t}\n\t~Matrix(){\n\t\tdelete [] values;\n\t}\n\tvoid print(){\n\t\tfor(int i = 0; i < this->rows; i++){\n\t\t\tfor(int j = 0; j < this->columns; j++){\n\t\t\t\tcout << \"    \" << this->values[i * columns + j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tMatrix pow(double exponent){\n\t\tMatrix m(this->rows, this->columns);\n\t\tfor(int i = 0; i < this->rows; i++){\n\t\t\tfor(int j = 0; j < this->columns; j++){\n\t\t\t\tm.values[i*columns + j] = ::pow(this->values[i*columns + j], exponent);\n\t\t\t}\n\t\t}\n\t\treturn m;\n\t}\n\tMatrix exp(){\n\t\tMatrix m(this->rows, this->columns);\n\t\tfor(int i = 0; i < this->rows; i++){\n\t\t\tfor(int j = 0; j < this->columns; j++){\n\t\t\t\tm.values[i*columns + j] = ::exp(this->values[i*columns + j]);\n\t\t\t}\n\t\t}\n\t\treturn m;\n\t}\n\tMatrix log(){\n\t\tMatrix m(this->rows, this->columns);\n\t\tfor(int i = 0; i < this->rows; i++){\n\t\t\tfor(int j = 0; j < this->columns; j++){\n\t\t\t\tm.values[i*columns + j] = ::log(this->values[i*columns + j]);\n\t\t\t}\n\t\t}\n\t\treturn m;\n\t}\n\tMatrix abs(){\n\t\tMatrix m(this->rows, this->columns);\n\t\tfor(int i = 0; i < this->rows; i++){\n\t\t\tfor(int j = 0; j < this->columns; j++){\n\t\t\t\tm.values[i*columns + j] = ::abs(this->values[i*columns + j]);\n\t\t\t}\n\t\t}\n\t\treturn m;\n\t}\n};",
            1589687847.6493726,
            100,
            "# 答案正确"
        ],
        [
            "2.9 (C++)",
            "莫振威",
            "#include<iostream>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tMatrix(int rows, int columns){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tthis->values = new double[rows * columns]();\n\t}\n\tMatrix(int rows, int columns, double * values){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tthis->values = new double[rows * columns]();\n\t\tfor(int i = 0; i < rows; i++){\n\t\t\tfor(int j = 0; j < columns; j++){\n\t\t\t\tthis->values[i*columns + j] = values[i*columns + j];\n\t\t\t}\n\t\t}\n\t}\n\tMatrix(const Matrix & matrix2){\n\t\tthis->rows = matrix2.rows;\n\t\tthis->columns = matrix2.columns;\n\t\tthis->values = new double[matrix2.rows * matrix2.columns]();\n\t\tfor(int i = 0; i < matrix2.rows; i++){\n\t\t\tfor(int j = 0; j < matrix2.columns; j++){\n\t\t\t\tthis->values[i*matrix2.columns + j] = matrix2.values[i*matrix2.columns + j];\n\t\t\t}\n\t\t}\n\t}\n\t~Matrix(){\n\t\tdelete [] values;\n\t}\n\tvoid print(){\n\t\tfor(int i = 0; i < this->rows; i++){\n\t\t\tfor(int j = 0; j < this->columns; j++){\n\t\t\t\tcout << \"    \" << this->values[i * columns + j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tMatrix operator+(const Matrix & matrix2){\n        Matrix m(this->rows, this->columns);\n        for(int i = 0; i < m.rows; i++){\n            for(int j = 0; j < m.columns; j++){\n                m.values[i * m.columns + j] = this->values[i * m.columns + j] + matrix2.values[i * m.columns + j];\n            }\n        }\n        return m;\n    }\n    Matrix operator+(double value){\n        Matrix m(this->rows, this->columns);\n        for(int i = 0; i < m.rows; i++){\n            for(int j = 0; j < m.columns; j++){\n                m.values[i * m.columns + j] = this->values[i * m.columns + j] + value;\n            }\n        }\n        return m;\n    }\n    Matrix operator-(const Matrix & matrix2){\n        Matrix m(this->rows, this->columns);\n        for(int i = 0; i < m.rows; i++){\n            for(int j = 0; j < m.columns; j++){\n                m.values[i * m.columns + j] = this->values[i * m.columns + j] - matrix2.values[i * m.columns + j];\n            }\n        }\n        return m;\n    }\n    Matrix operator-(double value){\n        Matrix m(this->rows, this->columns);\n        for(int i = 0; i < m.rows; i++){\n            for(int j = 0; j < m.columns; j++){\n                m.values[i * m.columns + j] = this->values[i * m.columns + j] - value;\n            }\n        }\n        return m;\n    }\n};",
            1590027430.7170758,
            100,
            "# 答案正确"
        ],
        [
            "6.1 (C++)",
            "莫振威",
            "template <typename T>\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tT * values;\npublic:\n\tMatrix(int rows, int columns){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tthis->values = new T[rows * columns]();\n\t}\n\tMatrix(int rows, int columns, const T * values){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tthis->values = new T[rows * columns]();\n\t\tfor(int i = 0; i < rows; i++){\n\t\t\tfor(int j = 0; j < columns; j++){\n\t\t\t\tthis->values[i*columns + j] = values[i*columns + j];\n\t\t\t}\n\t\t}\n\t}\n\tMatrix(const Matrix & matrix2){\n\t\tthis->rows = matrix2.rows;\n\t\tthis->columns = matrix2.columns;\n\t\tthis->values = new T[matrix2.rows * matrix2.columns]();\n\t\tfor(int i = 0; i < matrix2.rows; i++){\n\t\t\tfor(int j = 0; j < matrix2.columns; j++){\n\t\t\t\tthis->values[i*matrix2.columns + j] = matrix2.values[i*matrix2.columns + j];\n\t\t\t}\n\t\t}\n\t}\n\t~Matrix(){\n\t\tdelete [] values;\n\t}\n\tvoid print(){\n\t\tfor(int i = 0; i < this->rows; i++){\n\t\t\tfor(int j = 0; j < this->columns; j++){\n\t\t\t\tcout << \"    \" << this->values[i * columns + j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tT & get(int row, int column){\n\t\treturn this->values[row-1, column-1];\n\t}\n\tMatrix & operator=(const Matrix & matrix2){\n\t\tif(this->values != NULL) delete [] this->values;\n\t\tthis->rows = matrix2.rows;\n\t\tthis->columns = matrix2.columns;\n\t\tthis->values = new T[matrix2.rows * matrix2.columns]();\n\t\tfor(int i = 0; i < matrix2.rows; i++){\n\t\t\tfor(int j = 0; j < matrix2.columns; j++){\n\t\t\t\tthis->values[i*matrix2.columns + j] = matrix2.values[i*matrix2.columns + j];\n\t\t\t}\n\t\t}\n\t\treturn *this;\n\t}\n};\n",
            1590202396.4063747,
            100,
            "# 答案正确"
        ],
        [
            "6.3 (C++)",
            "莫振威",
            "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\ntemplate <typename T>\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tvector<T> values;\npublic:\n\tMatrix(int rows, int columns){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tfor(int i = 0; i < rows; i++){\n\t\t\tfor(int j = 0; j < columns; j++){\n\t\t\t\tthis->values.push_back(0);\n\t\t\t}\n\t\t}\n\t}\n\tMatrix(int rows, int columns, const vector<T> values){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tfor(int i = 0; i < rows; i++){\n\t\t\tfor(int j = 0; j < columns; j++){\n\t\t\t\tthis->values.push_back(0);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < rows; i++){\n\t\t\tfor(int j = 0; j < columns; j++){\n\t\t\t\tthis->values[i*columns + j] = values[i*columns + j];\n\t\t\t}\n\t\t}\n\t}\n\tMatrix(const Matrix & matrix2){\n\t\tthis->rows = matrix2.rows;\n\t\tthis->columns = matrix2.columns;\n\t\tfor(int i = 0; i < rows; i++){\n\t\t\tfor(int j = 0; j < columns; j++){\n\t\t\t\tthis->values.push_back(0);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < matrix2.rows; i++){\n\t\t\tfor(int j = 0; j < matrix2.columns; j++){\n\t\t\t\tthis->values[i*matrix2.columns + j] = matrix2.values[i*matrix2.columns + j];\n\t\t\t}\n\t\t}\n\t}\n\tvoid print(){\n\t\tfor(int i = 0; i < this->rows; i++){\n\t\t\tfor(int j = 0; j < this->columns; j++){\n\t\t\t\tcout << \"    \" << this->values[i * columns + j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tT & get(int row, int column){\n\t\treturn this->values[row-1, column-1];\n\t}\n\tMatrix & operator=(const Matrix & matrix2){ \n\t\tthis->rows = matrix2.rows;\n\t\tthis->columns = matrix2.columns;\n\t\tif(this->values.empty()){\n\t\t\tfor(int i = 0; i < rows; i++){\n\t\t\t\tfor(int j = 0; j < columns; j++){\n\t\t\t\t\tthis->values.push_back(0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < matrix2.rows; i++){\n\t\t\tfor(int j = 0; j < matrix2.columns; j++){\n\t\t\t\tthis->values[i*matrix2.columns + j] = matrix2.values[i*matrix2.columns + j];\n\t\t\t}\n\t\t}\n\t\treturn *this;\n\t}\n\tMatrix getColumn(int column){\n\t\tMatrix m(this->rows, 1);\n\t\tfor(int i = 0; i < this->rows; i++){\n\t\t\tm.values[i] = this->values[i*this->columns + column - 1];\n\t\t}\n\t\treturn m;\n\t}\n\tMatrix getRow(int row){\n\t\tMatrix m(1, this->columns);\n\t\tfor(int i = 0; i < this->columns; i++){\n\t\t\tm.values[i] = this->values[(row-1)*this->columns + i];\n\t\t}\n\t\treturn m;\n\t}\n\tMatrix concatenateRows(const Matrix & matrix2){\n\t\tMatrix m(this->rows+matrix2.rows, this->columns);\n\t\tfor(int i = 0; i < m.rows; i++){\n\t\t\tfor(int j = 0; j < m.columns; j++){\n\t\t\t\tif(i < this->rows) m.values[i*m.columns + j] = this->values[i*this->columns + j];\n\t\t\t\telse  m.values[i*m.columns + j] = matrix2.values[(i-this->rows)*this->columns + j];\n\t\t\t}\n\t\t}\n\t\treturn m;\n\t}\n\tMatrix concatenateColumns(const Matrix & matrix2){\n\t\tMatrix m(this->rows, this->columns+matrix2.columns);\n\t\tfor(int i = 0; i < m.rows; i++){\n\t\t\tfor(int j = 0; j < m.columns; j++){\n\t\t\t\tif(j < this->columns) m.values[i*m.columns + j] = this->values[i*this->columns + j];\n\t\t\t\telse  m.values[i*m.columns + j] = matrix2.values[i*this->columns + j - this->columns];\n\t\t\t}\n\t\t}\n\t\treturn m;\n\t}\n\tMatrix reshape(int rows, int columns){\n\t\tMatrix m(rows, columns);\n\t\tvector<T> values;\n\t\tfor(int i = 0; i < this->columns; i++){\n\t\t\tfor(int j  = 0; j < this->rows; j++){\n\t\t\t\tvalues.push_back(this->values[i + j*this->columns]);\n\t\t\t}\n\t\t}\n\t\tint k = 0;\n\t\tfor(int i = 0; i < m.columns; i++){\n\t\t\tfor(int j = 0; j < m.rows; j++){\n\t\t\t\tm.values[i + j*m.columns] = values[k++];\n\t\t\t}\n\t\t}\n\t\treturn m;\n\t}\n\tMatrix transpose(){\n\t\tMatrix m(this->rows, this->columns);\n\t\tint k = 0;\n\t\tfor(int i = 0; i < m.columns; i++){\n\t\t\tfor(int j = 0; j < m.rows; j++){\n\t\t\t\tm.values[i + j*m.columns] = this->values[k++];\n\t\t\t}\n\t\t}\n\t\treturn m;\n\t}\n\tMatrix operator+(const Matrix & matrix2){\n\t\tMatrix m(this->rows, this->columns);\n\t\tfor(int i = 0; i < m.rows; i++){\n\t\t\tfor(int j = 0; j < m.columns; j++){\n\t\t\t\tm.values[i*m.columns + j] = this->values[i*m.columns + j] + matrix2.values[i*m.columns + j];\n\t\t\t}\n\t\t}\n\t\treturn m;\n\t}\n\tMatrix operator+(T n){\n\t\tMatrix m(this->rows, this->columns);\n\t\tfor(int i = 0; i < m.rows; i++){\n\t\t\tfor(int j = 0; j < m.columns; j++){\n\t\t\t\tm.values[i*m.columns + j] = this->values[i*m.columns + j] + n;\n\t\t\t}\n\t\t}\n\t\treturn m;\n\t}\n\tMatrix operator-(const Matrix & matrix2){\n\t\tMatrix m(this->rows, this->columns);\n\t\tfor(int i = 0; i < m.rows; i++){\n\t\t\tfor(int j = 0; j < m.columns; j++){\n\t\t\t\tm.values[i*m.columns + j] = this->values[i*m.columns + j] - matrix2.values[i*m.columns + j];\n\t\t\t}\n\t\t}\n\t\treturn m;\n\t}\n\tMatrix operator-(T n){\n\t\tMatrix m(this->rows, this->columns);\n\t\tfor(int i = 0; i < m.rows; i++){\n\t\t\tfor(int j = 0; j < m.columns; j++){\n\t\t\t\tm.values[i*m.columns + j] = this->values[i*m.columns + j] - n;\n\t\t\t}\n\t\t}\n\t\treturn m;\n\t}\n\tMatrix operator*(Matrix & matrix2){\n\t\tMatrix m(this->rows, matrix2.columns);\n\t\tfor(int i = 0; i < m.rows; i++){\n\t\t\tfor(int j = 0; j < m.columns; j++){\n\t\t\t\tfor(int k = 0; k < this->columns; k++){\n\t\t\t\t\tm.values[i*m.columns + j] += this->values[i*this->columns + k]*matrix2.values[j + k*this->columns];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn m;\n\t}\n\tMatrix operator*(T n){\n\t\tMatrix m(this->rows, this->columns);\n\t\tfor(int i = 0; i < m.rows; i++){\n\t\t\tfor(int j = 0; j < m.columns; j++){\n\t\t\t\tm.values[i*m.columns + j] = this->values[i*m.columns + j] * n;\n\t\t\t}\n\t\t}\n\t\treturn m;\n\t}\n\tMatrix max(){\n\t\tif(this->rows != 1){\n\t\t\tMatrix m(1, this->columns);\n\t\t\tfor(int i = 0; i < this->columns; i++){\n\t\t\t\tT max = 0;\n\t\t\t\tfor(int j = 0; j < this->rows; j++){\n\t\t\t\t\tif(max < this->values[i + j*this->columns]) max = this->values[i + j*this->columns];\n\t\t\t\t}\n\t\t\t\tm.values[i] = max;\n\t\t\t}\n\t\t\treturn m;\n\t\t}\n\t\telse{\n\t\t\tMatrix m(1, 1);\n\t\t\tT max = 0;\n\t\t\tfor(int i = 0; i < this->columns; i++){\n\t\t\t\tif(max < this->values[i]) max = this->values[i];\n\t\t\t}\n\t\t\tm.values[0] = max;\n\t\t\treturn m;\n\t\t}\n\t}\n\tMatrix min(){\n\t\tif(this->rows != 1){\n\t\t\tMatrix m(1, this->columns);\n\t\t\tfor(int i = 0; i < this->columns; i++){\n\t\t\t\tT min = this->values[i*this->columns];\n\t\t\t\tfor(int j = 0; j < this->rows; j++){\n\t\t\t\t\tif(min > this->values[i + j*this->columns]) min = this->values[i + j*this->columns];\n\t\t\t\t}\n\t\t\t\tm.values[i] = min;\n\t\t\t}\n\t\t\treturn m;\n\t\t}\n\t\telse{\n\t\t\tMatrix m(1, 1);\n\t\t\tT min = this->values[0];\n\t\t\tfor(int i = 0; i < this->columns; i++){\n\t\t\t\tif(min > this->values[i]) min = this->values[i];\n\t\t\t}\n\t\t\tm.values[0] = min;\n\t\t\treturn m;\n\t\t}\n\t}\n\tMatrix sum(){\n\t\tif(this->rows != 1){\n\t\t\tMatrix m(1, this->columns);\n\t\t\tfor(int i = 0; i < this->columns; i++){\n\t\t\t\tT sum = 0;\n\t\t\t\tfor(int j = 0; j < this->rows; j++){\n\t\t\t\t\tsum += this->values[i + j*this->columns];\n\t\t\t\t}\n\t\t\t\tm.values[i] = sum;\n\t\t\t}\n\t\t\treturn m;\n\t\t}\n\t\telse{\n\t\t\tMatrix m(1, 1);\n\t\t\tT sum = 0;\n\t\t\tfor(int i = 0; i < this->columns; i++){\n\t\t\t\tsum += this->values[i];\n\t\t\t}\n\t\t\tm.values[0] = sum;\n\t\t\treturn m;\n\t\t}\n\t}\n};",
            1590208614.661063,
            100,
            "# 答案正确"
        ],
        [
            "6.2 (C++)",
            "莫振威",
            "#include<iostream>\nusing namespace std;\n\ntemplate <typename T>\nclass Matrix{\nprivate:\n\tint rows;\n\tint columns;\n\tT * values;\npublic:\n\tMatrix(int rows, int columns){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tthis->values = new T[rows * columns]();\n\t}\n\t~Matrix(){\n\t\tdelete [] this->values;\n\t}\n\tvoid print(){\n\t\tfor(int i = 0; i < this->rows; i++){\n\t\t\tfor(int j = 0; j < this->columns; j++){\n\t\t\t\tcout << \"    \" << this->values[i * this->columns + j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n};\n",
            1590632138.8087325,
            100,
            "# 答案正确"
        ],
        [
            "7.1 (C++)",
            "莫振威",
            "#include<cmath>\nclass Triangle : public GeometricObject\n{\nprivate:\n\tdouble side1;\n\tdouble side2;\n\tdouble side3;\npublic:\n\tTriangle(){\n\t\tthis->side1 = this->side2 = this->side3 = 1; \n\t}\n\tTriangle(double side1, double side2, double side3){\n\t\tthis->side1 = side1;\n\t\tthis->side2 = side2;\n\t\tthis->side3 = side3;\n\t}\n\tdouble getSide1(){\n\t\treturn side1;\n\t}\n\tdouble getSide2(){\n\t\treturn side2;\n\t}\n\tdouble getSide3(){\n\t\treturn side3;\n\t}\n\tdouble getArea(){\n\t\tdouble s = (side1 + side2 + side3) / 2;\n\t\treturn ::sqrt(s * (s-side1) * (s-side2) * (s-side3));\n\t}\n\tdouble getPerimeter(){\n\t\treturn side1 + side2 + side3;\n\t}\n};",
            1590885495.6806912,
            100,
            "# 答案正确"
        ],
        [
            "7.3 (C++)",
            "莫振威",
            "template <typename A, typename R>\nvector<R> map2(const vector<A> & x, const vector<A> & y, R(*map2_func)(const A &, const A &)){\n\tvector<R> res;\n\tfor(int i = 0; i < x.size(); i++){\n\t\tres.push_back(map2_func(x[i], y[i]));\n\t}\n\treturn res;\n}\ntemplate <typename A, typename R>\nvector<R> map2(const vector<A> & x, const A & y, R(*map2_func)(const A &, const A &)){\n\tvector<R> res;\n\tfor(int i = 0; i < x.size(); i++){\n\t\tres.push_back(map2_func(x[i], y));\n\t}\n\treturn res;\n}\n",
            1590886200.6560237,
            100,
            "# 答案正确"
        ],
        [
            "7.2 (C++)",
            "莫振威",
            "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nvector<string> split(const string & line, const string & delimeter = \" \"){\n\tvector<string> words;\n\tint start = 0;\n\twhile(start < line.size()){\n\t\tint end = line.find(delimeter, start);\n\t\tif(end == start) start += delimeter.size();\n\t\telse{\n\t\t\tif(end == 1){\n\t\t\t\twords.push_back(line.substr(start));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twords.push_back(line.substr(start, end - start));\n\t\t\tstart = end + delimeter.size();\n\t\t}\n\t}\n\treturn words;\n}",
            1591236685.2745023,
            100,
            "# 答案正确"
        ],
        [
            "8.1 (C++)",
            "莫振威",
            "#include <iostream>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n\n\nclass Full : public Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tFull(int rows, int columns){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tthis->values = new double[rows * columns]();\n\t}\t\n\tFull(int rows, int columns, double values[]){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tthis->values = new double[rows * columns]();\n\t\tfor(int i = 0; i < rows; i++){\n\t\t\tfor(int j = 0; j < columns; j++){\n\t\t\t\tthis->values[i * columns + j] = values[i * columns + j];\n\t\t\t}\n\t\t}\n\t}\n\t~Full(){\n\t\tdelete [] this->values;\n\t}\n\tFull(const Matrix & matrix2){\n\t\tthis->rows = matrix2.size(1);\n\t\tthis->columns = matrix2.size(2);\n\t\tthis->values = new double[this->rows * this->columns]();\n\t\tfor(int i = 0; i < rows; i++){\n\t\t\tfor(int j = 0; j < columns; j++){\n\t\t\t\tthis->values[i * columns + j] = matrix2.get(i, j);\n\t\t\t}\n\t\t}\n\t}\n\tint size(int demension) const{\n\t\tif(demension == 1) return this->rows;\n\t\telse return this->columns;\n\t}\n\tvoid set(int row, int column, double value){\n\t\tthis->values[row * this->columns + column] = value;\n\t}\n\tdouble get(int row, int column) const{\n\t\treturn this->values[row * this->columns + column];\n\t}\n\tvoid print() const{\n\t\tfor(int i = 0; i < this->rows; i++){\n\t\t\tfor(int j = 0; j < this->columns; j++){\n\t\t\t\tcout << \"    \" << this->values[i * this->columns + j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tMatrix & operator=(const Matrix & matrix2){\n\t\tif(this->values != NULL) delete [] this->values;\n\t\tthis->rows = matrix2.size(1);\n\t\tthis->columns = matrix2.size(2);\n\t\tthis->values = new double[this->rows * this->columns]();\n\t\tfor(int i = 0; i < rows; i++){\n\t\t\tfor(int j = 0; j < columns; j++){\n\t\t\t\tset(i, j, matrix2.get(i, j));\n\t\t\t}\n\t\t}\n\t\treturn *this;\n\t}\n};\n\n",
            1591836018.09703,
            100,
            "# 答案正确"
        ],
        [
            "8.5 (C++)",
            "莫振威",
            "#include <iostream>\nusing namespace std;\nclass Point3D : public Point2D\n{\nprivate:\n\tdouble z;\npublic:\n\tPoint3D(){\n\t\tsetX(0);\n\t\tsetY(0);\n\t\tz = 0;\n\t}\n\tPoint3D(double x, double y, double z){\n\t\tsetX(x);\n\t\tsetY(y);\n\t\tthis->z = z;\n\t}\n\tdouble getZ(){\n\t\treturn z;\n\t}\n\tdouble distance(Point3D & point3){\n\t\tdouble dx = getX() - point3.getX();\n\t\tdouble dy = getY() - point3.getY();\n\t\tdouble dz = getZ() - point3.getZ();\n\t\treturn sqrt(dx * dx + dy * dy + dz * dz);\n\t}\n};\n\nvoid printDistance(Point3D & point1, Point3D & point2){\n\tcout << \"point1.distance(point2) = \" << \n\t\tpoint1.distance(point2) << endl;\n}",
            1591844044.0750859,
            100,
            "# 答案正确"
        ],
        [
            "8.3 (C++)",
            "莫振威",
            "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nclass Sparse: public Matrix {\nprivate:\n\tint rows, columns;\n\t\npublic:\n\tvector<Entry> p;\n\tSparse() {}\n\tSparse(int r, int c) {\n\t\trows = r;\n\t\tcolumns = c;\n\t\tp.reserve(100);\n\t}\n\tvirtual int size(int dimension) const {\n\t\tif(dimension == 1) return rows;\n\t\telse if(dimension == 2) return columns;\n\t\telse {\n\t\t\tcout << \"Error when getting size\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tvirtual void set(int r, int c, double v) {\n\t\tfor(auto i = p.begin(); i < p.end(); i ++) {\n\t\t\tif(i -> row == r) {\n\t\t\t\tif(i -> column == c) {\n\t\t\t\t\ti -> value = v;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tEntry temp;\n\t\ttemp.row = r;\n\t\ttemp.column = c;\n\t\ttemp.value = v;\n\t\tfor(auto i = p.begin(); i < p.end(); i ++) {\n\t\t\tif(cmp(*i, temp)) {\n\t\t\t\tp.insert(i, temp);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tp.push_back(temp);\n\t}\n\t\n\tvirtual double get(int r, int c) const {\n\t\tfor(auto i = p.begin(); i < p.end(); i ++) {\n\t\t\tif(i -> row == r) {\n\t\t\t\tif(i -> column == c) {\n\t\t\t\t\treturn i -> value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tvirtual void print() {\n\t\tsort(p.begin(), p.end(), cmp);\n\t\tfor(auto i = p.begin(); i < p.end(); i ++) {\n\t\t\tcout << \"(\" << i -> row << \",\" << i -> column;\n\t\t\tcout << \",\" << i -> value << \")\" << endl;\n\t\t}\n\t}\n\n\tSparse operator + (Sparse & sparse2) {\n\t\tsort(p.begin(), p.end(), cmp);\n\t\tsort(sparse2.p.begin(), sparse2.p.end(), cmp);\n\t\tSparse temp(rows, columns);\n\t\tauto pa = p.begin();\n\t\tauto pb = sparse2.p.begin();\n\t\twhile(pa < p.end() && pb < sparse2.p.end()) {\n\t\t\tif(pa -> row == pb -> row && pa -> column == pb -> column) {\n\t\t\t\tEntry t;\n\t\t\t\tt.row = pa -> row;\n\t\t\t\tt.column = pa -> column;\n\t\t\t\tt.value = pa -> value + pb -> value;\n\t\t\t\tif(t.value != 0) temp.p.push_back(t);\n\t\t\t\tpa ++;\n\t\t\t\tpb ++;\n\t\t\t}\n\t\t\telse if(pa -> row > pb -> row || \n\t\t\t(pa -> row == pb -> row && pa -> column > pb -> column)) {\n\t\t\t\ttemp.p.push_back(*pb);\n\t\t\t\tpb ++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttemp.p.push_back(*pa);\n\t\t\t\tpa ++;\n\t\t\t}\n\t\t}\n\t\twhile(pa < p.end()) {\n\t\t\ttemp.p.push_back(*pa);\n\t\t\tpa ++;\n\t\t}\n\t\twhile(pb < sparse2.p.end()) {\n\t\t\ttemp.p.push_back(*pb);\n\t\t\tpb ++;\n\t\t}\n\t\treturn temp;\n\t}\n\n\tstatic bool cmp(Entry a, Entry b) {\n\t\tif(a.row == b.row) {\n\t\t\treturn a.column < b.column;\n\t\t}\n\t\telse return a.row < b.row;\n\t}\n};",
            1591877487.6267838,
            100,
            "# 答案正确"
        ],
        [
            "8.4 (C++)",
            "莫振威",
            "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nclass Sparse: public Matrix {\nprivate:\n\tint rows, columns;\n\t\npublic:\n\tvector<Entry> p;\n\tSparse() {}\n\tSparse(int r, int c) {\n\t\trows = r;\n\t\tcolumns = c;\n\t\tp.reserve(100);\n\t}\n\tvirtual int size(int dimension) const {\n\t\tif(dimension == 1) return rows;\n\t\telse if(dimension == 2) return columns;\n\t\telse {\n\t\t\tcout << \"Error when getting size\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tvirtual void set(int r, int c, double v) {\n\t\tfor(auto i = p.begin(); i < p.end(); i ++) {\n\t\t\tif(i -> row == r) {\n\t\t\t\tif(i -> column == c) {\n\t\t\t\t\ti -> value = v;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tEntry temp;\n\t\ttemp.row = r;\n\t\ttemp.column = c;\n\t\ttemp.value = v;\n\t\tfor(auto i = p.begin(); i < p.end(); i ++) {\n\t\t\tif(cmp(*i, temp)) {\n\t\t\t\tp.insert(i, temp);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tp.push_back(temp);\n\t}\n\t\n\tvirtual double get(int r, int c) const {\n\t\tfor(auto i = p.begin(); i < p.end(); i ++) {\n\t\t\tif(i -> row == r) {\n\t\t\t\tif(i -> column == c) {\n\t\t\t\t\treturn i -> value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tvirtual void print() {\n\t\tsort(p.begin(), p.end(), cmp);\n\t\tfor(auto i = p.begin(); i < p.end(); i ++) {\n\t\t\tcout << \"(\" << i -> row << \",\" << i -> column;\n\t\t\tcout << \",\" << i -> value << \")\" << endl;\n\t\t}\n\t}\n\n\tSparse operator + (Sparse & sparse2) {\n\t\tsort(p.begin(), p.end(), cmp);\n\t\tsort(sparse2.p.begin(), sparse2.p.end(), cmp);\n\t\tSparse temp(rows, columns);\n\t\tauto pa = p.begin();\n\t\tauto pb = sparse2.p.begin();\n\t\twhile(pa < p.end() && pb < sparse2.p.end()) {\n\t\t\tif(pa -> row == pb -> row && pa -> column == pb -> column) {\n\t\t\t\tEntry t;\n\t\t\t\tt.row = pa -> row;\n\t\t\t\tt.column = pa -> column;\n\t\t\t\tt.value = pa -> value + pb -> value;\n\t\t\t\tif(t.value != 0) temp.p.push_back(t);\n\t\t\t\tpa ++;\n\t\t\t\tpb ++;\n\t\t\t}\n\t\t\telse if(pa -> row > pb -> row || \n\t\t\t(pa -> row == pb -> row && pa -> column > pb -> column)) {\n\t\t\t\ttemp.p.push_back(*pb);\n\t\t\t\tpb ++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttemp.p.push_back(*pa);\n\t\t\t\tpa ++;\n\t\t\t}\n\t\t}\n\t\twhile(pa < p.end()) {\n\t\t\ttemp.p.push_back(*pa);\n\t\t\tpa ++;\n\t\t}\n\t\twhile(pb < sparse2.p.end()) {\n\t\t\ttemp.p.push_back(*pb);\n\t\t\tpb ++;\n\t\t}\n\t\treturn temp;\n\t}\n\n\tstatic bool cmp(Entry a, Entry b) {\n\t\tif(a.row == b.row) {\n\t\t\treturn a.column < b.column;\n\t\t}\n\t\telse return a.row < b.row;\n\t}\n\n\n\t\n\tSparse operator * (Sparse & sparse2) {\n\t\tsort(p.begin(), p.end(), cmp);\n\t\tsort(sparse2.p.begin(), sparse2.p.end(), cmp);\n\t\tSparse temp(rows, sparse2.columns);\n\t\tfor(int i = 0; i < p.size(); i ++) {\n\t\t\tint cur_row = p[i].row;\n\t\t\tint row_begin = i;\n\t\t\twhile(cur_row == p[i + 1].row) {\n\t\t\t\ti ++;\n\t\t\t}\n\t\t\tint temp_column[100];\n\t\t\tdouble temp_value[100];\n\t\t\tint nnz = 0;\n\t\t\tmemset(temp_value, 0, sizeof(temp_value));\n\t\t\tmemset(temp_column, 0, sizeof(temp_column));\n\t\t\tfor(int j = row_begin; j <= i; j ++) {\n\t\t\t\tint cur_col = p[j].column;\n\t\t\t\tfor(int k = 0; k < sparse2.p.size(); k ++) {\n\t\t\t\t\tif(sparse2.p[k].row == cur_col) {\n\t\t\t\t\t\tbool exists = false;\n\t\t\t\t\t\tint new_column = sparse2.p[k].column;\n\t\t\t\t\t\tfor(int l = 0; l < nnz; l ++) {\n\t\t\t\t\t\t\tif(temp_column[l] == sparse2.p[k].column) {\n\t\t\t\t\t\t\t\ttemp_value[l] += p[j].value * sparse2.p[k].value;\n\t\t\t\t\t\t\t\texists = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!exists) {\n\t\t\t\t\t\t\ttemp_column[nnz] = sparse2.p[k].column;\n\t\t\t\t\t\t\ttemp_value[nnz] = sparse2.p[k].value * p[j].value;\n\t\t\t\t\t\t\tnnz ++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = 0; j < nnz; j ++) {\n\t\t\t\tEntry t;\n\t\t\t\tt.row = cur_row;\n\t\t\t\tt.column = temp_column[j];\n\t\t\t\tt.value = temp_value[j];\n\t\t\t\ttemp.p.push_back(t);\n\t\t\t}\n\t\t}\n\t\treturn temp;\n\t}\n};",
            1591877632.2861247,
            100,
            "# 答案正确"
        ],
        [
            "8.6 (C++)",
            "莫振威",
            "#include <iostream>\nusing namespace std;\n\nclass MyTensor : public Tensor<double>\n{\nprivate:\n\tdouble * data;\npublic:\n\tMyTensor(vector<int> I) : Tensor(I){\n\t\tint size = 1;\n\t\tfor(int i = 0; i < I.size(); i++){\n\t\t\tsize *= sizes[i];\n\t\t}\n\t\tdata = new double[size]();\n\t}\n\t~MyTensor(){\n\t\tdelete [] data;\n\t}\n\tvirtual double & get(const vector<int> & indexes){\n\t\tint index = 0;\n\t\tfor(int i = 0; i < indexes.size(); i++){\n\t\t\tint num = indexes[i];\n\t\t\tfor(int j = i+1; j < sizes.size(); j++){\n\t\t\t\tnum *= sizes[j];\n\t\t\t}\n\t\t\tindex += num;\n\t\t}\n\t\treturn data[index];\n\t}\n};",
            1592451491.3582654,
            100,
            "# 答案正确"
        ],
        [
            "9.1 (C++)",
            "莫振威",
            "class Circle\n{\nprivate:\n\tdouble data;\npublic:\n\tCircle(double data) : data(data){}\n\tdouble get(){\n\t\treturn this->data;\n\t}\n};\n\nbool operator<(Circle x, Circle y){\n\tif(x.get() < y.get()) return true;\n\telse return false;\n}\nbool operator<=(Circle x, Circle y){\n\tif(x.get() <= y.get()) return true;\n\telse return false;\n}\nbool operator==(Circle x, Circle y){\n\tif(x.get() == y.get()) return true;\n\telse return false;\n}\nbool operator!=(Circle x, Circle y){\n\tif(x.get() != y.get()) return true;\n\telse return false;\n}\nbool operator>(Circle x, Circle y){\n\tif(x.get() > y.get()) return true;\n\telse return false;\n}\nbool operator>=(Circle x, Circle y){\n\tif(x.get() >= y.get()) return true;\n\telse return false;\n}",
            1593073565.5804794,
            100,
            "# 答案正确"
        ],
        [
            "9.2 (C++)",
            "莫振威",
            "class I : public vector<int>\n{\npublic:\n\tI(int size1, int size2, int size3, int size4 = 0){\n\t\tpush_back(size1);\n\t\tpush_back(size2);\n\t\tpush_back(size3);\n\t\tif(size4 != 0) push_back(size4);\n\t}\n};\n",
            1593076929.8134174,
            100,
            "# 答案正确"
        ],
        [
            "9.3 (C++)",
            "莫振威",
            "class Complex\n{\npublic:\n\tdouble r;\n\tdouble i;\n\tComplex(int a, int b){\n\t\tr = (double)a;\n\t\ti = (double)b;\n\t}\n\tComplex(double a, double b){\n\t\tr = a;\n\t\ti = b;\n\t}\n\tdouble real(){\n\t\treturn r;\n\t}\n\tdouble imag(){\n\t\treturn i;\n\t}\n\tComplex operator+=(const Complex & c){\n\t\tthis->r += c.r;\n\t\tthis->i += c.i;\n\t\treturn *this;\n\t}\n\tComplex operator-=(const Complex & c){\n\t\tthis->r -= c.r;\n\t\tthis->i -= c.i;\n\t\treturn *this;\n\t}\n\tComplex operator*=(const Complex & c){\n\t\tdouble r1 = this->r;\n\t\tdouble i1 = this->i;\n\t\tthis->r = r1*c.r - i1*c.i;\n\t\tthis->i = i1*c.r + r1*c.i;\n\t\treturn *this;\n\t}\n\tComplex operator/=(const Complex & c){\n\t\tdouble r1 = this->r;\n\t\tdouble i1 = this->i;\n\t\tdouble d = c.r*c.r + c.i*c.i;\n\t\tthis->r = (r1*c.r + i1*c.i) / d;\n\t\tthis->i = (i1*c.r - r1*c.i) / d;\n\t\treturn *this;\n\t}\n};\n\nComplex operator+(Complex a, Complex b){\n\tComplex temp(a.r+b.r, a.i+b.i);\n\treturn temp;\n}\nComplex operator-(Complex a, Complex b){\n\tComplex temp(a.r-b.r, a.i-b.i);\n\treturn temp;\n}\nComplex operator*(Complex a, Complex b){\n\tComplex temp(a.r*b.r-a.i*b.i, a.i*b.r+a.r*b.i);\n\treturn temp;\n}\nComplex operator/(Complex a, Complex b){\n\tdouble r1 = a.r*b.r+a.i*b.i;\n\tdouble i1 = a.i*b.r-a.r*b.i;\n\tdouble c = b.r*b.r + b.i*b.i;\n\tComplex temp(r1/c, i1/c);\n\treturn temp;\n}\nComplex operator+(int a, Complex b){\n\tComplex temp(a+b.r, b.i);\n\treturn temp;\n}\nComplex operator-(Complex a, int b){\n\tComplex temp(a.r-b, a.i);\n\treturn temp;\n}\nbool operator==(Complex a, Complex b){\n\tif(a.r == b.r && a.i == b.i) return true;\n\telse return false;\n}\nbool operator!=(Complex a, Complex b){\n\tif(a.r != b.r || a.i != b.i) return true;\n\telse return false;\n}",
            1593079356.994101,
            100,
            "# 答案正确"
        ],
        [
            "9.4 (C++)",
            "莫振威",
            "\n\nclass Complex\n{\npublic:\n\tdouble r;\n\tdouble i;\n\tComplex(){}\n\tComplex(double r, double i){\n\t\tthis->r = r;\n\t\tthis->i = i;\n\t}\n};\n\nistream & operator>>(istream & in, Complex & m){\n\tdouble r, i;\n\tin >> r >> i;\n\tComplex tmp(r, i);\n\tm = tmp;\n\treturn in;\n}\n\nostream & operator<< (ostream & out, const Complex & m){\n\tout << m.r << \" + \" << m.i << \" i\";\n\treturn out;\n}\n\nComplex operator+(Complex a, Complex b){\n\tComplex m(a.r+b.r, a.i+b.i);\n\treturn m;\n}\nComplex operator-(Complex a, Complex b){\n\tComplex m(a.r-b.r, a.i-b.i);\n\treturn m;\n}",
            1593080205.6093688,
            100,
            "# 答案正确"
        ],
        [
            "9.5 (C++)",
            "莫振威",
            "class Complex\n{\npublic:\n\tdouble r;\n\tdouble i;\n\tComplex(){}\n\tComplex(double r, double i){\n\t\tthis->r = r;\n\t\tthis->i = i;\n\t}\n\toperator double() const{return r;}\n\tComplex & operator++(){\n\t\tthis->r ++;\n\t\treturn *this;\n\t}\n\tComplex operator++ (int){\n\t\tComplex temp(this->r, this->i);\n\t\tthis->r ++;\n\t\treturn temp;\n\t}\n};\n\nistream & operator>>(istream & in, Complex & m){\n\tdouble r, i;\n\tin >> r >> i;\n\tm = Complex(r, i);\n\treturn in;\n}\n\nostream & operator<< (ostream & out,  Complex & m){\n\tout << m.r << \" + \" << m.i << \" i\";\n\treturn out;\n}",
            1593086047.6511538,
            100,
            "# 答案不正确\n\n# 随机输入:\n8.5\n7.6\n\n\n# 参考答案:\n++ c1 = 9.5 + 7.6 i \nc1 ++ = 9.5 + 7.6 i \nreal = 10.5\n\n\n# 我的答案:\n++ c1 = 9.5 + 7.6 i\nc1 ++ = 9.5\nreal = 10.5\n"
        ],
        [
            "9.6 (C++)",
            "莫振威",
            "class Tensor\n{\nprivate:\n\tvector<int> sizes;\n\tdouble * values;\npublic:\n\tTensor(int a, int b, int c, int d = 0){\n\t\tthis->sizes.push_back(a);\n\t\tthis->sizes.push_back(b);\n\t\tthis->sizes.push_back(c);\n\t\tif(d != 0) {\n\t\t\tthis->sizes.push_back(d);\n\t\t\tvalues = new double[a*b*c*d]();\n\t\t}\n\t\telse{\n\t\t\tvalues = new double[a*b*c];\n\t\t}\n\t}\n\t~Tensor(){\n\t\tdelete [] values;\n\t}\n\tdouble & operator () (int a, int b, int c, int d = 0){\n\t\tint indexes[4];\n\t\tindexes[0] = a; indexes[1] = b; indexes[2] = c; indexes[3] = d;\n\t\tint index = 0;\n\t\tfor(int i = 0; i < this->sizes.size(); i++){\n\t\t\tindex *= sizes[i];\n\t\t\tindex += indexes[i];\n\t\t}\n\t\treturn this->values[index];\n\t}\n};",
            1593081487.7940917,
            100,
            "# 答案正确"
        ],
        [
            "9.7 (C++)",
            "莫振威",
            "class Tensor\n{\npublic:\n\tvector<int> sizes;\n\tvector<double> values;\n\tTensor(){}\n\tTensor(vector<int> sizes){\n\t\tint size = 1;\n\t\tfor(int i = 0; i < sizes.size(); i++){\n\t\t\tthis->sizes.push_back(sizes[i]);\n\t\t\tsize *= sizes[i];\n\t\t}\n\t\tvalues.resize(size);\n\t}\n\t~Tensor(){}\n\tint size() const{\n\t\treturn this->sizes.size();\t\t\n\t}\n\tdouble & operator()(int a, int b, int c, int d = 0){\n\t\tint indexes[4];\n\t\tindexes[0] = a; indexes[1] = b; indexes[2] = c; indexes[3] = d;\n\t\tint index = 0;\n\t\tfor(int i = 0; i < this->sizes.size(); i++){\n\t\t\tindex *= sizes[i];\n\t\t\tindex += indexes[i];\n\t\t}\n\t\treturn this->values[index];\n\t}\n\tconst double & operator()(int a, int b, int c, int d = 0) const {\n\t\tint indexes[4];\n\t\tindexes[0] = a; indexes[1] = b; indexes[2] = c; indexes[3] = d;\n\t\tint index = 0;\n\t\tfor(int i = 0; i < this->sizes.size(); i++){\n\t\t\tindex *= sizes[i];\n\t\t\tindex += indexes[i];\n\t\t}\n\t\treturn this->values[index];\n\t}\n};\n\nistream & operator >> (istream & in, Tensor & m){\n\tint n;\n\tin >> n;\n\tint size[n];\n\tfor(int i = 0; i < n; i++){\n\t\tin >> size[i];\n\t}\n\tvector<int> sizes(size, size+n);\n\tTensor tmp(sizes);\n\tif(sizes.size() == 3){\n\t\tfor(int i = 0; i < size[0]; i++){\n\t\t\tfor(int j = 0; j < size[1]; j++){\n\t\t\t\tfor(int k = 0; k < size[2]; k++){\n\t\t\t\t\tin >> tmp(i,j,k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse if(sizes.size() == 4){\n\t\tfor(int i = 0; i < size[0]; i++){\n\t\t\tfor(int j = 0; j < size[1]; j++){\n\t\t\t\tfor(int k = 0; k < size[2]; k++){\n\t\t\t\t\tfor(int l = 0; l < size[3]; l++)\n\t\t\t\t\t\tin >> tmp(i,j,k,l);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tm = tmp;\n\treturn in;\n}\n\nostream & operator << (ostream & out, const Tensor & m){\n\tout << m.size() << endl;\n\tfor(int i = 0; i < m.size(); i++){\n\t\tout << m.sizes[i] << \" \";\n\t}\n\tcout << endl << endl;\n\tif(m.size() == 3){\n\t\tfor(int i = 0; i < m.sizes[0]; i++){\n\t\t\tfor(int j = 0; j < m.sizes[1]; j++){\n\t\t\t\tfor(int k = 0; k < m.sizes[2]; k++){\n\t\t\t\t\tout << m(i,j,k) << \" \";\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\t cout << endl;\n\t\t}\n\t}\n\telse if(m.size() == 4){\n\t\tfor(int i = 0; i < m.sizes[0]; i++){\n\t\t\tfor(int j = 0; j < m.sizes[1]; j++){\n\t\t\t\tfor(int k = 0; k < m.sizes[2]; k++){\n\t\t\t\t\tfor(int l = 0; l < m.sizes[3]; l++){\n\t\t\t\t\t\tout << m(i,j,k,l) << \" \";\n\t\t\t\t\t}\n\t\t\t\t\tcout << endl;\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\treturn out;\n}\n",
            1593089570.7374895,
            100,
            "# 答案不正确\n\n# 随机输入:\n3\n4 2 2\n\n8.7 6.2 \n6.7 2.2 \n\n2.2 7.3 \n7.8 2.7 \n\n5.9 6.1 \n9.3 5.1 \n\n7.2 5.6 \n3.6 7.5 \n\n4\n3 4 2 2\n\n4.2 6.8 \n4.6 7.2 \n\n3.3 6.6 \n3.2 2.4 \n\n9.5 6.7 \n2.6 9.2 \n\n6.1 9.2 \n8.1 8.9 \n\n5.1 8.4 \n8.0 1.8 \n\n4.1 8.3 \n6.8 8.6 \n\n2.1 8.0 \n9.1 3.5 \n\n1.2 9.8 \n1.7 2.4 \n\n3.6 6.5 \n9.3 3.9 \n\n2.5 8.6 \n8.8 1.2 \n\n1.6 7.4 \n3.0 2.9 \n\n5.1 2.1 \n9.8 6.5 \n\n\n# 参考答案:\n3\n4 2 2 \n\n8.7 6.2 \n6.7 2.2 \n\n2.2 7.3 \n7.8 2.7 \n\n5.9 6.1 \n9.3 5.1 \n\n7.2 5.6 \n3.6 7.5 \n\n\n4\n3 4 2 2 \n\n4.2 6.8 \n4.6 7.2 \n\n3.3 6.6 \n3.2 2.4 \n\n9.5 6.7 \n2.6 9.2 \n\n6.1 9.2 \n8.1 8.9 \n\n5.1 8.4 \n8 1.8 \n\n4.1 8.3 \n6.8 8.6 \n\n2.1 8 \n9.1 3.5 \n\n1.2 9.8 \n1.7 2.4 \n\n3.6 6.5 \n9.3 3.9 \n\n2.5 8.6 \n8.8 1.2 \n\n1.6 7.4 \n3 2.9 \n\n5.1 2.1 \n9.8 6.5 \n\n\n\n\n# 我的答案:\n3\n4 2 2 \n\n8.7 6.2 \n6.7 2.2 \n\n2.2 7.3 \n7.8 2.7 \n\n5.9 6.1 \n9.3 5.1 \n\n7.2 5.6 \n3.6 7.5 \n\n\n4\n3 4 2 2 \n\n4.2 6.8 \n4.6 7.2 \n\n3.3 6.6 \n3.2 2.4 \n\n9.5 6.7 \n2.6 9.2 \n\n6.1 9.2 \n8.1 8.9 \n\n\n5.1 8.4 \n8 1.8 \n\n4.1 8.3 \n6.8 8.6 \n\n2.1 8 \n9.1 3.5 \n\n1.2 9.8 \n1.7 2.4 \n\n\n3.6 6.5 \n9.3 3.9 \n\n2.5 8.6 \n8.8 1.2 \n\n1.6 7.4 \n3 2.9 \n\n5.1 2.1 \n9.8 6.5 \n\n\n\n"
        ],
        [
            "10.1 (C++)",
            "莫振威",
            "#include <stdexcept>\n\ndouble Matrix::get(int row, int column) const{\n    if(row > size(1) || column > size(2)) throw out_of_range(\"\");\n    return elements[row * size(2) + column];\n}\n\nvoid Matrix::set(int row, int column, double value){\n    if(row > size(1) || column > size(2)) throw out_of_range(\"\");\n    elements[row * size(2) + column] = value;\n}\n\nclass MatrixSizesDoNotMatchException{};\n\nMatrix Matrix::operator+(const Matrix & matrix2) const{\n    if(matrix2.size(1) != this->size(1) || matrix2.size(2) != this->size(2)) throw MatrixSizesDoNotMatchException();\n    Matrix m(this->size(1), this->size(2));\n    for(int i = 0; i < this->size(1); i++){\n        for(int j = 0; j < this->size(2); j++){\n            m.set(i+1, j+1, matrix2.get(i+1,j+1)+this->get(i+1,j+1));\n        }\n    }\n    return m;\n}\n",
            1593582083.9057214,
            100,
            "# 答案正确"
        ],
        [
            "10.2 (C++)",
            "莫振威",
            "catch(NonPositiveValueException & ex){\n\t\t\tcout << \"caught: \" << \"NonPositiveValueException\" << endl;\n\t\t}\n\t\tcatch(out_of_range & ex){\n\t\t\tcout << \"caught: \" << \"out_of_range\" << endl;\n\t\t}",
            1593655940.1603727,
            100,
            "# 答案正确"
        ],
        [
            "2020-07-09 LAB",
            "莫振威",
            "#include <iostream>\nusing namespace std;\n\nclass Integer\n{\nprivate:\n\tstatic int size;\n\tstatic Integer * a[20];\n\tint value;\npublic:\n\tInteger() : value(0) { a[size++] = this;}\n\tInteger(int value){ \n\t\tthis->value = value;\n\t\ta[size++] = this;\n\t}\n\tint & get(){ return value;}\n\tconst int & get() const{ return value;}\n\tvoid increase_value(int n){\n\t\tvalue += n;\n\t}\n\tstatic void increase_all(Integer va){\n\t\tfor(int i = 0; i < size; i++){\n\t\t\ta[i]->increase_value(va.get());\n\t\t}\n\t}\n};\n\nInteger * Integer::a[20];\nint Integer::size = 0;\n\nistream & operator >> (istream & in, Integer & m){\n\tint value;\n\tin >> value;\n\tInteger tmp(value);\n\tm = tmp;\n\treturn in;\n}\n\nostream & operator << (ostream & out, const Integer & m){\n\tout << m.get();\n\treturn out;\n}",
            1594264249.902174,
            100,
            "# 答案正确"
        ],
        [
            "15.1 (C++)",
            "莫振威",
            "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nclass Table\n{\nprivate:\n\tvector<string> headers;\n\tvector<vector<string>> rows;\n\tint numOfRows;\npublic:\n\tTable() : numOfRows(0) {}\n\tvoid addCol(string s){\n\t\theaders.push_back(s);\n\t}\n\tvector<string> & operator [] (const int n){\n\t\tif(n >= numOfRows){\n\t\t\tnumOfRows = n + 2;\n\t\t\trows.resize(n + 2);\n\t\t}\n\t\treturn rows[n];\n\t}\n\tstring json() const{\n\t\tstring str;\n\t\tstr += \"{\\n\\theaders: [\";\n\t\tfor(int i = 0; i < headers.size(); i++){\n\t\t\tstr = str + \"'\" + headers[i] + \"'\" + \",\";\n\t\t}\n\t\tstr += \"],\\n\\trows: [\\n\";\n\t\tfor(int i = 0; i < numOfRows; i++){\n\t\t\tstr += \"\\t\\t[\";\n\t\t\tfor(int j = 0; j < rows[i].size(); j++){\n\t\t\t\tstr = str + \"'\" + rows[i][j] + \"'\" + \",\";\n\t\t\t}\n\t\t\tstr += \"],\\n\";\n\t\t}\n\t\tstr += \"\\t],\\n}\\n\";\n\t\treturn str;\n\t}\t\n};",
            1594297943.506191,
            100,
            "# 答案正确"
        ],
        [
            "A.2 (C++)",
            "莫振威",
            "template <class E>\nvoid LinkedList<E>::removeAll(const E & e){\n\tI(i, _size){\n\t\tint index = indexOf(e);\n\t\tif (index == -1)\n\t\t\tbreak;\n\t\tremove(index);\n\t}\n}",
            1594867450.0502734,
            100,
            "# 答案正确"
        ],
        [
            "A.1 (C++)",
            "莫振威",
            "private:\n\tNode<E> * get_node(int index) const{\n\t\tif(index < -1 || index > _size)\n\t\t\tthrow NotSuchElementException();\n\t\tif(index == -1 || index == _size) return 0;\n\t\tif(index < _size / 2){\n\t\t\tif(index == 0) return head;\n\t\t\tNode<E> * n1 = head;\n\t\t\tNode<E> * n2 = head->next_node(0);\n\t\t\tI(i, index-1) {\n\t\t\t\tNode<E> * temp = n2;\n\t\t\t\tn2 = n2->next_node(n1);\n\t\t\t\tn1 = temp;\n\t\t\t}\n\t\t\treturn n2;\n\t\t}\n\t\telse{\n\t\t\tif(index == _size - 1) return tail;\n\t\t\tNode<E> * n1 = tail;\n\t\t\tNode<E> * n2 = tail->prev_node(0);\n\t\t\tI(i, (_size-2-index)) {\n\t\t\t\tNode<E> * temp = n2;\n\t\t\t\tn2 = n2->prev_node(n1);\n\t\t\t\tn1 = temp;\n\t\t\t} \n\t\t\treturn n2;\n\t\t}\n\t}\npublic:\n\tE & get(int index) const{\n\t\tNode<E> * node = get_node(index);\n\t\treturn node->element;\n\t}\n\tvoid set(int index, const E & e){\n\t\tNode<E> * node = get_node(index);\n\t\tnode->element = e;\n\t}\n\tE & getFirst() const {\n\t\treturn get(0);\n\t}\n\n\tE & getLast() const {\n\t\treturn get(_size - 1);\n\t}\n\n\tvoid remove(int index){\n\t\tNode<E> * node = get_node(index);\n\t\tNode<E> * prev_node = get_node(index-1);\n\t\tNode<E> * next_node = get_node(index+1);\n\t\tif(prev_node != 0) prev_node->update_next_node(node, next_node);\n\t\tif(next_node != 0) next_node->update_prev_node(node, prev_node);\n\t\tif(prev_node == 0) head = next_node;\n\t\tif(next_node == 0) tail = prev_node;\n\t\tdelete node;\n\t\t--_size;\n\t}\n\tvoid removeFirst () {\n\t\tremove(0);\n\t}\n\n\tvoid removeLast () {\n\t\tremove(_size-1);\n\t}\n\tvoid add(int index, const E & e) {\n\t\tif (index < 0 || index > _size){ \n\t\t\tthrow NotSuchElementException();\n\t\t}\n\t\tNode<E> * node = new Node<E>();\n\t\tnode->element = e;\n\n\t\tNode<E> * next_node = (index == _size ? 0 : get_node(index));\n\t\tNode<E> * prev_node = (next_node == 0 ? tail : get_node(index-1));\n\t\tnode->update_prev_and_next_node(prev_node,next_node);\n\t\tif (prev_node != 0) prev_node->update_next_node(next_node, node);\n\t\tif (next_node != 0) next_node->update_prev_node(prev_node, node);\n\t\tif (prev_node == 0) head = node;\n\t\tif (next_node == 0) tail = node;\n\t\t++_size;\n\t}\n\tvoid addFirst (const E & e) {\n\t\tadd(0, e);\n\t}\n\n\tvoid addLast (const E & e) {\n\t\tadd(_size, e);\n\t}\n\n\tvoid clear() {\n\t\twhile (_size > 0) removeFirst();\n\t}\n\n\tvoid addAll(const LinkedList & list, int index=-1) {\n\t\tif (index == -1) index = _size;\n\t\tI(i, list._size) {\n\t\t\tNode<E> * node = list.get_node(i);\n\t\t\tadd(index + i, node->element);\n\t\t}\n\t}\n\tLinkedList(const LinkedList & list) : _size(0), head(0), tail(0) {\n\t\taddAll(list);\n\t}\n\tLinkedList & operator = (const LinkedList & list) {\n\t\tclear();\n\t\taddAll(list);\n\t\treturn *this;\n\t}\n\t~LinkedList() {\n\t\tclear();\n\t}\n\tint indexOf(const E & e) const{\n\t\tNode<E> * n1 = head;\n\t\tNode<E> * n2 = head->next_node(0);\n\t\tif(n1->element == e) return 0;\n\t\tI(i, _size-1){\n\t\t\tif(n2->element == e) return i+1;\n\t\t\tNode<E> * temp = n2;\n\t\t\tn2 = n2->next_node(n1);\n\t\t\tn1 = temp;   \n\t\t}\n\t\treturn -1;\n\t}\n\tbool contains(const E & e) const {\n\t\treturn indexOf(e) >= 0;\n\t}\n\tvoid removeFirstOccurrence(const E & e) {\n\t\tint index = indexOf(e);\n\t\tif (index == -1)\n\t\t\tthrow NotSuchElementException();\n\t\tremove(index);\n\t}\n\tvoid removeLastOccurrence(const E & e) {\n\t\tint index = lastIndexOf(e);\n\t\tif (index == -1)\n\t\t\tthrow NotSuchElementException();\n\t\tremove(index);\n\t}",
            1594888074.4243312,
            100,
            "# 答案正确"
        ],
        [
            "A.3 (C++)",
            "莫振威",
            "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <stdexcept>\nusing namespace std;\n\n#define I(i,n) for (size_t i = 0; i < n; ++ i)\n\nclass NoSuchKeyException {};\n\nsize_t circular_shift(size_t bits, int shift_bits) {\n\tconst int num_bits = 8 * sizeof(size_t);\n\tshift_bits = shift_bits % num_bits;\n\treturn bits << shift_bits | bits >> (num_bits - shift_bits);\n}\n\nsize_t hash_function(const int & key) {\n\tsize_t code = 0;\n\tint temp = key;\n\tfor(int i = 0; temp != 0;++i){\n\t\tcode ^= circular_shift(temp % 10, i * 5);\n\t\ttemp /= 10;\n\t}\t\n\treturn code;\n}\n\ntemplate <typename V>\nclass HT\n{\n\tclass Tuple\n\t{\n\tpublic:\n\t    int key;\n\t\tV val;\n\t\tbool in_use;\n\n\t\tTuple() : in_use(false) {}\n\t};\n\n\tvector<Tuple> tuples;\n\tsize_t _size;\n\n\tsize_t canonical_index(const int & key) const {\n\t\tsize_t hash_code = hash_function(key); // needs hash_function(K)\n\t\treturn hash_code % tuples.size();\n\t}\n\n\t// the returned tuple is either empty or with the same key\n\tsize_t indexOfKey(const int & key) const {\n\t\tsize_t index = canonical_index(key);\n\t\twhile (true) { // will enter a dead loop if there is not empty tuple\n\t\t\tif (! tuples[index].in_use) return index;\n\t\t\tif (tuples[index].key == key) return index;\n\t\t\tindex = (index + 1) % tuples.size();\n\t\t}\n\t}\n\npublic:\n\tHT() : _size(0) {\n\t\ttuples.resize(2000);\n\t}\n\n\tbool containsKey(const int & key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\treturn tuples[index].in_use;\n\t}\n\n\tconst V & operator [] (const int & key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples[index].val;\n\t}\n\n\tV & operator [] (const int & key) {\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples[index].val;\n\t}\n\n\tvoid put(const int & key, const V & val) {\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].key = key;\n\t\ttuples[index].val = val;\n\t\tif (tuples[index].in_use) return;\n\t\ttuples[index].in_use = true;\n\t\t++ _size;\n\t\t// make sure empty > size / 2\n\t\tif (2 * _size > tuples.size())\n\t\t\t_double_tuples();\n\t}\n\n\tvoid _double_tuples() {\n\t\tvector<Tuple> non_empty_tuples;\n\t\tI(i, tuples.size())\n\t\t\tif (tuples[i].in_use)\n\t\t\t\tnon_empty_tuples.push_back(tuples[i]);\n\t\tclear();\n\t\ttuples.resize(tuples.size() * 2);\n\t\tI(i, non_empty_tuples.size())\n\t\t\tput(non_empty_tuples[i].key, non_empty_tuples[i].val);\n\t}\n\n\tstatic bool _between(size_t hole, size_t canonical, size_t tuple_index) {\n\t\tif (hole < tuple_index)\n\t\t\treturn canonical > hole && canonical <= tuple_index;\n\t\telse\n\t\t\treturn canonical > hole || canonical <= tuple_index;\n\t}\n\n\tvoid remove(const int & key) { \n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\ttuples[index].in_use = false;\n\t\t-- _size;\n\t\t// if there is a hole between a tuple and its canonical position\n\t\t// move the tuple to the hole\n\t\tsize_t hole = index;\n\t\tsize_t tuple_index = hole;\n\t\twhile (true) {\n\t\t\ttuple_index = (tuple_index + 1) % tuples.size();\n\t\t\tif (! tuples[tuple_index].in_use) return;\n\t\t\tsize_t canonical = canonical_index(tuples[tuple_index].key);\n\t\t\tif (_between(hole, canonical, tuple_index)) continue;\n\t\t\ttuples[hole] = tuples[tuple_index];\n\t\t\thole = tuple_index;\n\t\t\ttuples[hole].in_use = false;\n\t\t}\n\t}\n\n\tsize_t size() const { return _size; }\n\n\tvoid clear() {\n\t\tI(i, tuples.size())\n\t\t\ttuples[i].in_use = false;\n\t\t_size = 0;\n\t}\n\tvector<int> getKeys(){\n\t\tvector<int> keys;\n\t\tfor(int i = 0; i < tuples.size();++i){\n\t\t\tif(tuples[i].in_use){\n\t\t\t\tkeys.push_back(tuples[i].key);\n\t\t\t}\n\t\t}\n\t\treturn keys;\n\t}\n};",
            1595474541.598842,
            100,
            "# 答案正确"
        ],
        [
            "A.4 (C++)",
            "莫振威",
            "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <stdexcept>\nusing namespace std;\n\n#define I(i,n) for (size_t i = 0; i < n; ++ i)\n\nclass NoSuchKeyException {};\n\nsize_t circular_shift(size_t bits, int shift_bits) {\n\tconst int num_bits = 8 * sizeof(size_t);\n\tshift_bits = shift_bits % num_bits;\n\treturn bits << shift_bits | bits >> (num_bits - shift_bits);\n}\n\nsize_t hash_function(const int & key) {\n\tsize_t code = 0;\n\tint num = key;\n\tfor(int i = 0; num > 0; i ++) {\n\t\tcode ^= circular_shift(num % 10, i * 5);\n\t\tnum /= 10;\n\t}\n\treturn code;\n}\n\nsize_t hash_function(const string & key) {\n\tsize_t code = 0;\n\tI(i, key.size()) {\n\t\tcode ^= circular_shift(key[i], i * 5);\n\t}\n\treturn code;\n}\n\nclass HT {\n\tclass Tuple {\n\tpublic:\n\t\tstring str_key;\n\t\tstring str_val;\n\t\tbool str_in_use;\n\n\t\tint int_key;\n\t\tint int_val;\n\t\tbool int_in_use;\n\n\t\tTuple(): str_in_use(false), int_in_use(false) {}\n\t};\n\n\tclass str_int {\n\tpublic:\n\t\tHT * hash_table;\n\t\tTuple * tuple;\n\t\tstring str_key;\n\t\tint int_key;\n\n\t\tstr_int(HT * ht, Tuple * tp, string str_key): hash_table(ht), tuple(tp), str_key(str_key) {}\n\n\t\tstr_int(HT * ht, Tuple * tp, int int_key): hash_table(ht), tuple(tp), int_key(int_key) {}\n\n\t\toperator string() {return tuple->str_val;}\n\n\t\toperator int() {return tuple->int_val;}\n\t};\n\n\tvector<Tuple> tuples;\n\tsize_t _size;\n\n\ttemplate <typename K>\n\tsize_t canonical_index(const K & key) const {\n\t\tsize_t hash_code = hash_function(key);\n\t\treturn hash_code % tuples.size();\n\t}\n\n\tsize_t indexOfKey(const string & key) const {\n\t\tsize_t index = canonical_index(key);\n\t\twhile(true) {\n\t\t\tif(!tuples[index].str_in_use) return index;\n\t\t\tif(tuples[index].str_key == key) return index;\n\t\t\tindex = (index + 1) % tuples.size();\n\t\t}\n\t}\n\n\tsize_t indexOfKey(const int & key) const {\n\t\tsize_t index = canonical_index(key);\n\t\twhile(true) {\n\t\t\tif(!tuples[index].int_in_use) return index;\n\t\t\tif(tuples[index].int_key == key) return index;\n\t\t\tindex = (index + 1) % tuples.size();\n\t\t}\n\t}\npublic:\n\tHT() : _size(0) {\n\t\ttuples.resize(20);\n\t}\n\n\ttemplate <typename K>\n\tstr_int operator[] (const K & key) {\n\t\tsize_t index = indexOfKey(key);\n\t\tif(!tuples[index].int_in_use && !tuples[index].str_in_use) return str_int(this, NULL, key);\n\t\treturn str_int(this, &tuples[index], key);\n\t}\n\n\ttemplate <typename K>\n\tconst str_int operator[] (const K & key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\tif(!tuples[index].int_in_use && !tuples[index].str_in_use) return str_int(this, NULL, key);\n\t\treturn str_int(this, &tuples[index], key);\n\t}\n\n\tstring To_string(int value) {\n\t\tint num = value;\n\t\tstring s;\n\t\tfor(int i = 0; num > 0; i ++) {\n\t\t\ts += num % 10;\n\t\t\tnum /= 10;\n\t\t}\n\t\treturn s;\n\t}\n\n\tvoid put(const string & key, string & value) {\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].str_key = key;\n\t\ttuples[index].str_val = value;\n\t\tif(tuples[index].str_in_use) return;\n\t\ttuples[index].str_in_use = true;\n\t\t_size ++;\n\t\tif(2 * _size > tuples.size()) _double_tuples();\n\t}\n\n\tvoid put(const string & key, int & value) {\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].str_key = key;\n\t\ttuples[index].int_val = value;\n\t\ttuples[index].str_val = To_string(value);\n\t\tif(tuples[index].str_in_use) return;\n\t\ttuples[index].str_in_use = true;\n\t\t_size ++;\n\t\tif(2 * _size > tuples.size()) _double_tuples();\n\t}\n\n\tvoid put(int key, string & value) {\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].int_key = key;\n\t\ttuples[index].str_val = value;\n\t\tif(tuples[index].int_in_use) return;\n\t\ttuples[index].int_in_use = true;\n\t\t_size ++;\n\t\tif(2 * _size > tuples.size()) _double_tuples();\n\t}\n\n\tvoid put(int key, int & value) {\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].int_key = key;\n\t\ttuples[index].int_val = value;\n\t\ttuples[index].str_val = To_string(value);\n\t\tif(tuples[index].int_in_use) return;\n\t\ttuples[index].int_in_use = true;\n\t\t_size ++;\n\t\tif(2 * _size > tuples.size()) _double_tuples();\n\t}\n\n\tvoid _double_tuples() {\n\t\tvector<Tuple> non_empty_tuples;\n\t\tI(i, tuples.size()) {\n\t\t\tif(tuples[i].str_in_use || tuples[i].int_in_use) \n\t\t\t\tnon_empty_tuples.push_back(tuples[i]);\n\t\t}\n\t\tclear();\n\t\ttuples.resize(tuples.size() * 2);\n\t\tI(i, non_empty_tuples.size()) {\n\t\t\tif(non_empty_tuples[i].str_in_use) \n\t\t\t\tput(non_empty_tuples[i].str_key, non_empty_tuples[i].str_val);\n\t\t\tif(non_empty_tuples[i].int_in_use) \n\t\t\t\tput(non_empty_tuples[i].int_key, non_empty_tuples[i].int_val);\n\t\t}\n\t}\n\tsize_t size() const { return _size; }\n\n\tvoid clear() {\n\t\tI(i, tuples.size()){\n\t\t\ttuples[i].str_in_use = false;\n\t\t\ttuples[i].int_in_use = false;\n\t\t}\n\t\t_size = 0;\n\t}\n};",
            1595848891.401999,
            100,
            "# 答案正确"
        ],
        [
            "A.5 (C++)",
            "莫振威",
            "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <stdexcept>\nusing namespace std;\n\nclass NoSuchKeyException {};\nclass NoSuchValueException {};\n\nsize_t circular_shift(size_t bits, int shift_bits){\n\tconst int num_bits = 8 * sizeof(size_t);\n\tshift_bits = shift_bits % num_bits;\n\treturn bits << shift_bits | bits >> (num_bits - shift_bits);\n}\n\nsize_t hash_funtion(const string & key){\n\tsize_t code = 0;\n\tfor(int i = 0; i <  key.size(); i++){\n\t\tcode ^= circular_shift(key[i], i * 5);\n\t}\n\treturn code;\n}\n\nsize_t hash_funtion(const int & key){\n\tsize_t code = 0;\n\tint num = key;\n\tfor(int i = 0; num > 0; i++){\n\t\tcode ^= circular_shift(num % 10, i * 5);\n\t\tnum /= 10; \n\t}\n\treturn code;\n}\n\nclass HT\n{\n\tclass Tuple\n\t{\n\tpublic:\n\t\tstring str_key;\n\t\tstring str_val;\n\t\tbool str_use;\n\n\t\tint int_key;\n\t\tint int_val;\n\t\tint int_use;\n\n\t\tTuple() : str_use(false), int_use(false) {}\n\t};\n\n\tclass TupleRef {\n\tpublic:\n\t\tHT * ht;\n\t\tTuple * tp;\n\t\tstring str_key;\n\t\tint int_key;\n\n\t\tTupleRef(HT * ht, Tuple * tp, string str_key): ht(ht), tp(tp), str_key(str_key) {}\n\n\t\tTupleRef(HT * ht, Tuple * tp, int int_key): ht(ht), tp(tp), int_key(int_key) {}\n\n\t\toperator string() {\n\t\t\tif(tp == NULL) throw NoSuchKeyException();\n\t\t\treturn tp->str_val;\n\t\t}\n\n\t\toperator int() {\n\t\t\tif(tp == NULL) throw NoSuchValueException();\n\t\t\treturn tp->int_val;\n\t\t}\n\n\t\tTupleRef & operator= (const int & val){\n\t\t\ttp->int_val = val;\n\t\t\treturn *this;\n\t\t}\n\t\tTupleRef & operator= (const string & val){\n\t\t\ttp->str_val = val;\n\t\t\treturn *this;\n\t\t}\n\t};\n\n\tvector<Tuple> tuples;\n\tsize_t _size;\n\n\ttemplate <typename K>\n\tsize_t canonical_index(const K & key) const{\n\t\tsize_t hash_code = hash_funtion(key);\n\t\treturn hash_code % tuples.size();\n\t}\n\n\tsize_t indexOfKey(const string & key) const{\n\t\tsize_t index = canonical_index(key);\n\t\twhile (true){\n\t\t\tif(!tuples[index].str_use) return index;\n\t\t\tif(tuples[index].str_key == key) return index;\n\t\t\tindex = (index + 1) % tuples.size();\n\t\t}\n\t}\n\n\tsize_t indexOfKey(const int & key) const{\n\t\tsize_t index = canonical_index(key);\n\t\twhile(true){\n\t\t\tif(!tuples[index].str_use) return index;\n\t\t\tif(tuples[index].int_key == key) return index;\n\t\t\tindex = (index + 1) % tuples.size();\n\t\t}\n\t}\n\npublic:\n\tHT() : _size(0) {\n\t\ttuples.resize(40);\n\t}\n\n\tsize_t size() {return _size; }\n\n\tvoid put(const string & key, string & val){\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].str_key = key;\n\t\ttuples[index].str_val = val;\n\t\tif(tuples[index].str_use) return;\n\t\ttuples[index].str_use = true;\n\t\t_size++;\n\t\tif(2 * _size > tuples.size()) _double_tuples(); \n \t}\n\tvoid put(const string & key, int & val){\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].str_key = key;\n\t\ttuples[index].int_val = val;\n\t\tif(tuples[index].str_use) return;\n\t\ttuples[index].str_use = true;\n\t\t_size++;\n\t\tif(2 * _size > tuples.size()) _double_tuples(); \n \t}\n\tvoid put(const int & key, string & val){\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].int_key = key;\n\t\ttuples[index].str_val = val;\n\t\tif(tuples[index].int_use) return;\n\t\ttuples[index].int_use = true;\n\t\t_size++;\n\t\tif(2 * _size > tuples.size()) _double_tuples(); \n \t}\n\tvoid put(const int & key, int & val){\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].int_key = key;\n\t\ttuples[index].int_val = val;\n\t\tif(tuples[index].int_use) return;\n\t\ttuples[index].int_use = true;\n\t\t_size++;\n\t\tif(2 * _size > tuples.size()) _double_tuples(); \n \t}\n\t\n\tTupleRef operator[] (int key) {\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].int_key = key;\n\t\tif(tuples[index].int_use) return TupleRef(this, &tuples[index], key);\n\t\ttuples[index].int_use = true;\n\t\t_size ++;\n\t\tif(2 * _size > tuples.size()) _double_tuples();\n\t\treturn TupleRef(this, &tuples[index], key);\n\t}\n\tTupleRef operator[] (string key) {\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].str_key = key;\n\t\tif(tuples[index].str_use) return TupleRef(this, &tuples[index], key);\n\t\ttuples[index].str_use = true;\n\t\t_size ++;\n\t\tif(2 * _size > tuples.size()) _double_tuples();\n\t\treturn TupleRef(this, &tuples[index], key);\n\t}\n\n\tvoid _double_tuples() {\n\t\tvector<Tuple> non_empty_tuples;\n\t\tfor(int i = 0; i < tuples.size(); i++){\n\t\t\tif(tuples[i].str_use || tuples[i].int_use){\n\t\t\t\tnon_empty_tuples.push_back(tuples[i]);\n\t\t\t}\n\t\t}\n\t\tclear();\n\t\ttuples.resize(2 * tuples.size());\n\t\tfor(int i = 0; i < non_empty_tuples.size(); i++){\n\t\t\tif(non_empty_tuples[i].str_use) {\n\t\t\t\tput(non_empty_tuples[i].str_key, non_empty_tuples[i].str_val);\n\t\t\t}\n\t\t\tif(non_empty_tuples[i].int_use) {\n\t\t\t\tput(non_empty_tuples[i].int_key, non_empty_tuples[i].int_val);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid clear(){\n\t\tfor(int i = 0; i < tuples.size(); i++){\n\t\t\ttuples[i].str_use = false;\n\t\t\ttuples[i].int_use = false;\n\t\t}\n\t\t_size = 0;\n\t}\n};\n\n\n",
            1595865213.1960166,
            100,
            "# 答案正确"
        ]
    ],
    "table_name": "答案"
}