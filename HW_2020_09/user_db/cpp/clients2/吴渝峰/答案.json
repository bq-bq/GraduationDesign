{
    "__update_time__": 1595913334.7512913,
    "field_names": [
        "题目名",
        "用户名",
        "答案",
        "提交时间",
        "分数",
        "评语"
    ],
    "field_types": [
        "text",
        "text",
        "text",
        "time",
        "number",
        "text"
    ],
    "foreign_keys": {},
    "primary_keys": [],
    "rows": [
        [
            "测试1",
            "吴渝峰",
            "#include <iostream>\nusing namespace std;\n\nint main() {\n\tstring a1, a2, a3;\n\tcin >> a1 >> a2 >> a3;\n\tcout << a3 << \" \" << a2 << \" \" << a1 << endl;\n\treturn 0;\n}",
            1587520504.0,
            100,
            "# 答案正确"
        ],
        [
            "测试2",
            "吴渝峰",
            "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint main() {\n\tchar words[10][20];\n\tfor (int i = 0; i < 10; ++ i)\n\t\tcin >> words[i];\n    for(int i = 0; i < 10; ++ i) {\n        for(int j = 0; j < 9; ++ j) {\n            if(strcmp(words[j],words[j + 1]) > 0) {\n                swap(words[j],words[j + 1]);\n            }\n        }\n    }\n\tfor (int i = 0; i < 10; ++ i) \n\t\tcout << words[i] << \" \";\n\treturn 0;\n}",
            1587609166.9007704,
            100,
            "# 答案正确"
        ],
        [
            "1.1 (C++)",
            "吴渝峰",
            "class Matrix5x5 {\npublic:\n\tdouble a[5][5];\n\tMatrix5x5() {\n\t\tfor (int i = 0; i < 5; ++ i) {\n\t\t\tfor(int j = 0; j < 5; ++ j) {\n\t\t\t\ta[i][j] = 0;\n\t\t\t}\n\t\t} \n\t}\n\tdouble get(int row, int col) {\n\t\treturn a[row][col];\n\t}\n\tvoid set(int row, int col, double x) {\n\t\ta[row][col] = x;\n\t}\n};\n\nMatrix5x5 operator + (Matrix5x5 & s1, Matrix5x5 & s2) {\n\tMatrix5x5 ans;\n\tfor(int i = 0; i < 5; ++ i) {\n\t\tfor(int j = 0; j < 5; ++ j) {\n\t\t\tans.a[i][j] = s1.a[i][j] + s2.a[i][j];\n\t\t}\n\t}\n\treturn ans;\n}",
            1587697423.2115061,
            100,
            "# 答案正确"
        ],
        [
            "1.2 (C++)",
            "吴渝峰",
            "#include <cstring>\n\nclass School {\npublic:\n\tchar name[10];\n\tint age;\n\tSchool() {\n\t\tstrcpy(name, \"NO_NAME\");\n\t\tage = 0;\n\t}\n\tvoid setName(char name[]) {\n\t\tstrcpy(this->name, name);\n\t}\n\tvoid setAge(int year) {\n\t\tthis->age = year;\n\t}\n\tvoid operator ++ () {\n\t\tthis->age ++;\n\t}\n};",
            1588212697.1727228,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/08",
            "吴渝峰",
            "double & Tensor_get(int dimensions, int sizes[], double data[], int x0, int x1, int x2, int x3) {\n    if(dimensions == 2) {\n        int ptr = x0 * sizes[1] + x1;\n        double num = x0 * 10 + x1;\n        data[ptr] = num;\n        return data[ptr];\n    }\n    if(dimensions == 3) {\n        int ptr = x0 * sizes[1] * sizes[2] + x1 * sizes[2] + x2;\n        double num = x0 * 100 + x1 * 10 + x2;\n        data[ptr] = num;\n        return data[ptr];\n    }\n    if(dimensions == 4) {\n        int ptr = x0 * sizes[1] * sizes[2] + sizes[3] + x1 * sizes[2] * sizes[3] + x2 * sizes[3] + x3;\n        double num = x0 * 1000 + x1 * 100 + x2 * 10 + x3;\n        data[ptr] = num;\n        return data[ptr];\n    }\n}",
            1588909085.5318942,
            100,
            "# 答案正确"
        ],
        [
            "2.1 (C++)",
            "吴渝峰",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix {\nprivate:\n\tint rows;\n\tint columns;\n\tdouble* values;\npublic:\n\tMatrix(int row, int column) {\n\t\trows = row;\n\t\tcolumns = column;\n\t\tvalues = new double[row * column];\n\t\tfor(int i = 0; i < row * column; ++ i) {\n\t\t\tvalues[i] = 0;\n\t\t}\n\t}\n\t~Matrix() {\n\t\tdelete[] values;\n\t}\n\tvoid print() {\n\t\tint k = 1;\n\t\tfor(int i = 0; i < rows * columns; ++ i) {\n\t\t\tcout << \"    \" << values[i];\n\t\t\tif(i == columns * k - 1) {\n\t\t\t\tcout << endl;\n\t\t\t\tk ++;\n\t\t\t}\n\t\t}\n\t}\n};",
            1589038582.6779668,
            100,
            "# 答案正确"
        ],
        [
            "2.2 (C++)",
            "吴渝峰",
            "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nclass Matrix {\nprivate:\n\tint rows;\n\tint columns;\n\tdouble* values;\npublic:\n\tMatrix(int row, int column, double values[]) {\n\t\trows = row;\n\t\tcolumns = column;\n\t\tthis->values = new double[row * column];\n\t\tfor(int i = 0; i < row * column; ++ i) {\n\t\t\tthis->values[i] = values[i];\n\t\t}\n\t}\n\t~Matrix() {\n\t\tdelete[] values;\n\t}\n\tvoid print() {\n        cout<<setiosflags(ios::right);\n\t\tint k = 1;\n\t\tfor(int i = 0; i < rows * columns; ++ i) {\n\t\t\tcout << setw(5) << values[i];\n\t\t\tif(i == columns * k - 1) {\n\t\t\t\tcout << endl;\n\t\t\t\tk ++;\n\t\t\t}\n\t\t}\n\t}\n};",
            1589038593.467651,
            100,
            "# 答案正确"
        ],
        [
            "2.3 (C++)",
            "吴渝峰",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix {\nprivate:\n\tint rows;\n\tint columns;\n\tdouble* values;\npublic:\n\tMatrix(int row, int column, double values[]) {\n\t\trows = row;\n\t\tcolumns = column;\n\t\tthis->values = new double[row * column];\n\t\tfor(int i = 0; i < row * column; ++ i) {\n\t\t\tthis->values[i] = values[i];\n\t\t}\n\t}\n    Matrix(Matrix & other) {\n        this->rows = other.rows;\n        this->columns = other.columns;\n        this->values = new double[rows * columns];\n\t\tfor(int i = 0; i < rows * columns; ++ i) {\n\t\t\tthis->values[i] = other.values[i];\n\t\t}\n    }\n\t~Matrix() {\n\t\tdelete[] values;\n\t}\n\tvoid print() {\n\t\tint k = 1;\n\t\tfor(int i = 0; i < rows * columns; ++ i) {\n\t\t\tcout << \"    \" << values[i];\n\t\t\tif(i == columns * k - 1) {\n\t\t\t\tcout << endl;\n\t\t\t\tk ++;\n\t\t\t}\n\t\t}\n\t}\n};",
            1589038617.0702658,
            100,
            "# 答案正确"
        ],
        [
            "2.5 (C++)",
            "吴渝峰",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix {\nprivate:\n\tint rows;\n\tint columns;\n\tdouble* values;\npublic:\n    Matrix(int row, int column) {\n\t\trows = row;\n\t\tcolumns = column;\n\t\tvalues = new double[row * column];\n\t\tfor(int i = 0; i < row * column; ++ i) {\n\t\t\tvalues[i] = 0;\n\t\t}\n\t}\n\tMatrix(int row, int column, double values[]) {\n\t\trows = row;\n\t\tcolumns = column;\n\t\tthis->values = new double[row * column];\n\t\tfor(int i = 0; i < row * column; ++ i) {\n\t\t\tthis->values[i] = values[i];\n\t\t}\n\t}\n\t~Matrix() {\n\t\tdelete[] values;\n\t}\n\tvoid print() {\n\t\tint k = 1;\n\t\tfor(int i = 0; i < rows * columns; ++ i) {\n\t\t\tcout << \"    \" << values[i];\n\t\t\tif(i == columns * k - 1) {\n\t\t\t\tcout << endl;\n\t\t\t\tk ++;\n\t\t\t}\n\t\t}\n\t}\n    Matrix getRow(int row) {\n\t\tMatrix ans(1, this->columns);\n\t\tfor(int i = 0; i < columns; ++ i) {\n\t\t\tans.values[i] = this->values[i+columns * (row - 1)];\n\t\t}\n\t\treturn ans;\n\t}\n\tMatrix getColumn(int column) {\n\t\tMatrix ans(rows, 1);\n\t\tfor(int i = 0; i < rows; ++ i) {\n\t\t\tans.values[i] = this->values[column - 1 + i * columns];\n\t\t}\n\t\treturn ans;\n\t}\n};",
            1589038648.8368087,
            100,
            "# 答案正确"
        ],
        [
            "2.6 (C++)",
            "吴渝峰",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix {\nprivate:\n\tint rows;\n\tint columns;\n\tdouble* values;\npublic:\n    Matrix(int row, int column) {\n\t\trows = row;\n\t\tcolumns = column;\n\t\tvalues = new double[row * column];\n\t\tfor(int i = 0; i < row * column; ++ i) {\n\t\t\tvalues[i] = 0;\n\t\t}\n\t}\n\tMatrix(int row, int column, double values[]) {\n\t\trows = row;\n\t\tcolumns = column;\n\t\tthis->values = new double[row * column];\n\t\tfor(int i = 0; i < row * column; ++ i) {\n\t\t\tthis->values[i] = values[i];\n\t\t}\n\t}\n\tMatrix(const Matrix & matrix2) {\n\t\trows = matrix2.rows;\n\t\tcolumns = matrix2.columns;\n\t\tthis->values = new double[rows * columns];\n\t\tfor(int i = 0; i < rows * columns; ++ i) {\n\t\t\tthis->values[i] = matrix2.values[i];\n\t\t}\n\t}\n\t~Matrix() {\n\t\tdelete[] values;\n\t}\n\tvoid print() {\n\t\tint k = 1;\n\t\tfor(int i = 0; i < rows * columns; ++ i) {\n\t\t\tcout << \"    \" << values[i];\n\t\t\tif(i == columns * k - 1) {\n\t\t\t\tcout << endl;\n\t\t\t\tk ++;\n\t\t\t}\n\t\t}\n\t}\n    Matrix concatenateRows(const Matrix & matrix2) {\n        Matrix ans(this->rows + matrix2.rows, columns);\n        for(int i = 0; i < rows * columns; ++ i) {\n            ans.values[i] = this->values[i];\n        }\n        for(int i = this->rows * this->columns; i < matrix2.rows * matrix2.columns + this->rows * this->columns; ++ i) {\n            ans.values[i] = matrix2.values[i - this->rows * this->columns];\n        }\n        return ans;\n    }\n    Matrix concatenateColumns(const Matrix & matrix2) {\n        Matrix ans(rows, columns + matrix2.columns);\n        int m = 0, n = 0;\n        for(int i = 0; i < rows * columns + matrix2.rows * matrix2.columns; ++ i) {\n            if(i % (columns + matrix2.columns) < columns)\n                ans.values[i] = values[m++];\n            else ans.values[i] = matrix2.values[n++];\n        }\n        return ans;\n    }\n};",
            1589038665.6049173,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/14",
            "吴渝峰",
            "#include <iostream>\nusing namespace std;\n\n\nvoid Tensor_print(int dimensions, const int sizes[], double data[]) {\n\tif(dimensions == 1) {\n\t\tcout << \"Tensor of \" << sizes[0] << endl;\n\t\tfor(int i = 0; i < sizes[0]; ++ i) {\n\t\t\tcout << data[i] << endl;\n\t\t}\n\t}\n\tif(dimensions == 2) {\n\t\tcout << \"Tensor of \" << sizes[0] << \"x\" << sizes[1] << endl;\n\t\tint k = 1;\n\t\tfor(int i = 0; i < sizes[0] * sizes[1]; ++ i) {\n\t\t\tcout << \"    \" << data[i];\n\t\t\tif(i == sizes[1] * k - 1) {\n\t\t\t\tcout << endl;\n\t\t\t\tk ++;\n\t\t\t}\n\t\t}\n\t}\n\tif(dimensions == 3) {\n\t\tcout << \"Tensor of \" << sizes[0] << \"x\" << sizes[1] << \"x\" << sizes[2] << endl;\n\t\tint index = 0;\n\t\tfor(int i = 0; i < sizes[0]; ++ i) {\n\t\t\tcout << \"data[\" << i  << \"]\" << endl;\n\t\t\tint k = 1;\n\t\t\tfor(int j = index; j < sizes[1] * sizes[2] + index; ++ j) {\n\t\t\t\tcout << \"    \" << data[j];\n\t\t\t\tif(j - index == sizes[2] * k - 1) {\n\t\t\t\t\tcout << endl;\n\t\t\t\t\tk ++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tindex += sizes[1] * sizes[2];\n\t\t}\n\t}\n\tif(dimensions == 4) {\n\t\tcout << \"Tensor of \" << sizes[0] << \"x\" << sizes[1] << \"x\" << sizes[2] << \"x\" << sizes[3] << endl;\n\t\tint index = 0;\n\t\tfor(int i = 0; i < sizes[0]; ++ i) {\n\t\t\tfor(int j = 0; j < sizes[1]; ++ j) {\n\t\t\t\tprintf(\"data[%d][%d]\\n\", i, j);\n\t\t\t\tint k = 1;\n\t\t\t\tfor(int m = index; m < sizes[2] * sizes[3] + index; ++ m) {\n\t\t\t\t\tcout << \"    \" << data[m];\n\t\t\t\t\tif(m - index == sizes[3] * k - 1) {\n\t\t\t\t\t\tcout << endl;\n\t\t\t\t\t\tk ++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tindex += sizes[2] * sizes[3];\n\t\t\t}\n\t\t}\n\t}\n}",
            1589426786.2402978,
            100,
            "# 答案正确"
        ],
        [
            "2.4 (C++)",
            "吴渝峰",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix {\nprivate:\n    int rows;\n    int columns;\n    double* values;\npublic:\n    Matrix(int row, int column) {\n        this->rows = row;\n        this->columns = column;\n        int size = row * column;\n        this->values = new double[size];\n        for(int i = 0; i < size; ++ i)\n            this->values[i] = 0;\n    }\n    Matrix(int row, int column, double values[]) {\n        this->rows = row;\n        this->columns = column;\n        int size = row * column;\n        this->values = new double[size];\n        for(int i = 0; i < size; ++ i)\n            this->values[i] = values[i];\n    }\n    ~Matrix() {\n        delete[] this->values;\n    }\n    void print() {\n        int k = 1;\n\t\tfor(int i = 0; i <  rows * columns; ++ i) {\n\t\t\tcout << \"    \" << values[i];\n\t\t\tif(i == columns * k - 1) {\n\t\t\t\tcout << endl;\n\t\t\t\tk ++;\n\t\t\t}\n\t\t}\n    }\n    void set(int row, int column, double value) {\n        row -= 1;\n        column -= 1;\n        this->values[row * columns + column] = value;\n    }\n    Matrix & operator = (const Matrix & other) {\n        rows = other.rows;\n        columns = other.columns;\n        delete[] values;\n        values = new double[rows * columns];\n        for(int i = 0; i < rows * columns; ++ i) {\n            values[i] = other.values[i];\n        }\n        return (*this);\n    }\n};",
            1589623649.262222,
            100,
            "# 答案正确"
        ],
        [
            "2.7 (C++)",
            "吴渝峰",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix {\nprivate:\n    int rows;\n    int columns;\n    double* values;\npublic:\n    Matrix(int row, int column, double values[]) {\n        this->rows = row;\n        this->columns = column;\n        int size = row * column;\n        this->values = new double[size];\n        for(int i = 0; i < size; ++ i)\n            this->values[i] = values[i];\n    }\n    Matrix(const Matrix & matrix2) {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        this->values = new double[rows * columns];\n        for(int i = 0; i < rows * columns; ++ i) {\n            this->values[i] = matrix2.values[i];\n        }\n    }\n    ~Matrix() {\n        delete[] this->values;\n    }\n    void print() {\n        int k = 1;\n\t\tfor(int i = 0; i < rows * columns; ++ i) {\n\t\t\tcout << \"    \" << values[i];\n\t\t\tif(i == columns * k - 1) {\n\t\t\t\tcout << endl;\n\t\t\t\tk ++;\n\t\t\t}\n\t\t}\n    }\n    Matrix reshape(int row, int column) {\n        Matrix ans(*this);\n        double a[this->rows][this->columns];\n        int ptr = 0;\n        for(int i = 0; i < this->rows; ++ i) {\n            for(int j = 0; j < this->columns; ++ j) {\n                a[i][j] = this->values[ptr++];\n            }\n        }\n        ans.rows = row;\n        ans.columns = column;\n        ptr = 0;\n        int k = 1;\n        for(int i = 0; i < this->columns; ++ i) {\n            for(int j = 0; j < this->rows; ++ j) {\n                ans.values[ptr] = a[j][i];\n                ptr += ans.columns;\n                if(ptr >= row * column) {\n                    ptr = k;\n                    k++;\n                }\n            }\n        }\n\t\treturn ans;\n    }\n};",
            1589725803.3504338,
            100,
            "# 答案正确"
        ],
        [
            "2.8 (C++)",
            "吴渝峰",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix {\nprivate:\n    int rows;\n    int columns;\n    double* values;\npublic:\n    Matrix(int row, int column, double values[]) {\n        this->rows = row;\n        this->columns = column;\n        int size = row * column;\n        this->values = new double[size];\n        for(int i = 0; i < size; ++ i)\n            this->values[i] = values[i];\n    }\n    Matrix(const Matrix & matrix2) {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        this->values = new double[rows * columns];\n        for(int i = 0; i < rows * columns; ++ i) {\n            this->values[i] = matrix2.values[i];\n        }\n    }\n    ~Matrix() {\n        delete[] this->values;\n    }\n    void print() {\n        int k = 1;\n\t\tfor(int i = 0; i <  rows * columns; ++ i) {\n\t\t\tcout << \"    \" << values[i];\n\t\t\tif(i == columns * k - 1) {\n\t\t\t\tcout << endl;\n\t\t\t\tk ++;\n\t\t\t}\n\t\t}\n    }\n    Matrix transpose() {\n        Matrix temp(*this);\n        double a[this->rows][this->columns];\n        int ptr = 0;\n        for(int i = 0; i < this->rows; ++ i) {\n            for(int j = 0; j < this->columns; ++ j) {\n                a[i][j] = this->values[ptr++];\n            }\n        }\n        temp.rows = this->columns;\n        temp.columns = this->rows;\n        ptr = 0;\n        int k = 0;\n        for(int i = 0; i < this->rows; ++ i) {\n            for(int j = 0; j < this->columns; ++ j) {\n                temp.values[ptr] = a[i][j];\n                ptr += this->rows;\n                if(ptr >= this->rows * this->columns) {\n                    ptr = ++k;\n                }\n            }\n        }\n        return temp;\n    }\n};",
            1589798548.368455,
            100,
            "# 答案正确"
        ],
        [
            "2.10 (C++)",
            "吴渝峰",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix {\nprivate:\n    int rows;\n    int columns;\n    double* values;\npublic:\n    Matrix(int row, int column) {\n        this->rows = row;\n        this->columns = column;\n        int size = row * column;\n        this->values = new double[size];\n        for(int i = 0; i < size; ++ i)\n            this->values[i] = 0;\n    }\n    Matrix(int row, int column, double values[]) {\n        this->rows = row;\n        this->columns = column;\n        int size = row * column;\n        this->values = new double[size];\n        for(int i = 0; i < size; ++ i)\n            this->values[i] = values[i];\n    }\n    Matrix(const Matrix & matrix2) {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        this->values = new double[rows * columns];\n        for(int i = 0; i < rows * columns; ++ i) {\n            this->values[i] = matrix2.values[i];\n        }\n    }\n    ~Matrix() {\n        delete[] this->values;\n    }\n    void print() {\n        int k = 1;\n\t\tfor(int i = 0; i <  rows * columns; ++ i) {\n\t\t\tcout << \"    \" << values[i];\n\t\t\tif(i == columns * k - 1) {\n\t\t\t\tcout << endl;\n\t\t\t\tk ++;\n\t\t\t}\n\t\t}\n    }\n    Matrix operator * (const Matrix & matrix2) const {\n        int ptr = 0;\n        double a[this->rows][this->columns];\n        for(int i = 0; i < this->rows; ++ i)\n            for(int j = 0; j < this->columns; ++ j)\n                a[i][j] = this->values[ptr++];\n        ptr = 0;\n        double b[matrix2.rows][matrix2.columns];\n        for(int i = 0; i < matrix2.rows; ++ i)\n            for(int j = 0; j < matrix2.columns; ++ j)\n                b[i][j] = matrix2.values[ptr++];\n        double c[this->rows][matrix2.columns];\n        for(int i = 0; i < this->rows; ++ i)\n            for(int j = 0; j < matrix2.columns; ++ j)\n                c[i][j] = 0;\n        for(int i = 0; i < this->rows; ++ i)\n            for(int j = 0; j < matrix2.columns; ++ j)\n                for(int k = 0; k < this->columns; ++ k)\n                    c[i][j] += a[i][k] * b[k][j];\n        Matrix ans(this->rows, matrix2.columns);\n        ptr = 0;\n        for(int i = 0; i < this->rows; ++ i)\n            for(int j = 0; j < matrix2.columns; ++ j)\n                ans.values[ptr++] = c[i][j];\n        return ans;\n    }\n    Matrix operator * (double value) const {\n        Matrix ans(*this);\n        int ptr = 0;\n        for(int i = 0; i < this->rows * this->columns; ++ i) {\n            ans.values[ptr] *= value;\n            ptr++;\n        }\n        return ans;\n    }\n};\n",
            1589814339.713697,
            100,
            "# 答案正确"
        ],
        [
            "2.12 (C++)",
            "吴渝峰",
            "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nclass Matrix {\nprivate:\n    int rows;\n    int columns;\n    double* values;\npublic:\n    Matrix(int row, int column, double values[]) {\n        this->rows = row;\n        this->columns = column;\n        int size = row * column;\n        this->values = new double[size];\n        for(int i = 0; i < size; ++ i)\n            this->values[i] = values[i];\n    }\n    Matrix(const Matrix & matrix2) {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        this->values = new double[rows * columns];\n        for(int i = 0; i < rows * columns; ++ i)\n            this->values[i] = matrix2.values[i];\n    }\n    ~Matrix() {\n        delete[] this->values;\n    }\n    void print() {\n        int k = 1;\n\t\tfor(int i = 0; i <  rows * columns; ++ i) {\n\t\t\tcout << \"    \" << values[i];\n\t\t\tif(i == columns * k - 1) {\n\t\t\t\tcout << endl;\n\t\t\t\tk ++;\n\t\t\t}\n\t\t}\n    }\n    Matrix pow(double exponent) {\n        Matrix ans(*this);\n        for(int i = 0; i < this->rows * this->columns; ++i)\n            ans.values[i] = ::pow(ans.values[i], exponent);\n        return ans;\n    }\n    Matrix exp() {\n        Matrix ans(*this);\n        for(int i = 0; i < this->rows * this->columns; ++i)\n            ans.values[i] = ::exp(ans.values[i]);\n        return ans;\n    }\n    Matrix log() {\n        Matrix ans(*this);\n        for(int i = 0; i < this->rows * this->columns; ++i)\n            ans.values[i] = ::log(ans.values[i]);\n        return ans;\n    }\n    Matrix abs() {\n        Matrix ans(*this);\n        for(int i = 0; i < this->rows * this->columns; ++i)\n            ans.values[i] = ::abs(ans.values[i]);\n        return ans;\n    }\n};\n",
            1589815964.7166247,
            100,
            "# 答案正确"
        ],
        [
            "2.11 (C++)",
            "吴渝峰",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix {\nprivate:\n    int rows;\n    int columns;\n    double* values;\npublic:\n    Matrix(int row, int column) {\n        this->rows = row;\n        this->columns = column;\n        int size = row * column;\n        this->values = new double[size];\n        for(int i = 0; i < size; ++ i)\n            this->values[i] = 0;\n    }\n    Matrix(int row, int column, double values[]) {\n        this->rows = row;\n        this->columns = column;\n        int size = row * column;\n        this->values = new double[size];\n        for(int i = 0; i < size; ++ i)\n            this->values[i] = values[i];\n    }\n    Matrix(const Matrix & matrix2) {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        this->values = new double[rows * columns];\n        for(int i = 0; i < rows * columns; ++ i)\n            this->values[i] = matrix2.values[i];\n    }\n    ~Matrix() {\n        delete[] this->values;\n    }\n    void print() {\n        int k = 1;\n\t\tfor(int i = 0; i <  rows * columns; ++ i) {\n\t\t\tcout << \"    \" << values[i];\n\t\t\tif(i == columns * k - 1) {\n\t\t\t\tcout << endl;\n\t\t\t\tk ++;\n\t\t\t}\n\t\t}\n    }\n    Matrix max() const {\n        if(this->rows == 1) {\n            Matrix ans(1, 1);\n            int temp = 0;\n            for(int i = 0; i < this->columns; ++ i)\n                if(this->values[i] > temp)\n                    temp = this->values[i];\n            ans.values[0] = temp;\n            return ans;\n        }\n        Matrix ans(1, this->columns);\n        int ptr = 0;\n        int k = 1;\n        int ptr2 = 0;\n        for(int i = 0; i < this->columns; ++ i) {\n            int temp = 0;\n            while(ptr < this->rows * this->columns) {\n                if(this->values[ptr] > temp)\n                    temp = this->values[ptr];\n                ptr += this->columns;\n            }\n            ans.values[ptr2++] = temp;\n            ptr = k++;\n        }\n        return ans;\n    }\n    Matrix min() const {\n        if(this->rows == 1) {\n            Matrix ans(1, 1);\n            int temp = 10000;\n            for(int i = 0; i < this->columns; ++ i)\n                if(this->values[i] < temp)\n                    temp = this->values[i];\n            ans.values[0] = temp;\n            return ans;\n        }\n        Matrix ans(1, this->columns);\n        int ptr = 0;\n        int k = 1;\n        int ptr2 = 0;\n        for(int i = 0; i < this->columns; ++ i) {\n            int temp = 10000;\n            while(ptr < this->rows * this->columns) {\n                if(this->values[ptr] < temp)\n                    temp = this->values[ptr];\n                ptr += this->columns;\n            }\n            ans.values[ptr2++] = temp;\n            ptr = k++;\n        }\n        return ans;\n    }\n    Matrix sum() const {\n        if(this->rows == 1) {\n            Matrix ans(1, 1);\n            for(int i = 0; i < this->columns; ++ i)\n                ans.values[0] += this->values[i];\n            return ans;\n        }\n        Matrix ans(1, this->columns);\n        int ptr = 0;\n        int k = 1;\n        int ptr2 = 0;\n        for(int i = 0; i < this->columns; ++ i) {\n            while(ptr < this->rows * this->columns) {\n                ans.values[ptr2] += this->values[ptr];\n                ptr += this->columns;\n            }\n            ptr2 ++;\n            ptr = k++;\n        }\n        return ans;\n    }\n};",
            1589861370.6504402,
            100,
            "# 答案正确"
        ],
        [
            "2.9 (C++)",
            "吴渝峰",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix {\nprivate:\n    int rows;\n    int columns;\n    double* values;\npublic:\n    Matrix(int row, int column, double values[]) {\n        this->rows = row;\n        this->columns = column;\n        int size = row * column;\n        this->values = new double[size];\n        for(int i = 0; i < size; ++ i)\n            this->values[i] = values[i];\n    }\n    Matrix(const Matrix & matrix2) {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        this->values = new double[rows * columns];\n        for(int i = 0; i < rows * columns; ++ i) {\n            this->values[i] = matrix2.values[i];\n        }\n    }\n    ~Matrix() {\n        delete[] this->values;\n    }\n    void print() {\n        int k = 1;\n\t\tfor(int i = 0; i <  rows * columns; ++ i) {\n\t\t\tcout << \"    \" << values[i];\n\t\t\tif(i == columns * k - 1) {\n\t\t\t\tcout << endl;\n\t\t\t\tk ++;\n\t\t\t}\n\t\t}\n    }\n    Matrix operator + (const Matrix & matrix2) const {\n        Matrix ans(*this);\n        for(int i = 0; i < this->rows * this->columns; ++ i)\n            ans.values[i] += matrix2.values[i];\n        return ans;\n    }\n    Matrix operator + (double value) const {\n        Matrix ans(*this);\n        for(int i = 0; i < this->rows * this->columns; ++ i)\n            ans.values[i] += value;\n        return ans;\n    }\n    Matrix operator - (const Matrix & matrix2) const {\n        Matrix ans(*this);\n        for(int i = 0; i < this->rows * this->columns; ++ i)\n            ans.values[i] -= matrix2.values[i];\n        return ans;\n    }\n    Matrix operator - (double value) const {\n        Matrix ans(*this);\n        for(int i = 0; i < this->rows * this->columns; ++ i)\n            ans.values[i] -= value;\n        return ans;\n    }\n};",
            1590028598.372481,
            100,
            "# 答案正确"
        ],
        [
            "6.1 (C++)",
            "吴渝峰",
            "#include <iostream>\n#include <cstring>\nusing namespace std;\n\ntemplate <typename T>\nclass Matrix {\nprivate:\n\tT* values;\n    int rows;\n    int columns;\n    \npublic:\n    Matrix(int row, int column) {\n        this->rows = row;\n        this->columns = column;\n        int size = row * column;\n        this->values = new T[size];\n        memset(values, 0, sizeof(T)*size);\n    }\n    Matrix(int row, int column, const T values[]) {\n        this->rows = row;\n        this->columns = column;\n        int size = row * column;\n        this->values = new T[size];\n        for(int i = 0; i < size; ++ i)\n            this->values[i] = values[i];\n    }\n    Matrix(const Matrix<T> & matrix2) {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        this->values = new T[rows * columns];\n        for(int i = 0; i < rows * columns; ++ i)\n            this->values[i] = matrix2.values[i];\n    }\n    ~Matrix() {\n        delete[] this->values;\n    }\n    Matrix & operator = (const Matrix<T> & other) {\n        rows = other.rows;\n        columns = other.columns;\n        delete[] values;\n        values = new T[rows * columns];\n        for(int i = 0; i < rows * columns; ++ i) {\n            values[i] = other.values[i];\n        }\n        return (*this);\n    }\n    T & get(int row, int column) {\n        return values[(row - 1) * columns + column - 1];\n    }\n    void print() {\n        int k = 1;\n\t\tfor(int i = 0; i <  rows * columns; ++ i) {\n\t\t\tcout << \"    \" << values[i];\n\t\t\tif(i == columns * k - 1) {\n\t\t\t\tcout << endl;\n\t\t\t\tk ++;\n\t\t\t}\n\t\t}\n    }\n};",
            1590392747.7526066,
            100,
            "# 答案正确"
        ],
        [
            "6.3 (C++)",
            "吴渝峰",
            "#include <iostream>\n#include <cstring>\n#include <vector>\nusing namespace std;\n\ntemplate <typename T>\nclass Matrix {\nprivate:\n    int rows;\n    int columns;\n    vector<T> values;\npublic:\n    Matrix(int row, int column) {\n        this->rows = row;\n        this->columns = column;\n        int size = row * column;\n        for(int i = 0; i < size; ++ i) {\n            values.push_back(0);\n        }\n    }\n    Matrix(int row, int column, vector<double> values2) {\n        this->rows = row;\n        this->columns = column;\n        int size = row * column;\n        for(int i = 0; i < size; ++ i) {\n            this->values.push_back(values2[i]);\n        }\n    }\n    Matrix(const Matrix & matrix2) {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        vector<T> temp;\n        for(int i = 0; i < rows * columns; ++ i) {\n            temp.push_back(matrix2.values[i]);\n        }\n        this->values = temp;\n    }\n    ~Matrix() {\n        //delete[] this->values;\n    }\n    Matrix & operator = (const Matrix & other) {\n        rows = other.rows;\n        columns = other.columns;\n        this->values = other.values;\n        return (*this);\n    }\n    T & get(int row, int column) {\n        return values[(row - 1) * columns + column - 1];\n    }\n    void print() {\n        int k = 1;\n\t\tfor(int i = 0; i <  rows * columns; ++ i) {\n\t\t\tcout << \"    \" << values[i];\n\t\t\tif(i == columns * k - 1) {\n\t\t\t\tcout << endl;\n\t\t\t\tk ++;\n\t\t\t}\n\t\t}\n    }\n    Matrix getColumn(int column) {\n\t\tMatrix ans(rows, 1);\n        int ptr = column - 1;\n\t\tfor(int i = 0; i < rows; ++ i) {\n\t\t\tans.values[i] = this->values[ptr];\n            ptr += columns;\n\t\t}\n\t\treturn ans;\n\t}\n    Matrix getRow(int row) {\n\t\tMatrix ans(1, this->columns);\n        int ptr = (row - 1) * columns;\n\t\tfor(int i = 0; i < columns; ++ i) {\n\t\t\tans.values[i] = this->values[ptr++];\n\t\t}\n\t\treturn ans;\n\t}\n    Matrix concatenateRows(const Matrix & matrix2) {\n        Matrix ans(this->rows + matrix2.rows, columns);\n        for(int i = 0; i < rows * columns; ++ i) {\n            ans.values[i] = this->values[i];\n        }\n        for(int i = this->rows * this->columns; i < this->rows * this->columns + matrix2.rows * matrix2.columns; ++ i) {\n            ans.values[i] = matrix2.values[i - this->rows * this->columns];\n        }\n        return ans;\n    }\n    Matrix concatenateColumns(const Matrix & matrix2) {\n        T a[rows][columns];\n        T b[matrix2.rows][matrix2.columns];\n        int ptr = 0;\n        for(int i = 0; i < rows; ++ i) {\n            for(int j = 0; j < columns; ++ j) {\n                a[i][j] = this->values[ptr++];\n            }\n        }\n        ptr = 0;\n        for(int i = 0; i < matrix2.rows; ++ i) {\n            for(int j = 0; j < matrix2.columns; ++ j) {\n                b[i][j] = matrix2.values[ptr++];\n            }\n        }\n        ptr = 0;\n        T temp[rows][columns + matrix2.columns];\n        for(int i = 0; i < rows; ++ i) {\n            for(int j = 0; j < columns; ++ j) {\n                temp[i][j] = a[i][j];\n            }\n        }\n        for(int i = 0; i < rows; ++ i) {\n            for(int j = columns; j < matrix2.columns + columns; ++ j) {\n                temp[i][j] = b[i][j - columns];\n            }\n        }\n        ptr = 0;\n        Matrix ans(rows, columns + matrix2.columns);\n        for(int i = 0; i < rows; ++ i) {\n            for(int j = 0; j < columns + matrix2.columns; ++ j) {\n                ans.values[ptr++] = temp[i][j];\n            }\n        }\n        return ans;\n    }\n    Matrix reshape(int row, int column) const {\n        Matrix ans(*this);\n        T a[this->rows][this->columns];\n        int ptr = 0;\n        for(int i = 0; i < this->rows; ++ i) {\n            for(int j = 0; j < this->columns; ++ j) {\n                a[i][j] = this->values[ptr++];\n            }\n        }\n        ans.rows = row;\n        ans.columns = column;\n        ptr = 0;\n        int k = 1;\n        for(int i = 0; i < this->columns; ++ i) {\n            for(int j = 0; j < this->rows; ++ j) {\n                ans.values[ptr] = a[j][i];\n                ptr += ans.columns;\n                if(ptr >= row * column) {\n                    ptr = k;\n                    k++;\n                }\n            }\n        }\n        return ans;\n    }\n    Matrix transpose() {\n        Matrix temp(*this);\n        T a[this->rows][this->columns];\n        int ptr = 0;\n        for(int i = 0; i < this->rows; ++ i) {\n            for(int j = 0; j < this->columns; ++ j) {\n                a[i][j] = this->values[ptr++];\n            }\n        }\n        temp.rows = this->columns;\n        temp.columns = this->rows;\n        ptr = 0;\n        int k = 0;\n        for(int i = 0; i < this->rows; ++ i) {\n            for(int j = 0; j < this->columns; ++ j) {\n                temp.values[ptr] = a[i][j];\n                ptr += this->rows;\n                if(ptr >= this->rows * this->columns) {\n                    ptr = ++k;\n                }\n            }\n        }\n        return temp;\n    }\n    Matrix operator + (const Matrix & matrix2) const {\n        Matrix ans(*this);\n        for(int i = 0; i < this->rows * this->columns; ++ i)\n            ans.values[i] += matrix2.values[i];\n        return ans;\n    }\n    Matrix operator + (double value) const {\n        Matrix ans(*this);\n        for(int i = 0; i < this->rows * this->columns; ++ i)\n            ans.values[i] += value;\n        return ans;\n    }\n    Matrix operator - (const Matrix & matrix2) const {\n        Matrix ans(*this);\n        for(int i = 0; i < this->rows * this->columns; ++ i)\n            ans.values[i] -= matrix2.values[i];\n        return ans;\n    }\n    Matrix operator - (double value) const {\n        Matrix ans(*this);\n        for(int i = 0; i < this->rows * this->columns; ++ i)\n            ans.values[i] -= value;\n        return ans;\n    }\n    Matrix operator * (const Matrix & matrix2) const {\n        int ptr = 0;\n        T a[this->rows][this->columns];\n        for(int i = 0; i < this->rows; ++ i)\n            for(int j = 0; j < this->columns; ++ j)\n                a[i][j] = this->values[ptr++];\n        ptr = 0;\n        T b[matrix2.rows][matrix2.columns];\n        for(int i = 0; i < matrix2.rows; ++ i)\n            for(int j = 0; j < matrix2.columns; ++ j)\n                b[i][j] = matrix2.values[ptr++];\n        T c[this->rows][matrix2.columns];\n        for(int i = 0; i < this->rows; ++ i)\n            for(int j = 0; j < matrix2.columns; ++ j)\n                c[i][j] = 0;\n        for(int i = 0; i < this->rows; ++ i)\n            for(int j = 0; j < matrix2.columns; ++ j)\n                for(int k = 0; k < this->columns; ++ k)\n                    c[i][j] += a[i][k] * b[k][j];\n        Matrix ans(this->rows, matrix2.columns);\n        ptr = 0;\n        for(int i = 0; i < this->rows; ++ i)\n            for(int j = 0; j < matrix2.columns; ++ j)\n                ans.values[ptr++] = c[i][j];\n        return ans;\n    }\n    Matrix operator * (double value) const {\n        Matrix ans(*this);\n        int ptr = 0;\n        for(int i = 0; i < this->rows * this->columns; ++ i) {\n            ans.values[ptr] *= value;\n            ptr++;\n        }\n        return ans;\n    }\n    Matrix max() const {\n        if(this->rows == 1) {\n            Matrix ans(1, 1);\n            int temp = 0;\n            for(int i = 0; i < this->columns; ++ i)\n                if(this->values[i] > temp)\n                    temp = this->values[i];\n            ans.values[0] = temp;\n            return ans;\n        }\n        Matrix ans(1, this->columns);\n        int ptr = 0;\n        int k = 1;\n        int ptr2 = 0;\n        for(int i = 0; i < this->columns; ++ i) {\n            int temp = 0;\n            while(ptr < this->rows * this->columns) {\n                if(this->values[ptr] > temp)\n                    temp = this->values[ptr];\n                ptr += this->columns;\n            }\n            ans.values[ptr2++] = temp;\n            ptr = k++;\n        }\n        return ans;\n    }\n    Matrix min() const {\n        if(this->rows == 1) {\n            Matrix ans(1, 1);\n            int temp = 10000;\n            for(int i = 0; i < this->columns; ++ i)\n                if(this->values[i] < temp)\n                    temp = this->values[i];\n            ans.values[0] = temp;\n            return ans;\n        }\n        Matrix ans(1, this->columns);\n        int ptr = 0;\n        int k = 1;\n        int ptr2 = 0;\n        for(int i = 0; i < this->columns; ++ i) {\n            int temp = 10000;\n            while(ptr < this->rows * this->columns) {\n                if(this->values[ptr] < temp)\n                    temp = this->values[ptr];\n                ptr += this->columns;\n            }\n            ans.values[ptr2++] = temp;\n            ptr = k++;\n        }\n        return ans;\n    }\n    Matrix sum() const {\n        if(this->rows == 1) {\n            Matrix ans(1, 1);\n            for(int i = 0; i < this->columns; ++ i)\n                ans.values[0] += this->values[i];\n            return ans;\n        }\n        Matrix ans(1, this->columns);\n        int ptr = 0;\n        int k = 1;\n        int ptr2 = 0;\n        for(int i = 0; i < this->columns; ++ i) {\n            while(ptr < this->rows * this->columns) {\n                ans.values[ptr2] += this->values[ptr];\n                ptr += this->columns;\n            }\n            ptr2 ++;\n            ptr = k++;\n        }\n        return ans;\n    }\n};",
            1590392759.7337344,
            100,
            "# 答案正确"
        ],
        [
            "6.2 (C++)",
            "吴渝峰",
            "#include <iostream>\n#include <cstring>\nusing namespace std;\n\ntemplate <typename T>\nclass Matrix {\nprivate:\n    int rows;\n    int columns;\n    T* values;\npublic:\n    Matrix(int row, int column) {\n        this->rows = row;\n        this->columns = column;\n        int size = row * column;\n        this->values = new T[size];\n        memset(values, 0, sizeof(T)*size);\n    }\n    ~Matrix() {\n        delete[] this->values;\n\t}\n    void print() {\n        int k = 1;\n\t\tfor(int i = 0; i <  rows * columns; ++ i) {\n\t\t\tcout << \"    \" << values[i];\n\t\t\tif(i == columns * k - 1) {\n\t\t\t\tcout << endl;\n\t\t\t\tk ++;\n\t\t\t}\n\t\t}\n    }\n};",
            1590631500.7715473,
            100,
            "# 答案正确"
        ],
        [
            "7.1 (C++)",
            "吴渝峰",
            "#include <cmath>\n\nclass Triangle :public GeometricObject {\nprivate:\n    double side1, side2, side3;\npublic:\n    Triangle() {\n        side1 = 1;\n        side2 = 1;\n        side3 = 1;\n    }\n    Triangle(double side1, double side2, double side3) {\n        this->side1 = side1;\n        this->side2 = side2;\n        this->side3 = side3;\n    }\n    double getSide1() {\n        return side1;\n    }\n    double getSide2() {\n        return side2;\n    }\n    double getSide3() {\n        return side3;\n    }\n    double getArea() {\n        double a = side1;\n        double b = side2;\n        double c = side3;\n        double p = (a + b + c) / 2;\n        return sqrt(p * (p - a) * (p - b) * (p - c));\n    }\n    double getPerimeter() {\n        return side1 + side2 + side3;\n    }\n};",
            1590856263.3088753,
            100,
            "# 答案正确"
        ],
        [
            "7.3 (C++)",
            "吴渝峰",
            "template <typename A, typename R>\nvector<R> map2(vector<A> & x, vector<A> & y, R (*map2_func)(const A &, const A &)) {\n    vector<R> res;\n    for(int i = 0; i < x.size(); ++ i)\n        res.push_back(map2_func(x[i], y[i]));\n    return res;\n}\n\ntemplate <typename A, typename R>\nvector<R> map2(vector<A> & x, R y, R (*map2_func)(const A &, const A &)) {\n    vector<R> res;\n    for(int i = 0; i < x.size(); ++ i)\n        res.push_back(map2_func(x[i], y));\n    return res;\n}",
            1591075286.5088298,
            100,
            "# 答案正确"
        ],
        [
            "7.2 (C++)",
            "吴渝峰",
            "#include <vector>\n#include <iostream>\n#include <string>\nusing namespace std;\n\nvector<string> split(const string & line) {\n    vector<string> words;\n    int ptr1 = 0;\n    int ptr2 = 0;\n    if(line[0] != ' ') {\n        ptr2 = line.find(' ', ptr1);\n        words.push_back(line.substr(ptr1, ptr2 - ptr1));\n    }\n    ptr1 = 1;\n    while(ptr1 < line.size()) {\n        while(!(line[ptr1-1] == ' ' && line[ptr1] != ' ')) {\n            ptr1 ++;\n        }\n        ptr2 = line.find(' ', ptr1);\n        if(ptr2 == -1) {\n            words.push_back(line.substr(ptr1));\n            break;\n        }\n        words.push_back(line.substr(ptr1, ptr2 - ptr1));\n        ptr1 = ptr2 + 1;\n    }\n    return words;\n}",
            1591239279.4742482,
            100,
            "# 答案正确"
        ],
        [
            "8.1 (C++)",
            "吴渝峰",
            "class Full : public Matrix {\nprivate:\n    int rows;\n    int columns;\n    double* values;\npublic:\n    Full(int row, int column) {\n        this->rows = row;\n        this->columns = column;\n        int size = row * column;\n        this->values = new double[size];\n        for(int i = 0; i < size; ++ i)\n            this->values[i] = 0;\n    }\n    Full(int row, int column, double values[]) {\n        this->rows = row;\n        this->columns = column;\n        int size = row * column;\n        this->values = new double[size];\n        for(int i = 0; i < size; ++ i)\n            this->values[i] = values[i];\n    }\n    Full(const Matrix & matrix2) {\n        this->rows = matrix2.size(1);\n        this->columns = matrix2.size(2);\n        this->values = new double[rows * columns];\n\t\tint ptr = 0;\n        for(int i = 0; i < rows; ++ i) {\n            for(int j = 0; j < columns; ++ j) {\n                this->values[ptr++] = matrix2.get(i, j);\n            }\n        }\n    }\n    ~Full() {\n        delete[] this->values;\n    }\n    int size(int dimension) const {\n        if(dimension == 1) {\n            return this->rows;\n        }\n        return this->columns;\n    }\n    void set(int row, int column, double value) {\n        row -= 1;\n        column -= 1;\n        this->values[row * columns + column] = value;\n    }\n    double get(int row, int column) const {\n        return this->values[row * columns + column];\n    }    \n    void print() const {\n        int k = 1;\n\t\tfor(int i = 0; i <  rows * columns; ++ i) {\n\t\t\tcout << \"    \" << values[i];\n\t\t\tif(i == columns * k - 1) {\n\t\t\t\tcout << endl;\n\t\t\t\tk ++;\n\t\t\t}\n\t\t}\n    }\n    Matrix & operator = (const Matrix & matrix2) {\n        this->rows = matrix2.size(1);\n        this->columns = matrix2.size(2);\n        //this->values = new double[rows * columns];\n\t\tint ptr = 0;\n        for(int i = 0; i < rows; ++ i) {\n            for(int j = 0; j < columns; ++ j) {\n                this->values[ptr++] = matrix2.get(i, j);\n            }\n        }\n        return (*this);\n    }\n};",
            1591632033.4447367,
            100,
            "# 答案正确"
        ],
        [
            "8.3 (C++)",
            "吴渝峰",
            "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Sparse : public Matrix {\nprivate:\n    int rows;\n    int columns;\n    vector<Entry> data;\npublic:\n    Sparse(int row, int column) {\n        rows = row;\n        columns = column;\n    }\n    int size(int dimension) const {\n        if(dimension == 1)\n            return this->rows;\n        return this->columns;\n    }\n    void set(int row, int column, double value) {\n        Entry temp;\n        temp.row = row;\n        temp.column = column;\n        temp.value = value;\n        data.push_back(temp);\n    }\n    double get(int row, int column) const {\n        for(int i = 0; i < data.size(); ++ i)\n            if(data[i].row == row && data[i].column == column)\n                return data[i].value;\n        return 0;\n    }\n    void print() {\n        for(int i = 0; i < data.size(); ++ i) {\n            for(int j = 0; j < data.size() - 1; ++ j) {\n                if(data[j].row > data[j+1].row || (data[j].row == data[j+1].row && data[j].column > data[j+1].column)) {\n                    int temp;\n                    double temp2;\n                    temp = data[j].row; data[j].row = data[j+1].row;data[j+1].row = temp;\n                    temp = data[j].column; data[j].column = data[j+1].column;data[j+1].column = temp;\n                    temp2 = data[j].value; data[j].value = data[j+1].value;data[j+1].value = temp2;\n                }\n            }\n        }\n        for(int i = 0; i < data.size(); ++ i) {\n            if(data[i].value != 0)\n                cout << \"(\" << data[i].row << \",\" << data[i].column << \",\" << data[i].value << \")\" << endl;\n        }\n    }\n    Sparse operator + (Sparse & sparse2) {\n        Sparse ans(this->rows, this->columns);\n        for(int i = 0; i < this->data.size(); ++ i) {\n            ans.data.push_back(this->data[i]);\n        }\n        int sum1 = sparse2.data.size();\n        int sum2 = this->data.size();\n        \n        for(int i = 0; i < sum1; ++ i) {\n            int check = 0;\n            for(int j = 0; j < sum2; ++ j) {\n                if(ans.data[j].row == sparse2.data[i].row && ans.data[j].column == sparse2.data[i].column) {\n                    ans.data[j].value += sparse2.data[i].value;\n                    check = 1;\n                }\n            }\n            if(check == 0) {\n                ans.data.push_back(sparse2.data[i]);\n            }\n        }\n        return ans;\n    }\n};",
            1591716430.4988303,
            100,
            "# 答案正确"
        ],
        [
            "8.4 (C++)",
            "吴渝峰",
            "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Sparse : public Matrix {\nprivate:\n    int rows;\n    int columns;\n    vector<Entry> data;\npublic:\n    Sparse(int row, int column) {\n        rows = row;\n        columns = column;\n    }\n    int size(int dimension) const {\n        if(dimension == 1)\n            return this->rows;\n        return this->columns;\n    }\n    void set(int row, int column, double value) {\n        Entry temp;\n        temp.row = row;\n        temp.column = column;\n        temp.value = value;\n        data.push_back(temp);\n    }\n    double get(int row, int column) const {\n        for(int i = 0; i < data.size(); ++ i)\n            if(data[i].row == row && data[i].column == column)\n                return data[i].value;\n        return 0;\n    }\n    void print() {\n        for(int i = 0; i < data.size(); ++ i) {\n            for(int j = 0; j < data.size() - 1; ++ j) {\n                if(data[j].row > data[j+1].row || (data[j].row == data[j+1].row && data[j].column > data[j+1].column)) {\n                    int temp;\n                    double temp2;\n                    temp = data[j].row; data[j].row = data[j+1].row;data[j+1].row = temp;\n                    temp = data[j].column; data[j].column = data[j+1].column;data[j+1].column = temp;\n                    temp2 = data[j].value; data[j].value = data[j+1].value;data[j+1].value = temp2;\n                }\n            }\n        }\n        for(int i = 0; i < data.size(); ++ i) {\n            cout << \"(\" << data[i].row << \",\" << data[i].column << \",\" << data[i].value << \")\" << endl;\n        }\n    }\n    Sparse operator * (Sparse & sparse2) {\n        Sparse ans(this->rows, sparse2.columns);\n        int sum1 = sparse2.data.size();\n        int sum2 = this->data.size();\n        for(int i = 0; i < sum1; ++ i) {\n            for(int j = 0; j < sum2; ++ j) {\n                if(this->data[j].column == sparse2.data[i].row) {\n                    int check = 0;\n                    for(int k = 0; k < ans.data.size(); ++ k) {\n                        if(this->data[j].row == ans.data[k].row && sparse2.data[i].column == ans.data[k].column) {\n                            ans.data[k].value += this->data[j].value * sparse2.data[i].value;\n                            check = 1;\n                        }\n                    }\n                    if(check == 0) {\n                        Entry temp;\n                        temp.row = this->data[j].row;\n                        temp.column = sparse2.data[i].column;\n                        temp.value = this->data[j].value * sparse2.data[i].value;\n                        ans.data.push_back(temp);\n                    }\n                }\n            }\n            \n        }\n        return ans;\n    }\n};",
            1591719385.5971847,
            100,
            "# 答案正确"
        ],
        [
            "8.5 (C++)",
            "吴渝峰",
            "#include <iostream>\nusing namespace std;\nclass Point3D : public Point2D {\nprivate:\n    double z;\npublic:\n    Point3D() {\n        setX(0);\n        setY(0);\n        z = 0;\n    }\n    Point3D(double x1, double y1, double z1) {\n        setX(x1);\n        setY(y1);\n        this->z = z1;\n    }\n    double getZ() {\n        return z;\n    }\n    double distance(Point2D & point2) {\n        Point3D* point1;\n        point1 = reinterpret_cast<Point3D *>(&point2);\n\t\tdouble dx = getX() - point1->getX();\n\t\tdouble dy = getY() - point1->getY();\n        double dz = getZ() - point1->getZ();\n\t\treturn sqrt(dx * dx + dy * dy + dz * dz);\n\t}\n};",
            1591844993.6954086,
            100,
            "# 答案正确"
        ],
        [
            "8.6 (C++)",
            "吴渝峰",
            "#include <iostream>\nusing namespace std;\n\nclass MyTensor : public Tensor<double> {\nprotected:\n    double* Array;\npublic:\n    MyTensor(vector<int> indexs) : Tensor(indexs) {\n        int sum = 1;\n        for(int i = 0; i < indexs.size(); ++ i)\n            sum *= indexs[i]; \n        Array = new double[sum];\n        for(int i = 0; i < sum; ++ i)\n            Array[i] = 0;\n    }\n    ~MyTensor() {\n        delete[] Array;\n    }\n    double & get(const vector<int> & indexes) {\n        int ptr;\n        if(indexes.size() == 3) {\n            int ptr1 = sizes[1] * sizes[2];\n            int ptr2 = sizes[2];\n            ptr = indexes[0] * ptr1 + indexes[1] * ptr2 + indexes[2];\n        }\n        if(indexes.size() == 4) {\n            int ptr1 = sizes[1] * sizes[2] * sizes[3];\n            int ptr2 = sizes[2] * sizes[3];\n            int ptr3 = sizes[3];\n            ptr = indexes[0] * ptr1 + indexes[1] * ptr2 + indexes[2] * ptr3 + indexes[3];    \n        }\n        return Array[ptr];\n    }\n};",
            1592450280.0685766,
            100,
            "# 答案正确"
        ],
        [
            "9.1 (C++)",
            "吴渝峰",
            "class Circle {\nprotected:\n    double radii;\npublic:\n    Circle(double radius) : radii(radius) { }\n    bool operator < (Circle other) {\n        if(radii < other.radii) return true;\n        return false;\n    }\n    bool operator <= (Circle other) {\n        if(radii <= other.radii) return true;\n        return false;\n    }\n    bool operator == (Circle other) {\n        if(radii == other.radii) return true;\n        return false;\n    }\n    bool operator != (Circle other) {\n        if(radii != other.radii) return true;\n        return false;\n    }\n    bool operator > (Circle other) {\n        if(radii > other.radii) return true;\n        return false;\n    }\n    bool operator >= (Circle other) {\n        if(radii >= other.radii) return true;\n        return false;\n    }\n};",
            1592539441.341926,
            100,
            "# 答案正确"
        ],
        [
            "9.3 (C++)",
            "吴渝峰",
            "class Complex {\npublic:\n    double reals;\n    double image;\n\n    Complex() {\n        reals = 0;\n        image = 0;\n    }\n    Complex(double real, double imag) {\n        reals = real;\n        image = imag;\n    }\n    double real() {\n        return reals;\n    }\n    double imag() {\n        return image;\n    }\n    Complex operator + (Complex & other) {\n        Complex ans(this->reals, this->image);\n        ans.reals += other.reals;\n        ans.image += other.image;\n        return ans;\n    }\n    Complex operator - (Complex & other) {\n        Complex ans(this->reals, this->image);\n        ans.reals -= other.reals;\n        ans.image -= other.image;\n        return ans;\n    }\n    Complex operator * (Complex & other) {\n        Complex ans;\n        ans.reals = reals * other.reals - image * other.image;\n        ans.image = image * other.reals + reals * other.image;\n        return ans;\n    }\n    Complex operator / (Complex & other) {\n        Complex ans;\n        ans.reals = (reals * other.reals + image * other.image) / (other.reals * other.reals + other.image * other.image);\n        ans.image = (image * other.reals - reals * other.image) / (other.reals * other.reals + other.image * other.image);\n        return ans;\n    }\n    Complex operator - (double real) {\n        Complex ans(this->reals, this->image);\n        ans.reals -= real;\n        return ans;\n    }\n    Complex operator += (Complex & other) {\n        this->reals += other.reals;\n        this->image += other.image;\n        return (*this);\n    }\n    Complex operator -= (Complex & other) {\n        this->reals -= other.reals;\n        this->image -= other.image;\n        return (*this);\n    }\n    Complex operator *= (Complex & other) {\n\t\tdouble real = reals;\n        this->reals = reals * other.reals - image * other.image;\n        this->image = image * other.reals + real * other.image;\n        return (*this);\n    }\n    Complex operator /= (Complex & other) {\n\t\tdouble real = reals;\n        this->reals = (reals * other.reals + image * other.image) / (other.reals * other.reals + other.image * other.image);\n        this->image = (image * other.reals - real * other.image) / (other.reals * other.reals + other.image * other.image);\n        return (*this);\n    }\n    bool operator == (Complex & other) {\n        if(reals == other.reals && image == other.image) return true;\n        return false;\n    }\n    bool operator != (Complex & other) {\n        if(reals != other.reals || image != other.image) return true;\n        return false;\n    }\n};\n\nComplex operator + (double real, Complex other) {\n    Complex ans(other.reals, other.image);\n    ans.reals += real;\n    return ans;\n}",
            1593065837.4861574,
            100,
            "# 答案正确"
        ],
        [
            "9.4 (C++)",
            "吴渝峰",
            "class Complex {\npublic:\n    double reals;\n    double image;\n\n    Complex() {\n        reals = 0;\n        image = 0;\n    }\n    Complex(double real, double imag) {\n        reals = real;\n        image = imag;\n    }\n    Complex operator + (Complex & other) {\n        Complex ans(this->reals, this->image);\n        ans.reals += other.reals;\n        ans.image += other.image;\n        return ans;\n    }\n    Complex operator - (Complex & other) {\n        Complex ans(this->reals, this->image);\n        ans.reals -= other.reals;\n        ans.image -= other.image;\n        return ans;\n    }\n};\n\nistream & operator >> (istream & in, Complex & m) {\n    in >> m.reals >> m.image;\n    return in;\n}\n\nostream & operator << (ostream & out, Complex & m) {\n    out << m.reals << \" + \" << m.image << \" i\";\n    return out;\n} ",
            1592802592.8319721,
            100,
            "# 答案正确"
        ],
        [
            "9.5 (C++)",
            "吴渝峰",
            "class Complex {\npublic:\n    double reals;\n    double image;\n    Complex() {\n        reals = 0;\n        image = 0;\n    }\n    Complex(double real, double imag) {\n        reals = real;\n        image = imag;\n    }\n    Complex(Complex & other) {\n        reals = other.reals;\n        image = other.image;\n    }\n    Complex & operator ++ () {\n        this->reals ++;\n        return (*this);\n    }\n    Complex operator ++ (int) {\n        Complex prev(*this);\n        this->reals ++;\n        return prev;\n    }\n    operator double() const {\n        return this->reals;\n    }\n};\n\nistream & operator >> (istream & in, Complex & m) {\n    in >> m.reals >> m.image;\n    return in;\n}\n\nostream & operator << (ostream & out, const Complex & m) {\n    out << m.reals << \" + \" << m.image << \" i\";\n    return out;\n} ",
            1592811386.1301105,
            100,
            "# 答案正确"
        ],
        [
            "9.2 (C++)",
            "吴渝峰",
            "class I {\npublic:\n    vector<int> data;\n    I(int a, int b, int c) {\n        data.push_back(a);\n        data.push_back(b);\n        data.push_back(c);\n    }\n    I(int a, int b, int c, int d) {\n        data.push_back(a);\n        data.push_back(b);\n        data.push_back(c);\n        data.push_back(d);\n    }\n    operator vector<int>() {\n        return this->data;\n    }\n};",
            1592813166.3261032,
            100,
            "# 答案正确"
        ],
        [
            "9.6 (C++)",
            "吴渝峰",
            "class Tensor {\n    vector<int> sizes;\n\tvector<double> values;\n    int _index(const vector<int> & indexes) const {\n\t\tint index = 0;\n\t\tfor (int i = 0; i < this->sizes.size(); ++ i) {\n\t\t\tindex *= sizes[i];\n\t\t\tindex += indexes[i];\n\t\t}\n\t\treturn index;\n\t}\npublic:\n    int numel() const {\n\t\tif (this->sizes.size() == 0) return 0;\n\t\tint size = 1;\n\t\tfor (int i = 0; i < this->sizes.size(); ++ i) size *= sizes[i];\n\t\treturn size;\n\t}\n    Tensor(int a, int b, int c) {\n        this->sizes.push_back(a);\n        this->sizes.push_back(b);\n        this->sizes.push_back(c);\n        this->values.resize(this->numel());\n\t\tfor (int i = 0; i < this->numel(); ++ i) this->values[i] = 0;\n    }\n    Tensor(int a, int b, int c, int d) {\n        this->sizes.push_back(a);\n        this->sizes.push_back(b);\n        this->sizes.push_back(c);\n        this->sizes.push_back(d);\n        this->values.resize(this->numel());\n\t\tfor (int i = 0; i < this->numel(); ++ i) this->values[i] = 0;\n    }\n    double & operator () (int a, int b, int c) {\n        vector<int> m;\n        m.push_back(a);\n        m.push_back(b);\n        m.push_back(c);\n        return values[this->_index(m)];\n    }\n    double & operator () (int a, int b, int c, int d) {\n        vector<int> m;\n        m.push_back(a);\n        m.push_back(b);\n        m.push_back(c);\n        m.push_back(d);\n        return values[this->_index(m)];\n    }\n};",
            1592841683.2805443,
            100,
            "# 答案正确"
        ],
        [
            "9.7 (C++)",
            "吴渝峰",
            "class Tensor {\npublic:\n    int dimension;\n    vector<int> sizes;\n\tvector<double> values;\n\t\n    int numel() const {\n\t\tif (this->sizes.size() == 0) return 0;\n\t\tint size = 1;\n\t\tfor (int i = 0; i < this->sizes.size(); ++ i) size *= sizes[i];\n\t\treturn size;\n\t}\n    Tensor() {\n        dimension = 0;\n    }\n};\n\nistream & operator >> (istream & in, Tensor & m) {\n    in >> m.dimension;\n    int tmp = 0;\n    for(int i = 0; i < m.dimension; ++ i) {\n        in >> tmp;\n        m.sizes.push_back(tmp);\n    }\n    double tmp2 = 0;\n    for(int i = 0; i < m.numel(); ++ i) {\n        in >> tmp2;\n        m.values.push_back(tmp2);\n    }\n    return in;\n}\n\nostream & operator << (ostream & out, const Tensor & m) {\n    out << m.dimension << endl;\n    for(int i = 0; i < m.sizes.size(); ++ i) {\n        out << m.sizes[i] << \" \";\n    }\n    out << endl << endl;\n    int size1 = 1;\n    int size2 = m.sizes[m.sizes.size() - 2];\n    int size3 = m.sizes[m.sizes.size() - 1];\n    int ptr = 0;\n    for(int i = 0; i < m.sizes.size() - 2; ++ i) {\n        size1 *= m.sizes[i];\n    }\n    for(int i = 0; i < size1; ++ i) {\n        for(int j = 0; j < size2; ++ j) {\n            for(int k = 0; k < size3; ++ k) {\n                out << m.values[ptr++] << \" \";\n            }\n            out << endl;\n        }\n        out << endl;\n    }\n    return out;\n}",
            1592913185.0982955,
            100,
            "# 答案正确"
        ],
        [
            "10.1 (C++)",
            "吴渝峰",
            "#include <stdexcept>\n\nclass MatrixSizesDoNotMatchException {};\n\ndouble Matrix::get(int row, int column) const {\n    if(row > rows || column > columns)\n        throw out_of_range(\"out_of_range\");\n    return this->elements[(row - 1) * columns + column - 1];\n}\n\nvoid Matrix::set(int row, int column, double value) {\n    if(row > rows || column > columns)\n        throw out_of_range(\"out_of_range\");\n    this->elements[(row - 1) * columns + column - 1] = value;\n}\n\nMatrix Matrix::operator + (const Matrix & matrix2) const {\n    if(rows != matrix2.rows || columns != matrix2.columns)\n        throw MatrixSizesDoNotMatchException();\n    Matrix tmp(rows, columns);\n    for(int i = 0; i < rows * columns; ++ i)\n        tmp.elements[i] = this->elements[i] + matrix2.elements[i];\n    return tmp;\n}",
            1593317089.6744292,
            100,
            "# 答案正确"
        ],
        [
            "10.2 (C++)",
            "吴渝峰",
            "catch (NonPositiveValueException & ex) {\n\tcout << \"caught: NonPositiveValueException\" << endl;\n} catch (out_of_range & ex) {\n\tcout << \"caught: out_of_range\" << endl;\n}",
            1593656079.3627038,
            100,
            "# 答案正确"
        ],
        [
            "15.1 (C++)",
            "吴渝峰",
            "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\ntypedef struct {\n    vector<string> column;\n    vector< vector<string> > data;\n}Json;\n\nclass Table {\n    vector<string> column;\n    vector< vector<string> > data;\npublic:\n    void addCol(string a) {\n        column.push_back(a);\n    }\n    vector<string> & operator [] (int x) {\n\t\tvector<string> tmp = column;\n        data.push_back(tmp);\n        return data[x];\n    }\n    Json json() const {\n        Json ans;\n        ans.column = column;\n        ans.data = data;\n        return ans;\n    }\n};\n\nostream & operator << (ostream & out, const Json & json) {\n    out << \"{\" << endl;\n    out << \"\\t\" << \"headers: ['\" << json.column[0] << \"','\" << json.column[1] << \"',],\" << endl;\n    out << \"\\t\" << \"rows: [\" << endl;\n    out << \"\\t\\t\" << \"['\" << json.data[0][0] << \"','\" << json.data[0][1] << \"',],\" << endl;\n    out << \"\\t\\t\" << \"['\" << json.data[1][0] << \"','\" << json.data[1][1] << \"',],\" << endl;\n    out << \"\\t\" << \"],\" << endl;\n    out << \"}\" << endl;\n    return out;\n}",
            1594129826.1918573,
            100,
            "# 答案正确"
        ],
        [
            "2020-07-09 LAB",
            "吴渝峰",
            "#include <iostream>\nusing namespace std;\n\nclass Integer;\nInteger * a[2];\n\nclass Integer {\n    int data;\n    static int ptr;\n    friend istream & operator >> (istream & in, Integer & integer);\n    friend ostream & operator << (ostream & out, Integer & integer);\npublic:\n    Integer() {\n        data = 0;\n        a[ptr++] = this;\n    }\n    Integer(int other) {\n        data = other;\n        a[ptr++] = this;\n    }\n    static void increase_all(int other) {\n        for(int i = 0; i < 2; ++ i) {\n            a[i]->data += other;\n        }\n    }\n    static void increase_all(Integer integer) {\n        for(int i = 0; i < 2; ++ i) {\n            a[i]->data += integer.data;\n        }\n    }\n};\n\nint Integer::ptr = 0;\n\nistream & operator >> (istream & in, Integer & integer) {\n    in >> integer.data;\n    return in;\n}\n\nostream & operator << (ostream & out, Integer & integer) {\n    out << integer.data;\n    return out;\n}",
            1594262916.0499833,
            100,
            "# 答案正确"
        ],
        [
            "A.1 (C++)",
            "吴渝峰",
            "private:\n    Node<E> * get_node(int index) const {\n\t\tif (index < 0 || index >= _size) \n\t\t\tthrow NotSuchElementException();\n\t\tif (index < _size / 2) {\n            if(index == 0) return head;\n            if(index == 1) {\n                Node<E> * temp = head->next_node(0);\n                return temp;\n            }\n\t\t\tNode<E> * node1 = head;\n            Node<E> * node2 = node1->next_node(0);\n            for(int i = 0; i < index - 1; ++ i) {\n                Node<E> * temp = node2;\n                node2 = node2->next_node(node1);\n                node1 = temp;\n            }\n            return node2;\n\t\t}\n\t\telse {\n            if(index == _size - 1) return tail;\n            if(index == _size - 2) {\n                Node<E> * temp = tail->prev_node(0);\n                return temp;\n            }\n\t\t\tNode<E> * node1 = tail;\n            Node<E> * node2 = node1->prev_node(0);\n            for(int i = 0; i < _size - 2 - index; ++ i) {\n                Node<E> * temp = node2;\n                node2 = node2->prev_node(node1);\n                node1 = temp;\n            }\n            return node2;\n\t\t}\n\t}\npublic:\n    void add(int index, const E & e) {\n\t\tif (index < 0 || index > _size) \n\t\t\tthrow NotSuchElementException();\n\t\tNode<E> * node = new Node<E>();\n\t\tnode->element = e;\n        if(_size == 0) {\n            head = node;\n            tail = node;\n            node->update_prev_and_next_node(0, 0);\n            ++ _size;\n            return;\n        }\n        if(index == 0 && _size == 1) {\n            head->update_prev_and_next_node(node, 0);\n            node->update_prev_and_next_node(0, head);\n            head = node;\n            ++ _size;\n            return;\n        }\n        if(index == 0) {\n            Node<E> * head_next_node = head->next_node(0);\n            head->update_prev_and_next_node(node, head_next_node);\n            node->update_prev_and_next_node(0, head);\n            head = node;\n            ++ _size;\n            return;\n        }\n        if(index == _size && _size == 1) {\n            tail->update_prev_and_next_node(0, node);\n            node->update_prev_and_next_node(tail, 0);\n            tail = node;\n            ++ _size;\n            return;\n        }\n        if(index == _size) {\n            Node<E> * tail_prev_node = tail->prev_node(0);\n            tail->update_prev_and_next_node(tail_prev_node, node);\n            node->update_prev_and_next_node(tail, 0);\n            tail = node;\n            ++ _size;\n            return;\n        }\n\t}\n    void addFirst (const E & e) {\n\t\tadd(0, e);\n\t}\n\n\tvoid addLast (const E & e) {\n\t\tadd(_size, e);\n\t}\n    void remove (int index) {\n        if(index == 0) {\n\t\t\tif(_size == 1) {\n\t\t\t\tdelete head;\n\t\t\t\thead = NULL;\n\t\t\t\ttail = NULL;\n\t\t\t\t-- _size;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(_size == 2) {\n\t\t\t\tdelete head;\n\t\t\t\thead = tail;\n\t\t\t\t-- _size;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tNode<E> * node = head;\n            Node<E> * next_node = head->next_node(0);\n            Node<E> * next_next_node = next_node->next_node(head);\n            delete node;\n            head = next_node;\n            head->update_prev_and_next_node(0, next_next_node);\n            -- _size;\n            return;\n        }\n        if(index == _size - 1) {\n            Node<E> * prev_node = tail->prev_node(0);\n            Node<E> * prev_prev_node = prev_node->prev_node(tail);\n            delete tail;\n            tail = prev_node;\n            tail->update_prev_and_next_node(0, prev_prev_node);\n            -- _size;\n            return;\n        }\n\t\tNode<E> * node = get_node(index);\n\t\tNode<E> * prev_node = get_node(index - 1);\n\t\tNode<E> * next_node = get_node(index + 1);\n\t\tNode<E> * prev_prev_node = prev_node->prev_node(node);\n\t\tNode<E> * next_next_node = next_node->next_node(node);\n\t\tNode<E> * temp = prev_node;\n\t\tprev_node->update_prev_and_next_node(prev_prev_node, next_node);\n\t\tnext_node->update_prev_and_next_node(temp, next_next_node);\n\t\tdelete node;\n\t\t-- _size;\n\t}\n    int indexOf(const E & e) const {\n\t\tNode<E> * node = head;\n\t\tif(node->element == e) return 0;\n\t\tNode<E> * node_next = node->next_node(head);\n\t\tI(i, _size) {\n\t\t\tif (node_next->element == e) return i + 1;\n\t\t\tNode<E> * temp = node_next;\n\t\t \tnode_next = node_next->next_node(node);\n\t\t\tnode = temp;\n\t\t}\n\t\treturn -1;\n\t}\n    void removeFirstOccurrence(const E & e) {\n\t\t int index = indexOf(e);\n\t\t if (index == -1)\n\t\t \tthrow NotSuchElementException();\n\t\t remove(index);\n\t}\n    void removeFirst () {\n\t\tremove(0);\n\t}\n\tvoid removeLast () {\n\t\tremove(_size-1);\n\t}\n    E & get(int index) const {\n\t\tNode<E> * node = get_node(index);\n\t\treturn node->element;\n\t}\n    void clear() {\n\t\twhile (_size > 0) removeFirst();\n\t}\n    void addAll(const LinkedList & list, int index=-1) {\n\t\tif (index == -1) index = _size;\n\t\tI(i, list._size) {\n\t\t\tNode<E> * node = list.get_node(i);\n\t\t\tadd(index + i, node->element);\n\t\t}\n\t}\n\tLinkedList(const LinkedList & list) : _size(0), head(0), tail(0) {\n\t\taddAll(list);\n\t}\n\tLinkedList & operator = (const LinkedList & list) {\n\t\tclear();\n\t\taddAll(list);\n\t\treturn *this;\n\t}\n    ~LinkedList() {\n\t\tclear();\n\t}",
            1594867783.7546146,
            100,
            "# 答案正确"
        ],
        [
            "A.2 (C++)",
            "吴渝峰",
            "template <typename E>\nvoid LinkedList<E>::removeAll(const E & e) {\n\tNode<E> * temp;\n\tI(i, _size) {\n\t\ttemp = get_node(i);\n\t\tif(temp->element == e) {\n\t\t\tremove(i);\n\t\t\ti --;\n\t\t}\n\t}\n}",
            1594867908.259082,
            100,
            "# 答案正确"
        ],
        [
            "A.4 (C++)",
            "吴渝峰",
            "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <stdexcept>\nusing namespace std;\n\n#define I(i,n) for (size_t i = 0; i < n; ++ i)\n\nclass NoSuchKeyException {};\n\nsize_t circular_shift(size_t bits, int shift_bits) {\n\tconst int num_bits = 8 * sizeof(size_t);\n\tshift_bits = shift_bits % num_bits;\n\treturn bits << shift_bits | bits >> (num_bits - shift_bits);\n}\n\nsize_t hash_function(const string & key) {\n\tsize_t code = 0;\n\tI(i, key.size())\n\t\tcode ^= circular_shift(key[i], i * 5);\n\treturn code;\n}\n\nclass HT {\n    class Tuple {\n    public:\n        string key;\n        string val;\n        bool in_use;\n\n        Tuple() : in_use(false) {}\n        operator string() const {\n            return val;\n        }\n        operator int() const {\n            int num = 0;\n            stringstream ss;\n            ss << val;\n            ss >> num;\n            return num;\n        }\n    };\n    vector<Tuple> tuples;\n    size_t _size;\n\n    size_t canonical_index(const string & key) const {\n\t\tsize_t hash_code = hash_function(key);\n\t\treturn hash_code % tuples.size();\n\t}\n\tsize_t indexOfKey(const string & key) const {\n\t\tsize_t index = canonical_index(key);\n\t\twhile (true) {\n\t\t\tif (! tuples[index].in_use) return index;\n\t\t\tif (tuples[index].key == key) return index;\n\t\t\tindex = (index + 1) % tuples.size();\n\t\t}\n\t}\npublic:\n    HT() : _size(0) {\n\t\ttuples.resize(2);\n\t}\n\tTuple & operator [] (const int & key1) {\n        string key = to_string(key1);\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples[index];\n\t}\n    Tuple & operator [] (const string & key) {\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples[index];\n\t}\n    void put(const string & key, const string & val) {\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].key = key;\n\t\ttuples[index].val = val;\n\t\tif (tuples[index].in_use) return;\n\t\ttuples[index].in_use = true;\n\t\t++ _size;\n\t\tif (2 * _size > tuples.size())\n\t\t\t_double_tuples();\n\t}\n    void put(const string & key, const int & val1) {\n        string val = to_string(val1);\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].key = key;\n\t\ttuples[index].val = val;\n\t\tif (tuples[index].in_use) return;\n\t\ttuples[index].in_use = true;\n\t\t++ _size;\n\t\tif (2 * _size > tuples.size())\n\t\t\t_double_tuples();\n\t}\n    void put(const int & key1, const string & val) {\n        string key = to_string(key1);\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].key = key;\n\t\ttuples[index].val = val;\n\t\tif (tuples[index].in_use) return;\n\t\ttuples[index].in_use = true;\n\t\t++ _size;\n\t\tif (2 * _size > tuples.size())\n\t\t\t_double_tuples();\n\t}\n    void put(const int & key1, const int & val1) {\n        string key = to_string(key1);\n        string val = to_string(val1);\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].key = key;\n\t\ttuples[index].val = val;\n\t\tif (tuples[index].in_use) return;\n\t\ttuples[index].in_use = true;\n\t\t++ _size;\n\t\tif (2 * _size > tuples.size())\n\t\t\t_double_tuples();\n\t}\n    void _double_tuples() {\n\t\tvector<Tuple> non_empty_tuples;\n\t\tI(i, tuples.size())\n\t\t\tif (tuples[i].in_use)\n\t\t\t\tnon_empty_tuples.push_back(tuples[i]);\n\t\tclear();\n\t\ttuples.resize(tuples.size() * 2);\n\t\tI(i, non_empty_tuples.size())\n\t\t\tput(non_empty_tuples[i].key, non_empty_tuples[i].val);\n\t}\n    static bool _between(size_t hole, size_t canonical, size_t tuple_index) {\n\t\tif (hole < tuple_index)\n\t\t\treturn canonical > hole && canonical <= tuple_index;\n\t\telse\n\t\t\treturn canonical > hole || canonical <= tuple_index;\n\t}\n\tvoid remove(const string & key) { \n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\ttuples[index].in_use = false;\n\t\t-- _size;\n\t\tsize_t hole = index;\n\t\tsize_t tuple_index = hole;\n\t\twhile (true) {\n\t\t\ttuple_index = (tuple_index + 1) % tuples.size();\n\t\t\tif (! tuples[tuple_index].in_use) return;\n\t\t\tsize_t canonical = canonical_index(tuples[tuple_index].key);\n\t\t\tif (_between(hole, canonical, tuple_index)) continue;\n\t\t\ttuples[hole] = tuples[tuple_index];\n\t\t\thole = tuple_index;\n\t\t\ttuples[hole].in_use = false;\n\t\t}\n\t}\n\tsize_t size() const { return _size; }\n\tvoid clear() {\n\t\tI(i, tuples.size())\n\t\t\ttuples[i].in_use = false;\n\t\t_size = 0;\n\t}\n};",
            1595696099.537708,
            100,
            "# 答案正确"
        ],
        [
            "A.3 (C++)",
            "吴渝峰",
            "#include <iostream>\n#include <vector>\n#include <string>\n#include <stdexcept>\nusing namespace std;\n\n#define I(i,n) for (size_t i = 0; i < n; ++ i)\n\nclass NoSuchKeyException {};\n\nsize_t hash_function(const int & key) {\n\tsize_t code = key;\n\treturn code;\n}\n\ntemplate <typename V>\nclass HT {\n\tclass Tuple {\n\tpublic:\n\t\tint key;\n\t\tV val;\n\t\tbool in_use;\n\n\t\tTuple() : in_use(false) {}\n\t};\n\n\tvector<Tuple> tuples;\n\tsize_t _size;\n\n\tsize_t canonical_index(const int & key) const {\n\t\tsize_t hash_code = hash_function(key); \n\t\treturn hash_code % tuples.size();\n\t}\n\n\tsize_t indexOfKey(const int & key) const {\n\t\tsize_t index = canonical_index(key);\n\t\twhile (true) { \n\t\t\tif (! tuples[index].in_use) return index;\n\t\t\tif (tuples[index].key == key) return index;\n\t\t\tindex = (index + 1) % tuples.size();\n\t\t}\n\t}\n\npublic:\n\tHT() : _size(0) {\n\t\ttuples.resize(2);\n\t}\n\n\tbool containsKey(const int & key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\treturn tuples[index].in_use;\n\t}\n\n\tconst V & operator [] (const int & key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples[index].val;\n\t}\n\n\tV & operator [] (const int & key) {\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples[index].val;\n\t}\n\n\tvoid put(const int & key, const V & val) {\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].key = key;\n\t\ttuples[index].val = val;\n\t\tif (tuples[index].in_use) return;\n\t\ttuples[index].in_use = true;\n\t\t++ _size;\n\t\tif (2 * _size > tuples.size())\n\t\t\t_double_tuples();\n\t}\n\n\tvoid _double_tuples() {\n\t\tvector<Tuple> non_empty_tuples;\n\t\tI(i, tuples.size())\n\t\t\tif (tuples[i].in_use)\n\t\t\t\tnon_empty_tuples.push_back(tuples[i]);\n\t\tclear();\n\t\ttuples.resize(tuples.size() * 2);\n\t\tI(i, non_empty_tuples.size())\n\t\t\tput(non_empty_tuples[i].key, non_empty_tuples[i].val);\n\t}\n\n\tstatic bool _between(size_t hole, size_t canonical, size_t tuple_index) {\n\t\tif (hole < tuple_index)\n\t\t\treturn canonical > hole && canonical <= tuple_index;\n\t\telse\n\t\t\treturn canonical > hole || canonical <= tuple_index;\n\t}\n\n\tvoid remove(const int & key) { \n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\ttuples[index].in_use = false;\n\t\t-- _size;\n\t\tsize_t hole = index;\n\t\tsize_t tuple_index = hole;\n\t\twhile (true) {\n\t\t\ttuple_index = (tuple_index + 1) % tuples.size();\n\t\t\tif (! tuples[tuple_index].in_use) return;\n\t\t\tsize_t canonical = canonical_index(tuples[tuple_index].key);\n\t\t\tif (_between(hole, canonical, tuple_index)) continue;\n\t\t\ttuples[hole] = tuples[tuple_index];\n\t\t\thole = tuple_index;\n\t\t\ttuples[hole].in_use = false;\n\t\t}\n\t}\n\n\tsize_t size() const { return _size; }\n\n\tvoid clear() {\n\t\tI(i, tuples.size())\n\t\t\ttuples[i].in_use = false;\n\t\t_size = 0;\n\t}\n\n    vector<int> getKeys() {\n        vector<int> ans;\n\t\tI(i, tuples.size())\n\t\t\tif(tuples[i].in_use == true)\n            \tans.push_back(tuples[i].key);\n        return ans;\n    }\n};",
            1595472863.4494722,
            100,
            "# 答案正确"
        ],
        [
            "A.5 (C++)",
            "吴渝峰",
            "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <stdexcept>\nusing namespace std;\n\n#define I(i,n) for (size_t i = 0; i < n; ++ i)\n\nclass NoSuchKeyException {};\n\nsize_t circular_shift(size_t bits, int shift_bits) {\n\tconst int num_bits = 8 * sizeof(size_t);\n\tshift_bits = shift_bits % num_bits;\n\treturn bits << shift_bits | bits >> (num_bits - shift_bits);\n}\n\nsize_t hash_function(const string & key) {\n\tsize_t code = 0;\n\tI(i, key.size())\n\t\tcode ^= circular_shift(key[i], i * 5);\n\treturn code;\n}\n\nclass HT {\n\tclass Tuple {\n\tpublic:\n\t\tstring key;\n\t\tstring val;\n\t\tbool in_use;\n\n\t\tTuple() : in_use(false) {}\n\t};\n\n    class TupleRef {\n    public:\n        HT * ht;\n        Tuple * tuple;\n        const string & key;\n\n        TupleRef(HT * ht, Tuple * tuple, const string & key) : ht(ht), tuple(tuple), key(key) {}\n\n        operator string() const {\n            if(tuple == 0) throw NoSuchKeyException();\n            return tuple->val;\n        }\n\n        operator int() const {\n            if(tuple == 0) throw NoSuchKeyException();\n            int num = 0;\n            stringstream ss;\n            ss << tuple->val;\n            ss >> num;\n            return num;\n        }\n\n        TupleRef & operator = (const string & val) {\n            if(tuple == 0) {\n                ht->put(key, val);\n            }\n            else {\n                tuple->val = val; \n                ++ ht->_size;\n            }\n            return *this;\n        }\n\n        TupleRef & operator = (const int & val1) {\n            string val;\n            stringstream ss;\n            ss << val1;\n            ss >> val;\n            if(tuple == 0) {\n                ht->put(key, val);\n            }\n            else {\n                tuple->val = val; \n                ++ ht->_size;\n            }\n            return *this;\n        }\n    };\n\n\tvector<Tuple> tuples;\n\tsize_t _size;\n\n\tsize_t canonical_index(const string & key) const {\n\t\tsize_t hash_code = hash_function(key); // needs hash_function(K)\n\t\treturn hash_code % tuples.size();\n\t}\n\n\t// the returned tuple is either empty or with the same key\n\tsize_t indexOfKey(const string & key) const {\n\t\tsize_t index = canonical_index(key);\n\t\twhile (true) { // will enter a dead loop if there is not empty tuple\n\t\t\tif (! tuples[index].in_use) return index;\n\t\t\tif (tuples[index].key == key) return index;\n\t\t\tindex = (index + 1) % tuples.size();\n\t\t}\n\t}\n\npublic:\n\tHT() : _size(0) {\n\t\ttuples.resize(10);\n\t}\n\n    TupleRef operator [] (const string & key) {\n        size_t index = indexOfKey(key);\n        if(index == -1) {\n            return TupleRef(this, 0, key);\n        }\n        return TupleRef(this, &tuples[index], key);\n    }\n\n    TupleRef operator [] (const int & key1) {\n        string key;\n        stringstream ss;\n        ss << key1;\n        ss >> key;\n        size_t index = indexOfKey(key);\n        if(index == -1) {\n            return TupleRef(this, 0, key);\n        }\n        return TupleRef(this, &tuples[index], key);\n    }\n\n\tvoid put(const string & key, const string & val) {\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].key = key;\n\t\ttuples[index].val = val;\n\t\tif (tuples[index].in_use) return;\n\t\ttuples[index].in_use = true;\n\t\t++ _size;\n\t\t// make sure empty > size / 2\n\t\tif (2 * _size > tuples.size())\n\t\t\t_double_tuples();\n\t}\n\n\tvoid _double_tuples() {\n\t\tvector<Tuple> non_empty_tuples;\n\t\tI(i, tuples.size())\n\t\t\tif (tuples[i].in_use)\n\t\t\t\tnon_empty_tuples.push_back(tuples[i]);\n\t\tclear();\n\t\ttuples.resize(tuples.size() * 2);\n\t\tI(i, non_empty_tuples.size())\n\t\t\tput(non_empty_tuples[i].key, non_empty_tuples[i].val);\n\t}\n\n\tsize_t size() const { return _size; }\n\n\tvoid clear() {\n\t\tI(i, tuples.size())\n\t\t\ttuples[i].in_use = false;\n\t\t_size = 0;\n\t}\n};",
            1595913332.4820125,
            100,
            "# 答案正确"
        ]
    ],
    "table_name": "答案"
}