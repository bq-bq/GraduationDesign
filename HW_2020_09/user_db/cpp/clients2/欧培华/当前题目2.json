{
    "__update_time__": 1595789578.9059894,
    "field_names": [
        "题目名",
        "问题",
        "主程序",
        "答案",
        "评语",
        "开始时间",
        "截止时间",
        "分数",
        "提交时间"
    ],
    "field_types": [
        "text",
        "text",
        "text",
        "text",
        "text",
        "time",
        "time",
        "number",
        "time"
    ],
    "rows": [
        [
            "A.5 (C++)",
            "<p>写出一个键和值的类型都可以是string或int的哈希表类, HT。<br>本题难度大，参考答案有270行，截止时间延长8天。<br>注意<br></p><ol><li>HT不是一个模版类，但是HT的一个对象可以同时使用int和string的对象作为键。</li><li>HT中去掉了put函数，HT的[]操作符同时具有get和put的功能。</li></ol><p><span style=\"font-weight: bolder;\">EXAMPLE INPUT</span></p><pre style=\"font-size: 14px;\">1 2 3 4 5 6 7 8\n</pre><p><span style=\"font-weight: bolder;\">EXAMPLE OUTPUT</span></p><pre style=\"font-size: 14px;\">4\n2\n4\n6\n8</pre>",
            "#include \"source.cpp\"\n\n#include <iostream>\n#include <sstream>\nusing namespace std;\n\nint main() {\n\tHT map;\n\t\n\tint key1;\n\tint value1;\n\tcin >> key1 >> value1;\n\tmap[key1] = value1;\n\t\n\tstring key2;\n\tstring value2;\n\tcin >> key2 >> value2;\n\tmap[key2] = value2;\n\t\n\tint key3;\n\tstring value3;\n\tcin >> key3 >> value3;\n\tmap[key3] = value3;\n\t\n\tstring key4;\n\tint value4;\n\tcin >> key4 >> value4;\n\tmap[key4] = value4;\n\t\n\tcout << map.size() << endl;\n\tcout << (int)map[key1] << endl;\n\tcout << (string)map[key2] << endl;\n\tcout << (string)map[key3] << endl;\n\tcout << (int)map[key4] << endl;\n}",
            "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <stdexcept>\nusing namespace std;\n\n#define I(i,n) for (size_t i = 0; i < n; ++ i)\n\nclass NoSuchKeyException {};\n\nsize_t circular_shift(size_t bits, int shift_bits) {\n    const int num_bits = 8 * sizeof(size_t);\n    shift_bits = shift_bits % num_bits;\n    return bits << shift_bits | bits >> (num_bits - shift_bits);\n}\n\nsize_t hash_function(const int & key) {\n    size_t code = 0;\n    I(i, (size_t)key)\n        code ^= circular_shift(key, i * 5);\n    return code;\n}\n\nsize_t hash_function(const string & key) {\n    size_t code = 0;\n    I(i, key.size())\n        code ^= circular_shift(key[i], i * 5);\n    return code;\n}\n\nclass HT\n{\n    class Tuple\n    {\n    public:\n        int key1;\n        string key2;\n        int val1;\n        string val2;\n        bool in_use;\n\n        Tuple() : in_use(false) {}\n\n        operator int() {return val1;}\n        operator string() {return val2;}\n\n        Tuple & operator = (const int & val){\n            this->val1 = val;\n            return *this;\n        }\n\n        Tuple & operator = (const string & val){\n            this->val2 = val;\n            return *this;\n        }\n    };\n\n    vector<Tuple> tuples;\n    size_t _size;\n\n    size_t canonical_index(const int & key) const {\n        size_t hash_code = hash_function(key); // needs hash_function(K)\n        return hash_code % tuples.size();\n    }\n\n    size_t canonical_index(const string & key) const {\n        size_t hash_code = hash_function(key); // needs hash_function(K)\n        return hash_code % tuples.size();\n    }\n\n    // the returned tuple is either empty or with the same key\n    size_t indexOfKey(const int & key) const {\n        size_t index = canonical_index(key);\n        while (true) { // will enter a dead loop if there is not empty tuple\n            if (! tuples[index].in_use) return index;\n            if (tuples[index].key1 == key) return index;\n            index = (index + 1) % tuples.size();\n        }\n    }\n\n    size_t indexOfKey(const string & key) const {\n        size_t index = canonical_index(key);\n        while (true) { // will enter a dead loop if there is not empty tuple\n            if (! tuples[index].in_use) return index;\n            if (tuples[index].key2 == key) return index;\n            index = (index + 1) % tuples.size();\n        }\n    }\n\npublic:\n    HT() : _size(0) {\n        tuples.resize(100);\n    }\n\n    Tuple & operator [] (const int & key) {\n        size_t index = indexOfKey(key);\n        if (! tuples[index].in_use) \n            put(key,-1);\n        return tuples[index];\n    }\n\n    Tuple & operator [] (const string & key) {\n        size_t index = indexOfKey(key);\n        if (! tuples[index].in_use) \n            put(key,-1);\n        return tuples[index];\n    }\n\n    void put(const int & key, const int & val) {\n        size_t index = indexOfKey(key);\n        tuples[index].key1 = key;\n        tuples[index].key2 = \"empty\";\n        tuples[index].val1 = val;\n        tuples[index].val2 = \"empty\";\n        if (tuples[index].in_use) return;\n        tuples[index].in_use = true;\n        ++ _size;\n        // make sure empty > size / 2\n        if (2 * _size > tuples.size())\n            double_tuples();\n    }\n\n    void put(const string & key, const string & val) {\n        size_t index = indexOfKey(key);\n        tuples[index].key1 = -1;\n        tuples[index].key2 = key;\n        tuples[index].val1 = -1;\n        tuples[index].val2 = val;\n        if (tuples[index].in_use) return;\n        tuples[index].in_use = true;\n        ++ _size;\n        // make sure empty > size / 2\n        if (2 * _size > tuples.size())\n            double_tuples();\n    }\n\n    void put(const int & key, const string & val) {\n        size_t index = indexOfKey(key);\n        tuples[index].key1 = key;\n        tuples[index].key2 = \"empty\";\n        tuples[index].val1 = -1;\n        tuples[index].val2 = val;\n        if (tuples[index].in_use) return;\n        tuples[index].in_use = true;\n        ++ _size;\n        // make sure empty > size / 2\n        if (2 * _size > tuples.size())\n            double_tuples();\n    }\n\n    void put(const string & key, const int & val) {\n        size_t index = indexOfKey(key);\n        tuples[index].key1 = -1;\n        tuples[index].key2 = key;\n        tuples[index].val1 = val;\n        tuples[index].val2 = \"empty\";\n        if (tuples[index].in_use) return;\n        tuples[index].in_use = true;\n        ++ _size;\n        // make sure empty > size / 2\n        if (2 * _size > tuples.size())\n            double_tuples();\n    }\n\n    void double_tuples() {\n        vector<Tuple> non_empty_tuples;\n        I(i, tuples.size())\n            if (tuples[i].in_use)\n                non_empty_tuples.push_back(tuples[i]);\n        clear();\n        tuples.resize(tuples.size() * 2);\n        I(i, non_empty_tuples.size())\n        {\n            if(non_empty_tuples[i].key2 == \"empty\" && non_empty_tuples[i].val2 == \"empty\")\n                put(non_empty_tuples[i].key1, non_empty_tuples[i].val1);\n            else if(non_empty_tuples[i].key1 == -1 && non_empty_tuples[i].val1 == -1)\n                put(non_empty_tuples[i].key2, non_empty_tuples[i].val2);\n            else if(non_empty_tuples[i].key2 == \"empty\" && non_empty_tuples[i].val1 == -1)\n                put(non_empty_tuples[i].key1, non_empty_tuples[i].val2);\n            else\n                put(non_empty_tuples[i].key2, non_empty_tuples[i].val1);\n        }\n    }\n\n    size_t size() const { return _size; }\n\n    void clear() {\n        I(i, tuples.size())\n            tuples[i].in_use = false;\n        _size = 0;\n    }\n};",
            "main.cpp: In function ‘int main()’:\nmain.cpp:13:12: error: no match for ‘operator=’ (operand types are ‘HT::Tuple’ and ‘int’)\n  map[key1] = value1;\n            ^\nIn file included from main.cpp:1:0:\nsource.cpp:34:11: note: candidate: HT::Tuple& HT::Tuple::operator=(const HT::Tuple&)\n     class Tuple\n           ^\nsource.cpp:34:11: note:   no known conversion for argument 1 from ‘int’ to ‘const HT::Tuple&’\nsource.cpp:34:11: note: candidate: HT::Tuple& HT::Tuple::operator=(HT::Tuple&&)\nsource.cpp:34:11: note:   no known conversion for argument 1 from ‘int’ to ‘HT::Tuple&&’\nmain.cpp:18:12: error: no match for ‘operator=’ (operand types are ‘HT::Tuple’ and ‘std::__cxx11::string {aka std::__cxx11::basic_string<char>}’)\n  map[key2] = value2;\n            ^\nIn file included from main.cpp:1:0:\nsource.cpp:34:11: note: candidate: HT::Tuple& HT::Tuple::operator=(const HT::Tuple&)\n     class Tuple\n           ^\nsource.cpp:34:11: note:   no known conversion for argument 1 from ‘std::__cxx11::string {aka std::__cxx11::basic_string<char>}’ to ‘const HT::Tuple&’\nsource.cpp:34:11: note: candidate: HT::Tuple& HT::Tuple::operator=(HT::Tuple&&)\nsource.cpp:34:11: note:   no known conversion for argument 1 from ‘std::__cxx11::string {aka std::__cxx11::basic_string<char>}’ to ‘HT::Tuple&&’\nmain.cpp:23:12: error: no match for ‘operator=’ (operand types are ‘HT::Tuple’ and ‘std::__cxx11::string {aka std::__cxx11::basic_string<char>}’)\n  map[key3] = value3;\n            ^\nIn file included from main.cpp:1:0:\nsource.cpp:34:11: note: candidate: HT::Tuple& HT::Tuple::operator=(const HT::Tuple&)\n     class Tuple\n           ^\nsource.cpp:34:11: note:   no known conversion for argument 1 from ‘std::__cxx11::string {aka std::__cxx11::basic_string<char>}’ to ‘const HT::Tuple&’\nsource.cpp:34:11: note: candidate: HT::Tuple& HT::Tuple::operator=(HT::Tuple&&)\nsource.cpp:34:11: note:   no known conversion for argument 1 from ‘std::__cxx11::string {aka std::__cxx11::basic_string<char>}’ to ‘HT::Tuple&&’\nmain.cpp:28:12: error: no match for ‘operator=’ (operand types are ‘HT::Tuple’ and ‘int’)\n  map[key4] = value4;\n            ^\nIn file included from main.cpp:1:0:\nsource.cpp:34:11: note: candidate: HT::Tuple& HT::Tuple::operator=(const HT::Tuple&)\n     class Tuple\n           ^\nsource.cpp:34:11: note:   no known conversion for argument 1 from ‘int’ to ‘const HT::Tuple&’\nsource.cpp:34:11: note: candidate: HT::Tuple& HT::Tuple::operator=(HT::Tuple&&)\nsource.cpp:34:11: note:   no known conversion for argument 1 from ‘int’ to ‘HT::Tuple&&’\n",
            1594951200,
            1596200400,
            0,
            1595511915.878201
        ]
    ]
}