{
    "__update_time__": 1595789581.016499,
    "field_names": [
        "题目名",
        "用户名",
        "答案",
        "提交时间",
        "分数",
        "评语"
    ],
    "field_types": [
        "text",
        "text",
        "text",
        "time",
        "number",
        "text"
    ],
    "foreign_keys": {},
    "primary_keys": [],
    "rows": [
        [
            "测试1",
            "欧培华",
            "#include <iostream>\nusing namespace std;\n\nint main() {\n\tchar c1[100],c2[100],c3[100];\n\tcin >> c1 >> c2 >> c3;\n\tcout << c3 << ' ' << c2 << ' ' << c1 << endl;\n\treturn 0;\n}",
            1587552910.8483179,
            100,
            "# 答案正确"
        ],
        [
            "测试2",
            "欧培华",
            "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint main()\n{\n    string c[10];\n    for (int i = 0; i < 10; ++i)\n        cin >> c[i];\n    for (int i = 0; i < 10; ++i)\n    {\n        for (int j = 0; j < 10; ++j)\n        {\n            if(c[i] < c[j])\n            {\n                string temp = c[i];\n                c[i] = c[j];\n                c[j] = temp;\n            }\n        }\n    }\n    for (int i = 0; i < 10; ++i)\n        cout << c[i] << ' ';\n}",
            1587610866.091401,
            100,
            "# 答案正确"
        ],
        [
            "1.1 (C++)",
            "欧培华",
            "class Matrix5x5{\npublic:\n    int matrix[5][5];\n    Matrix5x5(){\n        for (int i = 0; i < 5; ++i)\n            for (int j = 0; j < 5; ++j)\n                matrix[i][j] = 0;\n    }\n    double get(int i, int j){\n        return matrix[i][j];\n    }\n    void set(int i, int j, double num){\n        matrix[i][j] = num;\n    }\n    Matrix5x5 operator +(Matrix5x5 &m)\n    {\n        for (int i = 0; i < 5; ++i)\n            for (int j = 0; j < 5; ++j)\n                matrix[i][j] = matrix[i][j] + m.matrix[i][j];\n        return (*this);\n    }\n};",
            1587964672.5834055,
            100,
            "# 答案正确"
        ],
        [
            "1.2 (C++)",
            "欧培华",
            "#include <cstring>\n\nclass School{\npublic:\n    char name[10];\n    int age;\n    School(){\n        strcpy(name,\"NO_NAME\");\n        age = 0;\n    }\n    void setName(char Name[]){\n        strcpy(name,Name);\n    }\n    void setAge(int Age){\n        age = Age;\n    }\n    void operator ++(){\n        age++;\n    }\n};",
            1588216389.6450076,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/08",
            "欧培华",
            "double & Tensor_get(int dimensions, int sizes[], double data[], int x0, int x1, int x2, int x3)\n{\n    int index = x0;\n    if(x1 != -1)\n        index = index * sizes[1] + x1;\n    if(x2 != -1)\n        index = index * sizes[2] + x2;\n    if(x3 != -1)\n        index = index * sizes[3] + x3;\n    return data[index];\n}",
            1588905883.1092641,
            100,
            "# 答案正确"
        ],
        [
            "2.1 (C++)",
            "欧培华",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n    int row;\n    int column;\n    double * value;\npublic:\n    Matrix(int row,int column)\n    {\n        this->row = row;\n        this->column = column;\n        value = new double[row*column];\n        for (int i = 0; i < row; ++i)\n            for (int j = 0; j < column; ++j)\n                value[(i*column)+j] = 0;\n    }\n    ~Matrix()\n    {\n        delete [] value;\n    }\n    void print()\n    {\n        for (int i = 0; i < row; ++i)\n        {\n            for (int j = 0; j < column; ++j)\n                cout << \"    \" << value[(i*column)+j];\n            cout << endl;\n        }\n    }\n};",
            1588910277.9140885,
            100,
            "# 答案正确"
        ],
        [
            "2.2 (C++)",
            "欧培华",
            "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n    int row;\n    int column;\n    double * value;\npublic:\n    Matrix(int row,int column,double value[])\n    {\n        this->row = row;\n        this->column = column;\n        this->value = new double[row*column];\n        for (int i = 0; i < row; ++i)\n            for (int j = 0; j < column; ++j)\n                this->value[(i*column)+j] = value[(i*column)+j];\n    }\n    ~Matrix()\n    {\n        delete [] value;\n    }\n    void print()\n    {\n        for (int i = 0; i < row; ++i)\n        {\n            for (int j = 0; j < column; ++j)\n                cout << setw(5) << right << value[(i*column)+j];\n            cout << endl;\n        }\n    }\n};",
            1588910699.6863945,
            100,
            "# 答案正确"
        ],
        [
            "2.3 (C++)",
            "欧培华",
            "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n    int row;\n    int column;\n    double * value;\npublic:\n    Matrix(int row,int column,double value[])\n    {\n        this->row = row;\n        this->column = column;\n        this->value = new double[row*column];\n        for (int i = 0; i < row; ++i)\n            for (int j = 0; j < column; ++j)\n                this->value[(i*column)+j] = value[(i*column)+j];\n    }\n    Matrix(const Matrix & s)\n    {\n        row = s.row;\n        column = s.column;\n        value = new double[row*column];\n        for (int i = 0; i < row; ++i)\n            for (int j = 0; j < column; ++j)\n                value[(i*column)+j] = s.value[(i*column)+j];\n    }\n    ~Matrix()\n    {\n        delete [] value;\n    }\n    void print()\n    {\n        for (int i = 0; i < row; ++i)\n        {\n            for (int j = 0; j < column; ++j)\n                cout << \"    \" << value[(i*column)+j];\n            cout << endl;\n        }\n    }\n};",
            1588911566.1755233,
            100,
            "# 答案正确"
        ],
        [
            "2.5 (C++)",
            "欧培华",
            "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n    int row;\n    int column;\n    double * value;\npublic:\n    Matrix(int row,int column)\n    {\n        this->row = row;\n        this->column = column;\n        this->value = new double[row*column];\n        for (int i = 0; i < row; ++i)\n            for (int j = 0; j < column; ++j)\n                this->value[(i*column)+j] = 0;\n    }\n    Matrix(int row,int column,double value[])\n    {\n        this->row = row;\n        this->column = column;\n        this->value = new double[row*column];\n        for (int i = 0; i < row; ++i)\n            for (int j = 0; j < column; ++j)\n                this->value[(i*column)+j] = value[(i*column)+j];\n    }\n    ~Matrix()\n    {\n        delete [] value;\n    }\n    void print()\n    {\n        for (int i = 0; i < row; ++i)\n        {\n            for (int j = 0; j < column; ++j)\n                cout << \"    \" << value[(i*column)+j];\n            cout << endl;\n        }\n    }\n    Matrix getRow(int row)\n    {\n        Matrix temp(1,this->column);\n        for (int i = 0; i < this->column; ++i)\n            temp.value[i] = this->value[(row-1)*this->column+i];\n        return temp;\n    }\n    Matrix getColumn(int column)\n    {\n        Matrix temp(this->row,1);\n        for (int i = 0; i < this->row; ++i)\n            temp.value[i] = this->value[(i*this->column)+(column-1)];\n        return temp;\n    }\n};",
            1588919424.3711267,
            100,
            "# 答案正确"
        ],
        [
            "2.6 (C++)",
            "欧培华",
            "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n    int row;\n    int column;\n    double * value;\npublic:\n    Matrix(int row,int column,double value[])\n    {\n        this->row = row;\n        this->column = column;\n        this->value = new double[row*column];\n        for (int i = 0; i < row; ++i)\n            for (int j = 0; j < column; ++j)\n                this->value[(i*column)+j] = value[(i*column)+j];\n    }\n    Matrix(const Matrix & matrix2)\n    {\n        this->row = matrix2.row;\n        this->column = matrix2.column;\n        this->value = new double[row*column];\n        for (int i = 0; i < row; ++i)\n            for (int j = 0; j < column; ++j)\n                this->value[(i*column)+j] = matrix2.value[(i*column)+j];\n    }\n    ~Matrix()\n    {\n        delete [] value;\n    }\n    void print()\n    {\n        for (int i = 0; i < row; ++i)\n        {\n            for (int j = 0; j < column; ++j)\n                cout << \"    \" << value[(i*column)+j];\n            cout << endl;\n        }\n    }\n    Matrix concatenateRows(const Matrix & matrix2) const\n    {\n        double values[1000];\n        for (int i = 0; i < this->row*this->column; ++i)\n            values[i] = this->value[i];\n        for (int i = 0; i < matrix2.row*matrix2.column; ++i)\n            values[this->row*this->column+i] = matrix2.value[i];\n        Matrix temp(this->row+matrix2.row,this->column,values);\n        return temp;\n    }\n    Matrix concatenateColumns(const Matrix & matrix2) const\n    {\n        double values[1000];\n        for (int i = 0; i < this->row; ++i)\n        {\n            for (int j = 0; j < this->column; ++j)\n                values[i*(matrix2.column+this->column)+j] = this->value[i*this->column+j];\n            for (int j = 0; j < matrix2.column; ++j)\n                values[i*(matrix2.column+this->column)+j+this->column] = matrix2.value[i*matrix2.column+j];\n        }\n        Matrix temp(this->row,this->column+matrix2.column,values);\n        return temp;\n    }\n};",
            1588923230.9968133,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/14",
            "欧培华",
            "#include <iostream>\nusing namespace std;\n\nvoid Tensor_print(const int dimensions, const int sizes[], const double * data)\n{\n    if(dimensions == 1)\n    {\n        cout << \"Tensor of \" << sizes[0] << endl;\n        for (int i = 0; i < sizes[0]; ++i)\n            cout << data[i] << endl;\n    }\n    else if(dimensions == 2)\n    {\n        cout << \"Tensor of \" << sizes[0] << \"x\" << sizes[1] << endl;\n        for (int i = 0; i < sizes[0]; ++i)\n        {\n            for (int j = 0; j < sizes[1]; ++j)\n                cout << \"    \" << data[i*sizes[1]+j];\n            cout << endl;\n        }\n    }\n    else if(dimensions == 3)\n    {\n        cout << \"Tensor of \" << sizes[0] << \"x\" << sizes[1] << \"x\" << sizes[2] << endl;\n        for (int i = 0; i < sizes[0]; ++i)\n        {\n            cout << \"data[\" << i << ']' << endl;\n            for (int j = 0; j < sizes[1]; ++j)\n            {\n                for (int k = 0; k < sizes[2]; ++k)\n                    cout << \"    \" << data[i*sizes[1]*sizes[2]+j*sizes[2]+k];\n                cout << endl;\n            }\n        }\n    }\n    else\n    {\n        cout << \"Tensor of \" << sizes[0] << \"x\" << sizes[1] << \"x\" << sizes[2] << \"x\" << sizes[3] << endl;\n        for (int i = 0; i < sizes[0]; ++i)\n        {\n            for (int j = 0; j < sizes[1]; ++j)\n            {\n                cout << \"data[\" << i << \"][\" << j << ']' << endl;\n                for (int k = 0; k < sizes[2]; ++k)\n                {\n                    for (int m = 0; m < sizes[3]; ++m)\n                        cout << \"    \" << data[i*sizes[1]*sizes[2]*sizes[3]+j*sizes[2]*sizes[3]+k*sizes[3]+m];\n                    cout << endl;\n                }\n            }\n        }\n    }\n}",
            1589424757.1149445,
            100,
            "# 答案正确"
        ],
        [
            "2.4 (C++)",
            "欧培华",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tMatrix(int rows, int columns)\n\t{\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tvalues = new double[rows*columns];\n\t\tfor (int i = 0; i < rows*columns; ++i)\n\t\t\tvalues[i] = 0;\n\t}\n\tMatrix(int rows, int columns, double values[])\n\t{\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tthis->values = new double[rows*columns];\n\t\tfor (int i = 0; i < rows*columns; ++i)\n\t\t\tthis->values[i] = values[i];\n\t}\n\t~Matrix()\n\t{\n\t\tif(values != 0)\n\t\t\tdelete [] values;\n\t}\n\tvoid print()\n\t{\n\t\tfor (int i = 0; i < rows; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < columns; ++j)\n\t\t\t\tcout << \"    \" << values[i*columns+j];\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tvoid set(int row, int column, double value)\n\t{\n\t\tvalues[(row-1)*columns+(column-1)] = value;\n\t}\n\tMatrix & operator =(const Matrix & matrix)\n\t{\n\t\trows = matrix.rows;\n\t\tcolumns = matrix.columns;\n\t\tif(values != 0)\n\t\t\tdelete [] values;\n\t\tvalues = new double[rows*columns];\n\t\tfor (int i = 0; i < rows*columns; ++i)\n\t\t\tvalues[i] = matrix.values[i];\n\t\treturn *this;\n\t}\n};",
            1589877257.023291,
            100,
            "# 答案正确"
        ],
        [
            "2.7 (C++)",
            "欧培华",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tMatrix(int rows, int columns, double values[])\n\t{\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tthis->values = new double[rows*columns];\n\t\tfor (int i = 0; i < rows*columns; ++i)\n\t\t\tthis->values[i] = values[i];\n\t}\n\tMatrix(const Matrix & matrix)\n\t{\n\t\trows = matrix.rows;\n\t\tcolumns = matrix.columns;\n\t\tvalues = new double[rows*columns];\n\t\tfor (int i = 0; i < rows*columns; ++i)\n\t\t\tvalues[i] = matrix.values[i];\n\t}\n\t~Matrix()\n\t{\n\t\tif(values != 0)\n\t\t\tdelete [] values;\n\t}\n\tvoid print()\n\t{\n\t\tfor (int i = 0; i < rows; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < columns; ++j)\n\t\t\t\tcout << \"    \" << values[i*columns+j];\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tvoid set(int row, int column, double value)\n\t{\n\t\tvalues[(row-1)*columns+(column-1)] = value;\n\t}\n\tMatrix reshape(int rows, int columns) const;\n};\n\nMatrix Matrix::reshape(int rows, int columns) const\n{\n\tdouble temp[rows*columns];\n\tint new_i = 0,new_j = 0;\n\tfor (int j = 0; j < this->columns; ++j)\n\t\tfor (int i = 0; i < this->rows; ++i)\n\t\t{\n\t\t\ttemp[new_i*columns+new_j] = this->values[i*this->columns+j];\n\t\t\tnew_i++;\n\t\t\tif(new_i >= rows)\n\t\t\t{\n\t\t\t\tnew_i = 0;\n\t\t\t\tnew_j++;\n\t\t\t}\n\t\t}\n\tMatrix new_matrix(rows, columns, temp);\n\treturn new_matrix;\n}",
            1589890094.2728665,
            100,
            "# 答案正确"
        ],
        [
            "2.8 (C++)",
            "欧培华",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tMatrix(int rows, int columns, double values[])\n\t{\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tthis->values = new double[rows*columns];\n\t\tfor (int i = 0; i < rows*columns; ++i)\n\t\t\tthis->values[i] = values[i];\n\t}\n\tMatrix(const Matrix & matrix)\n\t{\n\t\trows = matrix.rows;\n\t\tcolumns = matrix.columns;\n\t\tvalues = new double[rows*columns];\n\t\tfor (int i = 0; i < rows*columns; ++i)\n\t\t\tvalues[i] = matrix.values[i];\n\t}\n\t~Matrix()\n\t{\n\t\tif(values != 0)\n\t\t\tdelete [] values;\n\t}\n\tvoid print()\n\t{\n\t\tfor (int i = 0; i < rows; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < columns; ++j)\n\t\t\t\tcout << \"    \" << values[i*columns+j];\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tMatrix transpose();\n};\n\nMatrix Matrix::transpose()\n{\n\tdouble temp[rows*columns];\n\tfor (int i = 0; i < rows; ++i)\n\t\tfor (int j = 0; j < columns; ++j)\n\t\t\ttemp[j*rows+i] = values[i*columns+j];\n\tMatrix new_matrix(columns,rows,temp);\n\treturn new_matrix;\n}",
            1589890071.6835928,
            100,
            "# 答案正确"
        ],
        [
            "2.10 (C++)",
            "欧培华",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tMatrix(int rows, int columns, double values[])\n\t{\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tthis->values = new double[rows*columns];\n\t\tfor (int i = 0; i < rows*columns; ++i)\n\t\t\tthis->values[i] = values[i];\n\t}\n\tMatrix(const Matrix & matrix)\n\t{\n\t\trows = matrix.rows;\n\t\tcolumns = matrix.columns;\n\t\tvalues = new double[rows*columns];\n\t\tfor (int i = 0; i < rows*columns; ++i)\n\t\t\tvalues[i] = matrix.values[i];\n\t}\n\t~Matrix()\n\t{\n\t\tif(values != 0)\n\t\t\tdelete [] values;\n\t}\n\tvoid print()\n\t{\n\t\tfor (int i = 0; i < rows; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < columns; ++j)\n\t\t\t\tcout << \"    \" << values[i*columns+j];\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tMatrix & operator =(const Matrix & matrix)\n\t{\n\t\trows = matrix.rows;\n\t\tcolumns = matrix.columns;\n\t\tif(values != 0)\n\t\t\tdelete [] values;\n\t\tvalues = new double[rows*columns];\n\t\tfor (int i = 0; i < rows*columns; ++i)\n\t\t\tvalues[i] = matrix.values[i];\n\t\treturn *this;\n\t}\n\tMatrix operator * (const Matrix & matrix) const;\n\tMatrix operator * (double value) const;\n};\n\nMatrix Matrix::operator * (const Matrix & matrix) const\n{\n\tdouble temp[rows*rows] = {0};\n\tfor (int i = 0; i < rows; ++i)\n\t\tfor (int j = 0; j < rows; ++j)\n\t\t\tfor (int k = 0; k < columns; ++k)\n\t\t\t\ttemp[i*rows+j] += values[i*columns+k] * matrix.values[k*rows+j];\n\tMatrix new_matrix(rows,rows,temp);\n\treturn new_matrix; \n}\n\nMatrix Matrix::operator * (double value) const\n{\n\tdouble temp[rows*columns];\n\tfor (int i = 0; i < rows*columns; ++i)\n\t\ttemp[i] = values[i] * value;\n\tMatrix new_matrix(rows,columns,temp);\n\treturn new_matrix;\n}",
            1589890012.5451622,
            100,
            "# 答案正确"
        ],
        [
            "2.11 (C++)",
            "欧培华",
            "#include <iostream>\nusing namespace std;\n#define MAX 9999\n\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tMatrix(int rows, int columns, double values[])\n\t{\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tif(rows*columns == 0)\n\t\t\tthis->values = 0;\n\t\telse\n\t\t{\n\t\t\tthis->values = new double[rows*columns];\n\t\t\tfor (int i = 0; i < rows*columns; ++i)\n\t\t\t\tthis->values[i] = values[i];\n\t\t}\n\t}\n\tMatrix(const Matrix & matrix)\n\t{\n\t\trows = matrix.rows;\n\t\tcolumns = matrix.columns;\n\t\tvalues = new double[rows*columns];\n\t\tfor (int i = 0; i < rows*columns; ++i)\n\t\t\tvalues[i] = matrix.values[i];\n\t}\n\t~Matrix()\n\t{\n\t\tif(values != 0)\n\t\t\tdelete [] values;\n\t}\n\tvoid print()\n\t{\n\t\tfor (int i = 0; i < rows; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < columns; ++j)\n\t\t\t\tcout << \"    \" << values[i*columns+j];\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tMatrix & operator =(const Matrix & matrix)\n\t{\n\t\trows = matrix.rows;\n\t\tcolumns = matrix.columns;\n\t\tif(values != 0)\n\t\t\tdelete [] values;\n\t\tvalues = new double[rows*columns];\n\t\tfor (int i = 0; i < rows*columns; ++i)\n\t\t\tvalues[i] = matrix.values[i];\n\t\treturn *this;\n\t}\n\tMatrix max() const;\n\tMatrix min() const;\n\tMatrix sum() const;\n};\n\nMatrix Matrix::max() const\n{\n\tif(rows > 1)\n\t{\n\t\tdouble temp[1*columns];\n\t\tfor (int i = 0; i < columns; ++i)\n\t\t{\n\t\t\tint max = 0;\n\t\t\tfor (int j = 0; j < rows; ++j)\n\t\t\t{\n\t\t\t\tif(max < values[j*columns+i])\n\t\t\t\t\tmax = values[j*columns+i];\n\t\t\t}\n\t\t\ttemp[i] = max;\n\t\t}\n\t\tMatrix new_matrix(1,columns,temp);\n\t\treturn new_matrix;\n\t}\n\telse\n\t{\n\t\tdouble temp[1] = {0};\n\t\tfor (int i = 0; i < columns; ++i)\n\t\t{\n\t\t\tif(temp[0] < values[i])\n\t\t\t\ttemp[0] = values[i];\n\t\t}\n\t\tMatrix new_matrix(1,1,temp);\n\t\treturn new_matrix;\n\t}\n}\n\nMatrix Matrix::min() const\n{\n\tif(rows > 1)\n\t{\n\t\tdouble temp[1*columns];\n\t\tfor (int i = 0; i < columns; ++i)\n\t\t{\n\t\t\tint min = MAX;\n\t\t\tfor (int j = 0; j < rows; ++j)\n\t\t\t{\n\t\t\t\tif(min > values[j*columns+i])\n\t\t\t\t\tmin = values[j*columns+i];\n\t\t\t}\n\t\t\ttemp[i] = min;\n\t\t}\n\t\tMatrix new_matrix(1,columns,temp);\n\t\treturn new_matrix;\n\t}\n\telse\n\t{\n\t\tdouble temp[1] = {MAX};\n\t\tfor (int i = 0; i < columns; ++i)\n\t\t{\n\t\t\tif(temp[0] > values[i])\n\t\t\t\ttemp[0] = values[i];\n\t\t}\n\t\tMatrix new_matrix(1,1,temp);\n\t\treturn new_matrix;\n\t}\n}\n\nMatrix Matrix::sum() const\n{\n\tif(rows > 1)\n\t{\n\t\tdouble temp[1*columns] = {0};\n\t\tfor (int i = 0; i < columns; ++i)\n\t\t\tfor (int j = 0; j < rows; ++j)\n\t\t\t\ttemp[i] += values[j*columns+i];\n\t\tMatrix new_matrix(1,columns,temp);\n\t\treturn new_matrix;\n\t}\n\telse\n\t{\n\t\tdouble temp[1*1] = {0};\n\t\tfor (int i = 0; i < columns; ++i)\n\t\t\ttemp[0] += values[i];\n\t\tMatrix new_matrix(1,1,temp);\n\t\treturn new_matrix;\n\t}\n}",
            1589890380.8659935,
            100,
            "# 答案正确"
        ],
        [
            "2.12 (C++)",
            "欧培华",
            "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tMatrix(int rows, int columns, double values[])\n\t{\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tif(rows*columns == 0)\n\t\t\tthis->values = 0;\n\t\telse\n\t\t{\n\t\t\tthis->values = new double[rows*columns];\n\t\t\tfor (int i = 0; i < rows*columns; ++i)\n\t\t\t\tthis->values[i] = values[i];\n\t\t}\n\t}\n\tMatrix(const Matrix & matrix)\n\t{\n\t\trows = matrix.rows;\n\t\tcolumns = matrix.columns;\n\t\tvalues = new double[rows*columns];\n\t\tfor (int i = 0; i < rows*columns; ++i)\n\t\t\tvalues[i] = matrix.values[i];\n\t}\n\t~Matrix()\n\t{\n\t\tif(values != 0)\n\t\t\tdelete [] values;\n\t}\n\tvoid print()\n\t{\n\t\tfor (int i = 0; i < rows; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < columns; ++j)\n\t\t\t\tcout << \"    \" << values[i*columns+j];\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tMatrix & operator =(const Matrix & matrix)\n\t{\n\t\trows = matrix.rows;\n\t\tcolumns = matrix.columns;\n\t\tif(values != 0)\n\t\t\tdelete [] values;\n\t\tvalues = new double[rows*columns];\n\t\tfor (int i = 0; i < rows*columns; ++i)\n\t\t\tvalues[i] = matrix.values[i];\n\t\treturn *this;\n\t}\n\tMatrix pow(double exponent)\n\t{\n\t\tdouble temp[rows*columns];\n\t\tfor (int i = 0; i < rows*columns; ++i)\n\t\t\ttemp[i] = std::pow(values[i],exponent);\n\t\tMatrix new_matrix(rows,columns,temp);\n\t\treturn new_matrix;\n\t}\n\tMatrix exp()\n\t{\n\t\tdouble temp[rows*columns];\n\t\tfor (int i = 0; i < rows*columns; ++i)\n\t\t\ttemp[i] = std::exp(values[i]);\n\t\tMatrix new_matrix(rows,columns,temp);\n\t\treturn new_matrix;\n\t}\n\tMatrix log()\n\t{\n\t\tdouble temp[rows*columns];\n\t\tfor (int i = 0; i < rows*columns; ++i)\n\t\t\ttemp[i] = std::log(values[i]);\n\t\tMatrix new_matrix(rows,columns,temp);\n\t\treturn new_matrix;\n\t}\n\tMatrix abs()\n\t{\n\t\tdouble temp[rows*columns];\n\t\tfor (int i = 0; i < rows*columns; ++i)\n\t\t\ttemp[i] = std::abs(values[i]);\n\t\tMatrix new_matrix(rows,columns,temp);\n\t\treturn new_matrix;\n\t}\n};",
            1589891858.2312202,
            100,
            "# 答案正确"
        ],
        [
            "2.9 (C++)",
            "欧培华",
            "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tMatrix(int rows, int columns, double values[])\n\t{\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tif(rows*columns == 0)\n\t\t\tthis->values = 0;\n\t\telse\n\t\t{\n\t\t\tthis->values = new double[rows*columns];\n\t\t\tfor (int i = 0; i < rows*columns; ++i)\n\t\t\t\tthis->values[i] = values[i];\n\t\t}\n\t}\n\tMatrix(const Matrix & matrix)\n\t{\n\t\trows = matrix.rows;\n\t\tcolumns = matrix.columns;\n\t\tvalues = new double[rows*columns];\n\t\tfor (int i = 0; i < rows*columns; ++i)\n\t\t\tvalues[i] = matrix.values[i];\n\t}\n\t~Matrix()\n\t{\n\t\tif(values != 0)\n\t\t\tdelete [] values;\n\t}\n\tvoid print()\n\t{\n\t\tfor (int i = 0; i < rows; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < columns; ++j)\n\t\t\t\tcout << \"    \" << values[i*columns+j];\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tMatrix & operator =(const Matrix & matrix)\n\t{\n\t\trows = matrix.rows;\n\t\tcolumns = matrix.columns;\n\t\tif(values != 0)\n\t\t\tdelete [] values;\n\t\tvalues = new double[rows*columns];\n\t\tfor (int i = 0; i < rows*columns; ++i)\n\t\t\tvalues[i] = matrix.values[i];\n\t\treturn *this;\n\t}\n\tMatrix operator + (const Matrix & matrix2) const;\n\tMatrix operator + (double value) const;\n\tMatrix operator - (const Matrix & matrix2) const;\n\tMatrix operator - (double value) const;\n};\n\nMatrix Matrix::operator + (const Matrix & matrix2) const\n{\n\tdouble temp[rows*columns];\n\tfor (int i = 0; i < rows*columns; ++i)\n\t\ttemp[i] = values[i] + matrix2.values[i];\n\tMatrix new_matrix(rows,columns,temp);\n\treturn new_matrix;\n}\n\nMatrix Matrix::operator + (double value) const\n{\n\tdouble temp[rows*columns];\n\tfor (int i = 0; i < rows*columns; ++i)\n\t\ttemp[i] = values[i] + value;\n\tMatrix new_matrix(rows,columns,temp);\n\treturn new_matrix;\n}\n\nMatrix Matrix::operator - (const Matrix & matrix2) const\n{\n\tdouble temp[rows*columns];\n\tfor (int i = 0; i < rows*columns; ++i)\n\t\ttemp[i] = values[i] - matrix2.values[i];\n\tMatrix new_matrix(rows,columns,temp);\n\treturn new_matrix;\n}\n\nMatrix Matrix::operator - (double value) const\n{\n\tdouble temp[rows*columns];\n\tfor (int i = 0; i < rows*columns; ++i)\n\t\ttemp[i] = values[i] - value;\n\tMatrix new_matrix(rows,columns,temp);\n\treturn new_matrix;\n}",
            1590029579.0394638,
            100,
            "# 答案正确"
        ],
        [
            "6.2 (C++)",
            "欧培华",
            "#include <iostream>\nusing namespace std;\n\ntemplate<typename T>\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tT * values;\npublic:\n\tMatrix(int rows, int columns)\n\t{\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tvalues = new T[rows*columns];\n\t\tfor (int i = 0; i < rows*columns; ++i)\n\t\t\tvalues[i] = 0;\n\t}\n\t~Matrix()\n\t{\n\t\tif(values != NULL)\n\t\t\tdelete [] values;\n\t}\n\tvoid print()\n\t{\n\t\tfor (int i = 0; i < rows; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < columns; ++j)\n\t\t\t\tcout << \"    \" << values[i*columns+j];\n\t\t\tcout << endl;\n\t\t}\n\t}\n};",
            1590631983.9379873,
            100,
            "# 答案正确"
        ],
        [
            "6.1 (C++)",
            "欧培华",
            "#include <iostream>\n#include <string>\nusing namespace std;\n\ntemplate<typename T>\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tT * values;\npublic:\n\tMatrix(int rows, int columns)\n\t{\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tvalues = new T[rows*columns]();\n\t}\n\tMatrix(int rows, int columns, const T values2[])\n\t{\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tvalues = new T[rows*columns];\n\t\tfor (int i = 0; i < rows*columns; ++i)\n\t\t\tvalues[i] = values2[i];\n\t}\n\tMatrix(const Matrix<T> & matrix2)\n\t{\n\t\trows = matrix2.rows;\n\t\tcolumns = matrix2.columns;\n\t\tvalues = new T[rows*columns];\n\t\tfor (int i = 0; i < rows*columns; ++i)\n\t\t\tvalues[i] = matrix2.values[i];\n\t}\n\t~Matrix()\n\t{\n\t\tif(values != NULL)\n\t\t\tdelete [] values;\n\t}\n\tT & get(int rows, int columns)\n\t{\n\t\treturn values[(rows-1)*this->columns+(columns-1)];\n\t}\n\tMatrix & operator = (const Matrix<T> & matrix2)\n\t{\n\t\trows = matrix2.rows;\n\t\tcolumns = matrix2.columns;\n\t\tif(values != NULL)\n\t\t\tdelete [] values;\n\t\tvalues = new T[rows*columns];\n\t\tfor (int i = 0; i < rows*columns; ++i)\n\t\t\tvalues[i] = matrix2.values[i];\n\t\treturn *this;\n\t} \n\tvoid print()\n\t{\n\t\tfor (int i = 0; i < rows; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < columns; ++j)\n\t\t\t\tcout << \"    \" << values[i*columns+j];\n\t\t\tcout << endl;\n\t\t}\n\t}\n};",
            1590638280.2195954,
            100,
            "# 答案正确"
        ],
        [
            "6.3 (C++)",
            "欧培华",
            "#include <iostream>\n#include <vector>\nusing namespace std;\n#define MAX 9999\n\ntemplate<typename T>\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tvector<T> values;\npublic:\n\tMatrix(int rows, int columns)\n\t{\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tfor (int i = 0; i < rows*columns; ++i)\n\t\t\tvalues.push_back(0);\n\t}\n\tMatrix(int rows, int columns, vector<T> values2)\n\t{\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tfor (int i = 0; i < rows*columns; ++i)\n\t\t\tvalues.push_back(values2[i]);\n\t}\n\tT & get(int row, int column)\n\t{\n\t\treturn values[(row-1)*this->columns+(column-1)];\n\t}\n\tvoid print()\n\t{\n\t\tfor (int i = 0; i < rows; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < columns; ++j)\n\t\t\t\tcout << \"    \" << values[i*columns+j];\n\t\t\tcout <<endl;\n\t\t}\n\t}\n\tMatrix getColumn(int column)\n\t{\n\t\tvector<T> temp;\n\t\tfor (int i = 0; i < rows; ++i)\n\t\t\ttemp.push_back(values[i*columns+(column-1)]);\n\t\tMatrix<double> new_matrix(rows,1,temp);\n\t\treturn new_matrix;\n\t}\n\tMatrix getRow(int row)\n\t{\n\t\tvector<T> temp;\n\t\tfor (int i = 0; i < columns; ++i)\n\t\t\ttemp.push_back(values[(row-1)*columns+i]);\n\t\tMatrix<double> new_matrix(1,columns,temp);\n\t\treturn new_matrix;\n\t}\n\tMatrix concatenateRows(const Matrix & matrix2)\n\t{\n\t\tvector<T> temp;\n\t\tfor (int i = 0; i < rows*columns; ++i)\n\t\t\ttemp.push_back(values[i]);\n\t\tfor (int i = 0; i < matrix2.rows*matrix2.columns; ++i)\n\t\t\ttemp.push_back(matrix2.values[i]);\n\t\tMatrix new_matrix(rows+matrix2.rows,columns,temp);\n\t\treturn new_matrix;\n\t}\n\tMatrix concatenateColumns(const Matrix & matrix2)\n\t{\n\t\tvector<T> temp;\n\t\tfor (int i = 0; i < rows; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < columns; ++j)\n\t\t\t\ttemp.push_back(values[i*columns+j]);\n\t\t\tfor (int j = 0; j < matrix2.columns; ++j)\n\t\t\t\ttemp.push_back(matrix2.values[i*matrix2.columns+j]);\n\t\t}\n\t\tMatrix new_matrix(rows,columns+matrix2.columns,temp);\n\t\treturn new_matrix;\n\t}\n\tMatrix reshape(int row, int column)\n\t{\n\t\tvector<T> temp;\n\t\tfor (int i = 0; i < row*column; ++i)\n\t\t\ttemp.push_back(0);\n\t\tint index1 = 0,index2 = 0;\n\t\tfor (int i = 0; i < columns; ++i)\n\t\t\tfor (int j = 0; j < rows; ++j)\n\t\t\t{\n\t\t\t\ttemp[index1*column+index2] = values[j*columns+i];\n\t\t\t\tindex1++;\n\t\t\t\tif(index1 == row)\n\t\t\t\t{\n\t\t\t\t\tindex1 = 0;\n\t\t\t\t\tindex2++;\n\t\t\t\t}\n\t\t\t}\n\t\tMatrix new_matrix(row,column,temp);\n\t\treturn new_matrix;\n\t}\n\tMatrix transpose()\n\t{\n\t\tvector<T> temp;\n\t\tfor (int i = 0; i < columns; ++i)\n\t\t\tfor (int j = 0; j < rows; ++j)\n\t\t\t\ttemp.push_back(values[j*columns+i]);\n\t\tMatrix new_matrix(rows,columns,temp);\n\t\treturn new_matrix;\n\t}\n\tMatrix operator + (const Matrix & matrix2)\n\t{\n\t\tvector<T> temp;\n\t\tfor (int i = 0; i < rows*columns; ++i)\n\t\t{\n\t\t\tT plus = values[i] + matrix2.values[i];\n\t\t\ttemp.push_back(plus);\n\t\t}\n\t\tMatrix new_matrix(rows,columns,temp);\n\t\treturn new_matrix;\n\t}\n\tMatrix operator + (T num)\n\t{\n\t\tvector<T> temp;\n\t\tfor (int i = 0; i < rows*columns; ++i)\n\t\t{\n\t\t\tT plus = values[i] + num;\n\t\t\ttemp.push_back(plus);\n\t\t}\n\t\tMatrix new_matrix(rows,columns,temp);\n\t\treturn new_matrix;\n\t}\n\tMatrix operator - (const Matrix & matrix2)\n\t{\n\t\tvector<T> temp;\n\t\tfor (int i = 0; i < rows*columns; ++i)\n\t\t{\n\t\t\tT sub = values[i] - matrix2.values[i];\n\t\t\ttemp.push_back(sub);\n\t\t}\n\t\tMatrix new_matrix(rows,columns,temp);\n\t\treturn new_matrix;\n\t}\n\tMatrix operator - (T num)\n\t{\n\t\tvector<T> temp;\n\t\tfor (int i = 0; i < rows*columns; ++i)\n\t\t{\n\t\t\tT sub = values[i] - num;\n\t\t\ttemp.push_back(sub);\n\t\t}\n\t\tMatrix new_matrix(rows,columns,temp);\n\t\treturn new_matrix;\n\t}\n\tMatrix operator * (const Matrix & matrix2)\n\t{\n\t\tvector<T> temp;\n\t\tfor (int i = 0; i < rows; ++i)\n\t\t\tfor (int j = 0; j < matrix2.columns; ++j)\n\t\t\t{\n\t\t\t\tT sum = 0;\n\t\t\t\tfor (int k = 0; k < columns; ++k)\n\t\t\t\t\tsum +=  values[i*columns+k] * matrix2.values[k*matrix2.columns+j];\n\t\t\t\ttemp.push_back(sum);\n\t\t\t}\n\t\tMatrix new_matrix(rows,matrix2.columns,temp);\n\t\treturn new_matrix;\n\t}\n\tMatrix operator * (T num)\n\t{\n\t\tvector<T> temp;\n\t\tfor (int i = 0; i < rows*columns; ++i)\n\t\t{\n\t\t\tT pow = values[i] * num;\n\t\t\ttemp.push_back(pow);\n\t\t}\n\t\tMatrix new_matrix(rows,columns,temp);\n\t\treturn new_matrix;\n\t}\n\tMatrix max()\n\t{\n\t\tif(rows == 1)\n\t\t{\n\t\t\tT max = 0;\n\t\t\tfor (int i = 0; i < columns; ++i)\n\t\t\t\tif(max < values[i])\n\t\t\t\t\tmax = values[i];\n\t\t\tvector<T> temp;\n\t\t\ttemp.push_back(max);\n\t\t\tMatrix new_matrix(1,1,temp);\n\t\t\treturn new_matrix;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tT max = 0;\n\t\t\tint row = 0;\n\t\t\tfor (int i = 0; i < rows; ++i)\n\t\t\t\tfor (int j = 0; j < columns; ++j)\n\t\t\t\t{\n\t\t\t\t\tif(max < values[i*columns+j])\n\t\t\t\t\t\trow = i;\n\t\t\t\t}\n\t\t\treturn getRow(row+1);\n\t\t}\n\t}\n\tMatrix min()\n\t{\n\t\tif(rows == 1)\n\t\t{\n\t\t\tT min = MAX;\n\t\t\tfor (int i = 0; i < columns; ++i)\n\t\t\t\tif(min > values[i])\n\t\t\t\t\tmin = values[i];\n\t\t\tvector<T> temp;\n\t\t\ttemp.push_back(min);\n\t\t\tMatrix new_matrix(1,1,temp);\n\t\t\treturn new_matrix;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tT min = 0;\n\t\t\tint row = 0;\n\t\t\tfor (int i = 0; i < rows; ++i)\n\t\t\t\tfor (int j = 0; j < columns; ++j)\n\t\t\t\t{\n\t\t\t\t\tif(min > values[i*columns+j])\n\t\t\t\t\t\trow = i;\n\t\t\t\t}\n\t\t\treturn getRow(row+1);\n\t\t}\n\t}\n\tMatrix sum()\n\t{\n\t\tif(rows == 1)\n\t\t{\n\t\t\tT sum = 0;\n\t\t\tfor (int i = 0; i < columns; ++i)\n\t\t\t\tsum += values[i];\n\t\t\tvector<T> temp;\n\t\t\ttemp.push_back(sum);\n\t\t\tMatrix new_matrix(1,1,temp);\n\t\t\treturn new_matrix;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvector<T> temp;\n\t\t\tfor (int i = 0; i < columns; ++i)\n\t\t\t{\n\t\t\t\tT sum = 0;\n\t\t\t\tfor (int j = 0; j < rows; ++j)\n\t\t\t\t\tsum += values[j*columns+i];\n\t\t\t\ttemp.push_back(sum);\n\t\t\t}\n\t\t\tMatrix new_matrix(1,columns,temp);\n\t\t\treturn new_matrix;\n\t\t}\n\t}\n};",
            1590647143.0189552,
            100,
            "# 答案正确"
        ],
        [
            "7.1 (C++)",
            "欧培华",
            "#include <cmath>\n\nclass Triangle:public GeometricObject\n{\nprivate:\n\tdouble side1;\n\tdouble side2;\n\tdouble side3;\npublic:\n\tTriangle()\n\t{\n\t\tside1 = 1.0;\n\t\tside2 = 1.0;\n\t\tside3 = 1.0;\t\t\n\t}\n\tTriangle(double side1, double side2, double side3)\n\t{\n\t\tthis->side1 = side1;\n\t\tthis->side2 = side2;\n\t\tthis->side3 = side3;\t\t\n\t}\n\tdouble getSide1()\n\t{\n\t\treturn side1;\n\t}\n\tdouble getSide2()\n\t{\n\t\treturn side2;\n\t}\n\tdouble getSide3()\n\t{\n\t\treturn side3;\n\t}\n\tdouble getArea()\n\t{\n\t\tdouble s = (side1+side2+side3)/2;\n\t\tdouble area = sqrt(s*(s-side1)*(s-side2)*(s-side3));\n\t\treturn area;\n\t}\n\tdouble getPerimeter()\n\t{\n\t\treturn side1+side2+side3;\n\t}\n} ;",
            1591210811.983528,
            100,
            "# 答案正确"
        ],
        [
            "7.3 (C++)",
            "欧培华",
            "template <typename A, typename R>\nvector<R> map2(const vector<A> & data1, const vector<A> & data2, R (*map2_func)(const A &, const A &))\n{\n\tvector<R> res;\n\tfor (int i = 0; i < data1.size(); ++i)\n\t\tres.push_back(map2_func(data1[i],data2[i]));\n\treturn res;\n}\n\ntemplate <typename A, typename R>\nvector<R> map2(const vector<A> & data1, const A & data2, R (*map2_func)(const A &, const A &))\n{\n\tvector<R> res;\n\tfor (int i = 0; i < data1.size(); ++i)\n\t\tres.push_back(map2_func(data1[i],data2));\n\treturn res;\n}",
            1591211875.2070172,
            100,
            "# 答案正确"
        ],
        [
            "7.2 (C++)",
            "欧培华",
            "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nvector <string> split(const string & line, const string & delimiter = \" \")\n{\n\tvector <string> words;\n\tint st = 0;\n\twhile(st < line.size())\n\t{\n\t\tint end = line.find(delimiter,st);\n\t\tif(st == end)\n\t\t\tst += delimiter.size();\n\t\telse if(end == -1)\n\t\t{\n\t\t\twords.push_back(line.substr(st));\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\twords.push_back(line.substr((st),end-st));\n\t\t\tst = end + delimiter.size();\n\t\t}\n\t}\n\treturn words;\n}",
            1591238129.6409812,
            100,
            "# 答案正确"
        ],
        [
            "8.1 (C++)",
            "欧培华",
            "class Full:public Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tFull(int rows, int columns)\n\t{\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tvalues = new double[rows*columns];\n\t\tfor (int i = 0; i < rows*columns; ++i)\n\t\t\tvalues[i] = 0;\n\t}\n\tFull(int rows, int columns, double values[])\n\t{\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tthis->values = new double[rows*columns];\n\t\tfor (int i = 0; i < rows*columns; ++i)\n\t\t\tthis->values[i] = values[i];\n\t}\n\tFull(const Matrix & matrix2)\n\t{\n\t\trows = matrix2.size(1);\n\t\tcolumns = matrix2.size(2);\n\t\tvalues = new double[rows*columns];\n\t\tfor (int i = 0; i < rows; ++i)\n\t\t\tfor (int j = 0; j < columns; ++j)\n\t\t\t\tvalues[i*columns+j] = matrix2.get(i+1,j+1);\n\t}\n\t~Full()\n\t{\n\t\tif(values != NULL)\n\t\t\tdelete [] values;\n\t}\n\tvirtual int size(int dimension) const\n\t{\n\t\tif(dimension == 1)\n\t\t\treturn rows;\n\t\telse return columns;\n\t}\n\tvirtual void set(int row, int column, double value)\n\t{\n\t\tvalues[(row-1)*columns+(column-1)] = value;\n\t}\n\tvirtual double get(int row, int column) const\n\t{\n\t\treturn values[(row-1)*columns+(column-1)];\n\t}\n\tvirtual void print() const\n\t{\n\t\tfor (int i = 0; i < rows; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < columns; ++j)\n\t\t\t\tcout << \"    \" << values[i*columns+j];\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tvirtual Matrix & operator = (const Matrix & matrix2)\n\t{\n\t\trows = matrix2.size(1);\n\t\tcolumns = matrix2.size(2);\n\t\tif(values != NULL)\n\t\t\tdelete [] values;\n\t\tvalues = new double[rows*columns];\n\t\tfor (int i = 0; i < rows; ++i)\n\t\t\tfor (int j = 0; j < columns; ++j)\n\t\t\t\tvalues[i*columns+j] = matrix2.get(i+1,j+1);\n\t\treturn *this;\n\t}\n};",
            1591802954.209483,
            100,
            "# 答案正确"
        ],
        [
            "8.3 (C++)",
            "欧培华",
            "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Sparse:public Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tint num;\n\tvector<Entry> entry;\npublic:\n\tSparse(int rows, int columns)\n\t{\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tnum = 0;\n\t}\n\tvirtual int size(int dimension) const\n\t{\n\t\tif(dimension == 1)\n\t\t\treturn rows;\n\t\telse return columns;\n\t}\n\tvirtual void set(int row, int column, double value)\n\t{\n\t\tfor (int i = 0; i < num; ++i)\n\t\t{\n\t\t\tif(entry[i].row == row && entry[i].column == column)\n\t\t\t{\n\t\t\t\tentry[i].value = value;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tEntry temp;\n\t\ttemp.row = row;\n\t\ttemp.column = column;\n\t\ttemp.value = value;\n\t\tentry.push_back(temp);\n\t\tnum++;\n\t}\n\tvirtual double get(int row, int column) const\n\t{\n\t\tfor (int i = 0; i < num; ++i)\n\t\t{\n\t\t\tif(entry[i].row == row && entry[i].column == column)\n\t\t\t\treturn entry[i].value;\n\t\t}\n\t\treturn 0;\n\t}\n\tvirtual void print()\n\t{\n\t\tfor (int i = 0; i < num; ++i)\n\t\t\tcout << '(' << entry[i].row << ',' << entry[i].column << ',' << entry[i].value <<')' << endl;\n\t}\n\tSparse operator + (Sparse & sparse2)\n\t{\n\t\tSparse new_sparse(rows,columns);\n\t\tfor (int i = 0; i < num; ++i)\n\t\t{\n\t\t\tEntry temp;\n\t\t\ttemp.row = entry[i].row;\n\t\t\ttemp.column = entry[i].column;\n\t\t\ttemp.value = entry[i].value;\n\t\t\tfor (int j = 0; j < sparse2.num; ++j)\n\t\t\t{\n\t\t\t\tif(entry[i].row == sparse2.entry[j].row && entry[i].column == sparse2.entry[j].column)\n\t\t\t\t\ttemp.value += sparse2.entry[j].value;\n\t\t\t}\n\t\t\tif(temp.value == 0)\n\t\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t{\n\t\t\t\tnew_sparse.entry.push_back(temp);\n\t\t\t\tnew_sparse.num++;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < sparse2.num; ++i)\n\t\t{\n\t\t\tEntry temp;\n\t\t\ttemp.row = sparse2.entry[i].row;\n\t\t\ttemp.column = sparse2.entry[i].column;\n\t\t\ttemp.value = sparse2.entry[i].value;\n\t\t\tbool judgement = 0;\n\t\t\tfor (int j = 0; j < num; ++j)\n\t\t\t{\n\t\t\t\tif(sparse2.entry[i].row == entry[j].row && sparse2.entry[i].column == entry[j].column)\n\t\t\t\t{\n\t\t\t\t\tjudgement = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(judgement)\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t{\n\t\t\t\tnew_sparse.entry.push_back(temp);\n\t\t\t\tnew_sparse.num++;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < new_sparse.num; ++i)\n\t\t{\n\t\t\tfor (int j = i; j < new_sparse.num; ++j)\n\t\t\t{\n\t\t\t\tif(new_sparse.entry[i].row > new_sparse.entry[j].row)\n\t\t\t\t{\n\t\t\t\t\tEntry temp;\n\t\t\t\t\ttemp.row = new_sparse.entry[i].row;\n\t\t\t\t\tnew_sparse.entry[i].row = new_sparse.entry[j].row;\n\t\t\t\t\tnew_sparse.entry[j].row = temp.row;\n\t\t\t\t\ttemp.column = new_sparse.entry[i].column;\n\t\t\t\t\tnew_sparse.entry[i].column = new_sparse.entry[j].column;\n\t\t\t\t\tnew_sparse.entry[j].column = temp.column;\n\t\t\t\t\ttemp.value = new_sparse.entry[i].value;\n\t\t\t\t\tnew_sparse.entry[i].value = new_sparse.entry[j].value;\n\t\t\t\t\tnew_sparse.entry[j].value = temp.value;\n\t\t\t\t}\n\t\t\t\telse if(new_sparse.entry[i].row == new_sparse.entry[j].row && new_sparse.entry[i].column > new_sparse.entry[j].column)\n\t\t\t\t{\n\t\t\t\t\tEntry temp;\n\t\t\t\t\ttemp.row = new_sparse.entry[i].row;\n\t\t\t\t\tnew_sparse.entry[i].row = new_sparse.entry[j].row;\n\t\t\t\t\tnew_sparse.entry[j].row = temp.row;\n\t\t\t\t\ttemp.column = new_sparse.entry[i].column;\n\t\t\t\t\tnew_sparse.entry[i].column = new_sparse.entry[j].column;\n\t\t\t\t\tnew_sparse.entry[j].column = temp.column;\n\t\t\t\t\ttemp.value = new_sparse.entry[i].value;\n\t\t\t\t\tnew_sparse.entry[i].value = new_sparse.entry[j].value;\n\t\t\t\t\tnew_sparse.entry[j].value = temp.value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new_sparse;\n\t}\n};",
            1591811084.1898525,
            100,
            "# 答案正确"
        ],
        [
            "8.5 (C++)",
            "欧培华",
            "class Point3D:public Point2D\n{\nprivate:\n\tdouble z;\npublic:\n\tPoint3D()\n\t{\n\t\tsetX(0);\n\t\tsetY(0);\n\t\tz = 0;\n\t}\n\tPoint3D(double x, double y, double z)\n\t{\n\t\tsetX(x);\n\t\tsetY(y);\n\t\tthis->z = z;\n\t}\n\tdouble getZ()\n\t{\n\t\treturn z;\n\t}\n\tvoid setZ(double z)\n\t{\n\t\tthis->z = z;\n\t}\n\tvirtual double distance(Point2D & point2)\n\t{\n\t\tPoint3D * p = dynamic_cast<Point3D *>(& point2);\n\t\tdouble dx = getX() - p->getX();\n\t\tdouble dy = getY() - p->getY();\n\t\tdouble dz = z - p->z;\n\t\treturn sqrt(dx * dx + dy * dy + dz * dz);\n\t}\n};",
            1591843225.5076165,
            100,
            "# 答案正确"
        ],
        [
            "8.4 (C++)",
            "欧培华",
            "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Sparse:public Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tint num;\n\tvector<Entry> entry;\npublic:\n\tSparse(int rows, int columns)\n\t{\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tnum = 0;\n\t}\n\tvirtual int size(int dimension) const\n\t{\n\t\tif(dimension == 1)\n\t\t\treturn rows;\n\t\telse return columns;\n\t}\n\tvirtual void set(int row, int column, double value)\n\t{\n\t\tfor (int i = 0; i < num; ++i)\n\t\t{\n\t\t\tif(entry[i].row == row && entry[i].column == column)\n\t\t\t{\n\t\t\t\tentry[i].value = value;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tEntry temp;\n\t\ttemp.row = row;\n\t\ttemp.column = column;\n\t\ttemp.value = value;\n\t\tentry.push_back(temp);\n\t\tnum++;\n\t}\n\tvirtual double get(int row, int column) const\n\t{\n\t\tfor (int i = 0; i < num; ++i)\n\t\t{\n\t\t\tif(entry[i].row == row && entry[i].column == column)\n\t\t\t\treturn entry[i].value;\n\t\t}\n\t\treturn 0;\n\t}\n\tvirtual void print()\n\t{\n\t\tfor (int i = 0; i < num; ++i)\n\t\t\tcout << '(' << entry[i].row << ',' << entry[i].column << ',' << entry[i].value <<')' << endl;\n\t}\n\tSparse operator * (Sparse & sparse2)\n\t{\n\t\tSparse new_sparse(rows,sparse2.columns);\n\t\tfor (int i = 0; i < num; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < sparse2.num; ++j)\n\t\t\t{\n\t\t\t\tif(entry[i].column == sparse2.entry[j].row)\n\t\t\t\t{\n\t\t\t\t\tif(new_sparse.num == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tEntry temp;\n\t\t\t\t\t\ttemp.row = entry[i].row;\n\t\t\t\t\t\ttemp.column = sparse2.entry[j].column;\n\t\t\t\t\t\ttemp.value = entry[i].value * sparse2.entry[j].value;\n\t\t\t\t\t\tnew_sparse.entry.push_back(temp);\n\t\t\t\t\t\tnew_sparse.num++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tbool judgement = 1;\n\t\t\t\t\t\tfor (int k = 0; k < new_sparse.num; ++k)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(entry[i].row == new_sparse.entry[k].row && sparse2.entry[j].column == new_sparse.entry[k].column)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tnew_sparse.entry[k].value += entry[i].value * sparse2.entry[j].value;\n\t\t\t\t\t\t\t\tjudgement = 0;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(judgement)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tEntry temp;\n\t\t\t\t\t\t\ttemp.row = entry[i].row;\n\t\t\t\t\t\t\ttemp.column = sparse2.entry[j].column;\n\t\t\t\t\t\t\ttemp.value = entry[i].value * sparse2.entry[j].value;\n\t\t\t\t\t\t\tnew_sparse.entry.push_back(temp);\n\t\t\t\t\t\t\tnew_sparse.num++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < new_sparse.num; ++i)\n\t\t{\n\t\t\tfor (int j = i; j < new_sparse.num; ++j)\n\t\t\t{\n\t\t\t\tif(new_sparse.entry[i].row > new_sparse.entry[j].row)\n\t\t\t\t{\n\t\t\t\t\tEntry temp;\n\t\t\t\t\ttemp.row = new_sparse.entry[i].row;\n\t\t\t\t\tnew_sparse.entry[i].row = new_sparse.entry[j].row;\n\t\t\t\t\tnew_sparse.entry[j].row = temp.row;\n\t\t\t\t\ttemp.column = new_sparse.entry[i].column;\n\t\t\t\t\tnew_sparse.entry[i].column = new_sparse.entry[j].column;\n\t\t\t\t\tnew_sparse.entry[j].column = temp.column;\n\t\t\t\t\ttemp.value = new_sparse.entry[i].value;\n\t\t\t\t\tnew_sparse.entry[i].value = new_sparse.entry[j].value;\n\t\t\t\t\tnew_sparse.entry[j].value = temp.value;\n\t\t\t\t}\n\t\t\t\telse if(new_sparse.entry[i].row == new_sparse.entry[j].row && new_sparse.entry[i].column > new_sparse.entry[j].column)\n\t\t\t\t{\n\t\t\t\t\tEntry temp;\n\t\t\t\t\ttemp.row = new_sparse.entry[i].row;\n\t\t\t\t\tnew_sparse.entry[i].row = new_sparse.entry[j].row;\n\t\t\t\t\tnew_sparse.entry[j].row = temp.row;\n\t\t\t\t\ttemp.column = new_sparse.entry[i].column;\n\t\t\t\t\tnew_sparse.entry[i].column = new_sparse.entry[j].column;\n\t\t\t\t\tnew_sparse.entry[j].column = temp.column;\n\t\t\t\t\ttemp.value = new_sparse.entry[i].value;\n\t\t\t\t\tnew_sparse.entry[i].value = new_sparse.entry[j].value;\n\t\t\t\t\tnew_sparse.entry[j].value = temp.value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new_sparse;\n\t}\n};",
            1591848162.298588,
            100,
            "# 答案正确"
        ],
        [
            "8.6 (C++)",
            "欧培华",
            "#include <iostream>\n\nclass MyTensor:public Tensor<double>\n{\nprivate:\n\tvector<double> values;\npublic:\n\tMyTensor(vector<int> sizes) : Tensor(sizes)\n\t{\n\t\tint sum = sizes[0];\n\t\tfor (int i = 1; i < sizes.size(); ++i)\n\t\t\tsum *= sizes[i];\n\t\tfor (int i = 0; i < sum; ++i)\n\t\t\tvalues.push_back(0);\n\t}\n\tvirtual double & get(const vector<int> & indexes)\n\t{\n\t\tint index = 0;\n\t\tfor (int i = 0; i < indexes.size(); ++i)\n\t\t{\n\t\t\tint temp = indexes[i];\n\t\t\tfor (int j = i+1; j < indexes.size(); ++j)\n\t\t\t\ttemp *= sizes[j];\n\t\t\tindex += temp;\n\t\t}\n\t\treturn values[index];\n\t}\n};",
            1592450455.6870246,
            100,
            "# 答案正确"
        ],
        [
            "9.1 (C++)",
            "欧培华",
            "class Circle\n{\nprivate:\n\tdouble radius;\npublic:\n\tCircle(double radius):radius(radius){}\n\tbool operator <(Circle circle2)\n\t{\n\t\treturn (radius<circle2.radius?1:0); \n\t}\n\tbool operator <=(Circle circle2)\n\t{\n\t\treturn (radius<=circle2.radius?1:0); \n\t}\n\tbool operator >(Circle circle2)\n\t{\n\t\treturn (radius>circle2.radius?1:0); \n\t}\n\tbool operator >=(Circle circle2)\n\t{\n\t\treturn (radius>=circle2.radius?1:0); \n\t}\n\tbool operator ==(Circle circle2)\n\t{\n\t\treturn (radius==circle2.radius?1:0); \n\t}\n\tbool operator !=(Circle circle2)\n\t{\n\t\treturn (radius!=circle2.radius?1:0); \n\t}\n};",
            1593007536.9461784,
            100,
            "# 答案正确"
        ],
        [
            "9.2 (C++)",
            "欧培华",
            "class I\n{\nprivate:\n\tvector<int> sizes;\npublic:\n\tI(int dim1,int dim2 = -1,int dim3 = -1,int dim4 = -1)\n\t{\n\t\tsizes.push_back(dim1);\n\t\tif(dim2 != -1) sizes.push_back(dim2);\n\t\tif(dim3 != -1) sizes.push_back(dim3);\n\t\tif(dim4 != -1) sizes.push_back(dim4);\t\t\n\t}\n\toperator vector<int>()\n\t{\n\t\treturn sizes;\n\t}\n\toperator const vector<int>() const\n\t{\n\t\treturn sizes;\n\t}\n};",
            1593009546.8540988,
            100,
            "# 答案正确"
        ],
        [
            "9.4 (C++)",
            "欧培华",
            "class Complex\n{\nprivate:\n\tdouble a;\n\tdouble b;\npublic:\n\tdouble & get_a(){return a;}\n\tdouble & get_b(){return b;}\n\tComplex operator +(const Complex & c2) const\n\t{\n\t\tComplex temp;\n\t\ttemp.a = a + c2.a;\n\t\ttemp.b = b + c2.b;\n\t\treturn temp;\n\t}\n\tComplex operator -(const Complex & c2) const\n\t{\n\t\tComplex temp;\n\t\ttemp.a = a - c2.a;\n\t\ttemp.b = b - c2.b;\n\t\treturn temp;\n\t}\n};\n\nostream & operator <<(ostream & out, Complex & c)\n{\n\tout << c.get_a() << \" + \" << c.get_b() << \" i\";\n\treturn out;\n}\n\nistream & operator >>(istream & in, Complex & c)\n{\n\tComplex temp;\n\tin >> temp.get_a() >> temp.get_b();\n\tc = temp;\n\treturn in;\n} \t",
            1593022654.294114,
            100,
            "# 答案正确"
        ],
        [
            "9.5 (C++)",
            "欧培华",
            "class Complex\n{\nprivate:\n\tdouble a;\n\tdouble b;\npublic:\n\tdouble & get_a(){return a;}\n\tdouble & get_b(){return b;}\n\tComplex operator +(const Complex & c2) const\n\t{\n\t\tComplex temp;\n\t\ttemp.a = a + c2.a;\n\t\ttemp.b = b + c2.b;\n\t\treturn temp;\n\t}\n\tComplex operator -(const Complex & c2) const\n\t{\n\t\tComplex temp;\n\t\ttemp.a = a - c2.a;\n\t\ttemp.b = b - c2.b;\n\t\treturn temp;\n\t}\n\tComplex operator ++()\n\t{\n\t\ta += 1;\n\t\treturn *this;\n\t}\n\tComplex operator ++(int)\n\t{\n\t\tComplex temp = *this;\n\t\ta += 1;\n\t\treturn temp;\n\t}\n\toperator double(){return a;}\n};\n\nostream & operator <<(ostream & out, Complex c)\n{\n\tout << c.get_a() << \" + \" << c.get_b() << \" i\";\n\treturn out;\n}\n\nistream & operator >>(istream & in, Complex & c)\n{\n\tComplex temp;\n\tin >> temp.get_a() >> temp.get_b();\n\tc = temp;\n\treturn in;\n}",
            1593023451.4614627,
            100,
            "# 答案正确"
        ],
        [
            "9.6 (C++)",
            "欧培华",
            "class Tensor\n{\nprivate:\n\tvector<int> sizes;\n\tvector<double> values;\npublic:\n\tTensor(int dim1,int dim2 = -1,int dim3 = -1,int dim4 = -1)\n\t{\n\t\tint dim = 1;\n\t\tsizes.push_back(dim1);\n\t\tif(dim2 != -1) \n\t\t{\n\t\t\tsizes.push_back(dim2);\n\t\t\tdim++;\n\t\t}\n\t\tif(dim3 != -1) \n\t\t{\n\t\t\tsizes.push_back(dim3);\n\t\t\tdim++;\n\t\t}\n\t\tif(dim4 != -1) \n\t\t{\n\t\t\tsizes.push_back(dim4);\n\t\t\tdim++;\n\t\t}\n\t\tint size = 1;\n\t\tfor (int i = 0; i < dim; ++i)\n\t\t\tsize *= sizes[i];\n\t\tfor (int i = 0; i < size; ++i)\n\t\t\tvalues.push_back(0);\n\t}\n\tdouble & operator ()(int dim1,int dim2 = -1,int dim3 = -1,int dim4 = -1)\n\t{\n\t\tint index = dim1;\n\t\tif(dim2 != -1) index = index * sizes[1] + dim2;\n\t\tif(dim3 != -1) index = index * sizes[2] + dim3;\n\t\tif(dim4 != -1) index = index * sizes[3] + dim4;\t\n\t\treturn values[index];\t\n\t}\n\tconst double & operator ()(int dim1,int dim2 = -1,int dim3 = -1,int dim4 = -1) const\n\t{\n\t\tint index = dim1;\n\t\tif(dim2 != -1) index = index * sizes[1] + dim2;\n\t\tif(dim3 != -1) index = index * sizes[2] + dim3;\n\t\tif(dim4 != -1) index = index * sizes[3] + dim4;\t\n\t\treturn values[index];\t\n\t}\n};",
            1593025321.3744628,
            100,
            "# 答案正确"
        ],
        [
            "9.7 (C++)",
            "欧培华",
            "class Tensor\n{\nprivate:\n\tint dim;\n\tvector<int> sizes;\n\tvector<double> values;\npublic:\n\tint & get_dim() {return dim;}\n\tvector<int> & get_sizes() {return sizes;}\n\tvector<double> & get_values() {return values;}\n};\n\nostream & operator <<(ostream & out, Tensor & t)\n{\n\tout << t.get_dim() << endl;\n\tvector<int> sizes = t.get_sizes();\n\tfor (int i = 0; i < t.get_dim(); ++i)\n\t\tout << sizes[i] << \" \";\n\tout << endl << endl;\n\tvector<double> values = t.get_values();\n\tif(t.get_dim() == 1)\n\t{\n\t\tfor (int i = 0; i < sizes[0]; ++i)\n\t\t\tout << values[i] << \" \";\n\t\tout << endl << endl;\n\t}\n\telse if(t.get_dim() == 2)\n\t{\n\t\tfor (int i = 0; i < sizes[0]; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < sizes[1]; ++j)\n\t\t\t\tout << values[i*sizes[1]+j] << \" \";\n\t\t\tout << endl;\n\t\t}\n\t\tout << endl;\n\t}\n\telse if(t.get_dim() == 3)\n\t{\n\t\tfor (int i = 0; i < sizes[0]; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < sizes[1]; ++j)\n\t\t\t{\n\t\t\t\tfor (int k = 0; k < sizes[2]; ++k)\n\t\t\t\t\tout << values[(i*sizes[1]+j)*sizes[2]+k] << \" \"; \n\t\t\t\tout << endl;\n\t\t\t}\n\t\t\tout << endl;\n\t\t}\n\t}\n\telse if(t.get_dim() == 4)\n\t{\n\t\tfor (int i = 0; i < sizes[0]; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < sizes[1]; ++j)\n\t\t\t{\n\t\t\t\tfor (int k = 0; k < sizes[2]; ++k)\n\t\t\t\t{\n\t\t\t\t\tfor (int l = 0; l < sizes[3]; ++l)\n\t\t\t\t\t\tout << values[((i*sizes[1]+j)*sizes[2]+k)*sizes[3]+l] << \" \";\n\t\t\t\t\tout << endl;\n\t\t\t\t}\n\t\t\t\tout << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn out;\n}\n\nistream & operator >>(istream & in, Tensor & t)\n{\n\tin >> t.get_dim();\n\tvector<int> sizes;\n\tint temp1;\n\tint size = 1;\n\tfor (int i = 0; i < t.get_dim(); ++i)\n\t{\n\t\tin >> temp1;\n\t\tsizes.push_back(temp1);\n\t\tsize *= sizes[i];\n\t}\n\tt.get_sizes() = sizes;\n\tvector<double> values;\n\tdouble temp2;\n\tfor (int i = 0; i < size; ++i)\n\t{\n\t\tin >> temp2;\n\t\tvalues.push_back(temp2);\n\t}\n\tt.get_values() = values;\n\treturn in;\n}",
            1593059088.7938647,
            100,
            "# 答案正确"
        ],
        [
            "9.3 (C++)",
            "欧培华",
            "class Complex\n{\nprivate:\n\tdouble r;\n\tdouble i;\npublic:\n\tComplex(double r,double i):r(r),i(i) {}\n\tComplex(const int r):r(r),i(0) {}\n\tComplex():r(0),i(0) {}\n\tdouble & real() {return r;}\n\tdouble & imag() {return i;}\n\tComplex operator* (Complex & c2)\n\t{\n\t\tComplex temp;\n\t\ttemp.real() = r * c2.real() - i * c2.imag();\n\t\ttemp.imag() = i * c2.real() + r * c2.imag();\n\t\treturn temp;\n\t}\n\tComplex operator/ (Complex & c2)\n\t{\n\t\tComplex _c2;\n\t\t_c2.real() = c2.real();\n\t\t_c2.imag() = 0-c2.imag();\n\t\tComplex temp = (*this) * _c2;\n\t\tdouble m = c2.real()*c2.real()+c2.imag()*c2.imag();\n\t\ttemp.real() /= m;\n\t\ttemp.imag() /= m;\n\t\treturn temp;\n\t}\n\tComplex operator+= (Complex & c2)\n\t{\n\t\tr += c2.real();\n\t\ti += c2.imag();\n\t\treturn *this;\n\t}\n\tComplex operator-= (Complex & c2)\n\t{\n\t\tr -= c2.real();\n\t\ti -= c2.imag();\n\t\treturn *this;\n\t}\n\tComplex operator*= (Complex & c2)\n\t{\n\t\t(*this) = (*this) * c2;\n\t\treturn *this;\n\t}\n\tComplex operator/= (Complex & c2)\n\t{\n\t\t(*this) = (*this) / c2;\n\t\treturn *this;\n\t}\n\tbool operator== (Complex & c2)\n\t{\n\t\tif(r == c2.real() && i == c2.imag()) return true;\n\t\telse return false;\n\t}\n\tbool operator!= (Complex & c2)\n\t{\n\t\tif(*this == c2) return false;\n\t\telse return true;\n\t}\n};\n\nComplex operator+ (Complex c1, Complex c2)\n{\n\tComplex temp;\n\ttemp.real() = c1.real() + c2.real();\n\ttemp.imag() = c1.imag() + c2.imag();\n\treturn temp;\n}\n\nComplex operator- (Complex c1, Complex c2)\n{\n\tComplex temp;\n\ttemp.real() = c1.real() - c2.real();\n\ttemp.imag() = c1.imag() - c2.imag();\n\treturn temp;\n}",
            1593064199.3805258,
            100,
            "# 答案正确"
        ],
        [
            "10.1 (C++)",
            "欧培华",
            "#include <stdexcept>\n\nclass MatrixSizesDoNotMatchException {};\n\ndouble Matrix::get(int row, int column) const\n{\n    if(row > rows || column > columns) \n    {\n        out_of_range temp(\"error\");\n        throw temp;\n    }\n    return elements[(row-1)*columns+(column-1)];\n}\n\nvoid Matrix::set(int row, int column, double value)\n{\n    if(row > rows || column > columns) \n    {\n        out_of_range temp(\"error\");\n        throw temp;\n    }\n    elements[(row-1)*columns+(column-1)] = value;\n}\n\nMatrix Matrix::operator + (const Matrix & matrix2) const\n{\n    if(rows != matrix2.rows || columns != matrix2.columns) throw MatrixSizesDoNotMatchException();\n    Matrix temp(rows,columns);\n    for (int i = 0; i < rows * columns; ++i)\n        temp.elements[i] = elements[i] + matrix2.elements[i];\n    return temp;\n}",
            1593620524.6872342,
            100,
            "# 答案正确"
        ],
        [
            "10.2 (C++)",
            "欧培华",
            "\t\tcatch(NonPositiveValueException & ex)\n        {\n            cout << \"caught: NonPositiveValueException\" << endl;\n        }\n        catch(out_of_range & ex)\n        {\n            cout << \"caught: out_of_range\" << endl;\n        }",
            1593656338.6023111,
            100,
            "# 答案正确"
        ],
        [
            "15.1 (C++)",
            "欧培华",
            "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nclass Table\n{\n    int rows;\n    int columns;\n    vector<vector<string>> elements;\npublic:\n    Table():rows(0),columns(0){\n        vector<string> temp;\n        elements.push_back(temp);\n    }\n    void addCol(const string & c)\n    {\n        columns++;\n        elements[0].push_back(c);\n    }\n    vector<string> & operator [] (const int & i){\n        vector<string> temp;\n        elements.push_back(temp);\n        rows++;\n        return elements[i+1];\n    }\n    string json() const {\n        string temp;\n        temp.append(\"{\\n\\theaders: [\");\n        for (int i = 0; i < (int)elements[0].size(); ++i)\n        {\n            temp.append(\"'\");\n            temp.append(elements[0][i]);\n            temp.append(\"',\");\n        }\n        temp.append(\"],\\n\\trows: [\\n\");\n        for (int i = 1; i < (int)elements.size(); ++i)\n        {\n            temp.append(\"\\t\\t[\");\n            for (int j = 0; j < (int)elements[i].size(); ++j)\n            {\n                temp.append(\"'\");\n                temp.append(elements[i][j]);\n                temp.append(\"',\");\n            }\n            temp.append(\"],\\n\");\n        }\n        temp.append(\"\\t],\\n}\");\n        return temp;\n    }\n};",
            1594219761.9462345,
            100,
            "# 答案正确"
        ],
        [
            "2020-07-09 LAB",
            "欧培华",
            "#include <iostream>\nusing namespace std;\n\nclass Integer{\n    int num;\n    static int increase_num;\npublic:\n    Integer():num(0){}\n    Integer(int temp):num(temp){}\n    int & get(){ return num;}\n    int get_increase_num(){ return increase_num;}\n    static void increase_all(int temp){\n        increase_num += temp;\n    }\n    static void increase_all(Integer y){\n        increase_num += y.get() + y.get_increase_num();\n    }\n    operator int (){\n        return get();\n    }\n};\n\nint Integer::increase_num = 0;\n\nistream & operator >> (istream & in, Integer & x){\n    in >> x.get();\n    return in;\n}\n\nostream & operator << (ostream & out, Integer & x){\n    out << x.get() + x.get_increase_num();\n    return out;\n}",
            1594263744.1271472,
            100,
            "# 答案正确"
        ],
        [
            "A.1 (C++)",
            "欧培华",
            "    void addFirst(const E & val){\n        Node<E> * temp = new Node<E>();\n        temp->element = val;\n        temp->update_prev_and_next_node(0,head);\n        if(head != 0) head->update_prev_node(0,temp);\n        head = temp;\n        if(tail == 0) tail = temp;\n        ++_size;\n    } \n\n    void addLast(const E & val){\n        Node<E> * temp = new Node<E>();\n        temp->element = val;\n        temp->update_prev_and_next_node(tail,0);\n        if(tail != 0) tail->update_next_node(0,temp);\n        tail = temp;\n        if(head == 0) head = temp;\n        ++_size;\n    }\n\n    void removeFirst(){\n        if(head == 0) return;\n        Node<E> * temp = head;\n        head = head->next_node(0);\n        if(head == 0) tail = 0;\n        if(head != 0) head->update_prev_node(temp,0);\n        delete temp;\n        --_size;\n    }\n\n    void removeLast(){\n        if(tail == 0) return;\n        Node<E> * temp = tail;\n        tail = tail->prev_node(0);\n        if(tail == 0) head = 0;\n        if(tail != 0) tail->update_next_node(temp,0);\n        delete temp;\n        --_size;\n    }\n\n    void clear(){\n        while (_size > 0) removeFirst();\n    }\n\n    Node<E> * get_node(const int & index) const {\n        if(index < 0 || index >= _size) return 0;\n        if(index < _size/2){\n            Node<E> * node = head;\n            Node<E> * prev_node = 0;\n            I(i,index){\n                Node<E> * next_temp = node->next_node(prev_node);\n                prev_node = node;\n                node = next_temp;\n            }\n            return node;\n        }\n        else{\n            Node<E> * node = tail;\n            Node<E> * next_temp = 0;\n            I(i,(_size-1-index)){\n                Node<E> * prev_node = node->prev_node(next_temp);\n                next_temp = node;\n                node = prev_node;\n            }\n            return node;\n        }\n    }\n\n    void add(const int & index, const E & element){\n        if(index < 0 || index > _size) return;\n        Node<E> * temp = new Node<E>();\n        temp->element = element;\n        Node<E> * next_node = (index == _size?0:get_node(index));\n        Node<E> * prev_node = (index == 0?0:get_node(index-1));\n        temp->update_prev_and_next_node(prev_node,next_node);\n        if(prev_node == 0) head = temp;\n        if(next_node == 0) tail = temp;\n        if(prev_node != 0) prev_node->update_next_node(next_node,temp);\n        if(next_node != 0) next_node->update_prev_node(prev_node,temp);\n        ++_size;\n    }\n\n    void addall(const LinkedList<E> & list, int index = -1){\n        if(index == -1) index = _size;\n        Node<E> * temp = list.head;\n        Node<E> * prev_temp = 0;\n        I(i,list._size){\n            add(index+i, temp->element);\n            Node<E> * next_temp = temp->next_node(prev_temp);\n            prev_temp = temp;\n            temp = next_temp;\n        }\n    }\n\n    LinkedList<E> & operator = (const LinkedList<E> & list){\n        clear();\n        addall(list);\n        return *this;\n    }\n\n    int get_index(const E & val){\n        Node<E> * node = head;\n        Node<E> * prev_node = 0;\n        I(i,_size){\n            if(node->element == val) return i;\n            Node<E> * next_temp = node->next_node(prev_node);\n            prev_node = node;\n            node = next_temp;\n        }\n        return -1;\n    }\n\n    void remove(const int & index){\n        if(index < 0 || index >= _size) return;\n        Node<E> * node = head;\n        Node<E> * prev_node = 0;\n        Node<E> * next_node = node->next_node(prev_node);\n        I(i,index){\n            prev_node = node;\n            node = next_node;\n            next_node = node->next_node(prev_node);\n        }\n        if(prev_node == 0) head = next_node;\n        if(next_node == 0) tail = prev_node;\n        if(prev_node != 0) prev_node->update_next_node(node,next_node);\n        if(next_node != 0) next_node->update_prev_node(node,prev_node);\n        delete node;\n        _size--;\n    }\n\n    void removeFirstOccurrence(const E & val){\n        int index = get_index(val);\n        if(index == -1) return;\n        remove(index);\n    }\n\n    E & get(const int & index) const {\n        Node<E> * temp = get_node(index);\n        return temp->element;\n    }\n\n    LinkedList(const LinkedList & list):_size(0),head(0),tail(0){\n        addall(list);\n    }\n\n    ~LinkedList(){\n        clear();\n    }",
            1594575439.278187,
            100,
            "# 答案正确"
        ],
        [
            "A.2 (C++)",
            "欧培华",
            "template<typename E>\nvoid LinkedList<E>::removeAll(const E & e){\n    while(true){\n        try{\n            removeFirstOccurrence(e);\n        }\n        catch(NotSuchElementException & err){\n            break;\n        }\n    }\n}",
            1594865877.9462948,
            100,
            "# 答案正确"
        ],
        [
            "A.3 (C++)",
            "欧培华",
            "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <stdexcept>\nusing namespace std;\n\n#define I(i,n) for (size_t i = 0; i < n; ++ i)\n\nclass NoSuchKeyException {};\n\nsize_t circular_shift(size_t bits, int shift_bits) {\n    const int num_bits = 8 * sizeof(size_t);\n    shift_bits = shift_bits % num_bits;\n    return bits << shift_bits | bits >> (num_bits - shift_bits);\n}\n\nsize_t hash_function(const int & key) {\n    size_t code = 0;\n    I(i, (size_t)key)\n        code ^= circular_shift(key, i * 5);\n    return code;\n}\n\ntemplate <typename E>\nclass HT\n{\n    class Tuple\n    {\n    public:\n        int key;\n        E val;\n        bool in_use;\n\n        Tuple() : in_use(false) {}\n    };\n\n    vector<Tuple> tuples;\n    size_t _size;\n\n    size_t canonical_index(const int & key) const {\n        size_t hash_code = hash_function(key); // needs hash_function(K)\n        return hash_code % tuples.size();\n    }\n\n    // the returned tuple is either empty or with the same key\n    size_t indexOfKey(const int & key) const {\n        size_t index = canonical_index(key);\n        while (true) { // will enter a dead loop if there is not empty tuple\n            if (! tuples[index].in_use) return index;\n            if (tuples[index].key == key) return index;\n            index = (index + 1) % tuples.size();\n        }\n    }\n\npublic:\n    HT() : _size(0) {\n        tuples.resize(2);\n    }\n\n    bool containsKey(const int & key) const {\n        size_t index = indexOfKey(key);\n        return tuples[index].in_use;\n    }\n\n    const E & operator [] (const int & key) const {\n        size_t index = indexOfKey(key);\n        if (! tuples[index].in_use) \n            throw NoSuchKeyException();\n        return tuples[index].val;\n    }\n\n    E & operator [] (const int & key) {\n        size_t index = indexOfKey(key);\n        if (! tuples[index].in_use) \n            throw NoSuchKeyException();\n        return tuples[index].val;\n    }\n\n    void clear() {\n        I(i, tuples.size())\n            tuples[i].in_use = false;\n        _size = 0;\n    }\n\n    void _double_tuples() {\n        vector<Tuple> non_empty_tuples;\n        I(i, tuples.size())\n            if (tuples[i].in_use)\n                non_empty_tuples.push_back(tuples[i]);\n        clear();\n        tuples.resize(tuples.size() * 2);\n        I(i, non_empty_tuples.size())\n            put(non_empty_tuples[i].key, non_empty_tuples[i].val);\n    }\n\n    void put(const int & key, const E & val) {\n        size_t index = indexOfKey(key);\n        tuples[index].key = key;\n        tuples[index].val = val;\n        if (tuples[index].in_use) return;\n        tuples[index].in_use = true;\n        ++ _size;\n        // make sure empty > size / 2\n        if (2 * _size > tuples.size())\n            _double_tuples();\n    }\n\n    static bool _between(size_t hole, size_t canonical, size_t tuple_index) {\n        if (hole < tuple_index)\n            return canonical > hole && canonical <= tuple_index;\n        else\n            return canonical > hole || canonical <= tuple_index;\n    }\n\n    void remove(const int & key) { \n        size_t index = indexOfKey(key);\n        if (! tuples[index].in_use) \n            throw NoSuchKeyException();\n        tuples[index].in_use = false;\n        -- _size;\n        // if there is a hole between a tuple and its canonical position\n        // move the tuple to the hole\n        size_t hole = index;\n        size_t tuple_index = hole;\n        while (true) {\n            tuple_index = (tuple_index + 1) % tuples.size();\n            if (! tuples[tuple_index].in_use) return;\n            size_t canonical = canonical_index(tuples[tuple_index].key);\n            if (_between(hole, canonical, tuple_index)) continue;\n            tuples[hole] = tuples[tuple_index];\n            hole = tuple_index;\n            tuples[hole].in_use = false;\n        }\n    }\n\n    size_t size() const { return _size; }\n\n    template <typename E2>\n    friend ostream & operator << (ostream & out, const HT<E2> & dict);\n\n    template <typename E2>\n    friend istream & operator >> (istream & in, HT<E2> & dict);\n\n    void _inspect() const {\n        I(i, tuples.size())\n            if (tuples[i].in_use)\n                cout << \"#\" << i << \" C\" << canonical_index(tuples[i].key) \n                    << \" \" << tuples[i].key << \" \" << tuples[i].val << endl;\n    }\n\n    vector<int> getKeys(){\n        vector<int> keys;\n        for (int i = 0; i < (int)tuples.size(); ++i)\n        {\n            if(tuples[i].in_use)\n                keys.push_back(tuples[i].key);\n        }\n        return keys;\n    }\n};\n\ntemplate <typename E>\nostream & operator << (ostream & out, const HT<E> & dict) {\n    out << dict.size() << endl;\n    I(i, dict.tuples.size())\n        if (dict.tuples[i].in_use)\n            out << dict.tuples[i].key << \"\\t\" << dict.tuples[i].val << endl;\n    return out;\n}\n\ntemplate <typename E>\nistream & operator >> (istream & in, HT<E> & dict) {\n    dict.clear();\n    size_t size;\n    in >> size;\n    I(i, size) {\n        int key;\n        E val;\n        in >> key >> val;\n        dict.put(key, val);\n    }\n    return in;\n}\n\ninline HT<string> load_dict() {\n    HT<string> dict;\n    ifstream in(\"my_dict.txt\");\n    if (in.fail())\n        throw runtime_error(\"Failed to load dictionary\");\n    in >> dict;\n    in.close();\n    return dict;\n}\n\ninline void save_dict(const HT<string> & dict) {\n    ofstream out(\"my_dict.txt\");\n    if (out.fail())\n        throw runtime_error(\"Failed to save dictionary\");\n    out << dict;\n    out.close();\n}",
            1595473358.6701488,
            100,
            "# 答案正确"
        ],
        [
            "A.5 (C++)",
            "欧培华",
            "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <stdexcept>\nusing namespace std;\n\n#define I(i,n) for (size_t i = 0; i < n; ++ i)\n\nclass NoSuchKeyException {};\n\nsize_t circular_shift(size_t bits, int shift_bits) {\n    const int num_bits = 8 * sizeof(size_t);\n    shift_bits = shift_bits % num_bits;\n    return bits << shift_bits | bits >> (num_bits - shift_bits);\n}\n\nsize_t hash_function(const int & key) {\n    size_t code = 0;\n    I(i, (size_t)key)\n        code ^= circular_shift(key, i * 5);\n    return code;\n}\n\nsize_t hash_function(const string & key) {\n    size_t code = 0;\n    I(i, key.size())\n        code ^= circular_shift(key[i], i * 5);\n    return code;\n}\n\nclass HT\n{\n    class Tuple\n    {\n    public:\n        int key1;\n        string key2;\n        int val1;\n        string val2;\n        bool in_use;\n\n        Tuple() : in_use(false) {}\n\n        operator int() {return val1;}\n        operator string() {return val2;}\n\n        Tuple & operator = (const int & val){\n            this->val1 = val;\n            return *this;\n        }\n\n        Tuple & operator = (const string & val){\n            this->val2 = val;\n            return *this;\n        }\n    };\n\n    vector<Tuple> tuples;\n    size_t _size;\n\n    size_t canonical_index(const int & key) const {\n        size_t hash_code = hash_function(key); // needs hash_function(K)\n        return hash_code % tuples.size();\n    }\n\n    size_t canonical_index(const string & key) const {\n        size_t hash_code = hash_function(key); // needs hash_function(K)\n        return hash_code % tuples.size();\n    }\n\n    // the returned tuple is either empty or with the same key\n    size_t indexOfKey(const int & key) const {\n        size_t index = canonical_index(key);\n        while (true) { // will enter a dead loop if there is not empty tuple\n            if (! tuples[index].in_use) return index;\n            if (tuples[index].key1 == key) return index;\n            index = (index + 1) % tuples.size();\n        }\n    }\n\n    size_t indexOfKey(const string & key) const {\n        size_t index = canonical_index(key);\n        while (true) { // will enter a dead loop if there is not empty tuple\n            if (! tuples[index].in_use) return index;\n            if (tuples[index].key2 == key) return index;\n            index = (index + 1) % tuples.size();\n        }\n    }\n\npublic:\n    HT() : _size(0) {\n        tuples.resize(100);\n    }\n\n    Tuple & operator [] (const int & key) {\n        size_t index = indexOfKey(key);\n        if (! tuples[index].in_use) \n            put(key,-1);\n        return tuples[index];\n    }\n\n    Tuple & operator [] (const string & key) {\n        size_t index = indexOfKey(key);\n        if (! tuples[index].in_use) \n            put(key,-1);\n        return tuples[index];\n    }\n\n    void put(const int & key, const int & val) {\n        size_t index = indexOfKey(key);\n        tuples[index].key1 = key;\n        tuples[index].key2 = \"empty\";\n        tuples[index].val1 = val;\n        tuples[index].val2 = \"empty\";\n        if (tuples[index].in_use) return;\n        tuples[index].in_use = true;\n        ++ _size;\n        // make sure empty > size / 2\n        if (2 * _size > tuples.size())\n            double_tuples();\n    }\n\n    void put(const string & key, const string & val) {\n        size_t index = indexOfKey(key);\n        tuples[index].key1 = -1;\n        tuples[index].key2 = key;\n        tuples[index].val1 = -1;\n        tuples[index].val2 = val;\n        if (tuples[index].in_use) return;\n        tuples[index].in_use = true;\n        ++ _size;\n        // make sure empty > size / 2\n        if (2 * _size > tuples.size())\n            double_tuples();\n    }\n\n    void put(const int & key, const string & val) {\n        size_t index = indexOfKey(key);\n        tuples[index].key1 = key;\n        tuples[index].key2 = \"empty\";\n        tuples[index].val1 = -1;\n        tuples[index].val2 = val;\n        if (tuples[index].in_use) return;\n        tuples[index].in_use = true;\n        ++ _size;\n        // make sure empty > size / 2\n        if (2 * _size > tuples.size())\n            double_tuples();\n    }\n\n    void put(const string & key, const int & val) {\n        size_t index = indexOfKey(key);\n        tuples[index].key1 = -1;\n        tuples[index].key2 = key;\n        tuples[index].val1 = val;\n        tuples[index].val2 = \"empty\";\n        if (tuples[index].in_use) return;\n        tuples[index].in_use = true;\n        ++ _size;\n        // make sure empty > size / 2\n        if (2 * _size > tuples.size())\n            double_tuples();\n    }\n\n    void double_tuples() {\n        vector<Tuple> non_empty_tuples;\n        I(i, tuples.size())\n            if (tuples[i].in_use)\n                non_empty_tuples.push_back(tuples[i]);\n        clear();\n        tuples.resize(tuples.size() * 2);\n        I(i, non_empty_tuples.size())\n        {\n            if(non_empty_tuples[i].key2 == \"empty\" && non_empty_tuples[i].val2 == \"empty\")\n                put(non_empty_tuples[i].key1, non_empty_tuples[i].val1);\n            else if(non_empty_tuples[i].key1 == -1 && non_empty_tuples[i].val1 == -1)\n                put(non_empty_tuples[i].key2, non_empty_tuples[i].val2);\n            else if(non_empty_tuples[i].key2 == \"empty\" && non_empty_tuples[i].val1 == -1)\n                put(non_empty_tuples[i].key1, non_empty_tuples[i].val2);\n            else\n                put(non_empty_tuples[i].key2, non_empty_tuples[i].val1);\n        }\n    }\n\n    size_t size() const { return _size; }\n\n    void clear() {\n        I(i, tuples.size())\n            tuples[i].in_use = false;\n        _size = 0;\n    }\n};",
            1595789578.9060106,
            100,
            "# 答案正确"
        ],
        [
            "A.4 (C++)",
            "欧培华",
            "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <stdexcept>\nusing namespace std;\n\n#define I(i,n) for (size_t i = 0; i < n; ++ i)\n\nclass NoSuchKeyException {};\n\nsize_t circular_shift(size_t bits, int shift_bits) {\n    const int num_bits = 8 * sizeof(size_t);\n    shift_bits = shift_bits % num_bits;\n    return bits << shift_bits | bits >> (num_bits - shift_bits);\n}\n\nsize_t hash_function(const int & key) {\n    size_t code = 0;\n    I(i, (size_t)key)\n        code ^= circular_shift(key, i * 5);\n    return code;\n}\n\nsize_t hash_function(const string & key) {\n    size_t code = 0;\n    I(i, key.size())\n        code ^= circular_shift(key[i], i * 5);\n    return code;\n}\n\nclass HT\n{\n    class Tuple\n    {\n    public:\n        int key1;\n        string key2;\n        int val1;\n        string val2;\n        bool in_use;\n\n        Tuple() : in_use(false) {}\n\n        operator int() {return val1;}\n        operator string() {return val2;}\n    };\n\n    vector<Tuple> tuples;\n    size_t _size;\n\n    size_t canonical_index(const int & key) const {\n        size_t hash_code = hash_function(key); // needs hash_function(K)\n        return hash_code % tuples.size();\n    }\n\n    size_t canonical_index(const string & key) const {\n        size_t hash_code = hash_function(key); // needs hash_function(K)\n        return hash_code % tuples.size();\n    }\n\n    // the returned tuple is either empty or with the same key\n    size_t indexOfKey(const int & key) const {\n        size_t index = canonical_index(key);\n        while (true) { // will enter a dead loop if there is not empty tuple\n            if (! tuples[index].in_use) return index;\n            if (tuples[index].key1 == key) return index;\n            index = (index + 1) % tuples.size();\n        }\n    }\n\n    size_t indexOfKey(const string & key) const {\n        size_t index = canonical_index(key);\n        while (true) { // will enter a dead loop if there is not empty tuple\n            if (! tuples[index].in_use) return index;\n            if (tuples[index].key2 == key) return index;\n            index = (index + 1) % tuples.size();\n        }\n    }\n\npublic:\n    HT() : _size(0) {\n        tuples.resize(2);\n    }\n\n    const Tuple & operator [] (const int & key) const {\n        size_t index = indexOfKey(key);\n        if (! tuples[index].in_use) \n            throw NoSuchKeyException();\n        return tuples[index];\n    }\n\n    Tuple & operator [] (const int & key) {\n        size_t index = indexOfKey(key);\n        if (! tuples[index].in_use) \n            throw NoSuchKeyException();\n        return tuples[index];\n    }\n\n    const Tuple & operator [] (const string & key) const {\n        size_t index = indexOfKey(key);\n        if (! tuples[index].in_use) \n            throw NoSuchKeyException();\n        return tuples[index];\n    }\n\n    Tuple & operator [] (const string & key) {\n        size_t index = indexOfKey(key);\n        if (! tuples[index].in_use) \n            throw NoSuchKeyException();\n        return tuples[index];\n    }\n\n    void put(const int & key, const int & val) {\n        size_t index = indexOfKey(key);\n        tuples[index].key1 = key;\n        tuples[index].key2 = \"empty\";\n        tuples[index].val1 = val;\n        tuples[index].val2 = \"empty\";\n        if (tuples[index].in_use) return;\n        tuples[index].in_use = true;\n        ++ _size;\n        // make sure empty > size / 2\n        if (2 * _size > tuples.size())\n            double_tuples();\n    }\n\n    void put(const string & key, const string & val) {\n        size_t index = indexOfKey(key);\n        tuples[index].key1 = -1;\n        tuples[index].key2 = key;\n        tuples[index].val1 = -1;\n        tuples[index].val2 = val;\n        if (tuples[index].in_use) return;\n        tuples[index].in_use = true;\n        ++ _size;\n        // make sure empty > size / 2\n        if (2 * _size > tuples.size())\n            double_tuples();\n    }\n\n    void put(const int & key, const string & val) {\n        size_t index = indexOfKey(key);\n        tuples[index].key1 = key;\n        tuples[index].key2 = \"empty\";\n        tuples[index].val1 = -1;\n        tuples[index].val2 = val;\n        if (tuples[index].in_use) return;\n        tuples[index].in_use = true;\n        ++ _size;\n        // make sure empty > size / 2\n        if (2 * _size > tuples.size())\n            double_tuples();\n    }\n\n    void put(const string & key, const int & val) {\n        size_t index = indexOfKey(key);\n        tuples[index].key1 = -1;\n        tuples[index].key2 = key;\n        tuples[index].val1 = val;\n        tuples[index].val2 = \"empty\";\n        if (tuples[index].in_use) return;\n        tuples[index].in_use = true;\n        ++ _size;\n        // make sure empty > size / 2\n        if (2 * _size > tuples.size())\n            double_tuples();\n    }\n\n    void double_tuples() {\n        vector<Tuple> non_empty_tuples;\n        I(i, tuples.size())\n            if (tuples[i].in_use)\n                non_empty_tuples.push_back(tuples[i]);\n        clear();\n        tuples.resize(tuples.size() * 2);\n        I(i, non_empty_tuples.size())\n        {\n            if(non_empty_tuples[i].key2 == \"empty\" && non_empty_tuples[i].val2 == \"empty\")\n                put(non_empty_tuples[i].key1, non_empty_tuples[i].val1);\n            else if(non_empty_tuples[i].key1 == -1 && non_empty_tuples[i].val1 == -1)\n                put(non_empty_tuples[i].key2, non_empty_tuples[i].val2);\n            else if(non_empty_tuples[i].key2 == \"empty\" && non_empty_tuples[i].val1 == -1)\n                put(non_empty_tuples[i].key1, non_empty_tuples[i].val2);\n            else\n                put(non_empty_tuples[i].key2, non_empty_tuples[i].val1);\n        }\n    }\n\n    size_t size() const { return _size; }\n\n    void clear() {\n        I(i, tuples.size())\n            tuples[i].in_use = false;\n        _size = 0;\n    }\n};",
            1595511970.0302129,
            100,
            "# 答案正确"
        ]
    ],
    "table_name": "答案"
}