{
    "__update_time__": 1596179727.832361,
    "field_names": [
        "题目名",
        "用户名",
        "答案",
        "提交时间",
        "分数",
        "评语"
    ],
    "field_types": [
        "text",
        "text",
        "text",
        "time",
        "number",
        "text"
    ],
    "foreign_keys": {},
    "primary_keys": [],
    "rows": [
        [
            "测试1",
            "伍海珊",
            "#include<iostream>\nusing namespace std;\n\nvoid Reverse_line(char* pBegin,char* pEnd){\n    if(pBegin==nullptr || pEnd==nullptr)\n        return;\n\n    while(pBegin<pEnd){\n        char t=*pBegin;\n        *pBegin=*pEnd;\n        *pEnd=t;\n\n        pBegin++;\n        pEnd--;\n    }\n\n}\n\nchar* Reverse(char* s){\n    if(s==nullptr) return nullptr;\n\n    char* pBegin=s;\n    char* pEnd=s;\n    while(*pEnd!=0) pEnd++;\n    pEnd--;\n\n    Reverse_line(pBegin,pEnd);\n\n    pBegin=pEnd=s;\n\n    while(*pBegin!=0){\n        if(*pBegin==' '){\n            pBegin++;\n            pEnd++;\n        }\n        else if(*pEnd==' '||*pEnd==0){\n            Reverse_line(pBegin,--pEnd);\n            pBegin=++pEnd;\n        }\n        else pEnd++;\n    }\n    return s;\n}\n\nint main(){\n\tchar s[100];\n\tcin.get(s,100);\n\n\tchar* p=Reverse(s);\n\n\twhile(*p!=0)\n        cout << *p++;\n}",
            1587609701.5191684,
            100,
            "# 答案正确"
        ],
        [
            "测试2",
            "伍海珊",
            "#include<iostream>\n#include<cstring>\nusing namespace std;\n\nint main(){\n\tchar words[10][10];\n\n\tfor(int i=0; i<10; ++i)\n        scanf(\"%s\",words[i]);\n\n    for(int i=0; i<10; ++i){\n        for(int j=i+1; j<10; ++j){\n            if(strcmp(words[i],words[j])>0){\n                char t[10];\n                strcpy(t,words[j]);\n                strcpy(words[j],words[i]);\n                strcpy(words[i],t);\n            }\n        }\n    }\n\n    for(int i=0; i<10; ++i)\n        cout << words[i] << ' ';\n}",
            1587610261.8394616,
            100,
            "# 答案正确"
        ],
        [
            "1.1 (C++)",
            "伍海珊",
            "class Matrix5x5{\npublic:\n    Matrix5x5();\n    ~Matrix5x5(){};\n    double get(int, int);\n    void set(int, int, double);\n    Matrix5x5 operator + (Matrix5x5 &);\n\nprivate:\n    double m[5][5];\n};\n\nMatrix5x5::Matrix5x5(){\n    for(int i=0; i<5; ++i){\n        for(int j=0; j<5; ++j)\n            m[i][j]=0;\n    }\n}\n\ndouble Matrix5x5::get(int row,int col){\n    return m[row][col];\n}\n\nvoid Matrix5x5::set(int row,int col,double value){\n    m[row][col]=value;\n}\n\nMatrix5x5 Matrix5x5::operator+(Matrix5x5& a){\n    Matrix5x5 sum;\n\n    for(int i=0; i<5; ++i){\n        for(int j=0; j<5; ++j){\n            sum.m[i][j]=m[i][j]+a.m[i][j];\n        }\n    }\n\n    return sum;\n}",
            1587698200.9099538,
            100,
            "# 答案正确"
        ],
        [
            "1.2 (C++)",
            "伍海珊",
            "#include <cstring>\n\nclass School{\npublic:\n    char name[10];\n    int age;\n    School():name(\"NO_NAME\"),age(0){};\n    ~School(){};\n    void setName(char name[]);\n    void setAge(int year);\n    void operator ++ ();\n\nprivate:\n};\n\nvoid School::setName(char name[]){\n    strcpy(this->name,name);\n}\n\nvoid School::setAge(int year){\n    age=year;\n}\n\nvoid School::operator++(){\n    age++;\n}",
            1588215709.0234375,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/08",
            "伍海珊",
            "double & Tensor_get(int dimensions, int sizes[], double data[], int x0, int x1, int x2, int x3){\n    int a[4];\n    a[0]=x0;\n    a[1]=x1;\n    a[2]=x2;\n    a[3]=x3;\n    int num=0;\n    \n    for (int i = 0; i < dimensions; i++){\n        num=num*10+a[i];\n    }\n    \n    data[0]=num;\n    return *data;\n}",
            1588907813.2466846,
            100,
            "# 答案正确"
        ],
        [
            "2.1 (C++)",
            "伍海珊",
            "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nclass Matrix{\npublic:\n    Matrix(int rows, int columns);\n    ~Matrix();\n    void print();\n\nprivate:\n    int rows;\n    int columns;\n    double* values;\n};\n\nMatrix::Matrix(int rows, int columns){\n    this->rows=rows;\n    this->columns=columns;\n    this->values = new double[rows*columns];\n\n    for(int i=0; i<rows*columns; ++i)\n        *(values+i)=0;\n}\n\nMatrix::~Matrix(){\n    delete [] this->values;\n}\n\nvoid Matrix::print(){\n    int row=this->rows;\n    int col=this->columns;\n\n    for(int i=0; i<row; ++i){\n        for(int j=0; j<col; ++j){\n            cout << setw(5) << *(this->values+col*i+j);\n        }\n        cout << endl;\n    }\n}\n",
            1588911918.112389,
            100,
            "# 答案正确"
        ],
        [
            "2.2 (C++)",
            "伍海珊",
            "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nclass Matrix{\npublic:\n    Matrix(int rows, int columns,double values[]);\n    ~Matrix();\n    void print();\n\nprivate:\n    int rows;\n    int columns;\n    double* values;\n};\n\nMatrix::Matrix(int rows, int columns,double values[]){\n    this->rows=rows;\n    this->columns=columns;\n    this->values = new double[rows*columns];\n\n    for(int i=0; i<rows*columns; ++i)\n        *(this->values+i)=values[i];\n}\n\nMatrix::~Matrix(){\n    delete [] this->values;\n}\n\nvoid Matrix::print(){\n    int row=this->rows;\n    int col=this->columns;\n\n    for(int i=0; i<row; ++i){\n        for(int j=0; j<col; ++j){\n            cout << setw(5) << *(this->values+col*i+j);\n        }\n        cout << endl;\n    }\n}\n",
            1588913047.0683126,
            100,
            "# 答案正确"
        ],
        [
            "2.3 (C++)",
            "伍海珊",
            "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nclass Matrix{\npublic:\n    Matrix(int rows, int columns,double values[]);\n    Matrix(const Matrix & matrix2);\n    ~Matrix();\n    void print();\n\nprivate:\n    int rows;\n    int columns;\n    double* values;\n};\n\nMatrix::Matrix(int rows, int columns,double values[]){\n    this->rows=rows;\n    this->columns=columns;\n    this->values = new double[rows*columns];\n\n    for(int i=0; i<rows*columns; ++i)\n        *(this->values+i)=values[i];\n}\n\nMatrix::Matrix(const Matrix& matrix2){\n    this->rows=matrix2.rows;\n    this->columns=matrix2.columns;\n    this->values=new double[this->rows*this->columns];\n\n    for(int i=0; i<rows*columns; ++i)\n        *(this->values+i)=*(matrix2.values+i);\n}\n\nMatrix::~Matrix(){\n    delete [] this->values;\n}\n\nvoid Matrix::print(){\n    int row=this->rows;\n    int col=this->columns;\n\n    for(int i=0; i<row; ++i){\n        for(int j=0; j<col; ++j){\n\t\t\t\n\t\t\tfor(int k=0; k<4; ++k) cout << ' ';\n\t\t\t\n            cout << *(this->values+col*i+j);\n        }\n        cout << endl;\n    }\n}",
            1588941114.7157094,
            100,
            "# 答案正确"
        ],
        [
            "2.5 (C++)",
            "伍海珊",
            "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nclass Matrix{\npublic:\n    Matrix(int rows, int columns);\n    Matrix(int rows, int columns,double values[]);\n    ~Matrix();\n\n    void print();\n    Matrix getRow(int row);\n    Matrix getColumn(int column);\n\nprivate:\n    int rows;\n    int columns;\n    double* values;\n};\n\nMatrix::Matrix(int rows, int columns){\n    this->rows=rows;\n    this->columns=columns;\n    this->values = new double[rows*columns];\n\n    for(int i=0; i<rows*columns; ++i)\n        *(values+i)=0;\n}\n\nMatrix::Matrix(int rows, int columns,double values[]){\n    this->rows=rows;\n    this->columns=columns;\n    this->values = new double[rows*columns];\n\n    for(int i=0; i<rows*columns; ++i)\n        *(this->values+i)=values[i];\n}\n\nMatrix::~Matrix(){\n    delete [] this->values;\n}\n\nvoid Matrix::print(){\n    int row=this->rows;\n    int col=this->columns;\n\n    for(int i=0; i<row; ++i){\n        for(int j=0; j<col; ++j){\n\n\t\t\tfor(int k=0; k<4; ++k) cout << ' ';\n\n            cout << *(this->values+col*i+j);\n        }\n        cout << endl;\n    }\n}\n\nMatrix Matrix::getRow(int row){\n    Matrix temp(1,this->columns,this->values+(row-1)*this->columns);\n    return temp;\n}\n\nMatrix Matrix::getColumn(int column){\n    Matrix temp(this->rows,1);\n\n    for(int i=0; i<this->rows; ++i){\n        *(temp.values+i)= *(this->values+i*this->columns+column-1);\n    }\n\n    return temp;\n}",
            1588948714.014648,
            100,
            "# 答案正确"
        ],
        [
            "2.6 (C++)",
            "伍海珊",
            "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nclass Matrix{\npublic:\n    Matrix(int rows, int columns,double values[]);\n    Matrix(const Matrix & matrix2);\n    ~Matrix();\n\n    void print();\n    Matrix concatenateRows(const Matrix & matrix2) const;\n    Matrix concatenateColumns(const Matrix & matrix2) const;\n\nprivate:\n    int rows;\n    int columns;\n    double* values;\n};\n\nMatrix::Matrix(int rows, int columns,double values[]){\n    this->rows=rows;\n    this->columns=columns;\n    this->values = new double[rows*columns];\n\n    for(int i=0; i<rows*columns; ++i)\n        *(this->values+i)=values[i];\n}\n\nMatrix::Matrix(const Matrix& matrix2){\n    this->rows=matrix2.rows;\n    this->columns=matrix2.columns;\n    this->values=new double[this->rows*this->columns];\n\n    for(int i=0; i<rows*columns; ++i)\n        *(this->values+i)=*(matrix2.values+i);\n}\n\nMatrix::~Matrix(){\n    delete [] this->values;\n}\n\nvoid Matrix::print(){\n    int row=this->rows;\n    int col=this->columns;\n\n    for(int i=0; i<row; ++i){\n        for(int j=0; j<col; ++j){\n\n\t\t\tfor(int k=0; k<4; ++k) cout << ' ';\n\n            cout << *(this->values+col*i+j);\n        }\n        cout << endl;\n    }\n}\n\nMatrix Matrix::concatenateRows(const Matrix & matrix2) const{\n    int len1=this->columns*this->rows;\n    int len2=matrix2.columns*matrix2.rows;\n    double value[len1+len2];\n\n    int k=0;\n    for(int i=0; i<len1; ++i){\n        value[k++]=*(this->values+i);\n    }\n    for(int i=0; i<len2; ++i){\n        value[k++]=*(matrix2.values+i);\n    }\n\n    Matrix temp(this->rows+matrix2.rows,this->columns,value);\n    return temp;\n}\n\nMatrix Matrix::concatenateColumns(const Matrix & matrix2) const{\n    int len1=this->columns*this->rows;\n    int len2=matrix2.columns*matrix2.rows;\n    double value[len1+len2];\n\n    int k=0;\n    for(int i=0; i<this->rows; ++i){\n        for(int j=0; j<this->columns; ++j)\n            value[k++]=*(this->values+i*this->columns+j);\n\n        for(int j=0; j<matrix2.columns; ++j)\n            value[k++]=*(matrix2.values+i*matrix2.columns+j);\n    }\n\n    Matrix temp(this->rows,this->columns+matrix2.columns,value);\n    return temp;\n}",
            1588949714.309006,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/14",
            "伍海珊",
            "#include <iostream>\nusing namespace std;\n\nvoid Tensor_print(int dimensions, const int sizes[], const double data[]){\n    cout << \"Tensor of \" << sizes[0];\n    for(int i=1; i<dimensions; ++i)\n        cout << 'x' << sizes[i];\n    cout << endl;\n\n    int times=1,rows=sizes[0],cols=1;\n\n    if(dimensions==4){\n        times=sizes[0]*sizes[1];\n        rows=sizes[2];\n        cols=sizes[3];\n    }\n    else if(dimensions==3){\n        times=sizes[0];\n        rows=sizes[1];\n        cols=sizes[2];\n    }\n    else if(dimensions==2){\n        cols=sizes[1];\n    }\n\n    int t1=0,t2=0,cnt=0;\n    for(int i=0; i<times; ++i){\n        if(dimensions==4){\n            cout << \"data[\" << t1 << \"][\" << t2 << ']' << endl;\n            if(t2==sizes[1]-1){\n                t1++;\n                t2=0;\n            }\n            else t2++;\n        }\n        else if(dimensions==3){\n            cout << \"data[\" << t1 << ']' << endl;\n            t1++;\n        }\n\n        for(int j=0; j<rows; ++j){\n            for(int k=0; k<cols; ++k){\n                cout << \"    \" << data[cnt++];\n            }\n            cout << endl;\n        }\n    }\n\n}\n",
            1589426010.936932,
            100,
            "# 答案正确"
        ],
        [
            "2.4 (C++)",
            "伍海珊",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix{\npublic:\n    Matrix(int rows, int columns);\n    Matrix(int rows, int columns, double values[]);\n    ~Matrix();\n    void print();\n    void set(int row, int column, double value);\n    Matrix& operator=(Matrix& Matrix2);\n\nprivate:\n    int rows;\n    int columns;\n    double* values;\n};\n\nMatrix::Matrix(int rows, int columns){\n    this->rows=rows;\n    this->columns=columns;\n    this->values=new double[rows*columns];\n\n    for(int i=0; i<rows*columns; ++i)\n        *(this->values+i)=0;\n}\n\nMatrix::Matrix(int rows, int columns, double values[]){\n    this->rows=rows;\n    this->columns=columns;\n    this->values=new double[rows*columns];\n\n    for(int i=0; i<rows*columns; ++i)\n        *(this->values+i)=values[i];\n}\n\nMatrix::~Matrix(){\n    delete []this->values;\n}\n\nvoid Matrix::print(){\n    for(int i=0; i<this->rows; ++i){\n        for(int j=0; j<this->columns; ++j){\n            cout << \"    \" << *(this->values+i*this->columns+j);\n        }\n        cout << endl;\n    }\n}\n\nvoid Matrix::set(int row, int column, double value){\n    *(this->values+(row-1)*this->columns+column-1)=value;\n}\n\nMatrix& Matrix::operator=(Matrix& Matrix2){\n    if(this!=&Matrix2){\n        this->rows=Matrix2.rows;\n        this->columns=Matrix2.columns;\n        delete []this->values;\n\n        this->values=new double[this->rows*this->columns];\n        for(int i=0; i<this->rows*this->columns; ++i)\n            *(this->values+i)=*(Matrix2.values+i);\n\n        return *this;\n    }\n}\n",
            1589879551.8831406,
            100,
            "# 答案正确"
        ],
        [
            "2.7 (C++)",
            "伍海珊",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix{\npublic:\n    Matrix(int rows, int columns, double values[]);\n    Matrix(const Matrix & matrix2);\n    ~Matrix();\n    void print();\n    Matrix reshape(int rows, int columns) const;\n\nprivate:\n    int rows;\n    int columns;\n    double* values;\n};\n\nMatrix::Matrix(int rows, int columns, double values[]){\n    this->rows=rows;\n    this->columns=columns;\n    this->values=new double[rows*columns];\n\n    for(int i=0; i<rows*columns; ++i)\n        *(this->values+i)=values[i];\n}\n\nMatrix::Matrix(const Matrix & matrix2){\n    this->rows=matrix2.rows;\n    this->columns=matrix2.columns;\n    this->values=new double[this->rows*this->columns];\n\n    for(int i=0; i<this->rows*this->columns; ++i)\n        *(this->values+i)=*(matrix2.values+i);\n}\n\nMatrix::~Matrix(){\n    delete []this->values;\n}\n\nvoid Matrix::print(){\n    for(int i=0; i<this->rows; ++i){\n        for(int j=0; j<this->columns; ++j){\n            cout << \"    \" << *(this->values+i*this->columns+j);\n        }\n        cout << endl;\n    }\n}\n\nMatrix Matrix::reshape(int rows, int columns) const{\n    double tmp[rows*columns];\n    int cnt=0;\n\n    for(int i=0; i<this->columns; ++i){\n        for(int j=0; j<this->rows; ++j){\n            tmp[cnt++]=*(this->values+i+j*this->columns);\n        }\n    }\n\n    double values[rows*columns];\n    int k=0;\n\n    for(int i=0; i<rows; ++i){\n        for(int j=0; j<columns; ++j){\n            values[k++]=tmp[i+j*rows];\n        }\n    }\n\n    Matrix t(rows,columns,values);\n    return t;\n}\n",
            1589890180.8963604,
            100,
            "# 答案正确"
        ],
        [
            "2.8 (C++)",
            "伍海珊",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix{\npublic:\n    Matrix(int rows, int columns, double values[]);\n    Matrix(const Matrix & matrix2);\n    ~Matrix();\n    void print();\n    Matrix transpose();\n\nprivate:\n    int rows;\n    int columns;\n    double* values;\n};\n\nMatrix::Matrix(int rows, int columns, double values[]){\n    this->rows=rows;\n    this->columns=columns;\n    this->values=new double[rows*columns];\n\n    for(int i=0; i<rows*columns; ++i)\n        *(this->values+i)=values[i];\n}\n\nMatrix::Matrix(const Matrix & matrix2){\n    this->rows=matrix2.rows;\n    this->columns=matrix2.columns;\n    this->values=new double[this->rows*this->columns];\n\n    for(int i=0; i<this->rows*this->columns; ++i)\n        *(this->values+i)=*(matrix2.values+i);\n}\n\nMatrix::~Matrix(){\n    delete []this->values;\n}\n\nvoid Matrix::print(){\n    for(int i=0; i<this->rows; ++i){\n        for(int j=0; j<this->columns; ++j){\n            cout << \"    \" << *(this->values+i*this->columns+j);\n        }\n        cout << endl;\n    }\n}\n\nMatrix Matrix::transpose(){\n    double values[this->rows*this->columns];\n    int cnt=0;\n\n    for(int i=0; i<this->columns; ++i){\n        for(int j=0; j<this->rows; ++j){\n            values[cnt++]=*(this->values+i+j*this->columns);\n        }\n    }\n\n    Matrix t(this->columns,this->rows,values);\n    return t;\n}",
            1589890534.3051114,
            100,
            "# 答案正确"
        ],
        [
            "2.10 (C++)",
            "伍海珊",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix{\npublic:\n    Matrix(int rows, int columns, double values[]);\n    Matrix(const Matrix & matrix2);\n    ~Matrix();\n    void print();\n    Matrix operator*(const Matrix & matrix2) const;\n    Matrix operator*(double value) const;\n\nprivate:\n    int rows;\n    int columns;\n    double* values;\n};\n\nMatrix::Matrix(int rows, int columns, double values[]){\n    this->rows=rows;\n    this->columns=columns;\n    this->values=new double[rows*columns];\n\n    for(int i=0; i<rows*columns; ++i)\n        *(this->values+i)=values[i];\n}\n\nMatrix::Matrix(const Matrix & matrix2){\n    this->rows=matrix2.rows;\n    this->columns=matrix2.columns;\n    this->values=new double[this->rows*this->columns];\n\n    for(int i=0; i<this->rows*this->columns; ++i)\n        *(this->values+i)=*(matrix2.values+i);\n}\n\nMatrix::~Matrix(){\n    delete []this->values;\n}\n\nvoid Matrix::print(){\n    for(int i=0; i<this->rows; ++i){\n        for(int j=0; j<this->columns; ++j){\n            cout << \"    \" << *(this->values+i*this->columns+j);\n        }\n        cout << endl;\n    }\n}\n\nMatrix Matrix::operator*(const Matrix & matrix2) const{\n    double ans[this->rows][matrix2.columns];\n\n    for(int i=0; i<this->rows; ++i){\n        for(int j=0; j<matrix2.columns; ++j)\n            ans[i][j]=0;\n    }\n\n    for(int i=0; i<this->rows; ++i){\n        for(int j=0; j<matrix2.columns; ++j){\n            for(int k=0; k<this->columns; ++k){\n                double a=*(this->values+i*this->columns+k);\n                double b=*(matrix2.values+k*matrix2.columns+j);\n                ans[i][j]+=a*b;\n            }\n        }\n    }\n\n    double values[this->rows*matrix2.columns];\n    int cnt=0;\n\n    for(int i=0; i<this->rows; ++i){\n        for(int j=0; j<matrix2.columns; ++j){\n            values[cnt++]=ans[i][j];\n        }\n    }\n\n    Matrix t(this->rows,matrix2.columns,values);\n    return t;\n}\n\nMatrix Matrix::operator*(double value) const{\n    double values[this->rows*this->columns];\n    int k=0;\n\n    for(int i=0; i<this->rows; ++i){\n        for(int j=0; j<this->columns; ++j){\n            values[k++]=(*(this->values+i*this->columns+j))*value;\n        }\n    }\n\n    Matrix t(this->rows,this->columns,values);\n    return t;\n}",
            1589892283.0950704,
            100,
            "# 答案正确"
        ],
        [
            "2.11 (C++)",
            "伍海珊",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix{\npublic:\n    Matrix(int rows, int columns, double values[]);\n    Matrix(const Matrix & matrix2);\n    ~Matrix();\n    void print();\n    Matrix max() const;\n    Matrix min() const;\n    Matrix sum() const;\n\nprivate:\n    int rows;\n    int columns;\n    double* values;\n};\n\nMatrix::Matrix(int rows, int columns, double values[]){\n    this->rows=rows;\n    this->columns=columns;\n    this->values=new double[rows*columns];\n\n    for(int i=0; i<rows*columns; ++i)\n        *(this->values+i)=values[i];\n}\n\nMatrix::Matrix(const Matrix & matrix2){\n    this->rows=matrix2.rows;\n    this->columns=matrix2.columns;\n    this->values=new double[this->rows*this->columns];\n\n    for(int i=0; i<this->rows*this->columns; ++i)\n        *(this->values+i)=*(matrix2.values+i);\n}\n\nMatrix::~Matrix(){\n    delete []this->values;\n}\n\nvoid Matrix::print(){\n    for(int i=0; i<this->rows; ++i){\n        for(int j=0; j<this->columns; ++j){\n            cout << \"    \" << *(this->values+i*this->columns+j);\n        }\n        cout << endl;\n    }\n}\n\nMatrix Matrix::max() const{\n    if(this->rows==1){\n        double max=0;\n\n        for(int i=0; i<this->columns; ++i){\n            if(max<*(this->values+i))\n                max=*(this->values+i);\n        }\n\n        Matrix t(1,1,&max);\n        return t;\n    }\n\n    double max[this->columns];\n    for(int i=0; i<this->columns; ++i){\n        int ans=0;\n\n        for(int j=0; j<this->rows; ++j){\n            if(ans<*(this->values+j*this->columns+i))\n                ans=*(this->values+j*this->columns+i);\n        }\n\n        max[i]=ans;\n    }\n\n    Matrix t(1,this->columns,max);\n    return t;\n}\n\nMatrix Matrix::min() const{\n    if(this->rows==1){\n        double min=*(this->values);\n\n        for(int i=0; i<this->columns; ++i){\n            if(min>*(this->values+i))\n                min=*(this->values+i);\n        }\n\n        Matrix t(1,1,&min);\n        return t;\n    }\n\n    double min[this->columns];\n    for(int i=0; i<this->columns; ++i){\n        int ans=*(this->values+i);\n\n        for(int j=0; j<this->rows; ++j){\n            if(ans>*(this->values+j*this->columns+i))\n                ans=*(this->values+j*this->columns+i);\n        }\n\n        min[i]=ans;\n    }\n\n    Matrix t(1,this->columns,min);\n    return t;\n}\n\nMatrix Matrix::sum() const{\n    if(this->rows==1){\n        double sum=0;\n\n        for(int i=0; i<this->columns; ++i){\n            sum+=*(this->values+i);\n        }\n\n        Matrix t(1,1,&sum);\n        return t;\n    }\n\n    double sum[this->columns];\n    for(int i=0; i<this->columns; ++i){\n        int ans=0;\n        for(int j=0; j<this->rows; ++j){\n            ans+=*(this->values+j*this->columns+i);\n        }\n        sum[i]=ans;\n    }\n\n    Matrix t(1,this->columns,sum);\n    return t;\n}",
            1589893802.1148953,
            100,
            "# 答案正确"
        ],
        [
            "2.12 (C++)",
            "伍海珊",
            "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nclass Matrix{\npublic:\n    Matrix(int rows, int columns, double values[]);\n    Matrix(const Matrix & matrix2);\n    ~Matrix();\n    void print();\n    Matrix pow(double exponent);\n    Matrix exp();\n    Matrix log();\n    Matrix abs();\n\nprivate:\n    int rows;\n    int columns;\n    double* values;\n};\n\nMatrix::Matrix(int rows, int columns, double values[]){\n    this->rows=rows;\n    this->columns=columns;\n    this->values=new double[rows*columns];\n\n    for(int i=0; i<rows*columns; ++i)\n        *(this->values+i)=values[i];\n}\n\nMatrix::Matrix(const Matrix & matrix2){\n    this->rows=matrix2.rows;\n    this->columns=matrix2.columns;\n    this->values=new double[this->rows*this->columns];\n\n    for(int i=0; i<this->rows*this->columns; ++i)\n        *(this->values+i)=*(matrix2.values+i);\n}\n\nMatrix::~Matrix(){\n    delete []this->values;\n}\n\nvoid Matrix::print(){\n    for(int i=0; i<this->rows; ++i){\n        for(int j=0; j<this->columns; ++j){\n            cout << \"    \" << *(this->values+i*this->columns+j);\n        }\n        cout << endl;\n    }\n}\n\nMatrix Matrix::pow(double exponent){\n    double values[this->rows*this->columns];\n\n    for(int i=0; i<this->rows*this->columns; ++i)\n        values[i]=std::pow(*(this->values+i),exponent);\n\n    Matrix t(this->rows,this->columns,values);\n    return t;\n}\n\nMatrix Matrix::exp(){\n    double values[this->rows*this->columns];\n\n    for(int i=0; i<this->rows*this->columns; ++i)\n        values[i]=std::exp(*(this->values+i));\n\n    Matrix t(this->rows,this->columns,values);\n    return t;\n}\n\nMatrix Matrix::log(){\n    double values[this->rows*this->columns];\n\n    for(int i=0; i<this->rows*this->columns; ++i)\n        values[i]=std::log(*(this->values+i));\n\n    Matrix t(this->rows,this->columns,values);\n    return t;\n}\n\nMatrix Matrix::abs(){\n    double values[this->rows*this->columns];\n\n    for(int i=0; i<this->rows*this->columns; ++i)\n        values[i]=std::abs(*(this->values+i));\n\n    Matrix t(this->rows,this->columns,values);\n    return t;\n}",
            1589894719.6215582,
            100,
            "# 答案正确"
        ],
        [
            "2.9 (C++)",
            "伍海珊",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix{\npublic:\n    Matrix(int rows, int columns, double values[]);\n    Matrix(const Matrix & matrix2);\n    ~Matrix();\n    void print();\n    Matrix operator + (const Matrix & matrix2) const;\n    Matrix operator + (double value) const;\n    Matrix operator - (const Matrix & matrix2) const;\n    Matrix operator - (double value) const;\n\nprivate:\n    int rows;\n    int columns;\n    double* values;\n};\n\nMatrix::Matrix(int rows, int columns, double values[]){\n    this->rows=rows;\n    this->columns=columns;\n    this->values=new double[rows*columns];\n\n    for(int i=0; i<rows*columns; ++i)\n        *(this->values+i)=values[i];\n}\n\nMatrix::Matrix(const Matrix & matrix2){\n    this->rows=matrix2.rows;\n    this->columns=matrix2.columns;\n    this->values=new double[this->rows*this->columns];\n\n    for(int i=0; i<this->rows*this->columns; ++i)\n        *(this->values+i)=*(matrix2.values+i);\n}\n\nMatrix::~Matrix(){\n    delete []this->values;\n}\n\nvoid Matrix::print(){\n    for(int i=0; i<this->rows; ++i){\n        for(int j=0; j<this->columns; ++j){\n            cout << \"    \" << *(this->values+i*this->columns+j);\n        }\n        cout << endl;\n    }\n}\n\nMatrix Matrix::operator + (const Matrix & matrix2) const{\n    double values[this->rows*this->columns];\n\n    for(int i=0; i<this->rows*this->columns; ++i)\n        values[i]=*(this->values+i)+*(matrix2.values+i);\n\n    Matrix t(this->rows,this->columns,values);\n    return t;\n}\n\nMatrix Matrix::operator + (double value) const{\n    double values[this->rows*this->columns];\n\n    for(int i=0; i<this->rows*this->columns; ++i)\n        values[i]=*(this->values+i)+value;\n\n    Matrix t(this->rows,this->columns,values);\n    return t;\n}\n\nMatrix Matrix::operator - (const Matrix & matrix2) const{\n    double values[this->rows*this->columns];\n\n    for(int i=0; i<this->rows*this->columns; ++i)\n        values[i]=*(this->values+i)-*(matrix2.values+i);\n\n    Matrix t(this->rows,this->columns,values);\n    return t;\n}\n\nMatrix Matrix::operator - (double value) const{\n    double values[this->rows*this->columns];\n\n    for(int i=0; i<this->rows*this->columns; ++i)\n        values[i]=*(this->values+i)-value;\n\n    Matrix t(this->rows,this->columns,values);\n    return t;\n}\n",
            1590028520.0706942,
            100,
            "# 答案正确"
        ],
        [
            "6.2 (C++)",
            "伍海珊",
            "#include <iostream>\nusing namespace std;\n\ntemplate <class T>\nclass Matrix{\npublic:\n\n    Matrix(int row, int column){\n        this->rows=row;\n        this->columns=column;\n        values=new T[row*column];\n\n        for(int i=0; i<row*column; ++i)\n            *(values+i)=0;\n    }\n\n    ~Matrix(){\n        delete []values;\n    }\n\n    void print(){\n        for(int i=0; i<this->rows; ++i){\n            for(int j=0; j<this->columns; ++j){\n                cout << \"    \" << *(values+i*this->columns+j);\n            }\n            cout << endl;\n        }\n    }\n\nprivate:\n    int rows;\n    int columns;\n    T* values;\n};",
            1590632590.6933842,
            100,
            "# 答案正确"
        ],
        [
            "6.1 (C++)",
            "伍海珊",
            "#include<vector>\ntemplate<typename T>\nclass Matrix {\nprivate:\n int mrows, mcolumns;\n vector<T>mvalues;\npublic:\n Matrix(int rows, int columns) :mrows(rows), mcolumns(columns) {\n  for (int i = 0; i < mrows * mcolumns; ++i) mvalues.push_back(T());\n };\n Matrix(int rows, int columns, const T* values) :mrows(rows), mcolumns(columns) {\n  for (int i = 0; i < mrows * mcolumns; ++i) mvalues.push_back(values[i]);\n };\n T& get(int i, int j) {\n  i--;\n  j--;\n  return mvalues[i * mcolumns + j];\n }\n void print() {\n  for (int i = 0; i < mrows; ++i) {\n   for (int j = 0; j < mcolumns; ++j) cout << \"    \" << mvalues[i * mcolumns + j];\n   cout << endl;\n  }\n }\n};",
            1590669677.6146276,
            100,
            "# 答案正确"
        ],
        [
            "6.3 (C++)",
            "伍海珊",
            "#include<iostream>\n#include<vector>\nusing namespace std;\ntemplate<typename T>\nclass Matrix {\n private:\n  int mrows, mcolumns;\n  vector<T>mvalues;\n public:\n  Matrix(int rows, int columns) :mrows(rows), mcolumns(columns) {\n   for (int i = 0; i < mrows * mcolumns; ++i) mvalues.push_back(0);\n  };\n  Matrix(int rows, int columns, vector<T>values) :mrows(rows), mcolumns(columns) {\n   for (int i = 0; i < mrows * mcolumns; ++i) mvalues.push_back(values[i]);\n  };\n  T& get(int i, int j) {\n   i--;\n   j--;\n   return mvalues[i * mcolumns + j];\n  }\n  void print() {\n   for (int i = 0; i < mrows; ++i) {\n    for (int j = 0; j < mcolumns; ++j) cout << \"    \" << mvalues[i * mcolumns + j];\n    cout << endl;\n   }\n  }\n  Matrix getColumn(int col){\n   vector<T>values;\n   col--;\n   for(int i=0;i<mrows;++i) values.push_back(mvalues[i*mcolumns+col]);\n   return Matrix(mrows,1,values);\n  } \n  Matrix getRow(int row){\n   vector<T>values;\n   row--;\n   for(int j=0;j<mcolumns;++j) values.push_back(mvalues[row*mcolumns+j]);\n   return Matrix(1,mcolumns,values);\n  } \n  Matrix concatenateRows(Matrix &m2){\n   vector<T>values;\n   for(int i=0;i<mvalues.size();++i) values.push_back(mvalues[i]);\n   for(int i=0;i<m2.mvalues.size();++i) values.push_back(m2.mvalues[i]);\n   return Matrix(mrows+m2.mrows,mcolumns,values);\n  }\n  Matrix concatenateColumns(Matrix &m2){\n   vector<T>values;\n   for(int i=0;i<mrows;++i){\n    for(int j=0;j<mcolumns+m2.mcolumns;++j){\n     if(j<mcolumns) values.push_back(mvalues[i*mcolumns+j]);\n     else values.push_back(m2.mvalues[i*m2.mcolumns+j-mcolumns]);\n    }   \n   }\n   return Matrix(mrows,m2.mcolumns+mcolumns,values);\n  }\n\tMatrix reshape(int row,int column){\n   vector<T>values;\n   for(int j=0;j<mcolumns;++j){\n    for(int i=0;i<mrows;++i) values.push_back(mvalues[i*mcolumns+j]);\n   }\n   return Matrix(column,row,values).transpose();\n  }\n  Matrix transpose(){\n   vector<T>values;\n   for(int j=0;j<mcolumns;++j){\n    for(int i=0;i<mrows;++i) values.push_back(mvalues[i*mcolumns+j]);\n   }\n   return Matrix(mcolumns,mrows,values);\n  }\n  Matrix operator +(T val){\n   vector<T>values;\n   for(int i=0;i<mvalues.size();++i) values.push_back(mvalues[i]+val);\n   return Matrix(mrows,mcolumns,values);\n  }\n  Matrix operator +(Matrix &m2){\n   vector<T>values;\n   for(int i=0;i<mvalues.size();++i) values.push_back(mvalues[i]+m2.mvalues[i]);\n   return Matrix(mrows,mcolumns,values);\n  }\n  Matrix operator -(Matrix &m2){\n   vector<T>values;\n   for(int i=0;i<mvalues.size();++i) values.push_back(mvalues[i]-m2.mvalues[i]);\n   return Matrix(mrows,mcolumns,values);\n  }\n  Matrix operator -(T val){\n   vector<T>values;\n   for(int i=0;i<mvalues.size();++i) values.push_back(mvalues[i]-val);\n   return Matrix(mrows,mcolumns,values);\n  }\n  Matrix operator *(T val){\n   vector<T>values;\n   for(int i=0;i<mvalues.size();++i) values.push_back(mvalues[i]*val);\n   return Matrix(mrows,mcolumns,values);\n  }\n  Matrix operator *(Matrix &m2){\n   vector<T>values;\n   for(int i=0;i<mrows;++i){\n    for(int j=0;j<m2.mcolumns;++j){\n     T val=0;\n     for(int p=0;p<mcolumns;++p) val+=mvalues[i*mcolumns+p]*m2.mvalues[p*m2.mcolumns+j];\n     values.push_back(val);\n    }\n   }\n   return Matrix(mrows,m2.mcolumns,values);\n  }\n Matrix min(){\n   if(mcolumns>1){\n    T temp[100]={0};\n    for(int i=0;i<mrows;++i){\n     for(int j=0;j<mcolumns;++j) {\n      temp[j]+=mvalues[i*mrows+j];\n     }\n    }\n    int index=0;\n    for(int i=0;i<mcolumns;++i) if(temp[i]<temp[index]) index=i;\n    return this->getColumn(index+1);\n   }\n   else{\n    T val=mvalues[0];\n    for(int i=0;i<mvalues.size();++i) if(mvalues[i]<val) val=mvalues[i];\n    vector<T>values;\n    values.push_back(val);\n    return Matrix(1,1,values);\n   }\n  }\n  Matrix max(){\n   if(mcolumns>1){\n    T temp[100]={0};\n    for(int i=0;i<mrows;++i){\n     for(int j=0;j<mcolumns;++j) {\n      temp[j]+=mvalues[i*mrows+j];\n     }\n    }\n    int index=0;\n    for(int i=0;i<mcolumns;++i) if(temp[i]>temp[index]) index=i;\n    return this->getColumn(index+1);\n   }\n   else{\n    T val=mvalues[0];\n    for(int i=0;i<mvalues.size();++i) if(mvalues[i]>val) val=mvalues[i];\n    vector<T>values;\n    values.push_back(val);\n    return Matrix(1,1,values);\n   }\n  }\n  Matrix sum(){\n   T val=0;\n   for(int i=0;i<mvalues.size();++i) val+=mvalues[i];\n   vector<T>values;\n   values.push_back(val);\n   return Matrix(1,1,values);\n  }\n  \n};",
            1590669740.9804559,
            100,
            "# 答案正确"
        ],
        [
            "7.1 (C++)",
            "伍海珊",
            "#include <cmath>\n\nclass Triangle:public GeometricObject\n{\npublic:\n    Triangle(){\n        side1=side2=side3=0;\n    }\n\n    Triangle(double side1,double side2,double side3){\n        this->side1=side1;\n        this->side2=side2;\n        this->side3=side3;\n    }\n\n    double getSide1(){return side1;}\n    double getSide2(){return side2;}\n    double getSide3(){return side3;}\n\n    double getArea(){\n        double s=(side1+side2+side3)/2;\n        return sqrt(s*(s-side1)*(s-side2)*(s-side3));\n    }\n\n    double getPerimeter(){\n        return side1+side2+side3;\n    }\n\nprivate:\n    double side1;\n    double side2;\n    double side3;\n};",
            1591235591.248077,
            100,
            "# 答案正确"
        ],
        [
            "7.3 (C++)",
            "伍海珊",
            "template <typename E>\nvector<E> map2(const vector<E>& x,const vector<E>& y,E (*map2_func)(const E&,const E&)){\n    vector<E> res;\n\n    for(int i=0; i<x.size(); ++i)\n        res.push_back(map2_func(x[i],y[i]));\n\n    return res;\n}\n\ntemplate <typename E>\nvector<E> map2(const vector<E>& x,const E& y,E (*map2_func)(const E&,const E&)){\n    vector<E> res;\n\n    for(int i=0; i<x.size(); ++i)\n        res.push_back(map2_func(x[i],y));\n\n    return res;\n}",
            1591236533.781275,
            100,
            "# 答案正确"
        ],
        [
            "7.2 (C++)",
            "伍海珊",
            "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nvector<string> split(const string & line,const string & delimiter=\" \"){\n    vector<string> res;\n    int p=0;\n\n    while(p<line.size()){\n        int end=line.find(delimiter,p);\n\n        if(p==end){\n            p=end+delimiter.size();\n        }\n        else if(end==-1){\n            res.push_back(line.substr(p));\n        }\n        else{\n            res.push_back(line.substr(p,end-p));\n            p=end+delimiter.size();\n        }\n    }\n\n    return res;\n}\n",
            1591237727.0638657,
            100,
            "# 答案正确"
        ],
        [
            "8.1 (C++)",
            "伍海珊",
            "class Full:public Matrix\n{\npublic:\n    Full(int rows,int columns){\n        this->rows=rows;\n        this->columns=columns;\n        this->values=new double [rows*columns];\n\n        for(int i=0; i<rows*columns; ++i)\n            *(this->values+i)=0;\n    }\n\n    Full(int rows,int columns,double* values){\n        this->rows=rows;\n        this->columns=columns;\n        this->values=new double [rows*columns];\n\n        for(int i=0; i<rows*columns; ++i)\n            *(this->values+i)=*(values+i);\n    }\n\n    Full(const Matrix & matrix2){\n        this->rows=matrix2.size(1);\n        this->columns=matrix2.size(2);\n        this->values=new double [this->rows*this->columns];\n\n        for(int i=0; i<this->rows; ++i){\n            for(int j=0; j<this->columns; ++j){\n                *(this->values+i*this->columns+j)=matrix2.get(i,j);\n            }\n        }\n    }\n\n    ~Full(){\n        delete [] this->values;\n    }\n\n    int size(int dimension) const{\n        if(dimension==1)\n            return this->rows;\n        else if(dimension==2)\n            return this->columns;\n    }\n\n\tvoid set(int row, int column, double value){\n        *(this->values+row*this->columns+column)=value;\n    }\n\n\tdouble get(int row, int column) const{\n\t    return *(this->values+row*this->columns+column);\n\t}\n\n\tvoid print() const{\n\t    for(int i=0; i<this->rows; ++i){\n\n            for(int j=0; j<this->columns; ++j){\n                cout << \"    \" << *(this->values+i*this->columns+j);\n            }\n\n            cout << endl;\n\t    }\n\t}\n\n\tMatrix & operator = (const Matrix & matrix2){\n\t    this->rows=matrix2.size(1);\n        this->columns=matrix2.size(2);\n\n        delete [] this->values;\n        this->values=new double [this->rows*this->columns];\n\n        for(int i=0; i<this->rows; ++i){\n            for(int j=0; j<this->columns; ++j){\n                *(this->values+i*this->columns+j)=matrix2.get(i,j);\n            }\n        }\n\n        return *this;\n\t}\n\nprivate:\n    int rows;\n    int columns;\n    double* values;\n};\n",
            1591662358.2099226,
            100,
            "# 答案正确"
        ],
        [
            "8.3 (C++)",
            "伍海珊",
            "#include <vector>\n#include <iostream>\nusing namespace std;\n\nvoid swap(Entry* a,Entry* b){\n    Entry t=*a;\n    *a=*b;\n    *b=t;\n}\n\nclass Sparse:public Matrix\n{\npublic:\n    vector<Entry> values;\n\n    Sparse(int rows, int columns){\n        this->rows=rows;\n        this->columns=columns;\n    }\n\n    int size(int dimension) const{\n        if(dimension==1)\n            return this->rows;\n        else if(dimension==2)\n            return this->columns;\n    }\n\n\tvoid set(int row, int column, double value){\n        if(value==0) return;\n\n        Entry t;\n        t.row=row;\n        t.column=column;\n        t.value=value;\n        this->values.push_back(t);\n    }\n\n\tdouble get(int row, int column) const{\n\t    int len=this->values.size();\n\n\t    for(int i=0; i<len; ++i){\n            if(this->values[i].row==row&&this->values[i].column==column)\n                return this->values[i].value;\n\t    }\n\n\t    return 0;\n\t}\n\n\tvoid print(){\n\t    int len=this->values.size();\n\n\t    for(int i=0; i<len; ++i){\n            for(int j=i+1; j<len; ++j){\n                if(this->values[i].row>this->values[j].row)\n                    swap(&this->values[i],&this->values[j]);\n\n                else if(this->values[i].row==this->values[j].row){\n                    if(this->values[i].column>this->values[j].column)\n                        swap(&this->values[i],&this->values[j]);\n                }\n            }\n\t    }\n\n\t    for(int i=0; i<len; ++i)\n            cout << '(' << this->values[i].row << ',' << this->values[i].column\n                 << ',' << this->values[i].value << \")\\n\";\n\t}\n\n\tSparse operator + (Sparse & sparse2);\n\nprivate:\n    int rows;\n    int columns;\n};\n\nbool find(Sparse* myS,int x,int y,double val){\n    int len=myS->values.size();\n\n    for(int i=0; i<len; ++i){\n        if(x==myS->values[i].row&&y==myS->values[i].column){\n            myS->values[i].value+=val;\n            if(myS->values[i].value==0)\n                myS->values.erase(myS->values.begin()+i);\n\n            return 1;\n        }\n    }\n\n    return 0;\n}\n\nSparse Sparse::operator + (Sparse & sparse2){\n    Sparse t=*this;\n    int len2=sparse2.values.size();\n\n    for(int i=0; i<len2; ++i){\n        double val=sparse2.values[i].value;\n        if(!find(&t,sparse2.values[i].row,sparse2.values[i].column,val)){\n            t.values.push_back(sparse2.values[i]);\n        }\n    }\n\n    return t;\n}\n",
            1591681618.9261158,
            100,
            "# 答案正确"
        ],
        [
            "8.4 (C++)",
            "伍海珊",
            "#include <vector>\n#include <iostream>\nusing namespace std;\n\nvoid swap(Entry* a,Entry* b){\n    Entry t=*a;\n    *a=*b;\n    *b=t;\n}\n\nclass Sparse:public Matrix\n{\npublic:\n    vector<Entry> values;\n\n    Sparse(int rows, int columns){\n        this->rows=rows;\n        this->columns=columns;\n    }\n\n    int size(int dimension) const{\n        if(dimension==1)\n            return this->rows;\n        else if(dimension==2)\n            return this->columns;\n    }\n\n\tvoid set(int row, int column, double value){\n        if(value==0) return;\n\n        Entry t;\n        t.row=row;\n        t.column=column;\n        t.value=value;\n        this->values.push_back(t);\n    }\n\n\tdouble get(int row, int column) const{\n\t    int len=this->values.size();\n\n\t    for(int i=0; i<len; ++i){\n            if(this->values[i].row==row&&this->values[i].column==column)\n                return this->values[i].value;\n\t    }\n\n\t    return 0;\n\t}\n\n\tvoid print(){\n\t    int len=this->values.size();\n\n\t    for(int i=0; i<len; ++i){\n            for(int j=i+1; j<len; ++j){\n                if(this->values[i].row>this->values[j].row)\n                    swap(&this->values[i],&this->values[j]);\n\n                else if(this->values[i].row==this->values[j].row){\n                    if(this->values[i].column>this->values[j].column)\n                        swap(&this->values[i],&this->values[j]);\n                }\n            }\n\t    }\n\n\t    for(int i=0; i<len; ++i)\n            cout << '(' << this->values[i].row << ',' << this->values[i].column\n                 << ',' << this->values[i].value << \")\\n\";\n\t}\n\n\tSparse operator * (Sparse & sparse2);\n\nprivate:\n    int rows;\n    int columns;\n};\n\nbool find(Sparse* myS,int x,int y,double val){\n    int len=myS->values.size();\n\n    for(int i=0; i<len; ++i){\n        if(x==myS->values[i].row&&y==myS->values[i].column){\n            myS->values[i].value+=val;\n\n            if(myS->values[i].value==0)\n                myS->values.erase(myS->values.begin()+i);\n                \n            return 1;\n        }\n    }\n    \n    return 0;\n}\n\nSparse Sparse::operator * (Sparse & sparse2){\n    Sparse t(this->rows,sparse2.columns);\n\n    int len1=this->values.size();\n    int len2=sparse2.values.size();\n\n    for(int i=0; i<len1; ++i){\n        int x=this->values[i].row;\n        int y=this->values[i].column;\n\n        for(int j=0; j<len2; ++j){\n            Entry temp;\n            temp.row=x;\n            temp.value=0;\n            int flag=0;\n\n            if(sparse2.values[j].row==y){\n                temp.column=sparse2.values[j].column;\n                temp.value=this->values[i].value * sparse2.values[j].value;\n\n                if(!find(&t,temp.row,temp.column,temp.value))\n                    flag=1;\n            }\n\n            if(flag) t.values.push_back(temp);\n        }\n    }\n\n    return t;\n}",
            1591686455.5499487,
            100,
            "# 答案正确"
        ],
        [
            "8.5 (C++)",
            "伍海珊",
            "class Point3D:public Point2D\n{\nprivate:\n\tdouble z;\n\npublic:\n\tPoint3D() {\n\t\tsetX(0);\n\t\tsetY(0);\n\t\tz=0;\n\t}\n\n\tPoint3D(double a,double b,double c){\n\t    setX(a);\n\t    setY(b);\n\t    z=c;\n\n\t}\n\n\tdouble getZ(){\n\t    return z;\n\t}\n\n\tdouble distance(Point2D & point2) {\n\t    Point3D & p = dynamic_cast<Point3D&> (point2);\n\n\t\tdouble dx = getX() - p.getX();\n\t\tdouble dy = getY() - p.getY();\n\t\tdouble dz = z - p.z;\n\n\t\treturn sqrt(dx * dx + dy * dy + dz * dz);\n\t}\n\n};",
            1591845059.2883768,
            100,
            "# 答案正确"
        ],
        [
            "8.6 (C++)",
            "伍海珊",
            "#include<vector>\n#include<iostream>\nusing namespace std;\nclass MyTensor : public Tensor<double>\n{\nprivate:\n    vector<double> cap;\n\npublic:\n    MyTensor(vector<int> indexes) : Tensor(indexes)\n    {\n        int num = 1;\n        for (int i = 0; i < indexes.size(); i++)\n        {\n            num *= indexes[i];\n        }\n        cap.resize(num);\n    }\n    ~MyTensor(){};\n    double &get(const vector<int> &indexes)\n    {\n        int pos = 0;\n        for (int i = 0; i < indexes.size(); i++)\n        {\n            if (i == indexes.size() - 1)\n            {\n                pos += indexes[i];\n                break;\n            }\n            int temp = indexes[i];\n            for (int j = i + 1; j < indexes.size(); j++)\n            {\n                temp *= sizes[j];\n            }\n            pos += temp;\n        }\n        return cap[pos];\n    }\n};",
            1592450114.8660567,
            100,
            "# 答案正确"
        ],
        [
            "9.1 (C++)",
            "伍海珊",
            "#include <iostream>\nusing namespace std;\n\nclass Circle{\npublic:\n    Circle(double r):radius(r){};\n    ~Circle(){};\n\n    bool operator < (Circle& circle2){\n        if(this->radius < circle2.radius)\n            return true;\n        else return false;\n    }\n\n    bool operator <= (Circle& circle2){\n        if(this->radius <= circle2.radius)\n            return true;\n        else return false;\n    }\n\n    bool operator == (Circle& circle2){\n        if(this->radius == circle2.radius)\n            return true;\n        else return false;\n    }\n\n    bool operator != (Circle& circle2){\n        if(this->radius != circle2.radius)\n            return true;\n        else return false;\n    }\n\n    bool operator > (Circle& circle2){\n        if(this->radius > circle2.radius)\n            return true;\n        else return false;\n    }\n\n    bool operator >= (Circle& circle2){\n        if(this->radius >= circle2.radius)\n            return true;\n        else return false;\n    }\n\nprivate:\n    double radius;\n};",
            1593053634.3907194,
            100,
            "# 答案正确"
        ],
        [
            "9.2 (C++)",
            "伍海珊",
            "class I : public vector<int>\n{\npublic:\n    I(int x,int y=-1,int z=-1,int q=-1){\n        this->resize(0);\n        this->push_back(x);\n        if(y!=-1) this->push_back(y);\n        if(z!=-1) this->push_back(z);\n        if(q!=-1) this->push_back(q);\n    }\n};\n",
            1593055581.561178,
            100,
            "# 答案正确"
        ],
        [
            "9.3 (C++)",
            "伍海珊",
            "class Complex{\npublic:\n    Complex(double real,double imag):r(real),i(imag){}\n    Complex(double real):r(real),i(0){}\n    double real() const {return this->r;}\n    double imag() const {return this->i;}\n\n    Complex& operator+=(const Complex& y){\n        this->r += y.r;\n        this->i += y.i;\n        return *this;\n    }\n    Complex& operator-=(const Complex& y){\n        this->r -= y.r;\n        this->i -= y.i;\n        return *this;\n    }\n    Complex& operator*=(const Complex& y){\n        double a = this->r;\n        double b = this->i;\n        this->r = a * y.r - b * y.i;\n        this->i = a * y.i + b * y.r;\n        return *this;\n    }\n    Complex& operator/=(const Complex& y){\n        Complex temp(y.real(),-y.imag());\n        (*this) *= temp;\n        this->r /= (pow(y.imag(),2)+pow(y.real(),2));\n        this->i /= (pow(y.imag(),2)+pow(y.real(),2));\n        return *this;\n    }\n\n    bool operator==(const Complex& y){\n        if(this->r==y.r && this->i==y.i)\n            return true;\n        else return false;\n    }\n    bool operator!=(const Complex& y){return !(*this==y);}\n\nprivate:\n    double r;\n    double i;\n};\n\nComplex operator + (const Complex& x,const Complex& y){\n    Complex res(x.real() + y.real(), x.imag() + y.imag());\n    return res;\n}\n\nComplex operator - (const Complex& x,const Complex& y){\n    Complex res(x.real() - y.real(), x.imag() - y.imag());\n    return res;\n}\n\nComplex operator * (const Complex& x,const Complex& y){\n    Complex res(x.real()*y.real()-x.imag()*y.imag(), x.real()*y.imag()+x.imag()*y.real());\n    return res;\n}\n\nComplex operator / (const Complex& x,const Complex& y){\n    Complex temp(y.real(),-y.imag());\n    Complex res = x * temp;\n    Complex t(res.real()/(pow(y.imag(),2)+pow(y.real(),2)),res.imag()/(pow(y.imag(),2)+pow(y.real(),2)));\n    return t;\n}",
            1593062006.8047256,
            100,
            "# 答案正确"
        ],
        [
            "9.4 (C++)",
            "伍海珊",
            "class Complex{\npublic:\n    Complex():r(0),i(0){}\n    Complex(double real,double imag):r(real),i(imag){}\n    Complex(double real):r(real),i(0){}\n    double& real(){return this->r;}\n    double& imag(){return this->i;}\n    const double& real() const {return this->r;}\n    const double& imag() const {return this->i;}\n\nprivate:\n    double r;\n    double i;\n};\n\nostream& operator << (ostream& out,Complex& c){\n    out << c.real() << \" + \" << c.imag() << \" i\";\n    return out;\n}\n\nistream& operator >> (istream& in,Complex& c){\n    in >> c.real() >> c.imag();\n    return in;\n}\n\nComplex operator + (const Complex& x,const Complex& y){\n    Complex res(x.real() + y.real(), x.imag() + y.imag());\n    return res;\n}\n\nComplex operator - (const Complex& x,const Complex& y){\n    Complex res(x.real() - y.real(), x.imag() - y.imag());\n    return res;\n}\n",
            1593064594.5140975,
            100,
            "# 答案正确"
        ],
        [
            "9.5 (C++)",
            "伍海珊",
            "class Complex{\npublic:\n    Complex():r(0),i(0){}\n    Complex(double real,double imag):r(real),i(imag){}\n    Complex(double real):r(real),i(0){}\n\n    double& real(){return this->r;}\n    double& imag(){return this->i;}\n    const double& real() const {return this->r;}\n    const double& imag() const {return this->i;}\n\n    operator double(){return this->real();}\n\n    Complex& operator++(){\n        this->r+=1;\n        return *this;\n    }\n\n    Complex operator++(int){\n        Complex t(*this);\n        this->r+=1;\n        return t;\n    }\n\nprivate:\n    double r;\n    double i;\n};\n\nostream& operator << (ostream& out,const Complex& c){\n    out << c.real() << \" + \" << c.imag() << \" i\";\n    return out;\n}\n\nistream& operator >> (istream& in,Complex& c){\n    in >> c.real() >> c.imag();\n    return in;\n}",
            1593065007.7633767,
            100,
            "# 答案正确"
        ],
        [
            "9.6 (C++)",
            "伍海珊",
            "class Tensor{\npublic:\n    Tensor(int a,int b=-1,int c=-1,int d=-1){\n        sizes.clear();\n        data.clear();\n\n        sizes.push_back(a);\n        if(b!=-1) sizes.push_back(b);\n        if(c!=-1) sizes.push_back(c);\n        if(d!=-1) sizes.push_back(d);\n\n        int numel=1;\n        for(int i=0; i<sizes.size(); ++i)\n            numel*=sizes[i];\n\n        for(int i=0; i<numel; ++i)\n            data.push_back(0);\n    }\n\n    double& operator()(int a,int b=-1,int c=-1,int d=-1){\n        vector<int> pos;\n        pos.push_back(a);\n        if(b!=-1) pos.push_back(b);\n        if(c!=-1) pos.push_back(c);\n        if(d!=-1) pos.push_back(d);\n\n        int index=0;\n        for(int i=0; i<sizes.size(); ++i){\n            index*=sizes[i];\n            index+=pos[i];\n        }\n\n        return data[index];\n    }\n\n    const double& operator()(int a,int b=-1,int c=-1,int d=-1) const{\n        vector<int> pos;\n        pos.push_back(a);\n        if(b!=-1) pos.push_back(b);\n        if(c!=-1) pos.push_back(c);\n        if(d!=-1) pos.push_back(d);\n\n        int index=0;\n        for(int i=0; i<sizes.size(); ++i){\n            index*=sizes[i];\n            index+=pos[i];\n        }\n\n        return data[index];\n    }\n\nprivate:\n    vector<int> sizes;\n    vector<double> data;\n};\n",
            1593082200.3653069,
            100,
            "# 答案正确"
        ],
        [
            "9.7 (C++)",
            "伍海珊",
            "#include<iostream>\n#include<vector>\n#include<iomanip>\nusing namespace std;\n\nclass Tensor {\n\n\tvector<double>values;\n\n\tint total;\npublic:\n\tvector<int>sizes;\n\tint dimension;\n\tTensor() :dimension(0) {};\n\tTensor(vector<int>_sizes) {\n\t\tdimension = _sizes.size();\n\t\ttotal = 1;\n\t\tfor (int i = 0; i < dimension; ++i) {\n\t\t\tsizes.push_back(_sizes[i]);\n\t\t\ttotal *= _sizes[i];\n\t\t}\n\t\tfor (int i = 0; i < total; ++i) values.push_back(0);\n\t};\n\tdouble& operator()(int a = -1, int b = -1, int c = -1, int d = -1) {\n\t\tvector<int>temp;\n\t\tif (a != -1) temp.push_back(a);\n\t\tif (b != -1) temp.push_back(b);\n\t\tif (c != -1) temp.push_back(c);\n\t\tif (d != -1) temp.push_back(d);\n\t\treturn values[_index(temp)];\n\t}\n\tconst double& operator()(int a = -1, int b = -1, int c = -1, int d = -1)const {\n\t\tvector<int>temp;\n\t\tif (a != -1) temp.push_back(a);\n\t\tif (b != -1) temp.push_back(b);\n\t\tif (c != -1) temp.push_back(c);\n\t\tif (d != -1) temp.push_back(d);\n\t\treturn values[_index(temp)];\n\t}\n\tint _index(const vector<int>& indexes) const {\n\t\tint index = 0;\n\t\tfor (int i = 0; i < indexes.size(); ++i) {\n\t\t\tint temp = indexes[i];\n\t\t\tfor (int j = i + 1; j < sizes.size(); ++j) temp *= sizes[j];\n\t\t\tindex += temp;\n\t\t}\n\t\treturn index;\n\t}\n\tint get_total() {\n\t\treturn total;\n\t}\n\tTensor& operator=(const vector<double>& val) {\n\t\tfor (int i = 0; i < val.size(); ++i) values[i] = val[i];\n\t\treturn *this;\n\t}\n};\n\nistream& operator>>(istream& in, Tensor& c) {\n\tint dimension;\n\tin >> dimension;\n\tvector<int>sizes;\n\tint p;\n\tfor (int i = 0; i < dimension; ++i) {\n\t\tin >> p;\n\t\tsizes.push_back(p);\n\t}\n\tTensor T(sizes);\n\tvector<double>val;\n\tdouble temp;\n\tfor (int i = 0; i < T.get_total(); ++i) {\n\t\tin >> temp;\n\t\tval.push_back(temp);\n\t}\n\tT = val;\n\tc = T;\n\treturn in;\n}\nostream& operator<<(ostream& out, const Tensor& c) {\n\tout << c.dimension << endl;\n\tfor (int i = 0; i < c.sizes.size(); ++i) out << c.sizes[i] << \" \";\n\tout << endl<<endl;\n\tif (c.dimension == 3) {\n\t\tfor (int i = 0; i < c.sizes[0]; ++i) {\n\t\t\tfor (int j = 0; j < c.sizes[1]; ++j) {\n\t\t\t\tfor (int k = 0; k < c.sizes[2]; ++k) {\n\t\t\t\t\tout  << c(i, j, k) << \" \";\n\t\t\t\t}\n\t\t\t\tout << endl;\n\t\t\t}\n\t\t\tout << endl;\n\t\t}\n\t}\n\tif (c.dimension == 4) {\n\t\tint flag=true;\n\t\tfor (int i = 0; i < c.sizes[0]; ++i) {\n\t\t\tfor (int j = 0; j < c.sizes[1]; ++j) {\n\t\t\t\tfor (int k = 0; k < c.sizes[2]; ++k) {\n\t\t\t\t\tfor (int p = 0; p < c.sizes[3]; ++p) {\n\t\t\t\t\t\tout << c(i, j, k, p) << \" \";\n\t\t\t\t\t}\n\t\t\t\t\tout<<endl;\t\n\t\t\t\t}\n\t\t\t\tout << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn out;\n}",
            1593086042.0225983,
            100,
            "# 答案正确"
        ],
        [
            "10.2 (C++)",
            "伍海珊",
            "\t\tcatch(NonPositiveValueException& ex){\n            cout << \"caught: NonPositiveValueException\" << endl;\n        }\n        catch(out_of_range& ex){\n            cout << \"caught: out_of_range\" << endl;\n        }",
            1593659271.8240118,
            100,
            "# 答案正确"
        ],
        [
            "10.1 (C++)",
            "伍海珊",
            "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass MatrixSizesDoNotMatchException{};\n\ndouble Matrix:: get(int row, int column) const\n{\n\tif(row>this->size(1)||column>this->size(2)) throw out_of_range(\"\");\n\trow--;\n\tcolumn--;\n\treturn this->elements[row*this->columns+column];\n}\n\t\nvoid Matrix:: set(int row, int column, double value)\n{\n\tif(row>this->rows||column>this->columns) throw out_of_range(\"\");\n\t--row;\n\t--column;\n\tthis->elements[row*this->columns+column] = value;\n\treturn;\n}\n\t\nMatrix Matrix:: operator+(const Matrix&matrix2)const{\n\tif(this->rows!=matrix2.rows||this->columns!=matrix2.columns)throw MatrixSizesDoNotMatchException();\n\tMatrix ans(this->rows,this->columns);\n\tvector<double> eles;\n\tfor (int i = 0; i < this->rows*this->columns; ++ i) \n\t\teles.push_back(this->elements[i] + matrix2.elements[i]);\n\tfor(int i=1;i<=this->size(1);++i){\n\t\tfor(int j=1;j<=this->size(2);++j){\n\t\t\tans.set(i,j,eles[(i-1)*this->columns+j-1]);\n\t\t}\n\t}\n\treturn ans;\n} \n",
            1593687866.7944562,
            100,
            "# 答案正确"
        ],
        [
            "15.1 (C++)",
            "伍海珊",
            "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nclass Table{\npublic:\n    vector<string> header;\n    vector< vector<string> > data;\n\n    void addCol(string h){this->header.push_back(h);}\n    vector<string> & operator[](int i);\n\n    const char json() const {\n        cout << \"{\\n\" << \"  headers: [\";\n\n        for(int i=0; i<this->header.size(); ++i){\n            cout << \"'\" << this->header[i] << \"',\";\n        }\n\n        cout << \"],\\n\" << \"   rows: [\\n\";\n\n        for(int i=0; i<this->data.size(); ++i){\n            cout << \"       [\";\n\n            for(int j=0; j<this->data[i].size(); ++j){\n                cout << \"'\" << this->data[i][j] << \"',\";\n            }\n\n            cout << \"],\\n\";\n        }\n\n        cout << \"   ],\\n\" << '}';\n        return '\\n';\n    }\n\n};\n\nvector<string> & Table::operator[](int i){\n    if(i==this->data.size()){\n        this->data.resize(i+1);\n        return this->data[i];\n    }\n}",
            1594176721.2102144,
            100,
            "# 答案正确"
        ],
        [
            "2020-07-09 LAB",
            "伍海珊",
            "#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Integer{\npublic:\n    static int add;\n    int a;\n    Integer(){\n        a = 0;\n    }\n    Integer(int s) {\n        a = s;\n    }\n    static void increase_all(int n) {\n        add = n;\n    }\n    static void increase_all(Integer n) {\n        add = n.a;\n    }\n    \n};\nint Integer::add = 0;\n\nistream & operator >> (istream & in, Integer & s) {\n    in >> s.a;\n    return in;\n}\nostream & operator << (ostream & out, Integer & s) {\n    s.a += Integer::add;\n    out << s.a;\n    return out;\n}",
            1594264245.240101,
            100,
            "# 答案正确"
        ],
        [
            "A.2 (C++)",
            "伍海珊",
            "template <typename E>\nvoid LinkedList<E>::removeAll(const E& e){\n    int index=indexOf(e);\n\n    while(index!=-1){\n        this->remove(index);\n        index=indexOf(e);\n    }\n}",
            1594867131.6744576,
            100,
            "# 答案正确"
        ],
        [
            "A.1 (C++)",
            "伍海珊",
            "\tNode<E>* _get(int index) const {\n        if(index<0 || index>=_size)\n            throw NotSuchElementException();    \n\n        if(index<_size/2){\n            Node<E>* pre=0;\n            Node<E>* node=head;\n\n            I(i,index){\n                Node<E>* temp=node;\n                node=node->next_node(pre);\n                pre=temp;\n            }\n\n            return node;\n        }\n        else{\n            Node<E>* next=0;\n            Node<E>* node=tail;\n\n            I(i,(_size-1-index)){\n                Node<E>* temp=node;\n                node=node->prev_node(next);\n                next=temp;\n            }\n\n            return node;\n        }\n\t}\n\n\tvoid addFirst(const E& val){\n        Node<E>* p=new Node<E>();\n        p->element=val;\n        p->update_prev_and_next_node(0,this->head);\n\n        if(head!=0) head->update_prev_node(0,p);\n        head=p;\n        if(tail==0) tail=p;\n\n        ++_size;\n    }\n\n    void addLast(const E& val){\n        Node<E>* p=new Node<E>();\n        p->element=val;\n        p->update_prev_and_next_node(tail,0);\n\n        if(tail!=0) tail->update_next_node(0,p);\n        tail=p;\n        if(head==0) head=p;\n\n        ++_size;\n    }\n    \n    void remove(int index){\n        Node<E>* node=_get(index);\n        Node<E>* p;\n        if(index==_size-1) p=0;\n        else p=_get(index+1);\n        \n        Node<E>* pre=node->prev_node(p);\n        Node<E>* next=node->next_node(pre);\n        \n        if(pre!=0) pre->update_next_node(node,next);\n        if(next!=0) next->update_prev_node(node,pre);\n        \n        if(pre==0) head=next;\n        if(next==0) tail=pre;\n        \n        delete node;\n        --_size;\n    }\n    \n    void removeFirst(){\n        if(head==0)\n            throw NotSuchElementException();\n\n        remove(0);\n    }\n\n    void removeLast(){\n        if(tail==0)\n            throw NotSuchElementException();\n\n        remove(_size-1);\n    }\n    \n   int indexOf(const E& e) const {\n        Node<E>* pre=0;\n\t\tNode<E>* node = head;\n\t\tI(i, _size) {\n\t\t\tif (node->element == e) return i;\n\t\t\tNode<E>* temp=node;\n            node=node->next_node(pre);\n            pre=temp;\n\t\t}\n\t\treturn -1;\n\t}\n\n\n    void removeFirstOccurrence(const E& val){\n        int index=indexOf(val);\n        if(index==-1)\n            throw NotSuchElementException();\n        \n        remove(index);\n    }\n\n    E& get(int index) const{\n\t\tNode<E>* node=_get(index);\n\t\treturn node->element;\n\t}",
            1594904312.7581704,
            100,
            "# 答案正确"
        ],
        [
            "A.3 (C++)",
            "伍海珊",
            "#include <vector>\nusing namespace std;\n\ntemplate <typename E>\nclass Tuple{\npublic:\n int key;\n E val;\n bool in_use;\n\t\n Tuple(){in_use = false;}\n};\n\ntemplate <typename E>\nclass HT{\nprivate:\n vector<Tuple<E>> tuples;\n int _size;\n\npublic:\n HT(){\n  tuples.resize(4000);\n  _size = 0;\n }\n\t\n int hashfunction(int key){\n  int hashcode = 0;\n  while (key){\n   hashcode = (hashcode << 5) + (key % 10);\n   key /= 10;\n  }\n  return hashcode % tuples.size();\n }\n\t\n int indexofkey(int key){\n  int index = hashfunction(key);\n  while (true){\n   if (tuples[index].in_use == false)\n    return index;\n   if (tuples[index].key == key)\n    return index;\n   index = (index + 1) % tuples.size();\n  }\n }\n\t\n void put(int key, E val){\n  int index = indexofkey(key);\n  tuples[index].val = val;\n  tuples[index].key = key;\n  if (tuples[index].in_use == false){\n   tuples[index].in_use = true;\n   _size++;\n  }\n }\n\t\n int size(){return _size;}\n\t\n bool containsKey(int key){\n  int index = indexofkey(key);\n  return tuples[index].in_use == true;\n }\n\t\n E operator[](int key){\n  int index = indexofkey(key);\n  return tuples[index].val;\n }\n\t\n vector<int> getKeys(){\n  vector<int> ans;\n  for (int i = 0; i < tuples.size(); i++){\n   if (tuples[i].in_use){\n    ans.push_back(tuples[i].key);\n   }\n\t  \n  }\n  return ans;\n }\n\t\n void remove(int key){\n  int index = indexofkey(key);\n  tuples[index].in_use = false;\n  _size--;\n }\n};",
            1595474091.2221541,
            100,
            "# 答案正确"
        ],
        [
            "A.4 (C++)",
            "伍海珊",
            "#include <vector>\n#include <string>\n#include <cstdlib>\n#include <iostream>\n#include <sstream>\nusing namespace std;\n\n#define I(i,n) for (size_t i = 0; i < n; ++ i)\n\nclass NoSuchKeyException{};\n\nclass HT{\n\n    class Tuple{\n\tpublic:\n\t\tstring key;\n\t\tint val;\n\t\tbool in_use;\n\n\t\toperator string() const{\n\t\t    char a[100];\n            const char* p=itoa(val,a,10);\n            return p;\n\t\t}\n\t};\n\n    vector<Tuple> tuples;\n    size_t _size;\n\n    size_t hash_function(const string& key) const{\n        istringstream is(key);\n        size_t i;\n        is >> i;\n        return i;\n    }\n\n    size_t canonical_index(const string& key) const {\n\t\tsize_t hash_code = hash_function(key); // needs hash_function(K)\n\t\treturn hash_code % tuples.size();\n\t}\n\n\tsize_t indexOfKey(const string& key) const {\n\t\tsize_t index = canonical_index(key);\n\t\twhile (true) {\n\t\t\tif (! tuples[index].in_use) return index;\n\t\t\tif (tuples[index].key == key) return index;\n\t\t\tindex = (index + 1) % tuples.size();\n\t\t}\n\t}\n\npublic:\n    HT() : _size(0) {\n\t\ttuples.resize(2);\n\t}\n\n    size_t size(){return _size;}\n\n    bool containsKey(const string& key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\treturn tuples[index].in_use;\n\t}\n\n\tconst int & operator [] (const string& key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use)\n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples[index].val;\n\t}\n\n\tint & operator [] (const string& key) {\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use)\n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples[index].val;\n\t}\n\n\tconst int & operator [] (const int& key) const {\n\t    stringstream ss;\n        ss << key;\n        string s = ss.str();\n\n\t\tsize_t index = indexOfKey(s);\n\t\tif (! tuples[index].in_use)\n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples[index].val;\n\t}\n\n\tint & operator [] (const int& key) {\n\t    stringstream ss;\n        ss << key;\n        string s = ss.str();\n\n\t\tsize_t index = indexOfKey(s);\n\t\tif (! tuples[index].in_use)\n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples[index].val;\n\t}\n\n    void put(const string& key, const int& value){\n        size_t index=indexOfKey(key);\n        tuples[index].key=key;\n        tuples[index].val=value;\n\n        if(tuples[index].in_use) return;\n        tuples[index].in_use=true;\n        ++_size;\n\n        if (2 * _size > tuples.size())\n\t\t\t_double_tuples();\n    }\n\n    void put(const int& key, const int& value){\n        stringstream ss;\n        ss << key;\n        string s = ss.str();\n\n        size_t index=indexOfKey(s);\n        tuples[index].key=key;\n        tuples[index].val=value;\n\n        if(tuples[index].in_use) return;\n        tuples[index].in_use=true;\n        ++_size;\n\n        if (2 * _size > tuples.size())\n\t\t\t_double_tuples();\n    }\n\n    void put(const int& key, const string& value){\n        stringstream ss;\n        ss << key;\n        string s = ss.str();\n\n        istringstream is(value);\n        size_t i;\n        is >> i;\n\n        size_t index=indexOfKey(s);\n        tuples[index].key=key;\n        tuples[index].val=i;\n\n        if(tuples[index].in_use) return;\n        tuples[index].in_use=true;\n        ++_size;\n\n        if (2 * _size > tuples.size())\n\t\t\t_double_tuples();\n    }\n\n    void put(const string& key, const string& value){\n        istringstream is(value);\n        size_t i;\n        is >> i;\n\n        size_t index=indexOfKey(key);\n        tuples[index].key=key;\n        tuples[index].val=i;\n\n        if(tuples[index].in_use) return;\n        tuples[index].in_use=true;\n        ++_size;\n\n        if (2 * _size > tuples.size())\n\t\t\t_double_tuples();\n    }\n\n    void _double_tuples() {\n\t\tvector<Tuple> non_empty_tuples;\n\t\tI(i, tuples.size())\n\t\t\tif (tuples[i].in_use)\n\t\t\t\tnon_empty_tuples.push_back(tuples[i]);\n\t\tclear();\n\t\ttuples.resize(tuples.size() * 2);\n\t\tI(i, non_empty_tuples.size())\n\t\t\tput(non_empty_tuples[i].key, non_empty_tuples[i].val);\n\t}\n\n\tvoid clear() {\n\t\tI(i, tuples.size())\n\t\t\ttuples[i].in_use = false;\n\t\t_size = 0;\n\t}\n\n};",
            1595854706.4910808,
            0,
            "In file included from main.cpp:1:0:\nsource.cpp:22:1: error: stray ‘\\302’ in program\n             const char* p=itoa(val,a,10);\n ^\nsource.cpp:22:1: error: stray ‘\\240’ in program\nsource.cpp:22:1: error: stray ‘\\302’ in program\nsource.cpp:22:1: error: stray ‘\\240’ in program\nsource.cpp:22:1: error: stray ‘\\302’ in program\nsource.cpp:22:1: error: stray ‘\\240’ in program\nsource.cpp:22:1: error: stray ‘\\302’ in program\nsource.cpp:22:1: error: stray ‘\\240’ in program\nsource.cpp: In member function ‘HT::Tuple::operator std::__cxx11::string() const’:\nsource.cpp:22:44: error: ‘itoa’ was not declared in this scope\n             const char* p=itoa(val,a,10);\n                                            ^\nmain.cpp: In function ‘int main()’:\nmain.cpp:32:26: error: no matching function for call to ‘std::__cxx11::basic_string<char>::basic_string(int&)’\n  cout << (string)map[key2] << endl;\n                          ^\nIn file included from /usr/include/c++/5/string:52:0,\n                 from source.cpp:2,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/basic_string.h:534:9: note: candidate: template<class _InputIterator, class> std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(_InputIterator, _InputIterator, const _Alloc&)\n         basic_string(_InputIterator __beg, _InputIterator __end,\n         ^\n/usr/include/c++/5/bits/basic_string.h:534:9: note:   template argument deduction/substitution failed:\nmain.cpp:32:26: note:   candidate expects 3 arguments, 1 provided\n  cout << (string)map[key2] << endl;\n                          ^\nIn file included from /usr/include/c++/5/string:52:0,\n                 from source.cpp:2,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/basic_string.h:511:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&&, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\n       basic_string(basic_string&& __str, const _Alloc& __a)\n       ^\n/usr/include/c++/5/bits/basic_string.h:511:7: note:   candidate expects 2 arguments, 1 provided\n/usr/include/c++/5/bits/basic_string.h:507:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\n       basic_string(const basic_string& __str, const _Alloc& __a)\n       ^\n/usr/include/c++/5/bits/basic_string.h:507:7: note:   candidate expects 2 arguments, 1 provided\n/usr/include/c++/5/bits/basic_string.h:503:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(std::initializer_list<_Tp>, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\n       basic_string(initializer_list<_CharT> __l, const _Alloc& __a = _Alloc())\n       ^\n/usr/include/c++/5/bits/basic_string.h:503:7: note:   no known conversion for argument 1 from ‘int’ to ‘std::initializer_list<char>’\n/usr/include/c++/5/bits/basic_string.h:476:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\n       basic_string(basic_string&& __str) noexcept\n       ^\n/usr/include/c++/5/bits/basic_string.h:476:7: note:   no known conversion for argument 1 from ‘int’ to ‘std::__cxx11::basic_string<char>&&’\n/usr/include/c++/5/bits/basic_string.h:464:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, _CharT, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int]\n       basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc())\n       ^\n/usr/include/c++/5/bits/basic_string.h:464:7: note:   candidate expects 3 arguments, 1 provided\n/usr/include/c++/5/bits/basic_string.h:454:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const _CharT*, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>] <near match>\n       basic_string(const _CharT* __s, const _Alloc& __a = _Alloc())\n       ^\n/usr/include/c++/5/bits/basic_string.h:454:7: note:   conversion of argument 1 would be ill-formed:\nmain.cpp:32:26: error: invalid conversion from ‘int’ to ‘const char*’ [-fpermissive]\n  cout << (string)map[key2] << endl;\n                          ^\nIn file included from /usr/include/c++/5/string:52:0,\n                 from source.cpp:2,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/basic_string.h:444:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const _CharT*, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int]\n       basic_string(const _CharT* __s, size_type __n,\n       ^\n/usr/include/c++/5/bits/basic_string.h:444:7: note:   candidate expects 3 arguments, 1 provided\n/usr/include/c++/5/bits/basic_string.h:426:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int]\n       basic_string(const basic_string& __str, size_type __pos,\n       ^\n/usr/include/c++/5/bits/basic_string.h:426:7: note:   candidate expects 4 arguments, 1 provided\n/usr/include/c++/5/bits/basic_string.h:410:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int]\n       basic_string(const basic_string& __str, size_type __pos,\n       ^\n/usr/include/c++/5/bits/basic_string.h:410:7: note:   candidate expects 3 arguments, 1 provided\n/usr/include/c++/5/bits/basic_string.h:398:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\n       basic_string(const basic_string& __str)\n       ^\n/usr/include/c++/5/bits/basic_string.h:398:7: note:   no known conversion for argument 1 from ‘int’ to ‘const std::__cxx11::basic_string<char>&’\n/usr/include/c++/5/bits/basic_string.h:390:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\n       basic_string(const _Alloc& __a)\n       ^\n/usr/include/c++/5/bits/basic_string.h:390:7: note:   no known conversion for argument 1 from ‘int’ to ‘const std::allocator<char>&’\n/usr/include/c++/5/bits/basic_string.h:379:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string() [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\n       basic_string()\n       ^\n/usr/include/c++/5/bits/basic_string.h:379:7: note:   candidate expects 0 arguments, 1 provided\nmain.cpp:33:26: error: no matching function for call to ‘std::__cxx11::basic_string<char>::basic_string(int&)’\n  cout << (string)map[key3] << endl;\n                          ^\nIn file included from /usr/include/c++/5/string:52:0,\n                 from source.cpp:2,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/basic_string.h:534:9: note: candidate: template<class _InputIterator, class> std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(_InputIterator, _InputIterator, const _Alloc&)\n         basic_string(_InputIterator __beg, _InputIterator __end,\n         ^\n/usr/include/c++/5/bits/basic_string.h:534:9: note:   template argument deduction/substitution failed:\nmain.cpp:33:26: note:   candidate expects 3 arguments, 1 provided\n  cout << (string)map[key3] << endl;\n                          ^\nIn file included from /usr/include/c++/5/string:52:0,\n                 from source.cpp:2,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/basic_string.h:511:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&&, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\n       basic_string(basic_string&& __str, const _Alloc& __a)\n       ^\n/usr/include/c++/5/bits/basic_string.h:511:7: note:   candidate expects 2 arguments, 1 provided\n/usr/include/c++/5/bits/basic_string.h:507:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\n       basic_string(const basic_string& __str, const _Alloc& __a)\n       ^\n/usr/include/c++/5/bits/basic_string.h:507:7: note:   candidate expects 2 arguments, 1 provided\n/usr/include/c++/5/bits/basic_string.h:503:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(std::initializer_list<_Tp>, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\n       basic_string(initializer_list<_CharT> __l, const _Alloc& __a = _Alloc())\n       ^\n/usr/include/c++/5/bits/basic_string.h:503:7: note:   no known conversion for argument 1 from ‘int’ to ‘std::initializer_list<char>’\n/usr/include/c++/5/bits/basic_string.h:476:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\n       basic_string(basic_string&& __str) noexcept\n       ^\n/usr/include/c++/5/bits/basic_string.h:476:7: note:   no known conversion for argument 1 from ‘int’ to ‘std::__cxx11::basic_string<char>&&’\n/usr/include/c++/5/bits/basic_string.h:464:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, _CharT, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int]\n       basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc())\n       ^\n/usr/include/c++/5/bits/basic_string.h:464:7: note:   candidate expects 3 arguments, 1 provided\n/usr/include/c++/5/bits/basic_string.h:454:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const _CharT*, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>] <near match>\n       basic_string(const _CharT* __s, const _Alloc& __a = _Alloc())\n       ^\n/usr/include/c++/5/bits/basic_string.h:454:7: note:   conversion of argument 1 would be ill-formed:\nmain.cpp:33:26: error: invalid conversion from ‘int’ to ‘const char*’ [-fpermissive]\n  cout << (string)map[key3] << endl;\n                          ^\nIn file included from /usr/include/c++/5/string:52:0,\n                 from source.cpp:2,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/basic_string.h:444:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const _CharT*, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int]\n       basic_string(const _CharT* __s, size_type __n,\n       ^\n/usr/include/c++/5/bits/basic_string.h:444:7: note:   candidate expects 3 arguments, 1 provided\n/usr/include/c++/5/bits/basic_string.h:426:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int]\n       basic_string(const basic_string& __str, size_type __pos,\n       ^\n/usr/include/c++/5/bits/basic_string.h:426:7: note:   candidate expects 4 arguments, 1 provided\n/usr/include/c++/5/bits/basic_string.h:410:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int]\n       basic_string(const basic_string& __str, size_type __pos,\n       ^\n/usr/include/c++/5/bits/basic_string.h:410:7: note:   candidate expects 3 arguments, 1 provided\n/usr/include/c++/5/bits/basic_string.h:398:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\n       basic_string(const basic_string& __str)\n       ^\n/usr/include/c++/5/bits/basic_string.h:398:7: note:   no known conversion for argument 1 from ‘int’ to ‘const std::__cxx11::basic_string<char>&’\n/usr/include/c++/5/bits/basic_string.h:390:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\n       basic_string(const _Alloc& __a)\n       ^\n/usr/include/c++/5/bits/basic_string.h:390:7: note:   no known conversion for argument 1 from ‘int’ to ‘const std::allocator<char>&’\n/usr/include/c++/5/bits/basic_string.h:379:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string() [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\n       basic_string()\n       ^\n/usr/include/c++/5/bits/basic_string.h:379:7: note:   candidate expects 0 arguments, 1 provided\n"
        ],
        [
            "A.5 (C++)",
            "伍海珊",
            "#include <iostream>\n#include <sstream>\n#include<vector>\n#include<map> \n#include<algorithm>\nusing namespace std;\n\nint total = 0;\n\nclass V {\npublic:\n\tstring s;\n\tint i;\n\tV(int _i) :i(_i) {\n\t}\n\tV(string _s) :s(_s) {\n\t}\n\toperator string() {\n\t\treturn s;\n\t}\n\toperator int() {\n\t\treturn i;\n\t}\n\tV& operator=(int val){\n\t\t\ti=val;\n\t\t\treturn *this;\n\t}\n\tV& operator=(string val){\n\t\ts=val;\n\t\treturn *this;\n\t}\n};\n\nclass HT {\n\tclass Tuple1 {\n\tpublic:\n\t\tint key;\n\t\tV value;\n\t\tTuple1(int _key, int _value) :key(_key), value(_value) { total++; };\n\t\tTuple1(int _key, string _value) :key(_key), value(_value) { total++; };\n\t};\n\tclass Tuple2 {\n\tpublic:\n\t\tstring key;\n\t\tV value;\n\t\tTuple2(string _key, string _value) :key(_key), value(_value) { total++; };\n\t\tTuple2(string _key, int _value) :key(_key), value(_value) { total++; };\n\t\tvoid operator=(int val){\n\t\t\tvalue=val;\n\t\t}\n\t\tvoid operator=(string val){\n\t\t\tvalue=val;\n\t\t}\n\t};\n\tvector<Tuple1>t1;\n\tvector<Tuple2>t2;\n\npublic:\n\tint size() { return total; }\n\tvoid put(int _key, int _value) {\n\t\tt1.push_back(Tuple1(_key, _value));\n\t}\n\tvoid put(int _key, string _value) {\n\t\tt1.push_back(Tuple1(_key, _value));\n\t}\n\tvoid put(string _key, int _value) {\n\t\tt2.push_back(Tuple2(_key, _value));\n\t}\n\tvoid put(string _key, string _value) {\n\t\tt2.push_back(Tuple2(_key, _value));\n\t}\n\tV& operator [] (const int& key) {\n\t\tfor (int i = 0; i < t1.size(); ++i) {\n\t\t\tif (t1[i].key == key) return t1[i].value;\n\t\t}\n\t\tput(key,5);\n\t\tfor (int i = 0; i < t1.size(); ++i) {\n\t\t\tif (t1[i].key == key) {\n\t\t\t\treturn t1[i].value;\n\t\t\t}\n\t\t}\n\t}\n\tV& operator [] (const string& key) {\n\t\tfor (int i = 0; i < t2.size(); ++i) {\n\t\t\tif (t2[i].key == key) return t2[i].value;\n\t\t}\n\t\tput(key,5);\n\t\tfor (int i = 0; i < t2.size(); ++i) {\n\t\t\tif (t2[i].key == key) {\n\t\t\t\treturn t2[i].value;\n\t\t\t}\n\t\t}\n\t}\n\n};",
            1596179725.5036042,
            100,
            "# 答案正确"
        ]
    ],
    "table_name": "答案"
}