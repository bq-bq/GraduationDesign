{
    "__update_time__": 1595472069.6975322,
    "field_names": [
        "题目名",
        "用户名",
        "答案",
        "提交时间",
        "分数",
        "评语"
    ],
    "field_types": [
        "text",
        "text",
        "text",
        "time",
        "number",
        "text"
    ],
    "foreign_keys": {},
    "primary_keys": [],
    "rows": [
        [
            "测试1",
            "廖雨轩",
            "#include <iostream>\n#include <string>\nusing namespace std;\n\nint main()\n{\n    string input[3];\n    for (int i = 0; i < 3; ++i)\n        cin >> input[i];\n    string tmp = input[0];\n    input[0] = input[2];\n    input[2] = tmp;\n    for (int i = 0; i < 3; ++i)\n    {\n        cout << input[i];\n        if(i != 2)\n            cout << \" \";\n    }\n\n    return 0;\n}\n\n",
            1587517894.0,
            100,
            "# 答案正确"
        ],
        [
            "测试2",
            "廖雨轩",
            "#include <iostream>\n#include <string>\nusing namespace std;\nvoid solve()\n{\n    string str[15];\n    for(int i = 0; i < 10; i++)\n        cin >> str[i];\n    for(int i = 0; i < 9; i++)\n        for (int j = i + 1; j < 10; j++)\n        {\n            if(str[i] > str[j])\n            {\n                string tmp = str[i];\n                str[i] = str[j];\n                str[j] = tmp;\n            }\n        }\n    for(int i = 0; i < 10; i++)\n    {\n        cout << str[i];\n        if(i < 9) cout << \" \";\n    }\n}\nint main()\n{\n    solve();\n    return 0;\n}\n",
            1587609031.5236404,
            100,
            "# 答案正确"
        ],
        [
            "1.1 (C++)",
            "廖雨轩",
            "#include <cstring>\nclass Matrix5x5\n{\npublic:\n    double matrix[5][5];\n    Matrix5x5()\n    {\n        memset(matrix, 0, sizeof(matrix));\n    }\n    double get(int i, int j)\n    {\n        return matrix[i][j];\n    }\n    void set(int i, int j, double val)\n    {\n        matrix[i][j] = val;\n    }\n\t    Matrix5x5 operator+(Matrix5x5 & m2)\n    {\n        for(int i = 0; i < 5; i++)\n            for(int j = 0; j < 5; j++)\n            {\n                double t = this->get(i, j);\n                this->set(i, j, t + m2.get(i, j));\n            }\n        return *this;\n    }\n};",
            1587696854.4207976,
            100,
            "# 答案正确"
        ],
        [
            "1.2 (C++)",
            "廖雨轩",
            "#include<cstring>\nclass School\n{\npublic:\n    char name[20];\n    int age;\n    School()\n    {\n        strcpy(this->name, \"NO_NAME\");\n        this->age = 0;\n    }\n    void setName(char input[])\n    {\n        strcpy(this->name, input);\n    }\n    void setAge(int year)\n    {\n        this->age = year;\n    }\n    School &operator++();\n};\nSchool &School::operator++()\n{\n    this->age++;\n    return *this;\n}\n",
            1588212714.6313689,
            100,
            "# 答案正确"
        ],
        [
            "2.1 (C++)",
            "廖雨轩",
            "#include <iostream>\nusing namespace std;\nclass Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    double *values;\n\npublic:\n    Matrix(int r, int c)\n    {\n        this->rows = r;\n        this->columns = c;\n        values = new double[r*c];\n        for(int i = 0; i < r*c; i++)\n            values[i] = 0.0;\n    }\n    ~Matrix()\n    {\n        delete[] values;\n    }\n    void print()\n    {\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < columns; j++)\n            {\n                cout << \"    \" << 0;\n            }\n            cout << endl;\n        }\n    }\n};\n",
            1588908613.2078714,
            100,
            "# 答案正确"
        ],
        [
            "2.2 (C++)",
            "廖雨轩",
            "#include <iostream>\nusing namespace std;\nclass Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    double *values;\n\npublic:\n    Matrix(int r, int c)\n    {\n        this->rows = r;\n        this->columns = c;\n        values = new double[r * c];\n        for (int i = 0; i < r * c; i++)\n            values[i] = 0.0;\n    }\n    Matrix(int r, int c, double val[])\n    {\n        this->rows = r;\n        this->columns = c;\n        this->values = new double[r * c + 1];\n        for (int i = 0; i < r * c; i++)\n            values[i] = val[i];\n    }\n    ~Matrix()\n    {\n        delete[] values;\n    }\n    void print()\n    {\n        int ini = 0;\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < columns; j++)\n            {\n                if (this->values[ini] < 10)\n                {\n                    cout << \"    \" << this->values[ini];\n                    ini++;\n                }\n                else\n                {\n                    cout << \"   \" << this->values[ini];\n                    ini++;\n                }\n            }\n            cout << endl;\n        }\n    }\n};",
            1588908675.8881478,
            100,
            "# 答案正确"
        ],
        [
            "2.3 (C++)",
            "廖雨轩",
            "#include <iostream>\nusing namespace std;\nclass Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    double *values;\n\npublic:\n    Matrix(int r, int c)\n    {\n        this->rows = r;\n        this->columns = c;\n        values = new double[r * c];\n        for (int i = 0; i < r * c; i++)\n            values[i] = 0.0;\n    }\n    Matrix(int r, int c, double val[])\n    {\n        this->rows = r;\n        this->columns = c;\n        this->values = new double[r * c + 1];\n        for (int i = 0; i < r * c; i++)\n            values[i] = val[i];\n    }\n    Matrix(const Matrix &matrix2)\n    {\n        int r = matrix2.rows;\n        int c = matrix2.columns;\n        this->rows = r;\n        this->columns = c;\n        this->values = new double[r * c + 1];\n        for(int i = 0; i < r*c; i++)\n            values[i] = matrix2.values[i];\n    }\n    ~Matrix()\n    {\n        delete[] values;\n    }\n    void print()\n    {\n        int ini = 0;\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < columns; j++)\n            {\n                cout << \"    \" << this->values[ini++];\n            }\n            cout << endl;\n        }\n    }\n};\n",
            1588908751.4221082,
            100,
            "# 答案正确"
        ],
        [
            "2.5 (C++)",
            "廖雨轩",
            "#include <iostream>\nusing namespace std;\nclass Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    double *values;\n\npublic:\n    Matrix(int r, int c)\n    {\n        this->rows = r;\n        this->columns = c;\n        values = new double[r * c];\n        for (int i = 0; i < r * c; i++)\n            values[i] = 0.0;\n    }\n    Matrix(int r, int c, double val[])\n    {\n        this->rows = r;\n        this->columns = c;\n        this->values = new double[r * c + 1];\n        for (int i = 0; i < r * c; i++)\n            values[i] = val[i];\n    }\n    Matrix(const Matrix &matrix2)\n    {\n        int r = matrix2.rows;\n        int c = matrix2.columns;\n        this->rows = r;\n        this->columns = c;\n        this->values = new double[r * c + 1];\n        for(int i = 0; i < r*c; i++)\n            values[i] = matrix2.values[i];\n    }\n    ~Matrix()\n    {\n        delete[] values;\n    }\n    void print()\n    {\n        int ini = 0;\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < columns; j++)\n            {\n                cout << \"    \" << this->values[ini++];\n            }\n            cout << endl;\n        }\n    }\n    Matrix getRow(int r)\n    {\n        int row = 1;\n        int col = this->columns;\n        double *val = new double[row * col + 1];\n        for (int i = 0; i < row * col; i++)\n        {\n            val[i] = values[(r - 1) * col + i];\n        }\n        Matrix ret(row, col, val);\n        return ret;\n    }\n    Matrix getColumn(int c)\n    {\n        int row = this->rows;\n        int col = 1;\n        double *val = new double[row * col + 1];\n\n        for (int i = 0; i < row * col; i++)\n        {\n            val[i] = values[(c - 1) + i * columns];\n        }\n        Matrix ret(row, col, val);\n        return ret;\n    }\n};",
            1588908824.8660777,
            100,
            "# 答案正确"
        ],
        [
            "2.6 (C++)",
            "廖雨轩",
            "#include <iostream>\nusing namespace std;\nclass Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    double *values;\n\npublic:\n    Matrix()\n    {\n        rows = 0;\n        columns = 0;\n        values = nullptr;\n    }\n    Matrix(int r, int c, double val[])\n    {\n        this->rows = r;\n        this->columns = c;\n        this->values = new double[r * c + 1];\n        for (int i = 0; i < r * c; i++)\n            values[i] = val[i];\n    }\n    Matrix(const Matrix &matrix2)\n    {\n        int r = matrix2.rows;\n        int c = matrix2.columns;\n        this->rows = r;\n        this->columns = c;\n        this->values = new double[r * c + 1];\n        for (int i = 0; i < r * c; i++)\n            values[i] = matrix2.values[i];\n    }\n    ~Matrix()\n    {\n        delete[] values;\n    }\n    void print()\n    {\n        int ini = 0;\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < columns; j++)\n            {\n                cout << \"    \" << this->values[ini++];\n            }\n            cout << endl;\n        }\n    }\n    Matrix concatenateRows(const Matrix &matrix2) const;\n    Matrix concatenateColumns(const Matrix &matrix2) const;\n};\nMatrix Matrix::concatenateRows(const Matrix &matrix2) const\n{\n    //col 一样 r1 r2不一样\n    int r1 = this->rows;\n    int r2 = matrix2.rows;\n    int c = this->columns;\n    int sz = (r1 + r2) * c;\n    double *val = new double[sz + 2];\n    int sz1 = r1 * c;\n    for (int i = 0; i < sz1; i++)\n        val[i] = this->values[i];\n\n    // for (int i = 0; i < sz1; i++)\n    //     cout << val[i] << \" \";\n    int sz2 = r2 * c;\n    for (int i = sz1, j = 0; j < sz2; i++, j++)\n        val[i] = matrix2.values[j];\n    Matrix matrix3(r1 + r2, c, val);\n    return matrix3;\n}\nMatrix Matrix::concatenateColumns(const Matrix &matrix2) const\n{\n    //row一样 c1 c2 不一样\n    int c1 = this->columns;\n    int c2 = matrix2.columns;\n    int r = this->rows;\n    int sz = r * (c1 + c2);\n    double *val = new double[sz + 2];\n    for (int i = 0; i < r; i++)\n    {\n        for (int j = 0; j < c1; j++)\n            val[i * (c1 + c2) + j] = this->values[i * c1 + j];\n        for (int j = 0; j < c2; j++)\n            val[i * (c2 + c1) + c1 + j] = matrix2.values[i * c2 + j];\n    }\n    Matrix matrix3(r, c1 + c2, val);\n    return matrix3;\n}",
            1588908868.5208957,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/08",
            "廖雨轩",
            "double &Tensor_get(int dimensions, int sizes[], double data[], int x0, int x1, int x2, int x3)\n{\n    int index = 0;\n    if (dimensions == 1)\n        index = x0;\n    if (dimensions == 2)\n        index = x0 * sizes[1] + x1;\n    if (dimensions == 3)\n        index = x0 * sizes[2] * sizes[1] + x1 * sizes[2] + x2;\n    if (dimensions == 4)\n        index = x0 * sizes[3] * sizes[2] * sizes[1] + x1 * sizes[3] * sizes[2] + x2 * sizes[2] + x3;\n    return data[index];\n}",
            1588908246.836021,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/14",
            "廖雨轩",
            "#include <iostream>\nusing namespace std;\nvoid Tensor_print(int dimensions, const int sizes[], const double data[])\n{\n    if (dimensions == 1)\n    {\n        cout << \"Tensor of \" << sizes[0] << endl;\n        for (int i = 0; i < sizes[0]; i++)\n        {\n            cout << data[i] << endl;\n        }\n    }\n    else if (dimensions == 2)\n    {\n        cout << \"Tensor of \" << sizes[0] << \"x\" << sizes[1] << endl;\n        int sz = 0;\n        for (int i = 0; i < sizes[0]; i++)\n        {\n            for (int j = 0; j < sizes[1]; j++)\n            {\n                cout << \"    \" << data[sz++];\n            }\n            cout << endl;\n        }\n    }\n    else if (dimensions == 3)\n    {\n        cout << \"Tensor of \" << sizes[0] << \"x\" << sizes[1] << \"x\" << sizes[2] << endl;\n        int sz = 0;\n        for (int i = 0; i < sizes[0]; i++)\n        {\n            cout << \"data[\" << i << \"]\" << endl;\n            for (int j = 0; j < sizes[1]; j++)\n            {\n                for (int k = 0; k < sizes[2]; k++)\n                {\n                    cout << \"    \" << data[sz++];\n                }\n                cout << endl;\n            }\n        }\n    }\n    else if (dimensions == 4)\n    {\n        int sz = 0;\n        cout << \"Tensor of \" << sizes[0] << \"x\" << sizes[1] << \"x\" << sizes[2] << \"x\" << sizes[3] << endl;\n\n        for (int i = 0; i < sizes[0]; i++)\n        {\n            for (int j = 0; j < sizes[1]; j++)\n            {\n                cout << \"data[\" << i << \"]\"\n                     << \"[\" << j << \"]\" << endl;\n\n                for (int k = 0; k < sizes[2]; k++)\n                {\n                    for (int l = 0; l < sizes[3]; l++)\n                    {\n                        cout << \"    \" << data[sz++];\n                    }\n                    cout << endl;\n                }\n            }\n        }\n    }\n}",
            1589423935.0893297,
            100,
            "# 答案正确"
        ],
        [
            "2.4 (C++)",
            "廖雨轩",
            "#include <iostream>\nusing namespace std;\nclass Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    double *values;\npublic:\n    Matrix() : rows(0), columns(0), values(NULL)\n    {\n    }\n    Matrix(int r, int c) : rows(r), columns(c)\n    {\n        int sz = r * c;\n        if (sz > 0)\n        {\n            values = new double[sz];\n            for (int i = 0; i < sz; i++)\n                values[i] = 0.0;\n        }\n        else\n        {\n            values = nullptr;\n        }\n    }\n    Matrix(int r, int c, double val[])\n    {\n        rows = r;\n        columns = c;\n        int sz = r * c;\n        if (sz > 0)\n        {\n            values = new double[sz];\n            for (int i = 0; i < sz; i++)\n                values[i] = val[i];\n        }\n        else\n        {\n            values = nullptr;\n        }\n    }\n    Matrix(const Matrix &rhs) //拷贝构造\n    {\n        rows = rhs.rows;\n        columns = rhs.columns;\n        int sz = rows * columns;\n        values = new double[sz];\n        for (int i = 0; i < sz; i++)\n            values[i] = rhs.values[i];\n    }\n    Matrix operator = (const Matrix & rhs)\n    {\n        this->rows = rhs.rows;\n        this->columns = rhs.columns;\n        int sz = rows * columns;\n        if(values != nullptr)\n        {\n            delete[] values;\n            values = nullptr;\n        }\n        values = new double[sz];\n        for(int i = 0; i < sz; i++)\n            values[i] = rhs.values[i];\n        return (*this);\n    }\n    void print()\n    {\n        int ini = 0;\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < columns; j++)\n            {\n                cout << \"    \" << this->values[ini++];\n            }\n            cout << endl;\n        }\n    }\n    void set(int row, int col, double val)\n    {\n        int r = this->rows;\n        int c = this->columns;\n        int index = (row - 1) * c + col - 1;\n        this->values[index] = val;\n    }\n    ~Matrix()\n    {\n        if (values != nullptr)\n        {\n            delete[] values;\n            values = nullptr;\n        }\n    }\n};",
            1589511130.515137,
            100,
            "# 答案正确"
        ],
        [
            "2.7 (C++)",
            "廖雨轩",
            "#include <iostream>\nusing namespace std;\nclass Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    double *values;\n\npublic:\n    Matrix() : rows(0), columns(0), values(NULL)\n    {\n    }\n    Matrix(int r, int c) : rows(r), columns(c)\n    {\n        int sz = r * c;\n        if (sz > 0)\n        {\n            values = new double[sz];\n            for (int i = 0; i < sz; i++)\n                values[i] = 0.0;\n        }\n        else\n        {\n            values = nullptr;\n        }\n    }\n    Matrix(int r, int c, double val[])\n    {\n        rows = r;\n        columns = c;\n        int sz = r * c;\n        if (sz > 0)\n        {\n            values = new double[sz];\n            for (int i = 0; i < sz; i++)\n                values[i] = val[i];\n        }\n        else\n        {\n            values = nullptr;\n        }\n    }\n    Matrix(const Matrix &rhs) //拷贝构造\n    {\n        rows = rhs.rows;\n        columns = rhs.columns;\n        int sz = rows * columns;\n        values = new double[sz];\n        for (int i = 0; i < sz; i++)\n            values[i] = rhs.values[i];\n    }\n    void print()\n    {\n        int ini = 0;\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < columns; j++)\n            {\n                cout << \"    \" << this->values[ini++];\n            }\n            cout << endl;\n        }\n    }\n    Matrix reshape(int r, int c) const;\n    ~Matrix()\n    {\n        if (values != nullptr)\n        {\n            delete[] values;\n            values = nullptr;\n        }\n    }\n};\nMatrix Matrix::reshape(int r, int c) const\n{\n    // if(r * c != rows * columns)\n    //     return *this;\n    int sz = r * c;\n    double res[sz] = {0};\n    int ini = 0;\n    for (int i = 0; i < columns; i++)\n    {\n        for (int j = 0; j < rows; j++)\n        {\n            res[ini++] = values[i + j * columns];\n        }\n    }\n    double ans[sz] = {0};\n    ini = 0;\n    for (int i = 0; i < c; i++)\n    {\n        for (int j = 0; j < r; j++)\n        {\n            ans[i + j * c] = res[ini++];\n        }\n    }\n    Matrix ret(r, c, ans);\n    return ret;\n}",
            1589522839.5421393,
            100,
            "# 答案正确"
        ],
        [
            "2.8 (C++)",
            "廖雨轩",
            "#include <iostream>\nusing namespace std;\nclass Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    double *values;\npublic:\n    Matrix() : rows(0), columns(0), values(NULL)\n    {\n    }\n    Matrix(int r, int c) : rows(r), columns(c)\n    {\n        int sz = r * c;\n        if (sz > 0)\n        {\n            values = new double[sz];\n            for (int i = 0; i < sz; i++)\n                values[i] = 0.0;\n        }\n        else\n        {\n            values = nullptr;\n        }\n    }\n    Matrix(int r, int c, double val[])\n    {\n        rows = r;\n        columns = c;\n        int sz = r * c;\n        if (sz > 0)\n        {\n            values = new double[sz];\n            for (int i = 0; i < sz; i++)\n                values[i] = val[i];\n        }\n        else\n        {\n            values = nullptr;\n        }\n    }\n    Matrix(const Matrix &rhs) //拷贝构造\n    {\n        rows = rhs.rows;\n        columns = rhs.columns;\n        int sz = rows * columns;\n        values = new double[sz];\n        for (int i = 0; i < sz; i++)\n            values[i] = rhs.values[i];\n    }\n    void print()\n    {\n        int ini = 0;\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < columns; j++)\n            {\n                cout << \"    \" << this->values[ini++];\n            }\n            cout << endl;\n        }\n    }\n    ~Matrix()\n    {\n        if (values != nullptr)\n        {\n            delete[] values;\n            values = nullptr;\n        }\n    }\n    Matrix transpose();\n};\nMatrix Matrix::transpose()\n{\n    int sz = columns * rows;\n    double val[sz] = {0};\n    int ini = 0;\n    for (int i = 0; i < columns; i++)\n    {\n        for(int j = 0; j < rows; j++)\n        {\n            val[ini++] = values[i + j * columns];\n        }\n    }\n    Matrix trans(columns, rows, val);\n    return trans;\n    \n}",
            1589513545.9668632,
            100,
            "# 答案正确"
        ],
        [
            "2.10 (C++)",
            "廖雨轩",
            "#include <iostream>\nusing namespace std;\nclass Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    double *values;\n\npublic:\n    Matrix() : rows(0), columns(0), values(NULL)\n    {\n    }\n    Matrix(int r, int c) : rows(r), columns(c)\n    {\n        int sz = r * c;\n        if (sz > 0)\n        {\n            values = new double[sz];\n            for (int i = 0; i < sz; i++)\n                values[i] = 0.0;\n        }\n        else\n        {\n            values = nullptr;\n        }\n    }\n    Matrix(int r, int c, double val[])\n    {\n        rows = r;\n        columns = c;\n        int sz = r * c;\n        if (sz > 0)\n        {\n            values = new double[sz];\n            for (int i = 0; i < sz; i++)\n                values[i] = val[i];\n        }\n        else\n        {\n            values = nullptr;\n        }\n    }\n    Matrix(const Matrix &rhs) //拷贝构造\n    {\n        rows = rhs.rows;\n        columns = rhs.columns;\n        int sz = rows * columns;\n        values = new double[sz];\n        for (int i = 0; i < sz; i++)\n            values[i] = rhs.values[i];\n    }\n    void print()\n    {\n        int ini = 0;\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < columns; j++)\n            {\n                cout << \"    \" << this->values[ini++];\n            }\n            cout << endl;\n        }\n    }\n    ~Matrix()\n    {\n        if (values != nullptr)\n        {\n            delete[] values;\n            values = nullptr;\n        }\n    }\n    Matrix operator*(const Matrix &matrix2) const;\n    Matrix operator*(double value) const;\n};\nMatrix Matrix::operator*(const Matrix &matrix2) const\n{\n        int sz = rows * matrix2.columns;\n    double res[sz] = {0};\n    for (int i = 0; i < rows; i++)\n    {\n        for (int j = 0; j < matrix2.columns; j++)\n        {\n            for (int k = 0; k < columns; k++)\n            {\n                res[i * matrix2.columns + j] += values[i * columns + k] * matrix2.values[k * matrix2.columns + j];\n            }\n        }\n    }\n    Matrix ret(rows, matrix2.columns, res);\n    return ret;\n}\nMatrix Matrix::operator*(double value) const\n{\n    int sz = rows * columns;\n    int ini = 0;\n    double res[sz] = {0};\n    for (int i = 0; i < sz; ++i)\n        res[i] = values[i] * value;\n    Matrix ret(rows, columns, res);\n    return ret;\n}",
            1589514674.1514268,
            100,
            "# 答案正确"
        ],
        [
            "2.11 (C++)",
            "廖雨轩",
            "#include <iostream>\nusing namespace std;\nclass Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    double *values;\n\npublic:\n    Matrix() : rows(0), columns(0), values(NULL)\n    {\n    }\n    Matrix(int r, int c) : rows(r), columns(c)\n    {\n        int sz = r * c;\n        if (sz > 0)\n        {\n            values = new double[sz];\n            for (int i = 0; i < sz; i++)\n                values[i] = 0.0;\n        }\n        else\n        {\n            values = nullptr;\n        }\n    }\n    Matrix(int r, int c, double val[])\n    {\n        rows = r;\n        columns = c;\n        int sz = r * c;\n        if (sz > 0)\n        {\n            values = new double[sz];\n            for (int i = 0; i < sz; i++)\n                values[i] = val[i];\n        }\n        else\n        {\n            values = nullptr;\n        }\n    }\n    Matrix(const Matrix &rhs) //拷贝构造\n    {\n        rows = rhs.rows;\n        columns = rhs.columns;\n        int sz = rows * columns;\n        values = new double[sz];\n        for (int i = 0; i < sz; i++)\n            values[i] = rhs.values[i];\n    }\n    void print()\n    {\n        int ini = 0;\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < columns; j++)\n            {\n                cout << \"    \" << this->values[ini++];\n            }\n            cout << endl;\n        }\n    }\n    Matrix max() const;//返回每一列最大\n    Matrix min() const;//返回每一列最小\n    Matrix sum() const;//返回每一列总和\n    ~Matrix()\n    {\n        if (values != nullptr)\n        {\n            delete[] values;\n            values = nullptr;\n        }\n    }\n};\nMatrix Matrix::max() const\n{\n    if (rows == 1)\n    {\n        double max[1] = {-1.0};\n        for (int i = 0; i < columns; i++)\n            if (values[i] >= max[0])\n                max[0] = values[i];\n\n        Matrix ret(1, 1, max);\n        return ret;\n    }\n    else\n    {\n        double res[columns] = {0};\n        int ini = 0;\n        for (int i = 0; i < columns; i++)\n        {\n            double maxCol = -1;\n            for (int j = 0; j < rows; j++)\n            {\n                if(values[i + j * columns] > maxCol)\n                    maxCol = values[i + j * columns];\n            }\n            res[ini++] = maxCol;\n        }\n        // cout << \"index :\" <<indexi << \" \" << indexj << endl;\n        Matrix ret(1, columns, res);\n        return ret;\n    }\n}\nMatrix Matrix::min() const\n{\n    double MAX = 0x3f3f3f3f3f3f3f3f;\n    if (rows == 1)\n    {\n        double min[1] = {MAX};\n        for (int i = 0; i < columns; i++)\n            if (values[i] <= min[0])\n                min[0] = values[i];\n\n        Matrix ret(1, 1, min);\n        return ret;\n    }\n    else\n    {\n        double res[columns] = {0};\n        int ini = 0;\n        for (int i = 0; i < columns; i++)\n        {\n            double minCol = MAX;\n            for (int j = 0; j < rows; j++)\n            {\n                if (values[i + j * columns] <= minCol)\n                {\n                    minCol = values[i + j * columns];\n                }\n            }\n            res[ini++] = minCol;\n        }\n        // cout << \"index :\" <<indexi << \" \" << indexj << endl;\n        Matrix ret(1, columns, res);\n        return ret;\n    }\n}\nMatrix Matrix::sum() const\n{\n    if (rows == 1)\n    {\n        double res[1] = {0};\n        for (int i = 0; i < columns; i++)\n            res[0] += values[i];\n        Matrix ret(1, 1, res);\n        return ret;\n    }\n    else\n    {\n        int r = 1;\n        int c = columns;\n        double res[r * c + 1] = {0};\n        int ini = 0;\n        for (int i = 0; i < columns; ++i)\n        {\n            double sum = 0.0;\n            for (int j = 0; j < rows; ++j)\n            {\n                sum += values[i + j * columns];\n            }\n            res[ini++] = sum;\n        }\n        Matrix ret(1, c, res);\n        return ret;\n    }\n}",
            1589517719.9537377,
            100,
            "# 答案正确"
        ],
        [
            "2.12 (C++)",
            "廖雨轩",
            "#include <iostream>\n#include <cmath>\nusing namespace std;\nclass Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    double *values;\n\npublic:\n    Matrix() : rows(0), columns(0), values(NULL)\n    {\n    }\n    Matrix(int r, int c) : rows(r), columns(c)\n    {\n        int sz = r * c;\n        if (sz > 0)\n        {\n            values = new double[sz];\n            for (int i = 0; i < sz; i++)\n                values[i] = 0.0;\n        }\n        else\n        {\n            values = nullptr;\n        }\n    }\n    Matrix(int r, int c, double val[])\n    {\n        rows = r;\n        columns = c;\n        int sz = r * c;\n        if (sz > 0)\n        {\n            values = new double[sz];\n            for (int i = 0; i < sz; i++)\n                values[i] = val[i];\n        }\n        else\n        {\n            values = nullptr;\n        }\n    }\n    Matrix(const Matrix &rhs) //拷贝构造\n    {\n        rows = rhs.rows;\n        columns = rhs.columns;\n        int sz = rows * columns;\n        values = new double[sz];\n        for (int i = 0; i < sz; i++)\n            values[i] = rhs.values[i];\n    }\n    void print()\n    {\n        int ini = 0;\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < columns; j++)\n            {\n                cout << \"    \" << this->values[ini++];\n            }\n            cout << endl;\n        }\n    }\n    ~Matrix()\n    {\n        if (values != nullptr)\n        {\n            delete[] values;\n            values = nullptr;\n        }\n    }\n    Matrix pow(double exponent);\n    Matrix exp();\n    Matrix log();\n    Matrix abs();\n};\nMatrix Matrix::pow(double exponent)\n{\n    double res[rows * columns];\n    for (int i = 0; i < rows; i++)\n    {\n        for (int j = 0; j < columns; j++)\n        {\n            double value = values[i * columns + j];\n            res[i * columns + j] = std::pow(value, exponent);\n        }\n    }\n    Matrix ret(rows, columns, res);\n    return ret;\n}\nMatrix Matrix::exp()\n{\n    double res[rows * columns] = {0};\n    for (int i = 0; i < rows; i++)\n    {\n        for (int j = 0; j < columns; j++)\n        {\n            res[i * columns + j] = std::exp(values[i * columns + j]);\n        }\n    }\n    Matrix ret(rows, columns, res);\n    return ret;\n}\nMatrix Matrix::log()\n{\n    double res[rows * columns] = {0};\n    for (int i = 0; i < rows; i++)\n    {\n        for (int j = 0; j < columns; j++)\n        {\n            res[i * columns + j] = std::log(values[i * columns + j]);\n        }\n    }\n    Matrix ret(rows, columns, res);\n    return ret;\n}\nMatrix Matrix::abs()\n{\n    double res[rows * columns] = {0};\n    for (int i = 0; i < rows; i++)\n    {\n        for (int j = 0; j < columns; j++)\n        {\n            res[i * columns + j] = std::abs(values[i * columns + j]);\n        }\n    }\n    Matrix ret(rows, columns, res);\n    return ret;\n}",
            1589519413.3153915,
            100,
            "# 答案正确"
        ],
        [
            "2.9 (C++)",
            "廖雨轩",
            "#include <iostream>\nusing namespace std;\nclass Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    double *values;\n\npublic:\n    Matrix() : rows(0), columns(0), values(NULL)\n    {\n    }\n    Matrix(int r, int c) : rows(r), columns(c)\n    {\n        int sz = r * c;\n        if (sz > 0)\n        {\n            values = new double[sz];\n            for (int i = 0; i < sz; i++)\n                values[i] = 0.0;\n        }\n        else\n        {\n            values = nullptr;\n        }\n    }\n    Matrix(int r, int c, double val[])\n    {\n        rows = r;\n        columns = c;\n        int sz = r * c;\n        if (sz > 0)\n        {\n            values = new double[sz];\n            for (int i = 0; i < sz; i++)\n                values[i] = val[i];\n        }\n        else\n        {\n            values = nullptr;\n        }\n    }\n    Matrix(const Matrix &rhs)\n    {\n        rows = rhs.rows;\n        columns = rhs.columns;\n        int sz = rows * columns;\n        values = new double[sz];\n        for (int i = 0; i < sz; i++)\n            values[i] = rhs.values[i];\n    }\n    void print()\n    {\n        int ini = 0;\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < columns; j++)\n            {\n                cout << \"    \" << this->values[ini++];\n            }\n            cout << endl;\n        }\n    }\n    ~Matrix()\n    {\n        if (values != nullptr)\n        {\n            delete[] values;\n            values = nullptr;\n        }\n    }\n    Matrix operator+(const Matrix &matrix2) const;\n    Matrix operator+(double value) const;\n    Matrix operator-(const Matrix &matrix2) const;\n    Matrix operator-(double value) const;\n};\nMatrix Matrix::operator+(const Matrix &matrix2) const\n{\n    int sz = rows * columns;\n    double val[sz + 1] = {0};\n    for (int i = 0; i < sz; i++)\n        val[i] = this->values[i] + matrix2.values[i];\n    Matrix ret(rows, columns, val);\n    return ret;\n}\nMatrix Matrix::operator+(double value) const\n{\n    int sz = rows * columns;\n    double val[sz + 1] = {0};\n    for (int i = 0; i < sz; i++)\n        val[i] = this->values[i] + value;\n    Matrix ret(rows, columns, val);\n    return ret;\n}\nMatrix Matrix::operator-(const Matrix &matrix2) const\n{\n    int sz = rows * columns;\n    double val[sz + 1] = {0};\n    for (int i = 0; i < sz; i++)\n        val[i] = this->values[i] - matrix2.values[i];\n    Matrix ret(rows, columns, val);\n    return ret;\n}\nMatrix Matrix::operator-(double value) const\n{\n    int sz = rows * columns;\n    double val[sz + 1] = {0};\n    for (int i = 0; i < sz; i++)\n        val[i] = this->values[i] - value;\n    Matrix ret(rows, columns, val);\n    return ret;\n}\n",
            1590026888.729814,
            100,
            "# 答案正确"
        ],
        [
            "6.1 (C++)",
            "廖雨轩",
            "#include <iostream>\n#include <string>\n#include <cstring>\nusing namespace std;\ntemplate <typename T>\nclass Matrix\n{\nprivate:\n    T *values;\n    int rows;\n    int columns;\n\npublic:\n    void print()\n    {\n        int ini = 0;\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < columns; j++)\n            {\n                cout << \"    \" << values[ini++];\n            }\n            cout << endl;\n        }\n    }\n    Matrix() : rows(0), columns(0), values(nullptr)\n    {\n    }\n    Matrix(int r, int c) : rows(r), columns(c)\n    {\n        int sz = r * c;\n        if (sz > 0)\n        {\n            values = new T[sz];\n            //?\n            for (int i = 0; i < sz; i++)\n                values[i] = 0.0;\n        }\n        else\n        {\n            values = nullptr;\n        }\n    }\n    Matrix(int r, int c, const T val[])\n    {\n        rows = r;\n        columns = c;\n        int sz = r * c;\n        if (sz > 0)\n        {\n            values = new T[sz];\n            for (int i = 0; i < sz; i++)\n                values[i] = val[i];\n        }\n        else\n        {\n            values = nullptr;\n        }\n    }\n    Matrix(const Matrix &rhs)\n    {\n        rows = rhs.rows;\n        columns = rhs.columns;\n        int sz = rows * columns;\n        values = new T[sz];\n        for (int i = 0; i < sz; i++)\n            values[i] = rhs.values[i];\n    }\n    ~Matrix()\n    {\n        if (values != nullptr)\n        {\n            delete[] values;\n            values = nullptr;\n        }\n    }\n    Matrix &operator=(const Matrix &mat)\n    {\n        rows = mat.rows;\n        columns = mat.columns;\n        if (values != nullptr)\n            delete[] values;\n        int sz = rows * columns;\n        values = new T[sz];\n        for (int i = 0; i < sz; i++)\n            values[i] = mat.values[i];\n        return *this;\n    }\n    T &get(int r, int c)\n    {\n        return values[(r - 1) * columns + (c - 1)];\n    }\n    int size() const { return columns * rows; }\n};",
            1590115533.6361117,
            100,
            "# 答案正确"
        ],
        [
            "6.3 (C++)",
            "廖雨轩",
            "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\ntemplate <typename T>\nclass Matrix\n{\nprivate:\n    vector<T> values;\n    int rows;\n    int columns;\n\npublic:\n    void print()\n    {\n        int ini = 0;\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < columns; j++)\n            {\n                cout << \"    \" << values[ini++];\n            }\n            cout << endl;\n        }\n    }\n    Matrix() : rows(0), columns(0)\n    {\n    }\n    Matrix(int r, int c) : rows(r), columns(c)\n    {\n        int sz = r * c;\n        if (sz > 0)\n        {\n            for (int i = 0; i < sz; i++)\n                values.push_back(0);\n        }\n    }\n    Matrix(int r, int c, vector<T> &val)\n    {\n        rows = r;\n        columns = c;\n        int sz = r * c;\n        if (sz > 0)\n        {\n            for (int i = 0; i < sz; i++)\n                values.push_back(val[i]);\n        }\n    }\n    Matrix(const Matrix &mat)\n    {\n        rows = mat.rows;\n        columns = mat.columns;\n        int sz = rows * columns;\n        values.clear();\n        for (int i = 0; i < sz; i++)\n            values.push_back(mat.values[i]);\n    }\n    ~Matrix()\n    {\n        // if (values != nullptr)\n        // {\n        //     delete[] values;\n        //     values = nullptr;\n        // }\n        values.clear();\n    }\n    Matrix &operator=(const Matrix &mat)\n    {\n        rows = mat.rows;\n        columns = mat.columns;\n        if (!values.empty())\n            values.clear();\n        int sz = rows * columns;\n        for (int i = 0; i < sz; i++)\n            values.push_back(mat.values[i]);\n        return *this;\n    }\n    T &get(int r, int c)\n    {\n        return values[(r - 1) * columns + (c - 1)];\n    }\n    int size() const { return columns * rows; }\n    Matrix transpose()\n    {\n        int sz = columns * rows;\n        vector<T> val(sz);\n        int ini = 0;\n        for (int i = 0; i < columns; i++)\n        {\n            for (int j = 0; j < rows; j++)\n            {\n                val[ini++] = values[i + j * columns];\n            }\n        }\n        Matrix trans(columns, rows, val);\n        return trans;\n    }\n    Matrix max() const //返回每一列最大\n    {\n        if (rows == 1)\n        {\n            vector<T> max(1);\n            max[0] = values[0];\n            for (int i = 0; i < columns; i++)\n                if (values[i] >= max[0])\n                    max[0] = values[i];\n            Matrix ret(1, 1, max);\n            return ret;\n        }\n        else\n        {\n            vector<T> res(columns);\n            int ini = 0;\n            for (int i = 0; i < columns; i++)\n            {\n                T maxCol = values[0];\n                for (int j = 0; j < rows; j++)\n                {\n                    if (values[i + j * columns] > maxCol)\n                        maxCol = values[i + j * columns];\n                }\n                res[ini++] = maxCol;\n            }\n            Matrix ret(1, columns, res);\n            return ret;\n        }\n    }\n    Matrix min() const //返回每一列最小\n    {\n        {\n            if (rows == 1)\n            {\n                vector<T> min(1);\n                min[0] = values[0];\n                for (int i = 0; i < columns; i++)\n                    if (values[i] <= min[0])\n                        min[0] = values[i];\n                Matrix ret(1, 1, min);\n                return ret;\n            }\n            else\n            {\n                vector<T> res(columns);\n                int ini = 0;\n                for (int i = 0; i < columns; i++)\n                {\n                    T minCol = values[0];\n                    for (int j = 0; j < rows; j++)\n                    {\n                        if (values[i + j * columns] <= minCol)\n                            minCol = values[i + j * columns];\n                    }\n                    res[ini++] = minCol;\n                }\n                Matrix ret(1, columns, res);\n                return ret;\n            }\n        }\n    }\n    Matrix getRow(int r)\n    {\n        int row = 1;\n        int col = columns;\n        vector<T> val(row * col + 1);\n        for (int i = 0; i < row * col; i++)\n        {\n            val[i] = values[(r - 1) * col + i];\n        }\n        Matrix ret(row, col, val);\n        return ret;\n    }\n    Matrix getColumn(int c)\n    {\n        int row = rows;\n        int col = 1;\n        vector<T> val(row * col + 1);\n        for (int i = 0; i < row * col; i++)\n        {\n            val[i] = values[(c - 1) + i * columns];\n        }\n        Matrix ret(row, col, val);\n        return ret;\n    }\n    Matrix sum() const //返回每一列总和\n    {\n        if (rows == 1)\n        {\n            vector<T> res(1);\n            res[0] = values[0];\n            for (int i = 1; i < columns; i++)\n                res[0] += values[i];\n            Matrix ret(1, 1, res);\n            return ret;\n        }\n        else\n        {\n            int r = 1;\n            int c = columns;\n            vector<T> res(r * c + 1);\n            int ini = 0;\n            for (int i = 0; i < columns; i++)\n            {\n                T sum = 0;\n                for (int j = 0; j < rows; ++j)\n                {\n                    sum += values[i + j * columns];\n                }\n                res[ini++] = sum;\n            }\n            Matrix ret(1, c, res);\n            return ret;\n        }\n    }\n    Matrix concatenateRows(const Matrix &matrix2) const\n    {\n        //col 一样 r1 r2不一样\n        int r1 = rows;\n        int r2 = matrix2.rows;\n        int c = columns;\n        int sz = (r1 + r2) * c;\n        vector<T> val(sz + 2);\n        int sz1 = r1 * c;\n        for (int i = 0; i < sz1; i++)\n            val[i] = this->values[i];\n        int sz2 = r2 * c;\n        for (int i = sz1, j = 0; j < sz2; i++, j++)\n            val[i] = matrix2.values[j];\n        Matrix matrix3(r1 + r2, c, val);\n        return matrix3;\n    }\n    Matrix concatenateColumns(const Matrix &matrix2) const\n    {\n        int c1 = columns;\n        int c2 = matrix2.columns;\n        int r = rows;\n        int sz = r * (c1 + c2);\n        vector<T> val(sz + 2);\n        for (int i = 0; i < r; i++)\n        {\n            for (int j = 0; j < c1; j++)\n                val[i * (c1 + c2) + j] = this->values[i * c1 + j];\n            for (int j = 0; j < c2; j++)\n                val[i * (c2 + c1) + c1 + j] = matrix2.values[i * c2 + j];\n        }\n        Matrix matrix3(r, c1 + c2, val);\n        return matrix3;\n    }\n    Matrix operator+(const Matrix &matrix2) const\n    {\n        int sz = rows * columns;\n        vector<T> val(sz + 1);\n        for (int i = 0; i < sz; i++)\n            val[i] = this->values[i] + matrix2.values[i];\n        Matrix ret(rows, columns, val);\n        return ret;\n    }\n    Matrix operator+(T value) const\n    {\n        int sz = rows * columns;\n        vector<T> val(sz + 1);\n        for (int i = 0; i < sz; i++)\n            val[i] = this->values[i] + value;\n        Matrix ret(rows, columns, val);\n        return ret;\n    }\n    Matrix operator-(const Matrix &matrix2) const\n    {\n        int sz = rows * columns;\n        vector<T> val(sz + 1);\n        for (int i = 0; i < sz; i++)\n            val[i] = this->values[i] - matrix2.values[i];\n        Matrix ret(rows, columns, val);\n        return ret;\n    }\n    Matrix operator-(T value) const\n    {\n        int sz = rows * columns;\n        vector<T> val(sz + 1);\n        for (int i = 0; i < sz; i++)\n            val[i] = this->values[i] - value;\n        Matrix ret(rows, columns, val);\n        return ret;\n    }\n    Matrix reshape(int r, int c) const\n    {\n        int sz = r * c;\n        vector<T> res(sz);\n        int ini = 0;\n        for (int i = 0; i < columns; i++)\n        {\n            for (int j = 0; j < rows; j++)\n            {\n                res[ini++] = values[i + j * columns];\n            }\n        }\n        vector<T> ans(sz);\n        ini = 0;\n        for (int i = 0; i < c; i++)\n        {\n            for (int j = 0; j < r; j++)\n            {\n                ans[i + j * c] = res[ini++];\n            }\n        }\n        Matrix ret(r, c, ans);\n        return ret;\n    }\n    Matrix operator*(const Matrix &matrix2) const\n    {\n        int sz = rows * matrix2.columns;\n        vector<T> res(sz);\n        res.assign(sz, 0);\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < matrix2.columns; j++)\n            {\n                for (int k = 0; k < columns; k++)\n                {\n                    res[i * matrix2.columns + j] += values[i * columns + k] * matrix2.values[k * matrix2.columns + j];\n                }\n            }\n        }\n        Matrix ret(rows, matrix2.columns, res);\n        return ret;\n    }\n    Matrix operator*(T value) const\n    {\n        int sz = rows * columns;\n        int ini = 0;\n        vector<T> res(sz);\n        for (int i = 0; i < sz; ++i)\n            res[i] = values[i] * value;\n        Matrix ret(rows, columns, res);\n        return ret;\n    }\n};",
            1590118898.3369765,
            100,
            "# 答案正确"
        ],
        [
            "6.2 (C++)",
            "廖雨轩",
            "#include <iostream>\nusing namespace std;\ntemplate <typename T>\nclass Matrix\n{\nprivate:\n    int rows, columns;\n    T *values;\n\npublic:\n    Matrix(int rows, int columns) : rows(rows), columns(columns)\n    {\n        int sz = rows * columns;\n        values = new T[sz];\n        for (int i = 0; i < sz; i++)\n            values[i] = 0;\n    }\n    ~Matrix()\n    {\n        delete[] values;\n    }\n    void print()\n    {\n        int ini = 0;\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < columns; j++)\n            {\n                cout << \"    \" << values[ini++];\n            }\n            cout << endl;\n        }\n    }\n};",
            1590631617.666673,
            100,
            "# 答案正确"
        ],
        [
            "7.1 (C++)",
            "廖雨轩",
            "#include <string>\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\nclass Triangle : public GeometricObject\n{\nprivate:\n    double side1, side2, side3;\n    double p;\n\npublic:\n    Triangle()\n    {\n        side1 = side2 = side3 = 1.0;\n        p = (side1 + side2 + side3) / 2;\n    }\n    Triangle(double a, double b, double c) : side1(a), side2(b), side3(c)\n    {\n        p = (a + b + c) / 2;\n    }\n    double getSide1() const\n    {\n        return this->side1;\n    }\n    double getSide2() const\n    {\n        return this->side2;\n    }\n    double getSide3() const\n    {\n        return this->side3;\n    }\n    double getArea()\n    {\n        double area = p * (p - side1) * (p - side2) * (p - side3);\n        area = sqrt(area);\n        return area;\n    }\n    double getPerimeter()\n    {\n        return p * 2;\n    }\n};\n",
            1590721720.9266822,
            100,
            "# 答案正确"
        ],
        [
            "7.3 (C++)",
            "廖雨轩",
            "#include <iostream>\n#include <vector>\nusing namespace std;\ntemplate <typename A, typename R>\nvector<R> map2(vector<A> x, vector<A> y, R (*map_func)(const A &, const A &)) //传一个函数指针  类型R 函数指针 参数\n{\n    vector<R> res;\n    if(x.size() != y.size())\n        return res;\n    for (int i = 0; i < x.size(); i++)\n        res.push_back(map_func(x[i], y[i]));\n    return res;\n}\ntemplate <typename A, typename R>\nvector<R> map2(vector<A> x, A y, R (*map_func)(const A &, const A &)) //传一个函数指针  类型R 函数指针 参数\n{\n    vector<R> res;\n    for (int i = 0; i < x.size(); i++)\n        res.push_back(map_func(x[i], y));\n    return res;\n}",
            1590723259.9267626,
            100,
            "# 答案正确"
        ],
        [
            "7.2 (C++)",
            "廖雨轩",
            "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\nvector<string> split(const string &line,\n                     const string &delimiter = \" \")\n{\n    vector<string> words;\n    int st = 0;\n    while (st < line.size())\n    {\n        int end = line.find(delimiter, st);\n        if (end == st)\n            st += delimiter.size();\n        else\n        {\n            if (end == -1)\n            {\n                words.push_back(line.substr(st));\n                break;\n            }\n            words.push_back(line.substr(st, end - st));\n            st = end + delimiter.size();\n        }\n    }\n    return words;\n}",
            1591236282.424352,
            100,
            "# 答案正确"
        ],
        [
            "8.1 (C++)",
            "廖雨轩",
            "#include <iostream>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nclass Full : public Matrix\n{\nprivate:\n    int rows, cols;\n    double *values;\npublic:\n    Full(int r, int c) : rows(r), cols(c)\n    {\n        int sz = rows * cols;\n        if(sz > 0)\n        {\n            values = new double[sz];\n            for(int i = 0; i < sz; i++)\n                values[i] = 0.0;\n        }\n        else\n            values = nullptr;\n    }\n    Full(int r, int c, double val[])\n    {\n        rows = r;\n        cols = c;\n        int sz = r * c;\n        values = new double[sz];\n        for (int i = 0; i < sz; i++)\n            values[i] = val[i];\n    }\n    Full(const Matrix &rhs)\n    {\n        rows = rhs.size(1);\n        cols = rhs.size(2);\n        int sz = rows * cols;\n        values = new double[sz];\n        int ini = 0;\n        for (int i = 1; i <= rows; i++)\n            for (int j = 1; j <= cols; j++)\n                values[ini++] = rhs.get(i, j);\n    }\n\n    void print() const\n    {\n        int ini = 0;\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < cols; j++)\n                cout << \"    \" << values[ini++];\n            cout << endl;\n        }\n    }\n    int size(int dimension) const\n    {\n        if (dimension == 1)\n            return rows;\n        else if (dimension == 2)\n            return cols;\n        else\n            return -1;\n    }\n    void set(int row, int column, double value)\n    {\n        int index = (row - 1) * cols + column - 1;\n        values[index] = value;\n    }\n    double get(int row, int column) const\n    {\n        int index = (row - 1) * cols + (column - 1);\n        return values[index];\n    }\n    Matrix &operator=(const Matrix &rhs)\n    {\n        if (&rhs == this)\n            return *this;\n        rows = rhs.size(1);\n        cols = rhs.size(2);\n        // int sz = rows * cols;\n        // values = new double[sz];\n        int ini = 0;\n        for (int i = 1; i <= rows; i++)\n            for (int j = 1; j <= cols; j++)\n                values[ini++] = rhs.get(i, j);\n        return (*this);\n    }\n    ~Full()\n    {\n        if (values != nullptr)\n        {\n            delete[] values;\n            values = nullptr;\n        }\n    }\n};\n\n",
            1591351711.1851573,
            100,
            "# 答案正确"
        ],
        [
            "8.3 (C++)",
            "廖雨轩",
            "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nbool cmp(Entry first, Entry second)\n{\n    if (first.row < second.row)\n        return true;\n    else if (first.row == second.row)\n        return first.column < second.column;\n    return false;\n}\nclass Sparse : public Matrix\n{\nprivate:\n    int rows, cols;\n    vector<Entry> entries;\n\npublic:\n    Sparse(int rows, int column) : rows(rows), cols(column)\n    {\n    }\n    Sparse operator+(Sparse &sparse2)\n    {\n        for (auto &x : sparse2.entries)\n        {\n            bool flag = 0;\n            for (auto &e : entries)\n            {\n                if (x.row == e.row && x.column == e.column)\n                {\n                    e.value += x.value;\n                    flag = 1;\n                }\n            }\n            if (flag == 0)\n            {\n                entries.push_back(x);\n            }\n        }\n        return *this;\n    }\n\n    int size(int dimension) const\n    {\n        if (dimension == 1)\n            return rows;\n        else\n            return cols;\n    }\n\n    void set(int row, int column, double value)\n    {\n        Entry tmp;\n        tmp.row = row;\n        tmp.column = column;\n        tmp.value = value;\n        entries.push_back(tmp);\n    }\n\n    double get(int row, int column) const\n    {\n        for (auto x : entries)\n            if (x.row == row && x.column == column)\n                return x.value;\n        return 0.0;\n    }\n\n    void print()\n    {\n        sort(entries.begin(), entries.end(), cmp);\n        for (auto x : entries)\n            if (x.value != 0.0)\n                cout << \"(\" << x.row << \",\" << x.column << \",\" << x.value << \")\" << endl;\n    }\n};",
            1591359564.1999793,
            100,
            "# 答案正确"
        ],
        [
            "8.4 (C++)",
            "廖雨轩",
            "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool cmp(Entry first, Entry second)\n{\n    if (first.row < second.row)\n        return true;\n    else if (first.row == second.row)\n        return first.column < second.column;\n    return false;\n}\nclass Sparse : public Matrix\n{\nprivate:\n    int rows, cols;\n    vector<Entry> entries;\n\npublic:\n    Sparse(int rows, int column) : rows(rows), cols(column)\n    {\n    }\n    Sparse operator*(Sparse &sparse2)\n    {\n        if (sparse2.entries.empty())\n            return *this;\n        //稀疏矩阵的乘法\n        vector<Entry> ret;\n        for (int i = 0; i < entries.size(); i++)\n        {\n            for (int j = 0; j < sparse2.entries.size(); j++)\n            {\n                if (entries[i].column == sparse2.entries[j].row)\n                {\n                    Entry tmp;\n                    tmp.row = entries[i].row;\n                    tmp.column = sparse2.entries[j].column;\n                    tmp.value = entries[i].value * sparse2.entries[j].value;\n                    ret.push_back(tmp);\n                }\n            }\n        }\n\n        for (int i = 0; i < ret.size(); i++)\n        {\n            for (int j = i + 1; j < ret.size(); j++)\n            {\n                if (ret[i].row == ret[j].row && ret[i].column == ret[j].column)\n                {\n                    ret[i].value += ret[j].value;\n                    ret.erase(ret.begin() + j);\n                }\n            }\n        }\n        entries.clear();\n        entries.resize(ret.size());\n        entries = ret;\n        return *this;\n    }\n    Sparse operator+(Sparse &sparse2)\n    {\n        for (auto &x : sparse2.entries)\n        {\n            bool flag = 0;\n            for (auto &e : entries)\n            {\n                if (x.row == e.row && x.column == e.column)\n                {\n                    e.value += x.value;\n                    flag = 1;\n                }\n            }\n            if (flag == 0)\n                entries.push_back(x);\n        }\n        return *this;\n    }\n\n    int size(int dimension) const\n    {\n        if (dimension == 1)\n            return rows;\n        else\n            return cols;\n    }\n\n    void set(int row, int column, double value)\n    {\n        Entry tmp;\n        tmp.row = row;\n        tmp.column = column;\n        tmp.value = value;\n        entries.push_back(tmp);\n    }\n\n    double get(int row, int column) const\n    {\n        for (auto x : entries)\n            if (x.row == row && x.column == column)\n                return x.value;\n        return 0.0;\n    }\n\n    void print()\n    {\n        sort(entries.begin(), entries.end(), cmp);\n        for (auto x : entries)\n            if (x.value != 0.0)\n                cout << \"(\" << x.row << \",\" << x.column << \",\" << x.value << \")\" << endl;\n    }\n};\n",
            1591367872.5982947,
            100,
            "# 答案正确"
        ],
        [
            "8.5 (C++)",
            "廖雨轩",
            "#include <iostream>\nusing namespace std;\n#include <cmath>\n\nclass Point3D : public Point2D\n{\nprivate:\n    double z;\n\npublic:\n    Point3D()\n    {\n        setX(0.0);\n        setY(0.0);\n        z = 0.0;\n    }\n    Point3D(double x, double y, double z)\n    {\n        setX(x);\n        setY(y);\n        this->z = z;\n    }\n    double getZ()\n    {\n        return this->z;\n    }\n    virtual double distance(Point2D &point2)\n    {\n        Point3D *p2 = dynamic_cast<Point3D *>(&point2);\n        double dx = getX() - p2->getX();\n        double dy = getY() - p2->getY();\n        double dz = this->z - p2->getZ();\n\n        return sqrt(dx * dx + dy * dy + dz * dz);\n    }\n};",
            1591842235.6874704,
            100,
            "# 答案正确"
        ],
        [
            "8.6 (C++)",
            "廖雨轩",
            "#include <iostream>\n#include <vector>\nusing namespace std;\nclass MyTensor : public Tensor<double>\n{\nprivate:\n    vector<double> data;\n\npublic:\n    MyTensor(vector<int> sz) : Tensor(sz)\n    {\n        int sum = 1;\n        for (auto &x : sz)\n            sum *= x;\n        data.assign(sum, 0.0);\n    }\n    double &get(const vector<int> &indexes)\n    {\n        int dimensions = indexes.size();\n        int index = indexes[0];\n        if (dimensions > 1)\n            index = index * indexes[1] + indexes[1];\n        if (dimensions > 2)\n            index = index * indexes[2] + indexes[2];\n        if (dimensions > 3)\n            index = index * indexes[3] + indexes[3];\n        return data[index];\n    }\n};",
            1592448087.8037314,
            100,
            "# 答案正确"
        ],
        [
            "9.1 (C++)",
            "廖雨轩",
            "#include <iostream>\nusing namespace std;\nclass Circle\n{\n    double radius;\n\npublic:\n    Circle(double radius) : radius(radius) {}\n    bool operator<(const Circle &other) const { return radius < other.radius; }\n    bool operator>(const Circle &other) const { return radius > other.radius; }\n    bool operator>=(const Circle &other) const { return radius >= other.radius; }\n    bool operator<=(const Circle &other) const { return radius <= other.radius; }\n    bool operator==(const Circle &other) const { return radius == other.radius; }\n    bool operator!=(const Circle &other) const { return radius != other.radius; }\n};",
            1592536896.8980954,
            100,
            "# 答案正确"
        ],
        [
            "9.2 (C++)",
            "廖雨轩",
            "#include <vector>\n#include <iostream>\nusing namespace std;\nclass I\n{\n    vector<int> values;\n\npublic:\n    I(int a, int b = -1, int c = -1, int d = -1)\n    {\n        if (a != -1)\n            values.push_back(a);\n        if (b != -1)\n            values.push_back(b);\n        if (c != -1)\n            values.push_back(c);\n        if (d != -1)\n            values.push_back(d);\n    }\n    operator vector<int>() const { return values; }\n};",
            1592539587.9136941,
            100,
            "# 答案正确"
        ],
        [
            "9.3 (C++)",
            "廖雨轩",
            "#include <iostream>\n#include <cmath>\nusing namespace std;\nclass Complex\n{\n    double r, i;\n\npublic:\n    Complex() : r(0.0), i(0.0) {}\n    Complex(double real, double image = 0.0) : r(real), i(image) {}\n    double real() const { return r; }\n    double imag() const { return i; }\n    Complex operator+(const Complex &c2) const;\n    Complex operator-(const Complex &c2) const;\n    Complex operator*(const Complex &c2) const;\n    Complex operator/(const Complex &c2) const;\n    Complex &operator+=(Complex &c1)\n    {\n        r += c1.r;\n        i += c1.i;\n        return *this;\n    }\n    Complex &operator-=(Complex &c1)\n    {\n        r -= c1.r;\n        i -= c1.i;\n        return *this;\n    }\n    Complex &operator*=(Complex &c1)\n    {\n        /*\n    Complex ret;\n    //a+bi * c+di = (ac-bd)+(bc+ad)i\n    ret.r = this->r * c2.r - this->i * c2.i;\n    ret.i = this->i * c2.r + this->r * c2.i;\n    return ret;\n        */\n        double a = this->r, b = this->i;\n        double c = c1.r, d = c1.i;\n        r = (a * c - b * d);\n        i = (b * c + a * d);\n        return *this;\n    }\n    Complex operator/=(Complex &c2)\n    {\n        double a = this->r;\n        double b = this->i;\n        double c = c2.r;\n        double d = c2.i;\n\n        r = (a * c + b * d) / (c * c + d * d);\n        i = (b * c - a * d) / (c * c + d * d);\n        return *this;\n    }\n};\nbool operator==(const Complex &c1, const Complex &c2)\n{\n    return (c1.real() == c2.real()) && (c1.imag() == c2.imag());\n}\nbool operator!=(const Complex &c1, const Complex &c2)\n{\n    return (c1.real() != c2.real()) || (c1.imag() != c2.imag());\n}\nComplex operator+(int r1, Complex &c1)\n{\n    return Complex(r1 + c1.real(), c1.imag());\n}\nComplex operator-(Complex &c1, int r2)\n{\n    return Complex(c1.real() - r2, c1.imag());\n}\nComplex Complex::operator+(const Complex &c2) const\n{\n    Complex ret;\n    ret.r = this->r + c2.r;\n    ret.i = this->i + c2.i;\n    return ret;\n}\nComplex Complex::operator-(const Complex &c2) const\n{\n    Complex ret;\n    ret.r = this->r - c2.r;\n    ret.i = this->i - c2.i;\n    return ret;\n}\nComplex Complex::operator*(const Complex &c2) const\n{\n    Complex ret;\n    //a+bi * c+di = (ac-bd)+(bc+ad)i\n    ret.r = this->r * c2.r - this->i * c2.i;\n    ret.i = this->i * c2.r + this->r * c2.i;\n    return ret;\n}\nComplex Complex::operator/(const Complex &c2) const\n{\n    double a = this->r;\n    double b = this->i;\n    double c = c2.r;\n    double d = c2.i;\n\n    double r1 = (a * c + b * d) / (c * c + d * d);\n    double i1 = (b * c - a * d) / (c * c + d * d);\n    return Complex(r1, i1);\n}",
            1592541163.0020797,
            100,
            "# 答案正确"
        ],
        [
            "9.4 (C++)",
            "廖雨轩",
            "#include <iostream>\nusing namespace std;\nclass Complex\n{\n    double r, i;\n\npublic:\n    Complex() : r(0.0), i(0.0) {}\n    Complex(double real, double image = 0.0) : r(real), i(image) {}\n    double real() const { return r; }\n    double imag() const { return i; }\n\n    Complex operator+(const Complex &c2) const;\n    Complex operator-(const Complex &c2) const;\n};\nComplex Complex::operator+(const Complex &c2) const\n{\n    Complex ret;\n    ret.r = this->r + c2.r;\n    ret.i = this->i + c2.i;\n    return ret;\n}\nComplex Complex::operator-(const Complex &c2) const\n{\n    Complex ret;\n    ret.r = this->r - c2.r;\n    ret.i = this->i - c2.i;\n    return ret;\n}\nostream &operator<<(ostream &out, const Complex &c)\n{\n    //输出虚实\n    out << c.real();\n    if (c.imag() < 0)\n        out << \" + \" << c.imag() << \" i \";\n    else if (c.imag() == 0)\n    {\n    }\n    else if (c.imag() > 0)\n        out << \" + \" << c.imag() << \" i \";\n    return out;\n}\nistream &operator>>(istream &in, Complex &c)\n{\n    double r, i;\n    in >> r >> i; //读入实部 虚部\n    Complex tmp(r, i);\n    c = tmp;\n    return in;\n}",
            1592541794.4781044,
            100,
            "# 答案正确"
        ],
        [
            "9.5 (C++)",
            "廖雨轩",
            "#include <iostream>\nusing namespace std;\nclass Complex\n{\n    double r, i;\n\npublic:\n    Complex() : r(0.0), i(0.0) {}\n    Complex(double real, double image = 0.0) : r(real), i(image) {}\n    double real() const { return r; }\n    double imag() const { return i; }\n\n    Complex operator+(const Complex &c2) const;\n    Complex operator-(const Complex &c2) const;\n    //前置++\n    Complex &operator++()\n    {\n        r++;\n        return *this;\n    }\n    //后置++\n    Complex operator++(int)\n    {\n        Complex prev(r, i);\n        r++;\n        return prev;\n    }\n    operator double() const { return r; }\n};\n\nostream &operator<<(ostream &out, const Complex &c)\n{\n    //输出虚实\n    out << c.real();\n    if (c.imag() < 0)\n        out << \" + \" << c.imag() << \" i \";\n    else if (c.imag() == 0)\n    {\n    }\n    else if (c.imag() > 0)\n        out << \" + \" << c.imag() << \" i \";\n    return out;\n}\nistream &operator>>(istream &in, Complex &c)\n{\n    double r, i;\n    in >> r >> i; //读入实部 虚部\n    Complex tmp(r, i);\n    c = tmp;\n    return in;\n}",
            1592542056.2100801,
            100,
            "# 答案正确"
        ],
        [
            "9.6 (C++)",
            "廖雨轩",
            "#include <vector>\n#include <iostream>\nusing namespace std;\n\nclass Tensor\n{\n    vector<int> sizes;\n    vector<double> values;\n    int _index(const vector<int> &indexes) const\n    {\n        int index = 0;\n        for (int i = 0; i < this->sizes.size(); ++i)\n        {\n            index *= sizes[i];\n            index += indexes[i];\n        }\n        return index;\n    }\n\npublic:\n    int numel() const\n    {\n        if (this->sizes.size() == 0)\n            return 0;\n        int size = 1;\n        for (int i = 0; i < this->sizes.size(); ++i)\n            size *= sizes[i];\n        return size;\n    }\n    Tensor(int x1, int x2, int x3, int x4 = -1)\n    {\n        sizes.push_back(x1);\n        sizes.push_back(x2);\n        sizes.push_back(x3);\n        if (x4 != -1)\n            sizes.push_back(x4);\n        this->values.resize(this->numel());\n        for (int i = 0; i < this->numel(); ++i)\n            this->values[i] = 0;\n    }\n    double &operator()(int x1, int x2, int x3)\n    {\n        vector<int> sz;\n        sz.push_back(x1);\n        sz.push_back(x2);\n        sz.push_back(x3);\n        return values[_index(sz)];\n    }\n    double &operator()(int x1, int x2, int x3, int x4)\n    {\n        vector<int> sz;\n        sz.push_back(x1);\n        sz.push_back(x2);\n        sz.push_back(x3);\n        sz.push_back(x4);\n        return values[_index(sz)];\n    }\n};",
            1592546548.629532,
            100,
            "# 答案正确"
        ],
        [
            "9.7 (C++)",
            "廖雨轩",
            "\n#include <vector>\n#include <iostream>\n#include <fstream>\nusing namespace std;\nclass I\n{\n    vector<int> values;\n\npublic:\n    I(int a, int b = -1, int c = -1, int d = -1)\n    {\n        if (a != -1)\n            values.push_back(a);\n        if (b != -1)\n            values.push_back(b);\n        if (c != -1)\n            values.push_back(c);\n        if (d != -1)\n            values.push_back(d);\n    }\n    operator vector<int>() const { return values; }\n};\nclass Tensor\n{\n    vector<int> sizes;\n    vector<double> values;\n    int _index(const vector<int> &indexes) const\n    {\n        int index = 0;\n        for (int i = 0; i < this->sizes.size(); ++i)\n        {\n            index *= sizes[i];\n            index += indexes[i];\n        }\n        return index;\n    }\n\npublic:\n    Tensor()\n    {\n        sizes.clear();\n        values.clear();\n    }\n    int _size(int index) const\n    {\n        if (index == 0)\n            return sizes[0];\n        if (index == 1)\n            return sizes[1];\n        if (index == 2 && sizes[2] != -1)\n            return sizes[2];\n        if (index == 3 && sizes[3] != -1)\n            return sizes[3];\n        return -1;\n    }\n    int dim() const\n    {\n        return sizes.size();\n    }\n    int numel() const\n    {\n        if (this->sizes.size() == 0)\n            return 0;\n        int size = 1;\n        for (int i = 0; i < this->sizes.size(); ++i)\n            size *= sizes[i];\n        return size;\n    }\n    Tensor(vector<int> sizes)\n    {\n        this->sizes = sizes;\n        this->values.resize(this->numel());\n        for (int i = 0; i < this->numel(); ++i)\n            this->values[i] = 0;\n    }\n    double &get(const vector<int> &indexes)\n    {\n        return values[this->_index(indexes)];\n    }\n    const double &get(const vector<int> &indexes) const\n    {\n        return values[this->_index(indexes)];\n    }\n};\nostream &operator<<(ostream &out, const Tensor &t)\n{\n    out << t.dim() << endl;\n    for (int i = 0; i < t.dim(); ++i)\n        out << t._size(i) << \" \";\n    out << endl;\n    out << endl;\n    if (t.dim() == 3)\n    {\n        for (int i = 0; i < t._size(0); ++i)\n        {\n            for (int j = 0; j < t._size(1); ++j)\n            {\n                for (int k = 0; k < t._size(2); ++k)\n                    out << t.get(I(i, j, k)) << \" \";\n                out << endl;\n            }\n            out << endl;\n        }\n    }\n    else if (t.dim() == 4)\n    {\n        for (int i = 0; i < t._size(0); ++i)\n        {\n            for (int j = 0; j < t._size(1); ++j)\n            {\n                for (int k = 0; k < t._size(2); ++k)\n                {\n                    for (int l = 0; l < t._size(3); ++l)\n                        out << t.get(I(i, j, k, l)) << \" \";\n                    out << endl;\n                }\n                out << endl;\n            }\n        }\n    }\n    return out;\n}\nistream &operator>>(istream &in, Tensor &t)\n{\n    int dim;\n    in >> dim;\n    vector<int> sz;\n    for (int i = 0; i < dim; i++)\n    {\n        int x;\n        in >> x;\n        sz.push_back(x);\n    }\n    Tensor tmp(sz);\n    if (dim == 3)\n    {\n        for (int i = 0; i < sz[0]; ++i)\n            for (int j = 0; j < sz[1]; ++j)\n                for (int k = 0; k < sz[2]; ++k)\n                    in >> tmp.get(I(i, j, k));\n    }\n    else if (dim == 4)\n    {\n        for (int i = 0; i < sz[0]; ++i)\n            for (int j = 0; j < sz[1]; ++j)\n                for (int k = 0; k < sz[2]; ++k)\n                    for (int l = 0; l < sz[3]; ++l)\n                        in >> tmp.get(I(i, j, k, l));\n    }\n    t = tmp;\n    return in;\n}",
            1592549117.0744054,
            100,
            "# 答案正确"
        ],
        [
            "10.1 (C++)",
            "廖雨轩",
            "#include <iostream>\n#include <vector>\n#include <stdexcept>\nusing namespace std;\nclass MatrixSizesDoNotMatchException\n{\n};\ndouble Matrix::get(int row, int column) const\n{\n    int sz = rows * columns;\n    if (row > rows || column > columns)\n        throw out_of_range(\"get wrong\");\n    return elements[(row - 1) * columns + (column - 1)];\n}\nvoid Matrix::set(int row, int column, double value)\n{\n    int r = this->rows, c = this->columns;\n    if (row > r || column > c)\n        throw out_of_range(\"set wrong\");\n    int index = (row - 1) * c + column - 1;\n    this->elements[index] = value;\n}\nMatrix Matrix::operator+(const Matrix &matrix2) const\n{\n    if (this->rows != matrix2.size(1) || this->columns != matrix2.size(2))\n    {\n        throw MatrixSizesDoNotMatchException();\n    }\n    Matrix ret(this->rows, this->columns);\n    for (int i = 0; i < this->rows; i++)\n    {\n        for (int j = 0; j < this->columns; j++)\n        {\n            double sum = this->get(i + 1, j + 1) + matrix2.get(i + 1, j + 1);\n            ret.set(i + 1, j + 1, sum);\n        }\n    }\n    return ret;\n}\n\n\t",
            1593313237.0952272,
            100,
            "# 答案正确"
        ],
        [
            "10.2 (C++)",
            "廖雨轩",
            "        catch (NonPositiveValueException &er)\n        {\n            cout << \"caught: NonPositiveValueException\" << endl;\n        }\n        catch (out_of_range &ex)\n        {\n            cout << \"caught: out_of_range\" << endl;\n        }",
            1593655808.1462102,
            100,
            "# 答案正确"
        ],
        [
            "15.1 (C++)",
            "廖雨轩",
            "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\nclass Table\n{\nprivate:\n    vector<string> header;\n    vector<vector<string>> table;\n    int cols;\n\npublic:\n    Table()\n    {\n        cols = 0;\n    }\n    void addCol(string col)\n    {\n        header.push_back(col);\n    }\n    string json() const\n    {\n        string res = \"{\";\n        res += '\\n';\n        res += \"\theaders: [\";\n        for (auto &h : header)\n        {\n            res += '\\'';\n            res += h;\n            res += '\\'';\n            res += ',';\n        }\n        res += \"],\";\n        res += '\\n';\n        res += \"\trows: [\";\n        res += '\\n';\n        for (int i = 0; i < table.size(); ++i)\n        {\n            res += \"\t\t[\";\n            for (int j = 0; j < table[i].size(); ++j)\n            {\n                res += '\\'';\n                res += table[i][j];\n                res += '\\'';\n                res += ',';\n            }\n            res += \"],\";\n            res += '\\n';\n        }\n        res += \"\t],\";\n        res += '\\n';\n        res += '}';\n        return res;\n    }\n    vector<string> &operator[](int index)\n    {\n        if (cols <= index)\n        {\n            table.push_back(vector<string>());\n            cols++;\n        }\n\n        return table[index];\n    }\n    Table(const Table &table)\n    {\n        cols = table.cols;\n        this->table = table.table;\n    }\n    Table &operator=(const vector<string> vec)\n    {\n        table[cols++] = vec;\n        return *this;\n    }\n};",
            1593750654.5646448,
            100,
            "# 答案正确"
        ],
        [
            "2020-07-09 LAB",
            "廖雨轩",
            "\n#include <iostream>\n#include <vector>\nusing namespace std;\nclass Integer\n{\n\npublic:\n    Integer()\n    {\n        value = 0;\n        m_I.push_back(this);\n    }\n    Integer(int v) : value(v)\n    {\n        m_I.push_back(this);\n    }\n    Integer(const Integer &other) : value(other.value)\n    {\n    }\n    int print() const\n    {\n        return value;\n    }\n    static void increase_all(int x)\n    {\n        for (int i = 0; i < m_I.size(); ++i)\n            m_I[i]->value += x;\n    }\n    operator int() const { return value; }\n\nprivate:\n    int value;\n    static int flag;\n    static vector<Integer *> m_I;\n};\nvector<Integer *> Integer::m_I{};\nistream &operator>>(istream &in, Integer &i)\n{\n    int v;\n    in >> v;\n    Integer tmp(v);\n    i = tmp;\n    return in;\n}\nostream &operator<<(ostream &out, Integer &i)\n{\n    out << i.print();\n    return out;\n}",
            1594264660.3181767,
            100,
            "# 答案正确"
        ],
        [
            "A.1 (C++)",
            "廖雨轩",
            "    void add(int index, const E &e)\n    {\n        if (index < 0 || index > _size)\n            throw NotSuchElementException();\n        Node<E> *curNode = new Node<E>();\n        curNode->element = e;\n        //下一位\n        Node<E> *nextNode = (index == _size ? nullptr : getNode(index));\n        //下下位\n        Node<E> *nextNext = (index + 1 >= _size ? nullptr : getNode(index + 1));\n        //上一位 如果要插入的位置是末尾的后一位\n        Node<E> *prevNode = (nextNode == nullptr ? tail : nextNode->prev_node(nextNext));\n\n        //curNode->update_next_node(nullptr, nextNode);\n        //curNode->update_prev_node(nullptr, prevNode);\n        curNode->update_prev_and_next_node(prevNode, nextNode);\n\n        if (prevNode != nullptr)\n        {\n            prevNode->update_next_node(nextNode, curNode);\n            prevNode->update_prev_and_next_node(prevNode->prev_node(curNode), curNode);\n        }\n        if (nextNode != nullptr)\n        {\n            nextNode->update_prev_node(nextNode->prev_node(nextNext), curNode);\n            nextNode->update_prev_and_next_node(curNode, nextNext);\n        }\n        if (prevNode == nullptr)\n            head = curNode;\n        if (nextNode == nullptr)\n            tail = curNode;\n        ++_size;\n    }\n    void addFirst(const E &e)\n    {\n        add(0, e);\n    }\n    void addLast(const E &e)\n    {\n        add(_size, e);\n    }\n    void addAll(const LinkedList &list, int index = -1)\n    {\n        if (index == -1)\n            index = _size;\n        I(i, list._size)\n        {\n            Node<E> *node = list.getNode(i);\n            add(index + i, node->element);\n        }\n    }\n    LinkedList(const LinkedList &list) : _size(0), head(nullptr), tail(nullptr)\n    {\n        addAll(list);\n    }\n    void clear()\n    {\n        while (_size > 0)\n            removeFirst();\n    }\n    LinkedList &operator=(const LinkedList &list)\n    {\n        clear();\n        addAll(list);\n        return *this;\n    }\n    //getNode\n    Node<E> *getNode(int index) const\n    {\n        if (index < 0 || index >= _size)\n            throw NotSuchElementException();\n        if (index < _size / 2)\n        {\n            Node<E> *node = head;\n            Node<E> *prev = nullptr;\n            Node<E> *temp = nullptr;\n            I(i, index)\n            {\n                temp = node;\n                node = node->next_node(prev);\n                prev = temp;\n            }\n            return node;\n        }\n        else\n        {\n            Node<E> *node = tail;\n            Node<E> *next = nullptr;\n            Node<E> *temp = nullptr;\n            I(i, (_size - 1 - index))\n            {\n                temp = node;\n                node = node->prev_node(next);\n                next = temp;\n            }\n            return node;\n        }\n    }\n    //remove\n    void remove(int index)\n    {\n        Node<E> *curNode = getNode(index);\n        Node<E> *next = (index + 1 >= _size ? nullptr : getNode(index + 1));\n        Node<E> *prev = (index - 1 < 0 ? nullptr : getNode(index - 1));\n        Node<E> *nextNode = curNode->next_node(prev);\n        Node<E> *prevNode = curNode->prev_node(next);\n        if (prevNode != nullptr)\n        {\n            prevNode->update_next_node(curNode, nextNode);\n            prevNode->update_prev_and_next_node(prevNode->prev_node(nextNode), nextNode);\n        }\n        if (nextNode != nullptr)\n        {\n            nextNode->update_prev_node(curNode, prevNode);\n            nextNode->update_prev_and_next_node(prevNode, nextNode->next_node(prevNode));\n        }\n        curNode->update_prev_and_next_node(prevNode, nextNode);\n        if (prevNode == nullptr)\n            head = nextNode;\n        if (nextNode == nullptr)\n            tail = prevNode;\n        delete curNode;\n        --_size;\n    }\n    void removeFirst()\n    {\n        remove(0);\n    }\n    void removeLast()\n    {\n        remove(_size - 1);\n    }\n    int indexOf(const E &e) const\n    {\n        Node<E> *node = head;\n        Node<E> *temp = nullptr;\n        Node<E> *prev = nullptr;\n        I(i, _size)\n        {\n            if (node->element == e)\n                return i;\n            temp = node;\n            node = node->next_node(prev);\n            prev = temp;\n        }\n        return -1;\n    }\n    void removeFirstOccurrence(const E &e)\n    {\n        int index = indexOf(e);\n        if (index == -1)\n            throw NotSuchElementException();\n        remove(index);\n    }\n    //get\n    E &get(int index) const\n    {\n        Node<E> *node = getNode(index);\n        return node->element;\n    }\n    ~LinkedList()\n    {\n        clear();\n    }\n",
            1594381356.5175595,
            100,
            "# 答案正确"
        ],
        [
            "A.2 (C++)",
            "廖雨轩",
            "template <typename E>\nvoid LinkedList<E>::removeAll(const E &e)\n{\n    while (contains(e))\n    {\n        removeFirstOccurrence(e);\n    }\n}",
            1594865511.1891065,
            100,
            "# 答案正确"
        ],
        [
            "A.4 (C++)",
            "廖雨轩",
            "#include <vector>\n#include <unordered_map>\n#include <string>\n#include <algorithm>\nusing namespace std;\nclass NoSuchException\n{\n};\nclass Return\n{\npublic:\n    unordered_map<int, int> int2int;\n    unordered_map<int, string> int2string;\n    unordered_map<string, string> string2string;\n    unordered_map<string, int> string2int;\n    int keyint;\n    string keystr;\n    Return(unordered_map<int, int> i2i, int k) : int2int(i2i), keyint(k) {}\n    Return(unordered_map<int, string> i2s, int k) : int2string(i2s), keyint(k) {}\n    Return(unordered_map<string, string> s2s, string k) : string2string(s2s), keystr(k) {}\n    Return(unordered_map<string, int> s2i, string k) : string2int(s2i), keystr(k) {}\n\n    operator int() const\n    {\n        if (int2int.find(keyint) != int2int.end())\n            return int2int.find(keyint)->second;\n        else if (string2int.find(keystr) != string2int.end())\n            return string2int.find(keystr)->second;\n        else\n            throw NoSuchException();\n    }\n    operator string() const\n    {\n        if (int2string.find(keyint) != int2string.end())\n            return int2string.find(keyint)->second;\n        else if (string2string.find(keystr) != string2string.end())\n            return string2string.find(keystr)->second;\n        else\n            throw NoSuchException();\n    }\n};\nclass HT\n{\n    unordered_map<int, int> int2int;\n    unordered_map<int, string> int2string;\n    unordered_map<string, string> string2string;\n    unordered_map<string, int> string2int;\n    int _size;\n\npublic:\n\t    HT()\n    {\n        _size = 0;\n    }\n    void put(int k, int v)\n    {\n        int2int[k] = v;\n        ++_size;\n    }\n    void put(int k, string v)\n    {\n        int2string[k] = v;\n        ++_size;\n    }\n    void put(string k, string v)\n    {\n        string2string[k] = v;\n        ++_size;\n    }\n    void put(string k, int v)\n    {\n        string2int[k] = v;\n        ++_size;\n    }\n    int size() const\n    {\n        return _size;\n    }\n    Return operator[](const int &key)\n    {\n        if (int2int.find(key) != int2int.end())\n            return Return(int2int, key);\n        else if (int2string.find(key) != int2string.end())\n            return Return(int2string, key);\n        else\n            throw NoSuchException();\n    }\n    Return operator[](const string &key)\n    {\n        if (string2int.find(key) != string2int.end())\n            return Return(string2int, key);\n        else if (string2string.find(key) != string2string.end())\n            return Return(string2string, key);\n        else\n            throw NoSuchException();\n    }\n};\n",
            1595000437.6001508,
            100,
            "# 答案正确"
        ],
        [
            "A.5 (C++)",
            "廖雨轩",
            "#include <vector>\n#include <unordered_map>\n#include <string>\n#include <algorithm>\nusing namespace std;\nclass NoSuchException\n{\n};\nclass Return\n{\npublic:\n    int intValue;\n    string stringValue;\n    int intkeyInUse;\n    string stringkeyInUse;\n    Return(int iV = -1, string sV = \"\", int i = -1, string s = \"\") : intValue(iV), stringValue(sV), intkeyInUse(i), stringkeyInUse(s) {}\n    operator int() const { return intValue; }\n    operator string() const { return stringValue; }\n    Return &operator=(const int &value)\n    {\n        intValue = value;\n        return *this;\n    }\n    Return &operator=(const string &value)\n    {\n        stringValue = value;\n        return *this;\n    }\n};\nclass HT\n{\n    unordered_map<int, int> int2int;\n    unordered_map<int, string> int2string;\n    unordered_map<string, string> string2string;\n    unordered_map<string, int> string2int;\n    int _size;\n    Return re;\n    void inUse()\n    {\n        //int:key is in use\n        if (re.intkeyInUse != -1)\n        {\n            if (re.intValue != -1)\n            {\n                int2int[re.intkeyInUse] = re.intValue;\n                re.intkeyInUse = -1;\n                re.intValue = -1;\n            }\n            else if (re.stringValue != \"\")\n            {\n                int2string[re.intkeyInUse] = re.stringValue;\n                re.stringValue = \"\";\n                re.intkeyInUse = -1;\n            }\n        }\n        else if (re.stringkeyInUse != \"\")\n        {\n            if (re.stringValue != \"\")\n            {\n                string2string[re.stringkeyInUse] = re.stringValue;\n                re.stringValue = \"\";\n                re.stringkeyInUse = \"\";\n            }\n            else if (re.intValue != -1)\n            {\n                string2int[re.stringkeyInUse] = re.intValue;\n                re.stringkeyInUse = \"\";\n                re.intValue = -1;\n            }\n        }\n    }\n\npublic:\n    HT()\n    {\n        _size = 0;\n        re;\n    }\n    void put(int k, int v)\n    {\n        ++_size;\n    }\n    void put(int k, string v)\n    {\n        ++_size;\n    }\n    void put(string k, string v)\n    {\n        ++_size;\n    }\n    void put(string k, int v)\n    {\n        ++_size;\n    }\n    int size() const { return _size; }\n\n    Return &operator[](const string &key)\n    {\n        inUse();\n        if (string2int.find(key) != string2int.end())\n            re.intValue = string2int[key];\n        else if (string2string.find(key) != string2string.end())\n            re.stringValue = string2string[key];\n        else\n        {\n            re.stringkeyInUse = key;\n            ++_size;\n        }\n        return re;\n    }\n    Return &operator[](const int &key)\n    {\n        inUse();\n        //已占用\n        if (int2int.find(key) != int2int.end())\n            re.intValue = int2int[key];\n        else if (int2string.find(key) != int2string.end())\n            re.stringValue = int2string[key];\n        //新建\n        else\n        {\n            re.intkeyInUse = key;\n            ++_size;\n        }\n        return re;\n    }\n};",
            1595040197.7412212,
            100,
            "# 答案正确"
        ],
        [
            "A.3 (C++)",
            "廖雨轩",
            "// put  size containsKey [] getKeys remove\n#include <vector>\n#include <iostream>\n#include <sstream>\nusing namespace std;\nclass NoSuchKeyException\n{\n};\ntemplate <typename E>\nclass HT\n{\n    class Tuple\n    {\n    public:\n        int key;\n        E value;\n        Tuple(int key, E value) : key(key), value(value) {}\n    };\n    vector<Tuple> tuples;\n    int _size;\n\npublic:\n    void put(int key, E value)\n    {\n        Tuple temp(key, value);\n        tuples.push_back(temp);\n        ++_size;\n    }\n    int size() const { return _size; }\n    bool containsKey(const int &key) const\n    {\n        bool flag = false;\n        for (auto &t : tuples)\n        {\n            if (t.key == key)\n            {\n                flag = true;\n                break;\n            }\n        }\n        return flag;\n    }\n    E &operator[](const int &key)\n    {\n        bool flag = false;\n        for (auto &t : tuples)\n        {\n            if (t.key == key)\n            {\n                flag = true;\n                return t.value;\n            }\n        }\n        if (flag == false)\n            throw NoSuchKeyException();\n    }\n    vector<int> getKeys()\n    {\n        vector<int> keys;\n        for (auto &t : tuples)\n        {\n            keys.push_back(t.key);\n        }\n        return keys;\n    }\n    void remove(const int &key)\n    {\n        for (auto &t : tuples)\n        {\n            if (t.key == key)\n            {\n                t.key = -1;\n            }\n        }\n        --_size;\n    }\n};\n",
            1595472066.1781662,
            100,
            "# 答案正确"
        ]
    ],
    "table_name": "答案"
}