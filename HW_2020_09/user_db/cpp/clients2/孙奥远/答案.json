{
    "__update_time__": 1595471366.4878414,
    "field_names": [
        "题目名",
        "用户名",
        "答案",
        "提交时间",
        "分数",
        "评语"
    ],
    "field_types": [
        "text",
        "text",
        "text",
        "time",
        "number",
        "text"
    ],
    "foreign_keys": {},
    "primary_keys": [],
    "rows": [
        [
            "测试1",
            "孙奥远",
            "#include<iostream>\n#include<string>\nusing namespace std;\n\nint main(){\n\tstring s1,s2,s3;\n\tcin >> s1 >> s2 >> s3;\n\tcout << s3 << \" \" << s2 << \" \" << s1 << endl;\n\treturn 0;\n}",
            1587519205.0,
            100,
            "# 答案正确"
        ],
        [
            "测试2",
            "孙奥远",
            "#include <iostream>\nusing namespace std;\n#include <cstring>\n\nint main()\n{\n    char str[10][6], temp[6];\n    char c;\n    for (int i = 0; i < 10; i++)\n    {\n        scanf(\"%s\", str[i]);\n        c = getchar();\n    }\n    for (int i = 0; i < 9; i++)\n    {\n        for (int j = 0; j < 9; j++)\n        {\n            if (strcmp(str[j], str[j + 1]) > 0)\n            {\n                strncpy(temp, str[j], 5);\n                strncpy(str[j], str[j + 1], 5);\n                strncpy(str[j + 1], temp, 5);\n            }\n        }\n    }\n    for (int i = 0; i < 10; i++)\n    {\n        cout << str[i];\n        if (i < 9)\n            cout << \" \";\n        else\n            cout << endl;\n    }\n    return 0;\n}",
            1587609667.0754385,
            100,
            "# 答案正确"
        ],
        [
            "1.1 (C++)",
            "孙奥远",
            "#include <cstring>\nclass Matrix5x5\n{\nprivate:\n    int row;\n    int col;\n    double matrix[5][5];\n\npublic:\n    Matrix5x5();\n    ~Matrix5x5() {}\n    double get(int x, int y) { return matrix[x][y]; }\n    void set(int x, int y, double value);\n    Matrix5x5 operator+(Matrix5x5 &);\n};\n\nMatrix5x5::Matrix5x5()\n{\n    memset(this->matrix, 0, sizeof(this->matrix));\n}\n\nvoid Matrix5x5::set(int x, int y, double value)\n{\n    matrix[x][y] = value;\n}\n\nMatrix5x5 Matrix5x5::operator+(Matrix5x5 &m)\n{\n    Matrix5x5 ans;\n    for (int i = 0; i < 5; i++)\n    {\n        for (int j = 0; j < 5; j++)\n        {\n            ans.matrix[i][j] = this->matrix[i][j] + m.matrix[i][j];\n        }\n    }\n    return ans;\n}\n",
            1587696865.7914612,
            100,
            "# 答案正确"
        ],
        [
            "1.2 (C++)",
            "孙奥远",
            "#include <iostream>\n#include<cstring>\nusing namespace std;\n\nclass School\n{\nprivate:\n    char name[20];\n    int age;\n\npublic:\n    ~School(){};\n    School();\n    void setName(char n[]);\n    void setAge(int year);\n    void operator++();\n\tfriend void print(School & school);\n};\n\nSchool::School()\n{\n    strcpy(name, \"NO_NAME\");\n    age = 0;\n}\n\nvoid School::setName(char n[])\n{\n    strcpy(name, n);\n}\n\nvoid School::setAge(int year)\n{\n    age = year;\n}\n\nvoid School::operator++()\n{\n    age++;\n}\n",
            1588213750.174413,
            100,
            "# 答案正确"
        ],
        [
            "2.1 (C++)",
            "孙奥远",
            "#include<iostream>\n#include<cstring>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    double**values;\npublic:\n    Matrix(int rows,int columns);\n    ~Matrix();\n    void print();\n};\n\nMatrix::Matrix(int rows,int columns)\n{\n    this->rows = rows;\n    this->columns = columns;\n    values = new double* [rows];\n    for(int i = 0;i < rows;i++)\n    {\n        values[i] = new double [columns];\n        for(int j = 0;j < columns;j++)\n            values[i][j] = 0;\n    }\n}\n\nMatrix::~Matrix()\n{\n    for(int i = 0;i < rows;i++)\n        delete [] values[i];\n    delete [] values;\n}\n\nvoid Matrix::print()\n{\n    for(int i = 0;i < rows;i++)\n    {\n        for(int j = 0;j < columns;j++)\n            cout << \"    \" << values[i][j];\n        cout << endl;\n    }\n}",
            1588825588.0986283,
            100,
            "# 答案正确"
        ],
        [
            "2.2 (C++)",
            "孙奥远",
            "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    double **values;\n\npublic:\n    Matrix(int rows, int columns, double values[]);\n    ~Matrix();\n    void print();\n};\n\nMatrix::Matrix(int rows, int columns, double val[])\n{\n    this->rows = rows;\n    this->columns = columns;\n    this->values = new double *[rows];\n    for (int i = 0; i < rows; i++)\n    {\n        this->values[i] = new double[columns];\n        for (int j = 0; j < columns; j++)\n        {\n            values[i][j] = val[i * columns + j];\n        }\n    }\n}\n\nMatrix::~Matrix()\n{\n    for (int i = 0; i < rows; i++)\n    {\n        delete[] values[i];\n    }\n    delete[] values;\n}\n\nvoid Matrix::print()\n{\n    for (int i = 0; i < rows; i++)\n    {\n        for (int j = 0; j < columns; j++)\n        {\n            cout << setw(5) << values[i][j];\n        }\n        cout << endl;\n    }\n}",
            1588826440.4969926,
            100,
            "# 答案正确"
        ],
        [
            "2.3 (C++)",
            "孙奥远",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    double **values;\n\npublic:\n    Matrix(int rows, int columns, double values[]);\n    ~Matrix();\n    Matrix(const Matrix&matrix2);\n    void print();\n};\n\nMatrix::Matrix(int rows, int columns, double val[])\n{\n    this->rows = rows;\n    this->columns = columns;\n    this->values = new double *[rows];\n    for (int i = 0; i < rows; i++)\n    {\n        this->values[i] = new double[columns];\n        for (int j = 0; j < columns; j++)\n        {\n            values[i][j] = val[i * columns + j];\n        }\n    }\n}\n\nMatrix::~Matrix()\n{\n    for (int i = 0; i < rows; i++)\n    {\n        delete[] values[i];\n    }\n    delete[] values;\n}\n\nvoid Matrix::print()\n{\n    for (int i = 0; i < rows; i++)\n    {\n        for (int j = 0; j < columns; j++)\n        {\n            cout << \"    \" << values[i][j];\n        }\n        cout << endl;\n    }\n}\n\nMatrix::Matrix(const Matrix&matrix2)\n{\n    rows = matrix2.rows;\n    columns = matrix2.columns;\n    values = new double* [rows];\n    for(int i = 0;i < rows;i++)\n    {\n        values[i] = new double [columns];\n        for(int j = 0;j < columns;j++)\n        {\n            values[i][j] = matrix2.values[i][j];\n        }\n    }\n}",
            1588827254.4722953,
            100,
            "# 答案正确"
        ],
        [
            "2.5 (C++)",
            "孙奥远",
            "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    double **values;\n\npublic:\n    Matrix(int rows, int columns);\n    Matrix(int rows, int columns, double val[]);\n    ~Matrix();\n    Matrix getRow(int row);\n    Matrix getColumn(int column);\n    void print();\n};\n\nMatrix::Matrix(int rows, int columns)\n{\n    this->rows = rows;\n    this->columns = columns;\n    values = new double *[rows];\n    for (int i = 0; i < rows; i++)\n    {\n        values[i] = new double[columns];\n        memset(values[i], 0, sizeof(double) * columns);\n    }\n}\nMatrix::Matrix(int rows, int columns, double val[])\n{\n    this->rows = rows;\n    this->columns = columns;\n    this->values = new double *[rows];\n    for (int i = 0; i < rows; i++)\n    {\n        this->values[i] = new double[columns];\n        for (int j = 0; j < columns; j++)\n        {\n            values[i][j] = val[i * columns + j];\n        }\n    }\n}\n\nMatrix Matrix::getRow(int row)\n{\n    Matrix temp(1, columns);\n    for (int i = 0; i < columns; i++)\n    {\n        temp.values[0][i] = values[row - 1][i];\n    }\n    return temp;\n}\n\nMatrix Matrix::getColumn(int column)\n{\n    Matrix temp(rows, 1);\n    for (int i = 0; i < rows; i++)\n    {\n        temp.values[i][0] = values[i][column - 1];\n    }\n    return temp;\n}\nMatrix::~Matrix()\n{\n    for (int i = 0; i < rows; i++)\n    {\n        delete[] values[i];\n    }\n    delete[] values;\n}\n\nvoid Matrix::print()\n{\n    for (int i = 0; i < rows; i++)\n    {\n        for (int j = 0; j < columns; j++)\n        {\n            cout << \"    \" << values[i][j];\n        }\n        cout << endl;\n    }\n}",
            1588832961.660821,
            100,
            "# 答案正确"
        ],
        [
            "2.6 (C++)",
            "孙奥远",
            "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    double **values;\n\npublic:\n    Matrix(int rows, int columns, double val[]);\n    Matrix(const Matrix &matrix2);\n    ~Matrix();\n    void print();\n    Matrix concatenateRows(const Matrix &matrix2) const;\n    Matrix concatenateColumns(const Matrix &matrix2) const;\n};\n\nMatrix::Matrix(int rows, int columns, double val[])\n{\n    this->rows = rows;\n    this->columns = columns;\n    values = new double *[this->rows];\n    for (int i = 0; i < rows; i++)\n    {\n        values[i] = new double[columns];\n        for (int j = 0; j < columns; j++)\n            values[i][j] = val[i * columns + j];\n    }\n}\n\nMatrix::Matrix(const Matrix &matrix2)\n{\n    this->rows = matrix2.rows;\n    this->columns = matrix2.columns;\n    values = new double *[this->rows];\n    for (int i = 0; i < this->rows; i++)\n    {\n        values[i] = new double[this->columns];\n        for (int j = 0; j < this->columns; j++)\n        {\n            values[i][j] = matrix2.values[i][j];\n        }\n    }\n}\n\nMatrix::~Matrix()\n{\n    for (int i = 0; i < rows; i++)\n        delete[] values[i];\n    delete[] values;\n}\n\nvoid Matrix::print()\n{\n    for (int i = 0; i < rows; i++)\n    {\n        for (int j = 0; j < columns; j++)\n        {\n            cout << \"    \" << values[i][j];\n        }\n        cout << endl;\n    }\n}\n\nMatrix Matrix::concatenateRows(const Matrix &matrix2) const\n{\n    double val[(rows + matrix2.rows) * columns];\n    int index;\n    for (int i = 0; i < rows; i++)\n    {\n        for (int j = 0; j < columns; j++)\n        {\n            val[i * columns + j] = values[i][j];\n            index = i * columns + j;\n        }\n    }\n    for (int i = 0; i < matrix2.rows; i++)\n    {\n        for (int j = 0; j < matrix2.columns; j++)\n        {\n            val[index + 1 + i * matrix2.columns + j] = matrix2.values[i][j];\n        }\n    }\n    return Matrix(rows + matrix2.rows, columns, val);\n}\n\nMatrix Matrix::concatenateColumns(const Matrix &matrix2) const\n{\n    double val[rows*(columns+matrix2.columns)];\n    double matrix[rows][columns+matrix2.columns];\n    for(int i = 0;i < rows;i++)\n    {\n        for (int j = 0; j < columns; j++)\n            matrix[i][j] = values[i][j];\n    }\n    for(int i = 0;i < rows;i++)\n    {\n        for (int j = 0; j < matrix2.columns; j++)\n        {\n            matrix[i][columns + j] = matrix2.values[i][j];\n        }\n    }\n    for(int i = 0;i < rows;i++)\n    {\n        for (int j = 0; j < columns + matrix2.columns; j++)\n        {\n            val[i * (columns + matrix2.columns) + j] = matrix[i][j];\n        }\n    }\n    return Matrix(rows,columns+matrix2.columns,val);\n}",
            1588851825.531116,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/08",
            "孙奥远",
            "double &Tensor_get(int dimensions, const int sizes[], double data[], int x0, int x1, int x2, int x3)\n{\n    if (dimensions == 1)\n        return data[x0];\n    if (dimensions == 2)\n        return data[x0 * sizes[1] + x1];\n    if (dimensions == 3)\n        return data[x0 * sizes[2] * sizes[1] + x1 * sizes[2] + x2];\n    if (dimensions == 4)\n        return data[x0 * sizes[3] * sizes[2] * sizes[1] + x1 * sizes[3] * sizes[2] + x2 * sizes[3] + x3];\n}",
            1588906286.0529304,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/14",
            "孙奥远",
            "#include<iostream>\nusing namespace std;\nvoid Tensor_print(int dimensions, const int sizes[], const double data[])\n{\n    if(dimensions == 1)\n    {\n        cout << \"Tensor of \" << sizes[0] <<endl;\n        for(int i = 0;i < sizes[0];i++)\n        {\n            cout << data[i] << endl;\n        }\n    }\n    else if(dimensions == 2)\n    {\n        cout << \"Tensor of \" << sizes[0] << \"x\" << sizes[1] << endl;\n        for(int i = 0; i < sizes[0];i++)\n        {\n            for(int j = 0;j < sizes[1];j++)\n            {\n                cout << \"    \" << data[i*sizes[1]+j];\n            }\n            cout << endl;\n        }\n    }\n    else if(dimensions == 3)\n    {\n        cout << \"Tensor of \" << sizes[0] << \"x\" <<sizes[1] << \"x\" << sizes[2] << endl;\n        for(int i = 0;i < sizes[0];i++)\n        {\n            cout << \"data[\" << i << \"]\" << endl;\n            for(int j = 0;j < sizes[1];j++)\n            {\n                for(int k = 0;k < sizes[2];k++)\n                {\n                    cout << \"    \" << data[i*sizes[0]+j*sizes[1]+k];\n                }\n                cout << endl;\n            }\n        }\n    }\n    else if(dimensions == 4)\n    {\n\t\tcout << \"Tensor of \" << sizes[0] << \"x\" <<sizes[1] << \"x\" << sizes[2] << \"x\" << sizes[3] << endl;\n        for(int i = 0;i < sizes[0];i++)\n        {\n            for(int j = 0;j < sizes[1];j++)\n            {\n                cout << \"data[\" << i << \"]\" << \"[\" << j << \"]\" << endl;\n                for(int k = 0;k < sizes[2];k++)\n                {\n                    for(int m = 0;m < sizes[3];m++)\n                    {\n                        cout << \"    \" << data[i*sizes[0]+j*sizes[1]+k*sizes[2]+m];\n                    }\n                    cout << endl;\n                }\n            }\n        }\n    }\n}",
            1589424044.4466288,
            100,
            "# 答案正确"
        ],
        [
            "2.4 (C++)",
            "孙奥远",
            "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble *values;\n\npublic:\n\tMatrix(int rows, int columns);\n\tMatrix(int rows, int columns, double values[]);\n\t~Matrix();\n\tvoid print();\n\tvoid set(int row, int column, double value);\n\tvoid operator=(Matrix &matrix2);\n};\n\nMatrix::Matrix(int rows, int columns)\n{\n\tthis->rows = rows;\n\tthis->columns = columns;\n\tif (rows * columns == 0)\n\t\tvalues = 0;\n\telse\n\t{\n\t\tvalues = new double[rows * columns];\n\t\tmemset(values, 0, sizeof(double) * rows * columns);\n\t}\n}\n\nMatrix::Matrix(int rows, int columns, double values[])\n{\n\tthis->rows = rows;\n\tthis->columns = columns;\n\tthis->values = new double[rows * columns];\n\tfor (int i = 0; i < rows * columns; i++)\n\t{\n\t\tthis->values[i] = values[i];\n\t}\n}\n\nMatrix::~Matrix()\n{\n\tdelete[] values;\n}\n\nvoid Matrix::print()\n{\n\tfor (int i = 0; i < rows; i++)\n\t{\n\t\tfor (int j = 0; j < columns; j++)\n\t\t{\n\t\t\tcout << \"    \" << values[i * columns + j];\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nvoid Matrix::set(int row, int column, double value)\n{\n\tvalues[(row - 1) * columns + column - 1] = value;\n}\n\nvoid Matrix::operator=(Matrix &matrix2)\n{\n\trows = matrix2.rows;\n\tcolumns = matrix2.columns;\n\tif (values != 0)\n\t\tdelete[] values;\n\tvalues = new double[rows * columns];\n\tfor (int i = 0; i < rows; i++)\n\t{\n\t\tfor (int j = 0; j < columns; j++)\n\t\t{\n\t\t\tvalues[i * columns + j] = matrix2.values[i * columns + j];\n\t\t}\n\t}\n}",
            1589515006.9460912,
            100,
            "# 答案正确"
        ],
        [
            "2.7 (C++)",
            "孙奥远",
            "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble *values;\n\npublic:\n\tMatrix(int rows, int columns, double values[]);\n\t~Matrix();\n\tvoid print();\n\tMatrix reshape(int rows, int columns) const;\n};\n\nMatrix Matrix::reshape(int rows, int columns) const\n{\n\tdouble v[rows*columns];\n\tfor(int i = 0;i < rows;i++)\n\t{\n\t\tfor(int j = 0;j < columns;j++)\n\t\t{\n\t\t\tint index1 = j * rows + i;\n\t\t\tint num = i * columns + j + 1;\n\t\t\tint a = num % rows,b;\n\t\t\tif(a == 0)\n\t\t\t{\n\t\t\t\ta = rows;\n\t\t\t\tb = num / rows;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tb = num / rows + 1;\n\t\t\t}\n\t\t\tint index2 = (a - 1)*columns + b - 1;\n\t\t\tv[index2] = values[index1];\n\t\t}\n\t}\n\treturn Matrix(rows,columns,v);\n}\n\nMatrix::Matrix(int rows, int columns, double values[])\n{\n\tthis->rows = rows;\n\tthis->columns = columns;\n\tthis->values = new double[rows * columns];\n\tfor (int i = 0; i < rows * columns; i++)\n\t{\n\t\tthis->values[i] = values[i];\n\t}\n}\n\nMatrix::~Matrix()\n{\n\tdelete[] values;\n}\n\nvoid Matrix::print()\n{\n\tfor (int i = 0; i < rows; i++)\n\t{\n\t\tfor (int j = 0; j < columns; j++)\n\t\t{\n\t\t\tcout << \"    \" << values[i * columns + j];\n\t\t}\n\t\tcout << endl;\n\t}\n}",
            1589551637.1652877,
            100,
            "# 答案正确"
        ],
        [
            "2.8 (C++)",
            "孙奥远",
            "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble *values;\n\npublic:\n\tMatrix(int rows, int columns, double values[]);\n\t~Matrix();\n\tvoid print();\n\tMatrix transpose();\n};\n\nMatrix Matrix::transpose()\n{\n\tdouble v[rows*columns];\n\tfor(int i = 0;i < rows;i++)\n\t{\n\t\tfor(int j = 0;j < columns;j++)\n\t\t{\n\t\t\tv[j*rows+i] = values[i*columns+j];\n\t\t}\n\t}\n\treturn Matrix(columns,rows,v);\n}\n\nMatrix::Matrix(int rows, int columns, double values[])\n{\n\tthis->rows = rows;\n\tthis->columns = columns;\n\tthis->values = new double[rows * columns];\n\tfor (int i = 0; i < rows * columns; i++)\n\t{\n\t\tthis->values[i] = values[i];\n\t}\n}\n\nMatrix::~Matrix()\n{\n\tdelete[] values;\n}\n\nvoid Matrix::print()\n{\n\tfor (int i = 0; i < rows; i++)\n\t{\n\t\tfor (int j = 0; j < columns; j++)\n\t\t{\n\t\t\tcout << \"    \" << values[i * columns + j];\n\t\t}\n\t\tcout << endl;\n\t}\n}\n",
            1589552165.9750617,
            100,
            "# 答案正确"
        ],
        [
            "2.10 (C++)",
            "孙奥远",
            "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble *values;\n\npublic:\n\tMatrix(int rows, int columns, double values[]);\n\t~Matrix();\n\tvoid print();\n\tMatrix operator*(const Matrix &matrix2) const;\n\tMatrix operator*(double value) const;\n};\nMatrix Matrix::operator*(double value) const\n{\n\tdouble v[rows * columns];\n\tfor (int i = 0; i < rows * columns; i++)\n\t{\n\t\tv[i] = values[i] * value;\n\t}\n\treturn Matrix(rows,columns,v);\n}\nMatrix Matrix::operator*(const Matrix &matrix2) const\n{\n\tdouble v[rows * matrix2.columns];\n\tfor (int i = 0; i < rows; i++)\n\t{\n\t\tfor (int j = 0; j < matrix2.columns; j++)\n\t\t{\n\t\t\tint sum = 0;\n\t\t\tfor (int k = 0; k < columns; k++)\n\t\t\t{\n\t\t\t\tsum += values[i * columns + k] * matrix2.values[k * matrix2.columns + j];\n\t\t\t}\n\t\t\tv[i * rows + j] = sum;\n\t\t}\n\t}\n\treturn Matrix(rows, matrix2.columns, v);\n}\n\nMatrix::Matrix(int rows, int columns, double values[])\n{\n\tthis->rows = rows;\n\tthis->columns = columns;\n\tthis->values = new double[rows * columns];\n\tfor (int i = 0; i < rows * columns; i++)\n\t{\n\t\tthis->values[i] = values[i];\n\t}\n}\n\nMatrix::~Matrix()\n{\n\tdelete[] values;\n}\n\nvoid Matrix::print()\n{\n\tfor (int i = 0; i < rows; i++)\n\t{\n\t\tfor (int j = 0; j < columns; j++)\n\t\t{\n\t\t\tcout << \"    \" << values[i * columns + j];\n\t\t}\n\t\tcout << endl;\n\t}\n}\n",
            1589552787.2609808,
            100,
            "# 答案正确"
        ],
        [
            "2.11 (C++)",
            "孙奥远",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble *values;\n\npublic:\n\tMatrix(int rows, int columns, double values[]);\n\t~Matrix();\n\tvoid print();\n\tMatrix max() const;\n\tMatrix min() const;\n\tMatrix sum() const;\n};\n\nMatrix Matrix::max() const\n{\n\tif (rows == 1)\n\t{\n\t\tdouble max[1], m = values[0];\n\t\tfor (int i = 1; i < columns; i++)\n\t\t{\n\t\t\tif (m < values[i])\n\t\t\t\tm = values[i];\n\t\t}\n\t\tmax[0] = m;\n\t\treturn Matrix(1, 1, max);\n\t}\n\telse\n\t{\n\t\tdouble max[columns];\n\t\tfor (int i = 0; i < columns; i++)\n\t\t{\n\t\t\tmax[i] = values[i];\n\t\t\tfor (int j = 1; j < rows; j++)\n\t\t\t{\n\t\t\t\tif (max[i] < values[j * columns + i])\n\t\t\t\t\tmax[i] = values[j * columns + i];\n\t\t\t}\n\t\t}\n\t\treturn Matrix(1, columns, max);\n\t}\n}\n\nMatrix Matrix::min() const\n{\n\tif (rows == 1)\n\t{\n\t\tdouble min[1], m = values[0];\n\t\tfor (int i = 1; i < columns; i++)\n\t\t{\n\t\t\tif (m > values[i])\n\t\t\t\tm = values[i];\n\t\t}\n\t\tmin[0] = m;\n\t\treturn Matrix(1, 1, min);\n\t}\n\telse\n\t{\n\t\tdouble min[columns];\n\t\tfor (int i = 0; i < columns; i++)\n\t\t{\n\t\t\tmin[i] = values[i];\n\t\t\tfor (int j = 1; j < rows; j++)\n\t\t\t{\n\t\t\t\tif (min[i] > values[j * columns + i])\n\t\t\t\t\tmin[i] = values[j * columns + i];\n\t\t\t}\n\t\t}\n\t\treturn Matrix(1, columns, min);\n\t}\n}\n\nMatrix Matrix::sum() const\n{\n\tif (rows == 1)\n\t{\n\t\tdouble sum[1], s = 0;\n\t\tfor (int i = 0; i < columns; i++)\n\t\t{\n\t\t\ts += values[i];\n\t\t}\n\t\tsum[0] = s;\n\t\treturn Matrix(1, 1, sum);\n\t}\n\telse\n\t{\n\t\tdouble sum[columns];\n\t\tfor (int i = 0; i < columns; i++)\n\t\t{\n\t\t\tsum[i] = 0;\n\t\t\tfor (int j = 0; j < rows; j++)\n\t\t\t{\n\t\t\t\tsum[i] += values[j * columns + i];\n\t\t\t}\n\t\t}\n\t\treturn Matrix(1, columns, sum);\n\t}\n}\nMatrix::Matrix(int rows, int columns, double values[])\n{\n\tthis->rows = rows;\n\tthis->columns = columns;\n\tthis->values = new double[rows * columns];\n\tfor (int i = 0; i < rows * columns; i++)\n\t{\n\t\tthis->values[i] = values[i];\n\t}\n}\n\nMatrix::~Matrix()\n{\n\tdelete[] values;\n}\n\nvoid Matrix::print()\n{\n\tfor (int i = 0; i < rows; i++)\n\t{\n\t\tfor (int j = 0; j < columns; j++)\n\t\t{\n\t\t\tcout << \"    \" << values[i * columns + j];\n\t\t}\n\t\tcout << endl;\n\t}\n}",
            1589553821.9359088,
            100,
            "# 答案正确"
        ],
        [
            "2.12 (C++)",
            "孙奥远",
            "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble *values;\n\npublic:\n\tMatrix(int rows, int columns, double values[]);\n\t~Matrix();\n\tvoid print();\n\tMatrix(const Matrix &matrix2);\n\tMatrix pow(double exponent);\n\tMatrix exp();\n\tMatrix log();\n\tMatrix abs();\n};\nMatrix Matrix::abs()\n{\n\tdouble v[rows * columns];\n\tfor (int i = 0; i < rows * columns; i++)\n\t{\n\t\tv[i] = std::abs(values[i]);\n\t}\n\treturn Matrix(rows, columns, v);\n}\nMatrix Matrix::log()\n{\n\tdouble v[rows * columns];\n\tfor (int i = 0; i < rows * columns; i++)\n\t{\n\t\tv[i] = std::log(values[i]);\n\t}\n\treturn Matrix(rows, columns, v);\n}\nMatrix Matrix::pow(double exponent)\n{\n\tdouble v[rows * columns];\n\tfor (int i = 0; i < rows * columns; i++)\n\t{\n\t\tv[i] = std::pow(values[i], exponent);\n\t}\n\treturn Matrix(rows, columns, v);\n}\n\nMatrix Matrix::exp()\n{\n\tdouble v[rows * columns];\n\tfor (int i = 0; i < rows * columns; i++)\n\t{\n\t\tv[i] = std::exp(values[i]);\n\t}\n\treturn Matrix(rows, columns, v);\n}\n\nMatrix::Matrix(const Matrix &matrix2)\n{\n\tthis->rows = matrix2.rows;\n\tthis->columns = matrix2.columns;\n\tthis->values = new double[rows * columns];\n\tfor (int i = 0; i < rows * columns; i++)\n\t{\n\t\tthis->values[i] = matrix2.values[i];\n\t}\n}\nMatrix::Matrix(int rows, int columns, double values[])\n{\n\tthis->rows = rows;\n\tthis->columns = columns;\n\tthis->values = new double[rows * columns];\n\tfor (int i = 0; i < rows * columns; i++)\n\t{\n\t\tthis->values[i] = values[i];\n\t}\n}\n\nMatrix::~Matrix()\n{\n\tdelete[] values;\n}\n\nvoid Matrix::print()\n{\n\tfor (int i = 0; i < rows; i++)\n\t{\n\t\tfor (int j = 0; j < columns; j++)\n\t\t{\n\t\t\tcout << \"    \" << values[i * columns + j];\n\t\t}\n\t\tcout << endl;\n\t}\n}",
            1589554771.5644064,
            100,
            "# 答案正确"
        ],
        [
            "2.9 (C++)",
            "孙奥远",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    double *values;\n\npublic:\n    Matrix(int rows, int columns, double values[]);\n    Matrix(const Matrix &matrix2);\n    ~Matrix();\n    void print();\n    Matrix operator+(const Matrix &matrix2) const;\n    Matrix operator+(double value) const;\n    Matrix operator-(const Matrix &matrix2) const;\n    Matrix operator-(double value) const;\n};\n\nMatrix::Matrix(int rows, int columns, double values[])\n{\n    this->rows = rows;\n    this->columns = columns;\n    this->values = new double[rows * columns];\n    for (int i = 0; i < rows * columns; i++)\n        this->values[i] = values[i];\n}\n\nMatrix::Matrix(const Matrix &matrix2)\n{\n    this->rows = matrix2.rows;\n    this->columns = matrix2.columns;\n    this->values = new double[this->rows * this->columns];\n    for (int i = 0; i < this->rows * this->columns; i++)\n        this->values[i] = matrix2.values[i];\n}\n\nMatrix::~Matrix()\n{\n    delete[] this->values;\n}\n\nvoid Matrix::print()\n{\n    for (int i = 0; i < rows; i++)\n    {\n        for (int j = 0; j < columns; j++)\n        {\n            cout << \"    \" << values[i * columns + j];\n        }\n        cout << endl;\n    }\n}\n\nMatrix Matrix::operator+(const Matrix &matrix2) const\n{\n    double v[rows * columns];\n    for (int i = 0; i < rows * columns; i++)\n    {\n        v[i] = this->values[i] + matrix2.values[i];\n    }\n    return Matrix(rows, columns, v);\n}\n\nMatrix Matrix::operator+(double value) const\n{\n    double v[rows * columns];\n    for (int i = 0; i < rows * columns; i++)\n    {\n        v[i] = value + this->values[i];\n    }\n    return Matrix(rows, columns, v);\n}\n\nMatrix Matrix::operator-(const Matrix &matrix2) const\n{\n    double v[rows * columns];\n    for (int i = 0; i < rows * columns; i++)\n    {\n        v[i] = this->values[i] - matrix2.values[i];\n    }\n    return Matrix(rows, columns, v);\n}\nMatrix Matrix::operator-(double value) const\n{\n    double v[rows * columns];\n    for (int i = 0; i < columns * rows; i++)\n    {\n        v[i] = this->values[i] - value;\n    }\n    return Matrix(rows, columns, v);\n}",
            1590028746.775717,
            100,
            "# 答案正确"
        ],
        [
            "6.1 (C++)",
            "孙奥远",
            "#include <iostream>\n#include <cstring>\n#include <string>\nusing namespace std;\n\ntemplate <typename T>\nclass Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    T *values;\n\npublic:\n    Matrix(int rows, int columns);\n    Matrix(int rows, int columns, const T *values);\n    ~Matrix();\n    void print() const;\n    Matrix(const Matrix &matrix2);\n    Matrix &operator=(const Matrix &matrix2);\n    T &get(int row, int column);\n};\n\ntemplate <typename T>\nMatrix<T>::Matrix(int rows, int columns)\n{\n    this->rows = rows;\n    this->columns = columns;\n    this->values = new T[rows * columns];\n    memset(this->values,0,sizeof(T)*rows*columns);\n}\n\ntemplate <typename T>\nMatrix<T>::Matrix(int rows, int columns, const T *values)\n{\n    this->rows = rows;\n    this->columns = columns;\n    this->values = new T[rows * columns];\n    for(int i = 0;i < rows*columns;i++)\n    {\n        this->values[i] = values[i];\n    }\n}\n\ntemplate <typename T>\nMatrix<T>::~Matrix()\n{\n    delete[] values;\n}\n\ntemplate <typename T>\nvoid Matrix<T>::print() const\n{\n    for (int i = 0; i < rows; i++)\n    {\n        for (int j = 0; j < columns; j++)\n        {\n            cout << \"    \" << values[i * columns + j];\n        }\n        cout << endl;\n    }\n}\n\ntemplate <typename T>\nMatrix<T>::Matrix(const Matrix<T> &matrix2)\n{\n    this->rows = matrix2.rows;\n    this->columns = matrix2.columns;\n    this->values = new T[rows * columns];\n    for(int i = 0;i < rows*columns;i++)\n    {\n        this->values[i] = matrix2.values[i];\n    }\n}\n\ntemplate <typename T>\nMatrix<T> &Matrix<T>::operator=(const Matrix<T> &matrix2)\n{\n    this->rows = matrix2.rows;\n    this->columns = matrix2.columns;\n    delete[] this->values;\n    this->values = new T[rows * columns];\n    for(int i = 0;i < rows*columns;i++)\n    {\n        this->values[i] = matrix2.values[i];\n    }\n    return *this;\n}\n\ntemplate <typename T>\nT &Matrix<T>::get(int row, int column)\n{\n    return this->values[(row - 1) * columns + column - 1];\n}",
            1590158570.0139127,
            100,
            "# 答案正确"
        ],
        [
            "6.3 (C++)",
            "孙奥远",
            "#include <iostream>\n#include <vector>\nusing namespace std;\n#define MAX 1000000\n#define MIN -1000000\n\ntemplate <typename T>\nclass Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    vector<T> values;\n\npublic:\n    Matrix(int rows, int columns);\n    void print();\n    Matrix(int rows, int columns, vector<T> v);\n    Matrix(const Matrix &matrix2);\n    T &get(int row, int column);\n    Matrix &operator=(const Matrix &matrix2);\n    Matrix getColumn(int column);\n    Matrix getRow(int row);\n    Matrix concatenateRows(const Matrix &matrix2);\n    Matrix concatenateColumns(const Matrix &matrix2);\n    Matrix reshape(int columns, int rows);\n    Matrix transpose();\n    Matrix operator+(const Matrix &matrix2);\n    Matrix operator+(int value);\n    Matrix operator-(const Matrix &matrix2);\n    Matrix operator-(int value);\n    Matrix operator*(const Matrix &matrix2);\n    Matrix operator*(int value);\n    Matrix max();\n    Matrix min();\n    Matrix sum();\n};\ntemplate <typename T>\nMatrix<T>::Matrix(int rows, int columns)\n{\n    this->rows = rows;\n    this->columns = columns;\n    for (int i = 0; i < rows * columns; i++)\n    {\n        this->values.push_back(0);\n    }\n}\n\ntemplate <typename T>\nvoid Matrix<T>::print()\n{\n    for (int i = 0; i < rows; i++)\n    {\n        for (int j = 0; j < columns; j++)\n        {\n            cout << \"    \" << values[i * columns + j];\n        }\n        cout << endl;\n    }\n}\n\ntemplate <typename T>\nMatrix<T>::Matrix(int rows, int columns, vector<T> v)\n{\n    this->rows = rows;\n    this->columns = columns;\n    for (int i = 0; i < rows * columns; i++)\n    {\n        this->values.push_back(v[i]);\n    }\n}\n\ntemplate <typename T>\nMatrix<T>::Matrix(const Matrix<T> &matrix2)\n{\n    this->rows = matrix2.rows;\n    this->columns = matrix2.columns;\n    for (int i = 0; i < rows * columns; i++)\n    {\n        this->values.push_back(matrix2.values[i]);\n    }\n}\n\ntemplate <typename T>\nT &Matrix<T>::get(int row, int column)\n{\n    return this->values[(row - 1) * columns + column - 1];\n}\n\ntemplate <typename T>\nMatrix<T> &Matrix<T>::operator=(const Matrix<T> &matrix2)\n{\n    this->rows = matrix2.rows;\n    this->columns = matrix2.columns;\n    while (this->values.size() > 0)\n    {\n        this->values.pop_back();\n    }\n    for (int i = 0; i < matrix2.rows * matrix2.columns; i++)\n    {\n        this->values.push_back(matrix2.values[i]);\n    }\n    return *this;\n}\n\ntemplate <typename T>\nMatrix<T> Matrix<T>::getColumn(int column)\n{\n    vector<T> temp;\n    for (int i = 0; i < rows; i++)\n    {\n        temp.push_back(this->values[columns * i + column - 1]);\n    }\n    return Matrix(rows, 1, temp);\n}\ntemplate <typename T>\nMatrix<T> Matrix<T>::getRow(int row)\n{\n    vector<T> temp;\n    for (int i = 0; i < columns; i++)\n    {\n        temp.push_back(this->values[columns * (row - 1) + i]);\n    }\n    return Matrix(1, columns, temp);\n}\ntemplate <typename T>\nMatrix<T> Matrix<T>::concatenateRows(const Matrix<T> &matrix2)\n{\n    vector<T> temp;\n    for (int i = 0; i < rows * columns; i++)\n    {\n        temp.push_back(this->values[i]);\n    }\n    for (int i = 0; i < matrix2.rows * matrix2.columns; i++)\n    {\n        temp.push_back(matrix2.values[i]);\n    }\n    return Matrix(rows + matrix2.rows, columns, temp);\n}\n\ntemplate <typename T>\nMatrix<T> Matrix<T>::concatenateColumns(const Matrix<T> &matrix2)\n{\n    vector<T> temp;\n    for (int i = 0; i < rows; i++)\n    {\n        for (int j = 0; j < columns; j++)\n        {\n            temp.push_back(this->values[i * columns + j]);\n        }\n        for (int j = 0; j < matrix2.columns; j++)\n        {\n            temp.push_back(matrix2.values[i * matrix2.columns + j]);\n        }\n    }\n    return Matrix(rows, columns + matrix2.columns, temp);\n}\n\ntemplate <typename T>\nMatrix<T> Matrix<T>::reshape(int columns, int rows)\n{\n    vector<T> temp;\n    for (int i = 0; i < columns; i++)\n    {\n        for (int j = 0; j < rows; j++)\n        {\n            temp.push_back(values[j * columns + i]);\n        }\n    }\n    return Matrix(rows, columns, temp).transpose();\n}\n\ntemplate <typename T>\nMatrix<T> Matrix<T>::transpose()\n{\n    vector<T> temp;\n    for (int i = 0; i < columns; i++)\n    {\n        for (int j = 0; j < rows; j++)\n        {\n            temp.push_back(this->values[j * columns + i]);\n        }\n    }\n    return Matrix(columns, rows, temp);\n}\n\ntemplate <typename T>\nMatrix<T> Matrix<T>::operator+(const Matrix<T> &matrix2)\n{\n    vector<T> ans;\n    for (int i = 0; i < rows * columns; i++)\n    {\n        ans.push_back(this->values[i] + matrix2.values[i]);\n    }\n    return Matrix(rows, columns, ans);\n}\n\ntemplate <typename T>\nMatrix<T> Matrix<T>::operator+(int value)\n{\n    vector<T> ans;\n    for (int i = 0; i < rows * columns; i++)\n    {\n        ans.push_back(this->values[i] + value);\n    }\n    return Matrix(rows, columns, ans);\n}\n\ntemplate <typename T>\nMatrix<T> Matrix<T>::operator-(const Matrix<T> &matrix2)\n{\n    vector<T> ans;\n    for (int i = 0; i < rows * columns; i++)\n    {\n        ans.push_back(this->values[i] - matrix2.values[i]);\n    }\n    return Matrix(rows, columns, ans);\n}\n\ntemplate <typename T>\nMatrix<T> Matrix<T>::operator-(int value)\n{\n    vector<T> ans;\n    for (int i = 0; i < rows * columns; i++)\n    {\n        ans.push_back(this->values[i] - value);\n    }\n    return Matrix(rows, columns, ans);\n}\n\ntemplate <typename T>\nMatrix<T> Matrix<T>::operator*(const Matrix<T> &matrix2)\n{\n    vector<T> ans;\n    T sum = 0;\n    for (int i = 0; i < rows; i++)\n    {\n        for (int j = 0; j < matrix2.columns; j++)\n        {\n            for (int k = 0; k < this->columns; k++)\n            {\n                sum += this->values[i * this->columns + k] * matrix2.values[k * this->columns + j];\n            }\n            ans.push_back(sum);\n            sum = 0;\n        }\n    }\n    return Matrix(this->rows, matrix2.columns, ans);\n}\n\ntemplate <typename T>\nMatrix<T> Matrix<T>::operator*(int value)\n{\n    vector<T> ans;\n    for (int i = 0; i < rows * columns; i++)\n    {\n        ans.push_back(values[i] * value);\n    }\n    return Matrix(rows, columns, ans);\n}\n\ntemplate <typename T>\nMatrix<T> Matrix<T>::max()\n{\n    vector<T> ans;\n    if (rows == 1)\n    {\n        T max = MIN;\n        for (int i = 0; i < columns; i++)\n        {\n            if (max < this->values[i])\n                max = this->values[i];\n        }\n        ans.push_back(max);\n        return Matrix(1, 1, ans);\n    }\n    for (int i = 0; i < columns; i++)\n    {\n        T max = MIN;\n        for (int j = 0; j < rows; j++)\n        {\n            if (max < this->values[j * columns + i])\n                max = this->values[j * columns + i];\n        }\n        ans.push_back(max);\n    }\n    return Matrix(1, columns, ans);\n}\n\ntemplate <typename T>\nMatrix<T> Matrix<T>::min()\n{\n    vector<T> ans;\n    if (rows == 1)\n    {\n        T min = MAX;\n        for (int i = 0; i < columns; i++)\n        {\n            if (min > this->values[i])\n                min = this->values[i];\n        }\n        ans.push_back(min);\n        return Matrix(1, 1, ans);\n    }\n    for (int i = 0; i < columns; i++)\n    {\n        T min = MAX;\n        for (int j = 0; j < rows; j++)\n        {\n            if (min > this->values[j * columns + i])\n                min = this->values[j * columns + i];\n        }\n        ans.push_back(min);\n    }\n    return Matrix(1, columns, ans);\n}\n\ntemplate <typename T>\nMatrix<T> Matrix<T>::sum()\n{\n    vector<T> ans;\n    if (rows == 1)\n    {\n        T s = 0;\n        for (int i = 0; i < columns; i++)\n        {\n            s += this->values[i];\n        }\n        ans.push_back(s);\n        return Matrix(1, 1, ans);\n    }\n    for (int i = 0; i < columns; i++)\n    {\n        T s = 0;\n        for (int j = 0; j < rows; j++)\n        {\n            s += this->values[j * columns + i];\n        }\n        ans.push_back(s);\n    }\n    return Matrix(1, columns, ans);\n}",
            1590158535.489359,
            100,
            "# 答案正确"
        ],
        [
            "6.2 (C++)",
            "孙奥远",
            "#include <iostream>\n#include <cstring>\nusing namespace std;\n\ntemplate <typename T>\nclass Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    T *values;\n\npublic:\n    Matrix(int rows, int columns);\n    ~Matrix();\n    void print() const;\n};\n\ntemplate <typename T>\nMatrix<T>::Matrix(int rows, int columns)\n{\n    this->rows = rows;\n    this->columns = columns;\n    this->values = new T[rows * columns];\n    memset(this->values, 0, sizeof(T) * rows * columns);\n}\n\ntemplate <typename T>\nMatrix<T>::~Matrix()\n{\n    delete[] this->values;\n}\n\ntemplate <typename T>\nvoid Matrix<T>::print() const\n{\n    for (int i = 0; i < this->rows; i++)\n    {\n        for (int j = 0; j < this->columns; j++)\n        {\n            cout << \"    \" << this->values[i * columns + j];\n        }\n        cout << endl;\n    }\n}",
            1590631844.2371538,
            100,
            "# 答案正确"
        ],
        [
            "7.1 (C++)",
            "孙奥远",
            "#include <iostream>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nclass Triangle : public GeometricObject\n{\nprivate:\n    double side1;\n    double side2;\n    double side3;\n\npublic:\n    Triangle();\n    ~Triangle(){};\n    Triangle(double side1, double side2, double side3);\n    double getSide1();\n    double getSide2();\n    double getSide3();\n    double getArea();\n    double getPerimeter();\n    void setColor(string color);\n    string getColor();\n};\n\nTriangle::Triangle()\n{\n    this->side1 = 1;\n    this->side2 = 1;\n    this->side3 = 1;\n}\n\nTriangle::Triangle(double side1, double side2, double side3)\n{\n    this->side1 = side1;\n    this->side2 = side2;\n    this->side3 = side3;\n}\n\ndouble Triangle::getSide1()\n{\n    return this->side1;\n}\n\ndouble Triangle::getSide2()\n{\n    return this->side2;\n}\n\ndouble Triangle::getSide3()\n{\n    return this->side3;\n}\n\ndouble Triangle::getArea()\n{\n    double s = (side1 + side2 + side3) / 2;\n    return sqrt(s * (s - side1) * (s - side2) * (s - side3));\n}\n\ndouble Triangle::getPerimeter()\n{\n    return side1 + side2 + side3;\n}\n\nvoid Triangle::setColor(string color)\n{\n    GeometricObject::setColor(color);\n}\n\nstring Triangle::getColor()\n{\n    return GeometricObject::getColor();\n}",
            1590726022.2768104,
            100,
            "# 答案正确"
        ],
        [
            "7.3 (C++)",
            "孙奥远",
            "#include<vector>\n\ntemplate <typename A>\nvector<A> map2(const vector<A> &x,const vector<A> & y, A (*map_func2)(const A&,const A&))\n{\n    vector<A> ans;\n    for(int i = 0;i < x.size();i++)\n    {\n        ans.push_back(map_func2(x[i],y[i]));\n    }\n    return ans;\n}\n\ntemplate <typename A>\nvector<A> map2(const vector<A> &x,A y, A (*map_func2)(const A&,const A&))\n{\n    vector<A> ans;\n    for(int i = 0;i < x.size();i++)\n    {\n        ans.push_back(map_func2(x[i],y));\n    }\n    return ans;\n}",
            1590727358.2138073,
            100,
            "# 答案正确"
        ],
        [
            "7.2 (C++)",
            "孙奥远",
            "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nvector<string> split(string line)\n{\n    vector<string> ans;\n    char sym = ' ';\n    int begin = 0, end = 0;\n    string temp;\n    while (begin < line.size() - 1)\n    {\n        if (line[begin] != sym)\n            break;\n        begin++;\n    }\n    end = begin;\n    while (end < line.size() - 1)\n    {\n        end = line.find(sym,begin);\n        if(end == -1)\n        {\n            temp = line.substr(begin,line.size() - 1 - begin);\n            ans.push_back(temp);\n            return ans;\n        }   \n        else\n        {\n            if(end - begin >=1)\n            {   \n                temp = line.substr(begin,end - begin);\n                ans.push_back(temp);\n            }\n            begin = end + 1;\n        }\n    }\n    return ans;\n}",
            1591238682.1228535,
            100,
            "# 答案正确"
        ],
        [
            "8.1 (C++)",
            "孙奥远",
            "#include <iostream>\n#include <string>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\nclass Full : public Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    vector<vector<double>> values;\n\npublic:\n    Full(int rows, int columns);\n    Full(int rows, int columns, double values[]);\n    Full(const Matrix &Matrix2);\n    ~Full(){};\n    void print() const;\n    int size(int dimension) const;\n    void set(int row, int column, double value);\n    double get(int row, int column) const;\n    Matrix &operator=(const Matrix &matrix2);\n};\n\nvoid Full::set(int row, int column, double value)\n{\n    this->values[row - 1][column - 1] = value;\n}\n\ndouble Full::get(int row, int column) const\n{\n    return this->values[row - 1][column - 1];\n}\n\nMatrix &Full::operator=(const Matrix &matrix2)\n{\n    if (this == &matrix2)\n        return *this;\n    Full &m = dynamic_cast<Full &>(const_cast<Matrix &>(matrix2));\n    this->rows = m.rows;\n    this->columns = m.columns;\n    for (int i = 0; i < rows; i++)\n    {\n        for (int j = 0; j < columns; j++)\n        {\n            this->values[i][j] = m.values[i][j];\n        }\n    }\n    return *this;\n}\nFull::Full(int rows, int columns)\n{\n    this->rows = rows;\n    this->columns = columns;\n    values.resize(rows);\n    for (int i = 0; i < rows; i++)\n    {\n        for (int j = 0; j < columns; j++)\n        {\n            values[i].push_back(0);\n        }\n    }\n}\n\nFull::Full(int rows, int columns, double values[])\n{\n    this->rows = rows;\n    this->columns = columns;\n    this->values.resize(rows);\n    for (int i = 0; i < rows; i++)\n    {\n        for (int j = 0; j < columns; j++)\n        {\n            this->values[i].push_back(values[i * columns + j]);\n        }\n    }\n}\n\nFull::Full(const Matrix &Matrix2)\n{\n    Full &matrix2 = dynamic_cast<Full &>(const_cast<Matrix &>(Matrix2));\n    this->rows = matrix2.rows;\n    this->columns = matrix2.columns;\n    this->values.resize(this->rows);\n    for (int i = 0; i < this->rows; i++)\n    {\n        for (int j = 0; j < this->columns; j++)\n        {\n            this->values[i].push_back(matrix2.values[i][j]);\n        }\n    }\n}\n\nvoid Full::print() const\n{\n    for (int i = 0; i < this->rows; i++)\n    {\n        for (int j = 0; j < this->columns; j++)\n        {\n            cout << \"    \" << this->values[i][j];\n        }\n        cout << endl;\n    }\n}\n\nint Full::size(int dimension) const\n{\n    if (dimension == 1)\n        return this->rows;\n    else\n        return this->columns;\n}",
            1591326917.549458,
            100,
            "# 答案正确"
        ],
        [
            "8.3 (C++)",
            "孙奥远",
            "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Sparse : public Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    vector<Entry> elem;\n\npublic:\n    Sparse(int rows, int columns);\n    int size(int dimension) const\n    {\n        if (dimension == 1)\n            return rows;\n        else\n            return columns;\n    };\n    void set(int row, int column, double value)\n    {\n        if (value != 0)\n        {\n            Entry myentry;\n            myentry.row = row;\n            myentry.column = column;\n            myentry.value = value;\n            elem.push_back(myentry);\n        }\n    };\n    double get(int row, int column) const\n    {\n        int i;\n        for (i = 0; i < elem.size(); i++)\n        {\n            if (elem[i].row == row && elem[i].column == column)\n                break;\n        }\n        return elem[i].value;\n    };\n    void print();\n    Sparse operator+(Sparse &sparse2);\n};\n\nSparse::Sparse(int rows, int columns)\n{\n    this->rows = rows;\n    this->columns = columns;\n}\n\nSparse Sparse::operator+(Sparse &sparse2)\n{\n    Sparse ans(rows, columns);\n    for (int i = 0; i < this->elem.size(); i++)\n    {\n        ans.set(this->elem[i].row, this->elem[i].column, this->elem[i].value + sparse2.get(this->elem[i].row, this->elem[i].column));\n    }\n    for (int i = 0; i < sparse2.elem.size(); i++)\n    {\n        int flag = 0;\n        for (int j = 0; j < this->elem.size(); j++)\n        {\n            if (sparse2.elem[i].row == this->elem[j].row && sparse2.elem[i].column == this->elem[j].column)\n            {\n                flag = 1;\n                break;\n            }\n        }\n        if (flag == 1)\n            continue;\n        ans.set(sparse2.elem[i].row, sparse2.elem[i].column, sparse2.elem[i].value + this->get(sparse2.elem[i].row, sparse2.elem[i].column));\n    }\n    return ans;\n}\nvoid Sparse::print()\n{\n    Entry temp;\n    for (int i = 0; i < elem.size() - 1; i++)\n    {\n        for (int j = 0; j < elem.size() - 1 - i; j++)\n        {\n            if (elem[j].row > elem[j + 1].row)\n            {\n                temp = elem[j];\n                elem[j] = elem[j + 1];\n                elem[j + 1] = temp;\n            }\n            else if (elem[j].row == elem[j + 1].row)\n            {\n                if (elem[j].column > elem[j + 1].column)\n                {\n                    temp = elem[j];\n                    elem[j] = elem[j + 1];\n                    elem[j + 1] = temp;\n                }\n            }\n        }\n    }\n    for (int i = 0; i < elem.size(); i++)\n    {\n        cout << \"(\" << elem[i].row << \",\" << elem[i].column << \",\" << elem[i].value << \")\" << endl;\n    }\n}\n",
            1591331674.014109,
            100,
            "# 答案正确"
        ],
        [
            "8.4 (C++)",
            "孙奥远",
            "#include <iostream>\n#include <vector>\nusing namespace std;\n\n\nclass Sparse : public Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    vector<Entry> elem;\n\npublic:\n    Sparse(int rows, int columns);\n    int size(int dimension) const\n    {\n        if (dimension == 1)\n            return rows;\n        else\n            return columns;\n    };\n    void set(int row, int column, double value)\n    {\n        if (value != 0)\n        {\n            Entry myentry;\n            myentry.row = row;\n            myentry.column = column;\n            myentry.value = value;\n            elem.push_back(myentry);\n        }\n    };\n    double get(int row, int column) const\n    {\n        int i;\n        for (i = 0; i < elem.size(); i++)\n        {\n            if (elem[i].row == row && elem[i].column == column)\n                break;\n        }\n        return elem[i].value;\n    };\n    void print();\n    Sparse operator*(Sparse &sparse2);\n};\n\nSparse::Sparse(int rows, int columns)\n{\n    this->rows = rows;\n    this->columns = columns;\n}\n\nSparse Sparse::operator*(Sparse &sparse2)\n{\n    Sparse ans(rows, sparse2.columns);\n    for (int i = 0; i < this->elem.size(); i++)\n    {\n        int r = this->elem[i].row;\n        for (int j = 0; j < sparse2.elem.size(); j++)\n        {\n            int col = sparse2.elem[j].column;\n            int flag = 0, k;\n            for (k = 0; k < ans.elem.size(); k++)\n            {\n                if (ans.elem[k].row == r && ans.elem[k].column == col)\n                {\n                    flag = 1;\n                    break;\n                }\n            }\n            if (flag == 1)\n                continue;\n            double sum = 0;\n            for (int m = 0; m < this->elem.size(); m++)\n            {\n                if (this->elem[m].row == r)\n                {\n                    for (int n = 0; n < sparse2.elem.size(); n++)\n                    {\n                        if (sparse2.elem[n].column == col && this->elem[m].column == sparse2.elem[n].row)\n                            sum += sparse2.elem[n].value * this->elem[m].value;\n                    }\n                }\n            }\n            ans.set(r, col, sum);\n        }\n    }\n    return ans;\n}\nvoid Sparse::print()\n{\n    Entry temp;\n    for (int i = 0; i < elem.size() - 1; i++)\n    {\n        for (int j = 0; j < elem.size() - 1 - i; j++)\n        {\n            if (elem[j].row > elem[j + 1].row)\n            {\n                temp = elem[j];\n                elem[j] = elem[j + 1];\n                elem[j + 1] = temp;\n            }\n            else if (elem[j].row == elem[j + 1].row)\n            {\n                if (elem[j].column > elem[j + 1].column)\n                {\n                    temp = elem[j];\n                    elem[j] = elem[j + 1];\n                    elem[j + 1] = temp;\n                }\n            }\n        }\n    }\n    for (int i = 0; i < elem.size(); i++)\n    {\n        cout << \"(\" << elem[i].row << \",\" << elem[i].column << \",\" << elem[i].value << \")\" << endl;\n    }\n}",
            1591341217.7742627,
            100,
            "# 答案正确"
        ],
        [
            "8.5 (C++)",
            "孙奥远",
            "#include <cmath>\n#include <iostream>\nusing namespace std;\n\nclass Point3D : public Point2D\n{\nprivate:\n    double z;\n\npublic:\n    Point3D()\n    {\n        z = 0;\n        this->setX(0);\n        this->setY(0);\n    }\n    Point3D(double a, double b, double c)\n    {\n        z = c;\n        this->setX(a);\n        this->setY(b);\n    }\n    double getZ()\n    {\n        return z;\n    }\n\tdouble distance (Point2D & point2)\n\t{\n\tPoint3D & pt = dynamic_cast<Point3D&>(point2);\n\tdouble dx = this->getX() - pt.getX();\n\tdouble dy = this->getY() - pt.getY();\n\tdouble dz = this->getZ() - pt.getZ();\n\treturn sqrt(dx*dx+dy*dy+dz*dz);\n\t}\n};\n",
            1591844410.1308618,
            100,
            "# 答案正确"
        ],
        [
            "8.6 (C++)",
            "孙奥远",
            "#include<vector>\n#include<iostream>\nusing namespace std;\nclass MyTensor : public Tensor<double>\n{\nprivate:\n    vector<double> cap;\n\npublic:\n    MyTensor(vector<int> indexes) : Tensor(indexes)\n    {\n        int num = 1;\n        for (int i = 0; i < indexes.size(); i++)\n        {\n            num *= indexes[i];\n        }\n        cap.resize(num);\n    }\n    ~MyTensor(){};\n    double &get(const vector<int> &indexes)\n    {\n        int pos = 0;\n        for (int i = 0; i < indexes.size(); i++)\n        {\n            if (i == indexes.size() - 1)\n            {\n                pos += indexes[i];\n                break;\n            }\n            int temp = indexes[i];\n            for (int j = i + 1; j < indexes.size(); j++)\n            {\n                temp *= sizes[j];\n            }\n            pos += temp;\n        }\n        return cap[pos];\n    }\n};",
            1592448426.2690566,
            100,
            "# 答案正确"
        ],
        [
            "9.1 (C++)",
            "孙奥远",
            "#include <iostream>\nusing namespace std;\n\nclass Circle\n{\nprivate:\n    double r;\n\npublic:\n    Circle(double r)\n    {\n        this->r = r;\n    }\n    bool operator<(const Circle &circle2) const\n    {\n        return this->r < circle2.r;\n    }\n    bool operator<=(const Circle &circle2) const\n    {\n        return this->r <= circle2.r;\n    }\n    bool operator==(const Circle &circle2) const\n    {\n        return this->r == circle2.r;\n    }\n    bool operator!=(const Circle &circle2) const\n    {\n        return this->r != circle2.r;\n    }\n    bool operator>=(const Circle &circle2) const\n    {\n        return this->r >= circle2.r;\n    }\n    bool operator>(const Circle &circle2) const\n    {\n        return this->r > circle2.r;\n    }\n};",
            1592535144.8735828,
            100,
            "# 答案正确"
        ],
        [
            "9.2 (C++)",
            "孙奥远",
            "#include <vector>\n#include <iostream>\nusing namespace std;\n\nclass I\n{\nprivate:\n    vector<int> num;\n\npublic:\n    I(int x, int y, int z)\n    {\n        num.resize(3);\n        num[0] = x;\n        num[1] = y;\n        num[2] = z;\n    }\n    I(int x, int y, int z, int m)\n    {\n        num.resize(4);\n        num[0] = x;\n        num[1] = y;\n        num[2] = z;\n        num[3] = m;\n    }\n    ~I() {}\n    operator vector<int>() const\n    {\n        return num;\n    }\n};",
            1592535771.633839,
            100,
            "# 答案正确"
        ],
        [
            "9.3 (C++)",
            "孙奥远",
            "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nclass Complex\n{\nprivate:\n    double r;\n    double i;\n\npublic:\n    Complex(double r, double i)\n    {\n        this->r = r;\n        this->i = i;\n    }\n    ~Complex() {}\n    double real()\n    {\n        return r;\n    }\n    double imag()\n    {\n        return i;\n    }\n    Complex operator+(Complex &complex2)\n    {\n        return Complex(r + complex2.real(), i + complex2.imag());\n    }\n    Complex operator-(Complex &complex2)\n    {\n        return Complex(r - complex2.real(), i - complex2.imag());\n    }\n    Complex operator*(Complex &complex2)\n    {\n        return Complex(r * complex2.real() - i * complex2.imag(), i * complex2.real() + r * complex2.imag());\n    }\n    Complex operator/(Complex &complex2)\n    {\n        return Complex((r * complex2.real() + i * complex2.imag()) / (complex2.real() * complex2.real() + complex2.imag() * complex2.imag()), (i * complex2.real() - r * complex2.imag()) / (complex2.real() * complex2.real() + complex2.imag() * complex2.imag()));\n    }\n    Complex &operator+=(Complex &c)\n    {\n        *this = *this + c;\n        return *this;\n    }\n    Complex &operator-=(Complex &c)\n    {\n        *this = *this - c;\n        return *this;\n    }\n    Complex &operator*=(Complex &c)\n    {\n        *this = *this * c;\n        return *this;\n    }\n    Complex &operator/=(Complex &c)\n    {\n        *this = *this / c;\n        return *this;\n    }\n    bool operator==(Complex &c)\n    {\n        return r == c.real() && i == c.imag();\n    }\n    bool operator!=(Complex &c)\n    {\n        return r != c.real() || i != c.imag();\n    }\n};\n\nComplex operator+(double x, Complex &complex)\n{\n    return Complex(x + complex.real(), complex.imag());\n}\n\nComplex operator-(Complex &complex, double y)\n{\n    return Complex(complex.real() - y, complex.imag());\n}",
            1592537673.2657325,
            100,
            "# 答案正确"
        ],
        [
            "9.4 (C++)",
            "孙奥远",
            "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nclass Complex\n{\nprivate:\n    double r;\n    double i;\n\npublic:\n    Complex() : r(0), i(0) {}\n    ~Complex() {}\n\t  Complex(double r, double i)\n    {\n        this->r = r;\n        this->i = i;\n    }\n    double &real()\n    {\n        return r;\n    }\n    double &imag()\n    {\n        return i;\n    }\n    Complex operator+(Complex &complex2)\n    {\n        return Complex(r + complex2.real(), i + complex2.imag());\n    }\n    Complex operator-(Complex &complex2)\n    {\n        return Complex(r - complex2.real(), i - complex2.imag());\n    }\n};\n\nostream &operator<<(ostream &os, Complex &c)\n{\n    os << c.real() << \" + \" << c.imag() << \" i\";\n    return os;\n}\n\nistream &operator>>(istream &is, Complex &c)\n{\n    is >> c.real() >> c.imag();\n    return is;\n}\nComplex operator+(double x, Complex &complex)\n{\n    return Complex(x + complex.real(), complex.imag());\n}",
            1592538137.1796792,
            100,
            "# 答案正确"
        ],
        [
            "9.5 (C++)",
            "孙奥远",
            "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nclass Complex\n{\nprivate:\n    double r;\n    double i;\n\npublic:\n    Complex() : r(0), i(0) {}\n    Complex(double r, double i)\n    {\n        this->r = r;\n        this->i = i;\n    }\n    ~Complex() {}\n    double &real()\n    {\n        return r;\n    }\n    double &imag()\n    {\n        return i;\n    }\n    Complex &operator++()\n    {\n        this->r++;\n        return *this;\n    }\n    Complex operator++(int)\n    {\n        double temp = r;\n        this->r++;\n        return Complex(temp, this->i);\n    }\n    operator double() const\n    {\n        return this->r;\n    }\n};\n\nistream &operator>>(istream &is, Complex &c)\n{\n    is >> c.real() >> c.imag();\n    return is;\n}\n\nostream &operator<<(ostream &os, Complex c)\n{\n    os << c.real() << \" + \" << c.imag() << \" i\";\n    return os;\n}",
            1592541388.0225935,
            100,
            "# 答案正确"
        ],
        [
            "9.6 (C++)",
            "孙奥远",
            "#include <vector>\n#include <iostream>\nusing namespace std;\n\nclass Tensor\n{\nprivate:\n    vector<double> value;\n    vector<int> sizes;\n\npublic:\n    Tensor(int x, int y, int z)\n    {\n        sizes.resize(3);\n        sizes[0] = x, sizes[1] = y, sizes[2] = z;\n        value.resize(sizes[0] * sizes[1] * sizes[2]);\n    }\n    ~Tensor() {}\n    Tensor(int x, int y, int z, int m)\n    {\n        sizes.resize(4);\n        sizes[0] = x, sizes[1] = y, sizes[2] = z, sizes[3] = m;\n        value.resize(sizes[0] * sizes[1] * sizes[2] * sizes[3]);\n    }\n    double &operator()(int x, int y, int z)\n    {\n        int index = 0;\n        index += x * sizes[1] * sizes[2];\n        index += y * sizes[2];\n        index += z;\n        return value[index];\n    }\n    double &operator()(int x, int y, int z, int m)\n    {\n        int index = 0;\n        index += x * sizes[1] * sizes[2] * sizes[3];\n        index += y * sizes[2] * sizes[3];\n        index += z * sizes[3];\n        index += m;\n        return value[index];\n    }\n};",
            1592541865.041534,
            100,
            "# 答案正确"
        ],
        [
            "9.7 (C++)",
            "孙奥远",
            "#include <vector>\n#include <iostream>\n#include <fstream>\nusing namespace std;\n\nclass Tensor\n{\nprivate:\n    int dismenion;\n    vector<int> sizes;\n    vector<double> value;\n\npublic:\n    Tensor()\n    {\n        dismenion = 0;\n    }\n    Tensor(int d, vector<int> s)\n    {\n        dismenion = d;\n        int cap = 1;\n        sizes.resize(d);\n        for (int i = 0; i < d; i++)\n        {\n            sizes[i] = s[i];\n            cap *= sizes[i];\n        }\n        value.resize(cap);\n    }\n    int size()\n    {\n        return value.size();\n    }\n    int get_dismension()\n    {\n        return dismenion;\n    }\n    int get_size(int index)\n    {\n        return sizes[index];\n    }\n    ~Tensor() {}\n    double &operator[](int index)\n    {\n        return value[index];\n    }\n    Tensor &operator=(Tensor &t)\n    {\n        if (&t == this)\n            return *this;\n        this->dismenion = t.dismenion;\n        sizes.resize(this->dismenion);\n        for (int i = 0; i < dismenion; i++)\n        {\n            sizes[i] = t.sizes[i];\n        }\n        this->value.resize(t.size());\n        for (int i = 0; i < t.size(); i++)\n        {\n            value[i] = t.value[i];\n        }\n        return *this;\n    }\n    int index(vector<int> indexes)\n    {\n        int _index = 0;\n        for (int i = 0; i < indexes.size(); i++)\n        {\n            int temp = indexes[i];\n            for (int j = i + 1; j < sizes.size(); j++)\n            {\n                temp *= sizes[j];\n            }\n            _index += temp;\n        }\n        return _index;\n    }\n};\n\nistream &operator>>(istream &is, Tensor &t)\n{\n    int d;\n    is >> d;\n    vector<int> arr;\n    arr.resize(d);\n    for (int i = 0; i < d; i++)\n        is >> arr[i];\n    Tensor temp(d, arr);\n    for (int i = 0; i < temp.size(); i++)\n    {\n        is >> temp[i];\n    }\n    t = temp;\n    return is;\n}\n\nostream &operator<<(ostream &os, Tensor &t)\n{\n    os << t.get_dismension() << endl;\n    for (int i = 0; i < t.get_dismension(); i++)\n    {\n        os << t.get_size(i);\n        if (i == t.get_dismension() - 1)\n            os << endl;\n        else\n            os << \" \";\n    }\n    os << endl;\n    if (t.get_dismension() == 3)\n    {\n        for (int i = 0; i < t.get_size(0); i++)\n        {\n            for (int j = 0; j < t.get_size(1); j++)\n            {\n                for (int k = 0; k < t.get_size(2); k++)\n                {\n                    vector<int> temp;\n                    temp.resize(3);\n                    temp[0] = i;\n                    temp[1] = j;\n                    temp[2] = k;\n                    os << t[t.index(temp)];\n                    if (k == t.get_size(2) - 1)\n                        os << endl;\n                    else\n                        os << \" \";\n                }\n            }\n            if (i < t.get_size(0) - 1)\n                os << endl;\n        }\n        cout << endl;\n    }\n    else if (t.get_dismension() == 4)\n    {\n        for (int i = 0; i < t.get_size(0); i++)\n        {\n            for (int j = 0; j < t.get_size(1); j++)\n            {\n                for (int k = 0; k < t.get_size(2); k++)\n                {\n                    for (int m = 0; m < t.get_size(3); m++)\n                    {\n                        vector<int> temp;\n                        temp.resize(4);\n                        temp[0] = i;\n                        temp[1] = j;\n                        temp[2] = k;\n                        temp[3] = m;\n                        os << t[t.index(temp)];\n                        if (m == t.get_size(3) - 1)\n                            os << endl;\n                        else\n                            os << \" \";\n                    }\n                }\n                if(j < t.get_size(1) - 1)\n                    cout << endl;\n            }\n            if (i < t.get_size(0) - 1)\n                os << endl;\n        }\n    }\n    return os;\n}",
            1592554436.2192154,
            100,
            "# 答案正确"
        ],
        [
            "10.1 (C++)",
            "孙奥远",
            "#include <vector>\n#include <iostream>\nusing namespace std;\n#include <stdexcept>\n#include <exception>\n\nclass MatrixSizesDoNotMatchException\n{\n};\ndouble Matrix::get(int row, int column) const\n{\n    if (row > size(1) || column > size(2))\n        throw out_of_range(\"error\");\n    else\n        return elements[(row - 1) * columns + column - 1];\n}\n\nvoid Matrix::set(int row, int column, double value)\n{\n    if (row > size(1) || column > size(2))\n        throw out_of_range(\"error\");\n    elements[(row - 1) * columns + column - 1] = value;\n}\n\nMatrix Matrix::operator+(const Matrix &matrix2) const\n{\n    if (rows != matrix2.size(1) || columns != matrix2.size(2))\n        throw MatrixSizesDoNotMatchException();\n    Matrix ans(rows, columns);\n    for (int i = 0; i < rows; i++)\n    {\n        for (int j = 0; j < columns; j++)\n        {\n            ans.set(i + 1, j + 1, elements[i * columns + j] + matrix2.elements[i * columns + j]);\n        }\n    }\n    return ans;\n}\n",
            1593311106.9977639,
            100,
            "# 答案正确"
        ],
        [
            "10.2 (C++)",
            "孙奥远",
            "\ncatch (NonPositiveValueException &ex)\n        {\n            cout << \"caught: NonPositiveValueException\" << endl;\n        }\n        catch (out_of_range &ex)\n        {\n            cout << \"caught: out_of_range\" << endl;\n        }",
            1593655935.4830775,
            100,
            "# 答案正确"
        ],
        [
            "15.1 (C++)",
            "孙奥远",
            "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nclass Table\n{\nprivate:\n    vector<vector<string>> table;\n    vector<string> head;\npublic:\n    Table(){\n        vector<string> temp;\n        temp.resize(head.size());\n        table.push_back(temp);\n    };\n    void addCol(string s)\n    {\n        head.push_back(s);\n    }\n    vector<string>& operator[](int index)\n    {\n        vector<string> temp;\n        temp.resize(head.size());\n        table.push_back(temp);\n        return table[index];\n    }\n    string json() const\n    {\n        cout << \"{\" << endl;\n        cout << \"        \" << \"headers: [\" ;\n        for(int i = 0;i < head.size();i++)\n        {\n            cout << '\\'' << head[i] << '\\'' << \",\";\n        }\n        cout << \"],\" << endl;\n        cout << \"        \" << \"rows: [\\n\";\n        for(int i = 0;i < table.size() - 1;i++)\n        {\n            cout << \"                \";\n            cout << \"[\";\n            for(int j = 0;j < table[i].size();j++)\n            {\n                cout << '\\'' << table[i][j] << '\\'' << \",\";\n            }\n            cout << \"],\\n\";\n        }\n        cout << \"        \" << \"],\\n\";\n        return string(\"}\");\n    }\n};",
            1593743414.452292,
            100,
            "# 答案正确"
        ],
        [
            "2020-07-09 LAB",
            "孙奥远",
            "#include <iostream>\nusing namespace std;\n\nclass Integer\n{\nprivate:\n    int val;\n    static int add;\n\npublic:\n    Integer(int v) : val(v) {}\n    Integer() : val(0) {}\n    friend ostream &operator<<(ostream &os, Integer &Int);\n    friend istream &operator>>(istream &is, Integer &Int);\n    static void increase_all(Integer Int)\n    {\n        add = Int.val;\n    }\n};\n\nint Integer::add = 0;\nistream &operator>>(istream &is, Integer &Int)\n{\n    is >> Int.val;\n    return is;\n}\nostream &operator<<(ostream &os, Integer &Int)\n{\n    Int.val = Int.val + Integer::add;\n    os << Int.val;\n    return os;\n}",
            1594261428.5904987,
            100,
            "# 答案正确"
        ],
        [
            "A.1 (C++)",
            "孙奥远",
            "\t ~LinkedList()\n\t {\n\t\t while(_size>0)\n\t\t\t removeLast();\n\t }\n\t LinkedList(LinkedList<E> &list)\n    {\n        _size = list._size;\n        if(_size == 0)\n        {\n            head = 0;\n            tail = 0;\n        }\n        else\n        {\n            Node<E>*add = new Node<E>;\n            add->element = list.head->element;\n            add->update_prev_and_next_node(0,0);\n            tail = head = add;\n            Node<E>*cur = list.head;\n            Node<E>*pre = 0;\n            Node<E>*nxt = cur->next_node(pre);\n            for(int i = 0;i < _size - 1;i++)\n            {\n                pre = cur;\n                cur = nxt;\n                nxt = cur->next_node(pre);\n                add = new Node<E>;\n                add->element = cur->element;\n                add->update_prev_and_next_node(0,tail);\n                tail->update_next_node(0,add);\n                tail = add;\n            }\n        }\n    }\n    void addFirst(E val)\n    {\n        Node<E> *add = new Node<E>;\n        add->element = val;\n        add->update_prev_and_next_node(0,head);\n        if(head != 0) head->update_prev_node(0,add);\n        head = add;\n        if (tail == 0)\n            tail = add;\n        _size++;\n    }\n    void addLast(E val)\n    {\n        Node<E> *add = new Node<E>;\n        add->element = val;\n        add->update_prev_and_next_node(0,tail);\n        if(tail !=0) tail->update_next_node(0,add);\n        tail = add;\n        if (head == 0)\n            head = add;\n        _size++;\n    }\n    void removeFirstOccurrence(E val)\n    {\n        Node<E> *cur = head;\n        Node<E> *pre = 0;\n        Node<E> *nxt = cur->next_node(pre);\n        for (int i = 0; i < _size; i++)\n        {\n            if (cur->element == val)\n            {\n                if (nxt != 0)\n                {\n                    nxt->update_prev_node(cur, pre);\n                }\n                if (pre != 0)\n                    pre->update_next_node(cur, nxt);\n                if (nxt == 0)\n                {\n                    removeLast();\n                    return;\n                }\n                if (pre == 0)\n                {\n                    removeFirst();\n                    return;\n                }\n                delete cur;\n                _size--;\n                return;\n            }\n            pre = cur;\n            cur = nxt;\n            nxt = cur->next_node(pre);\n        }\n    }\n    E get(int index)\n    {\n        if (index < _size / 2){\n            Node<E> *cur = head;\n            Node<E> *pre = 0;\n            Node<E> *nxt = cur->next_node(pre);\n            for (int i = 0; i < index; i++)\n            {\n                pre = cur;\n                cur = nxt;\n                nxt = cur->next_node(pre);\n            }\n            return cur->element;\n        }\n        else\n        {\n            Node<E> *cur = tail;\n            Node<E> *nxt = 0;\n            Node<E> *pre = cur->prev_node(nxt);\n            for (int i = 0; i < _size - 1 - index; i++)\n            {\n                nxt = cur;\n                cur = pre;\n                pre = cur->prev_node(nxt);\n            }\n            return cur->element;\n        }\n    }\n    void removeLast()\n    {\n        Node<E> *cur = tail;\n        Node<E> *nxt = 0;\n        Node<E> *pre = 0;\n        if (cur != 0)\n            pre = cur->prev_node(nxt);\n        if (pre != 0)\n            pre->update_next_node(cur, 0);\n        if (cur != 0)\n            delete cur;\n        tail = pre;\n        _size--;\n    }\n    void removeFirst()\n    {\n        Node<E> *cur = head;\n        Node<E> *pre = 0;\n        Node<E> *nxt = 0;\n        if (cur != 0)\n            nxt = cur->next_node(pre);\n        if (nxt != 0)\n            nxt->update_prev_node(cur, 0);\n        if (cur != 0)\n            delete cur;\n        head = nxt;\n        _size--;\n    }",
            1594360575.6742342,
            100,
            "# 答案正确"
        ],
        [
            "A.2 (C++)",
            "孙奥远",
            "template <typename E>\nvoid LinkedList<E>::removeAll(const E & e)\n{\n    Node<E>*cur = this->head;\n    int index = 0;\n    while(cur)\n    {\n        if(cur->element == e)\n        {\n            cur = cur->next_node;\n            this->remove(index);\n        }\n        else \n        {   cur = cur->next_node;\n            index++;\n        }\n    }\n}",
            1594866094.4179761,
            100,
            "# 答案正确"
        ],
        [
            "A.4 (C++)",
            "孙奥远",
            "#include<string>\n#include<vector>\nusing namespace std;\nclass Tuple\n{\npublic:\n\tint a;\n\tint b;\n\tstring c;\n\tstring d;\n\tvector<bool> arr;\n\tbool in_use;\n\tTuple()\n\t{\n\t\tin_use = false;\n\t\tarr.resize(4);\n\t\tfor (int i = 0; i < 4; i++)\n\t\t\tarr[i] = false;\n\t}\n};\n\nclass helper\n{\nprivate:\n\tint int_val;\n\tstring string_val;\n\tbool is_int;\n\npublic:\n\thelper(Tuple t, int key)\n\t{\n\t\tif (t.arr[1])\n\t\t{\n\t\t\tint_val = t.b;\n\t\t\tis_int = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstring_val = t.c;\n\t\t\tis_int = false;\n\t\t}\n\t}\n\thelper(Tuple t, string key)\n\t{\n\t\tif (t.arr[3])\n\t\t{\n\t\t\tstring_val = t.d;\n\t\t\tis_int = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint_val = t.b;\n\t\t\tis_int = true;\n\t\t}\n\t}\n\toperator int() const\n\t{\n\t\treturn int_val;\n\t}\n\toperator string() const\n\t{\n\t\treturn string_val;\n\t}\n};\n\n\nclass HT\n{\nprivate:\n\tvector<Tuple> tuples;\n\tint _size;\n\npublic:\n\tHT()\n\t{\n\t\ttuples.resize(20);\n\t\t_size = 0;\n\t}\n\tint size()\n\t{\n\t\treturn _size;\n\t}\n\tint hashfunction(int key)\n\t{\n\t\tunsigned int hashval = 0;\n\t\twhile (key)\n\t\t{\n\t\t\thashval = (hashval << 5) + (key % 10);\n\t\t\tkey = key / 10;\n\t\t}\n\t\treturn hashval % tuples.size();\n\t}\n\tint hashfunction(string key)\n\t{\n\t\tunsigned int hashval = 0;\n\t\tfor (int i = 0; i < key.size(); i++)\n\t\t{\n\t\t\thashval = (hashval << 5) + key[i];\n\t\t}\n\t\treturn hashval % tuples.size();\n\t}\n\tint indexofkey(int key)\n\t{\n\t\tint index = hashfunction(key);\n\t\twhile (true)\n\t\t{\n\t\t\tif (tuples[index].in_use == false)\n\t\t\t\treturn index;\n\t\t\tif (tuples[index].a == key)\n\t\t\t\treturn index;\n\t\t\tindex = (index + 1) % tuples.size();\n\t\t}\n\t}\n\tint indexofkey(string key)\n\t{\n\t\tint index = hashfunction(key);\n\t\twhile (true)\n\t\t{\n\t\t\tif (tuples[index].in_use == false)\n\t\t\t\treturn index;\n\t\t\tif (tuples[index].c == key)\n\t\t\t\treturn index;\n\t\t\tindex = (index + 1) % tuples.size();\n\t\t}\n\t}\n\tvoid put(int key, int value)\n\t{\n\t\tint index = indexofkey(key);\n\t\ttuples[index].a = key;\n\t\ttuples[index].b = value;\n\t\tif (tuples[index].in_use)\n\t\t\treturn;\n\t\ttuples[index].in_use = true;\n\t\ttuples[index].arr[0] = tuples[index].arr[1] = true;\n\t\t_size++;\n\t\tif (_size * 2 > tuples.size())\n\t\t\tdouble_tuples();\n\t}\n\tvoid double_tuples()\n\t{\n\t\tvector<Tuple> non_empty_tuples;\n\t\tfor(int i = 0;i < tuples.size();i++)\n\t\t{\n\t\t\tif(tuples[i].in_use)\n\t\t\t\tnon_empty_tuples.push_back(tuples[i]);\n\t\t}\n\t\ttuples.clear();\n\t\ttuples.resize(non_empty_tuples.size()*2);\n\t\tfor(int i = 0;i < non_empty_tuples.size();i++)\n\t\t{\n\t\t\tif(non_empty_tuples[i].arr[0])\n\t\t\t{\n\t\t\t\tif(non_empty_tuples[i].arr[1])\n\t\t\t\t\tthis->put(non_empty_tuples[i].a,non_empty_tuples[i].b);\n\t\t\t\telse this->put(non_empty_tuples[i].a,non_empty_tuples[i].c);\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tif(non_empty_tuples[i].arr[3])\n\t\t\t\t\tthis->put(non_empty_tuples[i].c,non_empty_tuples[i].d);\n\t\t\t\telse this->put(non_empty_tuples[i].c,non_empty_tuples[i].b);\n\t\t\t}\n\t\t}\n\t}\n\tvoid put(int key, string value)\n\t{\n\t\tint index = indexofkey(key);\n\t\ttuples[index].a = key;\n\t\ttuples[index].c = value;\n\t\tif (tuples[index].in_use)\n\t\t\treturn;\n\t\ttuples[index].in_use = true;\n\t\ttuples[index].arr[0] = tuples[index].arr[2] = true;\n\t\t_size++;\n\t\tif (_size * 2 > tuples.size())\n\t\t\tdouble_tuples();\n\t}\n\tvoid put(string key, int value)\n\t{\n\t\tint index = indexofkey(key);\n\t\ttuples[index].c = key;\n\t\ttuples[index].b = value;\n\t\tif (tuples[index].in_use)\n\t\t\treturn;\n\t\ttuples[index].in_use = true;\n\t\ttuples[index].arr[0] = tuples[index].arr[1] = true;\n\t\t_size++;\n\t\tif (_size * 2 > tuples.size())\n\t\t\tdouble_tuples();\n\t}\n\tvoid put(string key, string value)\n\t{\n\t\tint index = indexofkey(key);\n\t\ttuples[index].c = key;\n\t\ttuples[index].d = value;\n\t\tif (tuples[index].in_use)\n\t\t\treturn;\n\t\ttuples[index].in_use = true;\n\t\ttuples[index].arr[2] = tuples[index].arr[3] = true;\n\t\t_size++;\n\t\tif (_size * 2 > tuples.size())\n\t\t\tdouble_tuples();\n\t}\n\thelper operator[](int key)\n\t{\n\t\tint index = indexofkey(key);\n\t\treturn helper(tuples[index], key);\n\t}\n\thelper operator[](string key)\n\t{\n\t\tint index = indexofkey(key);\n\t\treturn helper(tuples[index], key);\n\t}\n};",
            1595130044.2895606,
            100,
            "# 答案正确"
        ],
        [
            "A.5 (C++)",
            "孙奥远",
            "#include<string>\n#include<vector>\nusing namespace std;\n\nclass Tuple\n{\npublic:\n\tint a;\n\tint b;\n\tstring c;\n\tstring d;\n\tbool in_use;\n};\n\nclass helper\n{\nint int_val;\nstring string_val;\nbool is_int;\npublic:\n\toperator int()\n\t{\n\t\treturn int_val;\n\t}\n\toperator string()\n\t{\n\t\treturn string_val;\n\t}\n\thelper&operator=(int val)\n\t{\n\t\tint_val = val;\n\t\tis_int = true;\n\t\treturn *this;\n\t}\n\thelper&operator=(string val)\n\t{\n\t\tstring_val = val;\n\t\tis_int = false;\n\t\treturn *this;\n\t}\n};\n\nclass HT\n{\nprivate:\n\tvector<Tuple> tuples;\n\tint _size;\n\tvector<helper> h;\npublic:\n\tHT()\n\t{\n\t\ttuples.resize(20);\n\t\t_size = 0;\n\t\th.resize(20);\n\t}\n\tint hashfunction(int key)\n\t{\n\t\tint hashval = 0;\n\t\twhile(key)\n\t\t{\n\t\t\thashval = (hashval << 5) + (key % 10);\n\t\t\tkey = key / 10; \n\t\t}\n\t\treturn hashval % tuples.size();\n\t}\n\tint hashfunction(string key)\n\t{\n\t\tint hashval = 0;\n\t\tfor(int i = 0;i < key.size();i++)\n\t\t{\n\t\t\thashval = (hashval << 5) + key[i];\n\t\t}\n\t\treturn hashval % tuples.size();\n\t}\n\tint indexofkey(int key)\n\t{\n\t\tint index = hashfunction(key);\n\t\twhile(true)\n\t\t{\n\t\t\tif(tuples[index].in_use == false)\n\t\t\t{\n\t\t\t\treturn index;\n\t\t\t}\n\t\t\tif(tuples[index].a == key)\n\t\t\t\treturn index;\n\t\t\tindex = (index + 1) % tuples.size();\n\t\t}\n\t}\n\tint indexofkey(string key)\n\t{\n\t\tint index = hashfunction(key);\n\t\twhile(true)\n\t\t{\n\t\t\tif(tuples[index].in_use == false)\n\t\t\t{\n\t\t\t\treturn index;\n\t\t\t}\n\t\t\tif(tuples[index].c == key)\n\t\t\t\treturn index;\n\t\t\tindex = (index + 1) % tuples.size();\n\t\t}\n\t}\n\thelper&operator[](int key)\n\t{\n\t\tint index = indexofkey(key);\n\t\tif(tuples[index].in_use==false)\n\t\t{\n\t\t\ttuples[index].a = key;\n\t\t\t_size++;\n\t\t\ttuples[index].in_use=true;\n\t\t}\n\t\treturn h[index];\n\t}\n\thelper&operator[](string key)\n\t{\n\t\tint index = indexofkey(key);\n\t\tif(tuples[index].in_use==false)\n\t\t{\n\t\t\ttuples[index].c = key;\n\t\t\t_size++;\n\t\t\ttuples[index].in_use=true;\n\t\t}\n\t\treturn h[index];\n\t}\n\tint size()\n\t{\n\t\treturn _size;\n\t}\n};",
            1595142932.7102523,
            100,
            "# 答案正确"
        ],
        [
            "A.3 (C++)",
            "孙奥远",
            "#include <vector>\nusing namespace std;\n\ntemplate <typename E>\nclass Tuple\n{\npublic:\n\tint key;\n\tE val;\n\tbool in_use;\n\tTuple()\n\t{\n\t\tin_use = false;\n\t}\n};\n\ntemplate <typename E>\nclass HT\n{\nprivate:\n\tvector<Tuple<E>> tuples;\n\tint _size;\n\npublic:\n\tHT()\n\t{\n\t\ttuples.resize(4000);\n\t\t_size = 0;\n\t}\n\tint hashfunction(int key)\n\t{\n\t\tint hashcode = 0;\n\t\twhile (key)\n\t\t{\n\t\t\thashcode = (hashcode << 5) + (key % 10);\n\t\t\tkey /= 10;\n\t\t}\n\t\treturn hashcode % tuples.size();\n\t}\n\tint indexofkey(int key)\n\t{\n\t\tint index = hashfunction(key);\n\t\twhile (true)\n\t\t{\n\t\t\tif (tuples[index].in_use == false)\n\t\t\t\treturn index;\n\t\t\tif (tuples[index].key == key)\n\t\t\t\treturn index;\n\t\t\tindex = (index + 1) % tuples.size();\n\t\t}\n\t}\n\tvoid put(int key, E val)\n\t{\n\t\tint index = indexofkey(key);\n\t\ttuples[index].val = val;\n\t\ttuples[index].key = key;\n\t\tif (tuples[index].in_use == false)\n\t\t{\n\t\t\ttuples[index].in_use = true;\n\t\t\t_size++;\n\t\t}\n\t}\n\tint size()\n\t{\n\t\treturn _size;\n\t}\n\tbool containsKey(int key)\n\t{\n\t\tint index = indexofkey(key);\n\t\treturn tuples[index].in_use == true;\n\t}\n\tE operator[](int key)\n\t{\n\t\tint index = indexofkey(key);\n\t\treturn tuples[index].val;\n\t}\n\tvector<int> getKeys()\n\t{\n\t\tvector<int> ans;\n\t\tfor (int i = 0; i < tuples.size(); i++)\n\t\t{\n\t\t\tif (tuples[i].in_use)\n\t\t\t{\n\t\t\t\tans.push_back(tuples[i].key);\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tvoid remove(int key)\n\t{\n\t\tint index = indexofkey(key);\n\t\ttuples[index].in_use = false;\n\t\t_size--;\n\t}\n};",
            1595471364.5294697,
            100,
            "# 答案正确"
        ]
    ],
    "table_name": "答案"
}