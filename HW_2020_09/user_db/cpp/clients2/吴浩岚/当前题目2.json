{
    "__update_time__": 1595475284.878228,
    "field_names": [
        "题目名",
        "问题",
        "主程序",
        "答案",
        "评语",
        "开始时间",
        "截止时间",
        "分数",
        "提交时间"
    ],
    "field_types": [
        "text",
        "text",
        "text",
        "text",
        "text",
        "time",
        "time",
        "number",
        "time"
    ],
    "rows": [
        [
            "A.3 (C++)",
            "在课堂上讲的哈希表的基础上，写一个以整数为键的只有一个类型参数的哈希表类, HT&lt;E&gt;。<br><p><span style=\"font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, &quot;Noto Sans&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 1rem;\">另外，请添加一个函数 getKeys，该函数返回所有二元组(tuple)中的键(key)。</span></p><p><span style=\"font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, &quot;Noto Sans&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 1rem; font-weight: bolder;\">HINT</span><span style=\"font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, &quot;Noto Sans&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 1rem;\">：尝试通过添加额外代码(&lt;10行)完成该题。</span><br></p><p><span style=\"font-weight: bolder;\">EXAMPLE INPUT</span></p><pre style=\"font-size: 14px;\">2000\n</pre><p><span style=\"font-weight: bolder;\">EXAMPLE OUTPUT</span></p><pre style=\"font-size: 14px;\">2000\ntext51\ntext151\ntext251\ntext351\ntext451\ntext551\ntext651\ntext751\ntext851\ntext951\ntext1051\ntext1151\ntext1251\ntext1351\ntext1451\ntext1551\ntext1651\ntext1751\ntext1851\ntext1951\n0</pre>",
            "\n#include \"source.cpp\"\n\n#include <iostream>\n#include <sstream>\nusing namespace std;\n\nint main() {\n\tint test_count;\n\tcin >> test_count;\n\tHT<string> map;\n\tfor (int i = 0; i < test_count; ++ i) {\n\t\tstringstream ss;\n\t\tss << \"text\" << (1 + i);\n\t\tmap.put(i * 10, ss.str());\n\t}\n\tcout << map.size() << endl;\n\tfor (int i = 0; i < test_count; ++ i) {\n\t\tif (! map.containsKey(i * 10)) {\n\t\t\tcout << \"bad\" << endl;\n\t\t}\n\t\telse if (i % 100 == 50) {\n\t\t\tcout << map[i * 10] << endl;\n\t\t}\n\t}\n\tvector<int> keys = map.getKeys();\n\tfor (int i = 0; i < keys.size(); ++ i) {\n\t\tmap.remove(keys[i]);\n\t}\n\tcout << map.size() << endl;\n}",
            "#include <vector>\n#include <iostream>\n#include <string>\n#define I(i,n) for (size_t i = 0; i < n; ++ i)\nusing namespace std;\nclass NoSuchKeyException {};\nsize_t circular_shift(size_t bits, int shift_bits) {\n\tconst int num_bits = 8 * sizeof(size_t);\n\tshift_bits = shift_bits % num_bits;\n\treturn bits << shift_bits | bits >> (num_bits - shift_bits);\n}\n\n\nsize_t hash_function(const int & key) {\n\tsize_t code = 0;\n\t\n\tI(i, key)\n\t\tcode ^= circular_shift(key, i * 5);\n\treturn code;\n}\n\n\ntemplate <typename E> \nclass HT{\n\tclass Tuple\n\t{\n\tpublic:\n\t\tint key;\n\t\tE val;\n\t\tbool in_use;\n\n\t\tTuple() : in_use(false) {}\n\t};\n\tvector<Tuple> tuples;\n\tsize_t _size;\n\tsize_t canonical_index(const int & key) const {\n\t\tsize_t hash_code = hash_function(key); // needs hash_function(K)\n\t\treturn hash_code % tuples.size();\n\t}\n\tsize_t indexOfKey(const int & key) const {\n\t\tsize_t index = canonical_index(key);\n\t\twhile (true) { // will enter a dead loop if there is not empty tuple\n\t\t\tif (! tuples[index].in_use) return index;\n\t\t\tif (tuples[index].key == key) return index;\n\t\t\tindex = (index + 1) % tuples.size();\n\t\t}\n\t}\n\tpublic:\n\tHT() : _size(0) {\n\t\ttuples.resize(2);\n\t}\n\tbool containsKey(const int & key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\treturn tuples[index].in_use;\n\t}\n\n\tconst E & operator [] (const int & key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples[index].val;\n\t}\n\n\tE & operator [] (const int & key) {\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples[index].val;\n\t}\n\tvoid put(const int & key, const E & val) {\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].key = key;\n\t\ttuples[index].val = val;\n\t\tif (tuples[index].in_use) return;\n\t\ttuples[index].in_use = true;\n\t\t++ _size;\n\t\t// make sure empty > size / 2\n\t\tif (2 * _size > tuples.size())\n\t\t\t_double_tuples();\n\t}\n\t\tvoid _double_tuples() {\n\t\tvector<Tuple> non_empty_tuples;\n\t\tI(i, tuples.size())\n\t\t\tif (tuples[i].in_use)\n\t\t\t\tnon_empty_tuples.push_back(tuples[i]);\n\t\tclear();\n\t\ttuples.resize(tuples.size() * 2);\n\t\tI(i, non_empty_tuples.size())\n\t\t\tput(non_empty_tuples[i].key, non_empty_tuples[i].val);\n\t}\n\tstatic bool _between(size_t hole, size_t canonical, size_t tuple_index) {\n\t\tif (hole < tuple_index)\n\t\t\treturn canonical > hole && canonical <= tuple_index;\n\t\telse\n\t\t\treturn canonical > hole || canonical <= tuple_index;\n\t}\n\n\tvoid remove(const int & key) { \n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\ttuples[index].in_use = false;\n\t\t-- _size;\n\t\t// if there is a hole between a tuple and its canonical position\n\t\t// move the tuple to the hole\n\t\tsize_t hole = index;\n\t\tsize_t tuple_index = hole;\n\t\twhile (true) {\n\t\t\ttuple_index = (tuple_index + 1) % tuples.size();\n\t\t\tif (! tuples[tuple_index].in_use) return;\n\t\t\tsize_t canonical = canonical_index(tuples[tuple_index].key);\n\t\t\tif (_between(hole, canonical, tuple_index)) continue;\n\t\t\ttuples[hole] = tuples[tuple_index];\n\t\t\thole = tuple_index;\n\t\t\ttuples[hole].in_use = false;\n\t\t}\n\t}\n\n\tsize_t size() const { return _size; }\n    void clear() {\n\t\tI(i, tuples.size())\n\t\t\ttuples[i].in_use = false;\n\t\t_size = 0;\n\t}\n\ttemplate <typename K2>\n\tfriend ostream & operator << (ostream & out, const HT<K2> & dict);\n\n\ttemplate <typename K2>\n\tfriend istream & operator >> (istream & in, HT<K2> & dict);\n   \tvoid _inspect() const {\n\t\tI(i, tuples.size())\n\t\t\tif (tuples[i].in_use)\n\t\t\t\tcout << \"#\" << i << \" C\" << canonical_index(tuples[i].key) \n\t\t\t\t\t<< \" \" << tuples[i].key << \" \" << tuples[i].val << endl;\n\t}\n\tvector <int> getKeys(){\n\t\tvector<int>m;\n\t\tfor(int i=0;i<tuples.size();i++){\n\t\t\tif(tuples[i].in_use!=0) m.push_back(tuples[i].key);\n\t\t}\n\t\treturn m;\n\t}\n};\ntemplate <typename E>\nostream & operator << (ostream & out, const HT<E> & dict) {\n\tout << dict.size() << endl;\n\tI(i, dict.tuples.size())\n\t\tif (dict.tuples[i].in_use)\n\t\t\tout << dict.tuples[i].key << \"\\t\" << dict.tuples[i].val << endl;\n\treturn out;\n}\n\ntemplate <typename E>\nistream & operator >> (istream & in, HT<E> & dict) {\n\tdict.clear();\n\tsize_t size;\n\tin >> size;\n\tI(i, size) {\n\t\tint key;\n\t\tE val;\n\t\tin >> key >> val;\n\t\tdict.put(key, val);\n\t}\n\treturn in;\n}",
            "In file included from main.cpp:2:0:\nsource.cpp:97:20: error: ‘K’ does not name a type\n  void remove(const K & key) { \n                    ^\nsource.cpp:127:53: error: ‘HashTable’ does not name a type\n  friend ostream & operator << (ostream & out, const HashTable<K2,V2> & dict);\n                                                     ^\nsource.cpp:127:62: error: expected ‘,’ or ‘...’ before ‘<’ token\n  friend ostream & operator << (ostream & out, const HashTable<K2,V2> & dict);\n                                                              ^\nsource.cpp:130:46: error: ‘HashTable’ has not been declared\n  friend istream & operator >> (istream & in, HashTable<K2,V2> & dict);\n                                              ^\nsource.cpp:130:55: error: expected ‘,’ or ‘...’ before ‘<’ token\n  friend istream & operator >> (istream & in, HashTable<K2,V2> & dict);\n                                                       ^\nsource.cpp:141:45: error: ‘HashTable’ does not name a type\n ostream & operator << (ostream & out, const HashTable<K,V> & dict) {\n                                             ^\nsource.cpp:141:54: error: expected ‘,’ or ‘...’ before ‘<’ token\n ostream & operator << (ostream & out, const HashTable<K,V> & dict) {\n                                                      ^\nsource.cpp: In function ‘std::ostream& operator<<(std::ostream&, int)’:\nsource.cpp:142:9: error: ‘dict’ was not declared in this scope\n  out << dict.size() << endl;\n         ^\nsource.cpp: At global scope:\nsource.cpp:150:38: error: ‘HashTable’ has not been declared\n istream & operator >> (istream & in, HashTable<K,V> & dict) {\n                                      ^\nsource.cpp:150:47: error: expected ‘,’ or ‘...’ before ‘<’ token\n istream & operator >> (istream & in, HashTable<K,V> & dict) {\n                                               ^\nsource.cpp: In function ‘std::istream& operator>>(std::istream&, int)’:\nsource.cpp:151:2: error: ‘dict’ was not declared in this scope\n  dict.clear();\n  ^\nsource.cpp: At global scope:\nsource.cpp:163:8: error: ‘HashTable’ does not name a type\n inline HashTable<string, string> load_dict() {\n        ^\nsource.cpp:173:29: error: ‘HashTable’ does not name a type\n inline void save_dict(const HashTable<string, string> & dict) {\n                             ^\nsource.cpp:173:38: error: expected ‘,’ or ‘...’ before ‘<’ token\n inline void save_dict(const HashTable<string, string> & dict) {\n                                      ^\nsource.cpp: In function ‘void save_dict(int)’:\nsource.cpp:174:14: error: variable ‘std::ofstream out’ has initializer but incomplete type\n  ofstream out(\"my_dict.txt\");\n              ^\nsource.cpp:177:9: error: ‘dict’ was not declared in this scope\n  out << dict;\n         ^\nmain.cpp: In function ‘int main()’:\nmain.cpp:26:25: error: ‘class HT<std::__cxx11::basic_string<char> >’ has no member named ‘getKeys’\n  vector<int> keys = map.getKeys();\n                         ^\n",
            1595469600,
            1595475600,
            0,
            1595474946.2181246
        ]
    ]
}