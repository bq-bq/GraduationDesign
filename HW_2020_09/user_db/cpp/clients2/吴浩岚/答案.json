{
    "__update_time__": 1595475287.053597,
    "field_names": [
        "题目名",
        "用户名",
        "答案",
        "提交时间",
        "分数",
        "评语"
    ],
    "field_types": [
        "text",
        "text",
        "text",
        "time",
        "number",
        "text"
    ],
    "foreign_keys": {},
    "primary_keys": [],
    "rows": [
        [
            "测试1",
            "吴浩岚",
            "#include<iostream>\nusing namespace std;\nint main(){\n\tstring a,b,c;\n\tcin>>a>>b>>c;\n\tcout<<c<<' '<<b<<' '<<a;\n}",
            1587608058.3323424,
            100,
            "# 答案正确"
        ],
        [
            "测试2",
            "吴浩岚",
            "#include<iostream>\n#include<cstring> \nusing namespace std;\n\nint main(){\n   char a[10][10];\n   for(int i=0;i<10;i++)\n   cin>>a[i];\n   \tfor(int i = 0; i < 9; i++){\n\t\tfor(int j = i+1; j < 10; j++){\n\t\t\tif(strcmp(a[i],a[j])>0){\n\t\t\t\tchar temp[10];\n\t\t\t\tstrcpy(temp,a[i]);\n\t\t\t\tstrcpy(a[i],a[j]);\n\t\t\t\tstrcpy(a[j],temp);\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n   for(int i=0;i<10;i++)\n   cout<<a[i]<<' ';\n}",
            1587610309.9312785,
            100,
            "# 答案正确"
        ],
        [
            "1.1 (C++)",
            "吴浩岚",
            "class Matrix5x5{\n\tpublic:\n\t\tdouble mat[5][5];\n\t\tMatrix5x5(){\n\t\tfor (int row = 0; row < 5; ++ row) {\n\t\t\t\tfor (int col = 0; col < 5; ++ col) {\n\t\t\t\t\tthis->mat[row][col] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble get(int row, int col){\n\t\t\treturn this->mat[row][col];\n\t\t}\n\t\tvoid set(int row, int col, double val){\n\t\t\tthis->mat[row][col] = val;\n\t\t}\n\t\tMatrix5x5 operator + ( Matrix5x5 & b){\n\t\t\tMatrix5x5 temp;\n\t\t\tfor (int row = 0; row < 5; ++ row) {\n\t\t\t\tfor (int col = 0; col < 5; ++ col) {\n\t\t\t\t\ttemp.mat[row][col] = this->mat[row][col]+b.mat[row][col];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn temp;\n\t\t}\n};\n\t\n\t\t",
            1587699912.4921393,
            100,
            "# 答案正确"
        ],
        [
            "1.2 (C++)",
            "吴浩岚",
            "#include<cstring>\nclass School{\n\tpublic:\n\t\tchar name[10];\n\tSchool(){\n\t\tstrcpy(name,\"NO_NAME\");\n\t}\n\t\tint age = 0;\n\tvoid setName(char name[]){\n\tstrcpy(this->name,name);\n\t}\n\tvoid setAge(int year){\n\t\tthis->age = year;\n\t}\n};\nvoid operator ++ (School & school){\n\tschool.age++;\n}\n",
            1588213635.879605,
            100,
            "# 答案正确"
        ],
        [
            "2.1 (C++)",
            "吴浩岚",
            "#include <iostream>\nusing namespace std;\nclass Matrix{\n\tprivate:\n\t\tint rows;\n\t\tint columns;\n\t\tdouble values[100][100];\n\tpublic:\n\t\tMatrix(int rows, int columns){\n\t\t\tthis->rows = rows;\n\t\t\tthis->columns = columns;\n\t\t\tfor (int i = 0; i < rows; ++ i) {\n\t\t\t\tfor (int j = 0; j < columns; ++ j) {\n\t\t\t\t\tvalues[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvoid print(){\n\t\t\tfor (int i = 0; i < this->rows; ++ i) {\n\t\t\t\tfor (int j = 0; j < this->columns; ++ j) {\n\t\t\t\t\tprintf(\"    %d\",(int)values[i][j] );\n\t\t\t\t}\n\t\t\t\tif(i!=this->rows-1)putchar('\\n');\n\t\t\t}\n\t\t}\n};",
            1588908295.4803033,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/08",
            "吴浩岚",
            "double & Tensor_get(int dimensions, const int sizes[],double data[], int x0, int x1, int x2, int x3)\n{\n if (dimensions == 1)\n  return data[x0];\n if (dimensions == 2)\n  return data[x0 * sizes[1] + x1];\n if (dimensions == 3)\n  return data[x0 * sizes[1] * sizes[2] + x1 * sizes[2] + x2];\n if (dimensions == 4)\n  return data[x0 * sizes[1] * sizes[2] * sizes[3]+ x1 * sizes[2] * sizes[3]+ x2 * sizes[3] + x3];\n}",
            1588906176.070483,
            100,
            "# 答案正确"
        ],
        [
            "2.2 (C++)",
            "吴浩岚",
            "#include <iostream>\n#include<iomanip>\nusing namespace std;\nclass Matrix{\n\tprivate:\n\t\tint rows;\n\t\tint columns;\n\t\tdouble*  values;\n\tpublic:\n\t\tMatrix(int rows, int columns, double values[]){\n\t\t\tthis->rows = rows;\n\t\t\tthis->columns = columns;\n\t\t\tthis->values = values;\n\t\t}\n\t\tvoid print(){\n\t\t\tint cnt = 0;\n\t\t\tfor (int i = 0; i < this->rows; ++ i) {\n\t\t\t\tfor(int j = 0; j < this->columns; j ++){\n\t\t\t\t\tcout <<(int)this->values[cnt]<<setw(5);\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t\tif(i!=this->rows)putchar('\\n');\n\t\t\t}\n\t\t\t\n\t\t}\n};",
            1588913432.1458583,
            100,
            "# 答案正确"
        ],
        [
            "2.3 (C++)",
            "吴浩岚",
            "#include <iostream>\n#include<iomanip>\nusing namespace std;\nclass Matrix{\n\tprivate:\n\t\tint rows;\n\t\tint columns;\n\t\tdouble*  values;\n\tpublic:\n\t// copy constructor\n\t\tMatrix(const Matrix & matrix2){\n\t\t\tthis->rows = matrix2.rows;\n\t\t\tthis->columns = matrix2.columns;\n\t\t\tthis->values = matrix2.values;\n\t\t}\n\t\tMatrix(int rows, int columns, double values[]){\n\t\t\tthis->rows = rows;\n\t\t\tthis->columns = columns;\n\t\t\tthis->values = values;\n\t\t}\n\t\tvoid print(){\n\t\t\tint cnt = 0;\n\t\t\tfor (int i = 0; i < this->rows; ++ i) {\n\t\t\t\tfor(int j = 0; j < this->columns; j ++){\n\t\t\t\t\tcout <<\"    \"<<(int)this->values[cnt];\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t\tif(i!=this->rows)putchar('\\n');\n\t\t\t}\n\t\t\t\n\t\t}\n};",
            1588939689.384688,
            100,
            "# 答案正确"
        ],
        [
            "2.5 (C++)",
            "吴浩岚",
            "#include <iostream>\n#include<iomanip>\nusing namespace std;\n\nclass Matrix{\n\tprivate:\n\t\tint rows;\n\t\tint columns;\n\t\tdouble*  values;\n\tpublic:\n\t\tMatrix(int rows, int columns, double values[]){\n\t\t\tthis->rows = rows;\n\t\t\tthis->columns = columns;\n\t\t\tthis->values = values;\n\t\t}\n\t\tvoid print(){\n\t\t\tint cnt = 0;\n\t\t\tfor (int i = 0; i < this->rows; ++ i) {\n\t\t\t\tfor(int j = 0; j < this->columns; j ++){\n\t\t\t\t\tcout <<\"    \"<<(int)this->values[cnt];\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t\tif(i!=this->rows)putchar('\\n');\n\t\t\t}\n\t\t\tif(this->columns == 1)delete [] this->values;\n\t\t\t\n\t\t}\n\t\tMatrix getRow(int row){\n\t\t\treturn Matrix(1, this->columns, this->values+(row-1)*columns);\n\t\t}\n\t\tMatrix getColumn(int column){\n\t\t\t  double* values2 = new double[100]; \n\t\t\tfor(int i = 0; i < this->rows; i ++){\n\t\t\t\tvalues2[i] = this->values[column-1+ i*this->columns];\n\t\t\t}\n\t\t\treturn Matrix(this->rows,1, values2);\n\t\t}\n};",
            1588990337.2324822,
            100,
            "# 答案正确"
        ],
        [
            "2.6 (C++)",
            "吴浩岚",
            "#include <iostream>\n#include<iomanip>\nusing namespace std;\n \nclass Matrix{\n\t private:\n        int rows;\n        int columns;\n        double * values;\n        \n    public:\n        Matrix(int row,int column,double value[]){\n           rows=row;\n           columns=column;\n           values=new double [rows*columns];\n           for(int m=0;m<rows*columns;m++)\n           values[m]=value[m]; \n        }\n        Matrix(const Matrix & matrix){\n            rows=matrix.rows;\n            columns=matrix.columns;\n            values=new double [rows*columns];\n            for(int m=0;m<rows*columns;m++)\n            values[m]=matrix.values[m];\n        }\n        ~Matrix(){\n           delete  [] values;\n         }\n\t\tvoid print(){\n\t\t\tint cnt = 0;\n\t\t\tfor (int i = 0; i < this->rows; ++ i) {\n\t\t\t\tfor(int j = 0; j < this->columns; j ++){\n\t\t\t\t\tcout <<\"    \"<<(int)this->values[cnt];\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t\tif(i!=this->rows)putchar('\\n');\n\t\t\t}\n\t\t\t\n\t\t}\n\t   \n\t   Matrix concatenateRows(const Matrix & matrix2)const {\n\t\t    double newarr[200];\n\t\t   for(int i = 0 ; i < this->rows*this->columns; i++){\n\t\t\t\tnewarr[i] = this->values[i];\n\t\t   }\n\t\t    for(int i = 0 ; i < this->rows*this->columns; i++){\n\t\t\tnewarr[i+this->rows*this->columns] = matrix2.values[i];\n\t\t   }\n\t\t\treturn Matrix(rows*2,columns,newarr);\n\t   }\n\t   Matrix concatenateColumns(const Matrix & matrix2) const{\n\t\t    double newarr[200];\n\t\t   int cnt = 0;\n\t\t   int cnt1 = 0, cnt2 = 0;\n\t\t \tfor(int i = 0; i < this->rows; i++){\n\t\t\t\tfor(int j = 0; j < this->columns; j++, cnt1++,cnt++){\n\t\t\t\t\tnewarr[cnt] = this->values[cnt1];\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < this->columns; j++,cnt2++,cnt++){\n\t\t\t\t\tnewarr[cnt] = matrix2.values[cnt2];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Matrix(rows,columns*2,newarr);\n\t   }\n};",
            1588994287.692914,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/14",
            "吴浩岚",
            "#include <iostream>\nusing namespace std;\nvoid Tensor_print(int dimensions, const int sizes[], const double data[]){\n\tif(dimensions == 1){\n\t\tcout<<\"Tensor of \"<<sizes[0]<<endl;\n\t\tfor(int i = 0; i<sizes[0]; i++)cout<<data[0]<<endl;\n\t}else if(dimensions == 2){\n\t\tcout<<\"Tensor of \"<<sizes[0]<<\"x\"<<sizes[1]<<endl;\n\t\tfor(int i = 0; i<sizes[0]; i++){\n\t\t\tfor(int j = 0; j < sizes[1]; j ++){\n\t\t\t\tcout<<\"    \"<<data[1];\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t}else if(dimensions == 3){\n\t\tcout<<\"Tensor of \"<<sizes[0]<<\"x\"<<sizes[1]<<\"x\"<<sizes[2]<<endl;\n\t\tfor(int k = 0; k < sizes[0]; k++){\n\t\t\tcout << \"data[\"<<k<<\"]\"<<endl;\n\t\t\t    for(int i = 0; i<sizes[1]; i++){\n\t\t\t        for(int j = 0; j < sizes[2]; j ++){\n\t\t\t\t        cout<<\"    \"<<data[2];\n\t\t\t         }\n\t\t\t    cout<<endl;\n\t\t       }\n\t\t}\n\t}else if(dimensions == 4){\n\t\tcout<<\"Tensor of \"<<sizes[0]<<\"x\"<<sizes[1]<<\"x\"<<sizes[2]<<'x'<<sizes[3]<<endl;\n\t\tfor(int k = 0; k < sizes[0]; k++){\n\t\t\tfor(int l  = 0; l< sizes[1]; l++){\n\t\t\t\tcout<<\"data[\"<<k<<\"][\"<<l<<\"]\"<<endl;\n\t\t\t    for(int i = 0; i<sizes[2]; i++){\n\t\t\t        for(int j = 0; j < sizes[3]; j ++){\n\t\t\t\t        cout<<\"    \"<<data[3];\n\t\t\t         }\n\t\t\t    cout<<endl;\n\t\t       }\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n}",
            1589423556.315428,
            100,
            "# 答案正确"
        ],
        [
            "2.4 (C++)",
            "吴浩岚",
            "#include <iostream>\n#include<iomanip>\nusing namespace std;\n \nclass Matrix{\n  private:\n        int rows = 0;\n        int columns = 0;\n        double * values;\n        \n    public:\n   Matrix(int row,int column){\n           rows=row;\n           columns=column;\n        }\n        Matrix(int row,int column,double value[]){\n           rows=row;\n           columns=column;\n           values=new double [rows*columns];\n           for(int m=0;m<rows*columns;m++)\n           values[m]=value[m]; \n        }\n        Matrix const operator =(const Matrix & matrix){\n            rows=matrix.rows;\n            columns=matrix.columns;\n            values=new double [rows*columns];\n            for(int m=0;m<rows*columns;m++)\n            values[m]=matrix.values[m];\n        }\n        ~Matrix(){\n           delete  [] values;\n         }\n  \n  void print(){\n   int cnt = 0;\n   for (int i = 0; i < this->rows; ++ i) {\n    for(int j = 0; j < this->columns; j ++){\n     cout <<\"    \"<<this->values[cnt];\n     cnt++;\n    }\n    if(i!=this->rows)putchar('\\n');\n   }\n   \n  }\n    void set(int row, int column, double value){\n    this->values[(row-1)*columns+column-1] = value;\n     return;\n    }\n    \n   \n};",
            1589513416.316007,
            100,
            "# 答案正确"
        ],
        [
            "2.7 (C++)",
            "吴浩岚",
            "#include <iostream>\n#include<iomanip>\nusing namespace std;\n double newarr[1000] = {0};\n double newarr2[1000] = {0};\nclass Matrix{\n\t private:\n        int rows = 0;\n        int columns = 0;\n        double * values;\n        \n    public:\n\t\t\tMatrix(int row,int column){\n           rows=row;\n           columns=column;\n        }\n        Matrix(int row,int column,double value[]){\n           rows=row;\n           columns=column;\n           values=new double [rows*columns];\n           for(int m=0;m<rows*columns;m++)\n           values[m]=value[m]; \n        }\n        Matrix (const Matrix & matrix){\n            rows=matrix.rows;\n            columns=matrix.columns;\n            values=new double [rows*columns];\n            for(int m=0;m<rows*columns;m++)\n            values[m]=matrix.values[m];\n        }\n        ~Matrix(){\n           delete  [] values;\n         }\n\t\t\n\t\tvoid print(){\n\t\t\tint cnt = 0;\n\t\t\tfor (int i = 0; i < this->rows; ++ i) {\n\t\t\t\tfor(int j = 0; j < this->columns; j ++){\n\t\t\t\t\tcout <<\"    \"<<this->values[cnt];\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t\tif(i!=this->rows)putchar('\\n');\n\t\t\t}\n\t\t\t\n\t\t}\n\t   void set(int row, int column, double value){\n\t\t\t\tthis->values[(row-1)*columns+column-1] = value;\n\t\t   return;\n\t   }\n\t   Matrix reshape(int rows, int columns)const {\n\t\t\t\t\n\t\t   \t\t\n\t\t   int cnt = 0;\n\t\t   \t\tfor(int i = 0; i < this->columns; i++){\n\t\t\t\t\tfor(int j = 0; j < this->rows; j++,cnt++){\n\t\t\t\t\t\tnewarr[cnt] = values[j*(this->columns)+i];\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t   cnt = 0;\n\t\t   \n\t\t   \tfor(int i = 0; i < columns; i++){\n\t\t\t\t\tfor(int j = 0; j < rows; j++,cnt++){\n\t\t\t\t\t\tnewarr2[j*(columns)+i] = newarr[cnt] ;\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t   \t\t\n\t\t   \t\treturn Matrix(rows, columns, newarr2);\n\t   }\n\t  \n};",
            1589512545.4807673,
            100,
            "# 答案正确"
        ],
        [
            "2.8 (C++)",
            "吴浩岚",
            "#include <iostream>\n#include<iomanip>\nusing namespace std;\n double newarr[1000] = {0};\nclass Matrix{\n\t private:\n        int rows = 0;\n        int columns = 0;\n        double * values;\n        \n    public:\n\t\t\t\n        Matrix(int row,int column,double value[]){\n           rows=row;\n           columns=column;\n           values=new double [rows*columns];\n           for(int m=0;m<rows*columns;m++)\n           values[m]=value[m]; \n        }\n        Matrix (const Matrix & matrix){\n            rows=matrix.rows;\n            columns=matrix.columns;\n            values=new double [rows*columns];\n            for(int m=0;m<rows*columns;m++)\n            values[m]=matrix.values[m];\n        }\n        ~Matrix(){\n           delete  [] values;\n         }\n\t\t\n\t\tvoid print(){\n\t\t\tint cnt = 0;\n\t\t\tfor (int i = 0; i < this->rows; ++ i) {\n\t\t\t\tfor(int j = 0; j < this->columns; j ++){\n\t\t\t\t\tcout <<\"    \"<<this->values[cnt];\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t\tif(i!=this->rows)putchar('\\n');\n\t\t\t}\n\t\t\t\n\t\t}\n\t   void set(int row, int column, double value){\n\t\t\t\tthis->values[(row-1)*columns+column-1] = value;\n\t\t   return;\n\t   }\n\t   Matrix transpose() {\n\t\t\t\t\n\t\t   \t\t\n\t\t   int cnt = 0;\n\t\t   \t\tfor(int i = 0; i < columns; i++){\n\t\t\t\t\tfor(int j = 0; j < rows; j++,cnt++){\n\t\t\t\t\t\tnewarr[cnt] = values[j*(columns)+i];\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t  \n\t\t   \t\t\n\t\t   \t\treturn Matrix(columns, rows, newarr);\n\t   }\n\t  \n};",
            1589513967.1500347,
            100,
            "# 答案正确"
        ],
        [
            "2.10 (C++)",
            "吴浩岚",
            "#include <iostream>\n#include<iomanip>\nusing namespace std;\n double newarr[1000] = {0};\n double newarr1[100][100] = {0};\n double newarr2[100][100] = {0};\n double newarr3[100][100] = {0};\nclass Matrix{\n\t private:\n        int rows = 0;\n        int columns = 0;\n        double * values;\n        \n    public:\n\t\t\t\n        Matrix(int row,int column,double value[]){\n           rows=row;\n           columns=column;\n           values=new double [rows*columns];\n           for(int m=0;m<rows*columns;m++)\n           values[m]=value[m]; \n        }\n        Matrix (const Matrix & matrix){\n            rows=matrix.rows;\n            columns=matrix.columns;\n            values=new double [rows*columns];\n            for(int m=0;m<rows*columns;m++)\n            values[m]=matrix.values[m];\n        }\n        ~Matrix(){\n           delete  [] values;\n         }\n\t\t\n\t\tvoid print(){\n\t\t\tint cnt = 0;\n\t\t\tfor (int i = 0; i < this->rows; ++ i) {\n\t\t\t\tfor(int j = 0; j < this->columns; j ++){\n\t\t\t\t\tcout <<\"    \"<<this->values[cnt];\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t\tif(i!=this->rows)putchar('\\n');\n\t\t\t}\n\t\t\t\n\t\t}\n\t   void set(int row, int column, double value){\n\t\t\t\tthis->values[(row-1)*columns+column-1] = value;\n\t\t   return;\n\t   }\n\t   Matrix transpose() {\n\t\t\t\t\n\t\t   \t\t\n\t\t   int cnt = 0;\n\t\t   \t\tfor(int i = 0; i < columns; i++){\n\t\t\t\t\tfor(int j = 0; j < rows; j++,cnt++){\n\t\t\t\t\t\tnewarr[cnt] = values[j*(columns)+i];\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t  \n\t\t   \t\t\n\t\t   \t\treturn Matrix(columns, rows, newarr);\n\t   }\n\t//坐标表示法 (row-1)*columns+column-1\n\t   Matrix  operator * (const Matrix & matrix2) const{\n\t\t   double arr[100] = {0};\n\t\t  \n\t\t   for(int i = 0; i < this->rows; i ++){\n\t\t\t\tfor(int j = 0; j <  matrix2.columns; j ++){\n\t\t\t\t\tfor (int l = 0, m = 0; l < matrix2.rows; l++,m++){\n       arr[i*matrix2.columns+j] += this->values[i*this->columns+l] * matrix2.values[m * matrix2.columns+j];\n                }\n\t\t\t\t}\n\t\t   }\n\t\t    Matrix newmatrix(this->rows, matrix2.columns, arr);\n\t\t   return newmatrix;\n\t   }\n\t\tMatrix  operator * (double value)  const{\n\t\t\t\n\t\t\tfor(int i = 0; i < rows*columns; i++){\n\t\t\t\tvalues[i] = values[i]*value;\n\t\t\t}\n\t\t\treturn *this;\n\t\t}\n\t  \n};",
            1589521630.840911,
            100,
            "# 答案正确"
        ],
        [
            "2.11 (C++)",
            "吴浩岚",
            "#include <iostream>\n#include<iomanip>\nusing namespace std;\n#define INF 1e7\n\nclass Matrix{\n\t private:\n        int rows = 0;\n        int columns = 0;\n        double * values;\n        \n    public:\n\t\t\tMatrix(int row,int column){\n           rows=row;\n           columns=column;\n        }\n        Matrix(int row,int column,double value[]){\n           rows=row;\n           columns=column;\n           values=new double [rows*columns];\n           for(int m=0;m<rows*columns;m++)\n           values[m]=value[m]; \n        }\n        Matrix (const Matrix & matrix){\n            rows=matrix.rows;\n            columns=matrix.columns;\n            values=new double [rows*columns];\n            for(int m=0;m<rows*columns;m++)\n            values[m]=matrix.values[m];\n        }\n        ~Matrix(){\n           delete  [] values;\n         }\n\t\t\n\t\tvoid print(){\n\t\t\tint cnt = 0;\n\t\t\tfor (int i = 0; i < this->rows; ++ i) {\n\t\t\t\tfor(int j = 0; j < this->columns; j ++){\n\t\t\t\t\tcout <<\"    \"<<this->values[cnt];\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t\tif(i!=this->rows)putchar('\\n');\n\t\t\t}\n\t\t\t\n\t\t}\n\t     Matrix max() const{\n\t\t\t \tif(rows>1){\n\t\t\t\t\tdouble newarr[1000] = {0};\n\t\t\t\t\tint max,maxrows;\n\t\t\t \t\tfor(int i = 0; i < this->columns;i++){\n\t\t\t\t\t\tmax = 0;\n\t\t\t\t\t\tmaxrows = 0;\n\t\t\t\t\t\tfor(int j = 0 ;j < this->rows; j++){\n\t\t\t\t\t\t\tif(values[columns*j+i]>max){\n\t\t\t\t\t\t\t\tmax = values[columns*j+i];\n\t\t\t\t\t\t\t\tmaxrows = j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnewarr[i] = this->values[this->columns*maxrows + i];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn  Matrix(1,columns,newarr);\n\t\t\t\t}\n\t\t\t\tif(rows==1){\n\t\t\t\t\tint max = 0;\n\t\t\t\t\tfor(int i = 0; i < columns; i++){\n\t\t\t\t\t\tif(values[i] > max)max = values[i];\n\t\t\t\t\t}\n\t\t\t\t\tdouble newarr[1] ;\n\t\t\t\t\tnewarr[0] = max;\n\t\t\t \t\treturn Matrix(1,1,newarr);\n\t\t\t\t}\n\t\t\t \t\n\t\t  }\n\t\t  Matrix min() const{\n\t\t\t  if(rows>1){\n\t\t\t\t\tdouble newarr[1000] = {0};\n\t\t\t\t\tint min,minrows;\n\t\t\t \t\tfor(int i = 0; i < this->columns;i++){\n\t\t\t\t\t\tmin = INF;\n\t\t\t\t\t\tminrows = 0;\n\t\t\t\t\t\tfor(int j = 0 ;j < this->rows; j++){\n\t\t\t\t\t\t\tif(values[columns*j+i]<min){\n\t\t\t\t\t\t\t\tmin = values[columns*j+i];\n\t\t\t\t\t\t\t\tminrows = j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnewarr[i] = this->values[this->columns*minrows + i];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn  Matrix(1,columns,newarr);\n\t\t\t\t}\n\t\t\t\tif(rows==1){\n\t\t\t\t\tint min = INF;\n\t\t\t\t\tfor(int i = 0; i < columns; i++){\n\t\t\t\t\t\tif(values[i] < min)min = values[i];\n\t\t\t\t\t}\n\t\t\t\t\tdouble newarr[1] ;\n\t\t\t\t\tnewarr[0] = min;\n\t\t\t \t\treturn Matrix(1,1,newarr);\n\t\t\t\t}\n\t\t  }\n\t\t  Matrix sum() const {\n\t\t\t\tif(rows>1){\n\t\t\t\t\tdouble newarr[1000] = {0};\n\t\t\t\t\tint sum;\n\t\t\t \t\tfor(int i = 0; i < this->columns;i++){\n\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\tfor(int j = 0 ;j < this->rows; j++){\n\t\t\t\t\t\t\t\tsum += values[columns*j+i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnewarr[i] = sum;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn  Matrix(1,columns,newarr);\n\t\t\t\t}\n\t\t\t  if(rows==1){\n\t\t\t\t\tint sum = 0;\n\t\t\t\t\tfor(int i = 0; i < columns; i++){\n\t\t\t\t\t\tsum += values[i];\n\t\t\t\t\t}\n\t\t\t\t\tdouble newarr[1] ;\n\t\t\t\t\tnewarr[0] = sum;\n\t\t\t \t\treturn Matrix(1,1,newarr);\n\t\t\t\t}\n\t\t  }\n\t  \n\t  \n};",
            1589631766.9120429,
            100,
            "# 答案正确"
        ],
        [
            "2.12 (C++)",
            "吴浩岚",
            "#include <iostream>\n#include<iomanip>\nusing namespace std;\n#include<cmath>\n\nclass Matrix{\n\t private:\n        int rows = 0;\n        int columns = 0;\n        double * values;\n        \n    public:\n\t\t\tMatrix(int row,int column){\n           rows=row;\n           columns=column;\n        }\n        Matrix(int row,int column,double value[]){\n           rows=row;\n           columns=column;\n           values=new double [rows*columns];\n           for(int m=0;m<rows*columns;m++)\n           values[m]=value[m]; \n        }\n        Matrix (const Matrix & matrix){\n            rows=matrix.rows;\n            columns=matrix.columns;\n            values=new double [rows*columns];\n            for(int m=0;m<rows*columns;m++)\n            values[m]=matrix.values[m];\n        }\n        ~Matrix(){\n           delete  [] values;\n         }\n\t\t\n\t\tvoid print(){\n\t\t\tint cnt = 0;\n\t\t\tfor (int i = 0; i < this->rows; ++ i) {\n\t\t\t\tfor(int j = 0; j < this->columns; j ++){\n\t\t\t\t\tcout <<\"    \"<<this->values[cnt];\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t\tif(i!=this->rows)putchar('\\n');\n\t\t\t}\n\t\t\t\n\t\t}\n\t     Matrix max() const{\n\t\t\t \tif(rows>1){\n\t\t\t\t\tdouble newarr[1000] = {0};\n\t\t\t\t\tint max,maxrows;\n\t\t\t \t\tfor(int i = 0; i < this->columns;i++){\n\t\t\t\t\t\tmax = 0;\n\t\t\t\t\t\tmaxrows = 0;\n\t\t\t\t\t\tfor(int j = 0 ;j < this->rows; j++){\n\t\t\t\t\t\t\tif(values[columns*j+i]>max){\n\t\t\t\t\t\t\t\tmax = values[columns*j+i];\n\t\t\t\t\t\t\t\tmaxrows = j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnewarr[i] = this->values[this->columns*maxrows + i];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn  Matrix(1,columns,newarr);\n\t\t\t\t}\n\t\t\t\tif(rows==1){\n\t\t\t\t\tint max = 0;\n\t\t\t\t\tfor(int i = 0; i < columns; i++){\n\t\t\t\t\t\tif(values[i] > max)max = values[i];\n\t\t\t\t\t}\n\t\t\t\t\tdouble newarr[1] ;\n\t\t\t\t\tnewarr[0] = max;\n\t\t\t \t\treturn Matrix(1,1,newarr);\n\t\t\t\t}\n\t\t\t \t\n\t\t  }\n\t\tMatrix pow(double exponent){\n\t\t\t\tdouble newarr[1000] = {0};\n\t\t\t \tfor(int i = 0; i < rows * columns; i++){\n\t\t\t\t\t\n\t\t\t\t\t\tnewarr[i] = std::pow(values[i], exponent);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t return Matrix(rows,columns, newarr);\n\t\t }\n\t\tMatrix  exp(){\n\t\t\t double newarr[1000] = {0};\n\t\t\t \tfor(int i = 0; i < rows * columns; i++){\n\t\t\t\t\t\n\t\t\t\t\t\tnewarr[i] = std::exp(values[i]);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t return Matrix(rows,columns, newarr);\n\t\t }\n\t\tMatrix log(){\n\t\t\t  double newarr[1000] = {0};\n\t\t\t \tfor(int i = 0; i < rows * columns; i++){\n\t\t\t\t\t\n\t\t\t\t\t\tnewarr[i] = std::log(values[i]);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t return Matrix(rows,columns, newarr);\n\t\t }\n\t\t Matrix  abs(){\n\t\t\t double newarr[1000] = {0};\n\t\t\t \tfor(int i = 0; i < rows * columns; i++){\n\t\t\t\t\t\n\t\t\t\t\t\tnewarr[i] = std::abs(values[i]);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t return Matrix(rows,columns, newarr);\n\t\t }\n\t  \n};",
            1589633622.2989185,
            100,
            "# 答案正确"
        ],
        [
            "2.9 (C++)",
            "吴浩岚",
            "#include <iostream>\n#include<iomanip>\nusing namespace std;\n#include<cmath>\n\nclass Matrix{\n\t private:\n        int rows = 0;\n        int columns = 0;\n        double * values;\n        \n    public:\n\t\t\tMatrix(int row,int column){\n           rows=row;\n           columns=column;\n        }\n        Matrix(int row,int column,double value[]){\n           rows=row;\n           columns=column;\n           values=new double [rows*columns];\n           for(int m=0;m<rows*columns;m++)\n           values[m]=value[m]; \n        }\n        Matrix (const Matrix & matrix){\n            rows=matrix.rows;\n            columns=matrix.columns;\n            values=new double [rows*columns];\n            for(int m=0;m<rows*columns;m++)\n            values[m]=matrix.values[m];\n        }\n        ~Matrix(){\n           delete  [] values;\n         }\n\t\t\n\t\tvoid print(){\n\t\t\tint cnt = 0;\n\t\t\tfor (int i = 0; i < this->rows; ++ i) {\n\t\t\t\tfor(int j = 0; j < this->columns; j ++){\n\t\t\t\t\tcout <<\"    \"<<this->values[cnt];\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t\tif(i!=this->rows)putchar('\\n');\n\t\t\t}\n\t\t\t\n\t\t}\n\t    \n\tMatrix operator + (const Matrix & matrix2) const{\n\t\tdouble newarr[100] = {0};\n\t\tfor(int i = 0; i < rows*columns; i++)newarr[i] = values[i]+ matrix2.values[i];\n\t\treturn Matrix(rows,columns,newarr);\n\t}\n\tMatrix operator + (double value) const{\n\t\tdouble newarr[100] = {0};\n\t\tfor(int i = 0; i < rows*columns; i++)newarr[i] = values[i]+value;\n\t\treturn Matrix(rows,columns,newarr);\n\t}\n\tMatrix operator - (const Matrix & matrix2) const{\n\t\tdouble newarr[100] = {0};\n\t\tfor(int i = 0; i < rows*columns; i++)newarr[i] = values[i]- matrix2.values[i];\n\t\treturn Matrix(rows,columns,newarr);\n\t}\n\tMatrix operator - (double value) const{\n\t\tdouble newarr[100] = {0};\n\t\tfor(int i = 0; i < rows*columns; i++)newarr[i] = values[i]-value;\n\t\treturn Matrix(rows,columns,newarr);\n\t}\n};\n",
            1590028401.2607105,
            100,
            "# 答案正确"
        ],
        [
            "6.1 (C++)",
            "吴浩岚",
            "#include<string.h>\ntemplate<typename T>\nclass Matrix\n{\n\t private:\n \tint row;\n \tint col;\n \tT * buffer;\n public:\n \tMatrix(int x,int y){\n  \t\trow=x;\n  \t\tcol=y;\n  \t\tbuffer=new T[row*col];\n  \t\tmemset(buffer,0,sizeof(T)*row*col);\n \t}\n\t Matrix(int x,int y,const T*val){\n \t\t row=x;\n  \t\tcol=y;\n  \t\tbuffer=new T[row*col];\n  \t\tfor(int i=0;i<row*col;i++){\n   \t\tbuffer[i]=val[i];\n \t\t }\n \t}\n\t ~Matrix(){\n \t\t delete [] buffer;\n \t}\n\t Matrix(const Matrix<T>&ma){\n  \t\tif(buffer!=NULL)delete []buffer;\n  \t\trow=ma.row;\n  \t\tcol=ma.col;\n  \t\tbuffer=new T[row*col];\n  \t\tfor(int i= 0;i<row*col;i++){\n  \t\t\t buffer[i]=ma.buffer[i];\n \t\t }\n \t}\n \n void print(){\n  \tfor(int i=0;i<row;i++){\n   for(int j=0;j<col;j++){\n    cout<<\"    \";\n    cout<<buffer[i*col+j];\n   }\n  \t\t cout<<endl;\n \t }\n }\n\t Matrix &operator =(const Matrix&ma){\n \t\t if(buffer!=NULL) delete[]buffer;\n \t\t row=ma.row;\n \t\t col=ma.col;\n \t\t buffer=new T[ma.row*ma.col];\n \t\t for(int i=0;i<row*col;i++){\n  \t\t buffer[i]=ma.buffer[i];\n \t\t }\n \t\t return *this;\n \t}\n\t T &get(int x,int y){\n  \t\treturn buffer[(x-1)*col+y-1];\n \t}\n};",
            1590129743.1267781,
            100,
            "# 答案正确"
        ],
        [
            "6.3 (C++)",
            "吴浩岚",
            "#include <vector>\n#include <iostream>\n#include <string.h>\n#define INF 0x7f7f7f7f\nusing namespace std;\n\ntemplate<typename T>\nclass Matrix\n{\n\t private:\n \tint rows;\n \tint columns;\n \t vector<T> values;\n public:\n \tMatrix(int x,int y){\n  \t\trows=x;\n  \t\tcolumns=y;\n\t\tfor(int i =0 ; i < rows*columns; i++)values.push_back(0);\n  \t\t\n \t}\n\t Matrix(int x,int y,const vector<T>val){\n \t\t rows=x;\n  \t\tcolumns=y;\n  \t\tfor(int i=0;i<rows*columns;i++){\n   \t\tvalues.push_back(val[i]);\n \t\t }\n \t}\n\t ~Matrix(){\n \t\t values.clear();\n \t}\n\t Matrix(const Matrix<T>&mat){\n  \t\t values.clear();\n  \t\trows=mat.rows;\n  \t\tcolumns=mat.columns;\n  \n  \t\tfor(int i=0;i<rows*columns;i++){\n   \t\tvalues.push_back(mat.values[i]);\n \t\t }\n \t}\n \n void print(){\n  \tfor(int i=0;i<rows;i++){\n   for(int j=0;j<columns;j++){\n    cout<<\"    \";\n    cout<<values[i*columns+j];\n   }\n  \t\t cout<<endl;\n \t }\n }\n\t Matrix &operator =(const Matrix&mat){\n \t\t\tvalues.clear();\n  \t\trows = mat.rows;\n  \t\tcolumns=mat.columns;\n  \t\n  \t\tfor(int i=0;i<rows*columns;i++){\n   \t\tvalues.push_back(mat.values[i]);\n \t\t }\n \t\t return *this;\n \t}\n\t T &get(int x,int y){\n  \t\treturn values[(x-1)*columns+y-1];\n \t}\n \t\n \tMatrix transpose() {\n\t\t   vector<T> newarr;\n\t\t   \t\tfor(int i = 0; i < columns; i++){\n\t\t\t\t\tfor(int j = 0; j < rows; j++){\n\t\t\t\t\t\tnewarr.push_back(values[j*(columns)+i]) ;\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t   \t\treturn Matrix(columns, rows, newarr);\n\t   }\n\t   \n\t   //坐标表示法 (row-1)*columns+column-1\n\t   Matrix  operator * (const Matrix<T> & matrix2) const{\n\t\t  vector<T> arr;\n\t\t  for(int i = 0; i < rows*columns; i++)arr.push_back(0);\n\t\t   for(int i = 0; i < this->rows; i ++){\n\t\t\t\tfor(int j = 0; j <  matrix2.columns; j ++){\n\t\t\t\t\tfor (int l = 0, m = 0; l < matrix2.rows; l++,m++){\n       arr[i*matrix2.columns+j] += this->values[i*this->columns+l] * matrix2.values[m * matrix2.columns+j];\n                }\n\t\t\t\t}\n\t\t   }\n\t\t    Matrix<T> newmatrix(rows, matrix2.columns, arr);\n\t\t   return newmatrix;\n\t   }\n\t\tMatrix  operator * (T value)  const{\n\t\t\tvector<T> arr;\n\t\t  for(int i = 0; i < rows*columns; i++)arr.push_back(0);\n\t\t\tfor(int i = 0; i < rows*columns; i++){\n\t\t\t\tarr[i] = value * values[i];\n\t\t\t}\n\t\t\treturn Matrix<T>(rows, columns, arr);\n\t\t}\n\t\tMatrix  operator + (T value)  const{\n\t\t\tvector<T> arr;\n\t\t  for(int i = 0; i < rows*columns; i++)arr.push_back(0);\n\t\t\tfor(int i = 0; i < rows*columns; i++){\n\t\t\t\tarr[i] = value + values[i];\n\t\t\t}\n\t\t\treturn Matrix<T>(rows, columns, arr);\n\t\t}\n\t\tMatrix operator + (const Matrix<T> & matrix2) const{\n\t\tvector<T> arr;\n\t\t  for(int i = 0; i < rows*columns; i++)arr.push_back(0);\n\t\t  for(int i = 0; i < rows*columns; i++)arr[i] = values[i]+matrix2.values[i];\n\t\t  return Matrix<T> (rows,columns,arr);\n\t\t}\n\t\t\tMatrix  operator - (T value)  const{\n\t\t\tvector<T> arr;\n\t\t  for(int i = 0; i < rows*columns; i++)arr.push_back(0);\n\t\t\tfor(int i = 0; i < rows*columns; i++){\n\t\t\t\tarr[i] =  values[i] - value;\n\t\t\t}\n\t\t\treturn Matrix<T>(rows, columns, arr);\n\t\t}\n\t\tMatrix operator - (const Matrix<T> & matrix2) const{\n\t\tvector<T> arr;\n\t\t  for(int i = 0; i < rows*columns; i++)arr.push_back(0);\n\t\t  for(int i = 0; i < rows*columns; i++)arr[i] = values[i]-matrix2.values[i];\n\t\t  return Matrix<T> (rows,columns,arr);\n\t\t}\n\t\t\n\t\tMatrix max() const{\n\t\t\t \tif(rows>1){\n\t\t\t\t\t\tvector<T> newarr;\n\t\t  for(int i = 0; i < rows*columns; i++)newarr.push_back(0);\n\t\t\t\t\tint max,maxrows;\n\t\t\t \t\tfor(int i = 0; i < this->columns;i++){\n\t\t\t\t\t\tmax = 0;\n\t\t\t\t\t\tmaxrows = 0;\n\t\t\t\t\t\tfor(int j = 0 ;j < this->rows; j++){\n\t\t\t\t\t\t\tif(values[columns*j+i]>max){\n\t\t\t\t\t\t\t\tmax = values[columns*j+i];\n\t\t\t\t\t\t\t\tmaxrows = j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnewarr[i] = values[this->columns*maxrows + i];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn  Matrix(1,columns,newarr);\n\t\t\t\t}\n\t\t\t\tif(rows==1){\n\t\t\t\t\tint max = 0;\n\t\t\t\t\tfor(int i = 0; i < columns; i++){\n\t\t\t\t\t\tif(values[i] > max)max = values[i];\n\t\t\t\t\t}\n\t\t\t\t\tvector<T> newarr;\n\t\t\t\t\tnewarr.push_back(0);\n\t\t\t\t\tnewarr[0] = max;\n\t\t\t \t\treturn Matrix(1,1,newarr);\n\t\t\t\t}\n\t\t\t \t\n\t\t  }\n\t\t  \n\t\t  Matrix min() const{\n\t\t\t  if(rows>1){\n\t\t\t\t\t\tvector<T> newarr;\n\t\t  for(int i = 0; i < rows*columns; i++)newarr.push_back(0);\n\t\t\t\t\tint min,minrows;\n\t\t\t \t\tfor(int i = 0; i < this->columns;i++){\n\t\t\t\t\t\tmin = INF;\n\t\t\t\t\t\tminrows = 0;\n\t\t\t\t\t\tfor(int j = 0 ;j < this->rows; j++){\n\t\t\t\t\t\t\tif(values[columns*j+i]<min){\n\t\t\t\t\t\t\t\tmin = values[columns*j+i];\n\t\t\t\t\t\t\t\tminrows = j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnewarr[i] = this->values[this->columns*minrows + i];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn  Matrix(1,columns,newarr);\n\t\t\t\t}\n\t\t\t\tif(rows==1){\n\t\t\t\t\tint min = INF;\n\t\t\t\t\tfor(int i = 0; i < columns; i++){\n\t\t\t\t\t\tif(values[i] < min)min = values[i];\n\t\t\t\t\t}\n\t\t\t\tvector<T> newarr;\n\t\t\t\t\tnewarr.push_back(0);\n\t\t\t\t\tnewarr[0] = min;\n\t\t\t \t\treturn Matrix(1,1,newarr);\n\t\t\t\t}\n\t\t  }\n\t\t   Matrix sum() const {\n\t\t\t\tif(rows>1){\n\t\t\t\t\tvector<T> newarr;\n\t\t  for(int i = 0; i < rows*columns; i++)newarr.push_back(0);\n\t\t\t\t\tint sum;\n\t\t\t \t\tfor(int i = 0; i < this->columns;i++){\n\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\tfor(int j = 0 ;j < this->rows; j++){\n\t\t\t\t\t\t\t\tsum += values[columns*j+i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnewarr[i] = sum;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn  Matrix(1,columns,newarr);\n\t\t\t\t}\n\t\t\t  if(rows==1){\n\t\t\t\t\tint sum = 0;\n\t\t\t\t\tfor(int i = 0; i < columns; i++){\n\t\t\t\t\t\tsum += values[i];\n\t\t\t\t\t}\n\t\t\t\t\tvector<T> newarr;\n\t\t\t\t\tnewarr.push_back(0);\n\t\t\t\t\tnewarr[0] = sum;\n\t\t\t \t\treturn Matrix(1,1,newarr);\n\t\t\t\t}\n\t\t  }\n\t\t   Matrix concatenateRows(const Matrix & matrix2)const {\n\t\t   \tvector<T> newarr;\n\t\t  for(int i = 0; i < rows*columns*2; i++)newarr.push_back(0);\n\t\t   for(int i = 0 ; i < this->rows*this->columns; i++){\n\t\t\t\tnewarr[i] = this->values[i];\n\t\t   }\n\t\t    for(int i = 0 ; i < this->rows*this->columns; i++){\n\t\t\tnewarr[i+this->rows*this->columns] = matrix2.values[i];\n\t\t   }\n\t\t\treturn Matrix(rows*2,columns,newarr);\n\t   }\n\t   Matrix concatenateColumns(const Matrix & matrix2) const{\n\t\t   \tvector<T> newarr;\n\t\t  for(int i = 0; i < rows*columns*2; i++)newarr.push_back(0);\n\t\t   int cnt = 0;\n\t\t   int cnt1 = 0, cnt2 = 0;\n\t\t \tfor(int i = 0; i < this->rows; i++){\n\t\t\t\tfor(int j = 0; j < this->columns; j++, cnt1++,cnt++){\n\t\t\t\t\tnewarr[cnt] = this->values[cnt1];\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < this->columns; j++,cnt2++,cnt++){\n\t\t\t\t\tnewarr[cnt] = matrix2.values[cnt2];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Matrix(rows,columns*2,newarr);\n\t   }\n\t   Matrix getRow(int row){\n\t   \t\t vector<T> newarr;\n\t\t  for(int i = 0; i < columns; i++)newarr.push_back(0);\n\t\t  for(int i = 0; i < columns; i++)newarr[i] = values[(row-1)*columns+i];\n\t\t\treturn Matrix(1, this->columns, newarr);\n\t\t}\n\t\tMatrix getColumn(int column){\n\t\t\t vector<T> newarr;\n\t\t  for(int i = 0; i < rows; i++)newarr.push_back(0);\n\t\t\tfor(int i = 0; i < this->rows; i ++){\n\t\t\t\tnewarr[i] = this->values[column-1+ i*this->columns];\n\t\t\t}\n\t\t\treturn Matrix(this->rows,1, newarr);\n\t\t}\n\t\tMatrix reshape(int x,int y){\n\t\t\tvector<T> newarr;\n\t\t\tfor(int i = 0; i < rows*columns; i++)newarr.push_back(0);\n\t\t\tvector<T> temp;\n\t\t\tfor(int i = 0; i < columns; i++){\n\t\t\t\tfor(int j = 0; j < rows; j++){\n\t\t\t\t\ttemp.push_back(values[columns*j+i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint cnt = 0;\n\t\t\tfor(int i = 0; i < y; i++){\n\t\t\t\tfor(int j = 0; j < x; j++,cnt++){\n\t\t\t\t\tnewarr[y*j+i] = temp[cnt];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Matrix<T>(columns, rows, newarr);\n\t\t}\n};",
            1590158554.0361872,
            100,
            "# 答案正确"
        ],
        [
            "6.2 (C++)",
            "吴浩岚",
            "#include <iostream>\n#include <vector>\nusing namespace std;\ntemplate<typename T>\nclass Matrix{\n\tprivate:\n\t\tint rows;\n\t\tint columns;\n\t\tvector<T> values;\n\tpublic:\n\t\tMatrix(int row, int col){\n\t\t\trows = row;\n\t\t\tcolumns = col;\n\t\t\tfor (int i = 0; i<columns*rows; i++)values.push_back(0);\n\t\t}\n\t\t~Matrix(){\n\t\t\tvalues.clear();\n\t\t}\n\t\tvoid print(){\n\t\t\tfor(int i = 0; i < rows; i++){\n\t\t\t\tfor(int j =0 ;j < columns ; j++){\n\t\t\t\t\tcout<<\"    \"<<values[i*rows+j];\n\t\t\t\t}\n\t\t\t\tcout<<endl;\n\t\t\t}\n\t\t}\n};",
            1590632243.9114122,
            100,
            "# 答案正确"
        ],
        [
            "7.1 (C++)",
            "吴浩岚",
            "#include <iostream>\n#include <cmath>\nusing namespace std;\nclass Triangle : public GeometricObject{\n\tprivate:\n\t  double side1 = 1.0;\n     double side2 = 1.0;\n     double side3 = 1.0;\n\tpublic:\n\t\tTriangle(){\n\t\t\t\n\t\t}\n\t\tTriangle(double side1, double side2, double side3) {\n        this->side1 = side1;\n        this->side2 = side2;\n        this->side3 = side3;\n    }\n\t double getSide1() {\n        return side1;\n    }\n\n   double getSide2() {\n        return side2;\n    }\n\n    double getSide3() {\n        return side3;\n    }\n\n    void setSide1(double side1) {\n        this->side1 = side1;\n    }\n\n    void setSide2(double side2) {\n        this->side2 = side2;\n    }\n\n    void setSide3(double side3) {\n        this->side3 = side2;\n    }\n\n    double getArea() {\n        double s = (side1 + side2 + side3) / 2;\n\t\t\treturn sqrt(s * (s - side1) * (s - side2) * (s - side3));\n    }\n\n    double getPerimeter() {\n        return side1 + side2 + side3;\n    }\n};",
            1590720618.6411514,
            100,
            "# 答案正确"
        ],
        [
            "7.3 (C++)",
            "吴浩岚",
            "template <typename B>\nvector<B> map2(const vector<B> & x,const vector<B> & y, B (*map_func)(const B &,const B &)) {\n\tvector<B> res;\n\tfor (int i = 0; i < x.size(); ++ i)\n\t\tres.push_back(map_func(x[i],y[i]));\n\treturn res;\n}\ntemplate <typename B>\nvector<B> map2(const vector<B> & x,const B & y, B (*map_func)(const B &,const B &)) {\n\tvector<B> res;\n\tfor (int i = 0; i < x.size(); ++ i)\n\t\tres.push_back(map_func(x[i],y));\n\treturn res;\n}",
            1591063616.651629,
            100,
            "# 答案正确"
        ],
        [
            "7.2 (C++)",
            "吴浩岚",
            "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\nvector<string> split(const string & line, \n\t\t\t\t\tconst string & delimiter=\" \") {\n\tvector<string> words;\n\tint st = 0;\n\twhile (st < line.size()) {\n\t\tint end = line.find(delimiter, st);\n\t\tif (end == st) st += delimiter.size();\n\t\telse {\n\t\t\tif (end == -1) {\n\t\t\t\twords.push_back(line.substr(st));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twords.push_back(line.substr(st, end-st));\n\t\t\tst = end + delimiter.size();\n\t\t}\n\t}\n\treturn words;\n}",
            1591236349.9665747,
            100,
            "# 答案正确"
        ],
        [
            "8.1 (C++)",
            "吴浩岚",
            "class Full: public Matrix\n{\nprivate:\n\tint rows;\n\tint cols;\n\tdouble *val;\npublic :\n \tFull(int row, int column){\n \t\trows=row;\n \t\tcols=column;\n \t\tval=new double[rows*cols];\n \t\tfor(int i=0;i<rows*cols;i++){\n \t\t\tval[i]=0;\n \t\t}\n\t }\n int size(int dimension) const\n {\n\n  if(dimension == 1) return rows;\n  if(dimension == 2) return cols;\n }\n\t Full(int row, int column, double values[]){\n  \t\trows=row;\n \t\tcols=column;\n \t\tval=new double[rows*cols];\n \t\tfor(int i=0;i<rows*cols;i++){\n \t\t\tval[i]=values[i];\n \t\t}\n \t}\n\n \tdouble get(int row, int column) const {\n \t\treturn val[row*cols+column];\n \t}\n \tvoid set(int row, int column, double value){\n \t\tval[(row-1)*cols+column-1]=value;\n \t}\n \tFull(const Matrix & m2){\n\t\t rows=m2.size(1);\n\t\t cols=m2.size(2);\n\t\tval=new double[rows*cols];\n \t\tfor(int i=0;i<rows;i++){\n\t\t\tfor(int j=0;j<cols;j++){\n\t\t\t\tval[i*cols+j]=m2.get(i,j);\n\t\t\t}\n\n\t\t }}\n \t~Full(){\n \t\tdelete[]val;\n\t }\n \tvoid print()const{\n\tfor(int i=0;i<rows;i++){\n\t\tfor(int j=0;j<cols;j++){\n\t\t\tprintf(\"    %0.lf\",val[i*cols+j]);\n\t\t}\n\t\tprintf(\"\\n\");}\n\t}\n\tMatrix & operator = (const Matrix & m2) {\n\t\tdelete []val;\n\t\trows=m2.size(1);\n\t\tcols=m2.size(2);\n\t\t val=new double[rows*cols];\n \t\tfor(int i=0;i<rows;i++){\n\t\t\tfor(int j=0;j<cols;j++){\n\t\t\t\tval[i*cols+j]=m2.get(i,j);\n\t\t\t}\n\t\t }\n\t }\n};",
            1591678512.817159,
            100,
            "# 答案正确"
        ],
        [
            "8.4 (C++)",
            "吴浩岚",
            "\n#include<vector>\n#include<algorithm>\n #include <iostream> \n using namespace std; \n  \n  \nbool Comp1(const Entry &a,const Entry &b)\n{\n\treturn a.row<b.row;\n}\nbool Comp2(const Entry &a,const Entry &b)\n{\n\treturn (a.row==b.row&&a.column<b.column);\n}\nclass Sparse : public Matrix\n{\nprivate:\n\tint _rows, _columns;\n\tvector<Entry> entry;\npublic:\n\tSparse(int rows, int column)\n\t{\n\t\t_rows = rows;\n\t\t_columns = column;\n\t\tentry = vector<Entry>();\n\t}\n\tint size(int dimension) const\n\t{\n\t\tif(dimension == 1) return _rows;\n\t\tif(dimension == 2) return _columns;\n\t}\n\tvoid set(int row, int column, double value)\n\t{\n\t\tEntry e;\n\t\te.row = row;\n\t\te.column = column;\n\t\te.value = value;\n\t\tentry.push_back(e);\n\t}\n\tdouble get(int row, int column) const\n\t{\n\t\tfor(int i=0; i < entry.size();i++)\n\t\t{\n\t\t\tif(entry[i].row == row\n\t\t\t\t && entry[i].column == column ){\n\t\t\t\treturn entry[i].value;\t\n\t\t\t}\n\t\t}\n\t}\n\tvoid print()\n\t{\n\t\tfor(int i=0; i < entry.size();i++)\n\t\t{\n\t\t\tcout<<\"(\"<<entry[i].row<<\",\"<<entry[i].column<<\",\"\n\t\t\t\t<<entry[i].value<<\")\\n\";\n\t\t}\n\t}\n\tSparse operator * (Sparse & sparse2)\n\t{\n\t\tSparse s(_rows, sparse2._columns);\n\n\t\tfor(int i=0; i < this->entry.size(); i++)\n\t\t{\n\t\t\tfor(int j = 0 ;j< sparse2.entry.size(); j++)\n\t\t\t{\n\t\t\t\tif(this->entry[i].column == sparse2.entry[j].row ){\n\t\t\t\t   \n\t\t\t\t   Entry e;\n\t\t\t\t\te.row =this->entry[i].row;\n\t\t\t\t\te.column =  sparse2.entry[j].column;\n\t\t\t\t\te.value = this->entry[i].value * sparse2.entry[j].value;\n\t\t\t\t\tint isIns = 0;\n\t\t\t\t\tint index = -1;\n\t\t\t\t\tfor(int k = 0 ; k < s.entry.size();k++){\n\t\t\t\t\t\tif(s.entry[k].row == e.row && s.entry[k].column == e.column){\n\t\t\t\t\t\t\tisIns = 1;\n\t\t\t\t\t\t\tindex = k;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(e.value && isIns == 0)\n\t\t\t\t\ts.entry.push_back(e);\n\t\t\t\t\tif(e.value && isIns == 1){\n\t\t\t\t\t\ts.entry[index].value += e.value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tsort(s.entry.begin(),s.entry.end(),Comp1);\n\t\tsort(s.entry.begin(),s.entry.end(),Comp2);\n\t\t\n\t\treturn s;\n\t}\n};\n",
            1591673967.4293835,
            100,
            "# 答案正确"
        ],
        [
            "8.3 (C++)",
            "吴浩岚",
            "\n#include<vector>\n#include<algorithm>\n #include <iostream> \n using namespace std; \n  \n  \nbool Comp1(const Entry &a,const Entry &b)\n{\n\treturn a.row<b.row;\n}\nbool Comp2(const Entry &a,const Entry &b)\n{\n\treturn (a.row==b.row&&a.column<b.column);\n}\nclass Sparse : public Matrix\n{\nprivate:\n\tint _rows, _columns;\n\tvector<Entry> entry;\npublic:\n\tSparse(int rows, int column)\n\t{\n\t\t_rows = rows;\n\t\t_columns = column;\n\t\tentry = vector<Entry>();\n\t}\n\tint size(int dimension) const\n\t{\n\t\tif(dimension == 1) return _rows;\n\t\tif(dimension == 2) return _columns;\n\t}\n\tvoid set(int row, int column, double value)\n\t{\n\t\tEntry e;\n\t\te.row = row;\n\t\te.column = column;\n\t\te.value = value;\n\t\tentry.push_back(e);\n\t}\n\tdouble get(int row, int column) const\n\t{\n\t\tfor(int i=0; i < entry.size();i++)\n\t\t{\n\t\t\tif(entry[i].row == row\n\t\t\t\t && entry[i].column == column ){\n\t\t\t\treturn entry[i].value;\t\n\t\t\t}\n\t\t}\n\t}\n\tvoid print()\n\t{\n\t\tfor(int i=0; i < entry.size();i++)\n\t\t{\n\t\t\tcout<<\"(\"<<entry[i].row<<\",\"<<entry[i].column<<\",\"\n\t\t\t\t<<entry[i].value<<\")\\n\";\n\t\t}\n\t}\n\tSparse operator + (Sparse & sparse2)\n\t{\n\t\tSparse s(_rows, _columns);\n\n\t\tfor(int i=0; i < this->entry.size(); i++)\n\t\t{\n\t\t\tfor(int j = 0 ;j< sparse2.entry.size(); j++)\n\t\t\t{\n\t\t\t\tif(this->entry[i].row == sparse2.entry[j].row \n\t\t\t\t\t&& this->entry[i].column == sparse2.entry[j].column){\n\t\t\t\t\tEntry e;\n\t\t\t\t\te.row = sparse2.entry[j].row;\n\t\t\t\t\te.column =  sparse2.entry[j].column;\n\t\t\t\t\te.value = this->entry[i].value + sparse2.entry[j].value;\n\t\t\t\t\t\n\t\t\t\t\tif(e.value)\n\t\t\t\t\ts.entry.push_back(e);\n\t\t\t\t\t\n\t\t\t\t\tthis->entry[i].value = 0;\n\t\t\t\t\tsparse2.entry[j].value = 0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i < this->entry.size(); i++)\n\t\t{\n\t\t\tEntry e;\n\t\t\te.row = this->entry[i].row;\n\t\t\te.column = this->entry[i].column;\n\t\t\te.value = this->entry[i].value;\n\t\t\tif(e.value)\n\t\t\t\ts.entry.push_back(e);\n\t\t}\n\t\tfor(int i=0; i < sparse2.entry.size(); i++)\n\t\t{\n\t\t\tEntry e;\n\t\t\te.row = sparse2.entry[i].row;\n\t\t\te.column = sparse2.entry[i].column;\n\t\t\te.value = sparse2.entry[i].value;\n\t\t\tif(e.value)\n\t\t\t\ts.entry.push_back(e);\n\t\t}\n\t\tsort(s.entry.begin(),s.entry.end(),Comp1);\n\t\tsort(s.entry.begin(),s.entry.end(),Comp2);\n\t\t\n\t\treturn s;\n\t}\n};\n",
            1591667328.4771056,
            100,
            "# 答案正确"
        ],
        [
            "8.5 (C++)",
            "吴浩岚",
            "class Point3D : public Point2D{\n\tprivate:\n\t\tdouble z;\n\tpublic:\n\t\tPoint3D(double x1, double y1, double z1){\n\t\t\tthis->setX(x1);\n\t\t\tthis->setY(y1);\n\t\t\tz = z1;\t\t\n\t\t}\n\tdouble getZ(){\n\t\treturn z;\n\t}\n\tvirtual double distance(Point2D & point2){\n\t\tPoint3D *newpoint2 = dynamic_cast<Point3D *>(&point2);\n\t\tdouble dx = getX() - newpoint2->getX();\n\t\tdouble dy = getY() - newpoint2->getY();\n\t\tdouble dz = getZ() - newpoint2->getZ();\n\t\treturn sqrt(dx * dx + dy * dy+dz * dz);\n\t}\n};",
            1591843238.4461896,
            100,
            "# 答案正确"
        ],
        [
            "8.6 (C++)",
            "吴浩岚",
            "#include <vector>\n#include <iostream>\nusing namespace std;\nclass MyTensor : public Tensor<double>{\n\tprivate:\n\t\tvector<double> mytensor;\n\tpublic:\n\tMyTensor(vector<int> sizes):Tensor(vector<int> sizes)  {\n\t\tint max = 1;\n\t\tfor(int i = 0; i < sizes.size();i++){\n\t\t\tmax *= sizes[i];\n\t\t}\n\t\tfor(int i = 0; i < max ; i++){\n\t\t\tmytensor.push_back(0);\n\t\t}\n\t}\n\t double & get(const vector<int> & indexes){\n\t\t if(indexes.size() == 1)\n\t\t return mytensor[indexes[0]];\n\t\t if(indexes.size() == 2)\n\t\t return mytensor[indexes[0]];\n\t\t if(indexes.size() == 3)\n\t\t return mytensor[indexes[0]];\n\t\t if(indexes.size() == 4)\n\t\t return mytensor[indexes[0]];\n\t }\n};",
            1592451568.4593801,
            0,
            "In file included from main.cpp:14:0:\nsource.cpp: In constructor ‘MyTensor::MyTensor(std::vector<int>)’:\nsource.cpp:8:49: error: expected primary-expression before ‘sizes’\n  MyTensor(vector<int> sizes):Tensor(vector<int> sizes)  {\n                                                 ^\n"
        ],
        [
            "9.1 (C++)",
            "吴浩岚",
            "class Circle{\n\tpublic:\n\t\tint radius;\n\t\tCircle(int r){\n\t\t\tradius = r;\n\t\t}\n\t\t~Circle(){\n\t\t\tradius = 0;\n\t\t}\n};\n\nbool operator < (Circle a,Circle b){\n\treturn (a.radius < b.radius);\n}\nbool operator <= (Circle a,Circle b){\n\treturn (a.radius <= b.radius);\n}\nbool operator != (Circle a,Circle b){\n\treturn (a.radius != b.radius);\n}\nbool operator == (Circle a,Circle b){\n\treturn (a.radius == b.radius);\n}\nbool operator > (Circle a,Circle b){\n\treturn (a.radius > b.radius);\n}\nbool operator >= (Circle a,Circle b){\n\treturn (a.radius >= b.radius);\n}\n",
            1593047550.2741249,
            100,
            "# 答案正确"
        ],
        [
            "9.2 (C++)",
            "吴浩岚",
            "class I{\n\tpublic:\n\tvector<int> indexes;\n\tI(int i1, int i2=-1, int i3=-1, int i4=-1){\n\t\tindexes.push_back(i1);\n\t\tif (i2 != -1) indexes.push_back(i2);\n\t\tif (i3 != -1) indexes.push_back(i3);\n\t\tif (i4 != -1) indexes.push_back(i4);\n\t}\n\t~I(){\n\t\tindexes.clear();\n\t}\n\toperator vector<int>() const{\n\t\treturn indexes;\n\t}\n};\n",
            1593062611.4993007,
            100,
            "# 答案正确"
        ],
        [
            "9.3 (C++)",
            "吴浩岚",
            "#include <iostream>\n#include <cmath>\nusing namespace std;\n\n\nclass Complex\n{\npublic:\n\tComplex(double r,double i);\n\tComplex operator+(const Complex &c);\n\tComplex operator-(const Complex &c);\n\tComplex operator+(const double &c);\n\tfriend Complex operator+(const double &c, Complex &b);\n\tComplex operator-(const double &c);\n\tComplex operator*(const Complex &c);\n\tComplex operator/(const Complex &c);\n\tComplex operator+=(const Complex &c);\n\tComplex operator-=(const Complex &c);\n\tbool operator==(const Complex &c);\n \tbool operator!=(const Complex &c);\n \tComplex operator*=(const Complex &c);\n\tComplex operator/=(const Complex &c);\n\tComplex(int r): _real(r),_image(0){}\n\tvoid print(Complex &c);\n\tdouble real(){\n\t\treturn _real;\n\t}\n\tdouble imag(){\n\t\treturn _image;\n\t}\nprivate:\n\tdouble _real;\n\tdouble _image;\n};\n \nComplex::Complex(double r = 0.0, double i = 0.0)\n{\n\t_real = r;\n\t_image = i;\n}\n\nComplex Complex:: operator + (const Complex &c)\n{\n\tComplex tmp;\n\ttmp._real = _real + c._real;\n\ttmp._image = _image + c._image;\n\treturn tmp;\n}\n\nComplex Complex::operator - (const Complex &c)\n{\n\tComplex tmp;\n\ttmp._image = _image - c._image;\n\ttmp._real = _real - c._real;\n\treturn tmp;\n}\nComplex Complex:: operator + ( const double &c)\n{\n\tComplex tmp;\n\ttmp._real = _real + c;\n\ttmp._image = _image;\n\treturn tmp;\n}\nComplex operator + ( const double &c , Complex &b)\n{\n\treturn b+c;\n}\n\nComplex Complex::operator - (const double &c)\n{\n\tComplex tmp;\n\ttmp._image = _image;\n\ttmp._real = _real - c;\n\treturn tmp;\n} \n\n//a+bi * c+di = ac-bd + bci+ adi \nComplex Complex::operator*(const Complex &c)\n{\n\tComplex tmp;\n\ttmp._real = _real*c._real - _image*c._image;\n\ttmp._image = _image*c._real + _real*c._image;\n\treturn tmp;\n}\n \n// a+bi / c+di = \nComplex Complex :: operator/(const Complex &c)\n{\n\tComplex tmp;\n\tdouble deno = c._real*c._real + c._image*c._image;  \n\ttmp._real = ((_real*c._real) + (_image*c._image))/deno;\n\ttmp._image = ((_image*c._real) - (_real*c._image))/deno;\n\treturn tmp;\n}\n \nComplex Complex::operator+=(const Complex &c)\n{\n\t\n\t_real += c._real;\n\t_image += c._image;\n\treturn *this;\n}\n \nComplex Complex::operator-=(const Complex &c)\n{\n\t_real -= c._real;\n\t_image -= c._image;\n\treturn *this;\n}\n Complex Complex::operator *= (const Complex &c)\n{\n\t\n\tdouble a = _real*c._real - _image*c._image;\n\tdouble b = _image*c._real + _real*c._image;\n\t _real = a;\n\t _image = b;\n\treturn *this;\n}\n Complex Complex::operator /= (const Complex &c)\n{\n\t\n\tdouble deno = c._real*c._real + c._image*c._image;  \n   double a = ((_real*c._real) + (_image*c._image))/deno;\n   double b = ((_image*c._real) - (_real*c._image))/deno;\n\t _real = a;\n\t _image = b;\n\treturn *this;\n}\nbool Complex::operator==(const Complex &c)\n{\n\treturn(_real == c._real) && (_image == c._image);\n}\nbool Complex::operator!=(const Complex &c)\n{\n\treturn(_real != c._real) || (_image != c._image);\n}\n ",
            1593073380.4301248,
            100,
            "# 答案正确"
        ],
        [
            "9.4 (C++)",
            "吴浩岚",
            "#include <iostream>\n#include <cmath>\nusing namespace std;\n\n\nclass Complex\n{\npublic:\n\tComplex(double r,double i);\n\tComplex operator+(const Complex &c);\n\tComplex operator-(const Complex &c);\n\tdouble real(){\n\t\treturn _real;\n\t}\n\tdouble imag(){\n\t\treturn _image;\n\t}\n\tfriend istream &operator>>( istream  &input, Complex &c)\n      { \n         input >> c._real >> c._image;\n         return input;            \n      }\n\t friend ostream &operator<<( ostream &output, const Complex &c )\n      { \n         output << c._real << \" + \" << c._image<<\" i\";\n         return output;            \n      }\nprivate:\n\tdouble _real;\n\tdouble _image;\n};\n \nComplex::Complex(double r = 0.0, double i = 0.0)\n{\n\t_real = r;\n\t_image = i;\n}\n\nComplex Complex:: operator + (const Complex &c)\n{\n\tComplex tmp;\n\ttmp._real = _real + c._real;\n\ttmp._image = _image + c._image;\n\treturn tmp;\n}\n\nComplex Complex::operator - (const Complex &c)\n{\n\tComplex tmp;\n\ttmp._image = _image - c._image;\n\ttmp._real = _real - c._real;\n\treturn tmp;\n}\n\n\n ",
            1593074118.8982913,
            100,
            "# 答案正确"
        ],
        [
            "9.5 (C++)",
            "吴浩岚",
            "#include <iostream>\n#include <cmath>\nusing namespace std;\n\n\nclass Complex\n{\npublic:\n\tComplex(double r,double i);\n\tComplex operator+(const Complex &c);\n\tComplex operator-(const Complex &c);\n\t\tComplex operator++();\n\tComplex operator++(int);\n\toperator double ()const{\n\t\treturn _real;\n\t};\n\tdouble real(){\n\t\treturn _real;\n\t}\n\tdouble imag(){\n\t\treturn _image;\n\t}\n\tfriend istream &operator>>( istream  &input, Complex &c)\n      { \n         input >> c._real >> c._image;\n         return input;            \n      }\n\t friend ostream &operator<<( ostream &output, const Complex &c )\n      { \n         output << c._real << \" + \" << c._image<<\" i\";\n         return output;            \n      }\nprivate:\n\tdouble _real;\n\tdouble _image;\n};\n \nComplex::Complex(double r = 0.0, double i = 0.0)\n{\n\t_real = r;\n\t_image = i;\n}\n\nComplex Complex:: operator + (const Complex &c)\n{\n\tComplex tmp;\n\ttmp._real = _real + c._real;\n\ttmp._image = _image + c._image;\n\treturn tmp;\n}\n\nComplex Complex::operator - (const Complex &c)\n{\n\tComplex tmp;\n\ttmp._image = _image - c._image;\n\ttmp._real = _real - c._real;\n\treturn tmp;\n}\nComplex Complex:: operator ++ ()\n{\n\n\treturn Complex(++_real,_image);\n}\nComplex Complex:: operator ++ (int)\n{\n\t\n\treturn Complex(_real++,_image);\n}\n",
            1593075061.9861388,
            100,
            "# 答案正确"
        ],
        [
            "9.6 (C++)",
            "吴浩岚",
            "class Tensor{\n\tvector<double> values;\n\tint _a,_b,_c,_d;\n\tpublic:\n\t\n\tTensor(int a,int b=1,int c=1,int d=1){\n\t\t_a = a;\n\t\t_b = b;\n\t\t_c = c;\n\t\t_d = d;\n\t\tfor(int i = 0; i < a*b*c*d; i++){\n\t\t\tvalues.push_back(0);\n\t\t}\n\t}\n\t~Tensor(){\n\t\tvalues.clear();\n\t}\n\tdouble & operator ()(int a,int b=0,int c=0,int d=0){\n\t\treturn values[d*_c*_b*_a+c*_b*_a+b*_a+a];\n\t}\n\tconst double & operator ()(int a,int b=0,int c=0,int d=0)const{\n\t\treturn values[d*_c*_b*_a+c*_b*_a+b*_a+a];\n\t}\n\t\n};",
            1593076734.255817,
            100,
            "# 答案正确"
        ],
        [
            "9.7 (C++)",
            "吴浩岚",
            "\n#include <vector>\n#include <iostream>\n#include <fstream>\nusing namespace std;\n\nclass Tensor{\n\tvector<double> values;\n\tint _dimension;\n\tpublic:\n\t\tint _a;\n\t\tint _b;\n\t\tint _c;\n\t\tint _d;\n\tTensor(){\n\t\t_a = 1;\n\t\t_b = 1;\n\t\t_c = 1;\n\t\t_d = 1;\n\t}\n\n\t~Tensor(){\n\t\tvalues.clear();\n\t}\n\t\n\tfriend istream &operator>>( istream  &input, Tensor &t)\n      { \n         input >>t._dimension;\n\t\t\tif(t._dimension == 1)input>>t._a;\n\t\t\tif(t._dimension == 2)input>>t._b>>t._a;\n\t\t\tif(t._dimension == 3)input>>t._c>>t._b>>t._a;\n\t\t\tif(t._dimension == 4)input>>t._d>>t._c>>t._b>>t._a;\n\t\t\tfor(int i =0 ;i < t._a*t._b*t._c*t._d;i++){\n\t\t\t\tt.values.push_back(0);\n\t\t\t}\n\t\t\tfor(int i =0 ;i < t._a*t._b*t._c*t._d;i++){\n\t\t\t\tinput>>t.values[i];\n\t\t\t}\n         return input;            \n      }\n\t friend ostream &operator<<( ostream &output, const Tensor& t )\n      { \n\t\t  \n         output << t._dimension<<endl;\n         if(t._dimension == 1)output<<t._a<<endl<<endl;\n\t\t\tif(t._dimension == 2)output<<t._b<<\" \"<<t._a<<endl<<endl;\n\t\t\tif(t._dimension == 3)output<<t._c<<\" \"<<t._b<<\" \"<<t._a<<endl<<endl;\n\t\t\tif(t._dimension == 4)output<<t._d<<\" \"<<t._c<<\" \"<<t._b<<\" \"<<t._a<<endl<<endl;\n\t\t\tint cnt=0;\n\t\t \tfor(int i = 0; i < t._d; i++){\n\t\t\t\tfor(int j = 0; j < t._c;j++){\n\t\t\t\t\tfor(int k = 0; k < t._b; k++){\n\t\t\t\t\t\tfor(int l = 0; l < t._a;l++){\n\t\t\t\t\t\t\toutput<< t.values[cnt] <<\" \";\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\toutput<< endl;\n\t\t\t\t\t}\n\t\t\t\t\toutput<<endl;\n\t\t\t\t}\n\t\t\t}\n         return output;            \n      }\n};",
            1593087418.8086343,
            100,
            "# 答案正确"
        ],
        [
            "10.1 (C++)",
            "吴浩岚",
            "#include <stdexcept>\nclass MatrixSizesDoNotMatchException{};\ndouble Matrix::get(int row, int column) const{\n\t\treturn this->elements[columns*(row-1) + column-1];\n}\n\t\nvoid Matrix::set(int row, int column, double value){\n\t\tthis->elements[columns*(row-1) + column-1] = value;\n\t}\n\t\nMatrix Matrix::operator + (const Matrix & matrix2) const{\n\tif(matrix2.rows != rows || matrix2.columns != columns){\n\t\tMatrixSizesDoNotMatchException error;\n\t\tthrow error;\n\t}\n\t\tMatrix newmatrix(rows,columns);\n\t\tfor(int i = 0; i < rows*columns; i++){\n\t\t\tnewmatrix.elements[i] = this->elements[i] + matrix2.elements[i];\n\t\t}\n\t\treturn newmatrix;\n\t}\n\n",
            1593613701.9709756,
            100,
            "# 答案正确"
        ],
        [
            "10.2 (C++)",
            "吴浩岚",
            "#include <stdexcept>\ncatch(NonPositiveValueException ex){\n\tprintf(\"caught: NonPositiveValueException\\n\");\n}",
            1593656135.2941382,
            100,
            "# 答案正确"
        ],
        [
            "15.1 (C++)",
            "吴浩岚",
            "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\nclass Table{\n\t\n\tpublic:\n\t\tvector<string> headers;\n\tvector<vector<string> > rows;\n\t\tTable(){}\n\tvoid addCol(string str){\n\t\theaders.push_back(str);\n\t}\n    string json() const{\n\t\tstring newstring;\n\t\tnewstring = \"{\\n\\theaders: [\";\n\t\t for(int i = 0; i < headers.size(); i ++){\n\t\t \tnewstring = newstring+\"'\"+headers[i]+\"'\"+\",\";\n\t\t }\n\t\t newstring += \"],\\n\\trows: [\\n\";\n\t\t for(int i= 0; i < rows.size(); i++){\n\t\t \tnewstring =newstring+\"\\t\\t[\";\n\t\t \tfor(int j = 0; j < rows[i].size(); j++){\n\t\t \t\tnewstring =newstring+\"'\"+ rows[i][j]+\"',\";\n\t\t\t }\n\t\t\t newstring =newstring+\"],\\n\";\n\t\t }\n\t\t newstring += \"\\t],\\n}\";\n\t\treturn  newstring;\n\t} \n\tvector<string> & operator [] (int i){\n\t\tif(i < rows.size() )return rows[i];\n\t\tif(i >= rows.size()){\n\t\t\trows.resize(rows.size()+1);\n\t\t\treturn rows[i];\n\t\t}\n\t}\n\tconst vector<string> & operator [] (int i)const{\n\t\treturn rows[i];\n\t}\n\t\n\t\n};",
            1593787040.457123,
            100,
            "# 答案正确"
        ],
        [
            "2020-07-09 LAB",
            "吴浩岚",
            "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\nint val = 0;\nclass Integer{\n\tpublic:\n\t\tint num;\n\t\tInteger(){\n\t\t\tnum = 0;\n\t\t}\n\t\tInteger(int a){\n\t\t\tnum = a;\n\t\t}\n\t\tint operator = (const int a){\n\t\t\tnum = a;\n\t\t}\n\t\tfriend istream &operator>>( istream  &input, Integer &c)\n      { \n         input >> c.num;\n         return input;            \n      }\n\t friend ostream &operator<<( ostream &output, Integer &c )\n      { \n\t\t \t c.num += val;\n         output << c.num;\n\t\t \t \n         return output;            \n      }\n\tstatic void increase_all(Integer a){\n      val = a.num;\n\t  }\n}; \n",
            1594265891.2411416,
            100,
            "# 答案正确"
        ],
        [
            "A.1 (C++)",
            "吴浩岚",
            "\nprivate:\n\tNode<E> * get_node(int index) const {\n\t\tif (index < 0 || index >= _size) \n\t\t\tthrow NotSuchElementException();\n\t\tif (index < _size / 2) {\n\t\t\tNode<E> * prevNode = NULL;\n\t\t\tNode<E> * node = head;\n\t\t\tNode<E> * tempNode ;\n\t\t\tI(i, index+1) {\n\t\t\t\ttempNode = node;\n\t\t\t\tnode = node->next_node(prevNode);\n\t\t\t\tprevNode = tempNode;\n\t\t\t}\n\t\t\treturn node;\n\t\t}\n\t\telse {\n\t\t\tNode<E> * nextNode = NULL;\n\t\t\tNode<E> * node = tail;\n\t\t\tNode<E> * tempNode ;\n\t\t\tI(i, (_size-index)) {\n\t\t\t\ttempNode = node;\n\t\t\t\tnode = node->prev_node(nextNode);\n\t\t\t\tnextNode = tempNode;\n\t\t\t}\n\t\t\treturn node;\n\t\t}\n\t}\n\npublic:\n\tE & get(int index) const {\n\t\tNode<E> * node = get_node(index);\n\t\treturn node->element;\n\t}\n\tvoid set(int index, const E & e) {\n\t\tNode<E> * node = get_node(index);\n\t\tnode->element = e;\n\t}\n\n\tE & getFirst() const {\n\t\treturn get(0);\n\t}\n\n\tE & getLast() const {\n\t\treturn get(_size - 1);\n\t}\n\n\tvoid remove (int index) {\n\t\tif(index == 0 && _size == 1){\n\t\t\tNode<E> * prevNode = NULL;\n\t\t\tNode<E> * node = head->next_node(prevNode);\n\t\t\thead->update_next_node(node,tail);\n\t\t\ttail->update_prev_node(node,head);\n\t\t\tdelete node;\n\t\t\t-- _size;\n\t\t\treturn;\n\t\t}else if(index == 0 && _size>1){\n\t\t\tNode<E> * prevNode = NULL;\n\t\t\tNode<E> * node = head->next_node(prevNode);\n\t\t\tNode<E> * node1 = get_node(1);\n\t\t\thead->update_next_node(node,node1);\n\t\t\tnode1->update_prev_node(node,head);\n\t\t\tdelete node;\n\t\t\t-- _size;\n\t\t\treturn;\n\t\t}else if(index == _size-1 && _size>1){\n\t\t\tNode<E> * nextNode = NULL;\n\t\t\tNode<E> * node = tail->prev_node(nextNode);\n\t\t\tNode<E> * node1 = get_node(_size-1);\n\t\t\ttail->update_prev_node(node,node1);\n\t\t\tnode1->update_next_node(node,tail);\n\t\t\tdelete node;\n\t\t\t-- _size;\n\t\t\treturn;\n\t\t}else{\n\t\t\tNode<E> * node = get_node(index);\n\t\t\tNode<E> * prevNode = get_node(index-1);\n\t\t\tNode<E> * nextNode = get_node(index+1);\n\t\t\tprevNode->update_next_node(node,nextNode);\n\t\t\tnextNode->update_prev_node(node,prevNode);\n\t\t\tdelete node;\n\t\t\t--_size;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tvoid removeFirst () {\n\t\tremove(0);\n\t}\n\n\tvoid removeLast () {\n\t\tremove(_size-1);\n\t}\n\n\tvoid add(int index, const E & e) {\n\t\t\tif (index < 0 || index > _size) \n\t\t\tthrow NotSuchElementException();\n\t\tif(index == 0 && _size ==0){\n\t\t\tNode<E> * node = new Node<E>();\n\t\t\tnode->element = e;\n\t\t\thead->update_next_node(tail,node);\n\t\t\ttail->update_prev_node(head,node);\n\t\t\tnode->update_prev_and_next_node(head,tail);\n\t\t\t++ _size;\n\t\t}else if(index == 0 && _size >0){\n\t\t\tNode<E> * node = new Node<E>();\n\t\t\tnode->element = e;\n\t\t\tNode<E> * nextNode = get_node(index);\n\t\t\thead->update_next_node(nextNode,node);\n\t\t\tnextNode->update_prev_node(head,node);\n\t\t\tnode->update_prev_and_next_node(head,nextNode);\t\t\t\n\t\t\t++ _size;\n\t\t}else if(index == _size && _size >0){\n\t\t\tNode<E> * node = new Node<E>();\n\t\t\tnode->element = e;\n\t\t\tNode<E> * prevNode = get_node(index-1);\n\t\t\tprevNode->update_next_node(tail,node);\n\t\t\ttail->update_prev_node(prevNode,node);\n\t\t\tnode->update_prev_and_next_node(prevNode,tail);\t\t\t\n\t\t\t++ _size;\n\t\t}\n\t\telse{\n\t\t\tNode<E> * node = new Node<E>();\n\t\t\tnode->element = e;\n\t\t\tNode<E> * nextNode = get_node(index);\n\t\t\tNode<E> * prevNode = get_node(index-1);\n\t\t\tprevNode->update_next_node(nextNode,node);\n\t\t\tnextNode->update_prev_node(prevNode,node);\n\t\t\tnode->update_prev_and_next_node(prevNode,nextNode);\n\t\t\t++ _size;\n\t\t}\n\t}\n\n\tvoid addFirst (const E & e) {\n\t\tadd(0, e);\n\t}\n\n\tvoid addLast (const E & e) {\n\t\tadd(_size, e);\n\t}\n\n\t// copy and clear\n\n\tvoid clear() {\n\t\twhile (_size > 0) removeFirst();\n\t}\n\n\tvoid addAll(const LinkedList & list, int index=-1) {\n\t\tif (index == -1) index = _size;\n\t\tI(i, list._size) {\n\t\t\tNode<E> * node = list.get_node(i);\n\t\t\tadd(index + i, node->element);\n\t\t}\n\t}\n\n\tLinkedList(const LinkedList & list) : _size(0), head(0), tail(0) {\n\t\taddAll(list);\n\t}\n\n\tLinkedList & operator = (const LinkedList & list) {\n\t\tclear();\n\t\taddAll(list);\n\t\treturn *this;\n\t}\n\n\t~LinkedList() {\n\t\tclear();\n\t}\n\n\tint indexOf(const E & e) const {\n\t\tNode<E> * prevNode = NULL;\n\t\tNode<E> * node = head->next_node(prevNode);\n\t\tNode<E> * tempNode;\n\t   prevNode = head;\n\t\tif(node->element == e)return 0;\n\t\tI(i, _size-1) {\n\t\t\tif (node->element == e) return i;\n\t\t\ttempNode = node;\n\t\t\tnode = node->next_node(prevNode);\n\t\t\tprevNode = tempNode;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tint lastIndexOf(const E & e) const {\n\t\tNode<E> * nextNode = NULL;\n\t\tNode<E> * node = tail->prev_node(nextNode);\n\t\tnextNode = tail;\n\t\tNode<E> * tempNode;\n\t\tif(node->element == e)return 0;\n\t\tI(i, _size-1) {\n\t\t\tif (node->element == e) return i;\n\t\t\ttempNode = node;\n\t\t\tnode = node->prev_node(nextNode);\n\t\t\tnextNode = tempNode;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tbool contains(const E & e) const {\n\t\treturn indexOf(e) >= 0;\n\t}\n\n\tvoid removeFirstOccurrence(const E & e) {\n\t\tint index = indexOf(e);\n\t\tif (index == -1)\n\t\t\tthrow NotSuchElementException();\n\t\tremove(index);\n\t}\n\n\tvoid removeLastOccurrence(const E & e) {\n\t\tint index = lastIndexOf(e);\n\t\tif (index == -1)\n\t\t\tthrow NotSuchElementException();\n\t\tremove(index);\n\t}\n",
            1594537516.8958468,
            0,
            "ASAN:SIGSEGV\n=================================================================\n==24536==ERROR: AddressSanitizer: SEGV on unknown address 0x000000000000 (pc 0x561452d2b580 bp 0x7ffcf0ce2680 sp 0x7ffcf0ce24c0 T0)\n    #0 0x561452d2b57f in Node<double>::update_prev_and_next_node(Node<double>*, Node<double>*) /home/吴浩岚/main.cpp:18\n    #1 0x561452d2b57f in Node<double>::update_next_node(Node<double>*, Node<double>*) /home/吴浩岚/main.cpp:26\n    #2 0x561452d2b57f in LinkedList<double>::add(int, double const&) /home/吴浩岚/source.cpp:101\n    #3 0x561452d2b57f in LinkedList<double>::addFirst(double const&) /home/吴浩岚/source.cpp:135\n    #4 0x561452d2b57f in main /home/吴浩岚/main.cpp:56\n    #5 0x7f4bff21f82f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2082f)\n    #6 0x561452d2b248 in _start (/home/吴浩岚/main.out+0x1248)\n\nAddressSanitizer can not provide additional info.\nSUMMARY: AddressSanitizer: SEGV /home/吴浩岚/main.cpp:18 Node<double>::update_prev_and_next_node(Node<double>*, Node<double>*)\n==24536==ABORTING\n"
        ],
        [
            "A.2 (C++)",
            "吴浩岚",
            "template <typename E>\nvoid LinkedList<E>::removeAll(const E & e){\n\twhile(LinkedList<E>::indexOf(e) != -1){\n\t\tLinkedList<E>::removeFirstOccurrence(e);\n\t}\n}",
            1594865762.370053,
            100,
            "# 答案正确"
        ],
        [
            "A.3 (C++)",
            "吴浩岚",
            "#include <vector>\n#include <iostream>\n#include <string>\n#define I(i,n) for (size_t i = 0; i < n; ++ i)\nusing namespace std;\nclass NoSuchKeyException {};\nsize_t circular_shift(size_t bits, int shift_bits) {\n\tconst int num_bits = 8 * sizeof(size_t);\n\tshift_bits = shift_bits % num_bits;\n\treturn bits << shift_bits | bits >> (num_bits - shift_bits);\n}\n\n\nsize_t hash_function(const int & key) {\n\tsize_t code = 0;\n\t\n\tI(i, key)\n\t\tcode ^= circular_shift(key, i * 5);\n\treturn code;\n}\n\n\ntemplate <typename E> \nclass HT{\n\tclass Tuple\n\t{\n\tpublic:\n\t\tint key;\n\t\tE val;\n\t\tbool in_use;\n\n\t\tTuple() : in_use(false) {}\n\t};\n\tvector<Tuple> tuples;\n\tsize_t _size;\n\tsize_t canonical_index(const int & key) const {\n\t\tsize_t hash_code = hash_function(key); // needs hash_function(K)\n\t\treturn hash_code % tuples.size();\n\t}\n\tsize_t indexOfKey(const int & key) const {\n\t\tsize_t index = canonical_index(key);\n\t\twhile (true) { // will enter a dead loop if there is not empty tuple\n\t\t\tif (! tuples[index].in_use) return index;\n\t\t\tif (tuples[index].key == key) return index;\n\t\t\tindex = (index + 1) % tuples.size();\n\t\t}\n\t}\n\tpublic:\n\tHT() : _size(0) {\n\t\ttuples.resize(2);\n\t}\n\tbool containsKey(const int & key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\treturn tuples[index].in_use;\n\t}\n\n\tconst E & operator [] (const int & key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples[index].val;\n\t}\n\n\tE & operator [] (const int & key) {\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples[index].val;\n\t}\n\tvoid put(const int & key, const E & val) {\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].key = key;\n\t\ttuples[index].val = val;\n\t\tif (tuples[index].in_use) return;\n\t\ttuples[index].in_use = true;\n\t\t++ _size;\n\t\t// make sure empty > size / 2\n\t\tif (2 * _size > tuples.size())\n\t\t\t_double_tuples();\n\t}\n\t\tvoid _double_tuples() {\n\t\tvector<Tuple> non_empty_tuples;\n\t\tI(i, tuples.size())\n\t\t\tif (tuples[i].in_use)\n\t\t\t\tnon_empty_tuples.push_back(tuples[i]);\n\t\tclear();\n\t\ttuples.resize(tuples.size() * 2);\n\t\tI(i, non_empty_tuples.size())\n\t\t\tput(non_empty_tuples[i].key, non_empty_tuples[i].val);\n\t}\n\tstatic bool _between(size_t hole, size_t canonical, size_t tuple_index) {\n\t\tif (hole < tuple_index)\n\t\t\treturn canonical > hole && canonical <= tuple_index;\n\t\telse\n\t\t\treturn canonical > hole || canonical <= tuple_index;\n\t}\n\n\tvoid remove(const int & key) { \n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\ttuples[index].in_use = false;\n\t\t-- _size;\n\t\t// if there is a hole between a tuple and its canonical position\n\t\t// move the tuple to the hole\n\t\tsize_t hole = index;\n\t\tsize_t tuple_index = hole;\n\t\twhile (true) {\n\t\t\ttuple_index = (tuple_index + 1) % tuples.size();\n\t\t\tif (! tuples[tuple_index].in_use) return;\n\t\t\tsize_t canonical = canonical_index(tuples[tuple_index].key);\n\t\t\tif (_between(hole, canonical, tuple_index)) continue;\n\t\t\ttuples[hole] = tuples[tuple_index];\n\t\t\thole = tuple_index;\n\t\t\ttuples[hole].in_use = false;\n\t\t}\n\t}\n\n\tsize_t size() const { return _size; }\n    void clear() {\n\t\tI(i, tuples.size())\n\t\t\ttuples[i].in_use = false;\n\t\t_size = 0;\n\t}\n\ttemplate <typename K2>\n\tfriend ostream & operator << (ostream & out, const HT<K2> & dict);\n\n\ttemplate <typename K2>\n\tfriend istream & operator >> (istream & in, HT<K2> & dict);\n   \tvoid _inspect() const {\n\t\tI(i, tuples.size())\n\t\t\tif (tuples[i].in_use)\n\t\t\t\tcout << \"#\" << i << \" C\" << canonical_index(tuples[i].key) \n\t\t\t\t\t<< \" \" << tuples[i].key << \" \" << tuples[i].val << endl;\n\t}\n\tvector <int> getKeys(){\n\t\tvector<int>m;\n\t\tfor(int i=0;i<tuples.size();i++){\n\t\t\tif(tuples[i].in_use!=0) m.push_back(tuples[i].key);\n\t\t}\n\t\treturn m;\n\t}\n};\ntemplate <typename E>\nostream & operator << (ostream & out, const HT<E> & dict) {\n\tout << dict.size() << endl;\n\tI(i, dict.tuples.size())\n\t\tif (dict.tuples[i].in_use)\n\t\t\tout << dict.tuples[i].key << \"\\t\" << dict.tuples[i].val << endl;\n\treturn out;\n}\n\ntemplate <typename E>\nistream & operator >> (istream & in, HT<E> & dict) {\n\tdict.clear();\n\tsize_t size;\n\tin >> size;\n\tI(i, size) {\n\t\tint key;\n\t\tE val;\n\t\tin >> key >> val;\n\t\tdict.put(key, val);\n\t}\n\treturn in;\n}",
            1595475284.8782485,
            100,
            "# 答案正确"
        ]
    ],
    "table_name": "答案"
}