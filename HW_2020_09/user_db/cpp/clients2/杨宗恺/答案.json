{
    "__update_time__": 1595470474.7250252,
    "field_names": [
        "题目名",
        "用户名",
        "答案",
        "提交时间",
        "分数",
        "评语"
    ],
    "field_types": [
        "text",
        "text",
        "text",
        "time",
        "number",
        "text"
    ],
    "foreign_keys": {},
    "primary_keys": [],
    "rows": [
        [
            "测试1",
            "杨宗恺",
            "#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    char s1[100];\n    char s2[100];\n    char s3[100];\n    cin >> s1 >> s2 >> s3;\n    cout << s3 << \" \" << s2 << \" \" << s1 << endl;\n}\n",
            1587522164.6624973,
            100,
            "# 答案正确"
        ],
        [
            "测试2",
            "杨宗恺",
            "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nint main()\n{\n    char s[10][6];\n    for (int i = 0; i < 10; ++i)\n    {\n        cin >> s[i];\n    }\n    for (int i = 0; i < 10; ++i)\n    {\n        for (int j = 0; j < 10 - i - 1; ++j)\n        {\n            if (strcmp(s[j], s[j + 1]) > 0)\n            {\n                char temp[6];\n                strcpy(temp, s[j]);\n                strcpy(s[j], s[j + 1]);\n                strcpy(s[j + 1], temp);\n            }\n        }\n    }\n    for (int i = 0; i < 10; ++i)\n    {\n        cout << s[i] << \" \";\n    }\n}\n\n",
            1587608572.1902907,
            100,
            "# 答案正确"
        ],
        [
            "1.1 (C++)",
            "杨宗恺",
            "class Matrix5x5\n{\npublic:\n    Matrix5x5()\n    {\n        for (int i = 0; i < 5; ++i)\n        {\n            for (int j = 0; j < 5; ++j)\n            {\n                a[i][j] = 0;\n            }\n        }\n    }\n\n    double get(int row, int col)\n    {\n        return a[row][col];\n    }\n\n    void set(int row, int col, double value)\n    {\n        a[row][col] = value;\n    }\n\n    Matrix5x5 operator + (Matrix5x5 & t1)\n    {\n        Matrix5x5 t;\n        for (int i = 0; i < 5; ++i)\n        {\n            for (int j = 0; j < 5; ++j)\n            {\n                t.a[i][j] = a[i][j] + t1.a[i][j];\n            }\n        }\n        return t;\n    }\n\nprivate:\n    double a[5][5];\n};",
            1587697684.8284512,
            100,
            "# 答案正确"
        ],
        [
            "1.2 (C++)",
            "杨宗恺",
            "#include <cstring>\n\nclass School\n{\npublic:\n    char name[10];\n    int age;\n\n    School()\n    {\n        strcpy(name, \"NO_NAME\");\n        age = 0;\n    }\n\n    void setName(char * name)\n    {\n        strcpy(this -> name, name);\n    }\n\n    void setAge(int year)\n    {\n        age = year;\n    }\n\n    void operator ++ ()\n    {\n        (*this).age += 1;\n    }\n};",
            1588212919.0352986,
            100,
            "# 答案正确"
        ],
        [
            "2.1 (C++)",
            "杨宗恺",
            "#include <iostream>\n\nusing namespace std;\n\nclass Matrix\n{\npublic:\n    Matrix()\n    {\n        matrix = nullptr;\n        row = 0;\n        col = 0;\n    }\n\n    Matrix(int row, int col)\n    {\n        this -> row = row;\n        this -> col = col;\n        matrix = new double*[row];\n        for (int i = 0; i < row; ++i)\n        {\n            matrix[i] = new double [col];\n            for (int j = 0; j < col; ++j)\n            {\n                matrix[i][j] = 0;\n            }\n        }\n    }\n\n    ~Matrix()\n    {\n        for (int i = 0; i < row; ++i)\n        {\n            if (matrix[i] != nullptr) delete [] matrix[i];\n        }\n        if (matrix != nullptr) delete [] matrix;\n    }\n\n    void print()\n    {\n        for (int i = 0; i < row; ++i)\n        {\n            for (int j = 0; j < col; ++j)\n            {\n                cout << \"    \" << matrix[i][j];\n            }\n            cout << endl;\n        }\n    }\n\nprivate:\n    double **matrix;\n    int row;\n    int col;\n};",
            1588824421.594285,
            100,
            "# 答案正确"
        ],
        [
            "2.2 (C++)",
            "杨宗恺",
            "#include <iostream>\n#include <iomanip>\n\nusing namespace std;\n\nclass Matrix\n{\npublic:\n    Matrix()\n    {\n        matrix = nullptr;\n        row = 0;\n        col = 0;\n    }\n\n    Matrix(int row, int col)\n    {\n        this -> row = row;\n        this -> col = col;\n        matrix = new double*[row];\n        for (int i = 0; i < row; ++i)\n        {\n            matrix[i] = new double [col];\n            for (int j = 0; j < col; ++j)\n            {\n                matrix[i][j] = 0;\n            }\n        }\n    }\n\n    Matrix(int row, int col, const double *value)\n    {\n        this -> row = row;\n        this -> col = col;\n        matrix = new double*[row];\n        for (int i = 0; i < row; ++i)\n        {\n            matrix[i] = new double [col];\n            for (int j = 0; j < col; ++j)\n            {\n                matrix[i][j] = value[i * col + j];\n            }\n        }\n    }\n\n    ~Matrix()\n    {\n        for (int i = 0; i < row; ++i)\n        {\n            if (matrix[i] != nullptr) delete [] matrix[i];\n        }\n        if (matrix != nullptr) delete [] matrix;\n    }\n\n    void print()\n    {\n        for (int i = 0; i < row; ++i)\n        {\n            for (int j = 0; j < col; ++j)\n            {\n                cout << setw(5) << matrix[i][j];\n            }\n            cout << endl;\n        }\n    }\n\nprivate:\n    double **matrix;\n    int row;\n    int col;\n};\n\n",
            1588825207.6155303,
            100,
            "# 答案正确"
        ],
        [
            "2.3 (C++)",
            "杨宗恺",
            "#include <iostream>\n\nusing namespace std;\n\nclass Matrix\n{\npublic:\n    Matrix()\n    {\n        matrix = nullptr;\n        row = 0;\n        col = 0;\n    }\n\n    Matrix(int row, int col)\n    {\n        this -> row = row;\n        this -> col = col;\n        matrix = new double*[row];\n        for (int i = 0; i < row; ++i)\n        {\n            matrix[i] = new double [col];\n            for (int j = 0; j < col; ++j)\n            {\n                matrix[i][j] = 0;\n            }\n        }\n    }\n\n    Matrix(int row, int col, const double *value)\n    {\n        this -> row = row;\n        this -> col = col;\n        matrix = new double*[row];\n        for (int i = 0; i < row; ++i)\n        {\n            matrix[i] = new double [col];\n            for (int j = 0; j < col; ++j)\n            {\n                matrix[i][j] = value[i * col + j];\n            }\n        }\n    }\n    \n    Matrix (const Matrix & matrix1)\n    {\n        row = matrix1.row;\n        col = matrix1.col;\n        matrix = new double*[row];\n        for (int i = 0; i < row; ++i)\n        {\n            matrix[i] = new double [col];\n            for (int j = 0; j < col; ++j)\n            {\n                matrix[i][j] = matrix1.matrix[i][j];\n            }\n        }\n    }\n\n    ~Matrix()\n    {\n        for (int i = 0; i < row; ++i)\n        {\n            if (matrix[i] != nullptr) delete [] matrix[i];\n        }\n        if (matrix != nullptr) delete [] matrix;\n    }\n\n    void print()\n    {\n        for (int i = 0; i < row; ++i)\n        {\n            for (int j = 0; j < col; ++j)\n            {\n                cout << \"    \" << matrix[i][j];\n            }\n            cout << endl;\n        }\n    }\n\nprivate:\n    double **matrix;\n    int row;\n    int col;\n};\n\n",
            1588824790.107034,
            100,
            "# 答案正确"
        ],
        [
            "2.5 (C++)",
            "杨宗恺",
            "#include <iostream>\n\nusing namespace std;\n\nclass Matrix\n{\npublic:\n    Matrix()\n    {\n        matrix = nullptr;\n        row = 0;\n        col = 0;\n    }\n\n    Matrix(int row, int col)\n    {\n        this -> row = row;\n        this -> col = col;\n        matrix = new double*[row];\n        for (int i = 0; i < row; ++i)\n        {\n            matrix[i] = new double [col];\n            for (int j = 0; j < col; ++j)\n            {\n                matrix[i][j] = 0;\n            }\n        }\n    }\n\n    Matrix(int row, int col, const double *value)\n    {\n        this -> row = row;\n        this -> col = col;\n        matrix = new double*[row];\n        for (int i = 0; i < row; ++i)\n        {\n            matrix[i] = new double [col];\n            for (int j = 0; j < col; ++j)\n            {\n                matrix[i][j] = value[i * col + j];\n            }\n        }\n    }\n    \n    Matrix (const Matrix & matrix1)\n    {\n        row = matrix1.row;\n        col = matrix1.col;\n        matrix = new double*[row];\n        for (int i = 0; i < row; ++i)\n        {\n            matrix[i] = new double [col];\n            for (int j = 0; j < col; ++j)\n            {\n                matrix[i][j] = matrix1.matrix[i][j];\n            }\n        }\n    }\n\n    ~Matrix()\n    {\n        for (int i = 0; i < row; ++i)\n        {\n            if (matrix[i] != nullptr) delete [] matrix[i];\n        }\n        if (matrix != nullptr) delete [] matrix;\n    }\n    \n    Matrix getColumn(int row)\n    {\n        Matrix t(this -> row, 1);\n        for(int i = 0; i < this -> row; ++i)\n        {\n            t.matrix[i][0] = matrix[i][row - 1];\n        }\n        return t;\n    }\n\n    Matrix getRow(int col)\n    {\n        Matrix t(1, this -> col);\n        for(int i = 0; i < this -> col; ++i)\n        {\n            t.matrix[0][i] = matrix[col - 1][i];\n        }\n        return t;\n    }\n\n    void print()\n    {\n        for (int i = 0; i < row; ++i)\n        {\n            for (int j = 0; j < col; ++j)\n            {\n                cout << \"    \" << matrix[i][j];\n            }\n            cout << endl;\n        }\n    }\n\nprivate:\n    double **matrix;\n    int row;\n    int col;\n};\n\n",
            1588824886.7492635,
            100,
            "# 答案正确"
        ],
        [
            "2.6 (C++)",
            "杨宗恺",
            "#include <iostream>\n\nusing namespace std;\n\nclass Matrix\n{\npublic:\n    Matrix()\n    {\n        matrix = nullptr;\n        row = 0;\n        col = 0;\n    }\n\n    Matrix(int row, int col)\n    {\n        this -> row = row;\n        this -> col = col;\n        matrix = new double*[row];\n        for (int i = 0; i < row; ++i)\n        {\n            matrix[i] = new double [col];\n            for (int j = 0; j < col; ++j)\n            {\n                matrix[i][j] = 0;\n            }\n        }\n    }\n\n    Matrix(int row, int col, const double *value)\n    {\n        this -> row = row;\n        this -> col = col;\n        matrix = new double*[row];\n        for (int i = 0; i < row; ++i)\n        {\n            matrix[i] = new double [col];\n            for (int j = 0; j < col; ++j)\n            {\n                matrix[i][j] = value[i * col + j];\n            }\n        }\n    }\n    \n    Matrix (const Matrix & matrix1)\n    {\n        row = matrix1.row;\n        col = matrix1.col;\n        matrix = new double*[row];\n        for (int i = 0; i < row; ++i)\n        {\n            matrix[i] = new double [col];\n            for (int j = 0; j < col; ++j)\n            {\n                matrix[i][j] = matrix1.matrix[i][j];\n            }\n        }\n    }\n\n    ~Matrix()\n    {\n        for (int i = 0; i < row; ++i)\n        {\n            if (matrix[i] != nullptr) delete [] matrix[i];\n        }\n        if (matrix != nullptr) delete [] matrix;\n    }\n    \n    Matrix getColumn(int row)\n    {\n        Matrix t(this -> row, 1);\n        for(int i = 0; i < this -> row; ++i)\n        {\n            t.matrix[i][0] = matrix[i][row - 1];\n        }\n        return t;\n    }\n\n    Matrix getRow(int col)\n    {\n        Matrix t(1, this -> col);\n        for(int i = 0; i < this -> col; ++i)\n        {\n            t.matrix[0][i] = matrix[col - 1][i];\n        }\n        return t;\n    }\n    \n    Matrix concatenateRows(Matrix & matrix1)\n    {\n        Matrix t(row + matrix1.row, col);\n        for(int i = 0; i < row; ++i)\n        {\n            for(int j = 0; j < col; ++j)\n            {\n                t.matrix[i][j] = matrix[i][j];\n            }\n        }\n        for(int i = row; i < t.row; ++i)\n        {\n            for(int j = 0; j < col; ++j)\n            {\n                t.matrix[i][j] = matrix1.matrix[i - row][j];\n            }\n        }\n        return t;\n    }\n\n    Matrix concatenateColumns(Matrix & matrix1)\n    {\n        Matrix t(row, col + matrix1.col);\n        for(int i = 0; i < row; ++i)\n        {\n            for(int j = 0; j < col; ++j)\n            {\n                t.matrix[i][j] = matrix[i][j];\n            }\n        }\n        for(int i = 0; i < row; ++i)\n        {\n            for(int j = col; j < t.col; ++j)\n            {\n                t.matrix[i][j] = matrix1.matrix[i][j - col];\n            }\n        }\n        return t;\n    }\n\n    void print()\n    {\n        for (int i = 0; i < row; ++i)\n        {\n            for (int j = 0; j < col; ++j)\n            {\n                cout << \"    \" << matrix[i][j];\n            }\n            cout << endl;\n        }\n    }\n\nprivate:\n    double **matrix;\n    int row;\n    int col;\n};\n\n",
            1588824980.7307172,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/08",
            "杨宗恺",
            "double & Tensor_get(int dimensions, const int sizes[], double data[], int x0, int x1, int x2, int x3)\n{\n\tif (dimensions == 1)\n\t{\n\t\treturn   data[x0];\n\t}\n\t\tif (dimensions == 2)\n\t\t{\n\t\t\t\treturn data[x0 * sizes[1] +  x1];\n\t\t}\n\t\t\n\t\tif (dimensions == 3)\n\t\t{\n\t\t\treturn data[x0 * sizes[1] * sizes[2] +  x1 * sizes[2] + x2  ];\n\t\t}\n\t\t\t\n\t\telse\n\t\t\treturn data[x0 * sizes[1] * sizes[2] * sizes[3]+  x1 * sizes[2]  * sizes[3]+ x2 * sizes[3] + x3  ];\n}",
            1588909171.033078,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/14",
            "杨宗恺",
            "#include <iostream>\nusing namespace std;\n\nvoid Tensor_print(int dimensions, const int sizes[], const double data[])\n{\n    cout << \"Tensor of \";\n    for (int i = 0; i < dimensions; ++i)\n    {\n        cout << sizes[i];\n        if (i != dimensions - 1) cout << \"x\";\n    }\n    cout << endl;\n    switch (dimensions)\n    {\n    case 1:\n        for (int i = 0; i < sizes[0]; ++i)\n        {\n            cout << data[i] << endl;\n        }\n        break;\n    case 2:\n        for (int i = 0; i < sizes[0]; ++i)\n        {\n            for (int j = 0; j < sizes[1]; ++j)\n            {\n                cout << \"    \" << data[i * sizes[1] + j];\n            }\n            cout << endl;\n        }\n        break;\n    case 3:\n        for (int i = 0; i < sizes[0]; ++i)\n        {\n            cout << \"data[\" << i << \"]\" << endl;\n            for (int j = 0; j < sizes[1]; ++j)\n            {\n                for (int k = 0; k < sizes[2]; ++k)\n                {\n                    cout << \"    \" << data[i * sizes[1] * sizes[2] + j * sizes[2] + k];\n                }\n                cout << endl;\n            }\n        }\n        break;\n    case 4:\n        for (int i = 0; i < sizes[0]; ++i)\n        {\n            for (int j = 0; j < sizes[1]; ++j)\n            {\n                cout << \"data[\" << i << \"]\" << \"[\" << j << \"]\" << endl;\n                for (int k = 0; k < sizes[2]; ++k)\n                {\n                    for (int l = 0; l < sizes[3]; ++l)\n                    {\n                        cout << \"    \" << data[i * sizes[1] * sizes[2] * sizes[3] + j * sizes[2] * sizes[3] + k * sizes[3] + l];\n                    }\n                    cout << endl;\n                }\n            }\n        }\n        break;\n    default:\n        break;\n    }\n}",
            1589424260.242443,
            100,
            "# 答案正确"
        ],
        [
            "2.4 (C++)",
            "杨宗恺",
            "#include <iostream>\n\nusing namespace std;\n\nclass Matrix\n{\npublic:\n    Matrix()\n    {\n        matrix = nullptr;\n        row = 0;\n        col = 0;\n    }\n\n    Matrix(int row, int col)\n    {\n        this -> row = row;\n        this -> col = col;\n        matrix = new double*[row];\n        for (int i = 0; i < row; ++i)\n        {\n            matrix[i] = new double [col];\n            for (int j = 0; j < col; ++j)\n            {\n                matrix[i][j] = 0;\n            }\n        }\n    }\n\n    Matrix(int row, int col, const double *value)\n    {\n        this -> row = row;\n        this -> col = col;\n        matrix = new double*[row];\n        for (int i = 0; i < row; ++i)\n        {\n            matrix[i] = new double [col];\n            for (int j = 0; j < col; ++j)\n            {\n                matrix[i][j] = value[i * col + j];\n            }\n        }\n    }\n\n    Matrix (const Matrix & matrix1)\n    {\n        row = matrix1.row;\n        col = matrix1.col;\n        matrix = new double*[row];\n        for (int i = 0; i < row; ++i)\n        {\n            matrix[i] = new double [col];\n            for (int j = 0; j < col; ++j)\n            {\n                matrix[i][j] = matrix1.matrix[i][j];\n            }\n        }\n    }\n\n    ~Matrix()\n    {\n        for (int i = 0; i < row; ++i)\n        {\n            if (matrix[i] != nullptr) delete [] matrix[i];\n        }\n        if (matrix != nullptr) delete [] matrix;\n    }\n    \n    Matrix & operator = (Matrix & matrix1)\n    {\n        if (matrix != nullptr)\n        {\n            for (int i = 0; i < this -> row; ++i)\n            {\n                if (matrix[i] != nullptr) delete [] matrix[i];\n            }\n            delete [] matrix;\n        }\n        this -> row = matrix1.row;\n        this -> col = matrix1.col;\n        this -> matrix = new double*[matrix1.row];\n        for (int i = 0; i < matrix1.row; ++i)\n        {\n            this -> matrix[i] = new double [matrix1.col];\n            for (int j = 0; j < matrix1.col; ++j)\n            {\n                this -> matrix[i][j] = matrix1.matrix[i][j];\n            }\n        }\n        return *this;\n    }\n    \n    void set(int row, int col, double value)\n    {\n        matrix[row - 1][col - 1] = value;\n    }\n\n    void print()\n    {\n        for (int i = 0; i < row; ++i)\n        {\n            for (int j = 0; j < col; ++j)\n            {\n                cout << \"    \" << matrix[i][j];\n            }\n            cout << endl;\n        }\n    }\n\nprivate:\n    double **matrix;\n    int row;\n    int col;\n};\n",
            1589508465.594258,
            100,
            "# 答案正确"
        ],
        [
            "2.7 (C++)",
            "杨宗恺",
            "#include <iostream>\n\nusing namespace std;\n\nclass Matrix\n{\npublic:\n    Matrix()\n    {\n        matrix = nullptr;\n        row = 0;\n        col = 0;\n    }\n\n    Matrix(int row, int col)\n    {\n        this -> row = row;\n        this -> col = col;\n        matrix = new double*[row];\n        for (int i = 0; i < row; ++i)\n        {\n            matrix[i] = new double [col];\n            for (int j = 0; j < col; ++j)\n            {\n                matrix[i][j] = 0;\n            }\n        }\n    }\n\n    Matrix(int row, int col, const double *value)\n    {\n        this -> row = row;\n        this -> col = col;\n        matrix = new double*[row];\n        for (int i = 0; i < row; ++i)\n        {\n            matrix[i] = new double [col];\n            for (int j = 0; j < col; ++j)\n            {\n                matrix[i][j] = value[i * col + j];\n            }\n        }\n    }\n\n    Matrix (const Matrix & matrix1)\n    {\n        row = matrix1.row;\n        col = matrix1.col;\n        matrix = new double*[row];\n        for (int i = 0; i < row; ++i)\n        {\n            matrix[i] = new double [col];\n            for (int j = 0; j < col; ++j)\n            {\n                matrix[i][j] = matrix1.matrix[i][j];\n            }\n        }\n    }\n\n    ~Matrix()\n    {\n        for (int i = 0; i < row; ++i)\n        {\n            if (matrix[i] != nullptr) delete [] matrix[i];\n        }\n        if (matrix != nullptr) delete [] matrix;\n    }\n\n    Matrix reshape(int row, int col)\n    {\n        Matrix t(row, col);\n        for(int i = 0; i < col; ++i)\n        {\n            for(int j = 0; j < row; ++j)\n            {\n                int num = i * row + j;\n                t.matrix[j][i] = matrix[num % this -> row][num / this -> row];\n            }\n        }\n        return t;\n    }\n\n    void print()\n    {\n        for (int i = 0; i < row; ++i)\n        {\n            for (int j = 0; j < col; ++j)\n            {\n                cout << \"    \" << matrix[i][j];\n            }\n            cout << endl;\n        }\n    }\n\nprivate:\n    double **matrix;\n    int row;\n    int col;\n};",
            1589508611.4993026,
            100,
            "# 答案正确"
        ],
        [
            "2.8 (C++)",
            "杨宗恺",
            "#include <iostream>\n\nusing namespace std;\n\nclass Matrix\n{\npublic:\n    Matrix()\n    {\n        matrix = nullptr;\n        row = 0;\n        col = 0;\n    }\n\n    Matrix(int row, int col)\n    {\n        this -> row = row;\n        this -> col = col;\n        matrix = new double*[row];\n        for (int i = 0; i < row; ++i)\n        {\n            matrix[i] = new double [col];\n            for (int j = 0; j < col; ++j)\n            {\n                matrix[i][j] = 0;\n            }\n        }\n    }\n\n    Matrix(int row, int col, const double *value)\n    {\n        this -> row = row;\n        this -> col = col;\n        matrix = new double*[row];\n        for (int i = 0; i < row; ++i)\n        {\n            matrix[i] = new double [col];\n            for (int j = 0; j < col; ++j)\n            {\n                matrix[i][j] = value[i * col + j];\n            }\n        }\n    }\n\n    Matrix (const Matrix & matrix1)\n    {\n        row = matrix1.row;\n        col = matrix1.col;\n        matrix = new double*[row];\n        for (int i = 0; i < row; ++i)\n        {\n            matrix[i] = new double [col];\n            for (int j = 0; j < col; ++j)\n            {\n                matrix[i][j] = matrix1.matrix[i][j];\n            }\n        }\n    }\n\n    ~Matrix()\n    {\n        for (int i = 0; i < row; ++i)\n        {\n            if (matrix[i] != nullptr) delete [] matrix[i];\n        }\n        if (matrix != nullptr) delete [] matrix;\n    }\n\n    Matrix transpose()\n    {\n        Matrix t(col, row);\n        for(int i = 0; i < col; ++i)\n        {\n            for(int j = 0; j < row; ++j)\n            {\n                t.matrix[i][j] = matrix[j][i];\n            }\n        }\n        return t;\n    }\n\n    void print()\n    {\n        for (int i = 0; i < row; ++i)\n        {\n            for (int j = 0; j < col; ++j)\n            {\n                cout << \"    \" << matrix[i][j];\n            }\n            cout << endl;\n        }\n    }\n\nprivate:\n    double **matrix;\n    int row;\n    int col;\n};\n",
            1589508700.6243353,
            100,
            "# 答案正确"
        ],
        [
            "2.10 (C++)",
            "杨宗恺",
            "#include <iostream>\n\nusing namespace std;\n\nclass Matrix\n{\npublic:\n    Matrix()\n    {\n        matrix = nullptr;\n        row = 0;\n        col = 0;\n    }\n\n    Matrix(int row, int col)\n    {\n        this -> row = row;\n        this -> col = col;\n        matrix = new double*[row];\n        for (int i = 0; i < row; ++i)\n        {\n            matrix[i] = new double [col];\n            for (int j = 0; j < col; ++j)\n            {\n                matrix[i][j] = 0;\n            }\n        }\n    }\n\n    Matrix(int row, int col, const double *value)\n    {\n        this -> row = row;\n        this -> col = col;\n        matrix = new double*[row];\n        for (int i = 0; i < row; ++i)\n        {\n            matrix[i] = new double [col];\n            for (int j = 0; j < col; ++j)\n            {\n                matrix[i][j] = value[i * col + j];\n            }\n        }\n    }\n\n    Matrix (const Matrix & matrix1)\n    {\n        row = matrix1.row;\n        col = matrix1.col;\n        matrix = new double*[row];\n        for (int i = 0; i < row; ++i)\n        {\n            matrix[i] = new double [col];\n            for (int j = 0; j < col; ++j)\n            {\n                matrix[i][j] = matrix1.matrix[i][j];\n            }\n        }\n    }\n\n    ~Matrix()\n    {\n        for (int i = 0; i < row; ++i)\n        {\n            if (matrix[i] != nullptr) delete [] matrix[i];\n        }\n        if (matrix != nullptr) delete [] matrix;\n    }\n    \n    Matrix operator *(Matrix & matrix1)\n    {\n        if (row != matrix1.col || col != matrix1.row) return Matrix();\n        Matrix t(row, col);\n        for (int i = 0; i < row; ++i)\n        {\n            for (int j = 0; j < col; ++j)\n            {\n                for (int k = 0; k < col; ++k)\n                {\n                    t.matrix[i][j] += matrix[i][k] * matrix1.matrix[k][j];\n                }\n            }\n        }\n        return t;\n    }\n\n    Matrix operator *(double value)\n    {\n        Matrix t(row, col);\n        for (int i = 0; i < row; ++i)\n        {\n            for (int j = 0; j < col; ++j)\n            {\n                t.matrix[i][j] = matrix[i][j] * value;\n            }\n        }\n        return t;\n    }\n\n    void print()\n    {\n        for (int i = 0; i < row; ++i)\n        {\n            for (int j = 0; j < col; ++j)\n            {\n                cout << \"    \" << matrix[i][j];\n            }\n            cout << endl;\n        }\n    }\n\nprivate:\n    double **matrix;\n    int row;\n    int col;\n};",
            1589508859.7893553,
            100,
            "# 答案正确"
        ],
        [
            "2.11 (C++)",
            "杨宗恺",
            "#include <iostream>\n\nusing namespace std;\n\nclass Matrix\n{\npublic:\n    Matrix()\n    {\n        matrix = nullptr;\n        row = 0;\n        col = 0;\n    }\n\n    Matrix(int row, int col)\n    {\n        this -> row = row;\n        this -> col = col;\n        matrix = new double*[row];\n        for (int i = 0; i < row; ++i)\n        {\n            matrix[i] = new double [col];\n            for (int j = 0; j < col; ++j)\n            {\n                matrix[i][j] = 0;\n            }\n        }\n    }\n\n    Matrix(int row, int col, const double *value)\n    {\n        this -> row = row;\n        this -> col = col;\n        matrix = new double*[row];\n        for (int i = 0; i < row; ++i)\n        {\n            matrix[i] = new double [col];\n            for (int j = 0; j < col; ++j)\n            {\n                matrix[i][j] = value[i * col + j];\n            }\n        }\n    }\n\n    Matrix (const Matrix & matrix1)\n    {\n        row = matrix1.row;\n        col = matrix1.col;\n        matrix = new double*[row];\n        for (int i = 0; i < row; ++i)\n        {\n            matrix[i] = new double [col];\n            for (int j = 0; j < col; ++j)\n            {\n                matrix[i][j] = matrix1.matrix[i][j];\n            }\n        }\n    }\n\n    ~Matrix()\n    {\n        for (int i = 0; i < row; ++i)\n        {\n            if (matrix[i] != nullptr) delete [] matrix[i];\n        }\n        if (matrix != nullptr) delete [] matrix;\n    }\n\n    Matrix max()\n    {\n        if (row > 1 && col > 1)\n        {\n            Matrix t(1, col);\n            double num_max = 0;\n            for (int i = 0; i < col; ++i)\n            {\n                for (int j = 0; j < row; ++j)\n                {\n                    num_max = num_max > matrix[j][i] ? num_max : matrix[j][i];\n                }\n                t[0][i] = num_max;\n                num_max = 0;\n            }\n            return t;\n        }\n        else if (row == 1 && col > 1)\n        {\n            double num_max[1] = {0};\n            for (int i = 0; i < col; ++i)\n            {\n                num_max[0] = num_max[0] > matrix[0][i] ? num_max[0] : matrix[0][i];\n            }\n            Matrix t(1, 1, num_max);\n            return t;\n        }\n        else return *this;\n    }\n\n    Matrix min()\n    {\n        if (row > 1 && col > 1)\n        {\n            Matrix t(1, col);\n            double num_min = 99999999;\n            for (int i = 0; i < col; ++i)\n            {\n                for (int j = 0; j < row; ++j)\n                {\n                    num_min = num_min > matrix[j][i] ? matrix[j][i] : num_min;\n                }\n                t[0][i] = num_min;\n                num_min = 99999999;\n            }\n            return t;\n        }\n        else if (row == 1 && col > 1)\n        {\n            double num_min[1] = {99999999};\n            for (int i = 0; i < col; ++i)\n            {\n                num_min[0] = num_min[0] > matrix[0][i] ? matrix[0][i] : num_min[0];\n            }\n            Matrix t(1, 1, num_min);\n            return t;\n        }\n        else return *this;\n    }\n\n    Matrix sum()\n    {\n        if (row > 1 && col > 1)\n        {\n            Matrix t(1, col);\n            double sum = 0;\n            for (int i = 0; i < col; ++i)\n            {\n                for (int j = 0; j < row; ++j)\n                {\n                    sum +=  matrix[j][i];\n                }\n                t[0][i] = sum;\n                sum = 0;\n            }\n            return t;\n        }\n        else if (row == 1 && col > 1)\n        {\n            double sum[1] = {0};\n            for (int i = 0; i < col; ++i)\n            {\n                sum[0] += matrix[0][i];\n            }\n            Matrix t(1, 1, sum);\n            return t;\n        }\n        else return *this;\n    }\n\n    double * operator [] (int n)\n    {\n        return matrix[n];\n    }\n\n    void print()\n    {\n        for (int i = 0; i < row; ++i)\n        {\n            for (int j = 0; j < col; ++j)\n            {\n                cout << \"    \" << matrix[i][j];\n            }\n            cout << endl;\n        }\n    }\n\nprivate:\n    double **matrix;\n    int row;\n    int col;\n};",
            1589509465.1656504,
            100,
            "# 答案正确"
        ],
        [
            "2.12 (C++)",
            "杨宗恺",
            "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nclass Matrix\n{\npublic:\n    Matrix()\n    {\n        matrix = nullptr;\n        row = 0;\n        col = 0;\n    }\n\n    Matrix(int row, int col)\n    {\n        this -> row = row;\n        this -> col = col;\n        matrix = new double*[row];\n        for (int i = 0; i < row; ++i)\n        {\n            matrix[i] = new double [col];\n            for (int j = 0; j < col; ++j)\n            {\n                matrix[i][j] = 0;\n            }\n        }\n    }\n\n    Matrix(int row, int col, const double *value)\n    {\n        this -> row = row;\n        this -> col = col;\n        matrix = new double*[row];\n        for (int i = 0; i < row; ++i)\n        {\n            matrix[i] = new double [col];\n            for (int j = 0; j < col; ++j)\n            {\n                matrix[i][j] = value[i * col + j];\n            }\n        }\n    }\n\n    Matrix (const Matrix & matrix1)\n    {\n        row = matrix1.row;\n        col = matrix1.col;\n        matrix = new double*[row];\n        for (int i = 0; i < row; ++i)\n        {\n            matrix[i] = new double [col];\n            for (int j = 0; j < col; ++j)\n            {\n                matrix[i][j] = matrix1.matrix[i][j];\n            }\n        }\n    }\n\n    ~Matrix()\n    {\n        for (int i = 0; i < row; ++i)\n        {\n            if (matrix[i] != nullptr) delete [] matrix[i];\n        }\n        if (matrix != nullptr) delete [] matrix;\n    }\n\n    Matrix pow(int n)\n    {\n        Matrix t(row, col);\n        for(int i = 0; i < row; ++i)\n        {\n            for(int j = 0; j < col; ++j)\n            {\n                if (n == 0) t.matrix[i][j] = 1;\n                else t.matrix[i][j] = std::pow(matrix[i][j], n);\n            }\n        }\n        return t;\n    }\n\n    Matrix exp()\n    {\n        Matrix t(row, col);\n        for(int i = 0; i < row; ++i)\n        {\n            for(int j = 0; j < col; ++j)\n            {\n                t.matrix[i][j] = std::exp(matrix[i][j]);\n            }\n        }\n        return t;\n    }\n\n    Matrix log()\n    {\n        Matrix t(row, col);\n        for(int i = 0; i < row; ++i)\n        {\n            for(int j = 0; j < col; ++j)\n            {\n                t.matrix[i][j] = std::log(matrix[i][j]);\n            }\n        }\n        return t;\n    }\n\n    Matrix abs()\n    {\n        Matrix t(row, col);\n        for(int i = 0; i < row; ++i)\n        {\n            for(int j = 0; j < col; ++j)\n            {\n                t.matrix[i][j] = std::abs(matrix[i][j]);\n            }\n        }\n        return t;\n    }\n\n    double * operator [] (int n)\n    {\n        return matrix[n];\n    }\n\n    void print()\n    {\n        for (int i = 0; i < row; ++i)\n        {\n            for (int j = 0; j < col; ++j)\n            {\n                cout << \"    \" << matrix[i][j];\n            }\n            cout << endl;\n        }\n    }\n\nprivate:\n    double **matrix;\n    int row;\n    int col;\n};",
            1589509652.391369,
            100,
            "# 答案正确"
        ],
        [
            "2.9 (C++)",
            "杨宗恺",
            "#include <iostream>\n\nusing namespace std;\n\nclass Matrix\n{\npublic:\n    Matrix()\n    {\n        matrix = nullptr;\n        row = 0;\n        col = 0;\n    }\n\n    Matrix(int row, int col)\n    {\n        this -> row = row;\n        this -> col = col;\n        matrix = new double*[row];\n        for (int i = 0; i < row; ++i)\n        {\n            matrix[i] = new double [col];\n            for (int j = 0; j < col; ++j)\n            {\n                matrix[i][j] = 0;\n            }\n        }\n    }\n\n    Matrix(int row, int col, const double *value)\n    {\n        this -> row = row;\n        this -> col = col;\n        matrix = new double*[row];\n        for (int i = 0; i < row; ++i)\n        {\n            matrix[i] = new double [col];\n            for (int j = 0; j < col; ++j)\n            {\n                matrix[i][j] = value[i * col + j];\n            }\n        }\n    }\n\n    Matrix (const Matrix & matrix1)\n    {\n        row = matrix1.row;\n        col = matrix1.col;\n        matrix = new double*[row];\n        for (int i = 0; i < row; ++i)\n        {\n            matrix[i] = new double [col];\n            for (int j = 0; j < col; ++j)\n            {\n                matrix[i][j] = matrix1.matrix[i][j];\n            }\n        }\n    }\n\n    ~Matrix()\n    {\n        for (int i = 0; i < row; ++i)\n        {\n            if (matrix[i] != nullptr) delete [] matrix[i];\n        }\n        if (matrix != nullptr) delete [] matrix;\n    }\n\n    Matrix operator +(const Matrix & matrix1)\n    {\n        if (row != matrix1.row || col != matrix1.col) return Matrix();\n        Matrix t(row, col);\n        for (int i = 0; i < row; ++i)\n        {\n            for (int j = 0; j < col; ++j)\n            {\n                t.matrix[i][j] = matrix[i][j] + matrix1.matrix[i][j];\n            }\n        }\n        return t;\n    }\n\n    Matrix operator +(double n)\n    {\n        Matrix t(row, col);\n        for (int i = 0; i < row; ++i)\n        {\n            for (int j = 0; j < col; ++j)\n            {\n                t.matrix[i][j] = matrix[i][j] + n;\n            }\n        }\n        return t;\n    }\n\n    Matrix operator -(const Matrix & matrix1)\n    {\n        if (row != matrix1.row || col != matrix1.col) return Matrix();\n        Matrix t(row, col);\n        for (int i = 0; i < row; ++i)\n        {\n            for (int j = 0; j < col; ++j)\n            {\n                t.matrix[i][j] = matrix[i][j] - matrix1.matrix[i][j];\n            }\n        }\n        return t;\n    }\n\n    Matrix operator -(double n)\n    {\n        Matrix t(row, col);\n        for (int i = 0; i < row; ++i)\n        {\n            for (int j = 0; j < col; ++j)\n            {\n                t.matrix[i][j] = matrix[i][j] - n;\n            }\n        }\n        return t;\n    }\n\n    void print()\n    {\n        for (int i = 0; i < row; ++i)\n        {\n            for (int j = 0; j < col; ++j)\n            {\n                cout << \"    \" << matrix[i][j];\n            }\n            cout << endl;\n        }\n    }\n\nprivate:\n    double **matrix;\n    int row;\n    int col;\n};",
            1590026971.0508366,
            100,
            "# 答案正确"
        ],
        [
            "6.3 (C++)",
            "杨宗恺",
            "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nconst double INF = 0x7fffffff;\n\ntemplate <typename T>\nclass Matrix\n{\npublic:\n    Matrix()\n    {\n        matrix = nullptr;\n        row = 0;\n        col = 0;\n    }\n\n    Matrix(int row, int col)\n    {\n        this -> row = row;\n        this -> col = col;\n        matrix = new T*[row];\n        for (int i = 0; i < row; ++i)\n        {\n            matrix[i] = new T [col];\n            for (int j = 0; j < col; ++j)\n            {\n                matrix[i][j] = T();\n            }\n        }\n    }\n\n    Matrix(int row, int col, vector<T> value)\n    {\n        this -> row = row;\n        this -> col = col;\n        matrix = new T*[row];\n        for (int i = 0; i < row; ++i)\n        {\n            matrix[i] = new T [col];\n            for (int j = 0; j < col; ++j)\n            {\n                matrix[i][j] = value[i * col + j];\n            }\n        }\n    }\n\n    Matrix (const Matrix<T> & matrix1)\n    {\n        row = matrix1.row;\n        col = matrix1.col;\n        matrix = new T*[row];\n        for (int i = 0; i < row; ++i)\n        {\n            matrix[i] = new T [col];\n            for (int j = 0; j < col; ++j)\n            {\n                matrix[i][j] = matrix1.matrix[i][j];\n            }\n        }\n    }\n\n    ~Matrix()\n    {\n        for (int i = 0; i < row; ++i)\n        {\n            if (matrix[i] != nullptr) delete [] matrix[i];\n        }\n        if (matrix != nullptr) delete [] matrix;\n    }\n\n    void print()\n    {\n        for (int i = 0; i < row; ++i)\n        {\n            for (int j = 0; j < col; ++j)\n            {\n                cout << \"    \" << matrix[i][j];\n            }\n            cout << endl;\n        }\n    }\n\n    T & get(int row, int col)\n    {\n        return matrix[row - 1][col - 1];\n    }\n\n    Matrix getColumn(int row)\n    {\n        Matrix t(this -> row, 1);\n        for(int i = 0; i < this -> row; ++i)\n        {\n            t.matrix[i][0] = matrix[i][row - 1];\n        }\n        return t;\n    }\n\n    Matrix getRow(int col)\n    {\n        Matrix t(1, this -> col);\n        for(int i = 0; i < this -> col; ++i)\n        {\n            t.matrix[0][i] = matrix[col - 1][i];\n        }\n        return t;\n    }\n\n    Matrix concatenateRows(Matrix & matrix1)\n    {\n        Matrix t(row + matrix1.row, col);\n        for(int i = 0; i < row; ++i)\n        {\n            for(int j = 0; j < col; ++j)\n            {\n                t.matrix[i][j] = matrix[i][j];\n            }\n        }\n        for(int i = row; i < t.row; ++i)\n        {\n            for(int j = 0; j < col; ++j)\n            {\n                t.matrix[i][j] = matrix1.matrix[i - row][j];\n            }\n        }\n        return t;\n    }\n\n    Matrix concatenateColumns(Matrix & matrix1)\n    {\n        Matrix t(row, col + matrix1.col);\n        for(int i = 0; i < row; ++i)\n        {\n            for(int j = 0; j < col; ++j)\n            {\n                t.matrix[i][j] = matrix[i][j];\n            }\n        }\n        for(int i = 0; i < row; ++i)\n        {\n            for(int j = col; j < t.col; ++j)\n            {\n                t.matrix[i][j] = matrix1.matrix[i][j - col];\n            }\n        }\n        return t;\n    }\n\n    Matrix reshape(int row, int col)\n    {\n        Matrix t(row, col);\n        for(int i = 0; i < col; ++i)\n        {\n            for(int j = 0; j < row; ++j)\n            {\n                int num = i * row + j;\n                t.matrix[j][i] = matrix[num % this -> row][num / this -> row];\n            }\n        }\n        return t;\n    }\n\n    Matrix transpose()\n    {\n        Matrix t(col, row);\n        for(int i = 0; i < col; ++i)\n        {\n            for(int j = 0; j < row; ++j)\n            {\n                t.matrix[i][j] = matrix[j][i];\n            }\n        }\n        return t;\n    }\n\n    Matrix<T> max()\n    {\n        if (row > 1 && col > 1)\n        {\n            Matrix<T> t(row, 1);\n            T num_max = 0;\n            for (int i = 0; i < row; ++i)\n            {\n                for (int j = 0; j < col; ++j)\n                {\n                    num_max = num_max > matrix[i][j] ? num_max : matrix[i][j];\n                }\n                t[i][0] = num_max;\n                num_max = 0;\n            }\n            return t;\n        }\n        else if (row > 1 && col == 1)\n        {\n            vector<T> num_max;\n            num_max.push_back(0);\n            for (int i = 0; i < row; ++i)\n            {\n                num_max[0] = num_max[0] > matrix[i][0] ? num_max[0] : matrix[i][0];\n            }\n            Matrix<T> t(1, 1, num_max);\n            return t;\n        }\n        else return *this;\n    }\n\n    Matrix<T> min()\n    {\n        if (row > 1 && col > 1)\n        {\n            Matrix<T> t(row, 1);\n            T num_min = INF;\n            for (int i = 0; i < row; ++i)\n            {\n                for (int j = 0; j < col; ++j)\n                {\n                    num_min = num_min > matrix[i][j] ? matrix[i][j] : num_min;\n                }\n                t[i][0] = num_min;\n                num_min = INF;\n            }\n            return t;\n        }\n        else if (row > 1 && col == 1)\n        {\n            vector<T> num_min;\n            num_min.push_back(INF);\n            for (int i = 0; i < row; ++i)\n            {\n                num_min[0] = num_min[0] > matrix[i][0] ? matrix[i][0] : num_min[0];\n            }\n            Matrix<T> t(1, 1, num_min);\n            return t;\n        }\n        else return *this;\n    }\n\n    Matrix<T> sum()\n    {\n        if (row > 1 && col > 1)\n        {\n            Matrix<T> t(row, 1);\n            T sum = 0;\n            for (int i = 0; i < row; ++i)\n            {\n                for (int j = 0; j < col; ++j)\n                {\n                    sum += matrix[i][j];\n                }\n                t[i][0] = sum;\n                sum = 0;\n            }\n            return t;\n        }\n        else if (row > 1 && col == 1)\n        {\n            vector<T> sum;\n            sum.push_back(0);\n            for (int i = 0; i < row; ++i)\n            {\n                sum[0] += matrix[i][0];\n            }\n            Matrix<T> t(1, 1, sum);\n            return t;\n        }\n        else return *this;\n    }\n\n    Matrix<T> & operator = (Matrix<T> & matrix1)\n    {\n        if (matrix != nullptr)\n        {\n            for (int i = 0; i < this -> row; ++i)\n            {\n                if (matrix[i] != nullptr) delete [] matrix[i];\n            }\n            delete [] matrix;\n        }\n        this -> row = matrix1.row;\n        this -> col = matrix1.col;\n        this -> matrix = new T*[matrix1.row];\n        for (int i = 0; i < matrix1.row; ++i)\n        {\n            this -> matrix[i] = new T [matrix1.col];\n            for (int j = 0; j < matrix1.col; ++j)\n            {\n                this -> matrix[i][j] = matrix1.matrix[i][j];\n            }\n        }\n        return *this;\n    }\n\n    Matrix<T> operator +(const Matrix<T> & matrix1)\n    {\n        if (row != matrix1.row || col != matrix1.col) return Matrix();\n        Matrix<T> t(row, col);\n        for (int i = 0; i < row; ++i)\n        {\n            for (int j = 0; j < col; ++j)\n            {\n                t.matrix[i][j] = matrix[i][j] + matrix1.matrix[i][j];\n            }\n        }\n        return t;\n    }\n\n    Matrix<T> operator +(T n)\n    {\n        Matrix<T> t(row, col);\n        for (int i = 0; i < row; ++i)\n        {\n            for (int j = 0; j < col; ++j)\n            {\n                t.matrix[i][j] = matrix[i][j] + n;\n            }\n        }\n        return t;\n    }\n\n    Matrix<T> operator -(const Matrix & matrix1)\n    {\n        if (row != matrix1.row || col != matrix1.col) return Matrix();\n        Matrix<T> t(row, col);\n        for (int i = 0; i < row; ++i)\n        {\n            for (int j = 0; j < col; ++j)\n            {\n                t.matrix[i][j] = matrix[i][j] - matrix1.matrix[i][j];\n            }\n        }\n        return t;\n    }\n\n    Matrix<T> operator -(T n)\n    {\n        Matrix<T> t(row, col);\n        for (int i = 0; i < row; ++i)\n        {\n            for (int j = 0; j < col; ++j)\n            {\n                t.matrix[i][j] = matrix[i][j] - n;\n            }\n        }\n        return t;\n    }\n\n    Matrix<T> operator *(Matrix & matrix1)\n    {\n        if (row != matrix1.col || col != matrix1.row) return Matrix();\n        Matrix<T> t(row, col);\n        for (int i = 0; i < row; ++i)\n        {\n            for (int j = 0; j < col; ++j)\n            {\n                for (int k = 0; k < col; ++k)\n                {\n                    t.matrix[i][j] += matrix[i][k] * matrix1.matrix[k][j];\n                }\n            }\n        }\n        return t;\n    }\n\n    Matrix<T> operator *(T n)\n    {\n        Matrix<T> t(row, col);\n        for (int i = 0; i < row; ++i)\n        {\n            for (int j = 0; j < col; ++j)\n            {\n                t.matrix[i][j] = matrix[i][j] * n;\n            }\n        }\n        return t;\n    }\n\n    T * operator [] (int n)\n    {\n        return matrix[n];\n    }\n\nprivate:\n    T **matrix;\n    int row;\n    int col;\n};",
            1590208647.6565,
            100,
            "# 答案正确"
        ],
        [
            "6.1 (C++)",
            "杨宗恺",
            "template <typename T>\nclass Matrix\n{\npublic:\n    Matrix()\n    {\n        matrix = nullptr;\n        row = 0;\n        col = 0;\n    }\n\n    Matrix(int row, int col)\n    {\n        this -> row = row;\n        this -> col = col;\n        matrix = new T*[row];\n        for (int i = 0; i < row; ++i)\n        {\n            matrix[i] = new T [col];\n            for (int j = 0; j < col; ++j)\n            {\n                matrix[i][j] = T();\n            }\n        }\n    }\n\n    Matrix(int row, int col, const T *value)\n    {\n        this -> row = row;\n        this -> col = col;\n        matrix = new T*[row];\n        for (int i = 0; i < row; ++i)\n        {\n            matrix[i] = new T [col];\n            for (int j = 0; j < col; ++j)\n            {\n                matrix[i][j] = value[i * col + j];\n            }\n        }\n    }\n\n    Matrix (const Matrix<T> & matrix1)\n    {\n        row = matrix1.row;\n        col = matrix1.col;\n        matrix = new T*[row];\n        for (int i = 0; i < row; ++i)\n        {\n            matrix[i] = new T [col];\n            for (int j = 0; j < col; ++j)\n            {\n                matrix[i][j] = matrix1.matrix[i][j];\n            }\n        }\n    }\n\n    ~Matrix()\n    {\n        for (int i = 0; i < row; ++i)\n        {\n            if (matrix[i] != nullptr) delete [] matrix[i];\n        }\n        if (matrix != nullptr) delete [] matrix;\n    }\n\n    void print()\n    {\n        for (int i = 0; i < row; ++i)\n        {\n            for (int j = 0; j < col; ++j)\n            {\n                cout << \"    \" << matrix[i][j];\n            }\n            cout << endl;\n        }\n    }\n\n    T & get(int row, int col)\n    {\n        return matrix[row - 1][col - 1];\n    }\n\n    Matrix<T> & operator = (Matrix<T> & matrix1)\n    {\n        if (matrix != nullptr)\n        {\n            for (int i = 0; i < this -> row; ++i)\n            {\n                if (matrix[i] != nullptr) delete [] matrix[i];\n            }\n            delete [] matrix;\n        }\n        this -> row = matrix1.row;\n        this -> col = matrix1.col;\n        this -> matrix = new T*[matrix1.row];\n        for (int i = 0; i < matrix1.row; ++i)\n        {\n            this -> matrix[i] = new T [matrix1.col];\n            for (int j = 0; j < matrix1.col; ++j)\n            {\n                this -> matrix[i][j] = matrix1.matrix[i][j];\n            }\n        }\n        return *this;\n    }\n\n    T * operator [] (int n)\n    {\n        return matrix[n];\n    }\n\nprivate:\n    T **matrix;\n    int row;\n    int col;\n};",
            1590208183.7333493,
            100,
            "# 答案正确"
        ],
        [
            "6.2 (C++)",
            "杨宗恺",
            "#include <iostream>\n\nusing namespace std;\n\ntemplate <typename T>\nclass Matrix\n{\npublic:\n    Matrix()\n    {\n        matrix = nullptr;\n        row = 0;\n        col = 0;\n    }\n\n    Matrix(int row, int col)\n    {\n        this -> row = row;\n        this -> col = col;\n        matrix = new T*[row];\n        for (int i = 0; i < row; ++i)\n        {\n            matrix[i] = new T [col];\n            for (int j = 0; j < col; ++j)\n            {\n                matrix[i][j] = T();\n            }\n        }\n    }\n\n    Matrix(int row, int col, T* value)\n    {\n        this -> row = row;\n        this -> col = col;\n        matrix = new T*[row];\n        for (int i = 0; i < row; ++i)\n        {\n            matrix[i] = new T [col];\n            for (int j = 0; j < col; ++j)\n            {\n                matrix[i][j] = value[i * col + j];\n            }\n        }\n    }\n\n    Matrix (const Matrix<T> & matrix1)\n    {\n        row = matrix1.row;\n        col = matrix1.col;\n        matrix = new T*[row];\n        for (int i = 0; i < row; ++i)\n        {\n            matrix[i] = new T [col];\n            for (int j = 0; j < col; ++j)\n            {\n                matrix[i][j] = matrix1.matrix[i][j];\n            }\n        }\n    }\n\n    ~Matrix()\n    {\n        for (int i = 0; i < row; ++i)\n        {\n            if (matrix[i] != nullptr) delete [] matrix[i];\n        }\n        if (matrix != nullptr) delete [] matrix;\n    }\n\n    void print()\n    {\n        for (int i = 0; i < row; ++i)\n        {\n            for (int j = 0; j < col; ++j)\n            {\n                cout << \"    \" << matrix[i][j];\n            }\n            cout << endl;\n        }\n    }\n\n    T * operator [] (int n)\n    {\n        return matrix[n];\n    }\n\nprivate:\n    T **matrix;\n    int row;\n    int col;\n};",
            1590631402.8521338,
            100,
            "# 答案正确"
        ],
        [
            "7.1 (C++)",
            "杨宗恺",
            "#include <iostream>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\n\nclass Triangle : public GeometricObject\n{\npublic:\n    Triangle()\n    {\n        side1 = 1.0;\n        side2 = 1.0;\n        side3 = 1.0;\n    }\n\n    Triangle(double side1, double side2, double side3)\n    {\n        this -> side1 = side1;\n        this -> side2 = side2;\n        this -> side3 = side3;\n    }\n\n    double getSide1()\n    {\n        return side1;\n    }\n\n    double getSide2()\n    {\n        return side2;\n    }\n\n    double getSide3()\n    {\n        return side3;\n    }\n\n    double getArea()\n    {\n        double s = getPerimeter() / 2;\n        return sqrt(s * (s - side1) * (s - side2) * (s - side3));\n    }\n\n    double getPerimeter()\n    {\n        return side1 + side2 + side3;\n    }\n\nprivate:\n    double side1;\n    double side2;\n    double side3;\n};",
            1590719260.0353258,
            100,
            "# 答案正确"
        ],
        [
            "7.3 (C++)",
            "杨宗恺",
            "template <typename A, typename R>\nvector<R> map2(const vector<A> & x, const vector<A> & y, R (*add)(const A &, const A &))\n{\n    vector<R> res;\n    for (int i = 0; i < x.size(); ++ i)\n        res.push_back(add(x[i], y[i]));\n    return res;\n}\n\ntemplate <typename A, typename R>\nvector<R> map2(const vector<A> & x, A y, R (*add)(const A &, const A &))\n{\n    vector<R> res;\n    for (int i = 0; i < x.size(); ++ i)\n        res.push_back(add(x[i], y));\n    return res;\n}",
            1590746586.3139067,
            100,
            "# 答案正确"
        ],
        [
            "7.2 (C++)",
            "杨宗恺",
            "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nvector<string> split(const string & line)\n{\n    vector<string> words;\n    int st = 0;\n    while (st < line.size())\n    {\n        int end = line.find(\" \", st);\n        if (end == st) st += 1;\n        else\n        {\n            if (end == -1)\n            {\n                words.push_back(line.substr(st));\n                break;\n            }\n            words.push_back(line.substr(st, end - st));\n            st = end + 1;\n        }\n    }\n    return words;\n}",
            1591236772.6225739,
            100,
            "# 答案正确"
        ],
        [
            "8.1 (C++)",
            "杨宗恺",
            "#include <iostream>\n#include <string>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nclass Full : public Matrix\n{\npublic:\n    Full(int rows, int column)\n    {\n        this -> rows = rows;\n        this -> columns = column;\n        for (int i = 0; i < rows; ++i)\n        {\n            matrix.push_back(vector<double>());\n\t\t\t\tfor (int j = 0; j < columns; ++j)\n\t\t\t\t{\n\t\t\t\t\tmatrix[i].push_back(0);\n\t\t\t\t}\n        }\n    }\n\n    Full(int rows, int column, const double *value)\n    {\n        this -> rows = rows;\n        this -> columns = column;\n        for (int i = 0; i < rows; ++i)\n        {\n            matrix.push_back(vector<double>());\n            for (int j = 0; j < column; ++j)\n            {\n                matrix[i].push_back(value[i * column + j]);\n            }\n        }\n    }\n\n    Full (const Matrix & matrix2)\n    {\n        rows = matrix2.size(1);\n        columns = matrix2.size(2);\n        for (int i = 0; i < rows; ++i)\n        {\n            matrix.push_back(vector<double>());\n            for (int j = 0; j < columns; ++j)\n            {\n                matrix[i].push_back(matrix2.get(i, j));\n            }\n        }\n    }\n\n    ~Full(){}\n\n    int size(int dimension) const\n    {\n        if (dimension == 1) return rows;\n        if (dimension == 2) return columns;\n    }\n\n    void set(int row, int column, double value)\n    {\n        matrix[row][column] = value;\n    }\n\n    double get(int row, int column) const\n    {\n        return matrix[row][column];\n    }\n\n    void print() const\n    {\n        for (int i = 0; i < rows; ++i)\n        {\n            for (int j = 0; j < columns; ++j)\n            {\n                cout << \"    \" << matrix[i][j];\n            }\n            cout << endl;\n        }\n    }\n\n    Matrix & operator = (const Matrix & matrix2)\n    {\n        rows = matrix2.size(1);\n        columns = matrix2.size(2);\n        for (int i = 0; i < rows; ++i)\n        {\n            for (int j = 0; j < columns; ++j)\n            {\n                set(i , j, matrix2.get(i, j));\n            }\n        }\n        return *this;\n    }\n\nprivate:\n    int rows;\n    int columns;\n    vector<vector<double>> matrix;\n};",
            1591372377.441809,
            100,
            "# 答案正确"
        ],
        [
            "8.3 (C++)",
            "杨宗恺",
            "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Sparse : public Matrix\n{\npublic:\n    Sparse(int rows, int column)\n    {\n        this -> rows = rows;\n        this -> columns = column;\n    }\n\n    int size(int dimension) const\n    {\n        if (dimension == 1)\n            return rows;\n        if (dimension == 2)\n            return columns;\n    }\n\n    void set(int row, int column, double value)\n    {\n        if (get(row, column) != 0)\n        {\n            if (value != 0)\n            {\n                for (int i = 0; i < entry.size(); ++i)\n                {\n                    if (entry[i].row == row && entry[i].column == column)\n                    {\n                        entry[i].value = value;\n                        return;\n                    }\n                }\n            }\n            else\n            {\n                for (int i = 0; i < entry.size(); ++i)\n                {\n                    if(row == entry[i].row && column == entry[i].column)\n                    {\n                        entry.erase(entry.begin() + i);\n                        return;\n                    }\n                }\n            }\n        }\n        if (value == 0)\n            return;\n        Entry t;\n        t.row = row;\n        t.column = column;\n        t.value = value;\n        for (int i = 0; i < entry.size(); ++i)\n        {\n            if (row < entry[i].row || (row == entry[i].row && column < entry[i].column))\n            {\n                entry.insert(entry.begin() + i, t);\n                return;\n            }\n        }\n        entry.push_back(t);\n    }\n\n    double get(int row, int column) const\n    {\n        for (int i = 0; i < entry.size(); ++i)\n        {\n            if (entry[i].row == row && entry[i].column == column)\n            {\n                return entry[i].value;\n            }\n        }\n        return 0;\n    }\n\n    void print()\n    {\n        for (int i = 0; i < entry.size(); ++i)\n        {\n            cout << \"(\" << entry[i].row << \",\" << entry[i].column << \",\" << entry[i].value << \")\" << endl;\n        }\n    }\n\n    Sparse operator + (Sparse & sparse2);\n\nprivate:\n    vector<Entry> entry;\n    int rows;\n    int columns;\n};\n\nSparse Sparse::operator + (Sparse & sparse2)\n{\n    Sparse sparse3 = *this;\n    for (int i = 0; i < sparse2.entry.size(); ++i)\n    {\n        Entry t = sparse2.entry[i];\n        double val = sparse3.get(t.row, t.column);\n        sparse3.set(t.row, t.column, val + t.value);\n    }\n    return sparse3;\n}",
            1591431339.8703272,
            100,
            "# 答案正确"
        ],
        [
            "8.4 (C++)",
            "杨宗恺",
            "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Sparse : public Matrix\n{\npublic:\n    Sparse(int rows, int column)\n    {\n        this -> rows = rows;\n        this -> columns = column;\n    }\n\n    int size(int dimension) const\n    {\n        if (dimension == 1) return rows;\n        if (dimension == 2) return columns;\n    }\n\n\tvoid set(int row, int column, double value)\n\t{\n\t    if (get(row, column) != 0)\n        {\n            if (value != 0)\n            {\n                for (int i = 0; i < entry.size(); ++i)\n                {\n                    if (entry[i].row == row && entry[i].column == column)\n                    {\n                        entry[i].value = value;\n                        return;\n                    }\n                }\n            }\n            else\n            {\n                for (int i = 0; i < entry.size(); ++i)\n                {\n                    if(row == entry[i].row && column == entry[i].column)\n                    {\n                        entry.erase(entry.begin() + i);\n                        return;\n                    }\n                }\n            }\n        }\n        if (value == 0) return;\n        Entry t;\n        t.row = row;\n        t.column = column;\n        t.value = value;\n        for (int i = 0; i < entry.size(); ++i)\n        {\n            if (row < entry[i].row || (row == entry[i].row && column < entry[i].column))\n            {\n                entry.insert(entry.begin() + i, t);\n                return;\n            }\n        }\n        entry.push_back(t);\n\t}\n\n\tdouble get(int row, int column) const\n\t{\n\t    for (int i = 0; i < entry.size(); ++i)\n        {\n            if (entry[i].row == row && entry[i].column == column)\n            {\n                return entry[i].value;\n            }\n        }\n        return 0;\n\t}\n\n\tvoid print()\n\t{\n\t    for (int i = 0; i < entry.size(); ++i)\n        {\n            cout << \"(\" << entry[i].row << \",\" << entry[i].column << \",\" << entry[i].value << \")\" << endl;\n        }\n\t}\n\n\tSparse operator * (Sparse & sparse2);\n\nprivate:\n    vector<Entry> entry;\n    int rows;\n    int columns;\n};\n\nSparse Sparse::operator * (Sparse & sparse2)\n{\n    int rows = this -> rows;\n    int columns = sparse2.size(2);\n    Sparse sparse3(rows, columns);\n    for (int i = 0; i < entry.size(); ++i)\n    {\n        Entry t = entry[i];\n        for (int j = 0; j < sparse2.entry.size(); ++j)\n        {\n            Entry temp = sparse2.entry[j];\n            if (t.column == temp.row)\n            {\n                double val = sparse3.get(t.row, temp.column);\n                sparse3.set(t.row, temp.column, val + t.value * temp.value);\n            }\n        }\n    }\n    return sparse3;\n}",
            1591432524.994586,
            100,
            "# 答案正确"
        ],
        [
            "8.5 (C++)",
            "杨宗恺",
            "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nclass Point3D : public Point2D\n{\npublic:\n    Point3D()\n    {\n        setX(0);\n        setY(0);\n        z = 0;\n    }\n\n    Point3D(double x, double y, double z)\n    {\n        setX(x);\n        setY(y);\n        this -> z = z;\n    }\n\n    double getZ()\n    {\n        return z;\n    }\n\n    virtual double distance(Point2D & point2) override\n    {\n      \t  Point3D * p = dynamic_cast<Point3D *>(&point2);\n\t\t\tdouble dx = getX() - point2.getX();\n\t\t\tdouble dy = getY() - point2.getY();\n\t\t\tdouble dz = z - p -> getZ();\n\t\t\treturn sqrt(dx * dx + dy * dy + dz * dz);\n\t}\n\nprivate:\n    double z;\n};\n",
            1591844309.2359037,
            100,
            "# 答案正确"
        ],
        [
            "8.6 (C++)",
            "杨宗恺",
            "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass MyTensor : public Tensor<double>\n{\npublic:\n    MyTensor(vector<int> sizes) : Tensor<double>(sizes)\n    {\n        int size = 1;\n        for (int i = 0; i < sizes.size(); ++i)\n        {\n            size *= sizes[i];\n        }\n        matrix = new double[size];\n    }\n\n    ~MyTensor()\n    {\n        if (matrix != nullptr) delete [] matrix;\n    }\n\n    virtual double & get(const vector<int> & indexes) override\n    {\n        int index;\n        if (indexes.size() == 1) index = indexes[0];\n        else if (indexes.size() == 2)\n        {\n            index = indexes[0] * sizes[1] + indexes[1];\n        }\n        else if (indexes.size() == 3)\n        {\n            index = indexes[0] * sizes[1] * sizes[2] + indexes[1] * sizes[2] + indexes[2];\n        }\n        else if (indexes.size() == 4)\n        {\n            index = indexes[0] * sizes[1] * sizes[2] * sizes[3] + indexes[1] * sizes[2] * sizes[3]\n            + indexes[2] * sizes[3] + indexes[3];\n        }\n        return matrix[index];\n    }\n\nprivate:\n    double *matrix;\n};",
            1592449379.982213,
            100,
            "# 答案正确"
        ],
        [
            "9.1 (C++)",
            "杨宗恺",
            "#include <iostream>\n\nusing namespace std;\n\nclass Circle\n{\npublic:\n    Circle(double radius)\n    {\n        this -> radius = radius;\n    }\n\n    double get()\n    {\n        return radius;\n    }\n\n    bool operator < (Circle & c2)\n    {\n        return radius < c2.radius;\n    }\n\n    bool operator <= (Circle & c2)\n    {\n        return radius <= c2.radius;\n    }\n\n    bool operator == (Circle & c2)\n    {\n        return radius == c2.radius;\n    }\n\n    bool operator != (Circle & c2)\n    {\n        return radius != c2.radius;\n    }\n\n    bool operator > (Circle & c2)\n    {\n        return radius > c2.radius;\n    }\n\n    bool operator >= (Circle & c2)\n    {\n        return radius >= c2.radius;\n    }\n\nprivate:\n    double radius;\n};",
            1592534546.6075432,
            100,
            "# 答案正确"
        ],
        [
            "9.3 (C++)",
            "杨宗恺",
            "class Complex\n{\npublic:\n    Complex(double r, double i)\n    {\n        _real = r;\n        _imag = i;\n    }\n\n    double real()\n    {\n        return _real;\n    }\n\n    double imag()\n    {\n        return _imag;\n    }\n\n    Complex operator +(Complex & c2)\n    {\n        return Complex(_real + c2._real, _imag + c2._imag);\n    }\n\n    Complex operator -(Complex & c2)\n    {\n        return Complex(_real - c2._real, _imag - c2._imag);\n    }\n\n    Complex operator *(Complex & c2)\n    {\n        return Complex(_real * c2._real - _imag * c2._imag, _real * c2._imag + _imag * c2._real);\n    }\n\n    Complex operator /(Complex & c2)\n    {\n        return Complex((_real * c2._real + _imag * c2._imag) / (c2._real * c2._real + c2._imag * c2._imag),\n                       (_imag * c2._real - _real * c2._imag) / (c2._real * c2._real + c2._imag * c2._imag));\n    }\n\n    Complex operator -(double val)\n    {\n        return Complex(_real - val, _imag);\n    }\n\n    Complex & operator +=(Complex & c2)\n    {\n        _real += c2._real;\n        _imag += c2._imag;\n        return *this;\n    }\n\n    Complex & operator -=(Complex & c2)\n    {\n        _real -= c2._real;\n        _imag -= c2._imag;\n        return *this;\n    }\n\n    Complex & operator *=(Complex & c2)\n    {\n        double treal = _real * c2._real - _imag * c2._imag;\n        double timag = _real * c2._imag + _imag * c2._real;\n        _real = treal;\n        _imag = timag;\n        return *this;\n    }\n\n    Complex & operator /=(Complex & c2)\n    {\n        double treal = (_real * c2._real + _imag * c2._imag) / (c2._real * c2._real + c2._imag * c2._imag);\n        double timag = (_imag * c2._real - _real * c2._imag) / (c2._real * c2._real + c2._imag * c2._imag);\n        _real = treal;\n        _imag = timag;\n        return *this;\n    }\n\n    bool operator == (Complex & c2)\n    {\n        return _real == c2._real && _imag == c2._imag;\n    }\n\n    bool operator != (Complex & c2)\n    {\n        return _real != c2._real || _imag != c2._imag;\n    }\nprivate:\n    double _real;\n    double _imag;\n};\n\nComplex operator +(double val, Complex & c1)\n{\n    return Complex(c1.real() + val, c1.imag());\n}",
            1592552907.21817,
            100,
            "# 答案正确"
        ],
        [
            "9.4 (C++)",
            "杨宗恺",
            "#include <iostream>\n\nusing namespace std;\n\nclass Complex\n{\npublic:\n    Complex()\n    {\n        _real = 0;\n        _imag = 0;\n    }\n\n    Complex(double r, double i)\n    {\n        _real = r;\n        _imag = i;\n    }\n\n    friend istream & operator >> (istream & in, Complex & c)\n    {\n        double r, i;\n        in >> r >> i;\n        Complex t(r, i);\n        c = t;\n        return in;\n    }\n\n    friend ostream & operator << (ostream & out, Complex & c)\n    {\n        out << c._real << \" + \" << c._imag << \" i\";\n        return out;\n    }\n\n    double real()\n    {\n        return _real;\n    }\n\n    double imag()\n    {\n        return _imag;\n    }\n\n    Complex operator +(Complex & c2)\n    {\n        return Complex(_real + c2._real, _imag + c2._imag);\n    }\n\n    Complex operator -(Complex & c2)\n    {\n        return Complex(_real - c2._real, _imag - c2._imag);\n    }\n\nprivate:\n    double _real;\n    double _imag;\n};",
            1592547518.622086,
            100,
            "# 答案正确"
        ],
        [
            "9.2 (C++)",
            "杨宗恺",
            "class I\n{\npublic:\n    I(int i1, int i2=-1, int i3=-1, int i4=-1)\n    {\n        indexes.push_back(i1);\n        if (i2 != -1)\n            indexes.push_back(i2);\n        if (i3 != -1)\n            indexes.push_back(i3);\n        if (i4 != -1)\n            indexes.push_back(i4);\n    };\n\n    operator vector<int> ()\n    {\n        return indexes;\n    }\n\nprivate:\n    vector<int> indexes;\n};",
            1592554216.3822198,
            100,
            "# 答案正确"
        ],
        [
            "9.5 (C++)",
            "杨宗恺",
            "class Complex\n{\npublic:\n    Complex()\n    {\n        _real = 0;\n        _imag = 0;\n    }\n\n    Complex(double r, double i)\n    {\n        _real = r;\n        _imag = i;\n    }\n\n    friend istream & operator >> (istream & in, Complex & c)\n    {\n        double r, i;\n        in >> r >> i;\n        Complex t(r, i);\n        c = t;\n        return in;\n    }\n\n    friend ostream & operator << (ostream & out, const Complex & c)\n    {\n        out << c._real << \" + \" << c._imag << \" i\";\n        return out;\n    }\n\n    double real()\n    {\n        return _real;\n    }\n\n    double imag()\n    {\n        return _imag;\n    }\n\n    Complex operator ++(int)\n    {\n        Complex t = *this;\n        _real++;\n        return t;\n    }\n\n    Complex & operator ++()\n    {\n        _real++;\n        return *this;\n    }\n\n    operator double ()\n    {\n        return _real;\n    }\n\nprivate:\n    double _real;\n    double _imag;\n};",
            1592557086.0580778,
            100,
            "# 答案正确"
        ],
        [
            "9.6 (C++)",
            "杨宗恺",
            "class Tensor\n{\n    vector<int> sizes;\n    vector<double> values;\n\n    int _index(const vector<int> & indexes) const\n    {\n        int index = 0;\n        for (int i = 0; i < this->sizes.size(); ++ i)\n        {\n            index *= sizes[i];\n            index += indexes[i];\n        }\n        return index;\n    }\n\npublic:\n    Tensor(int i1, int i2=-1, int i3=-1, int i4=-1)\n    {\n        int n = i1;\n        sizes.push_back(i1);\n        if (i2 != -1)\n        {\n            sizes.push_back(i2);\n            n *= i2;\n        }\n        if (i3 != -1)\n        {\n            sizes.push_back(i3);\n            n *= i3;\n        }\n        if (i4 != -1)\n        {\n            sizes.push_back(i4);\n            n *= i4;\n        }\n        values.resize(n);\n    }\n\n    double & operator ()(int i1, int i2=-1, int i3=-1, int i4=-1)\n    {\n        vector<int> index;\n        index.push_back(i1);\n        if (i2 != -1)\n        {\n            index.push_back(i2);\n        }\n        if (i3 != -1)\n        {\n            index.push_back(i3);\n        }\n        if (i4 != -1)\n        {\n            index.push_back(i4);\n        }\n        int indexs = _index(index);\n        return values[indexs];\n    }\n\n    friend istream & operator >> (istream & in, double & d)\n    {\n        double val;\n        in >> val;\n        d = val;\n        return in;\n    }\n\n    friend ostream & operator << (ostream & out, const double & d)\n    {\n        out << d;\n        return out;\n    }\n};",
            1592558174.550223,
            100,
            "# 答案正确"
        ],
        [
            "9.7 (C++)",
            "杨宗恺",
            "class Tensor\n{\n    vector<int> sizes;\n    vector<double> values;\n\npublic:\n    Tensor() {}\n\n    Tensor(vector<int> the_sizes, vector<double> the_values)\n    {\n        sizes = the_sizes;\n        values = the_values;\n    }\n\n    int getsize(int dimension)\n    {\n        return sizes[dimension - 1];\n    }\n\n    int getdimension()\n    {\n        return sizes.size();\n    }\n\n    double getvalue(int n)\n    {\n        return values[n];\n    }\n\n    friend istream & operator >> (istream & in, Tensor & t)\n    {\n        int dimension;\n        in >> dimension;\n        vector<int> the_sizes;\n        vector<double> the_values;\n        int num;\n        double nmb;\n        int n = 1;\n        for (int i = 0; i < dimension; ++i)\n        {\n            in >> num;\n            the_sizes.push_back(num);\n            n *= num;\n        }\n        the_values.resize(n);\n        for (int i = 0; i < n; ++i)\n        {\n            in >> nmb;\n            the_values[i] = nmb;\n        }\n        Tensor temp(the_sizes, the_values);\n        t = temp;\n        return in;\n    }\n\n    friend ostream & operator << (ostream & out, Tensor & t)\n    {\n        int temp = 1;\n        int n = 0;\n        int dimension = t.getdimension();\n        int size1 = t.getsize(dimension);\n        int size2 = 1;\n        if(dimension >= 2) size2 = t.getsize(dimension - 1);\n        if(dimension == 3) temp = t.getsize(1);\n        if(dimension == 4) temp = t.getsize(1) * t.getsize(2);\n        out << dimension << endl;\n        for (int i = 1; i <= dimension; ++i)\n        {\n            out << t.getsize(i) << \" \";\n        }\n        out << endl << endl;\n        for (int i = 0; i < temp; ++i)\n        {\n            for (int j = 0; j < size2; ++j)\n            {\n                for(int k = 0; k < size1; ++k)\n                {\n                    out << t.getvalue(n) << \" \";\n                    n++;\n                }\n                out << endl;\n            }\n            out << endl;\n        }\n        return out;\n    }\n};",
            1592580994.9739156,
            100,
            "# 答案正确"
        ],
        [
            "10.1 (C++)",
            "杨宗恺",
            "#include <iostream>\n#include <vector>\n#include <stdexcept>\n\nusing namespace std;\n\nclass MatrixSizesDoNotMatchException {};\n\ndouble Matrix::get(int row, int column) const\n{\n    if (rows < row || columns < column) throw out_of_range(\"\");\n    else return elements[(row - 1) * columns + column - 1];\n}\n\nvoid Matrix::set(int row, int column, double value)\n{\n    if (rows < row || columns < column) throw out_of_range(\"\");\n    else elements[(row - 1) * columns + column - 1] = value;\n}\n\nMatrix Matrix::operator + (const Matrix & matrix2) const\n{\n    if (rows != matrix2.rows || columns != matrix2.columns) throw MatrixSizesDoNotMatchException();\n    else\n    {\n        Matrix t(rows, columns);\n        for (int i = 1; i <= rows; ++i)\n        {\n            for (int j = 1; j <= columns; ++j)\n            {\n                int temp = get(i, j) + matrix2.get(i, j);\n                t.set(i, j, temp);\n            }\n        }\n        return t;\n    }\n}",
            1593344299.0360742,
            100,
            "# 答案正确"
        ],
        [
            "10.2 (C++)",
            "杨宗恺",
            "catch (NonPositiveValueException & ex)\n{\n\tcout << \"caught: NonPositiveValueException\" << endl;\n}\ncatch (out_of_range & ex)\n{\n\tcout << \"caught: out_of_range\" << endl;\n}",
            1593655922.0677242,
            100,
            "# 答案正确"
        ],
        [
            "15.1 (C++)",
            "杨宗恺",
            "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nclass Table\n{\npublic:\n    Table()\n    {\n        rows.resize(1);\n    }\n\n    void addCol(string s)\n    {\n        headers.push_back(s);\n    }\n\n    vector<string> & operator [](int n)\n    {\n        vector<string> str;\n        if (rows.size() == n + 1) rows.push_back(str);\n        return rows[n];\n    }\n\n    string json() const\n    {\n        string s = \"\";\n        s += \"{\";\n        if (headers.size() != 0)\n        {\n            s += \"\\n\\t\";\n            s += \"headers: [\";\n            for (int i = 0; i < headers.size(); ++i)\n            {\n                s += \"'\" + headers[i] + \"',\";\n            }\n            s += \"],\\n\";\n        }\n        if (rows.size() > 1)\n        {\n            s += \"\\t\";\n            s += \"rows: [\\n\";\n            for (int i = 0; i < rows.size() - 1; ++i)\n            {\n                s += \"\\t\\t[\";\n                for (int j = 0; j < rows[i].size(); ++j)\n                {\n                    s += \"'\" + rows[i][j] + \"',\";\n                }\n                s += \"],\\n\";\n            }\n            s += \"\\t],\\n\";\n        }\n        s += \"}\";\n        return s;\n    }\n\nprivate:\n    vector<string> headers;\n    vector<vector<string>> rows;\n};",
            1593833431.9969084,
            100,
            "# 答案正确"
        ],
        [
            "2020-07-09 LAB",
            "杨宗恺",
            "#include <iostream>\n#include <fstream>\n\nusing namespace std;\n\nclass Integer\n{\npublic:\n    Integer()\n    {\n        num = 0;\n    }\n\n    Integer(int n)\n    {\n        num = n;\n    }\n\n    Integer operator = (int n)\n    {\n        return Integer(n);\n    }\n\n    friend istream & operator >> (istream & in, Integer & t)\n    {\n        int n;\n        in >> n;\n        t.num = n;\n        return in;\n    }\n\n    friend ostream & operator << (ostream & out, Integer & t)\n    {\n        out << t.num + add_num;\n        return out;\n    }\n\n    static void increase_all(int n)\n    {\n        add_num += n;\n    }\n\n    static void increase_all(Integer & t)\n    {\n        add_num += t.num + add_num;\n    }\n\nprivate:\n    int num;\n    static int add_num;\n};\n\nint Integer::add_num = 0;\n",
            1594263704.266158,
            100,
            "# 答案正确"
        ],
        [
            "A.1 (C++)",
            "杨宗恺",
            "\tvoid add(int index, const E & e)\n    {\n        if (index < 0 || index > _size) throw NotSuchElementException();\n        Node<E> * node = new Node<E>;\n        node -> element = e;\n        if (_size == 0)\n        {\n            head = node;\n            tail = node;\n            ++_size;\n            return;\n        }\n        Node<E> * prev_node = (index == 0 ? nullptr : get_node(index - 1));\n        Node<E> * next_node = (index == _size ? nullptr : get_node(index));\n        node -> update_prev_and_next_node(prev_node, next_node);\n        if (prev_node != nullptr) prev_node -> update_next_node(next_node, node);\n        if (next_node != nullptr) next_node -> update_prev_node(prev_node, node);\n        if (prev_node == nullptr) head = node;\n        if (next_node == nullptr) tail = node;\n        ++_size;\n    }\n\n    void addFirst(const E & e)\n    {\n        add(0, e);\n    }\n\n    void addLast(const E & e)\n    {\n\t\tadd(_size, e);\n    }\n\n    void remove(int index)\n    {\n        Node<E> * node = get_node(index);\n        if (_size == 1)\n        {\n            head = nullptr;\n            tail = nullptr;\n        }\n        else\n        {\n            Node<E> * prev_node = nullptr;\n            if (index != 0) prev_node = get_node(index - 1);\n            Node<E> * next_node = node -> next_node(prev_node);\n            if (prev_node != nullptr) prev_node -> update_next_node(node, next_node);\n            if (next_node != nullptr) next_node -> update_prev_node(node, prev_node);\n            if (prev_node == nullptr) head = next_node;\n            if (next_node == nullptr) tail = prev_node;\n        }\n        delete node;\n        --_size;\n    }\n\n    void removeFirst()\n    {\n\t\tremove(0);\n    }\n\n    void removeLast()\n    {\n        remove(_size - 1);\n    }\n\n    void removeFirstOccurrence(const E & e)\n    {\n        int index = indexOf(e);\n        if (index ==  -1) throw NotSuchElementException();\n        remove(index);\n    }\n\n    E & get(int index)\n    {\n        Node<E> * node = get_node(index);\n        return node -> element;\n    }\n\nprivate:\n    Node<E> * get_node(int index)\n    {\n        if (index < 0 || index >= _size) throw NotSuchElementException();\n        if (index < _size / 2)\n        {\n            Node<E> * prev_node = nullptr;\n            Node<E> * node = head;\n            I(i, index)\n            {\n                Node<E> * t = node;\n                node = node -> next_node(prev_node);\n                prev_node = t;\n            }\n            return node;\n        }\n        else\n        {\n            Node<E> * node = tail;\n            Node<E> * next_node = nullptr;\n            I(i, _size - 1 - index)\n            {\n                Node<E> * t = node;\n                node = node -> prev_node(next_node);\n                next_node = t;\n\n            }\n            return node;\n        }\n    }\n\n    int indexOf(const E & e)\n    {\n        Node<E> * prev_node = nullptr;\n        Node<E> * node = head;\n        I(i, _size)\n        {\n            if (node -> element == e) return i;\n            Node<E> * t = node;\n            node = node -> next_node(prev_node);\n            prev_node = t;\n        }\n        return -1;\n    }",
            1594826175.4142232,
            100,
            "# 答案正确"
        ],
        [
            "A.2 (C++)",
            "杨宗恺",
            "template<typename E>\nvoid LinkedList<E>::removeAll(const E & e)\n{\n    int index = indexOf(e);\n    while(index != -1)\n    {\n        remove(index);\n        index = indexOf(e);\n    }\n}",
            1594865373.5957286,
            100,
            "# 答案正确"
        ],
        [
            "A.4 (C++)",
            "杨宗恺",
            "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass NoSuchKeyException{};\n\nint circular_shift(int bits, int shift_bits) {\n\tconst int num_bits = sizeof(int);\n\tshift_bits = shift_bits % num_bits;\n\treturn bits << shift_bits | bits >> (num_bits - shift_bits);\n}\n\nint hash_function(const string & key) {\n\tint code = 0;\n\tfor (int i = 0; i < key.size(); ++i)\n\t\tcode ^= circular_shift(key[i], i * 5);\n\treturn code;\n}\n\nclass HT\n{\nprivate:\n    class Tuple\n    {\n    public:\n        int int_key;\n        string string_key;\n        int int_value;\n        string string_value;\n        bool in_use;\n\n        Tuple () : in_use(false){}\n\n        operator int ()\n        {\n            return int_value;\n        }\n\n        operator string()\n        {\n            return string_value;\n        }\n    };\n\n    vector<Tuple> tuples;\n    int _size;\n\n    int canonical_index(const int & key) const {\n        stringstream ss;\n        ss << key;\n        string s = \"\";\n        ss >> s;\n\t\tint hash_code = hash_function(s); // needs hash_function(K)\n\t\treturn hash_code % tuples.size();\n\t}\n\n    int canonical_index(const string & key) const {\n\t\tint hash_code = hash_function(key); // needs hash_function(K)\n\t\treturn hash_code % tuples.size();\n\t}\n\n    int indexofKey(const int & key) const\n    {\n        int index = canonical_index(key);\n        while(true)\n        {\n            if (!tuples[index].in_use) return index;\n            if (tuples[index].int_key == key) return index;\n            index = (index + 1) % tuples.size();\n        }\n    }\n\n    int indexofKey(const string & key) const\n    {\n        int index = canonical_index(key);\n        while(true)\n        {\n            if (!tuples[index].in_use) return index;\n            if (tuples[index].string_key == key) return index;\n            index = (index + 1) % tuples.size();\n        }\n    }\n\npublic:\n    HT() : _size(0)\n    {\n        tuples.resize(1000);\n    }\n\n    int size() const\n    {\n        return _size;\n    }\n\n    void put(const int & key, const int & value)\n    {\n        int index = indexofKey(key);\n        tuples[index].int_key = key;\n        tuples[index].int_value = value;\n        tuples[index].in_use = true;\n        stringstream ss;\n        ss << key;\n        ss >> tuples[index].string_key;\n        ss.clear();\n        ss << value;\n        ss >> tuples[index].string_value;\n        ++_size;\n    }\n\n    void put(const string & key, const int & value)\n    {\n        int index = indexofKey(key);\n        tuples[index].string_key = key;\n        tuples[index].int_value = value;\n        tuples[index].in_use = true;\n        stringstream ss;\n        ss << key;\n        ss >> tuples[index].int_key;\n        ss.clear();\n        ss << value;\n        ss >> tuples[index].string_value;\n        ++_size;\n    }\n\n    void put(const int & key, const string & value)\n    {\n        int index = indexofKey(key);\n        tuples[index].int_key = key;\n        tuples[index].string_value = value;\n        tuples[index].in_use = true;\n        stringstream ss;\n        ss << key;\n        ss >> tuples[index].string_key;\n        ss.clear();\n        ss << value;\n        ss >> tuples[index].int_value;\n        ++_size;\n    }\n\n    void put(const string & key, const string & value)\n    {\n        int index = indexofKey(key);\n        tuples[index].string_key = key;\n        tuples[index].string_value = value;\n        tuples[index].in_use = true;\n        stringstream ss;\n        ss << key;\n        ss >> tuples[index].int_key;\n        ss.clear();\n        ss << value;\n        ss >> tuples[index].int_value;\n        ++_size;\n    }\n\n    Tuple & operator [](int key)\n    {\n        int index = indexofKey(key);\n        if (!tuples[index].in_use) throw NoSuchKeyException();\n        return tuples[index];\n    }\n\n    Tuple & operator [](string key)\n    {\n        int index = indexofKey(key);\n        if (!tuples[index].in_use) throw NoSuchKeyException();\n        return tuples[index];\n    }\n};",
            1595172732.593135,
            100,
            "# 答案正确"
        ],
        [
            "A.5 (C++)",
            "杨宗恺",
            "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint circular_shift(int bits, int shift_bits) {\n\tconst int num_bits = 8 * sizeof(int);\n\tshift_bits = shift_bits % num_bits;\n\treturn bits << shift_bits | bits >> (num_bits - shift_bits);\n}\n\nint hash_function(const string & key) {\n\tint code = 0;\n\tfor (int i = 0; i < key.size(); ++i)\n\t\tcode ^= circular_shift(key[i], i * 5);\n\treturn code;\n}\n\nclass HT\n{\nprivate:\n    class Tuple\n    {\n    public:\n        int int_key;\n        string string_key;\n        int int_value;\n        string string_value;\n        bool in_use;\n\n        Tuple () : in_use(false){}\n\n        void operator = (int value)\n        {\n            int_value = value;\n            stringstream ss;\n            ss << int_value;\n            ss >> string_value;\n        }\n\n        void operator = (string value)\n        {\n            string_value = value;\n            stringstream ss;\n            ss << string_value;\n            ss >> int_value;\n        }\n\n        operator int ()\n        {\n            return int_value;\n        }\n\n        operator string()\n        {\n            return string_value;\n        }\n    };\n\n    vector<Tuple> tuples;\n    int _size;\n\n    int canonical_index(const int & key) const {\n        stringstream ss;\n        ss << key;\n        string s = \"\";\n        ss >> s;\n\t\tint hash_code = hash_function(s); // needs hash_function(K)\n\t\treturn hash_code % tuples.size();\n\t}\n\n    int canonical_index(const string & key) const {\n\t\tint hash_code = hash_function(key); // needs hash_function(K)\n\t\treturn hash_code % tuples.size();\n\t}\n\n    int indexofKey(const int & key) const\n    {\n        int index = canonical_index(key);\n        while(true)\n        {\n            if (!tuples[index].in_use) return index;\n            if (tuples[index].int_key == key) return index;\n            index = (index + 1) % tuples.size();\n        }\n    }\n\n    int indexofKey(const string & key) const\n    {\n        int index = canonical_index(key);\n        while(true)\n        {\n            if (!tuples[index].in_use) return index;\n            if (tuples[index].string_key == key) return index;\n            index = (index + 1) % tuples.size();\n        }\n    }\n\npublic:\n    HT() : _size(0)\n    {\n        tuples.resize(1000);\n    }\n\n    int size() const\n    {\n        return _size;\n    }\n\n    Tuple & operator [](int key)\n    {\n        int index = indexofKey(key);\n        if (!tuples[index].in_use)\n        {\n            tuples[index].int_key = key;\n            stringstream ss;\n            ss << key;\n            ss >> tuples[index].string_key;\n            tuples[index].in_use = true;\n            ++_size;\n        }\n        return tuples[index];\n    }\n\n    Tuple & operator [](string key)\n    {\n        int index = indexofKey(key);\n        if (!tuples[index].in_use)\n        {\n            tuples[index].string_key = key;\n            stringstream ss;\n            ss << key;\n            ss >> tuples[index].int_key;\n            tuples[index].in_use = true;\n            ++_size;\n        }\n        return tuples[index];\n    }\n};",
            1595173041.4364939,
            100,
            "# 答案正确"
        ],
        [
            "A.3 (C++)",
            "杨宗恺",
            "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <stdexcept>\nusing namespace std;\n\n#define I(i,n) for (int i = 0; i < n; ++ i)\n\nclass NoSuchKeyException {};\n\nint circular_shift(int bits, int shift_bits) {\n\tconst int num_bits = 8 * sizeof(int);\n\tshift_bits = shift_bits % num_bits;\n\treturn bits << shift_bits | bits >> (num_bits - shift_bits);\n}\n\nint hash_function(const int & key) {\n\tint code = 0;\n    code ^= circular_shift(key, 5);\n\treturn code;\n}\n\ntemplate <typename V>\nclass HT\n{\n\tclass Tuple\n\t{\n\tpublic:\n\t\tint key;\n\t\tV val;\n\t\tbool in_use;\n\n\t\tTuple() : in_use(false) {}\n\t};\n\n\tvector<Tuple> tuples;\n\tint _size;\n\n\tint canonical_index(const int & key) const {\n\t\tint hash_code = hash_function(key); // needs hash_function(K)\n\t\treturn hash_code % tuples.size();\n\t}\n\n\t// the returned tuple is either empty or with the same key\n\tint indexOfKey(const int & key) const {\n\t\tint index = canonical_index(key);\n\t\twhile (true) { // will enter a dead loop if there is not empty tuple\n\t\t\tif (! tuples[index].in_use) return index;\n\t\t\tif (tuples[index].key == key) return index;\n\t\t\tindex = (index + 1) % tuples.size();\n\t\t}\n\t}\n\npublic:\n\tHT() : _size(0) {\n\t\ttuples.resize(5000);\n\t}\n\n\tbool containsKey(const int & key) const {\n\t\tint index = indexOfKey(key);\n\t\treturn tuples[index].in_use;\n\t}\n\n\tconst V & operator [] (const int & key) const {\n\t\tint index = indexOfKey(key);\n\t\tif (! tuples[index].in_use)\n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples[index].val;\n\t}\n\n\tV & operator [] (const int & key) {\n\t\tint index = indexOfKey(key);\n\t\tif (! tuples[index].in_use)\n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples[index].val;\n\t}\n\n\tvoid put(const int & key, const V & val) {\n\t\tint index = indexOfKey(key);\n\t\ttuples[index].key = key;\n\t\ttuples[index].val = val;\n\t\tif (tuples[index].in_use) return;\n\t\ttuples[index].in_use = true;\n\t\t++ _size;\n\t\t// make sure empty > size / 2\n\t\tif (2 * _size > tuples.size())\n\t\t\t_double_tuples();\n\t}\n\n\tvoid _double_tuples() {\n\t\tvector<Tuple> non_empty_tuples;\n\t\tI(i, tuples.size())\n\t\t\tif (tuples[i].in_use)\n\t\t\t\tnon_empty_tuples.push_back(tuples[i]);\n\t\tclear();\n\t\ttuples.resize(tuples.size() * 2);\n\t\tI(i, non_empty_tuples.size())\n\t\t\tput(non_empty_tuples[i].key, non_empty_tuples[i].val);\n\t}\n\n\tstatic bool _between(int hole, int canonical, int tuple_index) {\n\t\tif (hole < tuple_index)\n\t\t\treturn canonical > hole && canonical <= tuple_index;\n\t\telse\n\t\t\treturn canonical > hole || canonical <= tuple_index;\n\t}\n\n\tvoid remove(const int & key) {\n\t\tint index = indexOfKey(key);\n\t\tif (! tuples[index].in_use)\n\t\t\tthrow NoSuchKeyException();\n\t\ttuples[index].in_use = false;\n\t\t-- _size;\n\t\t// if there is a hole between a tuple and its canonical position\n\t\t// move the tuple to the hole\n\t\tint hole = index;\n\t\tint tuple_index = hole;\n\t\twhile (true) {\n\t\t\ttuple_index = (tuple_index + 1) % tuples.size();\n\t\t\tif (! tuples[tuple_index].in_use) return;\n\t\t\tint canonical = canonical_index(tuples[tuple_index].key);\n\t\t\tif (_between(hole, canonical, tuple_index)) continue;\n\t\t\ttuples[hole] = tuples[tuple_index];\n\t\t\thole = tuple_index;\n\t\t\ttuples[hole].in_use = false;\n\t\t}\n\t}\n\n\tint size() const { return _size; }\n\n\tvoid clear() {\n\t\tI(i, tuples.size())\n\t\t\ttuples[i].in_use = false;\n\t\t_size = 0;\n\t}\n\n\tvector<int> getKeys()\n\t{\n\t    vector<int> keys;\n\t    for (int i = 0; i < tuples.size(); ++i)\n        {\n            if (tuples[i].in_use == true) keys.push_back(tuples[i].key);\n        }\n        return keys;\n\t}\n};",
            1595470470.8261373,
            100,
            "# 答案正确"
        ]
    ],
    "table_name": "答案"
}