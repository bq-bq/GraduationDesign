{
    "__update_time__": 1595472133.3141026,
    "field_names": [
        "题目名",
        "用户名",
        "答案",
        "提交时间",
        "分数",
        "评语"
    ],
    "field_types": [
        "text",
        "text",
        "text",
        "time",
        "number",
        "text"
    ],
    "foreign_keys": {},
    "primary_keys": [],
    "rows": [
        [
            "测试1",
            "谭鸿鑫",
            "#include <iostream>\nusing namespace std;\n\nint main() {\n\tstring s1, s2, s3;\n\tcin >> s1 >> s2 >> s3;\n\tcout << s3 << ' ' << s2 << ' ' << s1;\n}",
            1587523022.5621154,
            100,
            "# 答案正确"
        ],
        [
            "测试2",
            "谭鸿鑫",
            "#include <iostream>\n#include<string>\nusing namespace std;\n\nint main(){\n\tstring word[10];\n\tfor(int i = 0;i < 10;i ++){\n\t\tcin >> word[i];\n\t}\n\tfor(int i = 0;i < 10;i ++){\n\t\tfor(int j = 0;j < 9 - i;j ++){\n\t\t\tif(word[j] > word[j+1]){\n\t\t\t\tstring tem = word[j + 1];\n\t\t\t\tword[j + 1] = word[j];\n\t\t\t\tword[j] = tem;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0;i < 10;i ++){\n\t\tcout << word[i] << ' ';\n\t}\n}",
            1587608629.1439698,
            100,
            "# 答案正确"
        ],
        [
            "1.1 (C++)",
            "谭鸿鑫",
            "class Matrix5x5{\n\tpublic:\n\tdouble value[5][5];\n\tdouble get(int a, int b){\n\t\treturn this->value[a][b];\n\t}\n\tvoid set(int a, int b, double x){\n\t\tthis->value[a][b] = x;\n\t}\n\tMatrix5x5(){\n\t\tfor (int i = 0; i < 5; ++ i){\n\t\t\tfor(int j = 0;j < 5;j ++){\n\t\t\t\tvalue[i][j] = 0;\n\t\t\t}\n\t\t} \n\t}\n\tMatrix5x5 operator + (Matrix5x5 & b){\n\t\tfor (int i = 0; i < 5; ++ i){\n\t\t\tfor(int j = 0;j < 5;j ++){\n\t\t\t\tthis->value[i][j] += b.value[i][j];\n\t\t\t}\n\t\t} \n\t\treturn *this;\n\t}\n};",
            1587696567.4514828,
            100,
            "# 答案正确"
        ],
        [
            "1.2 (C++)",
            "谭鸿鑫",
            "#include <string>\nusing namespace std;\n\nclass School{\n\tpublic:\n\tstring name;\n\tint age;\n\tSchool(){\n\t\tname = \"NO_NAME\";\n\t\tage = 0;\n\t}\n\tvoid setName(char x[]){\n\t\tthis->name = x;\n\t}\n\tvoid setAge(int x){\n\t\tthis->age = x;\n\t}\n\tSchool operator ++(){\n\t\tthis->age ++;\n\t\treturn *this;\n\t}\n};",
            1588213520.4748733,
            100,
            "# 答案正确"
        ],
        [
            "2.1 (C++)",
            "谭鸿鑫",
            "#include<iostream>\nusing namespace std;\n\nclass Matrix{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tMatrix(int x, int y){\n\t\trows = x;\n\t\tcolumns = y;\n\t\tvalues = (double*)new double[x * y];\n        int i;\n        for(i = 0;i < x*y;i ++){\n            values[i] = 0;\n        }\n\t}\n    ~Matrix(){\n        delete [] values;\n    }\n    void print(){\n        int i;\n        for(i = 0;i < rows*columns;i ++){\n            cout << values[i];\n            if((i+1) % columns == 0){\n                cout << endl;\n            }\n            else{\n                cout << \"    \";\n            }\n        }\n    }\n};",
            1588861626.4109752,
            100,
            "# 答案正确"
        ],
        [
            "2.2 (C++)",
            "谭鸿鑫",
            "#include<iostream>\nusing namespace std;\n\nclass Matrix{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tMatrix(int x, int y){\n\t\trows = x;\n\t\tcolumns = y;\n\t\tvalues = (double*)new double[x * y];\n        int i;\n        for(i = 0;i < x*y;i ++){\n            values[i] = 0;\n        }\n\t}Matrix(int x, int y, double n[]){\n\t\trows = x;\n\t\tcolumns = y;\n\t\tvalues = (double*)new double[x * y];\n        int i;\n        for(i = 0;i < x*y;i ++){\n            values[i] = n[i];\n        }\n\t}\n    ~Matrix(){\n        delete [] values;\n    }\n    void print(){\n        int i;\n        for(i = 0;i < rows*columns;i ++){\n            cout.width(5);\n            cout << values[i];\n            if((i+1) % columns == 0){\n                cout << endl;\n            }\n        }\n    }\n};",
            1588861980.561752,
            100,
            "# 答案正确"
        ],
        [
            "2.3 (C++)",
            "谭鸿鑫",
            "#include<iostream>\nusing namespace std;\n\nclass Matrix{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tMatrix(int x, int y){\n\t\trows = x;\n\t\tcolumns = y;\n\t\tvalues = (double*)new double[x * y];\n        int i;\n        for(i = 0;i < x*y;i ++){\n            values[i] = 0;\n        }\n\t}\n    Matrix(int x, int y, double n[]){\n\t\trows = x;\n\t\tcolumns = y;\n\t\tvalues = (double*)new double[x * y];\n        int i;\n        for(i = 0;i < x*y;i ++){\n            values[i] = n[i];\n        }\n\t}\n    Matrix(Matrix & x){\n        this->rows = x.rows;\n        this->columns = x.columns;\n        values = (double*)new double[x.rows * x.columns];\n        int i;\n        for(i = 0;i < x.rows * x.columns;i ++){\n            values[i] = x.values[i];\n        }\n    }\n    ~Matrix(){\n        delete [] values;\n    }\n    void print(){\n        int i;\n        for(i = 0;i < rows*columns;i ++){\n            cout << \"    \";\n            cout << values[i];\n            if((i+1) % columns == 0){\n                cout << endl;\n            }\n        }\n    }\n};",
            1588862340.0954592,
            100,
            "# 答案正确"
        ],
        [
            "2.5 (C++)",
            "谭鸿鑫",
            "#include<iostream>\nusing namespace std;\n\nclass Matrix{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tMatrix(int x, int y){\n\t\trows = x;\n\t\tcolumns = y;\n\t\tvalues = (double*)new double[x * y];\n        int i;\n        for(i = 0;i < x*y;i ++){\n            values[i] = 0;\n        }\n\t}\n    Matrix(int x, int y, double n[]){\n\t\trows = x;\n\t\tcolumns = y;\n\t\tvalues = (double*)new double[x * y];\n        int i;\n        for(i = 0;i < x*y;i ++){\n            values[i] = n[i];\n        }\n\t}\n    Matrix(Matrix & x){\n        this->rows = x.rows;\n        this->columns = x.columns;\n        values = (double*)new double[x.rows * x.columns];\n        int i;\n        for(i = 0;i < x.rows * x.columns;i ++){\n            values[i] = x.values[i];\n        }\n    }\n    ~Matrix(){\n        delete [] values;\n    }\n    void print(){\n        int i;\n        for(i = 0;i < rows*columns;i ++){\n            cout << \"    \";\n            cout << values[i];\n            if((i+1) % columns == 0){\n                cout << endl;\n            }\n        }\n    }\n    Matrix getRow(int x){\n        Matrix res(1, columns);\n        int i;\n        for(i = 0;i < columns;i ++){\n            res.values[i] = this->values[i + columns*(x-1)];\n        }\n        return res;\n    }\n    Matrix getColumn(int x){\n        Matrix res(rows, 1);\n        int i;\n        for(i = 0;i < rows;i ++){\n            res.values[i] = this->values[i * rows + x - 1];\n        }\n        return res;\n    }\n};",
            1588862948.3557708,
            100,
            "# 答案正确"
        ],
        [
            "2.6 (C++)",
            "谭鸿鑫",
            "#include<iostream>\nusing namespace std;\n\nclass Matrix{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tMatrix(int x, int y){\n\t\trows = x;\n\t\tcolumns = y;\n\t\tvalues = (double*)new double[x * y];\n        int i;\n        for(i = 0;i < x*y;i ++){\n            values[i] = 0;\n        }\n\t}\n    Matrix(int x, int y, double n[]){\n\t\trows = x;\n\t\tcolumns = y;\n\t\tvalues = (double*)new double[x * y];\n        int i;\n        for(i = 0;i < x*y;i ++){\n            values[i] = n[i];\n        }\n\t}\n    Matrix(const Matrix & x){\n        this->rows = x.rows;\n        this->columns = x.columns;\n        values = (double*)new double[x.rows * x.columns];\n        int i;\n        for(i = 0;i < x.rows * x.columns;i ++){\n            values[i] = x.values[i];\n        }\n    }\n    ~Matrix(){\n        delete [] values;\n    }\n    void print(){\n        int i;\n        for(i = 0;i < rows*columns;i ++){\n            cout << \"    \";\n            cout << values[i];\n            if((i+1) % columns == 0){\n                cout << endl;\n            }\n        }\n    }\n    Matrix getRow(int x){\n        Matrix res(1, columns);\n        int i;\n        for(i = 0;i < columns;i ++){\n            res.values[i] = this->values[i + columns*(x-1)];\n        }\n        return res;\n    }\n    Matrix getColumn(int x){\n        Matrix res(rows, 1);\n        int i;\n        for(i = 0;i < rows;i ++){\n            res.values[i] = this->values[i * rows + x - 1];\n        }\n        return res;\n    }\n    Matrix concatenateRows(const Matrix & x) const{\n        Matrix res(rows+x.rows, columns);\n        int i;\n        for(i = 0;i < rows*columns;i ++){\n            res.values[i] = this->values[i];\n        }\n        for(i = 0;i < x.rows*x.columns;i ++){\n            res.values[i + rows*columns] = x.values[i];\n        }\n\t\t  return res;\n    }\n    Matrix concatenateColumns(const Matrix & x) const{\n        Matrix res(rows, columns + x.columns);\n        int i,j;\n        for(i = 0;i < rows;i ++){\n            for(j = 0;j < columns;j ++){\n                res.values[i*res.columns + j] = this->values[i*this->columns + j];\n            }\n        }\n        for(i = 0;i < rows;i ++){\n            for(j = 0;j < columns;j ++){\n                res.values[i*res.columns + j + this->columns] = x.values[i * x.columns + j];\n            }\n        }\n\t\t  return res;\n    }\n};",
            1588864747.788779,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/08",
            "谭鸿鑫",
            "double & Tensor_get(int dimensions, const int sizes[], double data[], int x0, int x1, int x2, int x3){\n\tint res;\n\tif(dimensions == 1) res = x0;\n\telse if(dimensions == 2) res = x0 * sizes[1] + x1;\n\telse if(dimensions == 3) res = x0 * sizes[1]*sizes[2] + x1 * sizes[2] + x2;\n\telse if(dimensions == 4) res = x0 * sizes[1]*sizes[2]*sizes[3] + x1 * sizes[2]*sizes[3] + x2 * sizes[3] + x3;\n\treturn data[res];\n}",
            1588904801.1148174,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/14",
            "谭鸿鑫",
            "#include <iostream>\nusing namespace std;\n\nvoid Tensor_print(int dimensions, const int sizes[], const double data[]){\n\tif(dimensions == 1){\n\t\tcout << \"Tensor of \" << sizes[0] << endl;\n\t\tfor(int i = 0;i < sizes[0];i ++){\n\t\t\tcout << data[i] << endl;\n\t\t}\n\t}\n\telse if(dimensions == 2){\n\t\tcout << \"Tensor of \" << sizes[0] << 'x' << sizes[1] << endl;\n\t\tfor(int i = 0;i < sizes[0];i ++){\n\t\t\tfor(int j = 0;j < sizes[1];j ++){\n\t\t\t\tcout << \"    \" << data[i*sizes[1] + j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\telse if(dimensions == 3){\n\t\tcout << \"Tensor of \" << sizes[0] << 'x' << sizes[1] << 'x' << sizes[2] << endl;\n\t\tfor(int i = 0;i < sizes[0];i ++){\n\t\t\tcout << \"data[\" << i << ']' << endl;\n\t\t\tfor(int j = 0;j < sizes[1];j ++){\n\t\t\t\tfor(int k = 0;k < sizes[2];k ++){\n\t\t\t\t\tcout << \"    \" << data[i*sizes[1]*sizes[2] + j*sizes[2] + k];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t}\n\telse if(dimensions == 4){\n\t\tcout << \"Tensor of \" << sizes[0] << 'x' << sizes[1] << 'x' << sizes[2] << 'x' << sizes[3] << endl;\n\t\tfor(int i = 0;i < sizes[0];i ++){\n\t\t\tfor(int j = 0;j < sizes[1];j ++){\n\t\t\t\tcout << \"data[\" << i << ']' << '[' << j << ']' << endl;\n\t\t\t\tfor(int k = 0;k < sizes[2];k ++){\n\t\t\t\t\tfor(int l = 0;l < sizes[3];l ++){\n\t\t\t\t\t\tcout << \"    \" << data[i*sizes[1]*sizes[2]*sizes[3] + j*sizes[2]*sizes[3] + k*sizes[3] + l];\n\t\t\t\t\t}\n\t\t\t\t\tcout << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
            1589424715.6738098,
            100,
            "# 答案正确"
        ],
        [
            "2.4 (C++)",
            "谭鸿鑫",
            "#include<iostream>\nusing namespace std;\n\nclass Matrix{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tMatrix(int x, int y){\n\t\trows = x;\n\t\tcolumns = y;\n\t\tvalues = (double*)new double[x * y];\n        int i;\n        for(i = 0;i < x*y;i ++){\n            values[i] = 0;\n        }\n\t}\n    Matrix(int x, int y, double n[]){\n\t\trows = x;\n\t\tcolumns = y;\n\t\tvalues = (double*)new double[x * y];\n        int i;\n        for(i = 0;i < x*y;i ++){\n            values[i] = n[i];\n        }\n\t}\n    Matrix(const Matrix & x){\n        this->rows = x.rows;\n        this->columns = x.columns;\n        values = (double*)new double[x.rows * x.columns];\n        int i;\n        for(i = 0;i < x.rows * x.columns;i ++){\n            values[i] = x.values[i];\n        }\n    }\n    Matrix & operator = (const Matrix & a){\n        rows = a.rows;\n        columns = a.columns;\n        delete [] values;\n        values = (double*)new double[rows * columns];\n        int i;\n        for(i = 0;i < rows * columns;i ++){\n            values[i] = a.values[i];\n        }\n    }\n    ~Matrix(){\n        delete [] values;\n    }\n    void print(){\n        int i;\n        for(i = 0;i < rows*columns;i ++){\n            cout << \"    \";\n            cout << values[i];\n            if((i+1) % columns == 0){\n                cout << endl;\n            }\n        }\n    }\n    void set(int x, int y, double n){\n        values[(x-1) * columns + y - 1] = n;\n    }\n};\n",
            1589512395.9035008,
            100,
            "# 答案正确"
        ],
        [
            "2.7 (C++)",
            "谭鸿鑫",
            "#include<iostream>\nusing namespace std;\n\nclass Matrix{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tMatrix(int x, int y){\n\t\trows = x;\n\t\tcolumns = y;\n\t\tvalues = (double*)new double[x * y];\n        int i;\n        for(i = 0;i < x*y;i ++){\n            values[i] = 0;\n        }\n\t}\n    Matrix(int x, int y, double n[]){\n\t\trows = x;\n\t\tcolumns = y;\n\t\tvalues = (double*)new double[x * y];\n        int i;\n        for(i = 0;i < x*y;i ++){\n            values[i] = n[i];\n        }\n\t}\n    Matrix(const Matrix & x){\n        this->rows = x.rows;\n        this->columns = x.columns;\n        values = (double*)new double[x.rows * x.columns];\n        int i;\n        for(i = 0;i < x.rows * x.columns;i ++){\n            values[i] = x.values[i];\n        }\n    }\n    Matrix & operator = (const Matrix & a){\n        rows = a.rows;\n        columns = a.columns;\n        delete [] values;\n        values = (double*)new double[rows * columns];\n        int i;\n        for(i = 0;i < rows * columns;i ++){\n            values[i] = a.values[i];\n        }\n    }\n    ~Matrix(){\n        delete [] values;\n    }\n    void print(){\n        int i;\n        for(i = 0;i < rows*columns;i ++){\n            cout << \"    \";\n            cout << values[i];\n            if((i+1) % columns == 0){\n                cout << endl;\n            }\n        }\n    }\n    void set(int x, int y, double n){\n        values[(x-1) * columns + y - 1] = n;\n    }\n\n    Matrix reshape(int x, int y) const{\n        Matrix res(x,y);\n        int i,j;\n        int a = 1, b = 1;\n        for(i = 1;i <= y;i ++){\n            for(j = 1;j <= x;j ++){\n                res.set(j, i, values[(a-1) * columns + b - 1]);\n                a ++;\n                if(a > rows){\n                    a = 1;\n                    b ++;\n                }\n            }\n        }\n        return res;\n    }\n\n};",
            1589513455.2600067,
            100,
            "# 答案正确"
        ],
        [
            "2.8 (C++)",
            "谭鸿鑫",
            "#include<iostream>\nusing namespace std;\n\nclass Matrix{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tMatrix(int x, int y){\n\t\trows = x;\n\t\tcolumns = y;\n\t\tvalues = (double*)new double[x * y];\n        int i;\n        for(i = 0;i < x*y;i ++){\n            values[i] = 0;\n        }\n\t}\n    Matrix(int x, int y, double n[]){\n\t\trows = x;\n\t\tcolumns = y;\n\t\tvalues = (double*)new double[x * y];\n        int i;\n        for(i = 0;i < x*y;i ++){\n            values[i] = n[i];\n        }\n\t}\n    Matrix(const Matrix & x){\n        this->rows = x.rows;\n        this->columns = x.columns;\n        values = (double*)new double[x.rows * x.columns];\n        int i;\n        for(i = 0;i < x.rows * x.columns;i ++){\n            values[i] = x.values[i];\n        }\n    }\n    Matrix & operator = (const Matrix & a){\n        rows = a.rows;\n        columns = a.columns;\n        delete [] values;\n        values = (double*)new double[rows * columns];\n        int i;\n        for(i = 0;i < rows * columns;i ++){\n            values[i] = a.values[i];\n        }\n    }\n    ~Matrix(){\n        delete [] values;\n    }\n    void print(){\n        int i;\n        for(i = 0;i < rows*columns;i ++){\n            cout << \"    \";\n            cout << values[i];\n            if((i+1) % columns == 0){\n                cout << endl;\n            }\n        }\n    }\n    void set(int x, int y, double n){\n        values[(x-1) * columns + y - 1] = n;\n    }\n\n    Matrix reshape(int x, int y) const{\n        Matrix res(x,y);\n        int i,j;\n        int a = 1, b = 1;\n        for(i = 1;i <= y;i ++){\n            for(j = 1;j <= x;j ++){\n                res.set(j, i, values[(a-1) * columns + b - 1]);\n                a ++;\n                if(a > rows){\n                    a = 1;\n                    b ++;\n                }\n            }\n        }\n        return res;\n    }\n\n    Matrix transpose(){\n        Matrix res(columns, rows);\n        int i,j;\n        int a = 1, b = 1;\n        for(i = 1;i <= rows;i ++){\n            for(j = 1;j <= columns;j ++){\n                res.set(j, i, values[(a-1) * columns + b - 1]);\n                b ++;\n                if(b > columns){\n                    b = 1;\n                    a ++;\n                }\n            }\n        }\n        return res;\n    }\n\n    \n};",
            1589513728.6713216,
            100,
            "# 答案正确"
        ],
        [
            "2.11 (C++)",
            "谭鸿鑫",
            "#include<iostream>\nusing namespace std;\n\nclass Matrix{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tMatrix(int x, int y){\n\t\trows = x;\n\t\tcolumns = y;\n\t\tvalues = (double*)new double[x * y];\n        int i;\n        for(i = 0;i < x*y;i ++){\n            values[i] = 0;\n        }\n\t}\n    Matrix(int x, int y, double n[]){\n\t\trows = x;\n\t\tcolumns = y;\n\t\tvalues = (double*)new double[x * y];\n        int i;\n        for(i = 0;i < x*y;i ++){\n            values[i] = n[i];\n        }\n\t}\n    Matrix(const Matrix & x){\n        this->rows = x.rows;\n        this->columns = x.columns;\n        values = (double*)new double[x.rows * x.columns];\n        int i;\n        for(i = 0;i < x.rows * x.columns;i ++){\n            values[i] = x.values[i];\n        }\n    }\n    Matrix & operator = (const Matrix & a){\n        rows = a.rows;\n        columns = a.columns;\n        delete [] values;\n        values = (double*)new double[rows * columns];\n        int i;\n        for(i = 0;i < rows * columns;i ++){\n            values[i] = a.values[i];\n        }\n    }\n    ~Matrix(){\n        delete [] values;\n    }\n    void print(){\n        int i;\n        for(i = 0;i < rows*columns;i ++){\n            cout << \"    \";\n            cout << values[i];\n            if((i+1) % columns == 0){\n                cout << endl;\n            }\n        }\n    }\n    void set(int x, int y, double n){\n        values[(x-1) * columns + y - 1] = n;\n    }\n\n    Matrix reshape(int x, int y) const{\n        Matrix res(x,y);\n        int i,j;\n        int a = 1, b = 1;\n        for(i = 1;i <= y;i ++){\n            for(j = 1;j <= x;j ++){\n                res.set(j, i, values[(a-1) * columns + b - 1]);\n                a ++;\n                if(a > rows){\n                    a = 1;\n                    b ++;\n                }\n            }\n        }\n        return res;\n    }\n\n    Matrix transpose(){\n        Matrix res(columns, rows);\n        int i,j;\n        int a = 1, b = 1;\n        for(i = 1;i <= rows;i ++){\n            for(j = 1;j <= columns;j ++){\n                res.set(j, i, values[(a-1) * columns + b - 1]);\n                b ++;\n                if(b > columns){\n                    b = 1;\n                    a ++;\n                }\n            }\n        }\n        return res;\n    }\n\n    Matrix getRow(int x){\n        Matrix res(1, columns);\n        int i;\n        for(i = 0;i < columns;i ++){\n            res.values[i] = this->values[i + columns*(x-1)];\n        }\n        return res;\n    }\n    Matrix getColumn(int x){\n        Matrix res(rows, 1);\n        int i;\n        for(i = 0;i < rows;i ++){\n            res.values[i] = this->values[i * rows + x - 1];\n        }\n        return res;\n    }\n\n    Matrix max() const{\n        if(rows == 1){\n            double ma = 0;\n            int i;\n            for(i = 0;i < columns;i ++){\n                if(values[i] > ma) ma = values[i];\n            }\n            Matrix res(1,1);\n            res.values[0] = ma;\n            return res;\n        }\n        else{\n            int i,j;\n            Matrix res(1, columns);\n            for(i = 0;i < columns;i ++){\n                double ma = 0;\n                for(j = 0;j < rows;j ++){\n                    if(values[i + columns*j] > ma) ma = values[i + columns*j];\n                }\n                res.values[i] = ma;\n            }\n            return res;\n        }\n    }\n\n    Matrix min() const{\n        if(rows == 1){\n            double ma = 999;\n            int i;\n            for(i = 0;i < columns;i ++){\n                if(values[i] < ma) ma = values[i];\n            }\n            Matrix res(1,1);\n            res.values[0] = ma;\n            return res;\n        }\n        else{\n            int i,j;\n            Matrix res(1, columns);\n            for(i = 0;i < columns;i ++){\n                double ma = 999;\n                for(j = 0;j < rows;j ++){\n                    if(values[i + columns*j] < ma) ma = values[i + columns*j];\n                }\n                res.values[i] = ma;\n            }\n            return res;\n        }\n    }\n\n    Matrix sum() const{\n        if(rows == 1){\n            double ressum = 0;\n            int i;\n            for(i = 0;i < columns;i ++){\n                ressum += values[i];\n            }\n            Matrix res(1,1);\n            res.values[0] = ressum;\n            return res;\n        }\n        else{\n            int i,j;\n            Matrix res(1, columns);\n            for(i = 0;i < columns;i ++){\n                for(j = 0;j < rows;j ++){\n                    res.values[i] += values[i + columns*j];\n                }\n            }\n            return res;\n        }\n    }\n\n};",
            1589515179.6946504,
            100,
            "# 答案正确"
        ],
        [
            "2.10 (C++)",
            "谭鸿鑫",
            "#include<iostream>\nusing namespace std;\n\nclass Matrix{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tMatrix(int x, int y){\n\t\trows = x;\n\t\tcolumns = y;\n\t\tvalues = (double*)new double[x * y];\n        int i;\n        for(i = 0;i < x*y;i ++){\n            values[i] = 0;\n        }\n\t}\n    Matrix(int x, int y, double n[]){\n\t\trows = x;\n\t\tcolumns = y;\n\t\tvalues = (double*)new double[x * y];\n        int i;\n        for(i = 0;i < x*y;i ++){\n            values[i] = n[i];\n        }\n\t}\n    Matrix(const Matrix & x){\n        this->rows = x.rows;\n        this->columns = x.columns;\n        values = (double*)new double[x.rows * x.columns];\n        int i;\n        for(i = 0;i < x.rows * x.columns;i ++){\n            values[i] = x.values[i];\n        }\n    }\n    Matrix & operator = (const Matrix & a){\n        rows = a.rows;\n        columns = a.columns;\n        delete [] values;\n        values = (double*)new double[rows * columns];\n        int i;\n        for(i = 0;i < rows * columns;i ++){\n            values[i] = a.values[i];\n        }\n    }\n    ~Matrix(){\n        delete [] values;\n    }\n    void print(){\n        int i;\n        for(i = 0;i < rows*columns;i ++){\n            cout << \"    \";\n            cout << values[i];\n            if((i+1) % columns == 0){\n                cout << endl;\n            }\n        }\n    }\n    void set(int x, int y, double n){\n        values[(x-1) * columns + y - 1] = n;\n    }\n\n    Matrix operator * (const Matrix & x) const{\n        Matrix res(rows, x.columns);\n        int i,j,k;\n        for(i = 1;i <= rows;i ++){\n            for(j = 1;j <= columns;j ++){\n                double sum = 0;\n                for(k = 1;k <= columns;k ++){\n                    sum += values[(i-1) * columns + k - 1] * x.values[(k-1) * x.columns + j - 1];\n                }\n                res.set(i,j,sum);\n            }\n        }\n        return res;\n    }\n    Matrix operator * (double value) const{\n        Matrix res(*this);\n        int i;\n        for(i = 0;i < rows*columns;i ++) res.values[i] *= value;\n        return res;\n    }\n\n};",
            1589541189.899933,
            100,
            "# 答案正确"
        ],
        [
            "2.12 (C++)",
            "谭鸿鑫",
            "#include<iostream>\n#include<cmath>\nusing namespace std;\n\nclass Matrix{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tMatrix(int x, int y){\n\t\trows = x;\n\t\tcolumns = y;\n\t\tvalues = (double*)new double[x * y];\n        int i;\n        for(i = 0;i < x*y;i ++){\n            values[i] = 0;\n        }\n\t}\n    Matrix(int x, int y, double n[]){\n\t\trows = x;\n\t\tcolumns = y;\n\t\tvalues = (double*)new double[x * y];\n        int i;\n        for(i = 0;i < x*y;i ++){\n            values[i] = n[i];\n        }\n\t}\n    Matrix(const Matrix & x){\n        this->rows = x.rows;\n        this->columns = x.columns;\n        values = (double*)new double[x.rows * x.columns];\n        int i;\n        for(i = 0;i < x.rows * x.columns;i ++){\n            values[i] = x.values[i];\n        }\n    }\n    Matrix & operator = (const Matrix & a){\n        rows = a.rows;\n        columns = a.columns;\n        delete [] values;\n        values = (double*)new double[rows * columns];\n        int i;\n        for(i = 0;i < rows * columns;i ++){\n            values[i] = a.values[i];\n        }\n    }\n    ~Matrix(){\n        delete [] values;\n    }\n    void print(){\n        int i;\n        for(i = 0;i < rows*columns;i ++){\n            cout << \"    \";\n            cout << values[i];\n            if((i+1) % columns == 0){\n                cout << endl;\n            }\n        }\n    }\n    void set(int x, int y, double n){\n        values[(x-1) * columns + y - 1] = n;\n    }\n\n    Matrix pow(double exponent){\n        Matrix res(*this);\n        int i;\n        for(i = 0;i < rows*columns;i ++){\n            res.values[i] = std::pow(res.values[i],exponent);\n        }\n        return res;\n    }\n    Matrix exp(){\n        Matrix res(*this);\n        int i;\n        for(i = 0;i < rows*columns;i ++){\n            res.values[i] = std::exp(res.values[i]);\n        }\n        return res;\n    }\n    Matrix log(){\n        Matrix res(*this);\n        int i;\n        for(i = 0;i < rows*columns;i ++){\n            res.values[i] = std::log(res.values[i]);\n        }\n        return res;\n    }\n    Matrix abs(){\n        Matrix res(*this);\n        int i;\n        for(i = 0;i < rows*columns;i ++){\n            res.values[i] = std::abs(res.values[i]);\n        }\n        return res;\n    }\n\n    Matrix operator * (const Matrix & x) const{\n        Matrix res(rows, x.columns);\n        int i,j,k;\n        for(i = 1;i <= rows;i ++){\n            for(j = 1;j <= columns;j ++){\n                double sum = 0;\n                for(k = 1;k <= columns;k ++){\n                    sum += values[(i-1) * columns + k - 1] * x.values[(k-1) * x.columns + j - 1];\n                }\n                res.set(i,j,sum);\n            }\n        }\n        return res;\n    }\n    Matrix operator * (double value) const{\n        Matrix res(*this);\n        int i;\n        for(i = 0;i < rows*columns;i ++) res.values[i] *= value;\n        return res;\n    }\n\n};",
            1589543318.9377317,
            100,
            "# 答案正确"
        ],
        [
            "2.9 (C++)",
            "谭鸿鑫",
            "#include<iostream>\n#include<cmath>\nusing namespace std;\n\nclass Matrix{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tMatrix(int x, int y){\n\t\trows = x;\n\t\tcolumns = y;\n\t\tvalues = (double*)new double[x * y];\n        int i;\n        for(i = 0;i < x*y;i ++){\n            values[i] = 0;\n        }\n\t}\n    Matrix(int x, int y, double n[]){\n\t\trows = x;\n\t\tcolumns = y;\n\t\tvalues = (double*)new double[x * y];\n        int i;\n        for(i = 0;i < x*y;i ++){\n            values[i] = n[i];\n        }\n\t}\n    Matrix(const Matrix & x){\n        this->rows = x.rows;\n        this->columns = x.columns;\n        values = (double*)new double[x.rows * x.columns];\n        int i;\n        for(i = 0;i < x.rows * x.columns;i ++){\n            values[i] = x.values[i];\n        }\n    }\n    Matrix & operator = (const Matrix & a){\n        rows = a.rows;\n        columns = a.columns;\n        delete [] values;\n        values = (double*)new double[rows * columns];\n        int i;\n        for(i = 0;i < rows * columns;i ++){\n            values[i] = a.values[i];\n        }\n    }\n    ~Matrix(){\n        delete [] values;\n    }\n    void print(){\n        int i;\n        for(i = 0;i < rows*columns;i ++){\n            cout << \"    \";\n            cout << values[i];\n            if((i+1) % columns == 0){\n                cout << endl;\n            }\n        }\n    }\n    void set(int x, int y, double n){\n        values[(x-1) * columns + y - 1] = n;\n    }\n\n    Matrix pow(double exponent){\n        Matrix res(*this);\n        int i;\n        for(i = 0;i < rows*columns;i ++){\n            res.values[i] = std::pow(res.values[i],exponent);\n        }\n        return res;\n    }\n    Matrix exp(){\n        Matrix res(*this);\n        int i;\n        for(i = 0;i < rows*columns;i ++){\n            res.values[i] = std::exp(res.values[i]);\n        }\n        return res;\n    }\n    Matrix log(){\n        Matrix res(*this);\n        int i;\n        for(i = 0;i < rows*columns;i ++){\n            res.values[i] = std::log(res.values[i]);\n        }\n        return res;\n    }\n    Matrix abs(){\n        Matrix res(*this);\n        int i;\n        for(i = 0;i < rows*columns;i ++){\n            res.values[i] = std::abs(res.values[i]);\n        }\n        return res;\n    }\n\n    Matrix operator + (const Matrix & x) const{\n        Matrix res(rows, columns);\n        int i;\n        for(i = 0;i < rows*columns;i ++){\n            res.values[i] = this->values[i] + x.values[i];\n        }\n        return res;\n    }\n    Matrix operator + (double x) const{\n        Matrix res(rows, columns);\n        int i;\n        for(i = 0;i < rows*columns;i ++){\n            res.values[i] = this->values[i] + x;\n        }\n        return res;\n    }\n    Matrix operator - (const Matrix & x) const{\n        Matrix res(rows, columns);\n        int i;\n        for(i = 0;i < rows*columns;i ++){\n            res.values[i] = this->values[i] - x.values[i];\n        }\n        return res;\n    }\n    Matrix operator - (double x) const{\n        Matrix res(rows, columns);\n        int i;\n        for(i = 0;i < rows*columns;i ++){\n            res.values[i] = this->values[i] - x;\n        }\n        return res;\n    }\n\n};",
            1590026888.567719,
            100,
            "# 答案正确"
        ],
        [
            "6.1 (C++)",
            "谭鸿鑫",
            "#include<cstring>\n#include<vector>\n\ntemplate <typename T>\nclass Matrix{\nprivate:\n\tint rows;\n\tint columns;\n\tT* values;\npublic:\n\tMatrix(int x, int y){\n\t\trows = x;\n\t\tcolumns = y;\n      values = new T[x*y];\n\t\tmemset(values,0,sizeof(T)*x*y);\n\t}\n    Matrix(int x, int y, const T n[]){\n\t\trows = x;\n\t\tcolumns = y;\n\t\tvalues = new T[x*y];\n        int i;\n        for(i = 0;i < x*y;i ++){\n            values[i] = n[i];\n        }\n\t}\n    Matrix(int x, int y, const vector<T> n){\n\t\trows = x;\n\t\tcolumns = y;\n\t\tvalues = n;\n\t}\n   \n    Matrix(const Matrix & x){\n        this->rows = x.rows;\n        this->columns = x.columns;\n        values = new T[x.rows * x.columns];\n        int i;\n        for(i = 0;i < x.rows * x.columns;i ++){\n            values[i] = x.values[i];\n        }\n    }\n    Matrix & operator = (const Matrix & a){\n        rows = a.rows;\n        columns = a.columns;\n        delete [] values;\n        values = new T[rows * columns];\n        int i;\n        for(i = 0;i < rows * columns;i ++){\n            values[i] = a.values[i];\n        }\n    }\n    ~Matrix(){\n        delete [] values;\n    }\n\n    T & get(int x, int y){\n        return values[(x-1)*columns + y - 1];\n    }\n\n    void print(){\n        int i;\n        for(i = 0;i < rows*columns;i ++){\n            cout << \"    \";\n            cout << values[i];\n            if((i+1) % columns == 0){\n                cout << endl;\n            }\n        }\n    }\n};",
            1590124211.1253774,
            100,
            "# 答案正确"
        ],
        [
            "6.3 (C++)",
            "谭鸿鑫",
            "#include<iostream>\n#include<string>\n#include<cstring>\n#include<cmath>\n#include<vector>\nusing namespace std;\n\ntemplate <typename T>\nclass Matrix{\nprivate:\n\tint rows;\n\tint columns;\n\tvector<T> values;\npublic:\n\tMatrix(int x, int y){\n\t\trows = x;\n\t\tcolumns = y;\n        int i;\n        for(i = 0;i < x*y;i ++){\n            values.push_back(0);\n        }\n\t}\n    Matrix(int x, int y, const T n[]){\n\t\trows = x;\n\t\tcolumns = y;\n        int i;\n        for(i = 0;i < x*y;i ++){\n            values.push_back(n[i]);\n        }\n\t}\n    Matrix(int x, int y, const vector<T> n){\n\t\trows = x;\n\t\tcolumns = y;\n\t\tvalues = n;\n\t}\n    /*\n    Matrix(const Matrix & x){\n        this->rows = x.rows;\n        this->columns = x.columns;\n        values = new T[x.rows * x.columns];\n        int i;\n        for(i = 0;i < x.rows * x.columns;i ++){\n            values[i] = x.values[i];\n        }\n    }\n    Matrix & operator = (const Matrix & a){\n        rows = a.rows;\n        columns = a.columns;\n        delete [] values;\n        values = new T[rows * columns];\n        int i;\n        for(i = 0;i < rows * columns;i ++){\n            values[i] = a.values[i];\n        }\n    }\n    ~Matrix(){\n        delete [] values;\n    }*/\n\n    T & get(int x, int y){\n        return values[(x-1)*columns + y - 1];\n    }\n\n    void print(){\n        int i;\n        for(i = 0;i < rows*columns;i ++){\n            cout << \"    \";\n            cout << values[i];\n            if((i+1) % columns == 0){\n                cout << endl;\n            }\n        }\n    }\n    void set(int x, int y, double n){\n        values[(x-1) * columns + y - 1] = n;\n    }\n\n    Matrix pow(double exponent){\n        Matrix res(*this);\n        int i;\n        for(i = 0;i < rows*columns;i ++){\n            res.values[i] = std::pow(res.values[i],exponent);\n        }\n        return res;\n    }\n    Matrix exp(){\n        Matrix res(*this);\n        int i;\n        for(i = 0;i < rows*columns;i ++){\n            res.values[i] = std::exp(res.values[i]);\n        }\n        return res;\n    }\n    Matrix log(){\n        Matrix res(*this);\n        int i;\n        for(i = 0;i < rows*columns;i ++){\n            res.values[i] = std::log(res.values[i]);\n        }\n        return res;\n    }\n    Matrix abs(){\n        Matrix res(*this);\n        int i;\n        for(i = 0;i < rows*columns;i ++){\n            res.values[i] = std::abs(res.values[i]);\n        }\n        return res;\n    }\n\n    Matrix operator + (const Matrix & x) const{\n        Matrix res(rows, columns);\n        int i;\n        for(i = 0;i < rows*columns;i ++){\n            res.values[i] = this->values[i] + x.values[i];\n        }\n        return res;\n    }\n    Matrix operator + (T x) const{\n        Matrix res(rows, columns);\n        int i;\n        for(i = 0;i < rows*columns;i ++){\n            res.values[i] = this->values[i] + x;\n        }\n        return res;\n    }\n    Matrix operator - (const Matrix & x) const{\n        Matrix res(rows, columns);\n        int i;\n        for(i = 0;i < rows*columns;i ++){\n            res.values[i] = this->values[i] - x.values[i];\n        }\n        return res;\n    }\n    Matrix operator - (T x) const{\n        Matrix res(rows, columns);\n        int i;\n        for(i = 0;i < rows*columns;i ++){\n            res.values[i] = this->values[i] - x;\n        }\n        return res;\n    }\n\n    Matrix operator * (const Matrix & x) const{\n        Matrix res(rows, x.columns);\n        int i,j,k;\n        for(i = 1;i <= rows;i ++){\n            for(j = 1;j <= columns;j ++){\n                double sum = 0;\n                for(k = 1;k <= columns;k ++){\n                    sum += values[(i-1) * columns + k - 1] * x.values[(k-1) * x.columns + j - 1];\n                }\n                res.set(i,j,sum);\n            }\n        }\n        return res;\n    }\n    Matrix operator * (T value) const{\n        Matrix res(*this);\n        int i;\n        for(i = 0;i < rows*columns;i ++) res.values[i] *= value;\n        return res;\n    }\n\n    Matrix reshape(int x, int y) const{\n        Matrix res(x,y);\n        int i,j;\n        int a = 1, b = 1;\n        for(i = 1;i <= y;i ++){\n            for(j = 1;j <= x;j ++){\n                res.set(j, i, values[(a-1) * columns + b - 1]);\n                a ++;\n                if(a > rows){\n                    a = 1;\n                    b ++;\n                }\n            }\n        }\n        return res;\n    }\n\n    Matrix transpose(){\n        Matrix res(columns, rows);\n        int i,j;\n        int a = 1, b = 1;\n        for(i = 1;i <= rows;i ++){\n            for(j = 1;j <= columns;j ++){\n                res.set(j, i, values[(a-1) * columns + b - 1]);\n                b ++;\n                if(b > columns){\n                    b = 1;\n                    a ++;\n                }\n            }\n        }\n        return res;\n    }\n\n    Matrix getRow(int x){\n        Matrix res(1, columns);\n        int i;\n        for(i = 0;i < columns;i ++){\n            res.values[i] = this->values[i + columns*(x-1)];\n        }\n        return res;\n    }\n    Matrix getColumn(int x){\n        Matrix res(rows, 1);\n        int i;\n        for(i = 0;i < rows;i ++){\n            res.values[i] = this->values[i * rows + x - 1];\n        }\n        return res;\n    }\n\n    Matrix max() const{\n        if(rows == 1){\n            double ma = 0;\n            int i;\n            for(i = 0;i < columns;i ++){\n                if(values[i] > ma) ma = values[i];\n            }\n            Matrix res(1,1);\n            res.values[0] = ma;\n            return res;\n        }\n        else{\n            int i,j;\n            Matrix res(1, columns);\n            for(i = 0;i < columns;i ++){\n                double ma = 0;\n                for(j = 0;j < rows;j ++){\n                    if(values[i + columns*j] > ma) ma = values[i + columns*j];\n                }\n                res.values[i] = ma;\n            }\n            return res;\n        }\n    }\n    Matrix min() const{\n        if(rows == 1){\n            double ma = 999;\n            int i;\n            for(i = 0;i < columns;i ++){\n                if(values[i] < ma) ma = values[i];\n            }\n            Matrix res(1,1);\n            res.values[0] = ma;\n            return res;\n        }\n        else{\n            int i,j;\n            Matrix res(1, columns);\n            for(i = 0;i < columns;i ++){\n                double ma = 999;\n                for(j = 0;j < rows;j ++){\n                    if(values[i + columns*j] < ma) ma = values[i + columns*j];\n                }\n                res.values[i] = ma;\n            }\n            return res;\n        }\n    }\n    Matrix sum() const{\n        if(rows == 1){\n            double ressum = 0;\n            int i;\n            for(i = 0;i < columns;i ++){\n                ressum += values[i];\n            }\n            Matrix res(1,1);\n            res.values[0] = ressum;\n            return res;\n        }\n        else{\n            int i,j;\n            Matrix res(1, columns);\n            for(i = 0;i < columns;i ++){\n                for(j = 0;j < rows;j ++){\n                    res.values[i] += values[i + columns*j];\n                }\n            }\n            return res;\n        }\n    }\n\n    Matrix concatenateRows(const Matrix & x) const{\n        Matrix res(rows+x.rows, columns);\n        int i;\n        for(i = 0;i < rows*columns;i ++){\n            res.values[i] = this->values[i];\n        }\n        for(i = 0;i < x.rows*x.columns;i ++){\n            res.values[i + rows*columns] = x.values[i];\n        }\n        return res;\n    }\n    Matrix concatenateColumns(const Matrix & x) const{\n        Matrix res(rows, columns + x.columns);\n        int i,j;\n        for(i = 0;i < rows;i ++){\n            for(j = 0;j < columns;j ++){\n                res.values[i*res.columns + j] = this->values[i*this->columns + j];\n            }\n        }\n        for(i = 0;i < rows;i ++){\n            for(j = 0;j < columns;j ++){\n                res.values[i*res.columns + j + this->columns] = x.values[i * x.columns + j];\n            }\n        }\n        return res;\n    }\n};\n",
            1590121741.6609879,
            100,
            "# 答案正确"
        ],
        [
            "6.2 (C++)",
            "谭鸿鑫",
            "#include <iostream>\n#include<cstring>\n#include<vector>\nusing namespace std;\n\ntemplate <typename T>\nclass Matrix{\nprivate:\n\tint rows;\n\tint columns;\n\tT* values;\npublic:\n\tMatrix(int x, int y){\n\t\trows = x;\n\t\tcolumns = y;\n      values = new T[x*y];\n\t\tmemset(values,0,sizeof(T)*x*y);\n\t}\n    Matrix(int x, int y, const T n[]){\n\t\trows = x;\n\t\tcolumns = y;\n\t\tvalues = new T[x*y];\n        int i;\n        for(i = 0;i < x*y;i ++){\n            values[i] = n[i];\n        }\n\t}\n    Matrix(const Matrix & x){\n        this->rows = x.rows;\n        this->columns = x.columns;\n        values = new T[x.rows * x.columns];\n        int i;\n        for(i = 0;i < x.rows * x.columns;i ++){\n            values[i] = x.values[i];\n        }\n    }\n    Matrix & operator = (const Matrix & a){\n        rows = a.rows;\n        columns = a.columns;\n        delete [] values;\n        values = new T[rows * columns];\n        int i;\n        for(i = 0;i < rows * columns;i ++){\n            values[i] = a.values[i];\n        }\n    }\n    ~Matrix(){\n        delete [] values;\n    }\n\n    T & get(int x, int y){\n        return values[(x-1)*columns + y - 1];\n    }\n\n    void print(){\n        int i;\n        for(i = 0;i < rows*columns;i ++){\n            cout << \"    \";\n            cout << values[i];\n            if((i+1) % columns == 0){\n                cout << endl;\n            }\n        }\n    }\n};",
            1590631400.3824458,
            100,
            "# 答案正确"
        ],
        [
            "7.1 (C++)",
            "谭鸿鑫",
            "#include<math.h>\n\nclass Triangle: public GeometricObject{\nprivate:\n    double side1;\n    double side2;\n    double side3;\npublic:\n    Triangle(){\n        side1 = 1.0;\n        side2 = 1.0;\n        side3 = 1.0;\n    }\n    Triangle(double x, double y, double z){\n        side1 = x;\n        side2 = y;\n        side3 = z;\n    }\n\n    double getSide1(){\n        return side1;\n    }\n    double getSide2(){\n        return side2;\n    }\n    double getSide3(){\n        return side3;\n    }\n    double getArea(){\n        double s = (side1 + side2 + side3) / 2;\n        return sqrt(s * (s - side1) * (s - side2) * (s - side3));\n    }\n    double getPerimeter(){\n        return side1 + side2 + side3;\n    }\n};",
            1590723782.300954,
            100,
            "# 答案正确"
        ],
        [
            "7.3 (C++)",
            "谭鸿鑫",
            "template <typename A, typename R>\nvector<R> map2(const vector<A> & x, const vector<A> & y, R (*map_func)(const A &, const A &)) {\n\tvector<R> res;\n\tfor (int i = 0; i < x.size(); ++ i)\n\t\tres.push_back(map_func(x[i], y[i]));\n\treturn res;\n}\ntemplate <typename A, typename R>\nvector<R> map2(const vector<A> & x, const int y, R (*map_func)(const A &, const A &)) {\n\tvector<R> res;\n\tfor (int i = 0; i < x.size(); ++ i)\n\t\tres.push_back(map_func(x[i], y));\n\treturn res;\n}",
            1590724158.8596392,
            100,
            "# 答案正确"
        ],
        [
            "7.2 (C++)",
            "谭鸿鑫",
            "#include <sstream>\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nvector<string> split(string line){\n    vector<string> res;\n    stringstream ss(line);\n    string tem;\n    while(getline(ss, tem, ' ')){\n        res.push_back(tem);\n    }\n    return res;\n}",
            1591237045.4995444,
            100,
            "# 答案正确"
        ],
        [
            "8.1 (C++)",
            "谭鸿鑫",
            "class Full: public Matrix{\nprivate:\n    int row;\n    int column;\n    double* values;\npublic:\n    Full(int x, int y){\n        row = x;\n        column = y;\n        values = new double[x * y];\n        int i;\n        for(i = 0;i < x * y;i ++)values[i] = 0;\n    }\n    Full(int x, int y, double n[]){\n        row = x;\n        column = y;\n        values = new double[x * y];\n        int i;\n        for(i = 0;i < x * y;i ++)values[i] = n[i];\n    }\n    Full(const Matrix & x){\n        row = x.size(1);\n        column = x.size(2);\n        values = new double[row * column];\n        int i,j;\n        for(i = 1;i <= row;i ++){\n            for(j = 1;j <= column;j ++){\n                set(i,j,x.get(i,j));\n            }\n        }\n    }\n    ~Full(){\n        delete [] values;\n    }\n\n    void print() const {\n        for(int i = 0;i < row*column;i ++){\n            cout << \"    \";\n            cout << values[i];\n            if((i+1) % column == 0){\n                cout << endl;\n            }\n        }\n    }\n    int size(int dimension) const{\n        if(dimension == 1) return row;\n        if(dimension == 2) return column;\n    }\n    void set(int x, int y, double n){\n        values[(x-1) * column + y - 1] = n;\n    }\n    double get(int x, int y) const{\n        return values[(x-1)*column + y - 1];\n    }\n    Matrix & operator = (const Matrix & x){\n        row = x.size(1);\n        column = x.size(2);\n        delete [] values;\n        values = new double[row * column];\n        int i,j;\n        for(i = 1;i <= row;i ++){\n            for(j = 1;j <= column;j ++){\n                set(i,j,x.get(i,j));\n            }\n        }\n        return *this;\n    }\n};",
            1591332401.4585192,
            100,
            "# 答案正确"
        ],
        [
            "8.3 (C++)",
            "谭鸿鑫",
            "#include<vector>\n#include<iostream>\nusing namespace std;\n\nclass Sparse:public Matrix{\nprivate:\n    int rows;\n    int columns;\n    vector<Entry> values;\n\tint size1;\npublic:\n    Sparse(int row, int column){\n        rows = row;\n        columns = column;\n\t\tsize1 = 0;\n    }\n\tint size(int dimension) const{\n        if(dimension == 1) return rows;\n        if(dimension == 2) return columns;\n    }\n\tvoid set(int row, int column, double value){\n\t\tEntry tem;\n\t\ttem.row = row;\n\t\ttem.column = column;\n\t\ttem.value = value;\n\t\tvalues.push_back(tem);\n\t\tsize1 ++;\n\t}\n\tdouble get(int row, int column) const{\n\t\tfor(int i = 0;i < values.size();i ++){\n\t\t\tif(values[i].row == row && values[i].column == column) return values[i].value;\n\t\t}\n\t\treturn 0;\n\t}\n\tvoid print(){\n\t\tfor(int i = 0;i < size1;i ++){\n\t\t\tfor(int j = 0;j < size1 - i - 1;j ++){\n\t\t\t\tif(values[j].row > values[j+1].row || \n\t\t\t\t(values[j].row == values[j+1].row && values[j].column > values[j+1].column)){\n\t\t\t\t\tEntry tem = values[j];\n\t\t\t\t\tvalues[j] = values[j+1];\n\t\t\t\t\tvalues[j+1] = tem;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < size1;i ++){\n\t\t\tif(values[i].value != 0){\n\t\t\t\tcout << '(' << values[i].row << ',' << values[i].column << ','\n\t\t\t\t<< values[i].value << ')' << endl;\n\t\t\t}\n\t\t}\n\t}\n\n\tSparse operator + (Sparse & x){\n\t\tSparse res(rows, columns);\n\t\tres.size1 = this->size1;\n\t\tfor(int i = 0;i < size1;i ++){\n\t\t\tres.values.push_back(this->values[i]);\n\t\t}\n\t\tfor(int i = 0;i < x.size1;i ++){\n\t\t\tint flag = 0;\n\t\t\tfor(int j = 0;j < res.size1;j ++){\n\t\t\t\tif(res.values[j].row == x.values[i].row && res.values[j].column == x.values[i].column){\n\t\t\t\t\tres.values[j].value += x.values[i].value;\n\t\t\t\t\tflag = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag == 0) res.set(x.values[i].row, x.values[i].column, x.values[i].value);\n\t\t}\n\t\treturn res;\n\t}\n};",
            1591343661.3912408,
            100,
            "# 答案正确"
        ],
        [
            "8.4 (C++)",
            "谭鸿鑫",
            "#include<vector>\n#include<iostream>\nusing namespace std;\n\nclass Sparse:public Matrix{\nprivate:\n    int rows;\n    int columns;\n    vector<Entry> values;\n\tint size1;\npublic:\n    Sparse(int row, int column){\n        rows = row;\n        columns = column;\n\t\tsize1 = 0;\n    }\n\tint size(int dimension) const{\n        if(dimension == 1) return rows;\n        if(dimension == 2) return columns;\n    }\n\tvoid set(int row, int column, double value){\n\t\tif(get(row, column) == 0){\n\t\t\tEntry tem;\n\t\t\ttem.row = row;\n\t\t\ttem.column = column;\n\t\t\ttem.value = value;\n\t\t\tvalues.push_back(tem);\n\t\t\tsize1 ++;\n\t\t}\n\t\telse{\n\t\t\tfor(int i = 0;i < values.size();i ++){\n\t\t\t\tif(values[i].row == row && values[i].column == column) values[i].value += value;\n\t\t\t}\n\t\t}\n\t}\n\tdouble get(int row, int column) const{\n\t\tfor(int i = 0;i < values.size();i ++){\n\t\t\tif(values[i].row == row && values[i].column == column) return values[i].value;\n\t\t}\n\t\treturn 0;\n\t}\n\tvoid print(){\n\t\tfor(int i = 0;i < size1;i ++){\n\t\t\tfor(int j = 0;j < size1 - i - 1;j ++){\n\t\t\t\tif(values[j].row > values[j+1].row || \n\t\t\t\t(values[j].row == values[j+1].row && values[j].column > values[j+1].column)){\n\t\t\t\t\tEntry tem = values[j];\n\t\t\t\t\tvalues[j] = values[j+1];\n\t\t\t\t\tvalues[j+1] = tem;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < size1;i ++){\n\t\t\tif(values[i].value != 0){\n\t\t\t\tcout << '(' << values[i].row << ',' << values[i].column << ','\n\t\t\t\t<< values[i].value << ')' << endl;\n\t\t\t}\n\t\t}\n\t}\n\n\tSparse operator + (Sparse & x){\n\t\tSparse res(rows, columns);\n\t\tres.size1 = this->size1;\n\t\tfor(int i = 0;i < size1;i ++){\n\t\t\tres.values.push_back(this->values[i]);\n\t\t}\n\t\tfor(int i = 0;i < x.size1;i ++){\n\t\t\tint flag = 0;\n\t\t\tfor(int j = 0;j < res.size1;j ++){\n\t\t\t\tif(res.values[j].row == x.values[i].row && res.values[j].column == x.values[i].column){\n\t\t\t\t\tres.values[j].value += x.values[i].value;\n\t\t\t\t\tflag = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag == 0) res.set(x.values[i].row, x.values[i].column, x.values[i].value);\n\t\t}\n\t\treturn res;\n\t}\n\tSparse operator * (Sparse & x){\n\t\tSparse res(this->rows, x.columns);\n\t\tfor(int i = 0;i < this->size1;i ++){\n\t\t\tfor(int j = 0;j < x.size1;j ++){\n\t\t\t\tif(this->values[i].column == x.values[j].row)\n\t\t\t\tres.set(this->values[i].row, x.values[j].column, this->values[i].value * x.values[j].value);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};",
            1591350230.334171,
            100,
            "# 答案正确"
        ],
        [
            "8.5 (C++)",
            "谭鸿鑫",
            "class Point3D: public Point2D{\nprivate:\n    double z;\npublic:\n    Point3D(){\n        setX(0);\n        setY(0);\n        z = 0;\n    }\n    Point3D(double x1, double y1, double z1){\n        setX(x1);\n        setY(y1);\n        z = z1;\n    }\n    double getZ(){\n        return z;\n    }\n    double distance(Point2D & point2) {\n\t\tdouble dx = getX() - point2.getX();\n\t\tdouble dy = getY() - point2.getY();\n        Point3D * tem = dynamic_cast<Point3D*>(&point2);\n        double dz = getZ() - tem->getZ();\n\t\treturn sqrt(dx * dx + dy * dy + dz * dz);\n\t}\n};",
            1591842812.3526556,
            100,
            "# 答案正确"
        ],
        [
            "8.6 (C++)",
            "谭鸿鑫",
            "#include<iostream>\n\nclass MyTensor:public Tensor<double>{\nprivate:\n    vector<double> val;\npublic:\n    MyTensor(vector<int> sizes): Tensor<double>(sizes){\n        int n = sizes[0];\n        if(sizes[1] != -1) n *= sizes[1];\n        if(sizes[2] != -1) n *= sizes[2];\n        if(sizes[3] != -1 && sizes.size() == 4) n *= sizes[3];\n        vector<double> tem(n);\n        val = tem;\n    }\n    double & get(const vector<int> & indexes){\n        int n = Tensor::sizes.size();\n        if(n == 3){\n            return val[indexes[0]*sizes[1]*sizes[2] + indexes[1]*sizes[2] + indexes[2]];\n        }\n        else if(n == 4){\n            return val[indexes[0]*sizes[1]*sizes[2]*sizes[3] + indexes[1]*sizes[2]*sizes[3]\n             + indexes[2]*sizes[3] + indexes[3]];\n        }\n    }\n};",
            1592449708.4508407,
            100,
            "# 答案正确"
        ],
        [
            "9.1 (C++)",
            "谭鸿鑫",
            "class Circle{\n    private:\n    double r;\n    public:\n    Circle(double x){\n        r = x;\n    }\n    int operator < (Circle x){\n        return this->r < x.r;\n    }\n    int operator <= (Circle x){\n        return this->r <= x.r;\n    }\n    int operator == (Circle x){\n        return this->r == x.r;\n    }\n    int operator != (Circle x){\n        return this->r != x.r;\n    }\n    int operator > (Circle x){\n        return this->r > x.r;\n    }\n    int operator >= (Circle x){\n        return this->r >= x.r;\n    }\n};",
            1592535979.6781552,
            100,
            "# 答案正确"
        ],
        [
            "9.2 (C++)",
            "谭鸿鑫",
            "class I{\nprivate:\n    vector<int> x;\npublic:\n    I(int a, int b, int c, int d = -1){\n        x.push_back(a);\n        x.push_back(b);\n        x.push_back(c);\n        if(d != -1)x.push_back(d);\n    }\n    operator vector<int>(){\n        return x;\n    }\n};",
            1592536500.078073,
            100,
            "# 答案正确"
        ],
        [
            "9.3 (C++)",
            "谭鸿鑫",
            "class Complex{\nprivate:\n    double r, v;\npublic:\n    Complex(double a = 0, double b = 0){\n        r = a;\n        v = b;\n    }\n    Complex(const Complex & x){\n        r = x.r;\n        v = x.v;\n    }\n    double real(){\n        return r;\n    }\n    double imag(){\n        return v;\n    }\n    Complex operator +(Complex x){\n        Complex res(this->r + x.r , this->v + x.v);\n        return res;\n    }\n    Complex operator -(Complex x){\n        Complex res(this->r - x.r , this->v - x.v);\n        return res;\n    }\n    Complex operator *(Complex x){\n        Complex res(this->r * x.r - this->v * x.v, this->r * x.v + this->v * x.r);\n        return res;\n    }\n    Complex operator /(Complex x){\n        Complex res(this->r * x.r + this->v * x.v, - this->r * x.v + this->v * x.r);\n        double n = x.r*x.r + x.v*x.v;\n        res.r /= n;\n        res.v /= n;\n        return res;\n    }\n    Complex operator +=(Complex x){\n        *this = *this + x;\n        return *this;\n    }\n    Complex operator -=(Complex x){\n        *this = *this - x;\n        return *this;\n    }\n    Complex operator *=(Complex x){\n        *this = *this * x;\n        return *this;\n    }\n    Complex operator /=(Complex x){\n        *this = *this / x;\n        return *this;\n    }\n    int operator ==(Complex x){\n        return this->r == x.r && this->v == x.v;\n    }\n    int operator !=(Complex x){\n        return !(*this == x);\n    }\n};\nComplex operator +(int a, Complex b){\n    Complex res(a, 0);\n    return res + b;\n}",
            1592537956.2694392,
            100,
            "# 答案正确"
        ],
        [
            "9.4 (C++)",
            "谭鸿鑫",
            "class Complex{\nprivate:\n    double r, v;\npublic:\n    Complex(double a = 0, double b = 0){\n        r = a;\n        v = b;\n    }\n    Complex(const Complex & x){\n        r = x.r;\n        v = x.v;\n    }\n    double real(){\n        return r;\n    }\n    double imag(){\n        return v;\n    }\n    Complex operator +(Complex x){\n        Complex res(this->r + x.r , this->v + x.v);\n        return res;\n    }\n    Complex operator -(Complex x){\n        Complex res(this->r - x.r , this->v - x.v);\n        return res;\n    }\n    Complex operator *(Complex x){\n        Complex res(this->r * x.r - this->v * x.v, this->r * x.v + this->v * x.r);\n        return res;\n    }\n    Complex operator /(Complex x){\n        Complex res(this->r * x.r + this->v * x.v, - this->r * x.v + this->v * x.r);\n        double n = x.r*x.r + x.v*x.v;\n        res.r /= n;\n        res.v /= n;\n        return res;\n    }\n    Complex operator +=(Complex x){\n        *this = *this + x;\n        return *this;\n    }\n    Complex operator -=(Complex x){\n        *this = *this - x;\n        return *this;\n    }\n    Complex operator *=(Complex x){\n        *this = *this * x;\n        return *this;\n    }\n    Complex operator /=(Complex x){\n        *this = *this / x;\n        return *this;\n    }\n    int operator ==(Complex x){\n        return this->r == x.r && this->v == x.v;\n    }\n    int operator !=(Complex x){\n        return !(*this == x);\n    }\n};\nComplex operator +(int a, Complex b){\n    Complex res(a, 0);\n    return res + b;\n}\n\nistream & operator >>(istream & in, Complex & x){\n    double r,v;\n    in >> r >> v;\n    Complex res(r,v);\n    x = res;\n    return in;\n}\nostream & operator <<(ostream & out, Complex & x){\n    out << x.real() << ' ' << '+' << ' ' << x.imag() << ' ' << 'i';\n    return out;\n}",
            1592538373.3773427,
            100,
            "# 答案正确"
        ],
        [
            "9.5 (C++)",
            "谭鸿鑫",
            "class Complex{\nprivate:\n    double r, v;\npublic:\n    Complex(double a = 0, double b = 0){\n        r = a;\n        v = b;\n    }\n    Complex(const Complex & x){\n        r = x.r;\n        v = x.v;\n    }\n    double real(){\n        return r;\n    }\n    double imag(){\n        return v;\n    }\n    Complex operator +(Complex x){\n        Complex res(this->r + x.r , this->v + x.v);\n        return res;\n    }\n    Complex operator -(Complex x){\n        Complex res(this->r - x.r , this->v - x.v);\n        return res;\n    }\n    Complex operator *(Complex x){\n        Complex res(this->r * x.r - this->v * x.v, this->r * x.v + this->v * x.r);\n        return res;\n    }\n    Complex operator /(Complex x){\n        Complex res(this->r * x.r + this->v * x.v, - this->r * x.v + this->v * x.r);\n        double n = x.r*x.r + x.v*x.v;\n        res.r /= n;\n        res.v /= n;\n        return res;\n    }\n    Complex operator +=(Complex x){\n        *this = *this + x;\n        return *this;\n    }\n    Complex operator -=(Complex x){\n        *this = *this - x;\n        return *this;\n    }\n    Complex operator *=(Complex x){\n        *this = *this * x;\n        return *this;\n    }\n    Complex operator /=(Complex x){\n        *this = *this / x;\n        return *this;\n    }\n    int operator ==(Complex x){\n        return this->r == x.r && this->v == x.v;\n    }\n    int operator !=(Complex x){\n        return !(*this == x);\n    }\n    Complex & operator ++(){\n        this->r ++;\n        return *this;\n    }\n    Complex operator ++(int){\n        Complex res(*this);\n        this->r ++;\n        return res;\n    }\n    operator double(){\n        return r;\n    }\n};\nComplex operator +(int a, Complex b){\n    Complex res(a, 0);\n    return res + b;\n}\n\nistream & operator >>(istream & in, Complex & x){\n    double r,v;\n    in >> r >> v;\n    Complex res(r,v);\n    x = res;\n    return in;\n}\nostream & operator <<(ostream & out, Complex x){\n    out << x.real() << ' ' << '+' << ' ' << x.imag() << ' ' << 'i';\n    return out;\n}",
            1592538883.432883,
            100,
            "# 答案正确"
        ],
        [
            "9.6 (C++)",
            "谭鸿鑫",
            "class Tensor{\nprivate:\n    vector<double> val;\n    vector<int> size;\npublic:\n    Tensor(int a, int b, int c, int d = 0){\n        int n = a;\n        n *= b;\n        n *= c;\n        size.push_back(a);\n        size.push_back(b);\n        size.push_back(c);\n        if(d != 0){\n            n *= d;\n            size.push_back(d);\n        }\n        val.resize(n);\n    }\n    double & operator()(int a, int b, int c, int d = -1){\n        int n = 0;\n        if(d == -1){\n            n = a*size[1]*size[2] + b*size[2] + c;\n        }\n        else{\n            n = a*size[1]*size[2]*size[3] + b*size[2]*size[3] + c*size[3];\n        }\n        return val[n];\n    }\n};",
            1592539881.6421757,
            100,
            "# 答案正确"
        ],
        [
            "9.7 (C++)",
            "谭鸿鑫",
            "class Tensor{\nprivate:\n    vector<int> size;\n    vector<double> value;\npublic:\n    Tensor():size(),value(){}\n    Tensor(vector<int> sizes):size(sizes){\n        int n = 1;\n        for(int i = 0;i < sizes.size();i ++){\n            n *= sizes[i];\n        }\n        value.resize(n);\n    }\n    const vector<int> getSize()const{\n        return size;\n    }\n    double & get(int a, int b, int c, int d = -1){\n        if(size.size() == 3){\n            return value[a*size[1]*size[2] + b*size[2] + c];\n        }\n        else{\n            return value[a*size[1]*size[2]*size[3] + b*size[2]*size[3] + c*size[3] + d];\n        }\n    }\n    const double & get(int a, int b, int c, int d = -1)const{\n        if(size.size() == 3){\n            return value[a*size[1]*size[2] + b*size[2] + c];\n        }\n        else{\n            return value[a*size[1]*size[2]*size[3] + b*size[2]*size[3] + c*size[3] + d];\n        }\n    }\n};\n\nistream & operator >>(istream & in, Tensor & x){\n    int n;\n    in >> n;\n    vector<int> sizes;\n    for(int i = 0;i < n;i ++){\n        int a;\n        in >> a;\n        sizes.push_back(a);\n    }\n    Tensor tem(sizes);\n    if(n == 3){\n        for(int i = 0;i < sizes[0];i ++){\n            for(int j = 0;j < sizes[1];j ++){\n                for(int k = 0;k < sizes[2];k ++){\n                    in >> tem.get(i,j,k);\n                }\n            }\n        }\n    }\n    else{\n        for(int i = 0;i < sizes[0];i ++){\n            for(int j = 0;j < sizes[1];j ++){\n                for(int k = 0;k < sizes[2];k ++){\n                    for(int l = 0;l < sizes[3];l ++){\n                        in >> tem.get(i,j,k,l);\n                    }\n                }\n            }\n        }\n    }\n    x = tem;\n    return in;\n}\nostream & operator <<(ostream & out, const Tensor & x){\n    vector<int> sizes = x.getSize();\n    out << sizes.size() << endl;\n    for(int i = 0;i < sizes.size();i ++){\n        out << sizes[i] << ' ';\n    }\n    out << endl;\n    if(sizes.size() == 3){\n        for(int i = 0;i < sizes[0];i ++){\n            out << endl;\n            for(int j = 0;j < sizes[1];j ++){\n                for(int k = 0;k < sizes[2];k ++){\n                    out << x.get(i,j,k) << ' ';\n                }\n                out << endl;\n            }\n        }\n        out << endl;\n    }\n    else{\n        for(int i = 0;i < sizes[0];i ++){\n            for(int j = 0;j < sizes[1];j ++){\n                out << endl;\n                for(int k = 0;k < sizes[2];k ++){\n                    for(int l = 0;l < sizes[3];l ++){\n                        out << x.get(i,j,k,l) << ' ';\n                    }\n                    out << endl;\n                }\n            }\n        }\n        out << endl;\n    }\n    return out;\n}",
            1592552775.1743286,
            100,
            "# 答案正确"
        ],
        [
            "10.1 (C++)",
            "谭鸿鑫",
            "#include<stdexcept>\n\nclass MatrixSizesDoNotMatchException{};\n\ndouble Matrix::get(int row, int column)const{\n    if(row <= 0 || row > this->rows) throw out_of_range(\"out_of_range\");\n    if(column <= 0 || column > this->columns) throw out_of_range(\"out_of_range\");\n    return this->elements[(row - 1)*this->size(2) + column - 1];\n}\nvoid Matrix::set(int row, int column, double value){\n    if(row <= 0 || row > this->rows) throw out_of_range(\"out_of_range\");\n    if(column <= 0 || column > this->columns) throw out_of_range(\"out_of_range\");\n    this->elements[(row - 1)*this->size(2) + column - 1] = value;\n}\n\nMatrix Matrix::operator +(const Matrix & matrix2) const{\n    if(this->rows != matrix2.rows || this->columns != matrix2.columns) throw MatrixSizesDoNotMatchException();\n    Matrix res(this->size(1), this->size(2));\n    for(int i = 0;i < this->size(1);i ++){\n        for(int j = 0;j < this->size(2);j ++){\n            res.set(i + 1, j + 1, this->get(i+1,j+1) + matrix2.get(i+1,j+1));\n        }\n    }\n    return res;\n}",
            1593314876.1576152,
            100,
            "# 答案正确"
        ],
        [
            "10.2 (C++)",
            "谭鸿鑫",
            "        catch(NonPositiveValueException){\n            cout << \"caught: NonPositiveValueException\" << endl;\n        }\n        catch(out_of_range){\n            cout << \"caught: out_of_range\" << endl;\n        }",
            1593655849.1760888,
            100,
            "# 答案正确"
        ],
        [
            "15.1 (C++)",
            "谭鸿鑫",
            "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nclass Table{\nprivate:\n    vector<string> headers;\n    vector< vector<string> > rows;\npublic:\n    Table(): headers(), rows(){}\n    void addCol(const string x){\n        headers.push_back(x);\n    }\n    vector<string> & operator[](int n){\n        if(n == rows.size()){\n            vector<string> tem;\n            rows.push_back(tem);\n        }\n        return rows[n];\n    }\n    string json()const{\n        string res = \"\";\n        res += \"{\\n\";\n        res += \"    headers: [\";\n        for(int i = 0;i < headers.size();i ++){\n            res += \"'\" + headers[i] + \"',\";\n        }\n        res += \"],\\n\";\n        res += \"    rows: [\\n\";\n        for(int i = 0;i < rows.size();i ++){\n            res += \"        [\";\n            for(int j = 0;j < headers.size();j ++){\n                res += \"'\" + rows[i][j] + \"',\";\n            }\n            res += \"],\\n\";\n        }\n        res += \"    ],\\n\";\n        res += \"}\";\n        return res;\n    }\n};",
            1593749431.7086353,
            100,
            "# 答案正确"
        ],
        [
            "2020-07-09 LAB",
            "谭鸿鑫",
            "#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Integer{\nprivate:\n    int val;\n    static int s_val;\npublic:\n    Integer(){\n        val = 0;\n    }\n    Integer(int x){\n        val = x;\n    }\n    static void increase_all(int x){\n        s_val += x;\n    }\n    static void increase_all(Integer x){\n        s_val += x.get();\n    }\n    int get(){\n        return val + s_val;\n    }\n};\nint Integer::s_val = 0;\n\nistream & operator >> (istream & in, Integer & x){\n    int a;\n    in >> a;\n    x = a;\n    return in;\n}\n\nostream & operator << (ostream & out, Integer & x){\n    out << x.get();\n    return out;\n}",
            1594261030.9021914,
            100,
            "# 答案正确"
        ],
        [
            "A.1 (C++)",
            "谭鸿鑫",
            "\n    void addFirst(E val){\n        Node<E> * tem = new Node<E>();\n        tem->element = val;\n        tem->update_prev_and_next_node(0, head);\n        if(head != 0)\n            head->update_prev_node(0, tem);\n        head = tem;\n        if(tail == 0)\n            tail = tem;\n        _size ++;\n    }\n    void addLast(E val){\n        Node<E> * tem = new Node<E>();\n        tem->element = val;\n        tem->update_prev_and_next_node(tail, 0);\n        if(tail != 0)\n            tail->update_next_node(0, tem);\n        tail = tem;\n        if(head == 0)\n            head = tem;\n        _size ++;\n    }\n    void removeFirst(){\n        if(_size == 0)return;\n        Node<E> * tem = head;\n        _size --;\n        if(_size != 0){\n            head = head->next_node(0);\n            head->update_prev_node(tem, 0);\n        }\n        if(_size == 0){\n            head = 0;\n            tail = 0;\n        }\n        delete tem;\n    }\n    void removeLast(){\n        if(_size == 0)return;\n        Node<E> * tem = tail;\n        _size --;\n        if(_size != 0){\n            tail = tail->prev_node(0);\n            tail->update_next_node(tem, 0);\n        }\n        if(_size == 0){\n            head = 0;\n            tail = 0;\n        }\n        delete tem;\n    }\n\n    Node<E> * get_Node(int index){\n        if(index < 0 || index >= _size)\n            throw NotSuchElementException();\n\t\tif (index < _size / 2) {\n\t\t\tNode<E> * node = head;\n            Node<E> * pre_node = 0;\n            Node<E> * tem = 0;\n\t\t\tI(i, index){\n                tem = node;\n                node = node->next_node(pre_node);\n                pre_node = tem;\n            }\n\t\t\treturn node;\n\t\t}\n\t\telse {\n\t\t\tNode<E> * node = tail;\n            Node<E> * next_node = 0;\n            Node<E> * tem = 0;\n\t\t\tI(i, (_size-1-index)){\n                tem = node;\n                node = node->prev_node(next_node);\n                next_node = tem;\n            }\n\t\t\treturn node;\n\t\t}\n    }\n\n    E get(int index){\n        Node<E> * node = get_Node(index);\n        return node->element;\n    }\n\n    void removeFirstOccurrence(int val) {\n        Node<E> * node = head;\n        Node<E> * pre_node = 0;\n        Node<E> * tem = 0;\n        if(node->element == val){\n            removeFirst();\n        }\n\t\tI(i, _size){\n            tem = node;\n            node = node->next_node(pre_node);\n            pre_node = tem;\n            if(node->element == val){\n                if(i == _size-1){\n                    removeLast();\n                    return;\n                }\n                Node<E> * next = node->next_node(pre_node);\n                pre_node->update_next_node(node, next);\n                next->update_prev_node(node, pre_node);\n                delete node;\n                _size --;\n                return;\n            }\n        }\n\t}\n\n    LinkedList(LinkedList & list1){\n        _size = 0;\n        head = 0;\n        tail = 0;\n        for(int i = 0;i < list1.size();i ++){\n            addLast(list1.get(i));\n        }\n    }\n\n    ~LinkedList(){\n        while(_size > 0){\n            removeLast();\n        }\n    }\n",
            1594370598.357302,
            100,
            "# 答案正确"
        ],
        [
            "A.2 (C++)",
            "谭鸿鑫",
            "template<typename E>\nvoid LinkedList<E>::removeAll(const E & e){\n\tint i = 0;\n\twhile(1){\n\t\tif(i >= this->size()) return;\n\t\tif(this->get(i) == e){\n\t\t\tthis->remove(i);\n\t\t}\n\t\telse{\n\t\t\ti ++;\n\t\t}\n\t}\n}",
            1594865476.666319,
            100,
            "# 答案正确"
        ],
        [
            "A.4 (C++)",
            "谭鸿鑫",
            "#include <iostream>\n#include <sstream>\n#include <string>\n#include <map>\nusing namespace std;\n\nint string_to_int(string x){\n    stringstream ss(x);\n    int res;\n    ss >> res;\n    return res;\n}\nstring int_to_string(int x){\n    stringstream ss;\n    ss << x;\n    string res = ss.str();\n    return res;\n}\n\n\nclass Ref{\npublic:\n    int t;\n    int val;\n    Ref(/*int t,*/int val):\n    /*t(t), */val(val){}\n\n    operator int(){\n        return val;\n    }\n    operator string(){\n        return int_to_string(val);\n    }\n};\n\n\nclass HT{\nprivate:\n    map<int, int> dic;\n    //map<int, int> t; //int = 0, string = 1\n    int _size;\n\npublic:\n    HT(){\n        _size = 0;\n    }\n    void put(int key, int val){\n        dic[key] = val;\n        //t[key] = 0;\n        _size ++;\n    }\n    void put(int key, string val){\n        dic[key] = string_to_int(val);\n        //t[key] = 1;\n        _size ++;\n    }\n    void put(string key, int val){\n        dic[string_to_int(key)] = val;\n        //t[string_to_int(key)] = 0;\n        _size ++;\n    }\n    void put(string key, string val){\n        dic[string_to_int(key)] = string_to_int(val);\n        //t[string_to_int(key)] = 1;\n        _size ++;\n    }\n\n    int size(){\n        return _size;\n    }\n\n    Ref operator[](int key){\n        return Ref(/*t[key],*/ dic[key]);\n    }\n    Ref operator[](string key){\n        return Ref(/*t[string_to_int(key)],*/ dic[string_to_int(key)]);\n    }\n};\n",
            1595053820.9899468,
            100,
            "# 答案正确"
        ],
        [
            "A.5 (C++)",
            "谭鸿鑫",
            "#include <iostream>\n#include <sstream>\n#include <string>\n#include <map>\nusing namespace std;\n\nint string_to_int(string x){\n    stringstream ss(x);\n    int res;\n    ss >> res;\n    return res;\n}\nstring int_to_string(int x){\n    stringstream ss;\n    ss << x;\n    string res = ss.str();\n    return res;\n}\n\nclass HT;\n\nclass Ref{\npublic:\n    HT * map;\n    int val;\n    int key;\n    Ref(HT* map, int val, int key):\n    map(map), val(val), key(key){}\n\n    operator int(){\n        return val;\n    }\n    operator string(){\n        return int_to_string(val);\n    }\n\n    Ref & operator=(int val);\n    Ref & operator=(string val);\n};\n\n\nclass HT{\nprivate:\n    map<int, int> dic;\n    int _size;\n    friend Ref;\npublic:\n    HT(){\n        _size = 0;\n    }\n    void put(int key, int val){\n        dic[key] = val;\n        _size ++;\n    }\n    void put(int key, string val){\n        dic[key] = string_to_int(val);\n        _size ++;\n    }\n    void put(string key, int val){\n        dic[string_to_int(key)] = val;\n        _size ++;\n    }\n    void put(string key, string val){\n        dic[string_to_int(key)] = string_to_int(val);\n        _size ++;\n    }\n\n    int size(){\n        return _size;\n    }\n\n    Ref operator[](int key){\n        return Ref(this, dic[key], key);\n    }\n    Ref operator[](string key){\n        return Ref(this, dic[string_to_int(key)], string_to_int(key));\n    }\n};\n\nRef & Ref::operator=(int v){\n    map->put(key, v);\n    val = v;\n}\nRef & Ref::operator=(string v){\n    map->put(key, v);\n    val = string_to_int(v);\n}\n",
            1595054829.5261173,
            100,
            "# 答案正确"
        ],
        [
            "A.3 (C++)",
            "谭鸿鑫",
            "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <stdexcept>\nusing namespace std;\n\n#define I(i,n) for (int i = 0; i < n; ++ i)\n\nclass NoSuchKeyException {};\n\nint circular_shift(int bits, int shift_bits) {\n\tconst int num_bits = 8 * sizeof(int);\n\tshift_bits = shift_bits % num_bits;\n\treturn bits << shift_bits | bits >> (num_bits - shift_bits);\n}\n\nint hash_function(int key) {\n\tstringstream ss;\n    ss << key;\n    string res = ss.str();\n\tint code = 0;\n\tI(i, res.size())\n\t\tcode ^= circular_shift(res[i], i * 5);\n\treturn code;\n}\n\ntemplate <typename V>\nclass HT{\n\tclass Tuple\n\t{\n\tpublic:\n\t\tint key;\n\t\tV val;\n\t\tbool in_use;\n\n\t\tTuple() : in_use(false) {}\n\t};\n\n\tvector<Tuple> tuples;\n\tint _size;\n\n\tint canonical_index(const int & key) const {\n\t\tint hash_code = hash_function(key); // needs hash_function(K)\n\t\treturn hash_code % tuples.size();\n\t}\n\n\t// the returned tuple is either empty or with the same key\n\tint indexOfKey(const int & key) const {\n\t\tint index = canonical_index(key);\n\t\twhile (true) { // will enter a dead loop if there is not empty tuple\n\t\t\tif (! tuples[index].in_use) return index;\n\t\t\tif (tuples[index].key == key) return index;\n\t\t\tindex = (index + 1) % tuples.size();\n\t\t}\n\t}\n\npublic:\n\tHT() : _size(0) {\n\t\ttuples.resize(2000);\n\t}\n\n\tbool containsKey(const int & key) const {\n\t\tint index = indexOfKey(key);\n\t\treturn tuples[index].in_use;\n\t}\n\n\tconst V & operator [] (const int & key) const {\n\t\tint index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples[index].val;\n\t}\n\n\tV & operator [] (const int & key) {\n\t\tint index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples[index].val;\n\t}\n\n\tvoid put(const int & key, const V & val) {\n\t\tint index = indexOfKey(key);\n\t\ttuples[index].key = key;\n\t\ttuples[index].val = val;\n\t\tif (tuples[index].in_use) return;\n\t\ttuples[index].in_use = true;\n\t\t++ _size;\n\t\t// make sure empty > size / 2\n\t\tif (2 * _size > tuples.size())\n\t\t\t_double_tuples();\n\t}\n\n\tvoid _double_tuples() {\n\t\tvector<Tuple> non_empty_tuples;\n\t\tI(i, tuples.size())\n\t\t\tif (tuples[i].in_use)\n\t\t\t\tnon_empty_tuples.push_back(tuples[i]);\n\t\tclear();\n\t\ttuples.resize(tuples.size() * 2);\n\t\tI(i, non_empty_tuples.size())\n\t\t\tput(non_empty_tuples[i].key, non_empty_tuples[i].val);\n\t}\n\n\tstatic bool _between(size_t hole, size_t canonical, size_t tuple_index) {\n\t\tif (hole < tuple_index)\n\t\t\treturn canonical > hole && canonical <= tuple_index;\n\t\telse\n\t\t\treturn canonical > hole || canonical <= tuple_index;\n\t}\n\n\tvoid remove(const int & key) { \n\t\tint index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\ttuples[index].in_use = false;\n\t\t-- _size;\n\t\t// if there is a hole between a tuple and its canonical position\n\t\t// move the tuple to the hole\n\t\tint hole = index;\n\t\tint tuple_index = hole;\n\t\twhile (true) {\n\t\t\ttuple_index = (tuple_index + 1) % tuples.size();\n\t\t\tif (! tuples[tuple_index].in_use) return;\n\t\t\tint canonical = canonical_index(tuples[tuple_index].key);\n\t\t\tif (_between(hole, canonical, tuple_index)) continue;\n\t\t\ttuples[hole] = tuples[tuple_index];\n\t\t\thole = tuple_index;\n\t\t\ttuples[hole].in_use = false;\n\t\t}\n\t}\n\n\tint size() const { return _size; }\n\n\tvoid clear() {\n\t\tI(i, tuples.size())\n\t\t\ttuples[i].in_use = false;\n\t\t_size = 0;\n\t}\n\n\tvector<int> getKeys(){\n\t\tvector<int> res;\n\t\tfor(int i = 0;i < tuples.size();i ++){\n\t\t\tif(tuples[i].in_use == true) res.push_back(tuples[i].key);\n\t\t}\n\t\treturn res;\n\t}\n\t\n};",
            1595472131.190265,
            100,
            "# 答案正确"
        ]
    ],
    "table_name": "答案"
}