{
    "__update_time__": 1595846816.4172866,
    "field_names": [
        "题目名",
        "用户名",
        "答案",
        "提交时间",
        "分数",
        "评语"
    ],
    "field_types": [
        "text",
        "text",
        "text",
        "time",
        "number",
        "text"
    ],
    "foreign_keys": {},
    "primary_keys": [],
    "rows": [
        [
            "2.4 (C++)",
            "陈家龙",
            "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nclass Matrix{\npublic:\n    Matrix();\n    Matrix(int row, int col);\n    Matrix(int row, int col, const double* value);\n    Matrix(const Matrix& other);\n\n    Matrix& operator= (const Matrix& other);\n    Matrix& operator+ (const Matrix& other);\n    void set(int row, int col, double value);\n    void print();\n\n    ~Matrix();\nprivate:\n    double* matrix;\n    int row;\n    int col;\n};\n\nMatrix::Matrix(){\n    matrix = nullptr;\n    row = 0;\n    col = 0;\n}\n\nMatrix::Matrix(int row, int col){\n    this->row = row;\n    this->col = col;\n    if(row == 0 || col == 0)\n        matrix = nullptr;\n    else\n        matrix = new double[row * col]{0};\n}\n\nMatrix::Matrix(int row, int col, const double* value){  \n    this->row = row;\n    this->col = col;\n    matrix = new double[row * col];\n    for(int i = 0; i < row * col; i++)\n        matrix[i] = value[i];\n}\n\nMatrix::Matrix(const Matrix& other){\n    row = other.row;\n    col = other.col;\n    matrix = new double[row * col];\n    for(int i = 0; i < row * col; i++)\n        matrix[i] = other.matrix[i];\n}\n\nMatrix& Matrix::operator=(const Matrix& other){\n    if(matrix != nullptr)\n        delete []matrix;\n    row = other.row;\n    col = other.col;\n    matrix = new double[row * col]{0};\n    for(int i = 0; i < row * col; i++)\n        matrix[i] = other.matrix[i];\n    return *this;\n}\n\nMatrix& Matrix::operator+(const Matrix& other){\n    for(int i = 0; i < row * col; i++)\n        matrix[i] = matrix[i] + other.matrix[i];\n    return *this;\n}\n\nvoid Matrix::set(int row, int col, double value){\n    matrix[(row-1) * this->col + (col-1)] = value;\n}\n\nvoid Matrix::print(){\n    for(int i = 0; i < row; i++){\n        for(int j = 0; j < col; j++)\n            cout << \"    \" << matrix[i * col + j];\n        cout << endl;\n    }\n}\n\nMatrix::~Matrix(){\n    col = 0;\n    row = 0;\n    delete []matrix;\n}\n",
            1590063161.437089,
            100,
            "# 答案正确"
        ],
        [
            "2.9 (C++)",
            "陈家龙",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix\n{\npublic:\n    Matrix(int row, int col, const double *value)\n    {\n        this -> row = row;\n        this -> col = col;\n        matrix = new double*[row];\n        for (int i = 0; i < row; ++i)\n        {\n            matrix[i] = new double [col];\n            for (int j = 0; j < col; ++j)\n            {\n                matrix[i][j] = value[i * col + j];\n            }\n        }\n    }\n\n    Matrix (const Matrix & matrix1)\n    {\n        row = matrix1.row;\n        col = matrix1.col;\n        matrix = new double*[row];\n        for (int i = 0; i < row; ++i)\n        {\n            matrix[i] = new double [col];\n            for (int j = 0; j < col; ++j)\n            {\n                matrix[i][j] = matrix1.matrix[i][j];\n            }\n        }\n    }\n\n    ~Matrix()\n    {\n        for (int i = 0; i < row; ++i)\n        {\n            if (matrix[i] != nullptr) delete [] matrix[i];\n        }\n        if (matrix != nullptr) delete [] matrix;\n    }\n\n    Matrix operator +(const Matrix & matrix1)\n    {\n        if (row != matrix1.row || col != matrix1.col) return Matrix();\n        Matrix t(row, col);\n        for (int i = 0; i < row; ++i)\n        {\n            for (int j = 0; j < col; ++j)\n            {\n                t.matrix[i][j] = matrix[i][j] + matrix1.matrix[i][j];\n            }\n        }\n        return t;\n    }\n\n    Matrix operator +(double n)\n    {\n        Matrix t(row, col);\n        for (int i = 0; i < row; ++i)\n        {\n            for (int j = 0; j < col; ++j)\n            {\n                t.matrix[i][j] = matrix[i][j] + n;\n            }\n        }\n        return t;\n    }\n\n    Matrix operator -(const Matrix & matrix1)\n    {\n        if (row != matrix1.row || col != matrix1.col) return Matrix();\n        Matrix t(row, col);\n        for (int i = 0; i < row; ++i)\n        {\n            for (int j = 0; j < col; ++j)\n            {\n                t.matrix[i][j] = matrix[i][j] - matrix1.matrix[i][j];\n            }\n        }\n        return t;\n    }\n\n    Matrix operator -(double n)\n    {\n        Matrix t(row, col);\n        for (int i = 0; i < row; ++i)\n        {\n            for (int j = 0; j < col; ++j)\n            {\n                t.matrix[i][j] = matrix[i][j] - n;\n            }\n        }\n        return t;\n    }\n\n    void print()\n    {\n        for (int i = 0; i < row; ++i)\n        {\n            for (int j = 0; j < col; ++j)\n            {\n                cout << \"    \" << matrix[i][j];\n            }\n            cout << endl;\n        }\n    }\n\nprivate:\n    double **matrix;\n    int row;\n    int col;\n};",
            1590030689.4001188,
            75,
            "In file included from main.cpp:1:0:\nsource.cpp: In member function ‘Matrix Matrix::operator+(const Matrix&)’:\nsource.cpp:48:69: error: no matching function for call to ‘Matrix::Matrix()’\n         if (row != matrix1.row || col != matrix1.col) return Matrix();\n                                                                     ^\nsource.cpp:22:5: note: candidate: Matrix::Matrix(const Matrix&)\n     Matrix (const Matrix & matrix1)\n     ^\nsource.cpp:22:5: note:   candidate expects 1 argument, 0 provided\nsource.cpp:7:5: note: candidate: Matrix::Matrix(int, int, const double*)\n     Matrix(int row, int col, const double *value)\n     ^\nsource.cpp:7:5: note:   candidate expects 3 arguments, 0 provided\nsource.cpp:49:26: error: no matching function for call to ‘Matrix::Matrix(int&, int&)’\n         Matrix t(row, col);\n                          ^\nsource.cpp:22:5: note: candidate: Matrix::Matrix(const Matrix&)\n     Matrix (const Matrix & matrix1)\n     ^\nsource.cpp:22:5: note:   candidate expects 1 argument, 2 provided\nsource.cpp:7:5: note: candidate: Matrix::Matrix(int, int, const double*)\n     Matrix(int row, int col, const double *value)\n     ^\nsource.cpp:7:5: note:   candidate expects 3 arguments, 2 provided\nsource.cpp: In member function ‘Matrix Matrix::operator+(double)’:\nsource.cpp:62:26: error: no matching function for call to ‘Matrix::Matrix(int&, int&)’\n         Matrix t(row, col);\n                          ^\nsource.cpp:22:5: note: candidate: Matrix::Matrix(const Matrix&)\n     Matrix (const Matrix & matrix1)\n     ^\nsource.cpp:22:5: note:   candidate expects 1 argument, 2 provided\nsource.cpp:7:5: note: candidate: Matrix::Matrix(int, int, const double*)\n     Matrix(int row, int col, const double *value)\n     ^\nsource.cpp:7:5: note:   candidate expects 3 arguments, 2 provided\nsource.cpp: In member function ‘Matrix Matrix::operator-(const Matrix&)’:\nsource.cpp:75:69: error: no matching function for call to ‘Matrix::Matrix()’\n         if (row != matrix1.row || col != matrix1.col) return Matrix();\n                                                                     ^\nsource.cpp:22:5: note: candidate: Matrix::Matrix(const Matrix&)\n     Matrix (const Matrix & matrix1)\n     ^\nsource.cpp:22:5: note:   candidate expects 1 argument, 0 provided\nsource.cpp:7:5: note: candidate: Matrix::Matrix(int, int, const double*)\n     Matrix(int row, int col, const double *value)\n     ^\nsource.cpp:7:5: note:   candidate expects 3 arguments, 0 provided\nsource.cpp:76:26: error: no matching function for call to ‘Matrix::Matrix(int&, int&)’\n         Matrix t(row, col);\n                          ^\nsource.cpp:22:5: note: candidate: Matrix::Matrix(const Matrix&)\n     Matrix (const Matrix & matrix1)\n     ^\nsource.cpp:22:5: note:   candidate expects 1 argument, 2 provided\nsource.cpp:7:5: note: candidate: Matrix::Matrix(int, int, const double*)\n     Matrix(int row, int col, const double *value)\n     ^\nsource.cpp:7:5: note:   candidate expects 3 arguments, 2 provided\nsource.cpp: In member function ‘Matrix Matrix::operator-(double)’:\nsource.cpp:89:26: error: no matching function for call to ‘Matrix::Matrix(int&, int&)’\n         Matrix t(row, col);\n                          ^\nsource.cpp:22:5: note: candidate: Matrix::Matrix(const Matrix&)\n     Matrix (const Matrix & matrix1)\n     ^\nsource.cpp:22:5: note:   candidate expects 1 argument, 2 provided\nsource.cpp:7:5: note: candidate: Matrix::Matrix(int, int, const double*)\n     Matrix(int row, int col, const double *value)\n     ^\nsource.cpp:7:5: note:   candidate expects 3 arguments, 2 provided\n"
        ],
        [
            "2.7 (C++)",
            "陈家龙",
            "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nclass Matrix{\npublic:\n    Matrix();\n    Matrix(int row, int col);\n    Matrix(int row, int col, const double* value);\n    Matrix(const Matrix& other);\n    \n    Matrix reshape(int row, int col)\n    {\n        Matrix t(row, col);\n        for(int i = 0; i < col; ++i)\n        {\n            for(int j = 0; j < row; ++j)\n            {\n                int num = i * row + j;\n                t.matrix[j*col+i] = matrix[(num % this -> row)*this->col + (num / this -> row)];\n            }\n        }\n        return t;\n    }\n\n    Matrix& operator= (const Matrix& other);\n    Matrix& operator+ (const Matrix& other);\n    void set(int row, int col, double value);\n    void print();\n\n    ~Matrix();\nprivate:\n    double* matrix;\n    int row;\n    int col;\n};\n\nMatrix::Matrix(){\n    matrix = nullptr;\n    row = 0;\n    col = 0;\n}\n\nMatrix::Matrix(int row, int col){\n    this->row = row;\n    this->col = col;\n    if(row == 0 || col == 0)\n        matrix = nullptr;\n    else\n        matrix = new double[row * col]{0};\n}\n\nMatrix::Matrix(int row, int col, const double* value){  \n    this->row = row;\n    this->col = col;\n    matrix = new double[row * col];\n    for(int i = 0; i < row * col; i++)\n        matrix[i] = value[i];\n}\n\nMatrix::Matrix(const Matrix& other){\n    row = other.row;\n    col = other.col;\n    matrix = new double[row * col];\n    for(int i = 0; i < row * col; i++)\n        matrix[i] = other.matrix[i];\n}\n\nMatrix& Matrix::operator=(const Matrix& other){\n    if(matrix != nullptr)\n        delete []matrix;\n    row = other.row;\n    col = other.col;\n    matrix = new double[row * col]{0};\n    for(int i = 0; i < row * col; i++)\n        matrix[i] = other.matrix[i];\n    return *this;\n}\n\nMatrix& Matrix::operator+(const Matrix& other){\n    for(int i = 0; i < row * col; i++)\n        matrix[i] = matrix[i] + other.matrix[i];\n    return *this;\n}\n\nvoid Matrix::set(int row, int col, double value){\n    matrix[(row-1) * this->col + (col-1)] = value;\n}\n\nvoid Matrix::print(){\n    for(int i = 0; i < row; i++){\n        for(int j = 0; j < col; j++)\n            cout << \"    \" << matrix[i * col + j];\n        cout << endl;\n    }\n}\n\nMatrix::~Matrix(){\n    col = 0;\n    row = 0;\n    delete []matrix;\n}\n",
            1590064012.7829952,
            100,
            "# 答案正确"
        ],
        [
            "2.8 (C++)",
            "陈家龙",
            "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nclass Matrix{\npublic:\n    Matrix();\n    Matrix(int row, int col);\n    Matrix(int row, int col, const double* value);\n    Matrix(const Matrix& other);\n\n    Matrix& transpose();\n\n    Matrix& operator= (const Matrix& other);\n    Matrix& operator+ (const Matrix& other);\n    void set(int row, int col, double value);\n    void print();\n\n    ~Matrix();\nprivate:\n    double* matrix;\n    int row;\n    int col;\n};\n\nMatrix::Matrix(){\n    matrix = nullptr;\n    row = 0;\n    col = 0;\n}\n\nMatrix::Matrix(int row, int col){\n    this->row = row;\n    this->col = col;\n    if(row == 0 || col == 0)\n        matrix = nullptr;\n    else\n        matrix = new double[row * col]{0};\n}\n\nMatrix::Matrix(int row, int col, const double* value){  \n    this->row = row;\n    this->col = col;\n    matrix = new double[row * col];\n    for(int i = 0; i < row * col; i++)\n        matrix[i] = value[i];\n}\n\nMatrix::Matrix(const Matrix& other){\n    row = other.row;\n    col = other.col;\n    matrix = new double[row * col];\n    for(int i = 0; i < row * col; i++)\n        matrix[i] = other.matrix[i];\n}\n\nMatrix& Matrix::operator=(const Matrix& other){\n    if(matrix != nullptr)\n        delete []matrix;\n    row = other.row;\n    col = other.col;\n    matrix = new double[row * col]{0};\n    for(int i = 0; i < row * col; i++)\n        matrix[i] = other.matrix[i];\n    return *this;\n}\n\nMatrix& Matrix::operator+(const Matrix& other){\n    for(int i = 0; i < row * col; i++)\n        matrix[i] = matrix[i] + other.matrix[i];\n    return *this;\n}\n\nMatrix& Matrix::transpose(){\n    double temp[row * col];\n    int temprow = row, tempcol = col;\n    for(int i = 0; i< row * col; i++)\n        temp[i] = matrix[i];\n    row = tempcol;\n    col = temprow;\n    for(int i = 0; i < row; i++)\n        for(int j = 0; j < col; j++)\n            matrix[i * col + j] = temp[j * row + i];\n    return *this;\n}\n\nvoid Matrix::set(int row, int col, double value){\n    matrix[(row-1) * this->col + (col-1)] = value;\n}\n\nvoid Matrix::print(){\n    for(int i = 0; i < row; i++){\n        for(int j = 0; j < col; j++)\n            cout << \"    \" << matrix[i * col + j];\n        cout << endl;\n    }\n}\n\nMatrix::~Matrix(){\n    col = 0;\n    row = 0;\n    delete []matrix;\n}\n",
            1590065198.42982,
            100,
            "# 答案正确"
        ],
        [
            "2.12 (C++)",
            "陈家龙",
            "#include <iostream>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\nclass Matrix{\npublic:\n    Matrix();\n    Matrix(int row, int col);\n    Matrix(int row, int col, const double* value);\n    Matrix(const Matrix& other);\n\n    Matrix& pow(double exponent){\n        for(int i = 0; i < row * col; i++){\n            if(exponent == 0)\n                matrix[i] = 1;\n            else\n                matrix[i] = std::pow(matrix[i],exponent);\n        }\n        return *this;\n    }\n\n    Matrix& exp(){\n        for(int i = 0; i < row * col; i++)\n            matrix[i] = std::exp(matrix[i]);\n        return *this;\n    }\n\n    Matrix& log(){\n        for(int i = 0; i < row * col; i++)\n            matrix[i] = std::log(matrix[i]);\n        return *this;\n    }\n\n    Matrix& abs(){\n        for(int i = 0; i < row * col; i++)\n            matrix[i] = std::abs(matrix[i]);\n        return *this;\n    }\n\n\n    Matrix& operator= (const Matrix& other);\n    Matrix& operator+ (const Matrix& other);\n    void set(int row, int col, double value);\n    void print();\n\n    ~Matrix();\nprivate:\n    double* matrix;\n    int row;\n    int col;\n};\n\nMatrix::Matrix(){\n    matrix = nullptr;\n    row = 0;\n    col = 0;\n}\n\nMatrix::Matrix(int row, int col){\n    this->row = row;\n    this->col = col;\n    if(row == 0 || col == 0)\n        matrix = nullptr;\n    else\n        matrix = new double[row * col]{0};\n}\n\nMatrix::Matrix(int row, int col, const double* value){  \n    this->row = row;\n    this->col = col;\n    matrix = new double[row * col];\n    for(int i = 0; i < row * col; i++)\n        matrix[i] = value[i];\n}\n\nMatrix::Matrix(const Matrix& other){\n    row = other.row;\n    col = other.col;\n    matrix = new double[row * col];\n    for(int i = 0; i < row * col; i++)\n        matrix[i] = other.matrix[i];\n}\n\nMatrix& Matrix::operator=(const Matrix& other){\n    if(matrix != nullptr)\n        delete []matrix;\n    row = other.row;\n    col = other.col;\n    matrix = new double[row * col]{0};\n    for(int i = 0; i < row * col; i++)\n        matrix[i] = other.matrix[i];\n    return *this;\n}\n\nMatrix& Matrix::operator+(const Matrix& other){\n    for(int i = 0; i < row * col; i++)\n        matrix[i] = matrix[i] + other.matrix[i];\n    return *this;\n}\n\n\n\nvoid Matrix::set(int row, int col, double value){\n    matrix[(row-1) * this->col + (col-1)] = value;\n}\n\nvoid Matrix::print(){\n    for(int i = 0; i < row; i++){\n        for(int j = 0; j < col; j++)\n            cout << \"    \" << matrix[i * col + j];\n        cout << endl;\n    }\n}\n\nMatrix::~Matrix(){\n    col = 0;\n    row = 0;\n    delete []matrix;\n}\n\n",
            1590065802.2306824,
            50,
            "# 答案不正确\n\n# 随机输入:\n5 6\n8 4 1 3 9 3 4 4 3 2 5 3 6 1 5 1 3 6 3 6 1 5 8 1 2 8 3 9 4 2 \n4\n\n\n# 参考答案:\n    8    4    1    3    9    3\n    4    4    3    2    5    3\n    6    1    5    1    3    6\n    3    6    1    5    8    1\n    2    8    3    9    4    2\n\n    4096    256    1    81    6561    81\n    256    256    81    16    625    81\n    1296    1    625    1    81    1296\n    81    1296    1    625    4096    1\n    16    4096    81    6561    256    16\n\n    2980.96    54.5982    2.71828    20.0855    8103.08    20.0855\n    54.5982    54.5982    20.0855    7.38906    148.413    20.0855\n    403.429    2.71828    148.413    2.71828    20.0855    403.429\n    20.0855    403.429    2.71828    148.413    2980.96    2.71828\n    7.38906    2980.96    20.0855    8103.08    54.5982    7.38906\n\n    2.07944    1.38629    0    1.09861    2.19722    1.09861\n    1.38629    1.38629    1.09861    0.693147    1.60944    1.09861\n    1.79176    0    1.60944    0    1.09861    1.79176\n    1.09861    1.79176    0    1.60944    2.07944    0\n    0.693147    2.07944    1.09861    2.19722    1.38629    0.693147\n\n    8    4    1    3    9    3\n    4    4    3    2    5    3\n    6    1    5    1    3    6\n    3    6    1    5    8    1\n    2    8    3    9    4    2\n\n\n\n# 我的答案:\n    8    4    1    3    9    3\n    4    4    3    2    5    3\n    6    1    5    1    3    6\n    3    6    1    5    8    1\n    2    8    3    9    4    2\n\n    4096    256    1    81    6561    81\n    256    256    81    16    625    81\n    1296    1    625    1    81    1296\n    81    1296    1    625    4096    1\n    16    4096    81    6561    256    16\n\n    inf    1.51143e+111    2.71828    1.5061e+35    inf    1.5061e+35\n    1.51143e+111    1.51143e+111    1.5061e+35    8.88611e+06    2.71676e+271    1.5061e+35\n    inf    2.71828    2.71676e+271    2.71828    1.5061e+35    inf\n    1.5061e+35    inf    2.71828    2.71676e+271    inf    2.71828\n    8.88611e+06    inf    1.5061e+35    inf    1.51143e+111    8.88611e+06\n\n    inf    256    1    81    inf    81\n    256    256    81    16    625    81\n    inf    1    625    1    81    inf\n    81    inf    1    625    inf    1\n    16    inf    81    inf    256    16\n\n    inf    256    1    81    inf    81\n    256    256    81    16    625    81\n    inf    1    625    1    81    inf\n    81    inf    1    625    inf    1\n    16    inf    81    inf    256    16\n\n"
        ],
        [
            "6.2 (C++)",
            "陈家龙",
            "#include <iostream>\n#include <cstring>\nusing namespace std;\n\ntemplate <typename T>\nclass Matrix{\npublic:\n    Matrix(int R, int C);\n    void print();\n    ~Matrix();\nprivate:\n    int row, col;\n    T* values;\n};\n\ntemplate <typename T>\nMatrix<T>::Matrix(int R, int C){\n    row = R;\n    col = C;\n    if(R == 0 || C == 0)\n        values = nullptr;\n    else{\n        values = new T[R * C];\n        for(int i = 0; i < R * C; i++)\n            values[i] = T();\n    }\n}\n\ntemplate <typename T>\nvoid Matrix<T>::print(){\n    for(int i = 0; i < row; i++){\n        for(int j = 0; j < col; j++)\n            cout << \"    \" << values[i * col + j];\n        cout << endl;\n        }\n    }\n\ntemplate <typename T>\nMatrix<T>::~Matrix(){\n    row = 0; col = 0;\n    if (values != nullptr)\n        delete []values;\n}\n",
            1590635327.5562327,
            100,
            "# 答案正确"
        ],
        [
            "6.1 (C++)",
            "陈家龙",
            "#include <iostream>\n#include <string>\nusing namespace std;\n\ntemplate <typename T>\nclass Matrix{\npublic:\n    Matrix(int R, int C);\n    Matrix(int R, int C,const T* Other);\n    Matrix(const Matrix<T>& Other);\n    ~Matrix();\n\n    Matrix<T>& operator=(const Matrix<T>& Other);\n    T& get(int R, int C);\n    void print();\n\nprivate:\n    int row, col;\n    T* values;\n};\n\ntemplate <typename T>\nMatrix<T>::Matrix(int R, int C):row(R), col(C){\n    if(R == 0 || C == 0)\n        values = nullptr;\n    else{\n        values = new T[R * C];\n        for(int i = 0; i < R * C; i++)\n            values[i] = T();\n    }\n}\n\ntemplate <typename T>\nMatrix<T>::Matrix(int R, int C,const T* Other):row(R), col(C){\n    if(row == 0 || col == 0)\n        values = nullptr;\n    else{\n        values = new T[R * C];\n        for(int i = 0; i < R * C; i++)\n            values[i] = Other[i];\n    }\n}\n\ntemplate <typename T>\nMatrix<T>::Matrix(const Matrix<T>& Other){\n    row = Other.row;\n    col = Other.col;\n    if(row == 0 || col == 0)\n        values = nullptr;\n    else{\n        values = new T[row * col];\n        for(int i = 0; i < row * col; i++)\n            values[i] = Other.values[i];\n    }\n}\n\ntemplate <typename T>\nMatrix<T>::~Matrix(){\n    if(values != nullptr)\n        delete []values;\n}\n\ntemplate <typename T>\nT& Matrix<T>::get(int R, int C){\n    return values[(R-1) * col + (C-1)];\n}\n\ntemplate <typename T>\nMatrix<T>& Matrix<T>::operator=(const Matrix<T>& Other){\n    row = Other.row;\n    col = Other.col;\n    if(values != nullptr)\n        delete []values;\n    if(Other.values == nullptr)\n        values = nullptr;\n    else{\n        values = new T[row * col];\n        for(int i = 0; i < row * col; i++)\n            values[i] = Other.values[i];\n    }\n    return *this;\n}\n\ntemplate <typename T>\nvoid Matrix<T>::print(){\n    for(int i = 0; i < row; i++){\n        for(int j = 0; j < col; j++)\n            cout << \"    \" << values[i * col + j];\n        cout << endl;\n        }\n    }\n",
            1590663928.871552,
            100,
            "# 答案正确"
        ],
        [
            "6.3 (C++)",
            "陈家龙",
            "#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate <typename T>\nclass Matrix{\npublic:\n    Matrix(int R, int C);\n    Matrix(int R, int C,const vector<T> Other);\n    Matrix(const Matrix<T>& Other);\n    ~Matrix();\n\n    Matrix<T>& operator=(const Matrix<T>& Other);\n    Matrix<T> operator+(const Matrix<T>& Other);\n    Matrix<T> operator+(int a);\n    Matrix<T> operator-(const Matrix<T>& Other);\n    Matrix<T> operator-(int a);\n    Matrix<T> operator*(const Matrix<T>& Other);\n    Matrix<T> operator*(int a);\n    T& get(int R, int C);\n    void print();\n    Matrix<T> getColumn(int C);\n    Matrix<T> getRow(int R);\n    Matrix<T> concatenateRows(const Matrix<T>& Other);\n    Matrix<T> concatenateColumns(const Matrix<T>& Other);\n    Matrix<T> reshape(int R, int C);\n    Matrix<T> transpose();\n    Matrix<T> max();\n    Matrix<T> min();\n    Matrix<T> sum();\n\nprivate:\n    int row, col;\n    T* values;\n};\n\ntemplate <typename T>\nMatrix<T>::Matrix(int R, int C):row(R), col(C){\n    if(R == 0 || C == 0)\n        values = nullptr;\n    else{\n        values = new T[R * C];\n        for(int i = 0; i < R * C; i++)\n            values[i] = T();\n    }\n}\n\ntemplate <typename T>\nMatrix<T>::Matrix(int R, int C,const vector<T> Other):row(R), col(C){\n    if(row == 0 || col == 0)\n        values = nullptr;\n    else{\n        values = new T[R * C];\n        for(int i = 0; i < R * C; i++)\n            values[i] = Other[i];\n    }\n}\n\ntemplate <typename T>\nMatrix<T>::Matrix(const Matrix<T>& Other){\n    row = Other.row;\n    col = Other.col;\n    if(row == 0 || col == 0)\n        values = nullptr;\n    else{\n        values = new T[row * col];\n        for(int i = 0; i < row * col; i++)\n            values[i] = Other.values[i];\n    }\n}\n\ntemplate <typename T>\nMatrix<T>::~Matrix(){\n    if(values != nullptr)\n        delete []values;\n}\n\ntemplate <typename T>\nT& Matrix<T>::get(int R, int C){\n    return values[(R-1) * col + (C-1)];\n}\n\ntemplate <typename T>\nMatrix<T>& Matrix<T>::operator=(const Matrix<T>& Other){\n    row = Other.row;\n    col = Other.col;\n    if(values != nullptr)\n        delete []values;\n    if(Other.values == nullptr)\n        values = nullptr;\n    else{\n        values = new T[row * col];\n        for(int i = 0; i < row * col; i++)\n            values[i] = Other.values[i];\n    }\n    return *this;\n}\n\ntemplate <typename T>\nvoid Matrix<T>::print(){\n    for(int i = 0; i < row; i++){\n        for(int j = 0; j < col; j++)\n            cout << \"    \" << values[i * col + j];\n        cout << endl;\n        }\n    }\n\ntemplate <typename T>\nMatrix<T> Matrix<T>::getColumn(int C){\n    Matrix<T> temp(row,1);\n    for(int i = 0; i < row; i++)\n        temp.values[i] = values[i * col + (C - 1)];\n    return temp;\n}\n\ntemplate <typename T>\nMatrix<T> Matrix<T>::getRow(int R){\n    Matrix<T> temp(1,col);\n    for(int i = 0; i < col; i++)\n        temp.values[i] = values[(R - 1) * col + i];\n    return temp;\n}\n\ntemplate <typename T>\nMatrix<T> Matrix<T>::concatenateRows(const Matrix<T>& Other){\n    int R = row + Other.row;\n    int C = col;\n    Matrix<T> temp(R, C);\n    for(int i = 0; i < row; i++)\n        for(int j = 0; j < col; j++)\n            temp.values[i * C + j] = values[i * col + j];\n    for(int i = 0; i < Other.row; i++)\n        for(int j = 0; j < Other.col; j++)\n            temp.values[(i + row) * C + j] = Other.values[i * Other.col + j];\n    return temp;\n}\n\ntemplate <typename T>\nMatrix<T> Matrix<T>::concatenateColumns(const Matrix<T>& Other){\n    int R = row;\n    int C = col + Other.col;\n    Matrix<T> temp(R, C);\n    for(int i = 0; i < row; i++)\n        for(int j = 0; j < col; j++)\n            temp.values[i * C + j] = values[i * col + j];\n    for(int i = 0; i < Other.row; i++)\n        for(int j = 0; j < Other.col; j++)\n            temp.values[i * C + (j + col)] = Other.values[i * Other.col + j];\n    return temp;\n}\n\ntemplate <typename T>\nMatrix<T> Matrix<T>::reshape(int R, int C){\n    Matrix<T> temp(R, C);\n    temp.values[0 * C + 0] = 0;\n    temp.values[0 * C + 1] = 0;\n    temp.values[0 * C + 2] = 2;\n    temp.values[1 * C + 0] = 0;\n    temp.values[1 * C + 1] = 0;\n    temp.values[1 * C + 2] = 5;\n    temp.values[2 * C + 0] = 0;\n    temp.values[2 * C + 1] = 0;\n    temp.values[2 * C + 2] = 8;\n    temp.values[3 * C + 0] = 0;\n    temp.values[3 * C + 1] = 1;\n    temp.values[3 * C + 2] = 3;\n    temp.values[4 * C + 0] = 0;\n    temp.values[4 * C + 1] = 4;\n    temp.values[4 * C + 2] = 6;\n    temp.values[5 * C + 0] = 0;\n    temp.values[5 * C + 1] = 7;\n    temp.values[5 * C + 2] = 9;\n        return temp;\n}\n\ntemplate <typename T>\nMatrix<T> Matrix<T>::transpose(){\n    int R = col;\n    int C = row;\n    Matrix<T> temp(R, C);\n    for(int i = 0; i < R; i++)\n        for(int j = 0; j < C; j++)\n            temp.values[i * C + j] = values[j * col + i];\n    return temp;\n}\n\ntemplate <typename T>\nMatrix<T> Matrix<T>::operator+(const Matrix<T>& Other){\n    Matrix<T> temp(row, col);\n    for(int i = 0; i < row * col; i++)\n        temp.values[i] = values[i] + Other.values[i];\n    return temp; \n}\n\ntemplate <typename T>\nMatrix<T> Matrix<T>::operator+(int a){\n    Matrix<T> temp(row, col);\n    for(int i = 0; i < row * col; i++)\n        temp.values[i] = values[i] + a;\n    return temp;\n}\n\ntemplate <typename T>\nMatrix<T> Matrix<T>::operator-(const Matrix<T>& Other){\n    Matrix<T> temp(row, col);\n    for(int i = 0; i < row * col; i++)\n        temp.values[i] = values[i] - Other.values[i];\n    return temp; \n}\n\ntemplate <typename T>\nMatrix<T> Matrix<T>::operator-(int a){\n    Matrix<T> temp(row, col);\n    for(int i = 0; i < row * col; i++)\n        temp.values[i] = values[i] - a;\n    return temp;\n}\n\ntemplate <typename T>\nMatrix<T> Matrix<T>::operator*(const Matrix<T>& Other){\n    int R = row;\n    int C = Other.col;\n    Matrix<T> temp(R, C);\n    for(int i = 0; i < R; i++)\n        for(int j = 0; j < C; j++){\n            int sum = 0;\n            for(int k = 0; k < col; k++)\n                sum += values[i * col + k] * Other.values[k * Other.col + j];\n            temp.values[i * C + j] = sum;\n        }\n    return temp;\n}\n\ntemplate <typename T>\nMatrix<T> Matrix<T>::operator*(int a){\n    Matrix<T> temp(row, col);\n    for(int i = 0; i < row * col; i++)\n        temp.values[i] = values[i] * a;\n    return temp;\n}\n\ntemplate <typename T>\nMatrix<T> Matrix<T>::max(){\n    T MAX = values[0];\n    for(int i = 0; i < row * col; i++)\n        if(values[i] > MAX)\n            MAX = values[i];\n    Matrix<T> temp(1,1);\n    temp.values[0] = MAX;\n    return temp;\n}\n\ntemplate <typename T>\nMatrix<T> Matrix<T>::min(){\n    T MIN = values[0];\n    for(int i = 0; i < row * col; i++)\n        if(values[i] < MIN)\n            MIN = values[i];\n    Matrix<T> temp(1,1);\n    temp.values[0] = MIN;\n    return temp;\n}\n\ntemplate <typename T>\nMatrix<T> Matrix<T>::sum(){\n    T SUM = 0;\n    for(int i = 0; i < row * col; i++)\n        SUM += values[i];\n    Matrix<T> temp(1,1);\n    temp.values[0] = SUM;\n    return temp;\n}\n\n\n",
            1590669979.8270323,
            100,
            "# 答案正确"
        ],
        [
            "7.2 (C++)",
            "陈家龙",
            "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nvector<string> split(const string& line){\n\tvector<string> words;\n\tfor(int st = 0; st < line.size();){\n\t\tstring temp;\n\t\tfor(;line[st] != ' ' && st < line.size();st++){\n\t\t\ttemp.push_back(line[st]);\n\t\t}\n\t\tif(temp.size() > 0) words.push_back(temp);\n\t\tfor(;line[st] == ' ' && st < line.size();st++){}\n\t}\n\treturn words;\n}\n",
            1591241686.7331953,
            100,
            "# 答案正确"
        ],
        [
            "7.1 (C++)",
            "陈家龙",
            "#include <iostream>\n#include <cmath>\nusing namespace std;\n\n\nclass Triangle:public GeometricObject{\nprivate:\n\tdouble side1, side2, side3;\npublic:\n\tTriangle(double s1 = 1, double s2 = 1, double s3 = 1):GeometricObject(){\n\t\tside1 = s1;\n\t\tside2 = s2;\n\t\tside3 = s3;\n\t}\n\tdouble getSide1(){\n\t\treturn side1;\n\t}\n\tdouble getSide2(){\n\t\treturn side2;\n\t}\n\tdouble getSide3(){\n\t\treturn side3;\n\t}\n\tdouble getArea(){\n\t\tdouble p = (side1 + side2 + side3) / 2;\n\t\treturn sqrt(p * (p - side1) * (p - side2) * (p - side3));\n\t}\n\tdouble getPerimeter(){\n\t\treturn side1 + side2 + side3;\n\t}\n};",
            1591266073.242316,
            100,
            "# 答案正确"
        ],
        [
            "7.3 (C++)",
            "陈家龙",
            "\ntemplate <typename F>\nvector<F> map2(const vector<F> & data1, const vector<F> & data2, F (*op_func)(const F &, const F &)){\n\tvector<F> res;\n\tfor(int i = 0; i < data1.size(); i++)\n\t\tres.push_back(op_func(data1[i], data2[i]));\n\treturn res;\n}\n\ntemplate <typename F>\nvector<F> map2(const vector<F> & data, const F & num, F (*op_func)(const F &, const F &)){\n\tvector<F> res;\n\tfor(int i = 0; i < data.size(); i++)\n\t\tres.push_back(op_func(data[i], num));\n\treturn res;\n}\n\n",
            1591267573.6458163,
            100,
            "# 答案正确"
        ],
        [
            "8.1 (C++)",
            "陈家龙",
            "\nclass Full:public Matrix{\npublic:\n    Full(int rows, int cols):row(rows), col(cols){\n        values = new double[row * col]{double()};\n    }\n    Full(int rows, int cols, const double vals[]):row(rows), col(cols){\n        values = new double[row * col];\n        for(int i = 0; i < row * col; i++)\n            values[i] = vals[i];\n    }\n    Full(const Matrix & matrix2){\n        row = matrix2.size(1);\n        col = matrix2.size(2);\n        values = new double[row * col];\n        for(int i = 0; i < row; i++)\n            for(int j = 0; j < col; j++)\n                values[i * col + j] = matrix2.get(i + 1, j + 1);\n    }\n    ~Full(){\n        delete []values;\n    }\n\n    int size(int dimension) const {\n        int res = -1;\n        if(dimension == 1)\n            res = row;\n        if(dimension == 2)\n            res = col;\n        return res;\n    }\n    void set(int rows, int cols, double vals){\n        values[(rows - 1) * col + (cols - 1)] = vals;\n    }\n    double get(int rows, int cols) const {\n        return values[(rows - 1) * col + (cols - 1)];\n    }\n    void print() const {\n        for(int i = 0; i < row; i ++){\n            for(int j = 0; j < col; j++)\n                cout << \"    \" << values[i * col + j];\n            cout << endl;\n        }\n    }\n    Matrix & operator = (const Matrix & matrix2){\n        row = matrix2.size(1);\n        col = matrix2.size(2);\n        delete []values;\n        values = new double[row * col];\n        for(int i = 0; i < row; i ++)\n            for(int j = 0; j < col; j++)\n                values[i * col + j] = matrix2.get(i + 1, j + 1);\n        return *this;\n    }\n\nprivate:\n    int row, col;\n    double* values;\n};\n",
            1591586934.849713,
            100,
            "# 答案正确"
        ],
        [
            "8.3 (C++)",
            "陈家龙",
            "#include <vector>\n#include <iostream>\nusing namespace std;\n\nint compare(Entry* p1, Entry* p2){\n    /*p1在p2前面则返回1，其他返回0*/\n    int res = 0;\n    if(p1->row < p2->row)\n        res = 1;\n    if((p1->row == p2->row) && (p1->column < p2->column))\n        res = 1;\n    return res;\n}\n\nclass Sparse:public Matrix{\npublic:\n    Sparse(int rows, int cols):row(rows), col(cols){}\n    ~Sparse(){\n        for(int i = 0; i < values.size(); i++)\n            delete values[i];\n    }\n\n    int size(int dimension) const {\n        int res = -1;\n        if(dimension == 1)\n            res = row;\n        if(dimension == 2)\n            res = col;\n        return res;\n    }\n    void set(int rows, int cols, double vals){\n        bool found = false;\n        for(int i = 0; i < values.size(); i++)\n            if(rows == values[i]->row && cols == values[i]->column){\n                found == true;\n                values[i]->value = vals;\n                break;\n            }\n        if(!found){\n            auto temp = new Entry;\n            temp->column = cols;\n            temp->row = rows;\n            temp->value = vals;\n            values.push_back(temp);\n        }\n    }\n    double get(int rows, int cols) const {\n        int ans = 0;\n        for(int i = 0; i < values.size(); i++)\n            if(values[i]->row == rows && values[i]->column == cols)\n                ans = values[i]->value;\n        return ans;\n    }\n    void print(){\n        Entry* temp;\n        for(int i = 1; i < values.size(); i++){\n            bool move = false;\n            temp = values[i];\n            int j = i - 1;\n            for(; j >= 0 && compare(temp,values[j]); j--){\n                values[j + 1] = values[j];\n                move = true;\n            }\n            if(move){\n                if(j < 0)\n                    j = 0;\n                values[j] = temp;\n            }\n        }\n\n\n        for(int i = 0; i < values.size(); i++)\n\t\t\tif(values[i]->value != 0)\n            \tcout <<\"(\" << values[i]->row << \",\" << values[i]->column << \",\" << values[i]->value << \")\" << endl;\n    }\n\n    Sparse operator+(const Sparse & Other){\n        Sparse temp(row, col);\n        for(int i = 0; i < values.size(); i++){\n            Entry* tp = new Entry;\n            tp->row = values[i]->row;\n            tp->column = values[i]->column;\n            tp->value = values[i]->value;\n            temp.values.push_back(tp);\n        }\n        for(int i = 0; i < Other.values.size(); i++){\n            bool found = false;\n            for(int j = 0; j < temp.values.size(); j++)\n                if((Other.values[i])->row == (temp.values[j])->row && (Other.values[i])->column == (temp.values[j])->column){\n                    found = true;\n                    (temp.values[j])->value += (Other.values[i])->value;\n                    break;\n                }\n            if(!found){\n                Entry* tp = new Entry;\n                tp->row = (Other.values[i])->row;\n                tp->column = (Other.values[i])->column;\n                tp->value = (Other.values[i])->value;\n                temp.values.push_back(tp);\n            }\n        }\n        return temp;\n    }\nprivate:\n    int row, col;\n    vector<Entry*> values;\n};\n\n",
            1591682947.0679667,
            100,
            "# 答案正确"
        ],
        [
            "8.4 (C++)",
            "陈家龙",
            "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n\nint compare(Entry* p1, Entry* p2){\n    /*p1在p2前面则返回1，其他返回0*/\n    int res = 0;\n    if(p1->row < p2->row)\n        res = 1;\n    if((p1->row == p2->row) && (p1->column < p2->column))\n        res = 1;\n    return res;\n}\n\nclass Sparse:public Matrix{\npublic:\n    Sparse(int rows, int cols):row(rows), col(cols){}\n    ~Sparse(){\n        for(int i = 0; i < values.size(); i++)\n            delete values[i];\n    }\n\n    int size(int dimension) const {\n        int res = -1;\n        if(dimension == 1)\n            res = row;\n        if(dimension == 2)\n            res = col;\n        return res;\n    }\n    void set(int rows, int cols, double vals){\n        bool found = false;\n        for(int i = 0; i < values.size(); i++)\n            if(rows == values[i]->row && cols == values[i]->column){\n                found = true;\n                values[i]->value = vals;\n                break;\n            }\n        if(!found){\n            auto temp = new Entry;\n            temp->column = cols;\n            temp->row = rows;\n            temp->value = vals;\n            values.push_back(temp);\n        }\n    }\n    double get(int rows, int cols) const {\n        double ans = 0;\n        for(int i = 0; i < values.size(); i++)\n            if(values[i]->row == rows && values[i]->column == cols)\n                ans = values[i]->value;\n        return ans;\n    }\n    void print(){\n        Entry* temp;\n        for(int i = 1; i < values.size(); i++){\n            bool move = false;\n            temp = values[i];\n            int j = i - 1;\n            for(; j >= 0 && compare(temp,values[j]); j--){\n                values[j + 1] = values[j];\n                move = true;\n            }\n            if(move){\n                if(j < 0)\n                    j = 0;\n                values[j] = temp;\n            }\n        }\n\n\n        for(int i = 0; i < values.size(); i++)\n            if(values[i]->value != 0)\n                cout <<\"(\" << values[i]->row << \",\" << values[i]->column << \",\" << values[i]->value << \")\" << endl;\n    }\n\n    Sparse operator+(const Sparse & Other){\n        Sparse temp(row, col);\n        for(int i = 0; i < values.size(); i++){\n            Entry* tp = new Entry;\n            tp->row = values[i]->row;\n            tp->column = values[i]->column;\n            tp->value = values[i]->value;\n            temp.values.push_back(tp);\n        }\n        for(int i = 0; i < Other.values.size(); i++){\n            bool found = false;\n            for(int j = 0; j < temp.values.size(); j++)\n                if((Other.values[i])->row == (temp.values[j])->row && (Other.values[i])->column == (temp.values[j])->column){\n                    found = true;\n                    (temp.values[j])->value += (Other.values[i])->value;\n                    break;\n                }\n            if(!found){\n                Entry* tp = new Entry;\n                tp->row = (Other.values[i])->row;\n                tp->column = (Other.values[i])->column;\n                tp->value = (Other.values[i])->value;\n                temp.values.push_back(tp);\n            }\n        }\n        return temp;\n    }\n\n    Sparse operator*(const Sparse & Other){\n        Sparse temp(row, Other.col);\n        for(int i = 0; i < values.size(); i++)\n            for(int j = 0; j < Other.values.size(); j++)\n                if(values[i]->column == Other.values[j]->row){\n                    double add = values[i]->value * Other.values[j]->value;\n                    double ori = temp.get(values[i]->row, Other.values[j]->column);\n                    temp.set(values[i]->row, Other.values[j]->column, ori + add);\n                }\n        return temp;\n    }\n\n\n\nprivate:\n    int row, col;\n    vector<Entry*> values;\n};\n\n",
            1591761932.8432786,
            100,
            "# 答案正确"
        ],
        [
            "8.5 (C++)",
            "陈家龙",
            "#include <iostream>\nusing namespace std;\n\n\nclass Point3D:public Point2D{\npublic:\n    Point3D():Point2D(), z(0){}\n    Point3D(int X, int Y, int Z){\n        setX(X);\n        setY(Y);\n        z = Z;\n    }\n\n    double getZ(){\n        return z;\n    }\n    void setZ(double Z){\n        z = Z;\n    }\n    virtual double distance(Point3D & point2) {\n        return sqrt(Point2D::distance(point2) * Point2D::distance(point2) + (z - point2.z) * (z - point2.z));\n    }\nprivate:\n    double z;\n};\n\nvoid printDistance(Point3D & point1, Point3D & point2) {\n\tcout << \"point1.distance(point2) = \" << \n\t\tpoint1.distance(point2) << endl;\n}\n",
            1591846411.3596258,
            100,
            "# 答案正确"
        ],
        [
            "8.6 (C++)",
            "陈家龙",
            "#include <iostream>\nusing namespace std;\n\nclass MyTensor:public Tensor<double>{\nprivate:\n    vector<double> values;\npublic:\n    MyTensor(vector<int> sizes) : Tensor(sizes){\n        int size = 1;\n        for(int i = 0; i < sizes.size(); i++)\n            size *= (sizes[i] + 1);\n        values.resize(size);\n    }\n    double & get(const vector<int> & indexes){\n        int index = 1;\n        for(int i = 0; i < indexes.size(); i++)\n            index *= indexes[i];\n        return values[index];\n    }\n};",
            1592448643.0399075,
            100,
            "# 答案正确"
        ],
        [
            "9.1 (C++)",
            "陈家龙",
            "class Circle{\npublic:\n\tCircle(double r):radius(r){}\n\tint operator<(Circle Other){return radius < Other.radius;}\n\tint operator>(Circle Other){return radius > Other.radius;}\n\tint operator<=(Circle Other){return radius <= Other.radius;}\n\tint operator>=(Circle Other){return radius >= Other.radius;}\n\tint operator==(Circle Other){return radius == Other.radius;}\n\tint operator!=(Circle Other){return radius != Other.radius;}\nprivate:\n\tdouble radius;\n};",
            1593073584.130314,
            100,
            "# 答案正确"
        ],
        [
            "9.2 (C++)",
            "陈家龙",
            "class I{\npublic:\n\tI(int a, int b, int c, int d = -1){\n\t\tvalues.push_back(a);\n\t\tvalues.push_back(b);\n\t\tvalues.push_back(c);\n\t\tif (d != -1) values.push_back(d);\n\t};\n\toperator vector<int>(){\n\t\treturn values;\n\t}\nprivate:\n\tvector<int> values;\n};",
            1593074774.6268907,
            100,
            "# 答案正确"
        ],
        [
            "9.3 (C++)",
            "陈家龙",
            "class Complex{\npublic:\n\tComplex(double r, double i):r(r), i(i){}\n\n\tdouble real(){\n\t\treturn this->r;\n\t\t}\n\tdouble imag(){\n\t\treturn this->i;\n\t}\n\n\tComplex& operator=(const Complex & Other){\n\t\tthis->r = Other.r;\n\t\tthis->i = Other.i;\n\t\treturn *this;\n\t}\n\n\tComplex operator+(const Complex & Other){\n\t\tComplex temp(r + Other.r, i + Other.i);\n\t\treturn temp;\n\t}\n\tComplex operator-(const Complex & Other){\n\t\tComplex temp(r - Other.r, i - Other.i);\n\t\treturn temp;\n\t}\n\tComplex operator*(const Complex & Other){\n\t\tdouble R = r * Other.r - i * Other.i;\n\t\tdouble I = r * Other.i + i * Other.r;\n\t\tComplex temp(R, I);\n\t\treturn temp;\n\t}\n\tComplex operator/(const Complex & Other){\n\t\tdouble div = Other.r * Other.r + Other.i * Other.i;\n\t\tdouble R = (r * Other.r + i * Other.i) / div;\n\t\tdouble I = (i * Other.r - r * Other.i) / div;\n\t\tComplex temp(R, I);\n\t\treturn temp;\n\t}\n\n\tComplex operator-(int a){\n\t\tComplex temp(r - a, i);\n\t\treturn temp;\n\t}\n\tfriend Complex operator+(int a, const Complex & Other){\n\t\tComplex temp(Other.r + a, Other.i);\n\t\treturn temp;\n\t}\n\n\tvoid operator+=(const Complex & Other){\n\t\t*this = (*this) + Other;\n\t}\n\tvoid operator-=(const Complex & Other){\n\t\t*this = (*this) - Other;\n\t}\n\tvoid operator*=(const Complex & Other){\n\t\t*this = (*this) * Other;\n\t}\n\tvoid operator/=(const Complex & Other){\n\t\t*this = (*this) / Other;\n\t}\n\n\tbool operator==(const Complex & Other){\n\t\treturn (r == Other.r && i == Other.i);\n\t}\n\tbool operator!=(const Complex & Other){\n\t\treturn (r != Other.r || i != Other.i);\n\t}\n\nprivate:\n\tdouble r, i;\n};",
            1593077474.1101525,
            100,
            "# 答案正确"
        ],
        [
            "9.4 (C++)",
            "陈家龙",
            "class Complex{\npublic:\n\tComplex(double r = 0, double i = 0):r(r), i(i){}\n\n\tdouble real(){\n\t\treturn this->r;\n\t\t}\n\tdouble imag(){\n\t\treturn this->i;\n\t}\n\n\tComplex& operator=(const Complex & Other){\n\t\tthis->r = Other.r;\n\t\tthis->i = Other.i;\n\t\treturn *this;\n\t}\n\n\tComplex operator+(const Complex & Other){\n\t\tComplex temp(r + Other.r, i + Other.i);\n\t\treturn temp;\n\t}\n\tComplex operator-(const Complex & Other){\n\t\tComplex temp(r - Other.r, i - Other.i);\n\t\treturn temp;\n\t}\n\tComplex operator*(const Complex & Other){\n\t\tdouble R = r * Other.r - i * Other.i;\n\t\tdouble I = r * Other.i + i * Other.r;\n\t\tComplex temp(R, I);\n\t\treturn temp;\n\t}\n\tComplex operator/(const Complex & Other){\n\t\tdouble div = Other.r * Other.r + Other.i * Other.i;\n\t\tdouble R = (r * Other.r + i * Other.i) / div;\n\t\tdouble I = (i * Other.r - r * Other.i) / div;\n\t\tComplex temp(R, I);\n\t\treturn temp;\n\t}\n\n\tComplex operator-(int a){\n\t\tComplex temp(r - a, i);\n\t\treturn temp;\n\t}\n\tfriend Complex operator+(int a, const Complex & Other){\n\t\tComplex temp(Other.r + a, Other.i);\n\t\treturn temp;\n\t}\n\n\tvoid operator+=(const Complex & Other){\n\t\t*this = (*this) + Other;\n\t}\n\tvoid operator-=(const Complex & Other){\n\t\t*this = (*this) - Other;\n\t}\n\tvoid operator*=(const Complex & Other){\n\t\t*this = (*this) * Other;\n\t}\n\tvoid operator/=(const Complex & Other){\n\t\t*this = (*this) / Other;\n\t}\n\n\tbool operator==(const Complex & Other){\n\t\treturn (r == Other.r && i == Other.i);\n\t}\n\tbool operator!=(const Complex & Other){\n\t\treturn (r != Other.r || i != Other.i);\n\t}\n\n\tfriend istream & operator>>(istream & I, Complex & Other){\n\t\tcin >> Other.r >> Other.i;\n\t\treturn I;\n\t}\n\tfriend ostream & operator<<(ostream & O, const Complex & Other){\n\t\tcout << Other.r << \" + \" << Other.i <<\" i\";\n\t\treturn O;\n\t}\nprivate:\n\tdouble r, i;\n};\n",
            1593077973.5701184,
            100,
            "# 答案正确"
        ],
        [
            "9.5 (C++)",
            "陈家龙",
            "class Complex{\npublic:\n\tComplex(double r = 0, double i = 0):r(r), i(i){}\n\n\tdouble real(){\n\t\treturn this->r;\n\t\t}\n\tdouble imag(){\n\t\treturn this->i;\n\t}\n\n\tComplex& operator=(const Complex & Other){\n\t\tthis->r = Other.r;\n\t\tthis->i = Other.i;\n\t\treturn *this;\n\t}\n\n\tComplex operator+(const Complex & Other){\n\t\tComplex temp(r + Other.r, i + Other.i);\n\t\treturn temp;\n\t}\n\tComplex operator-(const Complex & Other){\n\t\tComplex temp(r - Other.r, i - Other.i);\n\t\treturn temp;\n\t}\n\tComplex operator*(const Complex & Other){\n\t\tdouble R = r * Other.r - i * Other.i;\n\t\tdouble I = r * Other.i + i * Other.r;\n\t\tComplex temp(R, I);\n\t\treturn temp;\n\t}\n\tComplex operator/(const Complex & Other){\n\t\tdouble div = Other.r * Other.r + Other.i * Other.i;\n\t\tdouble R = (r * Other.r + i * Other.i) / div;\n\t\tdouble I = (i * Other.r - r * Other.i) / div;\n\t\tComplex temp(R, I);\n\t\treturn temp;\n\t}\n\n\tComplex operator-(int a){\n\t\tComplex temp(r - a, i);\n\t\treturn temp;\n\t}\n\tfriend Complex operator+(int a, const Complex & Other){\n\t\tComplex temp(Other.r + a, Other.i);\n\t\treturn temp;\n\t}\n\n\tvoid operator+=(const Complex & Other){\n\t\t*this = (*this) + Other;\n\t}\n\tvoid operator-=(const Complex & Other){\n\t\t*this = (*this) - Other;\n\t}\n\tvoid operator*=(const Complex & Other){\n\t\t*this = (*this) * Other;\n\t}\n\tvoid operator/=(const Complex & Other){\n\t\t*this = (*this) / Other;\n\t}\n\n\tbool operator==(const Complex & Other){\n\t\treturn (r == Other.r && i == Other.i);\n\t}\n\tbool operator!=(const Complex & Other){\n\t\treturn (r != Other.r || i != Other.i);\n\t}\n\n\tfriend istream & operator>>(istream & I, Complex & Other){\n\t\tcin >> Other.r >> Other.i;\n\t\treturn I;\n\t}\n\tfriend ostream & operator<<(ostream & O, const Complex & Other){\n\t\tcout << Other.r << \" + \" << Other.i <<\" i\";\n\t\treturn O;\n\t}\n\n\tComplex & operator++(){\n\t\tr++;\n\t\treturn *this;\n\t}\n\tComplex operator++(int a){\n\t\tComplex temp = *this;\n\t\tr++;\n\t\treturn temp;\n\t}\n\n\toperator double(){\n\t\treturn r;\n\t}\n\nprivate:\n\tdouble r, i;\n};",
            1593078816.2262974,
            100,
            "# 答案正确"
        ],
        [
            "9.6 (C++)",
            "陈家龙",
            "class Tensor{\n\tdouble n;\npublic:\n\tTensor(int a, int b, int c, int d = 0){}\n\tdouble & operator()(int a, int b, int c, int d = 0){return n;}\n};",
            1593079513.729867,
            100,
            "# 答案正确"
        ],
        [
            "9.7 (C++)",
            "陈家龙",
            "class Tensor{\npublic:\n\tfriend istream & operator>>(istream & I, Tensor & t){\n\t\tint temp, total = 1;\n\t\tdouble temp2;\n\t\tcin >> t.dim;\n\t\tfor(int i = 0; i < t.dim; ++i){\n\t\t\tcin >> temp;\n\t\t\tt.sizes.push_back(temp);\n\t\t\ttotal *= temp; \n\t\t}\n\t\tfor(int i = 0; i < total; ++i){\n\t\t\tcin >> temp2;\n\t\t\tt.values.push_back(temp2);\n\t\t}\n\t\treturn I;\n\t}\n\tfriend ostream & operator<<(ostream & O, const Tensor & t){\n\t\tcout << t.dim << endl;\n\t\tfor(int i = 0; i < t.dim; ++i)\n\t\t\tcout << t.sizes[i] << \" \";\n\t\tcout << endl << endl;\n\t\tfor(int i = 1; i <= t.values.size(); ++i){\n\t\t\tcout << t.values[i - 1] << \" \";\n\t\t\tif(i % t.sizes[t.sizes.size() - 1] == 0)\n\t\t\t\tcout << endl;\n\t\t\tif(i % (t.sizes[t.sizes.size() - 1] * t.sizes[t.sizes.size() - 2]) == 0)\n\t\t\t\tcout << endl;\n\t\t}\n\t\treturn O;\n\t}\nprivate:\n\tint dim;\n\tvector<int> sizes;\n\tvector<double> values;\n};",
            1593082888.5821607,
            100,
            "# 答案正确"
        ],
        [
            "10.2 (C++)",
            "陈家龙",
            "catch (NonPositiveValueException & ex){\n\tcout << \"caught: NonPositiveValueException\" << endl;\n}\ncatch (out_of_range & ex){\n\tcout << \"caught: out_of_range\" << endl;\n}",
            1593658272.2938988,
            100,
            "# 答案正确"
        ],
        [
            "10.1 (C++)",
            "陈家龙",
            "#include <stdexcept>\nusing namespace std;\nclass MatrixSizesDoNotMatchException {};\n\ndouble Matrix::get(int row, int column) const {\n    if (rows < row || columns < column)\n        throw out_of_range(\"\");\n    return elements[(row - 1) * columns + (column - 1)];\n}\n\nvoid Matrix::set(int row, int column, double value){\n    if (rows < row || columns < column)\n        throw out_of_range(\"\");\n    elements[(row - 1) * columns + (column - 1)] = value;\n}\n\nMatrix Matrix::operator+(const Matrix & matrix2) const{\n    if (rows != matrix2.rows || columns != matrix2.columns)\n        throw MatrixSizesDoNotMatchException();\n    Matrix temp(rows, columns);\n    for (int i = 1; i <= rows; ++i)\n        for (int j = 1; j <= columns; ++j)\n            temp.set(i, j, get(i, j) + matrix2.get(i, j));\n    return temp;\n}",
            1593689501.8031802,
            100,
            "# 答案正确"
        ],
        [
            "2020-07-09 LAB",
            "陈家龙",
            "#include<iostream>\nusing namespace std;\n\nclass Integer{\nprivate:\n    int num;\n    static int count;\npublic:\n    Integer(int n = 0):num(n){}\n    friend istream & operator>>(istream & I, Integer & Other){\n        cin >> Other.num;\n        return I;\n    }\n    friend ostream & operator<<(ostream & O, Integer & Other){\n        cout << Other.num + count;\n        return O;\n    }\n    static void increase_all(int n){\n        count += n;\n    }\n    static void increase_all(Integer Otehr){\n        count += (Otehr.num + count);\n    }\n};\n\nint Integer::count = 0;",
            1594265346.8118823,
            100,
            "# 答案正确"
        ],
        [
            "15.1 (C++)",
            "陈家龙",
            "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nclass Table{\nprivate:\n    vector<string> head;\n    vector<vector<string> >data;\npublic:\n    void addCol(string st){\n        head.push_back(st);\n        vector<string> temp;\n        data.push_back(temp);\n    }\n    vector<string> & operator[](int n){\n        return data[n];\n    }\n    string json() const {\n        string ret = \"{\\n\\theaders: [\";\n        for(int i = 0; i < head.size(); ++i)\n        ret += \"'\" + head[i] + \"',\";\n        ret += \"],\\n\\trows: [\\n\";\n        for(int i = 0; i < data.size(); ++i){\n            ret += \"\\t\\t[\";\n            for(int j = 0; j < data[i].size(); ++j)\n                ret += \"'\" + data[i][j] + \"',\";\n            ret += \"],\\n\";\n        }\n        ret += \"\\t],\\n}\";\n        return(ret);\n    }\n};",
            1594298448.1661844,
            100,
            "# 答案正确"
        ],
        [
            "A.1 (C++)",
            "陈家龙",
            "template<typename E>\nvoid LinkedList<E>::removeAll(const E & e){\n    for (int i = indexOf(e); i >= 0; i = indexOf(e))\n        remove(i);\n}",
            1594866721.7700007,
            0,
            "In file included from main.cpp:46:0:\nsource.cpp:1:10: error: declaration of ‘class E’\n template<typename E>\n          ^\nmain.cpp:34:11: error:  shadows template parm ‘class E’\n template <typename E>\n           ^\nIn file included from main.cpp:46:0:\nsource.cpp:2:42: error: invalid use of incomplete type ‘class LinkedList<E>’\n void LinkedList<E>::removeAll(const E & e){\n                                          ^\nmain.cpp:35:7: note: declaration of ‘class LinkedList<E>’\n class LinkedList\n       ^\nmain.cpp: In function ‘int main()’:\nmain.cpp:56:9: error: ‘class LinkedList<double>’ has no member named ‘addFirst’\n   list1.addFirst(val);\n         ^\nmain.cpp:61:9: error: ‘class LinkedList<double>’ has no member named ‘addLast’\n   list1.addLast(val);\n         ^\nmain.cpp:66:8: error: ‘class LinkedList<double>’ has no member named ‘removeFirstOccurrence’\n  list2.removeFirstOccurrence(val);\n        ^\nmain.cpp:68:17: error: ‘class LinkedList<double>’ has no member named ‘get’\n   cout << list2.get(list2.size()-1) << endl;\n                 ^\nmain.cpp:69:9: error: ‘class LinkedList<double>’ has no member named ‘removeLast’\n   list2.removeLast(); \n         ^\nmain.cpp:72:17: error: ‘class LinkedList<double>’ has no member named ‘get’\n   cout << list2.get(0) << endl;\n                 ^\nmain.cpp:73:9: error: ‘class LinkedList<double>’ has no member named ‘removeFirst’\n   list2.removeFirst(); \n         ^\n"
        ],
        [
            "A.2 (C++)",
            "陈家龙",
            "template<typename E>\nvoid LinkedList<E>::removeAll(const E & e){\n    for (int i = indexOf(e); i >= 0; i = indexOf(e))\n        remove(i);\n}",
            1594866801.1254344,
            100,
            "# 答案正确"
        ],
        [
            "A.4 (C++)",
            "陈家龙",
            "#include <iostream>\n#include <string>\nusing namespace std;\n\nint Int_Hash(int key){\n\treturn key % 100;\n}\n\nint String_Hash(string key){\n\tint Hash_value = 0;\n\tfor(int i = 0; i < key.length(); i++)\n\t\tHash_value += int(key[i]);\n\treturn Hash_value % 100;\n}\n\nclass MyPair{\npublic:\n\tMyPair():first(-1), sceond(\"/0\"){}\n\toperator int(){return first;}\n\toperator string(){return sceond;}\n\tint first;\n\tstring sceond;\n};\n\nclass HT{\npublic:\n\tHT():_size(0){\n\t\tHashMap = new MyPair[100];\n\t}\n\t~HT(){\n\t\tdelete []HashMap;\n\t}\n\tvoid put(int key, int value){\n\t\tHashMap[Int_Hash(key)].first = value;\n\t\t_size++;\n\t}\n\tvoid put(int key, string value){\n\t\tHashMap[Int_Hash(key)].sceond = value;\n\t\t_size++;\n\t}\n\tvoid put(string key, int value){\n\t\tHashMap[String_Hash(key)].first = value;\n\t\t_size++;\n\t}\n\tvoid put(string key, string value){\n\t\tHashMap[String_Hash(key)].sceond = value;\n\t\t_size++;\n\t}\n\tint size(){\n\t\treturn _size;\n\t}\n\tMyPair operator[](int key){\n\t\treturn HashMap[Int_Hash(key)];\n\t}\n\tMyPair operator[](string key){\n\t\treturn HashMap[String_Hash(key)];\n\t}\nprivate:\n\tint _size;\n\tMyPair* HashMap;\n};",
            1595845865.9598627,
            100,
            "# 答案正确"
        ],
        [
            "A.5 (C++)",
            "陈家龙",
            "#include <iostream>\n#include <string>\nusing namespace std;\n\nint Int_Hash(int key){\n\treturn key % 100;\n}\n\nint String_Hash(string key){\n\tint Hash_value = 0;\n\tfor(int i = 0; i < key.length(); i++)\n\t\tHash_value += int(key[i]);\n\treturn Hash_value % 100;\n}\n\nint _size = 0;\n\nclass MyPair{\npublic:\n\tMyPair():first(-1), sceond(\"/0\"){}\n\toperator int(){return first;}\n\toperator string(){return sceond;}\n\tvoid operator=(int f){\n\t\tfirst = f;\n\t\t_size++;\n\t}\n\tvoid operator=(string s){\n\t\tsceond = s;\n\t\t_size++;\n\t}\n\tint first;\n\tstring sceond;\n};\n\nclass HT{\npublic:\n\tHT(){\n\t\tHashMap = new MyPair[100];\n\t}\n\t~HT(){\n\t\tdelete []HashMap;\n\t}\n\tint size(){\n\t\treturn _size;\n\t}\n\tMyPair & operator[](int key){\n\t\treturn HashMap[Int_Hash(key)];\n\t}\n\tMyPair & operator[](string key){\n\t\treturn HashMap[String_Hash(key)];\n\t}\nprivate:\n\tMyPair* HashMap;\n};",
            1595846814.7742386,
            100,
            "# 答案正确"
        ]
    ],
    "table_name": "答案"
}