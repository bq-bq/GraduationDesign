{
    "__update_time__": 1595573973.1502542,
    "field_names": [
        "题目名",
        "用户名",
        "答案",
        "提交时间",
        "分数",
        "评语"
    ],
    "field_types": [
        "text",
        "text",
        "text",
        "time",
        "number",
        "text"
    ],
    "foreign_keys": {},
    "primary_keys": [],
    "rows": [
        [
            "测试1",
            "王著",
            "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\n\tchar s1[100];\n\tchar s2[100];\n\tchar s3[100];\n\tcin>>s1>>s2>>s3;\n\tcout<<s3<<' '<<s2<<' '<<s1;\n\t\n}",
            1587607759.2551508,
            100,
            "# 答案正确"
        ],
        [
            "测试2",
            "王著",
            "#include <iostream>\n#include <cstring>\n\nusing namespace std;\nint main() {\n\n\tchar **s=new char*[10];\n\tint i;\n\tfor(i=0;i<10;i++){\n\t\ts[i]=new char[100];\n\t}\n\tfor(i=0;i<10;i++) {\n\t\tcin>>s[i];\n\t}\n\tchar *temp=new char[100];\n\tint j;\n\tfor(i=9;i>=1;i--){\n\t\tfor(j=0;j<i;j++){\n\t\t\tif(strcmp(s[j],s[j+1])>0) {\n\t\t\t\tstrcpy(temp,s[j]);\n\t\t\t\tstrcpy(s[j],s[j+1]);\n\t\t\t\tstrcpy(s[j+1],temp);\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=0;i<10;i++){\n\t\tcout<<s[i];\n\t\tif(i!=9) cout<<' ';\n\t}\n\tdelete temp;\n\tfor(i=0;i<10;i++) delete s[i];\n\tdelete s;\n\t\n}",
            1587608702.2474525,
            100,
            "# 答案正确"
        ],
        [
            "1.1 (C++)",
            "王著",
            "class Matrix5x5\n{public:\n double a[5][5];\n double get(int i,int j){\n\t return a[i][j];\n }\n void set(int i,int j,double x){\n\t a[i][j]=x;\n }\n Matrix5x5(){\n\t int i,j;\n\t for(i=0;i<5;i++){\n\t\t for(j=0;j<5;j++) a[i][j]=0;\n\t }\n }\n friend Matrix5x5 operator + (Matrix5x5& m1,Matrix5x5& m2){\n\t Matrix5x5 ret;\n\t int i,j;\n\t for (i = 0; i < 5; ++ i) {\n\t\t for(j=0;j<5;j++){\n\t\t\t ret.a[i][j]=m1.a[i][j]+m2.a[i][j];\n\t\t }\n\t }\n\t return ret;\n }\n};",
            1587696615.4460936,
            100,
            "# 答案正确"
        ],
        [
            "1.2 (C++)",
            "王著",
            "#include <cstring>\nclass School{\n\tpublic :\n\tint age;\n\tchar name[100];\n\tSchool(){\n\t\tage=0;\n\t\tname[0]='N';\n\t\tname[1]='O';\n\t\tname[2]='_';\n\t\tname[3]='N';\n\t\tname[4]='A';\n\t\tname[5]='M';\n\t\tname[6]='E';\n\t\tname[7]=0;\n\t\t\n\t}\n\tvoid setName(char name[]){\n\t\tstrcpy(this->name,name);\n\t}\n\tvoid setAge(int year){\n\t\tthis->age=year;\n\t}\n\tvoid operator ++ (){\n\t\tthis->age++;\n\t\t\n\t}\n\t\n};",
            1588212750.5959685,
            100,
            "# 答案正确"
        ],
        [
            "2.1 (C++)",
            "王著",
            "#include <iostream>\nusing namespace std;\nclass Matrix{\n\tprivate:\n\tint rows;\n\tint columns;\n\tdouble **values;\n\tpublic:\n\tMatrix(int rows, int column){\n\t\tint i,j;\n\t\tthis->rows=rows;\n\t\tthis->columns=column;\n\t\tvalues=new double*[rows];\n\t\tfor(i=0;i<rows;i++) values[i]=new double[column];\n\t\tfor(i=0;i<rows;i++){\n\t\t\tfor(j=0;j<column;j++){\n\t\t\t\tvalues[i][j]=0;\n\t\t\t}\n\t\t}\n\t}\n\t~Matrix(){\n\t\tint i,j;\n\t\tfor(i=0;i<this->rows;i++) delete values[i];\n\t\tdelete values;\n\t}\n\tvoid print(){\n\t\tint i,j;\n\t\tfor(i=0;i<rows;i++){\n\t\t\tfor(j=0;j<columns;j++){\n\t\t\t\tprintf(\"%5.0f\",values[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n};",
            1588835515.011859,
            100,
            "# 答案正确"
        ],
        [
            "2.2 (C++)",
            "王著",
            "#include <iostream>\nusing namespace std;\nclass Matrix{\n\tprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\n\tpublic:\n\tMatrix(int row,int column,double *value){\n\t\tint i;\n\t\trows=row;\n\t\tcolumns=column;\n\t\tthis->values=new double[row*column];\n\t\tfor(i=0;i<row*column;i++){\n\t\t\tthis->values[i]=value[i];\n\t\t}\n\t}\n\t~Matrix(){\n\t\tdelete values;\n\t}\n\tvoid print(){\n\t\tint i;\n\t\tint cnt=0;\n\t\tfor(i=0;i<rows*columns;i++){\n\t\t\tprintf(\"%5.0f\",values[i]);\n\t\t\tcnt++;\n\t\t\tif(cnt%columns==0) {\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t}\n\t}\n};",
            1588836261.7848744,
            100,
            "# 答案正确"
        ],
        [
            "2.3 (C++)",
            "王著",
            "#include <iostream>\nusing namespace std;\nclass Matrix{\n\tprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\n\tpublic:\n\tMatrix(int row,int column,double *value){\n\t\tint i;\n\t\trows=row;\n\t\tcolumns=column;\n\t\tthis->values=new double[row*column];\n\t\tfor(i=0;i<row*column;i++){\n\t\t\tthis->values[i]=value[i];\n\t\t}\n\t}\n\tMatrix(const Matrix &s2){\n\t\tthis->rows=s2.rows;\n\t\tthis->columns=s2.columns;\n\t\tthis->values=new double[this->rows*this->columns];\n\t\tint i;\n\t\tfor(i=0;i<this->rows*this->columns;i++){\n\t\t\tthis->values[i]=s2.values[i];\n\t\t}\n\t\t\n\t}\n\t~Matrix(){\n\t\tdelete values;\n\t}\n\tvoid print(){\n\t\tint i;\n\t\tint cnt=0;\n\t\tfor(i=0;i<rows*columns;i++){\n\t\t\tprintf(\"    %0.0f\",values[i]);\n\t\t\tcnt++;\n\t\t\tif(cnt%columns==0) {\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t}\n\t}\n};",
            1588836564.1532013,
            100,
            "# 答案正确"
        ],
        [
            "2.5 (C++)",
            "王著",
            "#include <iostream>\nusing namespace std;\nclass Matrix{\n\tprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\n\tpublic:\n\tMatrix(){\n\t\trows=0;\n\t\tcolumns=0;\n\t}\n\tMatrix(int row,int column,double *value){\n\t\tint i;\n\t\trows=row;\n\t\tcolumns=column;\n\t\tthis->values=new double[row*column];\n\t\tfor(i=0;i<row*column;i++){\n\t\t\tthis->values[i]=value[i];\n\t\t}\n\t}\n\tMatrix(const Matrix &s2){\n\t\tthis->rows=s2.rows;\n\t\tthis->columns=s2.columns;\n\t\tthis->values=new double[this->rows*this->columns];\n\t\tint i;\n\t\tfor(i=0;i<this->rows*this->columns;i++){\n\t\t\tthis->values[i]=s2.values[i];\n\t\t}\n\t\t\n\t}\n\t~Matrix(){\n\t\tdelete values;\n\t}\n\tvoid print(){\n\t\tif(rows==1){\n\t\t\tint i;\n\t\t\tfor(i=0;i<columns;i++) printf(\"    %0.0f\",values[i]);\n\t\t\tprintf(\"\\n\");\n\t\t\treturn ;\n\t\t}\n\t\tif(columns==1){\n\t\t\tint i;\n\t\t\tfor(i=0;i<rows;i++) {\n\t\t\t\tprintf(\"    %0.0f\\n\",values[i]);\n\t\t\t}\n\t\t\treturn ;\n\t\t}\n\t\tint i;\n\t\tint cnt=0;\n\t\tfor(i=0;i<rows*columns;i++){\n\t\t\tprintf(\"    %0.0f\",values[i]);\n\t\t\tcnt++;\n\t\t\tif(cnt%columns==0) {\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t}\n\t}\n\tMatrix getRow(int row){\n\t\tMatrix ret;\n\t\tret.rows=1;\n\t\tret.columns=this->columns;\n\t\tint i,j;\n\t\tret.values=new double[this->columns];\n\t\ti=row;\n\t\tfor(j=0;j<this->columns;j++){\n\t\t\tret.values[j]=this->values[j+(i-1)*this->columns];\n\t\t}\n\t\treturn ret;\n\t\t\n\t}\n\tMatrix getColumn(int column){\n\t\tMatrix ret;\n\t\tret.rows=this->rows;\n\t\tret.columns=1;\n\t\tint i,j;\n\t\tret.values=new double[this->rows];\n\t\tj=column;\n\t\tfor(i=0;i<this->rows;i++){\n\t\t\tret.values[i]=this->values[j-1+i*this->columns];\n\t\t}\n\t\treturn ret;\n\t}\n};",
            1588838979.52603,
            100,
            "# 答案正确"
        ],
        [
            "2.6 (C++)",
            "王著",
            "#include <iostream>\nusing namespace std;\nclass Matrix{\n\tprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\n\tpublic:\n\tMatrix(){\n\t\trows=0;\n\t\tcolumns=0;\n\t}\n\tMatrix(int row,int column,double *value){\n\t\tint i;\n\t\trows=row;\n\t\tcolumns=column;\n\t\tthis->values=new double[row*column];\n\t\tfor(i=0;i<row*column;i++){\n\t\t\tthis->values[i]=value[i];\n\t\t}\n\t}\n\tMatrix(const Matrix &s2){\n\t\tthis->rows=s2.rows;\n\t\tthis->columns=s2.columns;\n\t\tthis->values=new double[this->rows*this->columns];\n\t\tint i;\n\t\tfor(i=0;i<this->rows*this->columns;i++){\n\t\t\tthis->values[i]=s2.values[i];\n\t\t}\n\t\t\n\t}\n\t~Matrix(){\n\t\tdelete values;\n\t}\n\tvoid print(){\n\t\tint i;\n\t\tint cnt=0;\n\t\tfor(i=0;i<rows*columns;i++){\n\t\t\tprintf(\"    %0.0f\",values[i]);\n\t\t\tcnt++;\n\t\t\tif(cnt%columns==0) {\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t}\n\t}\n\tMatrix concatenateRows(const Matrix & matrix2){\n\tMatrix ret;\n\t\tret.values=new double[this->rows*this->columns+matrix2.rows*matrix2.columns];  \n\t\t\tret.rows=this->rows+matrix2.rows;\n\t\tret.columns=this->columns;\n\t\tint i;\n\t\tfor(i=0;i<this->rows*this->columns;i++){\n\t\t\tret.values[i]=this->values[i];\n\t\t}\n\t\tfor(i=this->rows*this->columns;i<this->rows*this->columns+matrix2.rows*matrix2.columns;i++){\n\t\t\tret.values[i]=matrix2.values[i-this->rows*this->columns];\n\t\t}\n\t\treturn ret;\n\t}\n\tMatrix concatenateColumns(const Matrix & matrix2){\n\t\tMatrix ret;\n\t\tret.values=new double[this->rows*this->columns+matrix2.rows*matrix2.columns];\n\t\tret.rows=this->rows;\n\t\tret.columns=this->columns+matrix2.columns;\n\t\tint i;\n\t\tint j;\n\t\tfor(i=0;i<this->rows;i++){\n\t\t\tfor(j=i*ret.columns;j<(i+1)*ret.columns;j++){\n\t\t\t\tif(j-i*ret.columns<this->columns){\n\t\t\t\t\tret.values[j]=this->values[j-matrix2.columns*i];\n\t\t\t\t}\n\t\t\t\telse ret.values[j]=matrix2.values[j-this->columns*(i+1)];\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n};",
            1588901808.2173831,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/08",
            "王著",
            "double & Tensor_get(int dimensions, const int sizes[],  double data[], int x0, int x1, int x2, int x3){\n\tif(dimensions==1) {\n\t\treturn data[x0];\n\t}\n\telse if(dimensions==2) {\n\t\tint index=x0*sizes[1]+x1;\n\t\treturn data[index];\n\t\t\n\t}\n\telse if(dimensions==3){\n\t\tint index=x0*sizes[1]*sizes[2]+x1*sizes[2]+x2;\n\t\treturn data[index];\n\t}\n\telse if(dimensions==4){\n\t\tint index=x0*sizes[1]*sizes[2]*sizes[3]+x1*sizes[2]*sizes[3]+x2*sizes[3]+x3;\n\t\treturn data[index];\n\t}\n}",
            1588906088.9810266,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/14",
            "王著",
            "#include <iostream>\nusing namespace std;\nvoid Tensor_print(int dimensions, const int sizes[], const double data[]){\n\tif(dimensions==1) {\n\t\tint i;\n\t\tprintf(\"Tensor of %d\\n\",sizes[0]);\n\t\tfor(i=0;i<sizes[0];i++) printf(\"%.1f\\n\",data[i]);\n\t}\n\telse if(dimensions==2){\n\t\tint i,j;\n\t\tprintf(\"Tensor of %dx%d\\n\",sizes[0],sizes[1]);\n\t\tint cnt=0;\n\t\tfor(i=0;i<sizes[0];i++){\n\t\t\tfor(j=0;j<sizes[1];j++){\n\t\t\t\tprintf(\"    %.1f\",data[cnt++]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\telse if(dimensions==3) {\n\t\tprintf(\"Tensor of %dx%dx%d\\n\",sizes[0],sizes[1],sizes[2]);\n\t\tint i,j,k;\n\t\tint cnt=0;\n\t\tfor(i=0;i<sizes[0];i++){\n\t\t\tprintf(\"data[%d]\\n\",i);\n\t\t\tfor(j=0;j<sizes[1];j++){\n\t\t\t\tfor(k=0;k<sizes[2];k++){\n\t\t\t\t\tprintf(\"    %.1f\",data[cnt++]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t}\n\t}\n\telse if(dimensions==4){\n\t\tprintf(\"Tensor of %dx%dx%dx%d\\n\",sizes[0],sizes[1],sizes[2],sizes[3]);\n\t\tint i,j,k,t;\n\t\tint cnt=0;\n\t\tfor(i=0;i<sizes[0];i++){\n\t\t\tfor(j=0;j<sizes[1];j++){\n\t\t\t\tprintf(\"data[%d][%d]\\n\",i,j);\n\t\t\t\tfor(k=0;k<sizes[2];k++){\n\t\t\t\t\tfor(t=0;t<sizes[3];t++){\n\t\t\t\t\t\tprintf(\"    %.1f\",data[cnt++]);\n\t\t\t\t\t}\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
            1589423541.0512059,
            100,
            "# 答案正确"
        ],
        [
            "2.4 (C++)",
            "王著",
            "#include <iostream>\n#include<iomanip>\nusing namespace std;\nclass Matrix{\n\tprivate:\n\tint rows;\n\tint columns;\n\tdouble *values;\n\tpublic:\n\tMatrix(int row,int column){\n\t\tthis->rows=row;\n\t\tthis->columns=column;\n\t\tthis->values=new double[row*column];\n\t\tint i;\n\t\tfor (int i = 0; i <row*column ; ++ i) values[i]=0;\n\t}\n\tMatrix(int row, int column, double value[]){\n\t\tthis->rows=row;\n\t\tthis->columns=column;\n\t\tthis->values=new double[row*column];\n\t\tfor (int i = 0; i <row*column ; ++ i) this->values[i]=value[i];\n\t}\n\t~Matrix(){\n\t\tdelete []values;\n\t}\n\tvoid print(){\n\t\tfor (int i = 0; i < rows; ++ i) {\n\t\t\tfor(int j=0;j<columns;j++){\n\t\t\tcout<<\"    \"<<values[i*columns+j];\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\treturn ;\n\t}\n\tvoid set(int row, int column, double value){\n\t\tthis->values[(row-1)*this->columns+column-1]=value;\n\t\treturn ; \n\t}\n\t Matrix const operator =(const Matrix &other){\n\t if(values!=NULL)\tdelete []values;\n\t\tthis->rows=other.rows;\n\t\tthis->columns=other.columns;\n\t\tthis->values=new double[rows*columns];\n\t\tint i;\n\t\tfor(i=0;i<rows*columns;i++){\n\t\t\tvalues[i]=other.values[i];\n\t\t}\n\t\t\n\t\n\t}\n};",
            1589514896.866177,
            100,
            "# 答案正确"
        ],
        [
            "2.7 (C++)",
            "王著",
            "#include <iostream>\n#include<iomanip>\nusing namespace std;\nclass Matrix{\n\tprivate:\n\tint rows;\n\tint columns;\n\tdouble *values;\n\tpublic:\n\tMatrix(int row,int column){\n\t\tthis->rows=row;\n\t\tthis->columns=column;\n\t\tthis->values=new double[row*column];\n\t\tint i;\n\t\tfor (int i = 0; i <row*column ; ++ i) values[i]=0;\n\t}\n\t\n\tMatrix(int row, int column, double value[]){\n\t\tthis->rows=row;\n\t\tthis->columns=column;\n\t\tthis->values=new double[row*column];\n\t\tfor (int i = 0; i <row*column ; ++ i) this->values[i]=value[i];\n\t}\n\tMatrix(const Matrix & matrix2){\n\t\tthis->rows=matrix2.rows;\n\t\tthis->columns=matrix2.columns;\n\t\tthis->values=new double[this->rows*this->columns];\n\t\tfor (int i = 0; i < this->rows*this->columns; ++ i) this->values[i]=matrix2.values[i];\n\t\t\n\t}\n\t\t\n\t~Matrix(){\n\t\tdelete []values;\n\t}\n\tvoid print(){\n\t\tfor (int i = 0; i < rows; ++ i) {\n\t\t\tfor(int j=0;j<columns;j++){\n\t\t\tcout<<\"    \"<<values[i*columns+j];\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\treturn ;\n\t}\n\t Matrix reshape(int row, int column) const{\n\t\tMatrix ret(row,column);\n\t\t int i,j;\n\t\t for(j=0;j<this->columns;j++){\n\t\t\t for(i=0;i<this->rows;i++){\n\t\t\t\t int cnt=j*this->rows+i;\n\t\t\t\t int x=(int)cnt/ret.rows;\n\t\t\t\t int y=cnt%ret.rows;\n\t\t\t\t ret.values[y*ret.columns+x]=this->values[i*this->columns+j];\n\t\t\t }\n\t\t }\n\t\t return ret;\n\t }\n\n};",
            1589529108.5865965,
            100,
            "# 答案正确"
        ],
        [
            "2.8 (C++)",
            "王著",
            "#include <iostream>\n#include<iomanip>\nusing namespace std;\nclass Matrix{\n\tprivate:\n\tint rows;\n\tint columns;\n\tdouble *values;\n\tpublic:\n\tMatrix(int row,int column){\n\t\tthis->rows=row;\n\t\tthis->columns=column;\n\t\tthis->values=new double[row*column];\n\t\tint i;\n\t\tfor (int i = 0; i <row*column ; ++ i) values[i]=0;\n\t}\n\t\n\tMatrix(int row, int column, double value[]){\n\t\tthis->rows=row;\n\t\tthis->columns=column;\n\t\tthis->values=new double[row*column];\n\t\tfor (int i = 0; i <row*column ; ++ i) this->values[i]=value[i];\n\t}\n\tMatrix(const Matrix & matrix2){\n\t\tthis->rows=matrix2.rows;\n\t\tthis->columns=matrix2.columns;\n\t\tthis->values=new double[this->rows*this->columns];\n\t\tfor (int i = 0; i < this->rows*this->columns; ++ i) this->values[i]=matrix2.values[i];\n\t\t\n\t}\n\t\t\n\t~Matrix(){\n\t\tdelete []values;\n\t}\n\tvoid print(){\n\t\tfor (int i = 0; i < rows; ++ i) {\n\t\t\tfor(int j=0;j<columns;j++){\n\t\t\tcout<<\"    \"<<values[i*columns+j];\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\treturn ;\n\t}\n\t Matrix transpose(){\n\t\tMatrix ret(this->columns,this->rows);\n\t\t int i,j;\n\t   int cnt=0;\n\t\t for(j=0;j<ret.columns;j++){\n\t\t\t for(i=0;i<ret.rows;i++){\n\t\t\t\t ret.values[i*ret.columns+j]=this->values[cnt++];\n\t\t\t }\n\t\t }\n\t\t return ret;\n\t }\n\n};",
            1589529356.3287246,
            100,
            "# 答案正确"
        ],
        [
            "2.12 (C++)",
            "王著",
            "#include <iostream>\n#include<iomanip>\n#include<cmath>\nusing namespace std;\nclass Matrix{\n\tprivate:\n\tint rows;\n\tint columns;\n\tdouble *values;\n\tpublic:\n\tMatrix(int row,int column){\n\t\tthis->rows=row;\n\t\tthis->columns=column;\n\t\tthis->values=new double[row*column];\n\t\tint i;\n\t\tfor (int i = 0; i <row*column ; ++ i) values[i]=0;\n\t}\n\t\n\tMatrix(int row, int column, double value[]){\n\t\tthis->rows=row;\n\t\tthis->columns=column;\n\t\tthis->values=new double[row*column];\n\t\tfor (int i = 0; i <row*column ; ++ i) this->values[i]=value[i];\n\t}\n\tMatrix(const Matrix & matrix2){\n\t\tthis->rows=matrix2.rows;\n\t\tthis->columns=matrix2.columns;\n\t\tthis->values=new double[this->rows*this->columns];\n\t\tfor (int i = 0; i < this->rows*this->columns; ++ i) this->values[i]=matrix2.values[i];\n\t\t\n\t}\n\t\t\n\t~Matrix(){\n\t\tdelete []values;\n\t}\n\tvoid print(){\n\t\tfor (int i = 0; i < rows; ++ i) {\n\t\t\tfor(int j=0;j<columns;j++){\n\t\t\tcout<<\"    \"<<values[i*columns+j];\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\treturn ;\n\t}\n\tMatrix pow(double exponent){\n\t\tMatrix ret(this->rows,this->columns,this->values);\n\t\tint i;\n\t\tfor(i=0;i<this->rows*this->columns;i++){\n\t\t\tret.values[i]=std::pow(ret.values[i],exponent);\n\t\t}\n\t\treturn ret;\n\t}\n\t Matrix exp(){\n\t\t Matrix ret(this->rows,this->columns,this->values);\n\t\tint i;\n\t\tfor(i=0;i<this->rows*this->columns;i++){\n\t\t\tret.values[i]=std::exp(ret.values[i]);\n\t\t}\n\t\treturn ret;\n\t }\n\t Matrix log(){\n\t\t  Matrix ret(this->rows,this->columns,this->values);\n\t\tint i;\n\t\tfor(i=0;i<this->rows*this->columns;i++){\n\t\t\tret.values[i]=std::log(ret.values[i])/std::log(std::exp(1));\n\t\t}\n\t\treturn ret;\n\t\t \n\t }\n\tMatrix abs(){\n\t\tMatrix ret(this->rows,this->columns,this->values);\n\t\tint i;\n\t\tfor(i=0;i<this->rows*this->columns;i++){\n\t\t\tret.values[i]=fabs(ret.values[i]);\n\t\t}\n\t\treturn ret;\n\t}\n\n};",
            1589592315.967046,
            100,
            "# 答案正确"
        ],
        [
            "2.10 (C++)",
            "王著",
            "#include <iostream>\n#include<iomanip>\nusing namespace std;\nclass Matrix{\n\tprivate:\n\tint rows;\n\tint columns;\n\tdouble *values;\n\tpublic:\n\tMatrix(int row,int column){\n\t\tthis->rows=row;\n\t\tthis->columns=column;\n\t\tthis->values=new double[row*column];\n\t\tint i;\n\t\tfor (int i = 0; i <row*column ; ++ i) values[i]=0;\n\t}\n\t\n\tMatrix(int row, int column, double value[]){\n\t\tthis->rows=row;\n\t\tthis->columns=column;\n\t\tthis->values=new double[row*column];\n\t\tfor (int i = 0; i <row*column ; ++ i) this->values[i]=value[i];\n\t}\n\tMatrix(const Matrix & matrix2){\n\t\tthis->rows=matrix2.rows;\n\t\tthis->columns=matrix2.columns;\n\t\tthis->values=new double[this->rows*this->columns];\n\t\tfor (int i = 0; i < this->rows*this->columns; ++ i) this->values[i]=matrix2.values[i];\n\t\t\n\t}\n\t\t\n\t~Matrix(){\n\t\tdelete []values;\n\t}\n\tvoid print(){\n\t\tfor (int i = 0; i < rows; ++ i) {\n\t\t\tfor(int j=0;j<columns;j++){\n\t\t\tcout<<\"    \"<<values[i*columns+j];\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\treturn ;\n\t}\n\tMatrix operator * (const Matrix & matrix2) const{\n\t\tMatrix ret(this->rows,matrix2.columns);\n\t\tint i,j;\n\t\tfor(i=0;i<ret.rows;i++){\n\t\t\tfor(j=0;j<ret.columns;j++){\n\t\t\t\tfor(int k=0;k<this->columns;k++){\n\t\t\t\t\tret.values[i*ret.columns+j]+=this->values[i*this->columns+k]*matrix2.values[k*matrix2.columns+j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\tMatrix operator * (double value) const{\n\t\tMatrix ret(this->rows,this->columns);\n\t\tint i,j;\n\t\tfor(i=0;i<ret.rows;i++){\n\t\t\tfor(j=0;j<ret.columns;j++){\n\t\t\t\t\n\t\t\t\t\tret.values[i*ret.columns+j]+=this->values[i*this->columns+j]*value;\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\n};",
            1589621917.322381,
            100,
            "# 答案正确"
        ],
        [
            "2.11 (C++)",
            "王著",
            "#include <iostream>\n#include<iomanip>\nusing namespace std;\nclass Matrix{\n\tprivate:\n\tint rows;\n\tint columns;\n\tdouble *values;\n\tpublic:\n\tMatrix(int row,int column){\n\t\tthis->rows=row;\n\t\tthis->columns=column;\n\t\tthis->values=new double[row*column];\n\t\tint i;\n\t\tfor (int i = 0; i <row*column ; ++ i) values[i]=0;\n\t}\n\t\n\tMatrix(int row, int column, double value[]){\n\t\tthis->rows=row;\n\t\tthis->columns=column;\n\t\tthis->values=new double[row*column];\n\t\tfor (int i = 0; i <row*column ; ++ i) this->values[i]=value[i];\n\t}\n\tMatrix(const Matrix & matrix2){\n\t\tthis->rows=matrix2.rows;\n\t\tthis->columns=matrix2.columns;\n\t\tthis->values=new double[this->rows*this->columns];\n\t\tfor (int i = 0; i < this->rows*this->columns; ++ i) this->values[i]=matrix2.values[i];\n\t\t\n\t}\n\t\t\n\t~Matrix(){\n\t\tdelete []values;\n\t}\n\tvoid print(){\n\t\tfor (int i = 0; i < rows; ++ i) {\n\t\t\tfor(int j=0;j<columns;j++){\n\t\t\tcout<<\"    \"<<values[i*columns+j];\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\treturn ;\n\t}\n\tMatrix max() const{\n\t\tif(this->rows==1){\n\t\t\tint ma=0;\n\t\t\tint i;\n\t\t\tfor(i=0;i<this->columns;i++){\n\t\t\t\tif(this->values[i]>ma) ma=this->values[i];\n\t\t\t}\n\t\t\tMatrix ret(1,1);\n\t\t\tret.values[0]=ma;\n\t\t\treturn ret;\n\t\t}\n\t\telse {\n\t\t\t\n\t\t\tMatrix ret(1,this->columns);\n\t\t\tint maxid=0;\n\t\t\t;\n\t\t\tint i,j;\n\t\t\tfor(j=0;j<this->columns;j++){\n\t\t\t\tint ma=0;\n\t\t\t\tfor(i=0;i<this->rows;i++){\n\t\t\t\t\tif(this->values[i*this->columns+j]>ma) {\n\t\t\t\t\t\tma=this->values[i*this->columns+j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tret.values[j]=ma;\n\t\t\t}\n\t\t\t\n\t\t\treturn ret;\n\t\t}\n\t}\n\tMatrix min() const{\n\t\tif(this->rows==1){\n\t\t\tint ma=100000;\n\t\t\tint i;\n\t\t\tfor(i=0;i<this->columns;i++){\n\t\t\t\tif(this->values[i]<ma) ma=this->values[i];\n\t\t\t}\n\t\t\tMatrix ret(1,1);\n\t\t\tret.values[0]=ma;\n\t\t\treturn ret;\n\t\t}\n\t\telse {\n\t\t\t\n\t\t\tMatrix ret(1,this->columns);\n\t\t\tint maxid=0;\n\t\t\t;\n\t\t\tint i,j;\n\t\t\tfor(j=0;j<this->columns;j++){\n\t\t\t\tint ma=100000;\n\t\t\t\tfor(i=0;i<this->rows;i++){\n\t\t\t\t\tif(this->values[i*this->columns+j]<ma) {\n\t\t\t\t\t\tma=this->values[i*this->columns+j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tret.values[j]=ma;\n\t\t\t}\n\t\t\t\n\t\t\treturn ret;\n\t\t}\n\t}\n\tMatrix sum() const{\n\t\tif(this->rows==1){\n\t\t\tMatrix ret(1,1);\n\t\t\tint i;\n\t\t\tint sum=0;\n\t\t\tfor(i=0;i<this->columns;i++){\n\t\t\t\tsum+=this->values[i];\n\t\t\t}\n\t\t\tret.values[0]=sum;\n\t\t\treturn ret;\n\t\t}\n\t\telse {\n\t\t\tMatrix ret(1,this->columns);\n\t\t\tint i,j;\n\t\t\tfor(j=0;j<this->columns;j++){\n\t\t\t\tint sum=0;\n\t\t\t\tfor(i=0;i<this->rows;i++){\n\t\t\t\t\tsum+=this->values[i*this->columns+j];\n\t\t\t\t}\n\t\t\t\tret.values[j]=sum;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n};",
            1589623293.509989,
            100,
            "# 答案正确"
        ],
        [
            "2.9 (C++)",
            "王著",
            "#include <iostream>\n#include<iomanip>\nusing namespace std;\nclass Matrix{\n\tprivate:\n\tint rows;\n\tint columns;\n\tdouble *values;\n\tpublic:\n\tMatrix(int row,int column){\n\t\tthis->rows=row;\n\t\tthis->columns=column;\n\t\tthis->values=new double[row*column];\n\t\tint i;\n\t\tfor (int i = 0; i <row*column ; ++ i) values[i]=0;\n\t}\n\t\n\tMatrix(int row, int column, double value[]){\n\t\tthis->rows=row;\n\t\tthis->columns=column;\n\t\tthis->values=new double[row*column];\n\t\tfor (int i = 0; i <row*column ; ++ i) this->values[i]=value[i];\n\t}\n\tMatrix(const Matrix & matrix2){\n\t\tthis->rows=matrix2.rows;\n\t\tthis->columns=matrix2.columns;\n\t\tthis->values=new double[this->rows*this->columns];\n\t\tfor (int i = 0; i < this->rows*this->columns; ++ i) this->values[i]=matrix2.values[i];\n\t\t\n\t}\n\t\t\n\t~Matrix(){\n\t\tdelete []values;\n\t}\n\tvoid print(){\n\t\tfor (int i = 0; i < rows; ++ i) {\n\t\t\tfor(int j=0;j<columns;j++){\n\t\t\tcout<<\"    \"<<values[i*columns+j];\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\treturn ;\n\t}\n  Matrix operator + (const Matrix & matrix2) const{\n\t  Matrix ret(this->rows,this->columns);\n\t  int i,j;\n\t  for(i=0;i<ret.rows;i++){\n\t\t  for(j=0;j<ret.columns;j++){\n\t\t\t  ret.values[i*ret.columns+j]=this->values[i*ret.columns+j]+matrix2.values[i*ret.columns+j];\n\t\t  }\n\t  }\n\t  return ret;\n  }\n\tMatrix operator + (double value) {\n\t\tint i,j;\n\t\tMatrix ret(this->rows,this->columns);\n\t\tfor(i=0;i<this->rows;i++){\n\t\t\tfor(j=0;j<this->columns;j++){\n\t\t\t\tret.values[i*this->columns+j]=this->values[i*this->columns+j]+value;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\tMatrix operator - (const Matrix & matrix2) const{\n\t  Matrix ret(this->rows,this->columns);\n\t  int i,j;\n\t  for(i=0;i<ret.rows;i++){\n\t\t  for(j=0;j<ret.columns;j++){\n\t\t\t  ret.values[i*ret.columns+j]=this->values[i*ret.columns+j]-matrix2.values[i*ret.columns+j];\n\t\t  }\n\t  }\n\t  return ret;\n  }\n\tMatrix operator - (double value) {\n\t\tint i,j;\n\t\tMatrix ret(this->rows,this->columns);\n\t\tfor(i=0;i<this->rows;i++){\n\t\t\tfor(j=0;j<this->columns;j++){\n\t\t\t\tret.values[i*this->columns+j]=this->values[i*this->columns+j]-value;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\n};",
            1590027368.5368068,
            100,
            "# 答案正确"
        ],
        [
            "6.1 (C++)",
            "王著",
            "#include<string.h>\ntemplate <typename T>\nclass Matrix{\n\tprivate:\n\tT *values;\n\tint rows;\n\tint columns;\n\tpublic:\n\tMatrix (int row,int column){\n\t\trows=row;\n\t\tcolumns=column;\n\t\tvalues=new T[rows*columns];\n\t\t\n\t\tmemset(values,0,rows*columns*sizeof(T));\n\t}\n\tMatrix(int row,int column,const T value[]){\n\t\trows=row;\n\t\tcolumns=column;\n\t\tvalues=new T[rows*columns];\n\t\tfor(int i=0;i<rows*columns;i++) values[i]=value[i];\n\t}\n\t~Matrix(){\n\t\tdelete []values;\n\t}\n\tMatrix(const Matrix<T> &matrix){\n\t\trows=matrix.rows;\n\t\tcolumns=matrix.columns;\n\t\tvalues=new T [rows*columns];\n\t\tfor(int i=0;i<rows*columns;i++) values[i]=matrix.values[i];\n\t\t\n\t\t\n\t}\n\tvoid print(){\n\t\tint i,j;\n\t\tfor(i=0;i<rows;i++){\n\t\t\tfor(j=0;j<columns;j++){\n\t\t\t\tcout<<\"    \"<<values[i*columns+j];\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t}\n\tMatrix & operator =(const Matrix &matrix){\n\t\tif(values!=NULL) delete []values;\n\t\trows=matrix.rows;\n\t\tcolumns=matrix.columns;\n\t\tvalues=new T [rows*columns];\n\t\tfor(int i=0;i<rows*columns;i++) values[i]=matrix.values[i];\n\t\treturn *this;\n\t}\n\tT &get(int x,int y){\n\t\treturn values[(x-1)*columns+y-1];\n\t}\n};",
            1590128706.1114092,
            100,
            "# 答案正确"
        ],
        [
            "6.3 (C++)",
            "王著",
            "#include <vector>\n#include <iostream>\nusing namespace std;\ntemplate <typename T>\nclass Matrix{\n\tprivate:\n\tint rows;\n   int columns;\n   vector<T> values;\n\tpublic:\n\tMatrix<T>(int row,int column){\n\t\trows=row;\n\t\tcolumns=column;\n\t\tfor(int i=0;i<rows*columns;i++){\n\t\t\tvalues.push_back(0);\n\t\t\t\n\t\t}\n\t} \n\tMatrix<T>(int row,int column,const vector<T> &other ){\n\t\trows=row;\n\t\tcolumns=column;\n\t\tfor(int i=0;i<other.size();i++){\n\t\t\tvalues.push_back(other[i]);\n\t\t}\n\t}\n\tvoid print(){\n\t\n\t\tint i,j;\n\t\tfor(i=0;i<rows;i++){\n\t\t\tfor(j=0;j<columns;j++) {\n\t\t\t\tcout<<\"    \"<<values[i*columns+j];\t\t\t}\n\t\t\t\tcout<<endl;\n\t\t}\n\t}\n\tMatrix <T>& operator =(const Matrix<T> &matrix){\n\t\tif(this->values.size()==0){\n\t\t\n\t\trows=matrix.rows;\n\t\tcolumns=matrix.columns;\n\t\t\n\t\tfor(int i=0;i<matrix.values.size();i++){\n\t\t\tvalues.push_back(matrix.values[i]);\n\t\t}\n\t\treturn *this;}\n\t\telse {\n\t\t\t\trows=matrix.rows;\n\t\tcolumns=matrix.columns;\n\t\t\tfor(int i=0;i<this->values.size();i++){\n\t\t\t\tthis->values[i]=0;\n\t\t\t}\n\t\t\tfor(int i=this->values.size();i<matrix.values.size();i++){\n\t\t\t\tthis->values.push_back(matrix.values[i]);\n\t\t\t}\n\t\t\tfor(int i=0;i<matrix.values.size();i++){\n\t\t\t\tthis->values[i]=matrix.values[i];\n\t\t\t}\n\t\t\treturn *this;\n\t\t}\n\t}\n\tT &get(int x,int y){\n\t\treturn values[(x-1)*columns+y-1];\n\t}\n\tMatrix <T> getRow(int row){\n\t\trow--;\n\t\tMatrix<T> ret(1,this->columns);\n\t\tfor(int i=0;i<this->columns;i++) {\n\t\t\tret.values[i]=this->values[row*this->columns+i];\n\t\t}\n\t\treturn ret;\n\t}\n\tMatrix <T>getColumn(int column){\n\t\tcolumn--;\n\t\tMatrix<T> ret(this->rows,1);\n\t\tint j=column;\n\t\tfor(int i=0;i<this->rows;i++){\n\t\t\tret.values[i]=this->values[i*this->columns+j];\n\t\t}\n\t\treturn ret;\n\t}\n\tMatrix <T>concatenateRows(const Matrix<T> &matrix){\n\t\t\tMatrix<T> ret(this->rows+matrix.rows,this->columns);\n\t\t\tfor(int i=0;i<ret.rows;i++){\n\t\t\t\tfor(int j=0;j<ret.columns;j++){\n\t\t\t\t\tif(i<this->rows){\n\t\t\t\t\t\tret.values[i*ret.columns+j]=this->values[i*ret.columns+j];\n\t\t\t\t\t}\n\t\t\t\t\telse ret.values[i*ret.columns+j]=matrix.values[(i-this->rows)*ret.columns+j];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t}\n\tMatrix <T>concatenateColumns(const Matrix<T> &matrix){\n\t\tMatrix <T> ret(this->rows,this->columns+matrix.columns);\n\t\tfor(int i=0;i<ret.rows;i++){\n\t\t\tfor(int j=0;j<ret.columns;j++){\n\t\t\t\tif(j<this->columns){\n\t\t\t\t\tret.values[i*ret.columns+j]=this->values[i*this->columns+j];\n\t\t\t\t}\n\t\t\t\telse ret.values[i*ret.columns+j]=matrix.values[i*matrix.columns+j-this->columns];\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\tMatrix <T> reshape(int row,int column){\n\t\tMatrix <T> ret(row,column);\n\t\tfor(int j=0;j<column;j++){\n\t\t\tfor(int i=0;i<row;i++){\n\t\t\t\tint cnt=j*row+i;\n\t\t\t\tint x=cnt/this->rows;\n\t\t\t\tint y=cnt%this->rows;\n\t\t\t\tret.values[i*ret.columns+j]=this->values[y*this->columns+x];\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\tMatrix <T> transpose(){\n\t\tMatrix <T> ret(this->columns,this->rows);\n\t\tfor(int i=0;i<ret.rows;i++){\n\t\t\tfor(int j=0;j<ret.columns;j++){\n\t\t\t\tret.values[i*ret.columns+j]=this->values[j*this->columns+i];\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\tMatrix<T> operator +(const Matrix<T>& matrix){\n\t\tMatrix <T>ret(this->rows,this->columns);\n\t\tfor(int i=0;i<this->rows;i++){\n\t\t\tfor(int j=0;j<this->columns;j++){\n\t\t\t\tret.values[i*this->columns+j]=this->values[i*this->columns+j]+matrix.values[i*this->columns+j];\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\tMatrix<T> operator+(T x){\n\t\t\tMatrix <T>ret(this->rows,this->columns);\n\t\tfor(int i=0;i<this->rows;i++){\n\t\t\tfor(int j=0;j<this->columns;j++){\n\t\t\t\tret.values[i*this->columns+j]=this->values[i*this->columns+j]+x;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\tMatrix<T> operator -(const Matrix<T>& matrix){\n\t\tMatrix <T>ret(this->rows,this->columns);\n\t\tfor(int i=0;i<this->rows;i++){\n\t\t\tfor(int j=0;j<this->columns;j++){\n\t\t\t\tret.values[i*this->columns+j]=this->values[i*this->columns+j]-matrix.values[i*this->columns+j];\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\tMatrix<T> operator-(T x){\n\t\t\tMatrix <T>ret(this->rows,this->columns);\n\t\tfor(int i=0;i<this->rows;i++){\n\t\t\tfor(int j=0;j<this->columns;j++){\n\t\t\t\tret.values[i*this->columns+j]=this->values[i*this->columns+j]-x;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\tMatrix<T> operator * (const Matrix<T> &matrix){\n\t\tMatrix <T>ret(this->rows,matrix.columns);\n\t\tfor(int i=0;i<this->rows;i++){\n\t\t\tfor(int j=0;j<ret.columns;j++){\n\t\t\t\tfor(int k=0;k<this->columns;k++){\n\t\t\t\t\tret.values[i*ret.columns+j]+=this->values[i*this->columns+k]*matrix.values[k*matrix.columns+j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\tMatrix <T> operator *(T x){\n\t\tMatrix <T> ret(this->rows,this->columns);\n\t\tfor(int i=0;i<this->rows;i++){\n\t\t\tfor(int j=0;j<this->columns;j++){\n\t\t\t\tret.values[i*this->columns+j]=this->values[i*this->columns+j]*x;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\tMatrix <T> max(){\n\t\tif(this->rows==1) {\n\t\t\tint max=0;\n\t\t\tfor(int i=0;i<this->columns;i++){\n\t\t\t\tif(this->values[i]>max) max=this->values[i];\n\t\t\t}\n\t\t\tMatrix <T> ret(1,1);\n\t\t\tret.values[0]=max;\n\t\t\treturn ret;\n\t\t}\n\t\telse {\n\t\t\tMatrix <T> ret(1,this->columns);\n\t\t\tfor(int j=0;j<this->columns;j++){\n\t\t\t\tint max=0;\n\t\t\t\tfor(int i=0;i<this->rows;i++){\n\t\t\t\t\tif(max<this->values[i*this->columns+j]) max=this->values[i*this->columns+j];\n\t\t\t\t}\n\t\t\t\tret.values[j]=max;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\t\n\t}\n\t\tMatrix <T> min(){\n\t\tif(this->rows==1) {\n\t\t\tint min=100000;\n\t\t\tfor(int  i=0;i<this->columns;i++){\n\t\t\t\tif(this->values[i]<min) min=this->values[i];\n\t\t\t}\n\t\t\tMatrix <T> ret(1,1);\n\t\t\tret.values[0]=min;\n\t\t\treturn ret;\n\t\t}\n\t\telse {\n\t\t\tMatrix <T> ret(1,this->columns);\n\t\t\tfor(int j=0;j<this->columns;j++){\n\t\t\t\tint min=100000;\n\t\t\t\tfor(int i=0;i<this->rows;i++){\n\t\t\t\t\tif(min>this->values[i*this->columns+j]) min=this->values[i*this->columns+j];\n\t\t\t\t}\n\t\t\t\tret.values[j]=min;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\t\n\t}\n\tMatrix<T> sum(){\n\t\tif(this->rows==1) {\n\t\t\tint sum=0;\n\t\t\tfor(int i=0;i<this->columns;i++) sum+=this->values[i];\n\t\t\tMatrix <T> ret(1,1);\n\t\t\tret.values[0]=sum;\n\t\t\treturn ret;\n\t\t\t\n\t\t}\n\t\telse {\n\t\t\t\tMatrix <T> ret(1,this->columns);\n\t\t\tfor(int j=0;j<this->columns;j++){\n\t\t\t\tint sum=0;\n\t\t\t\tfor(int i=0;i<this->rows;i++){\n\t\t\t\t\tsum+=this->values[i*this->columns+j];\n\t\t\t\t}\n\t\t\t\tret.values[j]=sum;\n\t\t\t}\n\t\t\treturn ret;\n\t\t\t\n\t\t}\n\t}\n};",
            1590377378.28799,
            100,
            "# 答案正确"
        ],
        [
            "6.2 (C++)",
            "王著",
            "#include <vector>\n#include <iostream>\n#include<string.h>\nusing namespace std;\ntemplate <typename T>\nclass Matrix{\n\tprivate:\n\tint rows;\n   int columns;\n   T * values;\n\tpublic:\n\tMatrix<T>(int row,int column){\n\t\trows=row;\n\t\tcolumns=column;\n\t\tvalues=new T[row*column];\n\t\tmemset(values,0,row*column*sizeof(T));\n\t} \n ~Matrix<T>(){\n\tdelete [] values;\n }\n\tvoid print(){\n\t\n\t\tint i,j;\n\t\tfor(i=0;i<rows;i++){\n\t\t\tfor(j=0;j<columns;j++) {\n\t\t\t\tcout<<\"    \"<<values[i*columns+j];\t\t\t}\n\t\t\t\tcout<<endl;\n\t\t}\n\t}\n\n};",
            1590631509.3458295,
            100,
            "# 答案正确"
        ],
        [
            "7.3 (C++)",
            "王著",
            "\n\ntemplate <typename A>\nvector<A> map2(const vector<A> & x,const vector<A> & y,A (*map_func)(const A &,const A &)){\n\tvector <A> res;\n\t\n\tfor(int i=0;i<x.size();i++){\n\t\tres.push_back(x[i]+y[i]);\n\t}\n\treturn res;\n}\ntemplate <typename A>\nvector<A> map2(const vector<A> & x,A  y,A (*map_func)(const A &,const A &)){\n\tvector <A> res;\n\t\n\tfor(int i=0;i<x.size();i++){\n\t\tres.push_back(x[i]+y);\n\t}\n\treturn res;\n}\n",
            1590997305.4771001,
            100,
            "# 答案正确"
        ],
        [
            "7.1 (C++)",
            "王著",
            "#include<cmath>\nclass Triangle:public  GeometricObject{\n\tprivate:\n\t\tdouble side1;\n\t\tdouble side2;\n\t\tdouble side3;\n\t\tpublic:\n\t\t\tTriangle(){\n\t\t\t\tside1=1.0;\n\t\t\t\tside2=1.0;\n\t\t\t\tside3=1.0;\n\t\t\t}\n\t\t\tTriangle(double a,double b,double c){\n\t\t\t\tside1=a;\n\t\t\t\tside2=b;\n\t\t\t\tside3=c;\n\t\t\t}\n\t\t\tdouble getSide1(){\n\t\t\t\treturn side1;\n\t\t\t}\n\t\t\tdouble getSide2(){\n\t\t\t\treturn side2;\n\t\t\t}\n\t\t\tdouble getSide3(){\n\t\t\t\treturn side3;\n\t\t\t}\n\t\t\tdouble getArea(){\n\t\t\t\tdouble s=(side1+side2+side3)/2;\n\t\t\t\treturn sqrt(s*(s-side1)*(s-side2)*(s-side3));\n\t\t\t}\n\t\t\tdouble getPerimeter(){\n\t\t\t\treturn(side1+side2+side3);\n\t\t\t}\n};\n",
            1591002350.063342,
            100,
            "# 答案正确"
        ],
        [
            "7.2 (C++)",
            "王著",
            "\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\nvector<string>  split(const string & line,const string & delimiter=\" \"){\n\tvector <string> words;\n\tint start=0;\n\twhile(start<line.size()){\n\t\tint end =line.find(delimiter,start);\n\t\tif(end==start) start+=delimiter.size();\n\t\telse {\n\t\t\tif(end==-1) {\n\t\t\t\twords.push_back(line.substr(start));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twords.push_back(line.substr(start,end-start));\n\t\t\tstart=end+delimiter.size();\n\t\t}\n\t}\n\treturn words;\n}",
            1591236888.3928757,
            100,
            "# 答案正确"
        ],
        [
            "8.1 (C++)",
            "王著",
            "#include<string.h>\nclass Full:public  Matrix{\n\tprivate:\n\tdouble *values;\n\tint rows;\n\tint columns;\n\tpublic:\n\t\tvirtual void set(int row, int column, double value){\n\t\tthis->values[row*columns+column]=value;\n\t}\n\t\tvirtual double get(int x,int y) const{\n\t\treturn values[(x-1)*columns+y-1];\n\t}\n\t\tvirtual int size(int dimension) const{\n\t\tif(dimension==1) return rows;\n\t\telse return columns;\n\t}\n\tFull (int row,int column){\n\t\trows=row;\n\t\tcolumns=column;\n\t\tvalues=new double[rows*columns];\n\t\t\n\t\tmemset(values,0,rows*columns*sizeof(double));\n\t}\n\tvirtual void print() const{\n\t\t\tint i,j;\n\t\tfor(i=0;i<rows;i++){\n\t\t\tfor(j=0;j<columns;j++){\n\t\t\t\tcout<<\"    \"<<values[i*columns+j];\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t}\n\t\tFull (int row,int column,const double value[]){\n\t\trows=row;\n\t\tcolumns=column;\n\t\tvalues=new double[rows*columns];\n\t\tfor(int i=0;i<rows*columns;i++) values[i]=value[i];\n\t}\n\tFull(const Matrix & matrix2){\n\t\tthis->rows=matrix2.size(1);\n\t\tthis->columns=matrix2.size(2);\n\t\tvalues=new double [rows*columns];\n\t\tfor(int i=0;i<rows;i++){\n\t\t\tfor(int j=0;j<columns;j++) {\n\t\t\t\tvalues[i*columns+j]=matrix2.get(i+1,j+1);\n\t\t\t}\n\t\t}\n\t}\t\t\n\t~Full(){\n\t\tdelete []values;\n\t}\t\n  virtual Matrix & operator = (const Matrix & matrix2){\n\t\n\t\t\n\t\tfor(int i=0;i<rows;i++){\n\t\t\tfor(int j=0;j<columns;j++){\n\t\t\t\tthis->set(i,j,matrix2.get(i+1,j+1));\n\t\t\t}\n\t\t}\n\t\treturn *this;\n\t}\n\n\t\n};",
            1591663979.9299765,
            100,
            "# 答案正确"
        ],
        [
            "8.3 (C++)",
            "王著",
            "#include <vector>\nusing namespace std;\n#include <iostream>\n\n\nclass Sparse :public Matrix{\n\tprivate:\n\t\tint rows;\n\t\tint columns;\n\tvector<Entry> matrix;\n\tpublic:\n\t\tSparse(int row,int column){\n\t\t\trows=row;\n\t\t\tcolumns=column;\n\t\t}\n\t\tvirtual void set(int row, int column, double value){\n\t\t\tEntry a;\n\t\t\ta.row=row;\n\t\t\ta.column=column;\n\t\t\ta.value=value;\n\t\t\tmatrix.push_back(a);\n\t\t}\n\t\tvirtual int size(int dimension) const{\n\t\tif(dimension==1) return rows;\n\t\telse return columns;\n\t\t}\n\t    virtual double get(int row, int column)const{\n\t    \tfor(int i=0;i<this->matrix.size();i++) {\n\t    \t\tif(matrix[i].row==row&&matrix[i].column==column) return matrix[i].value;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tvirtual void print(){\n\t\t\tfor(int i=matrix.size()-1;i>=1;i--){\n\t\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\t\tif(matrix[j].row>matrix[j+1].row) {\n\t\t\t\t\t\tEntry temp;\n\t\t\t\t\t\ttemp.row=matrix[j].row;\n\t\t\t\t\t\ttemp.column=matrix[j].column;\n\t\t\t\t\t\ttemp.value=matrix[j].value;\n\t\t\t\t\t\tmatrix[j].row=matrix[j+1].row;\n\t\t\t\t\t\tmatrix[j].column=matrix[j+1].column;\n\t\t\t\t\t\tmatrix[j].value=matrix[j+1].value;\n\t\t\t\t\t\tmatrix[j+1].row=temp.row;\n\t\t\t\t\t\tmatrix[j+1].column=temp.column;\n\t\t\t\t\t\tmatrix[j+1].value=temp.value;\n\t\t\t\t\t}\n\t\t\t\t\telse if(matrix[j].row==matrix[j+1].row){\n\t\t\t\t\t\t\tif(matrix[j].column>matrix[j+1].column) {\n\t\t\t\t\t\tEntry temp;\n\t\t\t\t\t\ttemp.row=matrix[j].row;\n\t\t\t\t\t\ttemp.column=matrix[j].column;\n\t\t\t\t\t\ttemp.value=matrix[j].value;\n\t\t\t\t\t\tmatrix[j].row=matrix[j+1].row;\n\t\t\t\t\t\tmatrix[j].column=matrix[j+1].column;\n\t\t\t\t\t\tmatrix[j].value=matrix[j+1].value;\n\t\t\t\t\t\tmatrix[j+1].row=temp.row;\n\t\t\t\t\t\tmatrix[j+1].column=temp.column;\n\t\t\t\t\t\tmatrix[j+1].value=temp.value;\n\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t\n\t\t\tfor(int i=0;i<matrix.size();i++){\n\t\t\t\tif(matrix[i].value!=0)\n\t\t\t\tcout<<\"(\"<<matrix[i].row<<\",\"<<matrix[i].column<<\",\"<<matrix[i].value<<\")\"<<endl;\n\t\t\t}\n\t\t}\n\t\tSparse operator + (const Sparse & other){\n\t\t\tSparse ret(this->rows,this->columns);\n\t\t\tfor(int i=0;i<this->matrix.size();i++){\n\t\t      ret.matrix.push_back(this->matrix[i]);\n\t\t\t}\n\t\t\tfor(int j=0;j<other.matrix.size();j++){\n\t\t\t\tret.matrix.push_back(other.matrix[j]);\n\t\t\t}\n\t\t\tfor(int i=ret.matrix.size()-1;i>=1;i--){\n\t\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\t\tif(ret.matrix[j].row>ret.matrix[j+1].row) {\n\t\t\t\t\t\tEntry temp;\n\t\t\t\t\t\ttemp.row=ret.matrix[j].row;\n\t\t\t\t\t\ttemp.column=ret.matrix[j].column;\n\t\t\t\t\t\ttemp.value=ret.matrix[j].value;\n\t\t\t\t\t\tret.matrix[j].row=ret.matrix[j+1].row;\n\t\t\t\t\t\tret.matrix[j].column=ret.matrix[j+1].column;\n\t\t\t\t\t\tret.matrix[j].value=ret.matrix[j+1].value;\n\t\t\t\t\t\tret.matrix[j+1].row=temp.row;\n\t\t\t\t\t\tret.matrix[j+1].column=temp.column;\n\t\t\t\t\t\tret.matrix[j+1].value=temp.value;\n\t\t\t\t\t}\n\t\t\t\t\telse if(ret.matrix[j].row==ret.matrix[j+1].row){\n\t\t\t\t\t\t\tif(ret.matrix[j].column>ret.matrix[j+1].column) {\n\t\t\t\t\t\tEntry temp;\n\t\t\t\t\t\ttemp.row=ret.matrix[j].row;\n\t\t\t\t\t\ttemp.column=ret.matrix[j].column;\n\t\t\t\t\t\ttemp.value=ret.matrix[j].value;\n\t\t\t\t\t\tret.matrix[j].row=ret.matrix[j+1].row;\n\t\t\t\t\t\tret.matrix[j].column=ret.matrix[j+1].column;\n\t\t\t\t\t\tret.matrix[j].value=ret.matrix[j+1].value;\n\t\t\t\t\t\tret.matrix[j+1].row=temp.row;\n\t\t\t\t\t\tret.matrix[j+1].column=temp.column;\n\t\t\t\t\t\tret.matrix[j+1].value=temp.value;\n\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t\n\t\t\t\n\t\t\tSparse x(this->rows,this->columns);\n\t\t\tint i,j;\n\t        for(i=0;i<ret.matrix.size();i++){\n\t        \tint t=1;\n\t        \tEntry temp;\n\t        \tfor( j=i+1;j<ret.matrix.size();j++){\n\t        \t\n\t        \t\tif(ret.matrix[i].row==ret.matrix[j].row&&ret.matrix[i].column==ret.matrix[j].column){\n\t        \t\t\tt=0;\n\t        \t\t\ttemp.row=ret.matrix[i].row;\n\t        \t\t\ttemp.column=ret.matrix[i].column;\n\t        \t\t\ttemp.value=ret.matrix[i].value+ret.matrix[j].value;\n\t\t\t\t\t}\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t\tif(i==ret.matrix.size()-1){\n\t\t\t\t\t\tif(ret.matrix[i].row==ret.matrix[i-1].row&&ret.matrix[i].column==ret.matrix[i-1].column){\n\t        \t\t\t\tgoto y ;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(t==1) x.matrix.push_back(ret.matrix[i]);\n\t\t\t\telse {\n\t\t\t\t\tif(temp.value!=0) {\n\t\t\t\t\tx.matrix.push_back(temp);\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t}i=j-1;\n\t\t\t\t}\n\t\t\t}\n\t\t\ty: \n\t\t\treturn x;\n\t\t}\n\t\n};\n\n\n",
            1591672410.585881,
            100,
            "# 答案正确"
        ],
        [
            "8.4 (C++)",
            "王著",
            "#include <vector>\nusing namespace std;\n#include <iostream>\n\n\nclass Sparse :public Matrix{\n\tprivate:\n\t\tint rows;\n\t\tint columns;\n\tvector<Entry> matrix;\n\tpublic:\n\t\tSparse(int row,int column){\n\t\t\trows=row;\n\t\t\tcolumns=column;\n\t\t}\n\t\tvirtual void set(int row, int column, double value){\n\t\t\tEntry a;\n\t\t\ta.row=row;\n\t\t\ta.column=column;\n\t\t\ta.value=value;\n\t\t\tmatrix.push_back(a);\n\t\t}\n\t\tvirtual int size(int dimension) const{\n\t\tif(dimension==1) return rows;\n\t\telse return columns;\n\t\t}\n\t    virtual double get(int row, int column)const{\n\t    \tfor(int i=0;i<this->matrix.size();i++) {\n\t    \t\tif(matrix[i].row==row&&matrix[i].column==column) return matrix[i].value;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tvirtual void print(){\n\t\t\tfor(int i=matrix.size()-1;i>=1;i--){\n\t\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\t\tif(matrix[j].row>matrix[j+1].row) {\n\t\t\t\t\t\tEntry temp;\n\t\t\t\t\t\ttemp.row=matrix[j].row;\n\t\t\t\t\t\ttemp.column=matrix[j].column;\n\t\t\t\t\t\ttemp.value=matrix[j].value;\n\t\t\t\t\t\tmatrix[j].row=matrix[j+1].row;\n\t\t\t\t\t\tmatrix[j].column=matrix[j+1].column;\n\t\t\t\t\t\tmatrix[j].value=matrix[j+1].value;\n\t\t\t\t\t\tmatrix[j+1].row=temp.row;\n\t\t\t\t\t\tmatrix[j+1].column=temp.column;\n\t\t\t\t\t\tmatrix[j+1].value=temp.value;\n\t\t\t\t\t}\n\t\t\t\t\telse if(matrix[j].row==matrix[j+1].row){\n\t\t\t\t\t\t\tif(matrix[j].column>matrix[j+1].column) {\n\t\t\t\t\t\tEntry temp;\n\t\t\t\t\t\ttemp.row=matrix[j].row;\n\t\t\t\t\t\ttemp.column=matrix[j].column;\n\t\t\t\t\t\ttemp.value=matrix[j].value;\n\t\t\t\t\t\tmatrix[j].row=matrix[j+1].row;\n\t\t\t\t\t\tmatrix[j].column=matrix[j+1].column;\n\t\t\t\t\t\tmatrix[j].value=matrix[j+1].value;\n\t\t\t\t\t\tmatrix[j+1].row=temp.row;\n\t\t\t\t\t\tmatrix[j+1].column=temp.column;\n\t\t\t\t\t\tmatrix[j+1].value=temp.value;\n\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t\n\t\t\tfor(int i=0;i<matrix.size();i++){\n\t\t\t\tif(matrix[i].value!=0)\n\t\t\t\tcout<<\"(\"<<matrix[i].row<<\",\"<<matrix[i].column<<\",\"<<matrix[i].value<<\")\"<<endl;\n\t\t\t}\n\t\t}\n\t\tSparse operator + (const Sparse & other){\n\t\t\tSparse ret(this->rows,this->columns);\n\t\t\tfor(int i=0;i<this->matrix.size();i++){\n\t\t      ret.matrix.push_back(this->matrix[i]);\n\t\t\t}\n\t\t\tfor(int j=0;j<other.matrix.size();j++){\n\t\t\t\tret.matrix.push_back(other.matrix[j]);\n\t\t\t}\n\t\t\tfor(int i=ret.matrix.size()-1;i>=1;i--){\n\t\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\t\tif(ret.matrix[j].row>ret.matrix[j+1].row) {\n\t\t\t\t\t\tEntry temp;\n\t\t\t\t\t\ttemp.row=ret.matrix[j].row;\n\t\t\t\t\t\ttemp.column=ret.matrix[j].column;\n\t\t\t\t\t\ttemp.value=ret.matrix[j].value;\n\t\t\t\t\t\tret.matrix[j].row=ret.matrix[j+1].row;\n\t\t\t\t\t\tret.matrix[j].column=ret.matrix[j+1].column;\n\t\t\t\t\t\tret.matrix[j].value=ret.matrix[j+1].value;\n\t\t\t\t\t\tret.matrix[j+1].row=temp.row;\n\t\t\t\t\t\tret.matrix[j+1].column=temp.column;\n\t\t\t\t\t\tret.matrix[j+1].value=temp.value;\n\t\t\t\t\t}\n\t\t\t\t\telse if(ret.matrix[j].row==ret.matrix[j+1].row){\n\t\t\t\t\t\t\tif(ret.matrix[j].column>ret.matrix[j+1].column) {\n\t\t\t\t\t\tEntry temp;\n\t\t\t\t\t\ttemp.row=ret.matrix[j].row;\n\t\t\t\t\t\ttemp.column=ret.matrix[j].column;\n\t\t\t\t\t\ttemp.value=ret.matrix[j].value;\n\t\t\t\t\t\tret.matrix[j].row=ret.matrix[j+1].row;\n\t\t\t\t\t\tret.matrix[j].column=ret.matrix[j+1].column;\n\t\t\t\t\t\tret.matrix[j].value=ret.matrix[j+1].value;\n\t\t\t\t\t\tret.matrix[j+1].row=temp.row;\n\t\t\t\t\t\tret.matrix[j+1].column=temp.column;\n\t\t\t\t\t\tret.matrix[j+1].value=temp.value;\n\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t\n\t\t\t\n\t\t\tSparse x(this->rows,this->columns);\n\t\t\tint i,j;\n\t        for(i=0;i<ret.matrix.size();i++){\n\t        \tint t=1;\n\t        \tEntry temp;\n\t        \tfor( j=i+1;j<ret.matrix.size();j++){\n\t        \t\n\t        \t\tif(ret.matrix[i].row==ret.matrix[j].row&&ret.matrix[i].column==ret.matrix[j].column){\n\t        \t\t\tt=0;\n\t        \t\t\ttemp.row=ret.matrix[i].row;\n\t        \t\t\ttemp.column=ret.matrix[i].column;\n\t        \t\t\ttemp.value=ret.matrix[i].value+ret.matrix[j].value;\n\t\t\t\t\t}\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t\tif(i==ret.matrix.size()-1){\n\t\t\t\t\t\tif(ret.matrix[i].row==ret.matrix[i-1].row&&ret.matrix[i].column==ret.matrix[i-1].column){\n\t        \t\t\t\tgoto y ;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(t==1) x.matrix.push_back(ret.matrix[i]);\n\t\t\t\telse {\n\t\t\t\t\tif(temp.value!=0) {\n\t\t\t\t\tx.matrix.push_back(temp);\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t}i=j-1;\n\t\t\t\t}\n\t\t\t}\n\t\t\ty: \n\t\t\treturn x;\n\t\t}\n\t Sparse operator * (Sparse & sparse2){\n\t\t Sparse ret(this->rows,sparse2.columns);\n\t\t for(int i=0;i<this->matrix.size();i++){\n\t\t\t Entry temp;\n\t\t\t for(int j=0;j<sparse2.matrix.size();j++){\n\t\t\t\t if(sparse2.matrix[j].row==this->matrix[i].column) {\n\t\t\t\t\t temp.row=this->matrix[i].row;\n\t\t\t\t\t temp.column=sparse2.matrix[j].column;\n\t\t\t\t\t temp.value=this->matrix[i].value*sparse2.matrix[j].value;\n\t\t\t\t\t \n\t\t\t\t\t int x=0;\n\t\t\t\t\t for(int t=0;t<ret.matrix.size();t++){\n\t\t\t\t\t\t if(ret.matrix[t].row==temp.row&&ret.matrix[t].column==temp.column){\n\t\t\t\t\t\t\t x=1;\n\t\t\t\t\t\t\t ret.matrix[t].value+=temp.value;\n\t\t\t\t\t\t }\n\t\t\t\t\t }\n\t\t\t\t\t if(x==0) ret.matrix.push_back(temp);\n\t\t\t\t }\n\t\t\t }\n\t\t }return ret;\n\t }\n\t\n};\n",
            1591674420.8361259,
            100,
            "# 答案正确"
        ],
        [
            "8.5 (C++)",
            "王著",
            "class Point3D :public Point2D{\n\tprivate :\n\tdouble z;\n\tpublic:\n\tPoint3D(){\n\t\tsetX(0);\n\t\tsetY(0);\n\t\tz=0;\n\t}\n\tPoint3D(double x1=0,double x2=0,double x3=0){\n\t\tsetX(x1);\n\t\tsetY(x2);\n\t\tz=x3;\n\t\t\n\t}\n\t virtual double getZ() {\n\t\treturn z;\n\t}\n\t\tvirtual double distance(Point2D & point2) {\n\t\t\tPoint3D * point3=dynamic_cast<Point3D *>(&point2);\n\t\tdouble dx = this->getX() - point2.getX();\n\t\tdouble dy = this->getY() - point2.getY();\n\t\t\tdouble dz=this->getZ()-point3->getZ();\n\t\treturn sqrt(dx * dx + dy * dy+dz*dz);\n\t}\n};",
            1591842651.165573,
            100,
            "# 答案正确"
        ],
        [
            "8.6 (C++)",
            "王著",
            "#include <iostream>\nclass MyTensor : public Tensor<double> {\n\tprivate:\n\t\tdouble *data;\n\t\t\n\tpublic:\n\t\tMyTensor(vector<int> size):Tensor(size){\n\t\t\tint cnt=1;\n\t\t\tfor(int i=0;i<size.size();i++){\n\t\t\t\tcnt*=size[i];\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tdata=new double[cnt];\n\t\t\t\n\t\t}\n\t\t~MyTensor(){\n\t\t\tdelete []data;\n\t\t}\n\t\tvirtual double & get(const vector<int> & indexes){\n\t\t\tif(indexes.size()==1) {\n\t\t\t\treturn data[indexes[0]];\n\t\t\t}\n\t\t\telse if(indexes.size()==2) {\n\t\t\t\treturn data[indexes[0]*sizes[1]+indexes[1]];\n\t\t\t}\n\t\t\telse if(indexes.size()==3){\n\t\t\t\treturn data[indexes[0]*sizes[1]*sizes[2]+indexes[1]*sizes[2]+indexes[2]];\n\t\t\t}\n\t\t\telse if(indexes.size()==4) {\n\t\t\t\treturn data[indexes[0]*sizes[1]*sizes[2]*sizes[3]+indexes[1]*sizes[2]*sizes[3]+indexes[2]*sizes[3]+indexes[3]];\n\t\t\t}\n\t\t}\n\t\n};\n",
            1592450879.8505962,
            100,
            "# 答案正确"
        ],
        [
            "9.1 (C++)",
            "王著",
            "#include <iostream>\nusing namespace std;\nclass Circle{\n\tpublic:\n\tdouble radius;\n\tCircle(double x){\n\t\tradius=x;\n\t}\n\t\n};\nbool operator < (Circle & c1,Circle &c2){\n\tif(c1.radius<c2.radius) return true;\n\treturn false;\n}\nbool operator <= (Circle & c1,Circle &c2){\n\tif(c1.radius<=c2.radius) return true;\n\treturn false;\n}\nbool operator == (Circle & c1,Circle &c2){\n\tif(c1.radius==c2.radius) return true;\n\treturn false;\n}\nbool operator != (Circle & c1,Circle &c2){\n\tif(c1.radius!=c2.radius) return true;\n\treturn false;\n}\nbool operator >= (Circle & c1,Circle &c2){\n\tif(c1.radius>=c2.radius) return true;\n\treturn false;\n}\nbool operator > (Circle & c1,Circle &c2){\n\tif(c1.radius>c2.radius) return true;\n\treturn false;\n}",
            1592749837.2501445,
            100,
            "# 答案正确"
        ],
        [
            "9.2 (C++)",
            "王著",
            "#include <vector>\n#include <iostream>\nusing namespace std;\nclass I{\n\tprivate :\n\tint i1;\n\tint i2=-1;\n\tint i3=-1;\n\tint i4=-1;\n\tvector<int> indexes;\n\tpublic:\n\tI(int i1, int i2=-1, int i3=-1, int i4=-1){\n\t\tindexes.push_back(i1);\n\tif (i2 != -1) indexes.push_back(i2);\n\tif (i3 != -1) indexes.push_back(i3);\n\tif (i4 != -1) indexes.push_back(i4);\n\t}\n\toperator vector<int> ()const{return indexes;}\n};\n",
            1592790319.3381553,
            100,
            "# 答案正确"
        ],
        [
            "9.3 (C++)",
            "王著",
            "class Complex{\n\t\n\t\n\tpublic:\n\t\t\n\tdouble r;\n\tdouble i;\n\tComplex(){\n\t\tr=0;\n\t\ti=0;\n\t}\n\tComplex(double real,double imag){\n\t\tthis->r=real;\n\t\tthis->i=imag;\n\t}\n\tdouble real(){\n\t\treturn r;\n\t}\n\tdouble imag(){\n\t\treturn i;\n\t}\nComplex & operator +=(const Complex & y){\n\t\tthis->r+=y.r;\n\t\tthis->i+=y.i;\n\t\treturn *this;\n\t}\n\tComplex & operator -=(const Complex & y){\n\t\tthis->r-=y.r;\n\t\tthis->i-=y.i;\n\t\treturn *this;\n\t}\n\t\tComplex & operator *=(const Complex & y){\n\t\t\tdouble ret=this->r;\n\t\tthis->r=this->r*y.r-this->i*y.i;\n\t\tthis->i=ret*y.i+this->i*y.r; \n\t\treturn *this;\n\t}\n\t\tComplex & operator /=(const Complex & y){\n\t\t\tdouble ret=this->r;\n\t\tthis->r=(this->r*y.r+this->i*y.i)/(pow(y.r,2)+pow(y.i,2));\n\t\tthis->i=(this->i*y.r-ret*y.i)/(pow(y.r,2)+pow(y.i,2));\n\t\treturn *this;\n\t}\n\n};\nComplex operator +( Complex &c1, Complex &c2){\n\tComplex ret;\n\tret.r=c1.r+c2.r;\n\tret.i=c1.i+c2.i;\n\treturn ret;\n}\nComplex operator +(double x,Complex &c2){\n\tComplex ret;\n\tret.r=x+c2.r;\n\tret.i=c2.i;\n\treturn ret;\n}\nComplex operator -(Complex &c1,Complex &c2){\n\tComplex ret;\n\tret.r=c1.r-c2.r;\n\tret.i=c1.i-c2.i;\n\treturn ret;\n}\nComplex operator -(Complex &c1,double x){\n\tComplex ret;\n\tret.r=c1.r-x;\n\tret.i=c1.i;\n\treturn ret;\n}\nComplex operator *(Complex &c1,Complex &c2){\n\tComplex ret;\n\tret.r=c1.r*c2.r-c1.i*c2.i;\n\tret.i=c1.r*c2.i+c1.i*c2.r;\n\treturn ret;\n}\nComplex operator /(Complex &c1,Complex &c2){\n\tComplex ret;\n\tret.r=(c1.r*c2.r+c1.i*c2.i)/(pow(c2.r,2)+pow(c2.i,2));\n\tret.i=(c1.i*c2.r-c1.r*c2.i)/(pow(c2.r,2)+pow(c2.i,2));\n\treturn ret;\n}\nbool operator ==(Complex &c1,Complex &c2){\n\tif(c1.r==c2.r&&c1.i==c2.i) return true;\n\treturn false;\n}\nbool operator !=(Complex &c1,Complex &c2){\n\tif(c1.r!=c2.r||c1.i!=c2.i)return true;\n\treturn false;\n}",
            1592793563.5784106,
            100,
            "# 答案正确"
        ],
        [
            "9.4 (C++)",
            "王著",
            "class Complex{\n\t\n\t\n\tpublic:\n\t\t\n\tdouble r;\n\tdouble i;\n\tComplex(){\n\t\tr=0;\n\t\ti=0;\n\t}\n\tComplex(double real,double imag){\n\t\tthis->r=real;\n\t\tthis->i=imag;\n\t}\n\tdouble real(){\n\t\treturn r;\n\t}\n\tdouble imag(){\n\t\treturn i;\n\t}\n\tComplex operator =(Complex  other){\n\t\tthis->r=other.r;\n\t\tthis->i=other.i;\n\t\treturn *this;\n\t}\n\n\n};\nComplex operator +( Complex &c1, Complex &c2){\n\tComplex ret;\n\tret.r=c1.r+c2.r;\n\tret.i=c1.i+c2.i;\n\treturn ret;\n}\nComplex operator +(double x,Complex &c2){\n\tComplex ret;\n\tret.r=x+c2.r;\n\tret.i=c2.i;\n\treturn ret;\n}\nComplex operator -(Complex &c1,Complex &c2){\n\tComplex ret;\n\tret.r=c1.r-c2.r;\n\tret.i=c1.i-c2.i;\n\treturn ret;\n}\nComplex operator -(Complex &c1,double x){\n\tComplex ret;\n\tret.r=c1.r-x;\n\tret.i=c1.i;\n\treturn ret;\n}\nostream & operator << (ostream & out,const Complex & m){\n\tout<<m.r<<\" + \"<<m.i<<\" i\";\n\treturn out;\n} \nistream & operator >>(istream & in, Complex & m){\n\tdouble real, imag;\n\tin>>real>>imag;\nComplex ret(real,imag);\nm=ret;\n\treturn in;\n}\n",
            1592794502.843814,
            100,
            "# 答案正确"
        ],
        [
            "9.5 (C++)",
            "王著",
            "class Complex{\n\t\n\t\n\tpublic:\n\t\t\n\tdouble r;\n\tdouble i;\n\tComplex(){\n\t\tr=0;\n\t\ti=0;\n\t}\n\tComplex(double real,double imag){\n\t\tthis->r=real;\n\t\tthis->i=imag;\n\t}\n\tdouble real(){\n\t\treturn r;\n\t}\n\tdouble imag(){\n\t\treturn i;\n\t}\n\tComplex operator =(Complex  other){\n\t\tthis->r=other.r;\n\t\tthis->i=other.i;\n\t\treturn *this;\n\t}\noperator double() const{return r;}\nComplex& operator++(){\n      r++;\n      \n      return *this;\n}\nComplex operator++(int){\n    Complex temp = *this;\n\t\tr++;\n\t\t\n\t\treturn temp;\n}\n};\nComplex operator +( Complex &c1, Complex &c2){\n\tComplex ret;\n\tret.r=c1.r+c2.r;\n\tret.i=c1.i+c2.i;\n\treturn ret;\n}\nComplex operator +(double x,Complex &c2){\n\tComplex ret;\n\tret.r=x+c2.r;\n\tret.i=c2.i;\n\treturn ret;\n}\nComplex operator -(Complex &c1,Complex &c2){\n\tComplex ret;\n\tret.r=c1.r-c2.r;\n\tret.i=c1.i-c2.i;\n\treturn ret;\n}\nComplex operator -(Complex &c1,double x){\n\tComplex ret;\n\tret.r=c1.r-x;\n\tret.i=c1.i;\n\treturn ret;\n}\nostream & operator << (ostream & out,const Complex & m){\n\tout<<m.r<<\" + \"<<m.i<<\" i\";\n\treturn out;\n} \nistream & operator >>(istream & in, Complex & m){\n\tdouble real, imag;\n\tin>>real>>imag;\nComplex ret(real,imag);\nm=ret;\n\treturn in;\n}\n",
            1592795062.2982132,
            100,
            "# 答案正确"
        ],
        [
            "9.6 (C++)",
            "王著",
            "class Tensor\n{\n\tvector<int> sizes;\n\tvector<double> values;\n\t\n\tint _index(const vector<int> & indexes) const {\n\t\tint index = 0;\n\t\tfor (int i = 0; i < this->sizes.size(); ++ i) {\n\t\t\tindex *= sizes[i];\n\t\t\tindex += indexes[i];\n\t\t}\n\t\treturn index;\n\t}\n\t\npublic:\n\tint numel() const {\n\t\tif (this->sizes.size() == 0) return 0;\n\t\tint size = 1;\n\t\tfor (int i = 0; i < this->sizes.size(); ++ i) size *= sizes[i];\n\t\treturn size;\n\t}\n\t\n\tTensor(int i1, int i2=-1, int i3=-1, int i4=-1){\n\t\tsizes.push_back(i1);\n\tif (i2 != -1) sizes.push_back(i2);\n\tif (i3 != -1) sizes.push_back(i3);\n\tif (i4 != -1) sizes.push_back(i4);\n\tint cnt=1;\n\tfor(int i=0;i<sizes.size();i++){\n\t\tcnt*=sizes[i];\n\t}\n\tvalues.resize(cnt);\n\t}\n\t\n\t\n\tdouble & operator () (int i1,int i2=-1,int i3=-1,int i4=-1){\n\t\tvector<int > indexes;\n\t\tindexes.push_back(i1);\n\tif (i2 != -1) indexes.push_back(i2);\n\tif (i3 != -1) indexes.push_back(i3);\n\tif (i4 != -1) indexes.push_back(i4);\n\tint index=_index(indexes);\n\treturn values[index];\n\t}\n};",
            1592876176.634119,
            100,
            "# 答案正确"
        ],
        [
            "9.7 (C++)",
            "王著",
            "class Tensor\n{\n\n\t\npublic:\t\nvector<int> sizes;\n\tvector<double> values;\n\t\n\tint _index(const vector<int> & indexes) const {\n\t\tint index = 0;\n\t\tfor (int i = 0; i < this->sizes.size(); ++ i) {\n\t\t\tindex *= sizes[i];\n\t\t\tindex += indexes[i];\n\t\t}\n\t\treturn index;\n\t}\n\tint numel() const {\n\t\tif (this->sizes.size() == 0) return 0;\n\t\tint size = 1;\n\t\tfor (int i = 0; i < this->sizes.size(); ++ i) size *= sizes[i];\n\t\treturn size;\n\t}\n\t\n\tTensor(int i1=-1, int i2=-1, int i3=-1, int i4=-1){\n\t\tif(i1!=-1)sizes.push_back(i1);\n\tif (i2 != -1) sizes.push_back(i2);\n\tif (i3 != -1) sizes.push_back(i3);\n\tif (i4 != -1) sizes.push_back(i4);\n\tint cnt=1;\n\tfor(int i=0;i<sizes.size();i++){\n\t\tcnt*=sizes[i];\n\t}\n\tvalues.resize(cnt);\n\t}\n\n\t\n\tdouble & operator () (int i1,int i2=-1,int i3=-1,int i4=-1){\n\t\tvector<int > indexes;\n\t\tindexes.push_back(i1);\n\tif (i2 != -1) indexes.push_back(i2);\n\tif (i3 != -1) indexes.push_back(i3);\n\tif (i4 != -1) indexes.push_back(i4);\n\tint index=_index(indexes);\n\treturn values[index];\n\t}\n};\n\nistream & operator >>(istream & in,Tensor & m){\nint dimension;\nin>>dimension;\nfor(int i=1;i<=dimension;i++){\n\tint x;\n\tin>>x;\n\tm.sizes.push_back(x);\n}\nm.values.resize(m.numel());\nfor(int i=0;i<m.numel();i++){\n\tdouble x;\n\tin>>x;\n\tm.values[i]=x;\n}\n\n\nreturn in;\n}\nostream & operator << (ostream & out,const Tensor & m){\n\tout<<m.sizes.size()<<endl;\n\tfor(int i=0;i<m.sizes.size();i++){\n\t\tout<<m.sizes[i];\n\t\tif(i!=m.sizes.size()-1)out<<\" \";\n\t\telse out<<endl;\n\t}\n\tout<<endl;\n\tint dimension=m.sizes.size();\n\tif(dimension==1) {\n\t\tfor(int i=0;i<m.values.size();i++){\n\t\t\tout<<m.values[i]<<\" \";\n\t\t}\n\t\tout<<endl<<endl;\n\t}\n\telse if(dimension==2) {\n\t\tfor(int i=0;i<m.sizes[0];i++){\n\t\t\tfor(int j=0;j<m.sizes[1];j++){\n\t\t\t\tout<<m.values[i*m.sizes[1]+j]<<' ';\n\t\t\t\t\n\t\t\t}out<<endl<<endl;\n\t\t}\n\t}\n\telse if(dimension==3) {\n\t\tfor(int k=0;k<m.sizes[0];k++){\n\t\t\tfor(int i=0;i<m.sizes[1];i++){\n\t\t\t\tfor(int j=0;j<m.sizes[2];j++){\n\t\t\t\t\tvector<int> indexes;\n\t\t\t\t\tindexes.push_back(k);\n\t\t\t\t\tindexes.push_back(i);\n\t\t\t\t\tindexes.push_back(j);\n\t\t\t\t\tint index=m._index(indexes);\n\t\t\t\t\tout<<m.values[index]<<' ';\n\t\t\t\t}\n\t\t\t\tout<<endl;\n\t\t\t}\n\t\t\tout<<endl;\n\t\n\t}}\n\telse if(dimension==4){\n\t\tfor(int x=0;x<m.sizes[0];x++){\n\t\t\tfor(int k=0;k<m.sizes[1];k++){\n\t\t\t\tfor(int i=0;i<m.sizes[2];i++){\n\t\t\t\t\tfor(int j=0;j<m.sizes[3];j++){\n\t\t\t\t\t\tvector<int> indexes;\n\t\t\t\t\tindexes.push_back(x);\n\t\t\t\t\tindexes.push_back(k);\n\t\t\t\t\tindexes.push_back(i);\n\t\t\t\t\tindexes.push_back(j);\n\t\t\t\t\tint index=m._index(indexes);\n\t\t\t\t\tout<<m.values[index]<<' ';\n\t\t\t\t\t}\n\t\t\t\t\tout<<endl;\n\t\t\t\t}\n\t\t\t\tout<<endl;\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\treturn out;\n} ",
            1592878940.2784853,
            100,
            "# 答案正确"
        ],
        [
            "10.1 (C++)",
            "王著",
            "#include <stdexcept>\nclass MatrixSizesDoNotMatchException{\n};\ndouble Matrix::get(int row, int column) const{\n    return this->elements[(row-1)*columns+column-1];\n}\nvoid Matrix::set(int row, int column, double value){\n\t\n\tthis->elements[(row-1)*columns+column-1]=value;\n}\nMatrix Matrix::operator + (const Matrix & matrix2) const{\n\tif(this->rows!=matrix2.rows||this->columns!=matrix2.columns) {\n\t\tMatrixSizesDoNotMatchException a;\n\t\tthrow a;\n\t}\n\tMatrix ret(this->rows,this->columns);\n\tfor(int i=0;i<this->rows*this->columns;i++){\n\t\tret.elements[i]=this->elements[i]+matrix2.elements[i];\n\t}\n\treturn ret;\n}",
            1593614535.6501086,
            100,
            "# 答案正确"
        ],
        [
            "10.2 (C++)",
            "王著",
            "catch (NonPositiveValueException &ex){\n\tcout<<\"caught: NonPositiveValueException\"<<endl;\n}\ncatch (out_of_range & ex){\n\tcout<<\"caught: out_of_range\"<<endl;\n}",
            1593656633.0860188,
            100,
            "# 答案正确"
        ],
        [
            "15.1 (C++)",
            "王著",
            "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\nclass Table{\n \n public:\n  vector<string> headers;\n vector<vector<string> > rows;\n  Table(){}\n void addCol(string str){\n  headers.push_back(str);\n }\n    string json() const{\n  string newstring;\n  newstring = \"{\\n\\theaders: [\";\n   for(int i = 0; i < headers.size(); i ++){\n    newstring = newstring+\"'\"+headers[i]+\"'\"+\",\";\n   }\n   newstring += \"],\\n\\trows: [\\n\";\n   for(int i= 0; i < rows.size(); i++){\n    newstring =newstring+\"\\t\\t[\";\n    for(int j = 0; j < rows[i].size(); j++){\n     newstring =newstring+\"'\"+ rows[i][j]+\"',\";\n    }\n    newstring =newstring+\"],\\n\";\n   }\n   newstring += \"\\t],\\n}\";\n  return  newstring;\n } \n\n vector<string> & operator [] (int i){\n  if(i < rows.size() )return rows[i];\n  if(i >= rows.size()){\n   rows.resize(rows.size()+1);\n   return rows[i];\n  }\n }\n \n \n};\n",
            1594257100.474101,
            100,
            "# 答案正确"
        ],
        [
            "2020-07-09 LAB",
            "王著",
            "#include <iostream>\n#include <string>\nusing namespace std;\nclass Integer{\n\tpublic:\n\tstatic int sum; \n\tint value;\n\tInteger(){\n\t\tvalue=0;\n\t}\n\tInteger(int x){\n\t\tvalue=x;\n\t}\n\tstatic void increase_all(int a){\n\t\tsum=a;\n\t}\n\toperator int()const {return value;}\n};\n\nint Integer::sum=0;\nostream & operator << (ostream & out, Integer & m){\n\tout<<m.value+Integer::sum;\n\tm.value=m.value+Integer::sum;\n\treturn out;\n} \nistream & operator >>(istream & in, Integer & m){\nint x;\n\tin>>x;\n\tm.value=x;\n\treturn in;\n}\n",
            1594264644.4142213,
            100,
            "# 答案正确"
        ],
        [
            "A.1 (C++)",
            "王著",
            "void addFirst(E val){\n\tNode<E>* node=new Node<E> ();\n\tnode->element=val;\n\t\n\tnode->update_prev_and_next_node(0,head);\n\tif(head != 0){Node<E>* temp=head->next_node(0);\n\t\thead->update_prev_and_next_node(node,temp);}\n\t\thead = node;\n\tif(tail==0) tail = node;\n\t ++_size;\n}\nvoid addLast(E val){\n\tNode<E>* node = new Node<E>();\n\tnode->element = val;\n\n\tnode->update_prev_and_next_node(tail,0);\n\tif(tail != 0){ \n\t\ttail->update_prev_and_next_node(tail->prev_node(0),node);}\n\ttail=node;\n\tif(head == 0) head = node;\n\t++_size;\n}\nLinkedList<E> operator =(LinkedList <E> other){\n\tthis->_size=other._size;\n\tthis->head=other.head;\n\tthis->tail= other.tail;\n\treturn *this;\n}\nvoid removeFirstOccurrence(E val){\n\tNode<E>* p = head;\n\tNode<E>* temp =0;\n\tNode<E>* prev=0;\n\twhile(p!=0){\n\t\t\n\t\tif(p->element == val) {\n\t\t\tif(p!=head)\n\t\t\t{\tprev->update_prev_and_next_node(prev->prev_node(p),p->next_node(prev));\n\t\t\tp->next_node(prev)->update_prev_and_next_node(prev,p->next_node(prev)->next_node(p));\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttemp=head;\n\t\t\t\t\n\t\t\t\thead=head->next_node(0);\n\t\t\t\t Node<E>* next= head->next_node(temp);\n\t\t\t\thead->update_prev_and_next_node(0,next);\n\t\t\t\t }\n\t\t\tdelete []p;\n\t\t\tp=0;\n\t\t\tbreak;\n\t\t}\n\t\ttemp=p;\n\t\tp=p->next_node(prev);\n\t\tprev=temp;\n\t}\n\t_size--;\n}\nE get(int position){\n\tint cnt=0;\n\tNode<E>* p = head;\n\tNode<E>* temp = p-> next_node(0);\n\tNode<E>* prev=0;\n\twhile(p!=0){\t\n\t\tcnt++;\n\t\tif(cnt==position+1) return p->element;\n\t\t\ttemp=p;\n\t\tp=p->next_node(prev);\n\t\tprev=temp;\n\t\n\t\t\n\t}\n}\nvoid removeFirst(){\n\tNode<E>* temp=head;\n\thead=head->next_node(0);\n\tNode<E> * next=head->next_node(temp);\n\thead->update_prev_and_next_node(0,next);\n\tdelete []temp;\n\ttemp=0;\n\t_size--;\n}\nvoid removeLast(){\n\tNode<E>* temp=tail;\n\ttail=tail->prev_node(0);\n\tNode<E>* prev=tail->prev_node(temp);\n\ttail->update_prev_and_next_node(prev,0);\n\tdelete []temp;\n\ttemp=0;\n\t_size--;\n}\n",
            1594866215.9595227,
            0,
            "=================================================================\n==19011==ERROR: AddressSanitizer: alloc-dealloc-mismatch (operator new vs operator delete []) on 0x60200000efd0\n    #0 0x7f031f756caa in operator delete[](void*) (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x99caa)\n    #1 0x557bba92c4c6 in LinkedList<double>::removeFirstOccurrence(double) /home/王著/source.cpp:47\n    #2 0x557bba92c4c6 in main /home/王著/main.cpp:66\n    #3 0x7f031ef9182f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2082f)\n    #4 0x557bba92bff8 in _start (/home/王著/main.out+0xff8)\n\n0x60200000efd0 is located 0 bytes inside of 16-byte region [0x60200000efd0,0x60200000efe0)\nallocated by thread T0 here:\n    #0 0x7f031f756532 in operator new(unsigned long) (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x99532)\n    #1 0x557bba92c258 in LinkedList<double>::addFirst(double) /home/王著/source.cpp:2\n    #2 0x557bba92c258 in main /home/王著/main.cpp:56\n    #3 0x7f031ef9182f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2082f)\n\nSUMMARY: AddressSanitizer: alloc-dealloc-mismatch ??:0 operator delete[](void*)\n==19011==HINT: if you don't care about these warnings you may set ASAN_OPTIONS=alloc_dealloc_mismatch=0\n==19011==ABORTING\n"
        ],
        [
            "A.2 (C++)",
            "王著",
            "template<typename E>\nvoid LinkedList<E>::removeAll(const E & e){\nfor(int i=0;i<_size;i++){\n\tNode<E> * temp=get_node(i);\n\tif(temp->element == e) remove(i);\n}\n\tfor(int i=0;i<_size;i++){\n\tNode<E> * temp=get_node(i);\n\tif(temp->element == e) remove(i);\n}\n}",
            1594865795.0234292,
            100,
            "# 答案正确"
        ],
        [
            "A.3 (C++)",
            "王著",
            "#include <vector>\n#include <iostream>\n#include <string>\n#define I(i,n) for (size_t i = 0; i < n; ++ i)\nusing namespace std;\nclass NoSuchKeyException {};\nsize_t circular_shift(size_t bits, int shift_bits) {\n\tconst int num_bits = 8 * sizeof(size_t);\n\tshift_bits = shift_bits % num_bits;\n\treturn bits << shift_bits | bits >> (num_bits - shift_bits);\n}\n\nsize_t hash_function(const int & key) {\n\tsize_t code = 0;\n\t\n\tI(i, key)\n\t\tcode ^= circular_shift(key, i * 5);\n\treturn code;\n}\ntemplate <typename E> \nclass HT{\n\tclass Tuple\n\t{\n\tpublic:\n\t\tint key;\n\t\tE val;\n\t\tbool in_use;\n\n\t\tTuple() : in_use(false) {}\n\t};\n\tvector<Tuple> tuples;\n\tsize_t _size;\n\tsize_t canonical_index(const int & key) const {\n\t\tsize_t hash_code = hash_function(key); // needs hash_function(K)\n\t\treturn hash_code % tuples.size();\n\t}\n\tsize_t indexOfKey(const int & key) const {\n\t\tsize_t index = canonical_index(key);\n\t\twhile (true) { // will enter a dead loop if there is not empty tuple\n\t\t\tif (! tuples[index].in_use) return index;\n\t\t\tif (tuples[index].key == key) return index;\n\t\t\tindex = (index + 1) % tuples.size();\n\t\t}\n\t}\n\tpublic:\n\tHT() : _size(0) {\n\t\ttuples.resize(2);\n\t}\n\tbool containsKey(const int & key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\treturn tuples[index].in_use;\n\t}\n\n\tconst E & operator [] (const int & key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples[index].val;\n\t}\n\n\tE & operator [] (const int & key) {\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples[index].val;\n\t}\n\tvoid put(const int & key, const E & val) {\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].key = key;\n\t\ttuples[index].val = val;\n\t\tif (tuples[index].in_use) return;\n\t\ttuples[index].in_use = true;\n\t\t++ _size;\n\t\t// make sure empty > size / 2\n\t\tif (2 * _size > tuples.size())\n\t\t\t_double_tuples();\n\t}\n\t\tvoid _double_tuples() {\n\t\tvector<Tuple> non_empty_tuples;\n\t\tI(i, tuples.size())\n\t\t\tif (tuples[i].in_use)\n\t\t\t\tnon_empty_tuples.push_back(tuples[i]);\n\t\tclear();\n\t\ttuples.resize(tuples.size() * 2);\n\t\tI(i, non_empty_tuples.size())\n\t\t\tput(non_empty_tuples[i].key, non_empty_tuples[i].val);\n\t}\n\tstatic bool _between(size_t hole, size_t canonical, size_t tuple_index) {\n\t\tif (hole < tuple_index)\n\t\t\treturn canonical > hole && canonical <= tuple_index;\n\t\telse\n\t\t\treturn canonical > hole || canonical <= tuple_index;\n\t}\n\n\tvoid remove(const int & key) { \n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\ttuples[index].in_use = false;\n\t\t-- _size;\n\t\t// if there is a hole between a tuple and its canonical position\n\t\t// move the tuple to the hole\n\t\tsize_t hole = index;\n\t\tsize_t tuple_index = hole;\n\t\twhile (true) {\n\t\t\ttuple_index = (tuple_index + 1) % tuples.size();\n\t\t\tif (! tuples[tuple_index].in_use) return;\n\t\t\tsize_t canonical = canonical_index(tuples[tuple_index].key);\n\t\t\tif (_between(hole, canonical, tuple_index)) continue;\n\t\t\ttuples[hole] = tuples[tuple_index];\n\t\t\thole = tuple_index;\n\t\t\ttuples[hole].in_use = false;\n\t\t}\n\t}\n\n\tsize_t size() const { return _size; }\n    void clear() {\n\t\tI(i, tuples.size())\n\t\t\ttuples[i].in_use = false;\n\t\t_size = 0;\n\t}\n\ttemplate <typename K2>\n\tfriend ostream & operator << (ostream & out, const HT<K2> & dict);\n\n\ttemplate <typename K2>\n\tfriend istream & operator >> (istream & in, HT<K2> & dict);\n   \tvoid _inspect() const {\n\t\tI(i, tuples.size())\n\t\t\tif (tuples[i].in_use)\n\t\t\t\tcout << \"#\" << i << \" C\" << canonical_index(tuples[i].key) \n\t\t\t\t\t<< \" \" << tuples[i].key << \" \" << tuples[i].val << endl;\n\t}\n\tvector <int> getKeys(){\n\t\tvector<int>m;\n\t\tfor(int i=0;i<tuples.size();i++){\n\t\t\tif(tuples[i].in_use!=0) m.push_back(tuples[i].key);\n\t\t}\n\t\treturn m;\n\t}\n};\ntemplate <typename E>\nostream & operator << (ostream & out, const HT<E> & dict) {\n\tout << dict.size() << endl;\n\tI(i, dict.tuples.size())\n\t\tif (dict.tuples[i].in_use)\n\t\t\tout << dict.tuples[i].key << \"\\t\" << dict.tuples[i].val << endl;\n\treturn out;\n}\n\ntemplate <typename E>\nistream & operator >> (istream & in, HT<E> & dict) {\n\tdict.clear();\n\tsize_t size;\n\tin >> size;\n\tI(i, size) {\n\t\tint key;\n\t\tE val;\n\t\tin >> key >> val;\n\t\tdict.put(key, val);\n\t}\n\treturn in;\n}",
            1595474120.9857535,
            100,
            "# 答案正确"
        ],
        [
            "A.4 (C++)",
            "王著",
            "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <stdexcept>\nusing namespace std;\n\n#define I(i,n) for (size_t i = 0; i < n; ++ i)\n\nclass NoSuchKeyException {};\nsize_t circular_shift(size_t bits, int shift_bits) {\n\tconst int num_bits = 8 * sizeof(size_t);\n\tshift_bits = shift_bits % num_bits;\n\treturn bits << shift_bits | bits >> (num_bits - shift_bits);\n}\n\nsize_t hash_function(const string & key) {\n\tsize_t code = 0;\n\tI(i, key.size())\n\t\tcode ^= circular_shift(key[i], i * 5);\n\treturn code;\n}\nsize_t hash_function(const int & key) {\n\tsize_t code = 0;\n\tI(i, key)\n\t\tcode ^= circular_shift(key, i * 5);\n\treturn code;\n}\nclass HT{\n\tclass Tuple\n\t{\n\tpublic:\n\t\tint key1;\n\t\tstring key2;\n\t\tint val1;\n\t\tstring val2;\n\t\tbool in_use;\n\n\t\tTuple(){\n\t\t\tkey1=0;\n\t\t\tkey2=0;\n\t\t\tval1=0;\n\t\t\tval2=0;\n\t\t\tin_use=0;\n\t\t}\n\t};\n\tvector<Tuple> tuples;\n\tsize_t _size;\n\n\tsize_t canonical_index(const int & key) const {\n\t\tsize_t hash_code = hash_function(key); // needs hash_function(K)\n\t\treturn hash_code % tuples.size();\n\t}\n\tsize_t canonical_index(const string & key) const {\n\t\tsize_t hash_code = hash_function(key); // needs hash_function(K)\n\t\treturn hash_code % tuples.size();\n\t}\n\tsize_t indexOfKey(const int & key) const {\n\t\tsize_t index = canonical_index(key);\n\t\twhile (true) { // will enter a dead loop if there is not empty tuple\n\t\t\tif (! tuples[index].in_use) return index;\n\t\t\tif (tuples[index].key1 == key) return index;\n\t\t\tindex = (index + 1) % tuples.size();\n\t\t}\n\t}\n\tsize_t indexOfKey(const string & key) const {\n\t\tsize_t index = canonical_index(key);\n\t\twhile (true) { // will enter a dead loop if there is not empty tuple\n\t\t\tif (! tuples[index].in_use) return index;\n\t\t\tif (tuples[index].key2 == key) return index;\n\t\t\tindex = (index + 1) % tuples.size();\n\t\t}\n\t}\n\tpublic:\n\tHT() : _size(0) {\n\t\ttuples.resize(2);\n\t}\n\n\tbool containsKey(const int & key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\treturn tuples[index].in_use;\n\t}\n\tbool containsKey(const string & key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\treturn tuples[index].in_use;\n\t}\n\tint & operator [] (const int & key) {\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples[index].val1;\n\t}\n\t\tstring & operator [] (const int & key) {\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples[index].va2;\n\t}\n\tint & operator [] (const string & key) {\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples[index].val1;\n\t}\n\t\tstring & operator [] (const string & key) {\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples[index].val2;\n\t}\n\t\tvoid put(const int & key, const int & val) {\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].key1 = key;\n\t\ttuples[index].val1 = val;\n\t\tif (tuples[index].in_use) return;\n\t\ttuples[index].in_use = true;\n\t\t++ _size;\n\t\t// make sure empty > size / 2\n\t\tif (2 * _size > tuples.size())\n\t\t\t_double_tuples();\n\t}\n\t\t\tvoid put(const int & key, const string & val) {\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].key1 = key;\n\t\ttuples[index].val2 = val;\n\t\tif (tuples[index].in_use) return;\n\t\ttuples[index].in_use = true;\n\t\t++ _size;\n\t\t// make sure empty > size / 2\n\t\tif (2 * _size > tuples.size())\n\t\t\t_double_tuples();\n\t}\n\t\t\tvoid put(const string & key, const int & val) {\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].key2 = key;\n\t\ttuples[index].val1 = val;\n\t\tif (tuples[index].in_use) return;\n\t\ttuples[index].in_use = true;\n\t\t++ _size;\n\t\t// make sure empty > size / 2\n\t\tif (2 * _size > tuples.size())\n\t\t\t_double_tuples();\n\t}\n\tvoid put(const string & key, const string & val) {\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].key2 = key;\n\t\ttuples[index].val2 = val;\n\t\tif (tuples[index].in_use) return;\n\t\ttuples[index].in_use = true;\n\t\t++ _size;\n\t\t// make sure empty > size / 2\n\t\tif (2 * _size > tuples.size())\n\t\t\t_double_tuples();\n\t}\n\tvoid _double_tuples() {\n\t\tvector<Tuple> non_empty_tuples;\n\t\tI(i, tuples.size())\n\t\t\tif (tuples[i].in_use)\n\t\t\t\tnon_empty_tuples.push_back(tuples[i]);\n\t\tclear();\n\t\ttuples.resize(tuples.size() * 2);\n\t\tI(i, non_empty_tuples.size()){\n\t\t\tif(key1!=0&&val1!=0)\n\t\t\tput(non_empty_tuples[i].key1, non_empty_tuples[i].val1);\n\t\tif(key1!=0&&val2!=0) put(non_empty_tuples[i].key1, non_empty_tuples[i].val2);\n\t\t\tif(key2!=0&&val1!=0) put(non_empty_tuples[i].key2, non_empty_tuples[i].val1);\n\t\t\tif(key2!=0&&val2!=0) put(non_empty_tuples[i].key2, non_empty_tuples[i].val2);\n\t\t}\n\t}\n\tstatic bool _between(size_t hole, size_t canonical, size_t tuple_index) {\n\t\tif (hole < tuple_index)\n\t\t\treturn canonical > hole && canonical <= tuple_index;\n\t\telse\n\t\t\treturn canonical > hole || canonical <= tuple_index;\n\t}\n\t\tvoid remove(const int & key) { \n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\ttuples[index].in_use = false;\n\t\t-- _size;\n\t\t// if there is a hole between a tuple and its canonical position\n\t\t// move the tuple to the hole\n\t\tsize_t hole = index;\n\t\tsize_t tuple_index = hole;\n\t\twhile (true) {\n\t\t\ttuple_index = (tuple_index + 1) % tuples.size();\n\t\t\tif (! tuples[tuple_index].in_use) return;\n\t\t\tsize_t canonical = canonical_index(tuples[tuple_index].key);\n\t\t\tif (_between(hole, canonical, tuple_index)) continue;\n\t\t\ttuples[hole] = tuples[tuple_index];\n\t\t\thole = tuple_index;\n\t\t\ttuples[hole].in_use = false;\n\t\t}\n\t}\n\t\t\tvoid remove(const string & key) { \n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\ttuples[index].in_use = false;\n\t\t-- _size;\n\t\t// if there is a hole between a tuple and its canonical position\n\t\t// move the tuple to the hole\n\t\tsize_t hole = index;\n\t\tsize_t tuple_index = hole;\n\t\twhile (true) {\n\t\t\ttuple_index = (tuple_index + 1) % tuples.size();\n\t\t\tif (! tuples[tuple_index].in_use) return;\n\t\t\tsize_t canonical = canonical_index(tuples[tuple_index].key);\n\t\t\tif (_between(hole, canonical, tuple_index)) continue;\n\t\t\ttuples[hole] = tuples[tuple_index];\n\t\t\thole = tuple_index;\n\t\t\ttuples[hole].in_use = false;\n\t\t}\n\t}\n\t\n\tvoid clear() {\n\t\tI(i, tuples.size())\n\t\t\ttuples[i].in_use = false;\n\t\t_size = 0;\n\t}\n\n\tsize_t size() const { return _size; }\n\n\t\n};",
            1595573972.0181684,
            0,
            "In file included from main.cpp:1:0:\nsource.cpp:93:12: error: ‘std::__cxx11::string& HT::operator[](const int&)’ cannot be overloaded\n   string & operator [] (const int & key) {\n            ^\nsource.cpp:87:8: error: with ‘int& HT::operator[](const int&)’\n  int & operator [] (const int & key) {\n        ^\nsource.cpp:105:12: error: ‘std::__cxx11::string& HT::operator[](const string&)’ cannot be overloaded\n   string & operator [] (const string & key) {\n            ^\nsource.cpp:99:8: error: with ‘int& HT::operator[](const string&)’\n  int & operator [] (const string & key) {\n        ^\nsource.cpp: In constructor ‘HT::Tuple::Tuple()’:\nsource.cpp:41:8: error: ambiguous overload for ‘operator=’ (operand types are ‘std::__cxx11::string {aka std::__cxx11::basic_string<char>}’ and ‘int’)\n    key2=0;\n        ^\nIn file included from /usr/include/c++/5/string:52:0,\n                 from /usr/include/c++/5/bits/locale_classes.h:40,\n                 from /usr/include/c++/5/bits/ios_base.h:41,\n                 from /usr/include/c++/5/ios:42,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from source.cpp:1,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/basic_string.h:550:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::operator=(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\n       operator=(const basic_string& __str)\n       ^\n/usr/include/c++/5/bits/basic_string.h:558:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::operator=(const _CharT*) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\n       operator=(const _CharT* __s)\n       ^\n/usr/include/c++/5/bits/basic_string.h:569:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::operator=(_CharT) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\n       operator=(_CharT __c)\n       ^\n/usr/include/c++/5/bits/basic_string.h:587:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::operator=(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\n       operator=(basic_string&& __str)\n       ^\nIn file included from main.cpp:1:0:\nsource.cpp:43:8: error: ambiguous overload for ‘operator=’ (operand types are ‘std::__cxx11::string {aka std::__cxx11::basic_string<char>}’ and ‘int’)\n    val2=0;\n        ^\nIn file included from /usr/include/c++/5/string:52:0,\n                 from /usr/include/c++/5/bits/locale_classes.h:40,\n                 from /usr/include/c++/5/bits/ios_base.h:41,\n                 from /usr/include/c++/5/ios:42,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from source.cpp:1,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/basic_string.h:550:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::operator=(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\n       operator=(const basic_string& __str)\n       ^\n/usr/include/c++/5/bits/basic_string.h:558:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::operator=(const _CharT*) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\n       operator=(const _CharT* __s)\n       ^\n/usr/include/c++/5/bits/basic_string.h:569:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::operator=(_CharT) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\n       operator=(_CharT __c)\n       ^\n/usr/include/c++/5/bits/basic_string.h:587:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::operator=(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\n       operator=(basic_string&& __str)\n       ^\nIn file included from main.cpp:1:0:\nsource.cpp: In member function ‘std::__cxx11::string& HT::operator[](const int&)’:\nsource.cpp:97:24: error: ‘__gnu_cxx::__alloc_traits<std::allocator<HT::Tuple> >::value_type {aka class HT::Tuple}’ has no member named ‘va2’\n   return tuples[index].va2;\n                        ^\nsource.cpp: In member function ‘void HT::_double_tuples()’:\nsource.cpp:163:7: error: ‘key1’ was not declared in this scope\n    if(key1!=0&&val1!=0)\n       ^\nsource.cpp:163:16: error: ‘val1’ was not declared in this scope\n    if(key1!=0&&val1!=0)\n                ^\nsource.cpp:165:6: error: ‘key1’ was not declared in this scope\n   if(key1!=0&&val2!=0) put(non_empty_tuples[i].key1, non_empty_tuples[i].val2);\n      ^\nsource.cpp:165:15: error: ‘val2’ was not declared in this scope\n   if(key1!=0&&val2!=0) put(non_empty_tuples[i].key1, non_empty_tuples[i].val2);\n               ^\nsource.cpp:166:7: error: ‘key2’ was not declared in this scope\n    if(key2!=0&&val1!=0) put(non_empty_tuples[i].key2, non_empty_tuples[i].val1);\n       ^\nsource.cpp:166:16: error: ‘val1’ was not declared in this scope\n    if(key2!=0&&val1!=0) put(non_empty_tuples[i].key2, non_empty_tuples[i].val1);\n                ^\nsource.cpp:167:7: error: ‘key2’ was not declared in this scope\n    if(key2!=0&&val2!=0) put(non_empty_tuples[i].key2, non_empty_tuples[i].val2);\n       ^\nsource.cpp:167:16: error: ‘val2’ was not declared in this scope\n    if(key2!=0&&val2!=0) put(non_empty_tuples[i].key2, non_empty_tuples[i].val2);\n                ^\nsource.cpp: In member function ‘void HT::remove(const int&)’:\nsource.cpp:189:59: error: ‘__gnu_cxx::__alloc_traits<std::allocator<HT::Tuple> >::value_type {aka class HT::Tuple}’ has no member named ‘key’\n    size_t canonical = canonical_index(tuples[tuple_index].key);\n                                                           ^\nsource.cpp: In member function ‘void HT::remove(const string&)’:\nsource.cpp:209:59: error: ‘__gnu_cxx::__alloc_traits<std::allocator<HT::Tuple> >::value_type {aka class HT::Tuple}’ has no member named ‘key’\n    size_t canonical = canonical_index(tuples[tuple_index].key);\n                                                           ^\nmain.cpp: In function ‘int main()’:\nmain.cpp:32:26: error: no matching function for call to ‘std::__cxx11::basic_string<char>::basic_string(int&)’\n  cout << (string)map[key2] << endl;\n                          ^\nIn file included from /usr/include/c++/5/string:52:0,\n                 from /usr/include/c++/5/bits/locale_classes.h:40,\n                 from /usr/include/c++/5/bits/ios_base.h:41,\n                 from /usr/include/c++/5/ios:42,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from source.cpp:1,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/basic_string.h:534:9: note: candidate: template<class _InputIterator, class> std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(_InputIterator, _InputIterator, const _Alloc&)\n         basic_string(_InputIterator __beg, _InputIterator __end,\n         ^\n/usr/include/c++/5/bits/basic_string.h:534:9: note:   template argument deduction/substitution failed:\nmain.cpp:32:26: note:   candidate expects 3 arguments, 1 provided\n  cout << (string)map[key2] << endl;\n                          ^\nIn file included from /usr/include/c++/5/string:52:0,\n                 from /usr/include/c++/5/bits/locale_classes.h:40,\n                 from /usr/include/c++/5/bits/ios_base.h:41,\n                 from /usr/include/c++/5/ios:42,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from source.cpp:1,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/basic_string.h:511:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&&, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\n       basic_string(basic_string&& __str, const _Alloc& __a)\n       ^\n/usr/include/c++/5/bits/basic_string.h:511:7: note:   candidate expects 2 arguments, 1 provided\n/usr/include/c++/5/bits/basic_string.h:507:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\n       basic_string(const basic_string& __str, const _Alloc& __a)\n       ^\n/usr/include/c++/5/bits/basic_string.h:507:7: note:   candidate expects 2 arguments, 1 provided\n/usr/include/c++/5/bits/basic_string.h:503:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(std::initializer_list<_Tp>, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\n       basic_string(initializer_list<_CharT> __l, const _Alloc& __a = _Alloc())\n       ^\n/usr/include/c++/5/bits/basic_string.h:503:7: note:   no known conversion for argument 1 from ‘int’ to ‘std::initializer_list<char>’\n/usr/include/c++/5/bits/basic_string.h:476:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\n       basic_string(basic_string&& __str) noexcept\n       ^\n/usr/include/c++/5/bits/basic_string.h:476:7: note:   no known conversion for argument 1 from ‘int’ to ‘std::__cxx11::basic_string<char>&&’\n/usr/include/c++/5/bits/basic_string.h:464:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, _CharT, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int]\n       basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc())\n       ^\n/usr/include/c++/5/bits/basic_string.h:464:7: note:   candidate expects 3 arguments, 1 provided\n/usr/include/c++/5/bits/basic_string.h:454:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const _CharT*, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>] <near match>\n       basic_string(const _CharT* __s, const _Alloc& __a = _Alloc())\n       ^\n/usr/include/c++/5/bits/basic_string.h:454:7: note:   conversion of argument 1 would be ill-formed:\nmain.cpp:32:26: error: invalid conversion from ‘int’ to ‘const char*’ [-fpermissive]\n  cout << (string)map[key2] << endl;\n                          ^\nIn file included from /usr/include/c++/5/string:52:0,\n                 from /usr/include/c++/5/bits/locale_classes.h:40,\n                 from /usr/include/c++/5/bits/ios_base.h:41,\n                 from /usr/include/c++/5/ios:42,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from source.cpp:1,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/basic_string.h:444:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const _CharT*, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int]\n       basic_string(const _CharT* __s, size_type __n,\n       ^\n/usr/include/c++/5/bits/basic_string.h:444:7: note:   candidate expects 3 arguments, 1 provided\n/usr/include/c++/5/bits/basic_string.h:426:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int]\n       basic_string(const basic_string& __str, size_type __pos,\n       ^\n/usr/include/c++/5/bits/basic_string.h:426:7: note:   candidate expects 4 arguments, 1 provided\n/usr/include/c++/5/bits/basic_string.h:410:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int]\n       basic_string(const basic_string& __str, size_type __pos,\n       ^\n/usr/include/c++/5/bits/basic_string.h:410:7: note:   candidate expects 3 arguments, 1 provided\n/usr/include/c++/5/bits/basic_string.h:398:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\n       basic_string(const basic_string& __str)\n       ^\n/usr/include/c++/5/bits/basic_string.h:398:7: note:   no known conversion for argument 1 from ‘int’ to ‘const std::__cxx11::basic_string<char>&’\n/usr/include/c++/5/bits/basic_string.h:390:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\n       basic_string(const _Alloc& __a)\n       ^\n/usr/include/c++/5/bits/basic_string.h:390:7: note:   no known conversion for argument 1 from ‘int’ to ‘const std::allocator<char>&’\n/usr/include/c++/5/bits/basic_string.h:379:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string() [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\n       basic_string()\n       ^\n/usr/include/c++/5/bits/basic_string.h:379:7: note:   candidate expects 0 arguments, 1 provided\nmain.cpp:33:26: error: no matching function for call to ‘std::__cxx11::basic_string<char>::basic_string(int&)’\n  cout << (string)map[key3] << endl;\n                          ^\nIn file included from /usr/include/c++/5/string:52:0,\n                 from /usr/include/c++/5/bits/locale_classes.h:40,\n                 from /usr/include/c++/5/bits/ios_base.h:41,\n                 from /usr/include/c++/5/ios:42,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from source.cpp:1,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/basic_string.h:534:9: note: candidate: template<class _InputIterator, class> std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(_InputIterator, _InputIterator, const _Alloc&)\n         basic_string(_InputIterator __beg, _InputIterator __end,\n         ^\n/usr/include/c++/5/bits/basic_string.h:534:9: note:   template argument deduction/substitution failed:\nmain.cpp:33:26: note:   candidate expects 3 arguments, 1 provided\n  cout << (string)map[key3] << endl;\n                          ^\nIn file included from /usr/include/c++/5/string:52:0,\n                 from /usr/include/c++/5/bits/locale_classes.h:40,\n                 from /usr/include/c++/5/bits/ios_base.h:41,\n                 from /usr/include/c++/5/ios:42,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from source.cpp:1,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/basic_string.h:511:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&&, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\n       basic_string(basic_string&& __str, const _Alloc& __a)\n       ^\n/usr/include/c++/5/bits/basic_string.h:511:7: note:   candidate expects 2 arguments, 1 provided\n/usr/include/c++/5/bits/basic_string.h:507:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\n       basic_string(const basic_string& __str, const _Alloc& __a)\n       ^\n/usr/include/c++/5/bits/basic_string.h:507:7: note:   candidate expects 2 arguments, 1 provided\n/usr/include/c++/5/bits/basic_string.h:503:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(std::initializer_list<_Tp>, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\n       basic_string(initializer_list<_CharT> __l, const _Alloc& __a = _Alloc())\n       ^\n/usr/include/c++/5/bits/basic_string.h:503:7: note:   no known conversion for argument 1 from ‘int’ to ‘std::initializer_list<char>’\n/usr/include/c++/5/bits/basic_string.h:476:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\n       basic_string(basic_string&& __str) noexcept\n       ^\n/usr/include/c++/5/bits/basic_string.h:476:7: note:   no known conversion for argument 1 from ‘int’ to ‘std::__cxx11::basic_string<char>&&’\n/usr/include/c++/5/bits/basic_string.h:464:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, _CharT, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int]\n       basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc())\n       ^\n/usr/include/c++/5/bits/basic_string.h:464:7: note:   candidate expects 3 arguments, 1 provided\n/usr/include/c++/5/bits/basic_string.h:454:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const _CharT*, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>] <near match>\n       basic_string(const _CharT* __s, const _Alloc& __a = _Alloc())\n       ^\n/usr/include/c++/5/bits/basic_string.h:454:7: note:   conversion of argument 1 would be ill-formed:\nmain.cpp:33:26: error: invalid conversion from ‘int’ to ‘const char*’ [-fpermissive]\n  cout << (string)map[key3] << endl;\n                          ^\nIn file included from /usr/include/c++/5/string:52:0,\n                 from /usr/include/c++/5/bits/locale_classes.h:40,\n                 from /usr/include/c++/5/bits/ios_base.h:41,\n                 from /usr/include/c++/5/ios:42,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from source.cpp:1,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/basic_string.h:444:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const _CharT*, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int]\n       basic_string(const _CharT* __s, size_type __n,\n       ^\n/usr/include/c++/5/bits/basic_string.h:444:7: note:   candidate expects 3 arguments, 1 provided\n/usr/include/c++/5/bits/basic_string.h:426:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int]\n       basic_string(const basic_string& __str, size_type __pos,\n       ^\n/usr/include/c++/5/bits/basic_string.h:426:7: note:   candidate expects 4 arguments, 1 provided\n/usr/include/c++/5/bits/basic_string.h:410:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int]\n       basic_string(const basic_string& __str, size_type __pos,\n       ^\n/usr/include/c++/5/bits/basic_string.h:410:7: note:   candidate expects 3 arguments, 1 provided\n/usr/include/c++/5/bits/basic_string.h:398:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\n       basic_string(const basic_string& __str)\n       ^\n/usr/include/c++/5/bits/basic_string.h:398:7: note:   no known conversion for argument 1 from ‘int’ to ‘const std::__cxx11::basic_string<char>&’\n/usr/include/c++/5/bits/basic_string.h:390:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\n       basic_string(const _Alloc& __a)\n       ^\n/usr/include/c++/5/bits/basic_string.h:390:7: note:   no known conversion for argument 1 from ‘int’ to ‘const std::allocator<char>&’\n/usr/include/c++/5/bits/basic_string.h:379:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string() [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\n       basic_string()\n       ^\n/usr/include/c++/5/bits/basic_string.h:379:7: note:   candidate expects 0 arguments, 1 provided\n"
        ]
    ],
    "table_name": "答案"
}