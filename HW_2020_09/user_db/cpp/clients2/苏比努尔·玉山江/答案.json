{
    "__update_time__": 1595513495.8344805,
    "field_names": [
        "题目名",
        "用户名",
        "答案",
        "提交时间",
        "分数",
        "评语"
    ],
    "field_types": [
        "text",
        "text",
        "text",
        "time",
        "number",
        "text"
    ],
    "foreign_keys": {},
    "primary_keys": [],
    "rows": [
        [
            "测试2",
            "苏比努尔·玉山江",
            "#include <iostream>\n#include <string>\n#include<vector>\nusing namespace std;\nint main()\n{\n\tvector<string> v;\n\tstring s;\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tcin >> s;\n\t\tv.push_back(s);\n\t}\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tfor (int j = 0; j < 9; j++)\n\t\t {\n\t\t if (v[j] > v[j + 1])\n\t\t {\n\t\t\t swap(v[j], v[j + 1]);\n\t\t }\n\t\t }\n\t}\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tcout << v[i] << \" \";\n\n\t}\n}",
            1587611242.0907917,
            100,
            "# 答案正确"
        ],
        [
            "1.1 (C++)",
            "苏比努尔·玉山江",
            "class Matrix5x5{\n\tpublic :\n\t\tdouble get(int a, int b){\n\t\t\treturn matrix[a][b] ;\n\t\t}\n\n\t\tvoid set(int a , int b, double num){\n\t\t\tmatrix[a][b] = num ;\n\t\t}\n\tprivate:\n\tdouble matrix[5][5] ;\n};\n\nMatrix5x5 operator + (Matrix5x5 & a, Matrix5x5 & b ){\n\tMatrix5x5 c ;\n\tfor (int i = 0 ; i < 5 ; ++ i){\n\t\tfor (int j = 0 ; j < 5 ; ++ j){\n\t\t\tdouble temp = a.get(i,j) + b.get(i,j) ;\n\t\t\tc.set(i,j,temp) ;\n\t\t}\n\t}\n\treturn c ;\n}",
            1587698013.5451791,
            100,
            "# 答案正确"
        ],
        [
            "1.2 (C++)",
            "苏比努尔·玉山江",
            "class  School \n{\n\tpublic: \n\tSchool()\n\t{\n \n\t\tchar n[10] = \"NO_NAME\";\n\t\tsetName(n);\n\t\tsetAge(0);\n\t\t \n\t}\n\tvoid setName(char  n[])\n\t{\n\t\t int i;\n\t\tfor(  i = 0; n[i] != '\\0'; i++ )\n\t\t\tname[i] = n[i];\n\t\tname[i] = '\\0'; \n\t\t \n\t}\n\tvoid setAge(int year)\n\t{\n\t\tage = year;\n\t}\n\tvoid operator ++ ()\n\t{\n\t\tage++;\n\t}\n\tchar name[10];\n\tint age;\n};",
            1588214784.2194266,
            100,
            "# 答案正确"
        ],
        [
            "2.1 (C++)",
            "苏比努尔·玉山江",
            "#include<iostream>\nusing namespace std;\nclass Matrix{\n    public:\n\t\n    Matrix(){\n        rows = 0;\n        columns = 0;\n        values = nullptr;\n    }\n\t\n    Matrix(int rows, int columns){\n        this->rows = rows;\n        this->columns = columns;\n        if (values != nullptr)\n        delete values;\n\t\t\n        values = new  double * [ rows];\n        for( int i = 0; i < rows; i++){\n            values[i] = new double [columns];\n\t\t\t\t\tfor (int j = 0; j < columns; j++)\n\t\t\t\t\t\tvalues[i][j] = 0;\n        }\n    }\n\t\n    ~Matrix(){\n        for  (int i = 0; i < rows; i++){\n\t\t\t\tif (values[i] != 0)  delete values[i];\n\t\t\t}\n\t\t\tif (values != 0)  delete values;\n    }\n\t\n    void print(){\n        for (int i = 0; i < rows; i++){\n            for (int j = 0; j < columns; j++){\n                cout<<values[ i][j]<<\"    \";\n         \t\t}\n            cout << endl;\n   \t\t\t}\n   \t }\n    private:\n    int rows;\n    int columns;\n    double ** values;\n};",
            1588904739.4001372,
            100,
            "=================================================================\n==11784==ERROR: AddressSanitizer: alloc-dealloc-mismatch (operator new [] vs operator delete) on 0x60400000df90\n    #0 0x7f336996fb2a in operator delete(void*) (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x99b2a)\n    #1 0x560b16be9a11 in Matrix::~Matrix() /home/苏比努尔·玉山江/source.cpp:28\n    #2 0x560b16be97e7 in main /home/苏比努尔·玉山江/main.cpp:7\n    #3 0x7f3368f9482f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2082f)\n    #4 0x560b16be9288 in _start (/home/苏比努尔·玉山江/main.out+0x1288)\n\n0x60400000df90 is located 0 bytes inside of 48-byte region [0x60400000df90,0x60400000dfc0)\nallocated by thread T0 here:\n    #0 0x7f336996f6b2 in operator new[](unsigned long) (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x996b2)\n    #1 0x560b16be95a4 in Matrix::Matrix(int, int) /home/苏比努尔·玉山江/source.cpp:20\n    #2 0x560b16be95a4 in main /home/苏比努尔·玉山江/main.cpp:7\n    #3 0x7f3368f9482f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2082f)\n\nSUMMARY: AddressSanitizer: alloc-dealloc-mismatch ??:0 operator delete(void*)\n==11784==HINT: if you don't care about these warnings you may set ASAN_OPTIONS=alloc_dealloc_mismatch=0\n==11784==ABORTING\n"
        ],
        [
            "2.2 (C++)",
            "苏比努尔·玉山江",
            "#include<iostream>\n#include <iomanip>\nusing namespace std;\nclass Matrix\n{\n    public:\n    Matrix()\n    {\n        rows = 0;\n        columns = 0;\n        values = nullptr;\n    }\n    Matrix(int rows, int columns)\n    {\n        this->rows = rows;\n        this->columns = columns;\n        if (values != nullptr)\n        delete values;\n\t\t\n        values = new  double * [ rows];\n        for(int i = 0; i < rows; i++)\n        {\n            values[i] = new double [columns];\n\t\t\t\t\tfor (int j = 0; j < columns; j++)\n\t\t\t\t\t\tvalues[i][j] = 0;\n        }\n    }\n\tMatrix(int rows, int columns, double v[] )\n    {\n        this->rows = rows;\n        this->columns = columns;\n        if (values != nullptr)\n        delete values;\n        values = new  double * [ rows];\n        for(int i = 0; i < rows; i++)\n        {\n            values[i] = new double [columns];\n\t\t\t\t\tfor (int j = 0; j < columns; j++)\n\t\t\t\t\t\tthis-> values[i][j] = v[i * columns + j];\n        }\n    }\n    ~Matrix()\n    {\n        for  (int i = 0; i < rows; i++)\n\t\t{\n\t\t\tif (values[i] != 0)\n\t\t\t\tdouble values[i];\n\t\t}\n\t\tif (values != 0)\n\t\t\tdouble values;\n    }\n    void print()\n    {\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < columns; j++)\n            {\n\t\t\t\t\t\t\n                cout<< setw(5) <<values[ i][j] ;\n \n            }\n            cout << endl;\n        }\n    }\n    private:\n    int rows;\n    int columns;\n    double ** values;\n};",
            1588904764.6444314,
            100,
            "# 答案正确"
        ],
        [
            "2.3 (C++)",
            "苏比努尔·玉山江",
            "#include<iostream>\n#include <iomanip>\nusing namespace std;\nclass Matrix\n{\n    public:\n    Matrix()\n    {\n        rows = 0;\n        columns = 0;\n        values = nullptr;\n    }\n    Matrix(int rows, int columns)\n    {\n        this->rows = rows;\n        this->columns = columns;\n        if (values != nullptr)\n        delete values;\n\t\t\n        values = new  double * [ rows];\n        for(int i = 0; i < rows; i++)\n        {\n            values[i] = new double [columns];\n\t\t\t\t\tfor (int j = 0; j < columns; j++)\n\t\t\t\t\t\tvalues[i][j] = 0;\n        }\n    }\n\tMatrix(int rows, int columns, double v[] )\n    {\n        this->rows = rows;\n        this->columns = columns;\n        if (values != nullptr)\n        delete values;\n        values = new  double * [ rows];\n        for(int i = 0; i < rows; i++)\n        {\n            values[i] = new double [columns];\n\t\t\t\t\tfor (int j = 0; j < columns; j++)\n\t\t\t\t\t\tthis-> values[i][j] = v[i * columns + j];\n        }\n    }\n\t  Matrix(const Matrix & matrix2)\n\t  {\n\t\t\t this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        if (values != nullptr)\n        delete values;\n        values = new  double * [ rows];\n\t\t   for(int i = 0; i < rows; i++)\n        {\n            values[i] = new double [columns];\n\t\t\t\t\tfor (int j = 0; j < columns; j++)\n\t\t\t\t\t\tthis-> values[i][j] = matrix2.values[i][j];\n        }\n\t  }\n    ~Matrix()\n    {\n        for  (int i = 0; i < rows; i++)\n\t\t{\n\t\t\tif (values[i] != 0)\n\t\t\t\tdouble values[i];\n\t\t}\n\t\tif (values != 0)\n\t\t\tdouble values;\n    }\n    void print()\n    {\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < columns; j++)\n            {\n\t\t\t\t\t\t\n                cout<< \"    \"<<values[ i][j] ;\n \n            }\n            cout << endl;\n        }\n    }\n    private:\n    int rows;\n    int columns;\n    double ** values;\n};",
            1588904788.6369596,
            100,
            "# 答案正确"
        ],
        [
            "2.5 (C++)",
            "苏比努尔·玉山江",
            "#include<iostream>\n#include <iomanip>\nusing namespace std;\nclass Matrix\n{\n    public:\n    Matrix()\n    {\n        rows = 0;\n        columns = 0;\n        values = nullptr;\n    }\n    Matrix(int rows, int columns)\n    {\n        this->rows = rows;\n        this->columns = columns;\n        if (values != nullptr)\n        delete values;\n\t\t\n        values = new  double * [ rows];\n        for(int i = 0; i < rows; i++)\n        {\n            values[i] = new double [columns];\n\t\t\t\t\tfor (int j = 0; j < columns; j++)\n\t\t\t\t\t\tvalues[i][j] = 0;\n        }\n    }\n\tMatrix(int rows, int columns, double v[] )\n    {\n        this->rows = rows;\n        this->columns = columns;\n        if (values != nullptr)\n        delete values;\n        values = new  double * [ rows];\n        for(int i = 0; i < rows; i++)\n        {\n            values[i] = new double [columns];\n\t\t\t\t\tfor (int j = 0; j < columns; j++)\n\t\t\t\t\t\tthis-> values[i][j] = v[i * columns + j];\n        }\n    }\n\t  Matrix(const Matrix & matrix2)\n\t  {\n\t\t\t this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        if (values != nullptr)\n        delete values;\n        values = new  double * [ rows];\n\t\t   for(int i = 0; i < rows; i++)\n        {\n            values[i] = new double [columns];\n\t\t\t\t\tfor (int j = 0; j < columns; j++)\n\t\t\t\t\t\tthis-> values[i][j] = matrix2.values[i][j];\n        }\n\t  }\n\t Matrix getRow(int row)\n\t {\n\t\tMatrix a (1, columns);\n\t\t for(int i = 0; i < columns; i++)\n\t\t {\n\t\t\ta.values[0][i] = this->values[row - 1][i];\n\t\t }\n\t\t return a;\n\t }\n\t Matrix getColumn(int col)\n\t {\n\t\tMatrix a (rows, 1);\n\t\t for (int i = 0; i < rows; i++)\n\t\t {\n\t\t\ta.values[i][0] = this->values[i][col - 1];\n\t\t }\n\t\t return a;\n\t\t \n\t\t \n\t }\n    ~Matrix()\n    {\n        for  (int i = 0; i < rows; i++)\n\t\t{\n\t\t\tif (values[i] != 0)\n\t\t\t\tdouble values[i];\n\t\t}\n\t\tif (values != 0)\n\t\t\tdouble values;\n    }\n    void print()\n    {\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < columns; j++)\n            {\n\t\t\t\t\t\t\n                cout<< \"    \"<<values[ i][j] ;\n \n            }\n            cout << endl;\n        }\n    }\n    private:\n    int rows;\n    int columns;\n    double ** values;\n};",
            1588904813.959441,
            100,
            "# 答案正确"
        ],
        [
            "2.6 (C++)",
            "苏比努尔·玉山江",
            "#include <iostream>\nusing namespace std;\nclass Matrix\n{\npublic:\n    Matrix()\n    {\n        matrix = nullptr;\n        row = 0;\n        col = 0;\n    }\n    Matrix(int row, int col)\n    {\n        this -> row = row;\n        this -> col = col; \n        matrix = new double*[row];\n        for (int i = 0; i < row; ++i)\n        {\n            matrix[i] = new double [col];\n            for (int j = 0; j < col; ++j)\n            {\n                matrix[i][j] = 0;\n            }\n        }\n    }\n\n    Matrix(int row, int col, const double *value)\n    {\n        this -> row = row;\n        this -> col = col;\n        matrix = new double*[row];\n        for (int i = 0; i < row; ++i)\n        {\n            matrix[i] = new double [col];\n            for (int j = 0; j < col; ++j)\n            {\n                matrix[i][j] = value[i * col + j];\n            }\n        }\n    }\n\n    Matrix (const Matrix & matrix1)\n    {\n        row = matrix1.row;\n        col = matrix1.col;\n        matrix = new double*[row];\n        for (int i = 0; i < row; ++i)\n        {\n            matrix[i] = new double [col];\n            for (int j = 0; j < col; ++j)\n            {\n                matrix[i][j] = matrix1.matrix[i][j];\n            }\n        }\n    }\n\n    ~Matrix()\n    {\n        for (int i = 0; i < row; ++i)\n        {\n            if (matrix[i] != nullptr) delete [] matrix[i];\n        }\n        if (matrix != nullptr) delete [] matrix;\n    }\n\n   \n    Matrix concatenateRows(Matrix & matrix1)\n    {\n        Matrix t(row  * 2 , col);\n        for(int i = 0; i < row * 2; ++i)\n        {\n            for(int j = 0; j < col; ++j)\n            {\n\t\t\t\t\t\tif ( i < row)\n                t.matrix[i][j] = matrix[i][j];\n\t\t\t\telse\n\t\t\t\t\t t.matrix[i][j] = matrix1.matrix[i - row][j];\n            }\n        }\n        \n        return t;\n    }\n\n    Matrix concatenateColumns(Matrix & matrix1)\n    {\n        Matrix t(row, col + matrix1.col);\n        for(int i = 0; i < row ; ++i)\n        {\n            for(int j = 0; j < col * 2; ++j)\n            {\n\t\t\t\t\t\tif (j < col)\n                t.matrix[i][j] = matrix[i][j];\n\t\t\t\t\t\telse\n\t\t\t\t\t  t.matrix[i][j] = matrix1.matrix[i][j - col];\n            }\n        }\n         \n        return t;\n    }\n\n   \n\n    \n    void print()\n    {\n        for (int i = 0; i < row; ++i)\n        {\n            for (int j = 0; j < col; ++j)\n            {\n                cout << \"    \" << matrix[i][j]  ;\n            }\n            cout << endl;\n        }\n    }\n \n   \n     \n \n \n\nprivate:\n    double **matrix;\n    int row;\n    int col;\n};\n",
            1588904840.6151698,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/08",
            "苏比努尔·玉山江",
            "double & Tensor_get(int dimensions, const int sizes[],   double data[], int x0, int x1, int x2, int x3)\n{\n\tif (dimensions == 1)\n\t\treturn   data[x0];\n\tif (dimensions == 2)\n\t\treturn data[x0 * sizes[1] +  x1];\n\tif (dimensions == 3)\n\t\treturn data[x0 * sizes[1] * sizes[2] +  x1 * sizes[2] + x2  ];\n\tif (dimensions == 4)\n\t\treturn data[x0 * sizes[1] * sizes[2] * sizes[3]+  x1 * sizes[2]  * sizes[3]+ x2 * sizes[3] + x3  ];\n}",
            1588906404.0903926,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/14",
            "苏比努尔·玉山江",
            "#include<cstdio>\n#include<iostream>\nusing namespace std;\nvoid Tensor_print(int dimensions, const int sizes[], const double data[])\n{\n\tif (dimensions == 1)\n\t{\n\t\tprintf(\"Tensor of %d\\n\",sizes[0]);\n\t\tfor (int i = 0; i < sizes[0]; i++)\n\t\t{\n\t\t\tcout << data[i] << endl;\n\t\t}\n\t\t\n\t}\n\tif (dimensions == 2)\n\t{\n\t\tprintf(\"Tensor of %dx%d\\n\",sizes[0],sizes[1]);\n\t\tfor (int i = 0; i < sizes[0]; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < sizes[1]; j++)\n\t\t\t{\n\t\t\t\tcout<<\"    \"<<data[i * sizes[1] + j];\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t}\n\tif (dimensions == 3)\n    {\n        printf(\"Tensor of %dx%dx%d\\n\",sizes[0],sizes[1],sizes[2]);\n        for (int i = 0; i < sizes[0]; i++)\n        {\n            printf(\"date[%d]\\n\",i);\n            for (int j = 0; j < sizes[1];j++)\n            {\n                for (int k = 0; k < sizes[2]; k++)\n                {\n                    cout <<\"    \"<< data[i*sizes[1]*sizes[2] + j * sizes[2] + k];\n                }\n                cout << endl;\n            }\n        }\n    }\n    if (dimensions==4)\n    {\n\t\tprintf(\"Tensor of %dx%dx%dx%d\\n\",sizes[0],sizes[1],sizes[2],sizes[3]);\n        for (int i = 0; i < sizes[0];i++)\n        {\n            for (int j = 0; j < sizes[1]; j++)\n            {\n                printf(\"data[%d][%d]\\n\",i,j);\n                for (int k = 0; k < sizes[2]; k++)\n                {\n                    for (int m = 0; m < sizes[3];m++)\n                    {\n                        cout << \"    \" <<data[i*sizes[1]*sizes[2]*sizes[3] + j * sizes[2] * sizes[3] + k * sizes[3] + m];\n                    }\n                    cout << endl;\n                }\n            }\n        }\n    }\n\tcout << endl;\n}",
            1589427595.1228926,
            54,
            "# 答案不正确\n\n# 随机输入:\n8.3\n9.8\n9.5\n5.9\n\n\n# 参考答案:\nTensor of 5\n8.3\n8.3\n8.3\n8.3\n8.3\n\nTensor of 3x4\n    9.8    9.8    9.8    9.8\n    9.8    9.8    9.8    9.8\n    9.8    9.8    9.8    9.8\n\nTensor of 3x4x5\ndata[0]\n    9.5    9.5    9.5    9.5    9.5\n    9.5    9.5    9.5    9.5    9.5\n    9.5    9.5    9.5    9.5    9.5\n    9.5    9.5    9.5    9.5    9.5\ndata[1]\n    9.5    9.5    9.5    9.5    9.5\n    9.5    9.5    9.5    9.5    9.5\n    9.5    9.5    9.5    9.5    9.5\n    9.5    9.5    9.5    9.5    9.5\ndata[2]\n    9.5    9.5    9.5    9.5    9.5\n    9.5    9.5    9.5    9.5    9.5\n    9.5    9.5    9.5    9.5    9.5\n    9.5    9.5    9.5    9.5    9.5\n\nTensor of 2x3x4x5\ndata[0][0]\n    5.9    5.9    5.9    5.9    5.9\n    5.9    5.9    5.9    5.9    5.9\n    5.9    5.9    5.9    5.9    5.9\n    5.9    5.9    5.9    5.9    5.9\ndata[0][1]\n    5.9    5.9    5.9    5.9    5.9\n    5.9    5.9    5.9    5.9    5.9\n    5.9    5.9    5.9    5.9    5.9\n    5.9    5.9    5.9    5.9    5.9\ndata[0][2]\n    5.9    5.9    5.9    5.9    5.9\n    5.9    5.9    5.9    5.9    5.9\n    5.9    5.9    5.9    5.9    5.9\n    5.9    5.9    5.9    5.9    5.9\ndata[1][0]\n    5.9    5.9    5.9    5.9    5.9\n    5.9    5.9    5.9    5.9    5.9\n    5.9    5.9    5.9    5.9    5.9\n    5.9    5.9    5.9    5.9    5.9\ndata[1][1]\n    5.9    5.9    5.9    5.9    5.9\n    5.9    5.9    5.9    5.9    5.9\n    5.9    5.9    5.9    5.9    5.9\n    5.9    5.9    5.9    5.9    5.9\ndata[1][2]\n    5.9    5.9    5.9    5.9    5.9\n    5.9    5.9    5.9    5.9    5.9\n    5.9    5.9    5.9    5.9    5.9\n    5.9    5.9    5.9    5.9    5.9\n\n\n# 我的答案:\nTensor of 5\n8.3\n8.3\n8.3\n8.3\n8.3\n\n\nTensor of 3x4\n    9.8    9.8    9.8    9.8\n    9.8    9.8    9.8    9.8\n    9.8    9.8    9.8    9.8\n\n\nTensor of 3x4x5\ndate[0]\n    9.5    9.5    9.5    9.5    9.5\n    9.5    9.5    9.5    9.5    9.5\n    9.5    9.5    9.5    9.5    9.5\n    9.5    9.5    9.5    9.5    9.5\ndate[1]\n    9.5    9.5    9.5    9.5    9.5\n    9.5    9.5    9.5    9.5    9.5\n    9.5    9.5    9.5    9.5    9.5\n    9.5    9.5    9.5    9.5    9.5\ndate[2]\n    9.5    9.5    9.5    9.5    9.5\n    9.5    9.5    9.5    9.5    9.5\n    9.5    9.5    9.5    9.5    9.5\n    9.5    9.5    9.5    9.5    9.5\n\n\nTensor of 2x3x4x5\ndata[0][0]\n    5.9    5.9    5.9    5.9    5.9\n    5.9    5.9    5.9    5.9    5.9\n    5.9    5.9    5.9    5.9    5.9\n    5.9    5.9    5.9    5.9    5.9\ndata[0][1]\n    5.9    5.9    5.9    5.9    5.9\n    5.9    5.9    5.9    5.9    5.9\n    5.9    5.9    5.9    5.9    5.9\n    5.9    5.9    5.9    5.9    5.9\ndata[0][2]\n    5.9    5.9    5.9    5.9    5.9\n    5.9    5.9    5.9    5.9    5.9\n    5.9    5.9    5.9    5.9    5.9\n    5.9    5.9    5.9    5.9    5.9\ndata[1][0]\n    5.9    5.9    5.9    5.9    5.9\n    5.9    5.9    5.9    5.9    5.9\n    5.9    5.9    5.9    5.9    5.9\n    5.9    5.9    5.9    5.9    5.9\ndata[1][1]\n    5.9    5.9    5.9    5.9    5.9\n    5.9    5.9    5.9    5.9    5.9\n    5.9    5.9    5.9    5.9    5.9\n    5.9    5.9    5.9    5.9    5.9\ndata[1][2]\n    5.9    5.9    5.9    5.9    5.9\n    5.9    5.9    5.9    5.9    5.9\n    5.9    5.9    5.9    5.9    5.9\n    5.9    5.9    5.9    5.9    5.9\n\n"
        ],
        [
            "2.4 (C++)",
            "苏比努尔·玉山江",
            "#include<iostream>\n#include <iomanip>\nusing namespace std;\nclass Matrix\n{\npublic:\n    Matrix()\n    {\n        rows = 0;\n        columns = 0;\n        values = 0;\n    }\n    Matrix(int rows, int columns)\n    {\n        this->rows = rows;\n        this->columns = columns;\n        \n        values = new  double[rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            values[i] = 0;\n        }\n    }\n    Matrix(int r, int c, double v[])\n    {\n        this->rows = r;\n        this->columns = c;\n         \n        values = new  double[r * c];\n        for (int i = 0; i < r * c; i++)\n        {\n            values[i] = v[i];\n        }\n    }\n    void set(int r, int c, double v)\n    {\n        values[(r - 1) * columns + c - 1] = v;\n    }\n    Matrix& operator= (const Matrix& matrix2)\n    {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        if (values != nullptr)\n            delete []values;\n\t\t\n        values = new  double[rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            values[i] = matrix2.values[i];\n        }\n        return *this;\n    }\n    Matrix(const Matrix& matrix2)\n    {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n       \n        values = new  double[rows * columns];\n        for (int i = 0; i < rows; i++)\n        {\n            values[i] = matrix2.values[i];\n        }\n    }\n\n    ~Matrix()\n    {\n        if (values != 0)\n            delete []values;\n    }\n    void print()\n    {\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < columns; j++)\n            {\n\n                cout << \"    \" << values[i * columns + j];\n            }\n            cout << endl;\n        }\n    }\nprivate:\n    int rows;\n    int columns;\n    double* values;\n};",
            1589813995.8445053,
            100,
            "# 答案正确"
        ],
        [
            "2.7 (C++)",
            "苏比努尔·玉山江",
            "#include<iostream>\n#include <iomanip>\nusing namespace std;\nclass Matrix\n{\npublic:\n    Matrix()\n    {\n        rows = 0;\n        columns = 0;\n        values = 0;\n    }\n    Matrix(int rows, int columns)\n    {\n        this->rows = rows;\n        this->columns = columns;\n        \n        values = new  double[rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            values[i] = 0;\n        }\n    }\n    Matrix(int r, int c, double v[])\n    {\n        this->rows = r;\n        this->columns = c;\n        values = new  double[r * c];\n        for (int i = 0; i < r * c; i++)\n        {\n            values[i] = v[i];\n        }\n    }\n    Matrix(const Matrix& matrix2)\n    {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        values = new  double[rows * columns];\n        for (int i = 0; i < rows; i++)\n        {\n            values[i] = matrix2.values[i];\n        }\n    }\n    void set(int r, int c, double v)\n    {\n        values[(r - 1) * columns + c - 1] = v;\n    }\n    Matrix& operator= (const Matrix& matrix2)\n    {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        if (values != nullptr)\n            delete []values;\n\n        values = new  double[rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            values[i] = matrix2.values[i];\n        }\n        return *this;\n    }\n    Matrix reshape(int r , int c ) const\n    {\n        double * a = new double [r * c];\n        int m = 0;\n        for (int i = 0; i < columns; i++)\n        {\n            for (int j = 0; j < rows; j++)\n            {\n                a[m++] = this->values[j * columns + i];\n            }\n        }\n        m = 0;\n        Matrix temp(r,c);\n        for (int i = 0; i < c; i++)\n        {\n            for(int j = 0; j < r; j++)\n            {\n                temp.values[j * c + i] = a[m++];\n            }\n        }\n        delete []a;\n        return temp;\n\n    }\n    ~Matrix()\n    {\n        if (values != 0)\n            delete []values;\n    }\n    void print()\n    {\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < columns; j++)\n            {\n\n                cout << \"    \" << values[i * columns + j];\n            }\n            cout << endl;\n        }\n    }\nprivate:\n    int rows;\n    int columns;\n    double* values;\n};\n",
            1589814016.6167686,
            100,
            "# 答案正确"
        ],
        [
            "2.8 (C++)",
            "苏比努尔·玉山江",
            "#include<iostream>\n#include <iomanip>\nusing namespace std;\nclass Matrix\n{\npublic:\n    Matrix()\n    {\n        rows = 0;\n        columns = 0;\n        values = 0;\n    }\n    Matrix(int rows, int columns)\n    {\n        this->rows = rows;\n        this->columns = columns;\n        \n        values = new  double[rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            values[i] = 0;\n        }\n    }\n    Matrix(int r, int c, double v[])\n    {\n        this->rows = r;\n        this->columns = c;\n        values = new  double[r * c];\n        for (int i = 0; i < r * c; i++)\n        {\n            values[i] = v[i];\n        }\n    }\n    Matrix(const Matrix& matrix2)\n    {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        values = new  double[rows * columns];\n        for (int i = 0; i < rows; i++)\n        {\n            values[i] = matrix2.values[i];\n        }\n    }\n    void set(int r, int c, double v)\n    {\n        values[(r - 1) * columns + c - 1] = v;\n    }\n    Matrix& operator= (const Matrix& matrix2)\n    {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        if (values != nullptr)\n            delete []values;\n\n        values = new  double[rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            values[i] = matrix2.values[i];\n        }\n        return *this;\n    }\n    Matrix reshape(int r , int c ) const\n    {\n        double * a = new double [r * c];\n        int m = 0;\n        for (int i = 0; i < columns; i++)\n        {\n            for (int j = 0; j < rows; j++)\n            {\n                a[m++] = this->values[j * columns + i];\n            }\n        }\n        m = 0;\n        Matrix temp(r,c);\n        for (int i = 0; i < c; i++)\n        {\n            for(int j = 0; j < r; j++)\n            {\n                temp.values[j * c + i] = a[m++];\n            }\n        }\n        delete []a;\n        return temp;\n    }\n    Matrix transpose()\n    {\n        double * a = new double [rows * columns];\n        int m = 0;\n        for (int i = 0; i < columns; i++)\n        {\n            for (int j = 0; j < rows; j++)\n            {\n                a[m++] = this->values[j * columns + i];\n            }\n        }\n        Matrix temp(columns,rows,a);\n        delete []a;\n        return temp;\n    }\n    ~Matrix()\n    {\n        if (values != 0)\n            delete []values;\n    }\n    void print()\n    {\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < columns; j++)\n            {\n\n                cout << \"    \" << values[i * columns + j];\n            }\n            cout << endl;\n        }\n    }\nprivate:\n    int rows;\n    int columns;\n    double* values;\n};",
            1589814036.252745,
            100,
            "# 答案正确"
        ],
        [
            "2.10 (C++)",
            "苏比努尔·玉山江",
            "#include<iostream>\n#include <iomanip>\nusing namespace std;\nclass Matrix\n{\npublic:\n   Matrix()\n    {\n        rows = 0;\n        columns = 0;\n        values = nullptr;\n    }\n    Matrix(int rows, int columns)\n    {\n        this->rows = rows;\n        this->columns = columns;\n        values = new  double[rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            values[i] = 0;\n        }\n    }\n    Matrix(int r, int c, double v[])\n    {\n        this->rows = r;\n        this->columns = c;\n        values = new  double[r * c];\n        for (int i = 0; i < r * c; i++)\n        {\n            values[i] = v[i];\n        }\n    }\n  Matrix(const Matrix& matrix2)\n    {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        values = new  double[rows * columns];\n        for (int i = 0; i < rows; i++)\n        {\n            values[i] = matrix2.values[i];\n        }\n    }\n   \n    Matrix operator * (const Matrix & matrix2) const\n    {\n        Matrix temp(rows,rows);\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < rows; j++)\n            {\n                double sum = 0;\n                for(int k = 0; k < columns; k++)\n                {\n                    sum += this->values[i * columns + k] * matrix2.values[k * rows + j];\n                }\n                temp.values[i*rows+j] = sum;\n            }\n        }\n        return temp;\n    }\n    Matrix  operator * (double v ) const\n    {\n        double * a = new double[rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = v * values[i];\n        }\n        Matrix temp (rows,columns,a);\n        delete []a;\n        return temp;\n    }\n    Matrix& operator= (const Matrix& matrix2)\n    {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        if (values != nullptr)\n            delete []values;\n\n        values = new  double[rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            values[i] = matrix2.values[i];\n        }\n        return *this;\n    }\n    Matrix reshape(int r , int c ) const\n    {\n        double * a = new double [r * c];\n        int m = 0;\n        for (int i = 0; i < columns; i++)\n        {\n            for (int j = 0; j < rows; j++)\n            {\n                a[m++] = this->values[j * columns + i];\n            }\n        }\n        m = 0;\n        Matrix temp(r,c);\n        for (int i = 0; i < c; i++)\n        {\n            for(int j = 0; j < r; j++)\n            {\n                temp.values[j * c + i] = a[m++];\n            }\n        }\n        delete []a;\n        return temp;\n    }\n    Matrix transpose()\n    {\n        double * a = new double [rows * columns];\n        int m = 0;\n        for (int i = 0; i < columns; i++)\n        {\n            for (int j = 0; j < rows; j++)\n            {\n                a[m++] = this->values[j * columns + i];\n            }\n        }\n        Matrix temp(columns,rows,a);\n        delete []a;\n        return temp;\n    }\n    ~Matrix()\n    {\n        if (values != 0)\n            delete []values;\n    }\n    void print()\n    {\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < columns; j++)\n            {\n\n                cout << \"    \" << values[i * columns + j];\n            }\n            cout << endl;\n        }\n    }\nprivate:\n    int rows;\n    int columns;\n    double* values;\n};",
            1589814058.6974247,
            100,
            "# 答案正确"
        ],
        [
            "2.11 (C++)",
            "苏比努尔·玉山江",
            "#include <iostream>\n\nusing namespace std;\n\nclass Matrix\n{\npublic:\n    Matrix()\n    {\n        matrix = nullptr;\n        rows = 0;\n        columns = 0;\n    }\n\n    Matrix(int rows, int columns)\n    {\n        this -> rows = rows;\n        this -> columns = columns;\n        matrix = new double*[rows];\n        for (int i = 0; i < rows; ++i)\n        {\n            matrix[i] = new double [columns];\n            for (int j = 0; j < columns; ++j)\n            {\n                matrix[i][j] = 0;\n            }\n        }\n    }\n\n    Matrix(int rows, int columns, const double *value)\n    {\n        this -> rows = rows;\n        this -> columns = columns;\n        matrix = new double*[rows];\n        for (int i = 0; i < rows; ++i)\n        {\n            matrix[i] = new double [columns];\n            for (int j = 0; j < columns; ++j)\n            {\n                matrix[i][j] = value[i * columns + j];\n            }\n        }\n    }\n\n    Matrix (const Matrix & matrix1)\n    {\n        rows = matrix1.rows;\n        columns = matrix1.columns;\n        matrix = new double*[rows];\n        for (int i = 0; i < rows; ++i)\n        {\n            matrix[i] = new double [columns];\n            for (int j = 0; j < columns; ++j)\n            {\n                matrix[i][j] = matrix1.matrix[i][j];\n            }\n        }\n    }\n\n    ~Matrix()\n    {\n        for (int i = 0; i < rows; ++i)\n        {\n            if (matrix[i] != nullptr) delete [] matrix[i];\n        }\n        if (matrix != nullptr) delete [] matrix;\n    }\n\n    Matrix max()\n    {\n        if (rows > 1 && columns > 1)\n        {\n            Matrix t(1, columns);\n            double num_max = 0;\n            for (int i = 0; i < columns; ++i)\n            {\n                for (int j = 0; j < rows; ++j)\n                {\n                    num_max = num_max > matrix[j][i] ? num_max : matrix[j][i];\n                }\n                t[0][i] = num_max;\n                num_max = 0;\n            }\n            return t;\n        }\n        else if (rows == 1 && columns > 1)\n        {\n            double num_max[1] = {0};\n            for (int i = 0; i < columns; ++i)\n            {\n                num_max[0] = num_max[0] > matrix[0][i] ? num_max[0] : matrix[0][i];\n            }\n            Matrix t(1, 1, num_max);\n            return t;\n        }\n        else return *this;\n    }\n\n    Matrix min()\n    {\n        if (rows > 1 && columns > 1)\n        {\n            Matrix t(1, columns);\n            double num_min = 99999999;\n            for (int i = 0; i < columns; ++i)\n            {\n                for (int j = 0; j < rows; ++j)\n                {\n                    num_min = num_min > matrix[j][i] ? matrix[j][i] : num_min;\n                }\n                t[0][i] = num_min;\n                num_min = 99999999;\n            }\n            return t;\n        }\n        else if (rows == 1 && columns > 1)\n        {\n            double num_min[1] = {99999999};\n            for (int i = 0; i < columns; ++i)\n            {\n                num_min[0] = num_min[0] > matrix[0][i] ? matrix[0][i] : num_min[0];\n            }\n            Matrix t(1, 1, num_min);\n            return t;\n        }\n        else return *this;\n    }\n\n    Matrix sum()\n    {\n        if (rows > 1 && columns > 1)\n        {\n            Matrix t(1, columns);\n            double sum = 0;\n            for (int i = 0; i < columns; ++i)\n            {\n                for (int j = 0; j < rows; ++j)\n                {\n                    sum +=  matrix[j][i];\n                }\n                t[0][i] = sum;\n                sum = 0;\n            }\n            return t;\n        }\n        else if (rows == 1 && columns > 1)\n        {\n            double sum[1] = {0};\n            for (int i = 0; i < columns; ++i)\n            {\n                sum[0] += matrix[0][i];\n            }\n            Matrix t(1, 1, sum);\n            return t;\n        }\n        else return *this;\n    }\n\n    double * operator [] (int n)\n    {\n        return matrix[n];\n    }\n\n    void print()\n    {\n        for (int i = 0; i < rows; ++i)\n        {\n            for (int j = 0; j < columns; ++j)\n            {\n                cout << \"    \" << matrix[i][j];\n            }\n            cout << endl;\n        }\n    }\n\nprivate:\n    double **matrix;\n    int rows;\n    int columns;\n};",
            1589814079.268518,
            100,
            "# 答案正确"
        ],
        [
            "2.12 (C++)",
            "苏比努尔·玉山江",
            "#include<iostream>\n#include <iomanip>\nusing namespace std;\n#include<cmath>\n\nclass Matrix\n{\npublic:\n    Matrix()\n    {\n        rows = 0;\n        columns = 0;\n        values = 0;\n    }\n    Matrix(int rows, int columns)\n    {\n        this->rows = rows;\n        this->columns = columns;\n        \n        values = new  double[rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            values[i] = 0;\n        }\n    }\n    Matrix(int r, int c, double v[])\n    {\n        this->rows = r;\n        this->columns = c;\n        values = new  double[r * c];\n        for (int i = 0; i < r * c; i++)\n        {\n            values[i] = v[i];\n        }\n    }\n    Matrix(const Matrix& matrix2)\n    {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        values = new  double[rows * columns];\n        for (int i = 0; i < rows; i++)\n        {\n            values[i] = matrix2.values[i];\n        }\n    }\n    void set(int r, int c, double v)\n    {\n        values[(r - 1) * columns + c - 1] = v;\n    }\n    Matrix operator * (const Matrix & matrix2) const\n    {\n        Matrix temp(rows,rows);\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < rows; j++)\n            {\n                double sum = 0;\n                for(int k = 0; k < columns; k++)\n                {\n                    sum += this->values[i * columns + k] * matrix2.values[k * rows + j];\n                }\n                temp.values[i*rows+j] = sum;\n            }\n        }\n        return temp;\n    }\n    Matrix  operator * (double v ) const\n    {\n        double * a = new double[rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = v * values[i];\n        }\n        Matrix temp (rows,columns,a);\n        delete []a;\n        return temp;\n    }\n    Matrix& operator= (const Matrix& matrix2)\n    {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        if (values != nullptr)\n            delete []values;\n\n        values = new  double[rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            values[i] = matrix2.values[i];\n        }\n        return *this;\n    }\n    Matrix reshape(int r , int c ) const\n    {\n        double * a = new double [r * c];\n        int m = 0;\n        for (int i = 0; i < columns; i++)\n        {\n            for (int j = 0; j < rows; j++)\n            {\n                a[m++] = this->values[j * columns + i];\n            }\n        }\n        m = 0;\n        Matrix temp(r,c);\n        for (int i = 0; i < c; i++)\n        {\n            for(int j = 0; j < r; j++)\n            {\n                temp.values[j * c + i] = a[m++];\n            }\n        }\n        delete []a;\n        return temp;\n    }\n    Matrix transpose()\n    {\n        double * a = new double [rows * columns];\n        int m = 0;\n        for (int i = 0; i < columns; i++)\n        {\n            for (int j = 0; j < rows; j++)\n            {\n                a[m++] = this->values[j * columns + i];\n            }\n        }\n        Matrix temp(columns,rows,a);\n        delete []a;\n        return temp;\n    }\n    Matrix  pow(double exponent)\n    {\n        double * a = new double[columns * rows];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] =  std ::pow(values[i],exponent);\n        }\n        Matrix temp (rows,columns,a);\n        delete [] a;\n        return temp;\n    }\n    Matrix  exp()\n    {\n        double * a = new double[columns * rows];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] =  std ::exp(values[i] );\n        }\n        Matrix temp (rows,columns,a);\n        delete [] a;\n        return temp;\n    }\n    Matrix  log()\n    {\n        double * a = new double[columns * rows];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] =  std ::log (values[i]);\n        }\n        Matrix temp (rows,columns,a);\n        delete [] a;\n        return temp;\n    }\n    Matrix  abs()\n    {\n        double * a = new double[columns * rows];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] =  std :: abs (values[i]);\n        }\n        Matrix temp (rows,columns,a);\n        delete [] a;\n        return temp;\n    }\n    ~Matrix()\n    {\n        if (values != 0)\n            delete []values;\n    }\n    void print()\n    {\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < columns; j++)\n            {\n\n                cout << \"    \" << values[i * columns + j];\n            }\n            cout << endl;\n        }\n    }\nprivate:\n    int rows;\n    int columns;\n    double* values;\n};",
            1589814103.0956688,
            100,
            "# 答案正确"
        ],
        [
            "2.9 (C++)",
            "苏比努尔·玉山江",
            "#include<iostream>\n#include <iomanip>\nusing namespace std;\nclass Matrix\n{\npublic:\n    Matrix()\n    {\n        rows = 0;\n        columns = 0;\n        values = 0;\n    }\n    Matrix(int rows, int columns)\n    {\n        this->rows = rows;\n        this->columns = columns;\n        \n        values = new  double[rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            values[i] = 0;\n        }\n    }\n    Matrix(int r, int c, double v[])\n    {\n        this->rows = r;\n        this->columns = c;\n        values = new  double[r * c];\n        for (int i = 0; i < r * c; i++)\n        {\n            values[i] = v[i];\n        }\n    }\n    Matrix(const Matrix& matrix2)\n    {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        values = new  double[rows * columns];\n        for (int i = 0; i < rows; i++)\n        {\n            values[i] = matrix2.values[i];\n        }\n    }\n\n    Matrix& operator= (const Matrix& matrix2)\n    {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        if (values != nullptr)\n            delete []values;\n\n        values = new  double[rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            values[i] = matrix2.values[i];\n        }\n        return *this;\n    }\n    Matrix operator + (const Matrix & matrix2) const\n    {\n        double * a = new double [this->rows * this->columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = this->values[i] + matrix2.values[i];\n        }\n        Matrix temp(rows,columns,a);\n        delete []a;\n        return temp;\n    }\n    Matrix operator + (double v) const\n    {\n        double * a = new double [this->rows * this->columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = this->values[i] + v;\n        }\n        Matrix temp(rows,columns,a);\n        delete []a;\n        return temp;\n    }\n    Matrix operator - (const Matrix & matrix2) const\n    {\n        double * a = new double [this->rows * this->columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = this->values[i] - matrix2.values[i];\n        }\n        Matrix temp(rows,columns,a);\n        delete []a;\n        return temp;\n    }\n    Matrix operator - (double v) const\n    {\n        double * a = new double [this->rows * this->columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = this->values[i] - v;\n        }\n        Matrix temp(rows,columns,a);\n        delete []a;\n        return temp;\n    }\n    ~Matrix()\n    {\n        if (values != 0)\n            delete []values;\n    }\n    void print()\n    {\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < columns; j++)\n            {\n\n                cout << \"    \" << values[i * columns + j];\n            }\n            cout << endl;\n        }\n    }\nprivate:\n    int rows;\n    int columns;\n    double* values;\n};",
            1590032394.6287613,
            100,
            "# 答案正确"
        ],
        [
            "6.1 (C++)",
            "苏比努尔·玉山江",
            "#include<iostream>\n#include <iomanip>\n#include<vector>\n#include<string>\nusing namespace std;\ntemplate < typename T>\nclass Matrix\n{\npublic:\n    Matrix()\n    {\n        rows = 0;\n        columns = 0;\n        values = 0;\n    }\n    Matrix(int r, int c)\n    {\n        this -> rows = r;\n        this -> columns = c;\n        values = new  T [rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            values[i] = T ();\n        }\n    }\n    Matrix(int r, int c, const  T *v)\n    {\n        this->rows = r;\n        this->columns = c;\n        values = new  T [r * c];\n        for (int i = 0; i < r * c; i++)\n        {\n            values[i] = v[i];\n        }\n    }\n    T& get (int r, int c)\n    {\n        return values[(r - 1) * columns + c - 1];\n    }\n    Matrix(const Matrix& matrix2)\n    {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        values = new T [rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            values[i] = matrix2.values[i];\n        }\n    }\n    Matrix& operator= (const Matrix& matrix2)\n    {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        if (values != 0)\n            delete []values;\n        values = new T [rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            values[i] = matrix2.values[i];\n        }\n        return *this;\n    }\n    Matrix operator + (const Matrix & matrix2) const\n    {\n        T* a = new T [this->rows * this->columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = this->values[i] + matrix2.values[i];\n        }\n        Matrix temp(rows,columns,a);\n        delete []a;\n        return temp;\n    }\n    Matrix operator + (double v) const\n    {\n        T * a = new T [this->rows * this->columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = this->values[i] + v;\n        }\n        Matrix temp(rows,columns,a);\n        delete []a;\n        return temp;\n    }\n    Matrix operator - (const Matrix & matrix2) const\n    {\n        T * a = new T [this->rows * this->columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = this->values[i] - matrix2.values[i];\n        }\n        Matrix temp(rows,columns,a);\n        delete []a;\n        return temp;\n    }\n    Matrix operator - (double v) const\n    {\n        T * a = new T [this->rows * this->columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = this->values[i] - v;\n        }\n        Matrix temp(rows,columns,a);\n        delete []a;\n        return temp;\n    }\n    Matrix operator * (const Matrix & matrix2) const\n    {\n        Matrix temp(rows,rows);\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < rows; j++)\n            {\n                T sum = 0;\n                for(int k = 0; k < columns; k++)\n                {\n                    sum += this->values[i * columns + k] * matrix2.values[k * rows + j];\n                }\n                temp.values[i*rows+j] = sum;\n            }\n        }\n        return temp;\n    }\n    Matrix  operator * (double v ) const\n    {\n        T * a = new T [rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = v * values[i];\n        }\n        Matrix temp (rows,columns,a);\n        delete []a;\n        return temp;\n    }\n    Matrix transpose()\n    {\n        T* a = new T [rows * columns];\n        int m = 0;\n        for (int i = 0; i < columns; i++)\n        {\n            for (int j = 0; j < rows; j++)\n            {\n                a[m++] = this->values[j * columns + i];\n            }\n        }\n        Matrix temp(columns,rows,a);\n        delete []a;\n        return temp;\n    }\n    Matrix concatenateRows(Matrix & matrix1)\n    {\n        Matrix t (rows * 2 , columns);\n        for(int i = 0; i < rows * columns; ++i)\n        {\n            t.values[i] = values[i];\n        }\n        for(int i = 0; i < rows * columns; i++)\n        {\n            t.values[ rows * columns + i] = matrix1.values[i];\n        }\n        return t;\n    }\n    Matrix concatenateColumns(Matrix & matrix1)\n    {\n        Matrix t(rows, columns * 2);\n        for(int i = 0; i < rows; ++i)\n        {\n            for(int j = 0; j < columns; ++j)\n            {\n                t.values[i* columns * 2  +  j] = values [ i *columns +  j];\n            }\n        }\n        for(int i = 0; i < rows; ++i)\n        {\n            for(int j = columns; j < columns * 2; ++j)\n            {\n                t.values[i* columns * 2  +  j] = matrix1.values[i * columns +  j - columns];\n            }\n        }\n        return t;\n    }\n    Matrix getRow(int r)\n\t{\n\t\tT * a = new T [columns];\n\t\tfor(int i = 0; i < columns; i++)\n\t\t{\n\t\t\ta[i] = values[(r-1) * columns + i];\n        }\n\t\tMatrix temp (1,columns,a);\n        delete []a;\n\t\treturn temp;\n\t}\n\tMatrix getColumn(int c)\n\t{\n\t\tT * a = new T [columns];\n\t\tfor (int i = 0; i < rows; i++)\n\t\t{\n\t\t\ta[i] = values[i * columns + c - 1];\n\t\t}\n\t\tMatrix temp(rows,1,a);\n        delete []a;\n        return temp;\n\t}\n    Matrix reshape(int r , int c ) const\n    {\n        T * a = new T [r * c];\n        int m = 0;\n        for (int i = 0; i < columns; i++)\n        {\n            for (int j = 0; j < rows; j++)\n            {\n                a[m++] = this->values[j * columns + i];\n            }\n        }\n        m = 0;\n        Matrix temp(r,c);\n        for (int i = 0; i < c; i++)\n        {\n            for(int j = 0; j < r; j++)\n            {\n                temp.values[j * c + i] = a[m++];\n            }\n        }\n        delete []a;\n        return temp;\n    }\n    Matrix max()\n    {\n        if(rows == 1 && columns == 1)\n        return * this;\n        else if (rows == 1 && columns != 1)\n        {\n            T m = values[0];\n            for (int i = 0; i < rows * columns ; i++)\n            {\n                if (values[i] > m)\n                m = values[i];\n            }\n            Matrix temp(1,1);\n            temp.values[0] = m;\n            return temp;\n        }\n        else\n        {\n            T m = values[0];\n            int index = 0;\n            for (int i = 0; i < rows; i++)\n            {\n                for (int j = 0; j < columns; j++)\n                {\n                    if (values[ i * columns + j] > m )\n                    {\n                        m = values[ i * columns + j];\n                        index = i;\n                    }\n                }\n                T * a = new T[columns];\n                for(int i = 0; i < columns; i++)\n                {\n                    a[i] = values[ index * columns + i];\n                }\n                Matrix temp (1,columns,a);\n                return temp;\n            }\n        }\n    }\n    Matrix min()\n    {\n        if(rows == 1 && columns == 1)\n        return * this;\n        else if (rows == 1 && columns != 1)\n        {\n            T m = values[0];\n            for (int i = 0; i < rows * columns ; i++)\n            {\n                if (values[i] < m)\n                m = values[i];\n            }\n            Matrix temp(1,1);\n            temp.values[0] = m;\n            return temp;\n        }\n        else\n        {\n            T m = values[0];\n            int index = 0;\n            for (int i = 0; i < rows; i++)\n            {\n                for (int j = 0; j < columns; j++)\n                {\n                    if (values[ i * columns + j] < m )\n                    {\n                        m = values[ i * columns + j];\n                        index = i;\n                    }\n                }\n                T * a = new T[columns];\n                for(int i = 0; i < columns; i++)\n                {\n                    a[i] = values[ index * columns + i];\n                }\n                Matrix temp (1,columns,a);\n                return temp;\n            }\n        }\n    }\n    Matrix sum()\n    {\n        if (rows == 1 && columns == 1)\n        return * this;\n        else if (rows == 1 && columns != 1)\n        {\n            T m = 0;\n            for (int i = 0; i < columns; i++)\n            m += values[i];\n            Matrix temp(1,1);\n            temp.values[0] = m;\n            return temp;\n        }\n        else\n        {\n            T * a = new T[columns];\n            for (int j = 0; j < columns; j++)\n            {\n                a[j] = 0;\n                for (int i = 0; i < rows; i++)\n                {\n                    a[j] += values[i * columns + j];\n                }\n            }\n            Matrix temp (1,columns,a);\n            return temp;\n        }\n        \n    }\n    ~Matrix()\n    {\n        if (values != 0)\n            delete []values;\n    }\n    void print()\n    {\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < columns; j++)\n            {\n                cout << \"    \" << values[i * columns + j];\n            }\n            cout << endl;\n        }\n    }\nprivate:\n    int rows;\n    int columns;\n    T * values;\n};",
            1590462801.741914,
            100,
            "# 答案正确"
        ],
        [
            "6.3 (C++)",
            "苏比努尔·玉山江",
            "#include<iostream>\n#include <iomanip>\n\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntemplate < typename T>\nclass Matrix\n{\n    public:\n    Matrix()\n    {\n        this->rows = 0;\n        this->columns = 0;\n        values.clear();\n    }\n    Matrix(int r, int c)\n    {\n        this->rows = r;\n        this->columns = c;\n        vector<T> temp ( r*c ,0);\n        values = temp;\n    }\n    Matrix(int r, int c, vector <T>  v)\n    {\n        this->rows = r;\n        this->columns = c;\n        values = v;\n    }\n    Matrix(const Matrix& matrix2)\n    {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        this->values = matrix2.values; \n    }\n    T& get (int r, int c)\n    {\n        return values[(r-1) * columns + c - 1];\n    }\n    Matrix& operator= (const Matrix& matrix2)\n    {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        this->values = matrix2.values; \n        return *this;\n    }\n    Matrix operator * (const Matrix & matrix2) const\n    {\n        Matrix temp(rows,rows);\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < rows; j++)\n            {\n                T sum = 0;\n                for(int k = 0; k < columns; k++)\n                {\n                    sum += this->values[i * columns + k] * matrix2.values[k * rows + j];\n                }\n                temp.values[i*rows+j] = sum;\n            }\n        }\n        return temp;\n    }\n    Matrix  operator * ( T v ) const\n    {\n        vector<T> a (rows * columns, 0);\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = v * values[i];\n        }\n        Matrix temp (rows,columns,a);\n        return temp;\n    }\n    Matrix operator + (const Matrix & matrix2) const\n    {\n        vector <T> a(rows * columns , 0);\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = this->values[i] + matrix2.values[i];\n        }\n        Matrix temp(rows,columns,a);\n        return temp;\n    }\n    Matrix operator + (T v) const\n    {\n        vector <T> a(rows * columns , 0);\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = this->values[i] + v;\n        }\n        Matrix temp(rows,columns,a);\n        return temp;\n    }\n    Matrix operator - (const Matrix & matrix2) const\n    {\n        vector <T> a(rows * columns , 0);\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = this->values[i] - matrix2.values[i];\n        }\n        Matrix temp(rows,columns,a);\n        return temp;\n    }\n    Matrix operator - (T v) const\n    {\n        vector <T> a(rows * columns , 0);\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = this->values[i] - v;\n        }\n        Matrix temp(rows,columns,a);\n        return temp;\n    }\n    Matrix getRow(int r)\n\t{\n\t\tvector <T> a(columns, 0);\n\t\tfor(int i = 0; i < columns; i++)\n\t\t{\n\t\t\ta[i] = this->values[(r-1) * columns + i];\n\t\t}\n\t\treturn Matrix(1,columns,a);\n\t}\n\tMatrix getColumn(int c)\n\t{\n\t\tvector <T> a( 1 * rows, 0);\n\t\tfor (int i = 0; i < rows; i++)\n\t\t{\n\t\t\ta[i] = values[i*columns + c - 1];\n\t\t}\n\t\treturn Matrix(rows, 1, a);\n\t}\n    Matrix concatenateRows(Matrix & matrix1)\n    {\n        Matrix t (rows * 2 , columns);\n        for(int i = 0; i < rows * columns; ++i)\n        {\n            t.values[i] = values[i];\n        }\n        for(int i = 0; i < rows * columns; i++)\n        {\n            t.values[ rows * columns + i] = matrix1.values[i];\n        }\n        return t;\n    }\n    Matrix concatenateColumns(Matrix & matrix1)\n    {\n        Matrix t(rows, columns * 2);\n        for(int i = 0; i < rows; ++i)\n        {\n            for(int j = 0; j < columns; ++j)\n            {\n                t.values[i* columns * 2  +  j] = values [ i *columns +  j];\n            }\n        }\n        for(int i = 0; i < rows; ++i)\n        {\n            for(int j = columns; j < columns * 2; ++j)\n            {\n                t.values[i* columns * 2  +  j] = matrix1.values[i * columns +  j - columns];\n            }\n        }\n        return t;\n    }\n    Matrix reshape(int r , int c ) const\n    {\n        vector<T> a(r * c ,0);\n        int m = 0;\n        for (int i = 0; i < columns; i++)\n        {\n            for (int j = 0; j < rows; j++)\n            {\n                a[m++] = this->values[j * columns + i];\n            }\n        }\n        m = 0;\n        Matrix temp(r,c);\n        for (int i = 0; i < c; i++)\n        {\n            for(int j = 0; j < r; j++)\n            {\n                temp.values[j * c + i] = a[m++];\n            }\n        }\n        return temp;\n    }\n    Matrix transpose()\n    {\n        vector<T> a(rows * columns);\n        int m = 0;\n        for (int i = 0; i < columns; i++)\n        {\n            for (int j = 0; j < rows; j++)\n            {\n                a[m++] = this->values[j * columns + i];\n            }\n        }\n        Matrix temp(columns,rows,a);\n        return temp;\n    }\n    Matrix max()\n    {\n        if(rows == 1 && columns == 1)\n        return * this;\n        else if (rows == 1 && columns != 1)\n        {\n            T m = values[0];\n            for (int i = 0; i < rows * columns ; i++)\n            {\n                if (values[i] > m)\n                m = values[i];\n            }\n            Matrix temp(1,1);\n            temp.values[0] = m;\n            return temp;\n        }\n        else\n        {\n            T m;\n            vector<T> a;\n            for (int j = 0; j < columns; j++)\n            {\n                m = -999;\n                for (int i = 0; i < rows; i++)\n                {\n\t\t\t\t\t\t\tif (values[i * columns + j] > m)\n\t\t\t\t\t\t\t\tm = values[i * columns + j];\n                }\n                a.push_back(m);\n            }\n                Matrix temp (1,columns,a);\n                return temp;\n        }\n    }\n        \n    \n    Matrix min()\n    {\n        if(rows == 1 && columns == 1)\n        return * this;\n        else if (rows == 1 && columns != 1)\n        {\n            T m = values[0];\n            for (int i = 0; i < rows * columns ; i++)\n            {\n                if (values[i] < m)\n                m = values[i];\n            }\n            Matrix temp(1,1);\n            temp.values[0] = m;\n            return temp;\n        }\n        else\n        {\n            T m;\n            vector<T> a;\n            for (int j = 0; j < columns; j++)\n            {\n                m =  999;\n                for (int i = 0; i < rows; i++)\n                {\n\t\t\t\t\t\t\tif (values[i * columns + j] < m)\n\t\t\t\t\t\t\t\tm = values[i * columns + j];\n                }\n                a.push_back(m);\n            }\n                Matrix temp (1,columns,a);\n                return temp;\n        }\n    }\n    Matrix sum()\n    {\n        if (rows == 1 && columns == 1)\n        return * this;\n        else if (rows == 1 && columns != 1)\n        {\n            T m = 0;\n            for (int i = 0; i < columns; i++)\n            m += values[i];\n            Matrix temp(1,1);\n            temp.values[0] = m;\n            return temp;\n        }\n        else\n        {\n            vector <T> a(columns,0);\n            for (int j = 0; j < columns; j++)\n            {\n                for (int i = 0; i < rows; i++)\n                {\n                    a[j] += values[i * columns + j];\n                }\n            }\n            Matrix temp (1,columns,a);\n            return temp;\n        }\n        \n    }\n    void print()\n    {\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < columns; j++)\n            {\n\n                cout << \"    \" << values[i * columns + j];\n            }\n            cout << endl;\n        }\n    }\n    private:\n    int rows;\n    int columns;\n    vector <T> values;\n};\n",
            1590636628.4843876,
            100,
            "# 答案正确"
        ],
        [
            "6.2 (C++)",
            "苏比努尔·玉山江",
            "#include<iostream>\n#include <iomanip>\n#include<vector>\n#include<string>\nusing namespace std;\ntemplate < typename T>\nclass Matrix\n{\npublic:\n    Matrix()\n    {\n        rows = 0;\n        columns = 0;\n        values = 0;\n    }\n    Matrix(int r, int c)\n    {\n        this -> rows = r;\n        this -> columns = c;\n        values = new  T [rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            values[i] = T ();\n        }\n    }\n    Matrix(int r, int c, const  T *v)\n    {\n        this->rows = r;\n        this->columns = c;\n        values = new  T [r * c];\n        for (int i = 0; i < r * c; i++)\n        {\n            values[i] = v[i];\n        }\n    }\n    T& get (int r, int c)\n    {\n        return values[(r - 1) * columns + c - 1];\n    }\n    Matrix(const Matrix& matrix2)\n    {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        values = new T [rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            values[i] = matrix2.values[i];\n        }\n    }\n    Matrix& operator= (const Matrix& matrix2)\n    {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        if (values != 0)\n            delete []values;\n        values = new T [rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            values[i] = matrix2.values[i];\n        }\n        return *this;\n    }\n    Matrix operator + (const Matrix & matrix2) const\n    {\n        T* a = new T [this->rows * this->columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = this->values[i] + matrix2.values[i];\n        }\n        Matrix temp(rows,columns,a);\n        delete []a;\n        return temp;\n    }\n    Matrix operator + (double v) const\n    {\n        T * a = new T [this->rows * this->columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = this->values[i] + v;\n        }\n        Matrix temp(rows,columns,a);\n        delete []a;\n        return temp;\n    }\n    Matrix operator - (const Matrix & matrix2) const\n    {\n        T * a = new T [this->rows * this->columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = this->values[i] - matrix2.values[i];\n        }\n        Matrix temp(rows,columns,a);\n        delete []a;\n        return temp;\n    }\n    Matrix operator - (double v) const\n    {\n        T * a = new T [this->rows * this->columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = this->values[i] - v;\n        }\n        Matrix temp(rows,columns,a);\n        delete []a;\n        return temp;\n    }\n    Matrix operator * (const Matrix & matrix2) const\n    {\n        Matrix temp(rows,rows);\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < rows; j++)\n            {\n                T sum = 0;\n                for(int k = 0; k < columns; k++)\n                {\n                    sum += this->values[i * columns + k] * matrix2.values[k * rows + j];\n                }\n                temp.values[i*rows+j] = sum;\n            }\n        }\n        return temp;\n    }\n    Matrix  operator * (double v ) const\n    {\n        T * a = new T [rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        {\n            a[i] = v * values[i];\n        }\n        Matrix temp (rows,columns,a);\n        delete []a;\n        return temp;\n    }\n    Matrix transpose()\n    {\n        T* a = new T [rows * columns];\n        int m = 0;\n        for (int i = 0; i < columns; i++)\n        {\n            for (int j = 0; j < rows; j++)\n            {\n                a[m++] = this->values[j * columns + i];\n            }\n        }\n        Matrix temp(columns,rows,a);\n        delete []a;\n        return temp;\n    }\n    Matrix concatenateRows(Matrix & matrix1)\n    {\n        Matrix t (rows * 2 , columns);\n        for(int i = 0; i < rows * columns; ++i)\n        {\n            t.values[i] = values[i];\n        }\n        for(int i = 0; i < rows * columns; i++)\n        {\n            t.values[ rows * columns + i] = matrix1.values[i];\n        }\n        return t;\n    }\n  \n    ~Matrix()\n    {\n        if (values != 0)\n            delete []values;\n    }\n    void print()\n    {\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < columns; j++)\n            {\n                cout << \"    \" << values[i * columns + j];\n            }\n            cout << endl;\n        }\n    }\nprivate:\n    int rows;\n    int columns;\n    T * values;\n};",
            1590636598.3872619,
            100,
            "# 答案正确"
        ],
        [
            "7.1 (C++)",
            "苏比努尔·玉山江",
            "#include <cmath>\nclass Triangle : public GeometricObject\n{\n    public:\n    Triangle()\n    {\n        side1 = side2 = side3 = 1.0;\n      \n    }\n    Triangle(double a, double b, double c)\n    {\n        side1 = a;\n        side2 = b;\n        side3 = c;\n      \n    }\n    double& getSide1()\n    {\n        return side1;\n    }\n    double& getSide2()\n    {\n        return side2;\n    }\n    double& getSide3()\n    {\n        return side3;\n    }\n    double getArea()\n    { \n        double s = this->getPerimeter() / 2;\n        double area = sqrt(s * (s - side1) * (s - side2) * (s - side3) );\n        return area;\n    }\n    double getPerimeter()\n    {\n        return side1 + side2 + side3;\n    }\n\n\n    private:\n    double side1;\n    double side2;\n    double side3;\n};\n\n",
            1591025182.3945735,
            100,
            "# 答案正确"
        ],
        [
            "7.3 (C++)",
            "苏比努尔·玉山江",
            "\ntemplate <typename T>\nvector<T> map2(const vector<T> & x,  const T data , T(*map2_func)(const T &, const T &) )\n{\n    vector<T> res;\n    for (int i = 0; i < x.size(); i++)\n    {\n        res.push_back(map2_func(x[i], data));\n    }\n    return res;\n}\ntemplate <typename T>\nvector<T> map2(const vector<T> & x,  const vector<T> & y, T(*map2_func)(const T &, const T &) )\n{\n    vector<T> res;\n    for (int i = 0; i < x.size(); i++)\n    {\n        res.push_back(map2_func(x[i], y[i]));\n    }\n    return res;\n}\n",
            1591025207.0782,
            100,
            "# 答案正确"
        ],
        [
            "7.2 (C++)",
            "苏比努尔·玉山江",
            "#include<string>\n#include<vector>\nusing namespace std;\nvector<string> split( const string &line, const string & delimiter = \" \")\n{\n    vector<string> ans;\n    int st = 0;\n    while(st < line.size())\n    {\n        int end = line.find(delimiter, st);\n        if (end == st)\n            st += delimiter.size();\n        else\n        {\n            if (end == -1)\n            {\n                ans.push_back(line.substr(st));\n                break;\n            }\n            ans.push_back(line.substr(st, end - st));\n            st = end + delimiter.size();\n        }\n        \n    }\n    return ans;\n}",
            1591238816.288538,
            100,
            "# 答案正确"
        ],
        [
            "8.1 (C++)",
            "苏比努尔·玉山江",
            "\nclass Full : public Matrix\n{\n    public:\n    Full (int r, int c)\n    {\n        this->rows = r;\n        this->columns = c;\n        values = new double [rows * columns];\n        for(int i = 0; i < rows * columns ; i++)\n        values[i] = 0;\n    }\n    Full (int r, int c, double values[])\n    {\n        this->rows = r;\n        this->columns = c;\n        this-> values = new double[rows * columns];\n        for (int i = 0; i < rows * columns; i++)\n        this->values[i] = values[i]; \n    }\n    Full(const Matrix & matrix2)\n    {\n        this->rows = matrix2.size(1);\n        this->columns = matrix2.size(2);\n        this->values = new double[this->rows * this-> columns];\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < columns; j++)\n            {\n                values[i * columns + j] = matrix2.get(i,j);\n            }\n        }\n    }\n    ~Full()\n    {\n        if(values != 0)\n        delete [] values;\n    }\n    virtual int size(int dimension) const\n    {\n        if (dimension == 1)\n            return rows;\n        else\n            return columns;\n    }\n\tvirtual void set(int r, int c, double v)\n    {\n        values[r * columns + c ] = v;\n    }\n\tvirtual double get(int r, int c) const \n\t{\n        return values[r * columns + c] ;\n    }\n\tvirtual void print() const\n    {\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < columns; j++)\n            {\n                cout <<\"    \" <<values[i*columns + j] ;\n            }\n            cout << endl;\n        }\n    }\n\tvirtual Matrix&  operator = (const Matrix & matrix2)\n    {\n        this->rows = matrix2.size(1);\n        this->columns = matrix2.size(2);\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j <columns; j++)\n            {\n                set(i,j,matrix2.get(i,j));\n            }\n        }\n        return *this;\n    }\n    private:\n    int rows;\n    int columns;\n    double * values;\n};",
            1591708372.7654855,
            100,
            "# 答案正确"
        ],
        [
            "8.3 (C++)",
            "苏比努尔·玉山江",
            "#include <iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nbool comp(const Entry& a, const Entry& b)\n{\n    if (a.row == b.row)\n    {\n        return a.column < b.column;\n    }\n    else\n    {\n        return a.row < b.row;\n    }\n}\nclass Sparse : public Matrix\n{\npublic:\n    Sparse(int r, int c)\n    {\n        this->rows = r;\n        this->columns = c ;\n        values.clear();\n    }\n/*Sparse  operator+ (Sparse& sparse2)\n    {\n        Sparse temp(this->rows, this->columns);\n        temp.values = this->values;\n        for (int i = 0; i < sparse2.values.size();i++)\n        {\n            int index = findIndex(sparse2.values[i].row,sparse2.values[i].column );\n            if (index == -1)\n            {\n                temp.values.push_back(sparse2.values[i]);\n            }\n            else\n            {\n                temp.set(sparse2.values[i].row,sparse2.values[i].column,this->values[index ].value + sparse2.values[i].value);\n            }\n        }\n        return temp;\n    }\n*/\n  Sparse  operator+ (Sparse& sparse2)\n    {\n        Sparse temp(this->rows, this->columns);\n        temp.values = this->values;\n\n        for (int i = 0; i < sparse2.values.size();i++)\n        {\n            Entry t = sparse2.values[i];\n            double v = temp.get(t.row, t.column);\n            temp.set(t.row,t.column, sparse2.get(t.row,t.column) + v);\n        }\n        return temp;\n    }\n\n    int findIndex(int r, int c) const\n    {\n        for (int i = 0; i < values.size(); i++)\n        {\n            if (values[i].row == r && values[i].column == c)\n            {\n                return i;\n            }\n        }\n        return -1;\n    }\n    virtual int size(int dimension) const\n    {\n        if (dimension == 1)\n            return rows;\n        else\n        {\n            return columns;\n        }\n    }\n\n\n    virtual void set(int r, int c, double v)\n    {\n        int index = findIndex(r, c);\n        if (index != -1)\n        {\n            if (v == 0)\n            {\n                values.erase(values.begin() + index);\n            }\n            else\n            {\n                values[index].value = v;\n            }\n        }\n        else\n        {\n            if (v != 0)\n            {\n                Entry t;\n                t.row = r;\n                t.column = c;\n                t.value = v;\n                values.push_back(t);\n            }\n        }\n    }\n\n    virtual double get(int r, int c) const\n    {\n        int index = findIndex(r, c);\n        if (index == -1)\n            return 0;\n        else\n        {\n            return values[index].value;\n        }\n    }\n\n    virtual void print()\n    {\n\n        sort(values.begin(), values.end(),comp);\n        for (int i = 0; i < values.size(); i++)\n        {\n            cout << \"(\" << values[i].row << \",\" << values[i].column << \",\" << values[i].value << \")\" << endl;\n        }\n    }\n\nprivate:\n    int rows;\n    int columns;\n    vector<Entry> values;\n};",
            1591708421.110133,
            100,
            "# 答案正确"
        ],
        [
            "8.4 (C++)",
            "苏比努尔·玉山江",
            "#include <iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nbool comp(const Entry& a, const Entry& b)\n{\n    if (a.row == b.row)\n    {\n        return a.column < b.column;\n    }\n    else\n    {\n        return a.row < b.row;\n    }\n}\nclass Sparse : public Matrix\n{\npublic:\n    Sparse(int r, int c)\n    {\n        this->rows = r;\n        this->columns = c ;\n        values.clear();\n    }\n  \n  Sparse  operator+ (Sparse& sparse2)\n    {\n        Sparse temp(this->rows, this->columns);\n        temp.values = this->values;\n\n        for (int i = 0; i < sparse2.values.size();i++)\n        {\n            Entry t = sparse2.values[i];\n            double v = temp.get(t.row, t.column);\n            temp.set(t.row,t.column,t.value+v);\n        }\n        return temp;\n    }\n\n    int findIndex(int r, int c) const\n    {\n        for (int i = 0; i < values.size(); i++)\n        {\n            if (values[i].row == r && values[i].column == c)\n            {\n                return i;\n            }\n        }\n        return -1;\n    }\n    virtual int size(int dimension) const\n    {\n        if (dimension == 1)\n            return rows;\n        else\n        {\n            return columns;\n        }\n    }\n\n\n    virtual void set(int r, int c, double v)\n    {\n        int index = findIndex(r, c);\n        if (index != -1)\n        {\n            if (v == 0)\n            {\n                values.erase(values.begin() + index);\n            }\n            else\n            {\n                values[index].value = v;\n            }\n        }\n        else\n        {\n            if (v != 0)\n            {\n                Entry t;\n                t.row = r;\n                t.column = c;\n                t.value = v;\n                values.push_back(t);\n            }\n        }\n    }\n\n    virtual double get(int r, int c) const\n    {\n        int index = findIndex(r, c);\n        if (index == -1)\n            return 0;\n        else\n        {\n            return values[index].value;\n        }\n    }\nSparse  operator * (Sparse & sparse2)\n    {\n        Sparse temp(this->rows, sparse2.columns);\n        for(int i = 0; i < values.size(); i++)\n        {\n            for(int j = 0; j < sparse2.values.size(); j++)\n            {\n                Entry a = this->values[i];\n                Entry b = sparse2.values[j];\n                if(a.column == b.row)\n                {\n                    double t = a.value * b.value;\n                    temp.set(a.row,b.column, temp.get(a.row,b.column) + t);\n                }\n            }\n        }\n        return temp;\n    }\n    virtual void print()\n    {\n\n        sort(values.begin(), values.end(),comp);\n        for (int i = 0; i < values.size(); i++)\n        {\n            cout << \"(\" << values[i].row << \",\" << values[i].column << \",\" << values[i].value << \")\" << endl;\n        }\n    }\n\nprivate:\n    int rows;\n    int columns;\n    vector<Entry> values;\n};",
            1591708495.5222452,
            100,
            "# 答案正确"
        ],
        [
            "8.5 (C++)",
            "苏比努尔·玉山江",
            "#include <iostream>\nusing namespace std;\n\nclass Point3D : public Point2D \n{\n    public:\n    Point3D()\n    {\n        setX(0);\n        setY(0);\n        setZ(0);\n    }\n    Point3D(double x, double y, double z)\n    {\n        setX(x);\n        setY(y);\n        setZ(z);\n    }\n    void setZ(double z) \n    {\n\t\tthis->z = z;\n\t}\n    double getZ() \n    {\n\t\treturn z;\n\t}\n  \n\tdouble distance(Point3D & point2) \n    {\n        \n\t\t  double dx = getX() - point2.getX();\n\t\t\tdouble dy = getY() -point2.getY();\n        double dz = getZ() - point2.getZ();\n\t\treturn sqrt(dx * dx + dy * dy + dz * dz);\n\t}\n    private:\n    double z;\n};\nvoid printDistance(Point3D & point1, Point3D & point2) {\n\tcout << \"point1.distance(point2) = \" << \n\t\tpoint1.distance(point2) << endl;\n}\n",
            1591843957.1982143,
            100,
            "# 答案正确"
        ],
        [
            "8.6 (C++)",
            "苏比努尔·玉山江",
            "#include <iostream>\nclass MyTensor : public Tensor<double>\n{\n    public:\n    MyTensor( vector<int> sizes ): Tensor<double> (sizes) \n    {\n        int total = 1;\n        for (int i = 0; i < sizes.size(); i++)\n        total *= sizes[i];\n        data = new double[total];\n    }\n    \n    virtual double & get(const vector<int> & indexes)\n    {\n        if( sizes.size() == 1)\n        return data[indexes[0]];\n        if(sizes.size() ==2)\n        {\n            return data[indexes[0] * sizes[1] + indexes[1]];\n        }\n        if(sizes.size()  == 3)\n        {\n            return data[ indexes[0] * indexes[1] * sizes[2] + indexes[1] * sizes[2] + indexes[2]   ];\n        }\n        if (sizes.size()  == 4)\n        {\n            return data[ indexes[0] * indexes[1] * indexes[2] * sizes[3] + indexes[1] * indexes[2] * sizes[3] + indexes[2] * sizes[3] + indexes[3] ];  \n        }\n\n    }\n    ~MyTensor()\n    {\n        if(data != nullptr)\n        delete [] data;\n    }\n    private:\n    double * data;\n};\n",
            1592451045.063984,
            100,
            "# 答案正确"
        ],
        [
            "9.1 (C++)",
            "苏比努尔·玉山江",
            "#include <iostream>\nusing namespace std;\nclass Circle\n{\n    friend bool operator<(const Circle&a, const Circle&b);\n    friend bool operator<=(const Circle&a, const Circle&b);\n    friend bool operator==(const Circle&a, const Circle&b);\n    friend bool operator!=(const Circle&a, const Circle&b);\n    friend bool operator>(const Circle&a, const Circle&b);\n    friend bool operator>=(const Circle&a, const Circle&b);\n    public:\n        Circle(double r) : radius(r) {}\n    private:\n        double radius;\n};\nbool operator<(const Circle&a, const Circle&b)\n{\n    return a.radius < b.radius;\n}\nbool operator<=(const Circle&a, const Circle&b)\n{\n    return a.radius <= b.radius;\n}\nbool operator==(const Circle&a, const Circle&b)\n{\n    return a.radius == b.radius;\n}\nbool operator!=(const Circle&a, const Circle&b)\n{\n    return !(a == b);\n}\nbool operator>(const Circle&a, const Circle&b)\n{\n    return !(a<=b);\n}\nbool operator>=(const Circle&a, const Circle&b)\n{\n    return !(a<b);\n}",
            1592816987.1181233,
            100,
            "# 答案正确"
        ],
        [
            "9.2 (C++)",
            "苏比努尔·玉山江",
            "class I\n{\n\tpublic:\n    I(int i1 = -1, int i2=-1, int i3=-1, int i4=-1)\n    {\n\t\tif(i1 != -1)\n            indexes.push_back(i1);\n        if (i2 != -1)\n            indexes.push_back(i2);\n        if (i3 != -1)\n            indexes.push_back(i3);\n        if (i4 != -1)\n            indexes.push_back(i4);\n    };\n\t\n    operator vector<int> ()\n    {\n        return indexes;\n    }\n\n\tprivate:\n    vector<int> indexes;\n};",
            1592818962.3674436,
            100,
            "# 答案正确"
        ],
        [
            "9.3 (C++)",
            "苏比努尔·玉山江",
            "class Complex\n{\n    friend Complex operator+(Complex & a,Complex &b);\n    friend Complex operator+(Complex & a,int b);\n    friend Complex operator+(int a,Complex & b);\n\n    friend Complex operator-(Complex & a,Complex &b);\n    friend Complex operator-(Complex & a,int b);\n    friend Complex operator-(int a,Complex & b);\n\n    friend Complex operator*(Complex & a,Complex &b);\n    friend Complex operator/(Complex & a,Complex &b);\n    \n    public:\n    Complex(double real, double imag) : m_real(real), m_imag(imag) {}\n    Complex& operator*=(Complex & a);\n    Complex& operator/=(Complex & a);\n    Complex& operator+=(Complex & a);\n    Complex& operator-=(Complex & a);\n    bool operator==(Complex & a);\n    bool operator!=(Complex & a);\n    double real();\n    double imag();\n    private:\n    double m_real;\n    double m_imag;\n};\nComplex& Complex :: operator*=(Complex & a)\n{\n    Complex t = *this * a;\n    *this = t;\n    return *this;\n}\nComplex& Complex :: operator/=(Complex & a)\n{\n    Complex t = *this / a;\n    *this = t;\n    return *this;\n}\nComplex& Complex :: operator+=(Complex & a)\n{\n    Complex t = *this + a;\n    *this = t;\n    return *this;\n}\nComplex& Complex :: operator-=(Complex & a)\n{\n    Complex t = *this - a;\n    *this = t;\n    return *this;\n}\nbool Complex :: operator==(Complex & a)\n{\n    if(m_real == a.real() && m_imag == a.imag())\n    return true;\n    else\n    {\n        return false;\n    }\n    \n}\nbool Complex :: operator!=(Complex & a)\n{\n    return !(*this == a);\n}\n\ndouble Complex ::  real()\n{\n    return m_real;\n}\ndouble Complex ::  imag()\n{\n    return m_imag;\n}\nComplex operator+(Complex & a,Complex &b)\n{\n    return Complex(a.real() + b.real(), a.imag() + b.imag());\n}\nComplex operator+(Complex & a,int b)\n{\n    return Complex(a.real() +b, a.imag());\n}\nComplex operator+(int a,Complex & b)\n{\n    return Complex(a + b.real(), b.imag());\n}\nComplex operator-(Complex & a,Complex &b)\n{\n    return Complex(a.real() - b.real(), a.imag() - b.imag());\n}\nComplex operator-(Complex & a,int b)\n{\n    return Complex(a.real() - b, a.imag());\n}\nComplex operator-(int a,Complex & b)\n{\n    return Complex(a - b.real(), -b.imag());\n}\nComplex operator*(Complex & a,Complex &b)\n{\n    double r = a.real() * b.real() - a.imag() * b.imag();\n    double i = a.real() * b.imag() + a.imag() * b.real();\n    return Complex(r,i);\n}\nComplex operator/(Complex & a,Complex &b)\n{\n    double r =(a.real() * b.real() + a.imag() * b.imag() ) / (b.real() * b.real() + b.imag() * b.imag());\n    double i = ( a.imag() * b.real() - a.real() * b.imag() ) / (b.real() * b.real() + b.imag() * b.imag());\n    return Complex(r,i);\n}",
            1592822852.4799688,
            100,
            "# 答案正确"
        ],
        [
            "9.4 (C++)",
            "苏比努尔·玉山江",
            "#include <cmath>\nclass Complex\n{\n    friend Complex operator+(Complex & a,Complex &b);\n    friend Complex operator+(Complex & a,int b);\n    friend Complex operator+(int a,Complex & b);\n    \n    friend Complex operator-(Complex & a,Complex &b);\n    friend Complex operator-(Complex & a,int b);\n    friend Complex operator-(int a,Complex & b);\n\n    friend Complex operator*(Complex & a,Complex &b);\n    friend Complex operator/(Complex & a,Complex &b);\n    friend ostream& operator<<(ostream &out, Complex & a);\n    friend istream& operator>>(istream &in, Complex & a);\n\n    public:\n    Complex(double real, double imag) : m_real(real), m_imag(imag) {}\n    Complex():m_real(0),m_imag(0){}\n\n    Complex& operator*=(Complex & a);\n    Complex& operator/=(Complex & a);\n    Complex& operator+=(Complex & a);\n    Complex& operator-=(Complex & a);\n    Complex& operator++();\n    Complex  operator++(int);\n    bool operator==(Complex & a);\n    bool operator!=(Complex & a);\n    operator double();\n    double real();\n    double imag();\n    private:\n    double m_real;\n    double m_imag;\n};\nComplex& Complex :: operator*=(Complex & a)\n{\n    Complex t = *this * a;\n    *this = t;\n    return *this;\n}\nComplex& Complex :: operator/=(Complex & a)\n{\n    Complex t = *this / a;\n    *this = t;\n    return *this;\n}\nComplex& Complex :: operator+=(Complex & a)\n{\n    Complex t = *this + a;\n    *this = t;\n    return *this;\n}\nComplex& Complex :: operator-=(Complex & a)\n{\n    Complex t = *this - a;\n    *this = t;\n    return *this;\n}\nbool Complex :: operator==(Complex & a)\n{\n    if(m_real == a.real() && m_imag == a.imag())\n    return true;\n    else\n    {\n        return false;\n    }\n    \n}\nbool Complex :: operator!=(Complex & a)\n{\n    return !(*this == a);\n}\nComplex& Complex :: operator++() // 前置\n{\n    this->m_real++;\n    return *this;\n}\nComplex Complex :: operator++(int)\n{\n    Complex temp = *this;\n    this->m_real++;\n    return temp;\n}\ndouble Complex ::  real()\n{\n    return m_real;\n}\ndouble Complex ::  imag()\n{\n    return m_imag;\n}\nComplex :: operator double()\n{\n    return m_real;\n}\nComplex operator+(Complex & a,Complex &b)\n{\n    return Complex(a.real() + b.real(), a.imag() + b.imag());\n}\nComplex operator+(Complex & a,int b)\n{\n    return Complex(a.real() +b, a.imag());\n}\nComplex operator+(int a,Complex & b)\n{\n    return Complex(a + b.real(), b.imag());\n}\nComplex operator-(Complex & a,Complex &b)\n{\n    return Complex(a.real() - b.real(), a.imag() - b.imag());\n}\nComplex operator-(Complex & a,int b)\n{\n    return Complex(a.real() - b, a.imag());\n}\nComplex operator-(int a,Complex & b)\n{\n    return Complex(a - b.real(), -b.imag());\n}\nComplex operator*(Complex & a,Complex &b)\n{\n    double r = a.real() * b.real() - a.imag() * b.imag();\n    double i = a.real() * b.imag() + a.imag() * b.real();\n    return Complex(r,i);\n}\nComplex operator/(Complex & a,Complex &b)\n{\n    double r =(a.real() * b.real() + a.imag() * b.imag() ) / (b.real() * b.real() + b.imag() * b.imag());\n    double i = ( a.imag() * b.real() - a.real() * b.imag() ) / (b.real() * b.real() + b.imag() * b.imag());\n    return Complex(r,i);\n}\n   ostream & operator << (ostream & out, Complex & c)\n    {\n        out << c.real() << \" + \" << c.imag() << \" i\";\n        return out;\n    }\nistream& operator>> (istream &in, Complex & a)\n{\n    double r,i;\n    in >> a.m_real;\n\tin >> a.m_imag;\n    return in;\n}",
            1592817062.4011078,
            100,
            "# 答案正确"
        ],
        [
            "9.5 (C++)",
            "苏比努尔·玉山江",
            "#include <iostream>\nusing namespace std;\n\nclass Complex\n{\n    \n \n    friend ostream& operator<<(ostream &out, Complex & a);\n    friend istream& operator>>(istream &in, Complex & a);\n\n    public:\n    Complex(double real, double imag) : m_real(real), m_imag(imag) {}\n    Complex():m_real(0),m_imag(0){}\n \n    Complex& operator++();\n    Complex  operator++(int);\n    bool operator==(Complex & a);\n    bool operator!=(Complex & a);\n    operator double();\n    double real();\n    double imag();\n    private:\n    double m_real;\n    double m_imag;\n};\n \n \n \nComplex& Complex :: operator++() // 前置\n{\n    this->m_real++;\n    return *this;\n}\nComplex Complex :: operator++(int)\n{\n    Complex temp = *this;\n    this->m_real++;\n    return temp;\n}\ndouble Complex ::  real()\n{\n    return  m_real;\n}\ndouble Complex ::  imag()\n{\n    return  m_imag;\n}\nComplex :: operator double()\n{\n    return m_real;\n}\n   \nostream& operator<<(ostream &out,  Complex & a)\n{\n    //out << a.real() << \" + \" << a.imag() << \"i\";\n    if(a.real() == 0 && a.imag() == 0)\n    out << 0 ;\n    else if (a.real() == 0 && a.imag() != 0)\n    out << a.imag() << \"i\";\n    else if (a.real() != 0 && a.imag() == 0)\n    out << a.real();\n    else\n    {\n        if(a.imag() > 0)\n        out << a.real() << \" + \" << a.imag() << \" i\";\n        if(a.imag()<0)\n        out << a.real() << \" - \" << (-1)  * a.imag()  << \" i\";\n    }\n    return out;\n}\nistream& operator>> (istream &in, Complex & a)\n{\n    double r,i;\n    in >> a.m_real;\n\tin >> a.m_imag;\n    return in;\n}\n ",
            1592985322.123475,
            75,
            "# 答案不正确\n\n# 随机输入:\n6.1\n2.4\n\n\n# 参考答案:\n++ c1 = 7.1 + 2.4 i \nc1 ++ = 7.1 + 2.4 i \nreal = 8.1\n\n\n# 我的答案:\n++ c1 = 7.1 + 2.4 i\nc1 ++ = 7.1\nreal = 8.1\n"
        ],
        [
            "9.6 (C++)",
            "苏比努尔·玉山江",
            "class Tensor\n{\n    public:\n    Tensor(int a = -1, int b = -1, int c = -1, int d = -1)\n    {\n        int size = 1;\n        if(a != -1)\n        {\n            sizes.push_back(a);\n            size *= a;\n        }\n        \n        if(b != -1)\n        {\n            sizes.push_back(b);\n            size *= b; \n        }\n        \n        if(c != -1)\n        {\n            sizes.push_back(c);\n            size *= c; \n        }\n        \n        if(d != -1)\n        {\n            sizes.push_back(d);\n            size *= d; \n        }\n        data.resize(size);\n    }\n    double& operator()(int a , int b , int c , int d = 0)\n    {\n        int index = 0;\n        if(sizes.size() == 1)\n        {\n            index = a;\n        }\n        if(sizes.size() == 2)\n        {\n            index = a * sizes[1] + b;\n        }\n        if(sizes.size() == 3)\n        {\n            index = a * sizes[1]* sizes[2] + b * sizes[2] + c;\n        }\n        if(index == 4)\n        {\n            index = a * sizes[1]* sizes[2] * sizes[3] + b *sizes[2] * sizes[3] + c * sizes[3] + d;\n        }\n        return data[index];\n    }\n    private:\n    vector <double> data;\n    vector <int> sizes;\n};\n",
            1592985346.4622407,
            100,
            "# 答案正确"
        ],
        [
            "9.7 (C++)",
            "苏比努尔·玉山江",
            "class Tensor\n{\n    friend istream & operator>>(istream &in, Tensor &A);\n    friend ostream & operator<<(ostream &out, Tensor A);\n    public:\n    Tensor()\n    {\n        total = 0;\n        dimention = 0;\n    }\n    private:\n    vector<double> data;\n    vector<int>sizes;\n    int total;\n    int dimention;\n};\nistream & operator>>(istream &in, Tensor &A)\n{\n    in >> A.dimention;\n    int total = 1;\n    for(int i = 0; i < A.dimention; i++)\n    {\n        int t;\n        in >> t;\n        total *= t; \n        A.sizes.push_back(t);\n    }\n    A.total = total;\n    for(int i = 0; i < total; i++)\n    {\n        double t;\n        in >> t;\n        A.data.push_back(t);\n    }\n    return in;\n}\nostream & operator<<(ostream &out, Tensor A)\n{\n        out << A.dimention << endl;\n        if(A.dimention == 3 )\n\t\t{\n\t\t\tout << A.sizes [0] << \" \" << A.sizes[1] <<\" \"<<A.sizes[2] << endl << endl;\n\t\t\t\tfor(int i = 0; i < A.sizes[0]; i++)\n                {\n\t\t\t\t\tfor (int j = 0; j < A.sizes[1]; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int k = 0; k < A.sizes[2]; k++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint index = i * A.sizes[1] * A.sizes[2] + j * A.sizes[2] + k;\n\t\t\t\t\t\t\tout << A.data[index] << \" \";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tout << endl;\n\t\t\t\t\t}\n                    out << endl;\n                }\n\t\t}\n\t\tif(A.dimention == 4 )\n\t\t{\n            out << A.sizes [0] << \" \" << A.sizes[1] <<\" \"<<A.sizes[2] <<\" \"<< A.sizes[3] << endl << endl ;\n            for(int i = 0; i < A.sizes[0] * A.sizes[1]; i++)\n                {\n\t\t\t\t\tfor (int j = 0; j < A.sizes[2]; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int k = 0; k < A.sizes[3]; k++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint index =  i * A.sizes[2] * A.sizes[3] + j * A.sizes[3] + k; \n\t\t\t\t\t\t\tout << A.data[index] << \" \";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tout << endl;\n\t\t\t\t\t}\n                    out << endl;\n                }\n\t\t}\n    return out;\n}\n",
            1592985363.3501256,
            100,
            "# 答案正确"
        ],
        [
            "10.1 (C++)",
            "苏比努尔·玉山江",
            "#include <iostream>\n#include <vector>\n#include <stdexcept>\nusing namespace std;\nclass MatrixSizesDoNotMatchException {};\n\ndouble Matrix :: get(int row, int column) const{\n\tif (row >  this->rows || column  >  this->columns)\n        throw out_of_range( \"\");\n\t\t\telse\n      \t return  elements[(row - 1) * columns + column - 1];\n    }\n\nvoid Matrix :: set(int row, int column, double value){\n        if (row >  this->rows || column  >  this->columns)\n        throw out_of_range( \"\");\n\t\t\telse\n      \telements[(row - 1) * columns + column - 1] = value;\n    }\n\nMatrix Matrix :: operator + (const Matrix & matrix2) const{\n    if(this->rows == matrix2.rows && this->columns == matrix2.columns){\n        Matrix t(rows,columns);\n        for(int i = 0; i < rows - 1 ; i++){\n            for(int j = 0; j < columns - 1; j++){\n                t.set(i,j, this->get(i,j) + matrix2.get(i,j));\n            }\n        }\n        return t;\n    }\n    else{\n        throw MatrixSizesDoNotMatchException();\n    }\n            \n}",
            1593658176.8022738,
            100,
            "# 答案正确"
        ],
        [
            "10.2 (C++)",
            "苏比努尔·玉山江",
            "\t\tcatch(NonPositiveValueException& ){\n            cout << \"caught: NonPositiveValueException\"<<endl;\n        }\n\n\ncatch(out_of_range&){\n            cout << \"caught: out_of_range\"<<endl;\n        }\n",
            1593657183.03022,
            100,
            "# 答案正确"
        ],
        [
            "15.1 (C++)",
            "苏比努尔·玉山江",
            "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\nclass Table\n{\n    friend ostream & operator << (ostream & out, const Table & table);\n    \n    public:\n  \t Table()\n    {\n        tab.resize(1);\n     \t\t\n    }\n    void addCol(string s)\n    {\n        col.push_back(s); \n    }\n    vector<string>& operator[](int n)\n    {  \n\t \t  \n        if (tab.size() == n + 1 ) \n\t\t{\n\t\t\tvector<string> temp;\n\t\t\ttab.push_back(temp);\n\t\t}\n        return tab[n];\n    }\n    string json()const\n    {\n        string s = \"{\\n    headers: [\";\n        for(int i = 0; i < col.size(); i++)\n        {\n            s += (\"'\" + col[i]+ \"'\" + \",\");\n        }\n        s+=\"],\\n\";\n        s+=\"    rows: [\\n\";\n       for(int i = 0 ; i< tab.size()-1; i++)\n        {\n            string a = \"       [\";\n            for (int j = 0; j < tab[i].size(); j++)\n            {\n                a += (\"'\" + tab[i][j] + \"',\"); \n            }\n            a+=\"],\\n\";\n            s += a;\n        }\n        s += \"    ],\\n}\"; \n        return s; \n    }\n    private:\n \t int row_size;\n    vector< vector <string> > tab;\n    vector<string> col;\n};",
            1594134623.5684059,
            100,
            "# 答案正确"
        ],
        [
            "2020-07-09 LAB",
            "苏比努尔·玉山江",
            "#include <iostream>\n#include <string>\nusing namespace std;\nclass Integer\n{\n    friend istream & operator >> (istream& in, Integer&m);\n    friend ostream &  operator << (istream& out,  Integer&m);\n    \n    private:\n    int val;\n    \n    public:\n    static int  increase;\n    Integer()\n    {\n        val = 0;\n    }\n    Integer(int a)\n    {\n        val = a;\n    }\n\n    static void increase_all(int x)\n    {\n        increase = x;\n    }\n    operator int()\n    {\n        return val;\n    }\n    int getInt()  \n    {\n        return val;\n    }\n\tvoid add(int x)\n\t{\n\t\tval+=x;\n\t}\n};\nint Integer :: increase  = 0;\nistream & operator >> (istream& in, Integer&m)\n{\n    in>>m.val;\n    return in;\n}\nostream &  operator << (ostream& out,    Integer&m)\n{\n    m.add( Integer :: increase);\n\tout << m.getInt();\n    return out;\n}\n\n",
            1594262748.8498485,
            100,
            "# 答案正确"
        ],
        [
            "A.1 (C++)",
            "苏比努尔·玉山江",
            "    void addFirst(const E & e)\n    {\n        Node<E> * node = new Node<E>;\n        node -> element = e;\n        node -> update_prev_and_next_node(nullptr, head);\n        if (head != nullptr) head -> update_prev_node(nullptr, node);\n        head = node;\n        if (tail == nullptr) tail = node;\n        ++_size;\n    }\n\n    void addLast(const E & e)\n    {\n        Node<E> * node = new Node<E>;\n        node -> element = e;\n        node -> update_prev_and_next_node(tail, nullptr);\n        if (tail != nullptr) tail -> update_next_node(nullptr, node);\n        tail = node;\n        if (head == nullptr) head = node;\n        ++_size;\n    }\n\n  void remove (int index) {\n\t\n\t\tif (index < 0 || index >= _size)\n        throw NotSuchElementException();\n\n        Node<E> * node =  get_node(index);\n        Node<E> * nextOfnode;\n\t\tNode<E> * preOfnode;\n        if(index == _size - 1)\n        {\n\t\t\tnextOfnode = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnextOfnode = get_node( index + 1 );\n\t\t}\n        if (index == 0)\n\t\t{\n\t\t\tpreOfnode = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpreOfnode = node->prev_node(nextOfnode);\n\t\t}\n        if(preOfnode != 0)\n        {\n            preOfnode->update_next_node(node,nextOfnode );\n        }\n        if(nextOfnode != 0)\n        {\n            nextOfnode->update_prev_node(node, preOfnode);\n        }\n        if(index == 0)\n        {\n            head = nextOfnode;\n        }\n        if(index == _size - 1)\n        {\n            tail = preOfnode;\n        }\n        delete node;\n\t\t-- _size;\n\t}\n\n\n    void removeFirst()\n    {\n        remove(0);\n    }\n\n    void removeLast()\n    {\n        remove(_size - 1);\n    }\n\n   void removeFirstOccurrence(const E & e) {\n\t\tint index = indexOf(e);\n\t\tif (index == -1)\n\t\t\tthrow NotSuchElementException();\n\t\tremove(index);\n\t}\n\n    E & get(int index)\n    {\n        Node<E> * node = get_node(index);\n        return node -> element;\n    }\n\nprivate:\n   \tNode<E> * get_node(int index) const \n\t{\n\t\tif (index < 0 || index >= _size) \n\t\t\tthrow NotSuchElementException();\n\t\tif (index < _size / 2) \n        {\n\t\t\tNode<E> * node = head;\n            Node<E> * preOfnow = 0;\n            Node<E> * temp = 0;\n\t\t\tI(i, index)\n            {\n                temp = node;\n                node = node -> next_node(preOfnow);\n                preOfnow = temp;\n            }\n\t\t\treturn node;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tNode<E> * node = tail;\n            Node<E> * nextOfnow = 0;\n            Node<E> * temp =0;\n\t\t\tI(i, (_size - 1 - index) )\n            {\n                temp = node;\n                node = node -> prev_node(nextOfnow);\n                nextOfnow = node;\n            }\n\t\t\treturn node;\n\t\t}\n\t}\n\n\tint indexOf(const E & e) const \n    {\n\t\t\n            Node<E> * node = head;\n            Node<E> * preOfnow = 0;\n            Node<E> * temp = 0;\n\t\t\tI(i, _size)\n            {\n                if(node->element == e)\n                return i;\n\n                temp = node;\n                node = node -> next_node(preOfnow);\n                preOfnow = temp;\n            }\n            return -1;\n\t}\n",
            1594866337.1979153,
            100,
            "# 答案正确"
        ],
        [
            "A.2 (C++)",
            "苏比努尔·玉山江",
            "template <typename E>\nvoid LinkedList<E> :: removeAll(const E & e)\n{\n\twhile (contains(e))\n\t{\n\t\t  removeFirstOccurrence( e );\n\t}\n}",
            1594868877.7422092,
            100,
            "# 答案正确"
        ],
        [
            "A.4 (C++)",
            "苏比努尔·玉山江",
            "#include <iostream>\n#include <sstream>\n#include<map>\n#include<vector>\n#include<string>\nusing namespace std;\n#define I(i,n) for (size_t i = 0; i < n; ++ i)\n\nclass NoSuchKeyException {};\nclass HT{\n    private:\n    class Tuple{\n        public:\n        int int_Key;\n        string string_Key;\n        int int_value;\n        string string_value;\n        bool in_use;\n        bool keyIsInt;\n        bool keyIsString;\n        Tuple() : in_use(false), keyIsInt(false), keyIsString(false) {}\n        Tuple(int key, int val): int_Key(key), int_value(val), in_use(true), keyIsInt(true), keyIsString(false) {}\n        Tuple(int key, string val): int_Key(key),string_value(val), in_use(true),  keyIsInt(true), keyIsString(false){}\n        Tuple(string key, int val): string_Key(key), int_value(val), in_use(true),  keyIsInt(false), keyIsString(true){}\n        Tuple(string key, string val): string_Key(key),string_value(val), in_use(true),keyIsInt(false), keyIsString(true) {}\n        operator int (){\n            return int_value;\n        }\n        operator string(){\n            return string_value;\n        }\n        void operator=(int val){\n            this->int_value = val;\n        }\n        void operator=(string val){\n            this->string_value = val;\n        }\n    };\n   vector<Tuple> tuples;\n\tsize_t _size;\n    size_t indexofKey(const int & key) const {\n        I(i, _size){\n            if(tuples[i].keyIsInt && tuples[i].int_Key == key){\n                return i;\n            }\n        }\n        return -1;\n\t}\n    size_t indexofKey(const string & key) const {\n        I(i, _size){\n            if(tuples[i].keyIsString && tuples[i].string_Key == key){\n                return i;\n           }\n        }\n        return -1;\n\t}\n\n    public:\n    HT() : _size(0){\n        tuples.resize(2);\n    }\n    int size() const{\n        return _size;\n    }\n    Tuple & operator [](int key){\n        int index = indexofKey(key);\n        if (index != -1) \n        \treturn tuples[index];\n        else{\n            tuples[_size].string_Key = key;\n            tuples[_size].keyIsInt = false;\n            tuples[_size].keyIsString = true;\n            _size++;\n            if (_size * 2 > tuples.size()) _double_tuples();\n            return tuples[_size - 1];\n\n        }   \n    }\n    Tuple & operator [](string key){\n        int index = indexofKey(key);\n        if (index != -1) \n        return tuples[index];\n        else{\n            tuples[_size].string_Key = key;\n            tuples[_size].keyIsInt = false;\n            tuples[_size].keyIsString = true;\n            _size++;\n            if (_size * 2 > tuples.size()) _double_tuples();\n            return tuples[_size - 1];\n\n        }  \n    }\n    void _double_tuples(){\n        vector<Tuple> non_empty_tuples;\n        for (int i = 0; i < _size; ++i){\n            if (tuples[i].in_use) non_empty_tuples.push_back(tuples[i]);\n        }\n        tuples.resize(tuples.size() * 2, Tuple());\n        for (int i = 0; i < non_empty_tuples.size(); ++i){\n            tuples[i] = non_empty_tuples[i];\n        }\n    }\n};\n\n\n",
            1595513494.736261,
            0,
            "main.cpp: In function ‘int main()’:\nmain.cpp:13:6: error: ‘class HT’ has no member named ‘put’\n  map.put(key1, value1);\n      ^\nmain.cpp:18:6: error: ‘class HT’ has no member named ‘put’\n  map.put(key2, value2);\n      ^\nmain.cpp:23:6: error: ‘class HT’ has no member named ‘put’\n  map.put(key3, value3);\n      ^\nmain.cpp:28:6: error: ‘class HT’ has no member named ‘put’\n  map.put(key4, value4);\n      ^\n"
        ],
        [
            "A.5 (C++)",
            "苏比努尔·玉山江",
            "#include <iostream>\n#include <sstream>\n#include<map>\n#include<vector>\n#include<string>\nusing namespace std;\n#define I(i,n) for (size_t i = 0; i < n; ++ i)\n\nclass NoSuchKeyException {};\nclass HT\n{\n    private:\n    class Tuple\n    {\n        public:\n        int int_Key;\n        string string_Key;\n        int int_value;\n        string string_value;\n        bool in_use;\n        bool keyIsInt;\n        bool keyIsString;\n        Tuple() : in_use(false), keyIsInt(false), keyIsString(false) {}\n        Tuple(int key, int val): int_Key(key), int_value(val), in_use(true), keyIsInt(true), keyIsString(false) {}\n        Tuple(int key, string val): int_Key(key),string_value(val), in_use(true),  keyIsInt(true), keyIsString(false){}\n        Tuple(string key, int val): string_Key(key), int_value(val), in_use(true),  keyIsInt(false), keyIsString(true){}\n        Tuple(string key, string val): string_Key(key),string_value(val), in_use(true),keyIsInt(false), keyIsString(true) {}\n        operator int ()\n        {\n            return int_value;\n        }\n        operator string()\n        {\n            return string_value;\n        }\n        void operator = (int val)\n        {\n            this->int_value = val;\n        }\n        void operator = (string val)\n        {\n            this->string_value = val;\n        }\n    };\n    vector<Tuple> tuples;\n\tsize_t _size;\n    size_t indexofKey(const int & key) const \n\t{\n        I(i, _size)\n        {\n            if(tuples[i].keyIsInt && tuples[i].int_Key == key)\n            {\n                return i;\n            }\n        }\n        return -1;\n\t}\n    size_t indexofKey(const string & key) const \n\t{\n        I(i, _size)\n        {\n            if(tuples[i].keyIsString && tuples[i].string_Key == key)\n            {\n                return i;\n            }\n        }\n        return -1;\n\t}\n\n    public:\n    HT() : _size(0)\n    {\n        tuples.resize(2);\n    }\n    int size() const\n    {\n        return _size;\n    }\n    Tuple & operator [](int key)\n    {\n        int index = indexofKey(key);\n        if (index != -1) \n        return tuples[index];\n        else\n        {\n            tuples[_size].int_Key = key;\n            tuples[_size].keyIsInt = true;\n            tuples[_size].keyIsString = false;\n            _size++;\n            if (_size * 2 > tuples.size()) \n            _double_tuples();\n            return tuples[_size - 1];\n        }\n        \n    }\n    Tuple & operator [](string key)\n    {\n        int index = indexofKey(key);\n        if (index != -1) \n        return tuples[index];\n        else\n        {\n            tuples[_size].string_Key = key;\n            tuples[_size].keyIsInt = false;\n            tuples[_size].keyIsString = true;\n            _size++;\n            if (_size * 2 > tuples.size()) \n            _double_tuples();\n            return tuples[_size - 1];\n\n        }\n        \n    }\n    void _double_tuples()\n    {\n        vector<Tuple> non_empty_tuples;\n        for (int i = 0; i < _size; ++i)\n        {\n            if (tuples[i].in_use) non_empty_tuples.push_back(tuples[i]);\n        }\n        tuples.resize(tuples.size() * 2, Tuple());\n        for (int i = 0; i < non_empty_tuples.size(); ++i)\n        {\n            tuples[i] = non_empty_tuples[i];\n        }\n    }\n};\n\n\n",
            1595341403.097951,
            100,
            "# 答案正确"
        ]
    ],
    "table_name": "答案"
}