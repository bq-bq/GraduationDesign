{
    "__update_time__": 1595475000.415245,
    "field_names": [
        "题目名",
        "用户名",
        "答案",
        "提交时间",
        "分数",
        "评语"
    ],
    "field_types": [
        "text",
        "text",
        "text",
        "time",
        "number",
        "text"
    ],
    "foreign_keys": {},
    "primary_keys": [],
    "rows": [
        [
            "测试1",
            "王子豪",
            "#include <iostream>\nusing namespace std;\nint main(){\n\tchar a[10];\n\tchar b[10];\n\tchar c[10];\n\tcin>>a;\n\tcin>>b;\n\tcin>>c;\n\tprintf(\"%s %s %s\",c,b,a);\n}",
            1587555154.8808093,
            100,
            "# 答案正确"
        ],
        [
            "测试2",
            "王子豪",
            "#include<iostream>\n#include<cstring>\nusing namespace std;\nint main(){\n\tchar (*a)[20]=new char[10][20];\n\tfor(int i=0;i<10;i++){\n\t\tscanf(\"%s\",a[i]);\n\t}\n\tfor(int i=0;i<10;i++){\n\t\tchar *t=new char[20];\n\t\tfor(int j=i;j<10;j++){\n\t\t\tif(strcmp(a[j],a[i])<0){\n\t\t\t\t\n\t\t\t\tstrcpy(t,a[j]);\n\t\t\t\tstrcpy(a[j],a[i]);\n\t\t\t\tstrcpy(a[i],t);\n\t\t\t}\n\t\t}\n\t\tdelete [] t;\n\t}\n\tfor(int i=0;i<10;i++){\n\t\tprintf(\"%s \",a[i]);\n\t}\n\t\tdelete [] a;\n\t\n} ",
            1587608686.4358294,
            100,
            "# 答案正确"
        ],
        [
            "1.1 (C++)",
            "王子豪",
            "class Matrix5x5\n{\n\tpublic:\n\t\tdouble num[5][5];\n\tMatrix5x5(){\n\t\tfor(int i=0;i<5;i++){\n\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\tnum[i][j]=0;\n\t\t\t}\n\t\t}\n\t}\n\tdouble get(int i, int j){\n \treturn this->num[i][j];\n }\t\n void set(int i, int j, double v){\n \tthis->num[i][j]=v;\n }\nMatrix5x5 operator + (Matrix5x5 & m1){\n\tMatrix5x5 tmp;\n\tfor(int i=0;i<5;i++){\n\t\tfor(int j=0;j<5;j++){\n\t\t\ttmp.set(i,j,this->num[i][j]+m1.num[i][j]);\n\t\t}\n\t}\n\treturn tmp;\n}\n\n };\n ",
            1587699529.259406,
            100,
            "# 答案正确"
        ],
        [
            "1.2 (C++)",
            "王子豪",
            "#include<cstring>\n#include <string>\nusing namespace std;\nclass School{\n\tpublic:\n\tstring name;\n\tint age;\n\tSchool(){\n\t\tthis->name=\"NO_NAME\";\n\t\tthis->age=0;\n\t}\n\tvoid setName(char name[]){\n\t\tthis->name=name;\n\t}\n\tvoid setAge(int year){\n\t\tthis->age=year;\n\t}\n\tvoid operator ++ (){\n\t\tthis->age++;\n\t}\n};\n",
            1588212819.6778755,
            100,
            "# 答案正确"
        ],
        [
            "2.1 (C++)",
            "王子豪",
            "#include<iostream>\nusing namespace std;\nclass Matrix\n{\n\tprivate:\n\tint rows;\nint columns;\ndouble * values;\n\tpublic:\n\tMatrix(int row,int col){\n\t\trows=row;\n\t\tcolumns=col;\n\t\tvalues=new double[row*col];\n\t\tfor(int i=0;i<col*row;i++){\n\t\t\tvalues[i]=0;\n\t\t}\n\t}\n\t~Matrix(){\n\t\tdelete [] values;\n\t}\n\tvoid print(){\n\t\tfor(int j=0;j<rows;j++){\n\t\t\tfor(int i=0;i<columns;i++){\n\t\t\t\tprintf(\"    %.0lf\",values[j*columns+i]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\t\n\t}\n};",
            1588825579.0233696,
            100,
            "# 答案正确"
        ],
        [
            "2.2 (C++)",
            "王子豪",
            "#include<iostream>\n#include <iomanip>\nusing namespace std;\nclass Matrix\n{\n\tprivate:\n\tint rows;\nint columns;\ndouble * values;\n\tpublic:\n\tMatrix(int row,int col,double* p){\n\t\trows=row;\n\t\tcolumns=col;\n\t\tvalues=new double[row*col];\n\t\tfor(int i=0;i<col*row;i++){\n\t\t\tvalues[i]=p[i];\n\t\t}\n\t}\n\t~Matrix(){\n\t\tdelete [] values;\n\t}\n\tvoid print(){\n\t\tfor(int j=0;j<rows;j++){\n\t\t\tfor(int i=0;i<columns;i++){\n\t\t\t\t\n\t\t\t\tcout<<setw(5)<<values[j*columns+i];\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\t\n\t}\n};",
            1588825945.5490785,
            100,
            "# 答案正确"
        ],
        [
            "2.3 (C++)",
            "王子豪",
            "#include<iostream>\n#include <iomanip>\nusing namespace std;\nclass Matrix\n{\n\tprivate:\n\tint rows;\nint columns;\ndouble * values;\n\tpublic:\n\t Matrix(const Matrix & matrix2)\n\t {\n\t\t rows=matrix2.rows;\n\t\t columns=matrix2.columns;\n\t\t values=new double[rows*columns];\n\t\tfor(int i=0;i<columns*rows;i++){\n\t\t\tvalues[i]=matrix2.values[i];\n\t\t}\n\t\t \n}\n\tMatrix(int row,int col,double* p){\n\t\trows=row;\n\t\tcolumns=col;\n\t\tvalues=new double[row*col];\n\t\tfor(int i=0;i<col*row;i++){\n\t\t\tvalues[i]=p[i];\n\t\t}\n\t}\n\t~Matrix(){\n\t\tdelete [] values;\n\t}\n\tvoid print(){\n\t\tfor(int j=0;j<rows;j++){\n\t\t\tfor(int i=0;i<columns;i++){\n\t\t\t\t\tprintf(\"    %.0lf\",values[j*columns+i]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\t\n\t}\n};",
            1588826322.952377,
            100,
            "# 答案正确"
        ],
        [
            "2.5 (C++)",
            "王子豪",
            "#include<iostream>\n#include <iomanip>\nusing namespace std;\nclass Matrix\n{\n\tprivate:\n\tint rows;\nint columns;\ndouble * values;\n\tpublic:\n\tMatrix(int row,int col){\n\t\trows=row;\n\t\tcolumns=col;\n\t\tvalues=new double[row*col];\n\t\tfor(int i=0;i<col*row;i++){\n\t\t\tvalues[i]=0;\n\t\t}\n\t}\n\t Matrix(const Matrix & matrix2)\n\t {\n\t\t rows=matrix2.rows;\n\t\t columns=matrix2.columns;\n\t\t values=new double[rows*columns];\n\t\tfor(int i=0;i<columns*rows;i++){\n\t\t\tvalues[i]=matrix2.values[i];\n\t\t}\n}\n\t\n\tMatrix getRow(int row){\n\t\tMatrix t(1,this->columns);\n\t\t\n\t\tfor(int i=0;i<columns;i++){\n\t\t\tt.values[i]=this->values[(row-1)*columns+i];\n\t\t}\n\t\treturn t;\n\t}\n\tMatrix getColumn(int column){\n\t\tMatrix t(this->rows,1);\n\t\t\n\t\tfor(int i=0;i<rows;i++){\n\t\t\tt.values[i]=this->values[column-1+i*rows];\n\t\t}\n\t\treturn t;\n\t}\n\tMatrix(int row,int col,double* p){\n\t\trows=row;\n\t\tcolumns=col;\n\t\tvalues=new double[row*col];\n\t\tfor(int i=0;i<col*row;i++){\n\t\t\tvalues[i]=p[i];\n\t\t}\n\t}\n\t~Matrix(){\n\t\tdelete [] values;\n\t}\n\tvoid print(){\n\t\tfor(int j=0;j<rows;j++){\n\t\t\tfor(int i=0;i<columns;i++){\n\t\t\t\t\tprintf(\"    %.0lf\",values[j*columns+i]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\t\n\t}\n};",
            1588827308.19818,
            100,
            "# 答案正确"
        ],
        [
            "2.6 (C++)",
            "王子豪",
            "#include<iostream>\n#include <iomanip>\nusing namespace std;\nclass Matrix\n{\n\tprivate:\n\tint rows;\nint columns;\ndouble * values;\n\tpublic:\n\tMatrix(int row,int col){\n\t\trows=row;\n\t\tcolumns=col;\n\t\tvalues=new double[row*col];\n\t\tfor(int i=0;i<col*row;i++){\n\t\t\tvalues[i]=0;\n\t\t}\n\t}\n\t Matrix(const Matrix & matrix2)\n\t {\n\t\t rows=matrix2.rows;\n\t\t columns=matrix2.columns;\n\t\t values=new double[rows*columns];\n\t\tfor(int i=0;i<columns*rows;i++){\n\t\t\tvalues[i]=matrix2.values[i];\n\t\t}\n}\n\tMatrix concatenateRows(const Matrix & m){\n\t\tMatrix t(this->rows+m.rows,this->columns);\n\t\t\n\t\tfor(int i=0;i<(this->rows+m.rows)*columns;i++){\n\t\t\tif(i<this->rows*columns){\n\t\t\t\tt.values[i]=this->values[i];\n\t\t\t}else{\n\t\t\t\tt.values[i]=m.values[i-this->rows*this->columns];\n\t\t\t}\n\t\t\t\n\t\t}\n\t\treturn t;\n\t}\n\tMatrix concatenateColumns(const Matrix & m){\n\t\tMatrix t(this->rows,this->columns*2);\n\t\t\n\t\tfor(int i=0;i<rows;i++){\nfor(int j=0;j<columns*2;j++){\n\tif(j<columns){\n\t\tt.values[i*columns*2+j]=this->values[i*columns+j];\n\t}else{\n\t\tt.values[i*columns*2+j]=m.values[i*columns+j-columns];\n\t}\n}\n\t\t}\n\t\treturn t;\n\t}\n\t\n\tMatrix(int row,int col,double* p){\n\t\trows=row;\n\t\tcolumns=col;\n\t\tvalues=new double[row*col];\n\t\tfor(int i=0;i<col*row;i++){\n\t\t\tvalues[i]=p[i];\n\t\t}\n\t}\n\t~Matrix(){\n\t\tdelete [] values;\n\t}\n\tvoid print(){\n\t\tfor(int j=0;j<rows;j++){\n\t\t\tfor(int i=0;i<columns;i++){\n\t\t\t\t\tprintf(\"    %.0lf\",values[j*columns+i]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\t\n\t}\n};",
            1588829761.7709103,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/08",
            "王子豪",
            " double & Tensor_get(int dimensions, const int sizes[],  double data[], int x0, int x1, int x2, int x3){\n\tif(dimensions==1){\n\t\t\n\t\treturn data[x0];\n}else if(dimensions==2){\n\t\tint num=sizes[0]*x1+x0;\n\t\treturn data[num];\n\t}else if(dimensions==3){\n\t\tint num=sizes[0]*x1+sizes[0]*sizes[1]*x2+x0;\n\t\treturn data[num];\n\t}else{\n\t\tint num=sizes[0]*x1+sizes[0]*sizes[1]*x2+sizes[0]*sizes[1]*sizes[2]*x3+x0;\n\t\treturn data[num];\n\t}\n}",
            1588907486.7201242,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/14",
            "王子豪",
            "#include <iostream>\nusing namespace std;\nvoid Tensor_print(int dimensions, const int sizes[], const double data[]){\n\tif(dimensions == 1){\n\t\tcout<<\"Tensor of \"<<sizes[0]<<endl;\n\t\tfor(int i = 0; i<sizes[0]; i++)cout<<data[i]<<endl;\n\t}else if(dimensions == 2){\n\t\tcout<<\"Tensor of \"<<sizes[0]<<\"x\"<<sizes[1]<<endl;\n\t\tfor(int i = 0; i<sizes[0]; i++){\n\t\t\tfor(int j = 0; j < sizes[1]; j ++){\n\t\t\t\tcout<<\"    \"<<data[i*sizes[1]+j];\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t}else if(dimensions == 3){\n\t\tcout<<\"Tensor of \"<<sizes[0]<<\"x\"<<sizes[1]<<\"x\"<<sizes[2]<<endl;\n\t\tfor(int k = 0; k < sizes[0]; k++){\n\t\t\tcout << \"data[\"<<k<<\"]\"<<endl;\n\t\t\t    for(int i = 0; i<sizes[1]; i++){\n\t\t\t        for(int j = 0; j < sizes[2]; j ++){\n\t\t\t\t        cout<<\"    \"<<data[k*sizes[1]*sizes[2]+i*sizes[2]];\n\t\t\t         }\n\t\t\t    cout<<endl;\n\t\t       }\n\t\t}\n\t}else if(dimensions == 4){\n\t\tcout<<\"Tensor of \"<<sizes[0]<<\"x\"<<sizes[1]<<\"x\"<<sizes[2]<<'x'<<sizes[3]<<endl;\n\t\tfor(int k = 0; k < sizes[0]; k++){\n\t\t\tfor(int l  = 0; l< sizes[1]; l++){\n\t\t\t\tcout<<\"data[\"<<k<<\"][\"<<l<<\"]\"<<endl;\n\t\t\t    for(int i = 0; i<sizes[2]; i++){\n\t\t\t        for(int j = 0; j < sizes[3]; j ++){\n\t\t\t\t        cout<<\"    \"<<data[3];\n\t\t\t         }\n\t\t\t    cout<<endl;\n\t\t       }\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n}",
            1589424898.1109493,
            100,
            "# 答案正确"
        ],
        [
            "2.4 (C++)",
            "王子豪",
            "#include <iostream>\n#include<iomanip>\nusing namespace std;\n \nclass Matrix{\n\t private:\n        int rows = 0;\n        int columns = 0;\n        double * values;\n        \n    public:\n\t\t\tMatrix(int row,int column){\n           rows=row;\n           columns=column;\n\t\t\t\t values=new double [rows*columns];\n           for(int m=0;m<rows*columns;m++)\n           values[m]=0;\n        }\n        Matrix(int row,int column,double value[]){\n           rows=row;\n           columns=column;\n           values=new double [rows*columns];\n           for(int m=0;m<rows*columns;m++)\n           values[m]=value[m]; \n        }\n        Matrix const operator =(const Matrix & matrix){\n             delete [] values;\n\t\t\trows=matrix.rows;\n\t\t\tcolumns=matrix.columns;\n\t\t\tvalues=new double[rows*columns];\n\t\t\t for(int m=0;m<rows*columns;m++)\n           values[m]=matrix.values[m]; \n        }\n        ~Matrix(){\n           delete  [] values;\n         }\n\t\t\n\t\tvoid print(){\n\t\t\tint cnt = 0;\n\t\t\tfor (int i = 0; i < this->rows; ++ i) {\n\t\t\t\tfor(int j = 0; j < this->columns; j ++){\n\t\t\t\t\tcout <<\"    \"<<this->values[cnt];\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t\tif(i!=this->rows)putchar('\\n');\n\t\t\t}\n\t\t\t\n\t\t}\n\t   void set(int row, int column, double value){\n\t\t\t\tthis->values[(row-1)*columns+column-1] = value;\n\t\t   return;\n\t   }\n\t   \n\t  \n};",
            1589514221.283193,
            100,
            "# 答案正确"
        ],
        [
            "2.7 (C++)",
            "王子豪",
            "#include <iostream>\n#include<iomanip>\nusing namespace std;\n \nclass Matrix{\n\t private:\n        int rows = 0;\n        int columns = 0;\n        double * values;\n        \n    public:\n\tMatrix reshape(int row, int column) {\n\t\tdouble* t=new double[rows*columns];\n\t\tint cnt=0;\n\t\tfor(int i=0;i<columns;i++){\n\t\t\tfor(int j=0;j<rows;j++){\n\t\t\t\tt[cnt]=values[j*columns+i];\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tcnt=0;\n\t\tMatrix g(row,column);\n\t\tfor(int i=0;i<column;i++){\n\t\t\tfor(int j=0;j<row;j++){\n\t\t\t\tg.values[j*column+i]=t[cnt];\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tdelete [] t;\n\t\treturn g;\n\t}\n\t\t\tMatrix(int row,int column){\n           rows=row;\n           columns=column;\n\t\t\t\t values=new double [rows*columns];\n           for(int m=0;m<rows*columns;m++)\n           values[m]=0;\n        }\n        Matrix(int row,int column,double value[]){\n           rows=row;\n           columns=column;\n           values=new double [rows*columns];\n           for(int m=0;m<rows*columns;m++)\n           values[m]=value[m]; \n        }\n\t Matrix(const Matrix & matrix2){\n\t\trows=matrix2.rows;\n\t\t columns=matrix2.columns;\n\t\t values=new double[rows*columns];\n\t\t for(int m=0;m<rows*columns;m++)\n           values[m]=matrix2.values[m];\n\t\t  \n\t }\n      \n        ~Matrix(){\n           delete  [] values;\n         }\n\t\t\n\t\tvoid print(){\n\t\t\tint cnt = 0;\n\t\t\tfor (int i = 0; i < this->rows; ++ i) {\n\t\t\t\tfor(int j = 0; j < this->columns; j ++){\n\t\t\t\t\tcout <<\"    \"<<this->values[cnt];\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t\tif(i!=this->rows)putchar('\\n');\n\t\t\t}\n\t\t\t\n\t\t}\n\t   void set(int row, int column, double value){\n\t\t\t\tthis->values[(row-1)*columns+column-1] = value;\n\t\t   return;\n\t   }\n\t   \n\t  \n};",
            1589515727.9348218,
            100,
            "# 答案正确"
        ],
        [
            "2.8 (C++)",
            "王子豪",
            "#include <iostream>\n#include<iomanip>\nusing namespace std;\n \nclass Matrix{\n\t private:\n        int rows = 0;\n        int columns = 0;\n        double * values;\n        \n    public:\n\tMatrix transpose(){\n\t\tMatrix t(columns,rows);\n\t\tfor(int i=0;i<rows;i++){\n\t\t\tfor(int j=0;j<columns;j++){\n\t\t\t\tt.values[j*rows+i]=values[i*columns+j];\n\t\t\t}\n\t\t}\n\t\treturn t;\n\t}\n\tMatrix reshape(int row, int column) {\n\t\tdouble* t=new double[rows*columns];\n\t\tint cnt=0;\n\t\tfor(int i=0;i<columns;i++){\n\t\t\tfor(int j=0;j<rows;j++){\n\t\t\t\tt[cnt]=values[j*columns+i];\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tcnt=0;\n\t\tMatrix g(row,column);\n\t\tfor(int i=0;i<column;i++){\n\t\t\tfor(int j=0;j<row;j++){\n\t\t\t\tg.values[j*column+i]=t[cnt];\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tdelete [] t;\n\t\treturn g;\n\t}\n\t\t\tMatrix(int row,int column){\n           rows=row;\n           columns=column;\n\t\t\t\t values=new double [rows*columns];\n           for(int m=0;m<rows*columns;m++)\n           values[m]=0;\n        }\n        Matrix(int row,int column,double value[]){\n           rows=row;\n           columns=column;\n           values=new double [rows*columns];\n           for(int m=0;m<rows*columns;m++)\n           values[m]=value[m]; \n        }\n\t Matrix(const Matrix & matrix2){\n\t\trows=matrix2.rows;\n\t\t columns=matrix2.columns;\n\t\t values=new double[rows*columns];\n\t\t for(int m=0;m<rows*columns;m++)\n           values[m]=matrix2.values[m];\n\t\t  \n\t }\n      \n        ~Matrix(){\n           delete  [] values;\n         }\n\t\t\n\t\tvoid print(){\n\t\t\tint cnt = 0;\n\t\t\tfor (int i = 0; i < this->rows; ++ i) {\n\t\t\t\tfor(int j = 0; j < this->columns; j ++){\n\t\t\t\t\tcout <<\"    \"<<this->values[cnt];\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t\tif(i!=this->rows)putchar('\\n');\n\t\t\t}\n\t\t\t\n\t\t}\n\t   void set(int row, int column, double value){\n\t\t\t\tthis->values[(row-1)*columns+column-1] = value;\n\t\t   return;\n\t   }\n\t   \n\t  \n};",
            1589515914.2286158,
            100,
            "# 答案正确"
        ],
        [
            "2.10 (C++)",
            "王子豪",
            "#include <iostream>\n#include<iomanip>\nusing namespace std;\n \nclass Matrix{\n\t private:\n        int rows = 0;\n        int columns = 0;\n        double * values;\n        \n    public:\n\tMatrix transpose(){\n\t\tMatrix t(columns,rows);\n\t\tfor(int i=0;i<rows;i++){\n\t\t\tfor(int j=0;j<columns;j++){\n\t\t\t\tt.values[j*rows+i]=values[i*columns+j];\n\t\t\t}\n\t\t}\n\t\treturn t;\n\t}\n\tMatrix operator * (const Matrix & matrix2) const{\n\t\tMatrix t(rows,matrix2.columns);\n\t\tfor(int i=0;i<rows;i++){\n\t\t\tfor(int j=0;j<matrix2.columns;j++){\n\t\t\t\tfor(int k=0;k<columns;k++){\n\t\t\t\t\tt.values[i*matrix2.columns+j]+=values[i*columns+k]*matrix2.values[k*matrix2.columns+j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn t;\n\t}\n\t Matrix operator * (double value) const{\n\t\t Matrix t(rows,columns);\n\t\t for(int i=0;i<rows*columns;i++){\n\t\t\t t.values[i]=values[i]*value;\n\t\t }\n\t\t return t;\n}\n\tMatrix reshape(int row, int column) {\n\t\tdouble* t=new double[rows*columns];\n\t\tint cnt=0;\n\t\tfor(int i=0;i<columns;i++){\n\t\t\tfor(int j=0;j<rows;j++){\n\t\t\t\tt[cnt]=values[j*columns+i];\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tcnt=0;\n\t\tMatrix g(row,column);\n\t\tfor(int i=0;i<column;i++){\n\t\t\tfor(int j=0;j<row;j++){\n\t\t\t\tg.values[j*column+i]=t[cnt];\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tdelete [] t;\n\t\treturn g;\n\t}\n\t\t\tMatrix(int row,int column){\n           rows=row;\n           columns=column;\n\t\t\t\t values=new double [rows*columns];\n           for(int m=0;m<rows*columns;m++)\n           values[m]=0;\n        }\n        Matrix(int row,int column,double value[]){\n           rows=row;\n           columns=column;\n           values=new double [rows*columns];\n           for(int m=0;m<rows*columns;m++)\n           values[m]=value[m]; \n        }\n\t Matrix(const Matrix & matrix2){\n\t\trows=matrix2.rows;\n\t\t columns=matrix2.columns;\n\t\t values=new double[rows*columns];\n\t\t for(int m=0;m<rows*columns;m++)\n           values[m]=matrix2.values[m];\n\t\t  \n\t }\n      \n        ~Matrix(){\n           delete  [] values;\n         }\n\t\t\n\t\tvoid print(){\n\t\t\tint cnt = 0;\n\t\t\tfor (int i = 0; i < this->rows; ++ i) {\n\t\t\t\tfor(int j = 0; j < this->columns; j ++){\n\t\t\t\t\tcout <<\"    \"<<this->values[cnt];\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t\tif(i!=this->rows)putchar('\\n');\n\t\t\t}\n\t\t\t\n\t\t}\n\t   void set(int row, int column, double value){\n\t\t\t\tthis->values[(row-1)*columns+column-1] = value;\n\t\t   return;\n\t   }\n\t   \n\t  \n};",
            1589531958.6653335,
            100,
            "# 答案正确"
        ],
        [
            "2.11 (C++)",
            "王子豪",
            "#include <iostream>\n#include<iomanip>\nusing namespace std;\n \nclass Matrix{\n\t private:\n        int rows = 0;\n        int columns = 0;\n        double * values;\n        \n    public:\n Matrix max() const{\n\t if(rows>1){\n\t\t Matrix t(1,columns);\n\t\t for(int i=0;i<rows;i++){\n\t\t\t for(int j=0;j<columns;j++){\n\t\t\t\t if(t.values[j]<values[i*columns+j]){\n\t\t\t\t\t t.values[j]=values[i*columns+j];\n\t\t\t\t }\n\t\t\t }\n\t\t }\n\t\t return t;\n\t }else{\n\t\t Matrix t(1,1);\n\t\t for(int i=0;i<columns;i++){\n\t\t\t if(t.values[0]<values[i]){\n\t\t\t\t t.values[0]=values[i];\n\t\t\t }\n\t\t }\n\t\t return t;\n\t }\n }\n\t Matrix min() const{\n\t if(rows>1){\n\t\t Matrix t(1,columns);\n\t\t for(int i=0;i<columns;i++){\n\t\t\t t.values[i]=100000;\n\t\t }\n\t\t for(int i=0;i<rows;i++){\n\t\t\t int flag=1;\n\t\t\t for(int j=0;j<columns;j++){\n\t\t\t\t \n\t\t\t\t if(t.values[j]>values[i*columns+j]||flag==1){\n\t\t\t\t\t t.values[j]=values[i*columns+j];\n\t\t\t\t\t flag=0;\n\t\t\t\t }\n\t\t\t }\n\t\t }\n\t\t return t;\n\t }else{\n\t\t Matrix t(1,1);\n\t\t t.values[0]=1000000;\n\t\t for(int i=0;i<columns;i++){\n\t\t\t if(t.values[0]>values[i]){\n\t\t\t\t t.values[0]=values[i];\n\t\t\t }\n\t\t }\n\t\t return t;\n\t }\n }\n\tMatrix sum() const{\n\t if(rows>1){\n\t\t Matrix t(1,columns);\n\t\t for(int i=0;i<rows;i++){\n\t\t\t for(int j=0;j<columns;j++){\n\t\t\t\t \n\t\t\t\t\t t.values[j]+=values[i*columns+j];\n\t\t\t\t \n\t\t\t }\n\t\t }\n\t\t return t;\n\t }else{\n\t\t Matrix t(1,1);\n\t\t for(int i=0;i<columns;i++){\n\t\t\t\n\t\t\t\t t.values[0]+=values[i];\n\t\t\t \n\t\t }\n\t\t return t;\n\t }\n }\n\n\n\n\tMatrix transpose(){\n\t\tMatrix t(columns,rows);\n\t\tfor(int i=0;i<rows;i++){\n\t\t\tfor(int j=0;j<columns;j++){\n\t\t\t\tt.values[j*rows+i]=values[i*columns+j];\n\t\t\t}\n\t\t}\n\t\treturn t;\n\t}\n\tMatrix operator * (const Matrix & matrix2) const{\n\t\tMatrix t(rows,matrix2.columns);\n\t\tfor(int i=0;i<rows;i++){\n\t\t\tfor(int j=0;j<matrix2.columns;j++){\n\t\t\t\tfor(int k=0;k<columns;k++){\n\t\t\t\t\tt.values[i*matrix2.columns+j]+=values[i*columns+k]*matrix2.values[k*matrix2.columns+j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn t;\n\t}\n\t Matrix operator * (double value) const{\n\t\t Matrix t(rows,columns);\n\t\t for(int i=0;i<rows*columns;i++){\n\t\t\t t.values[i]=values[i]*value;\n\t\t }\n\t\t return t;\n}\n\tMatrix reshape(int row, int column) {\n\t\tdouble* t=new double[rows*columns];\n\t\tint cnt=0;\n\t\tfor(int i=0;i<columns;i++){\n\t\t\tfor(int j=0;j<rows;j++){\n\t\t\t\tt[cnt]=values[j*columns+i];\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tcnt=0;\n\t\tMatrix g(row,column);\n\t\tfor(int i=0;i<column;i++){\n\t\t\tfor(int j=0;j<row;j++){\n\t\t\t\tg.values[j*column+i]=t[cnt];\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tdelete [] t;\n\t\treturn g;\n\t}\n\t\t\tMatrix(int row,int column){\n           rows=row;\n           columns=column;\n\t\t\t\t values=new double [rows*columns];\n           for(int m=0;m<rows*columns;m++)\n           values[m]=0;\n        }\n        Matrix(int row,int column,double value[]){\n           rows=row;\n           columns=column;\n           values=new double [rows*columns];\n           for(int m=0;m<rows*columns;m++)\n           values[m]=value[m]; \n        }\n\t Matrix(const Matrix & matrix2){\n\t\trows=matrix2.rows;\n\t\t columns=matrix2.columns;\n\t\t values=new double[rows*columns];\n\t\t for(int m=0;m<rows*columns;m++)\n           values[m]=matrix2.values[m];\n\t\t  \n\t }\n      \n        ~Matrix(){\n           delete  [] values;\n         }\n\t\t\n\t\tvoid print(){\n\t\t\tint cnt = 0;\n\t\t\tfor (int i = 0; i < this->rows; ++ i) {\n\t\t\t\tfor(int j = 0; j < this->columns; j ++){\n\t\t\t\t\tcout <<\"    \"<<this->values[cnt];\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t\tif(i!=this->rows)putchar('\\n');\n\t\t\t}\n\t\t\t\n\t\t}\n\t   void set(int row, int column, double value){\n\t\t\t\tthis->values[(row-1)*columns+column-1] = value;\n\t\t   return;\n\t   }\n\t   \n\t  \n};",
            1589533691.8441827,
            100,
            "# 答案正确"
        ],
        [
            "2.12 (C++)",
            "王子豪",
            "#include <iostream>\n#include<iomanip>\n#include<cmath>\nusing namespace std;\n \nclass Matrix{\n\t private:\n        int rows = 0;\n        int columns = 0;\n        double * values;\n        \n    public:\n Matrix pow(double exponent){\n\t Matrix t(rows,columns);\n\t for(int i=0;i<rows*columns;i++){\n\t\t t.values[i]=std::pow(values[i],exponent);\n\t }\n\t return t;\n }\nMatrix  exp(){\n\tMatrix t(rows,columns);\n\t for(int i=0;i<rows*columns;i++){\n\t\t t.values[i]=std::exp(values[i]);\n\t }\n\t return t;\n }\n Matrix log(){\n\t  Matrix t(rows,columns);\n\t for(int i=0;i<rows*columns;i++){\n\t\t t.values[i]=std::log(values[i])/std::log(std::exp(1));\n\t }\n\t return t;\n }\nMatrix abs()const{\n\t Matrix t(rows,columns);\n\t for(int i=0;i<rows*columns;i++){\n\t\t t.values[i]=std::abs(values[i]);\n\t }\n\t return t;\n }\n\t\t\tMatrix(int row,int column){\n           rows=row;\n           columns=column;\n\t\t\t\t values=new double [rows*columns];\n           for(int m=0;m<rows*columns;m++)\n           values[m]=0;\n        }\n        Matrix(int row,int column,double value[]){\n           rows=row;\n           columns=column;\n           values=new double [rows*columns];\n           for(int m=0;m<rows*columns;m++)\n           values[m]=value[m]; \n        }\n\t Matrix(const Matrix & matrix2){\n\t\trows=matrix2.rows;\n\t\t columns=matrix2.columns;\n\t\t values=new double[rows*columns];\n\t\t for(int m=0;m<rows*columns;m++)\n           values[m]=matrix2.values[m];\n\t\t  \n\t }\n      \n        ~Matrix(){\n           delete  [] values;\n         }\n\t\t\n\t\tvoid print(){\n\t\t\tint cnt = 0;\n\t\t\tfor (int i = 0; i < this->rows; ++ i) {\n\t\t\t\tfor(int j = 0; j < this->columns; j ++){\n\t\t\t\t\tcout <<\"    \"<<this->values[cnt];\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t\tif(i!=this->rows)putchar('\\n');\n\t\t\t}\n\t\t\t\n\t\t}\n\t   void set(int row, int column, double value){\n\t\t\t\tthis->values[(row-1)*columns+column-1] = value;\n\t\t   return;\n\t   }\n\t   \n\t  \n};",
            1589592624.6665308,
            100,
            "# 答案正确"
        ],
        [
            "2.9 (C++)",
            "王子豪",
            "#include <iostream>\n#include<iomanip>\nusing namespace std;\n \nclass Matrix{\n\t private:\n        int rows = 0;\n        int columns = 0;\n        double * values;\n        \n    public:\n\t\n\t\tMatrix operator + (const Matrix & matrix2) const{\n\t\tMatrix t(rows,matrix2.columns);\n\t\tfor(int i=0;i<rows*columns;i++){\n\t\t\tt.values[i]=values[i]+matrix2.values[i];\n\t\t}\n\t\treturn t;\n\t}\n\t Matrix operator + (double value) const{\n\t\t Matrix t(rows,columns);\n\t\t for(int i=0;i<rows*columns;i++){\n\t\t\t t.values[i]=values[i]+value;\n\t\t }\n\t\t return t;\n}\n\t\tMatrix operator - (const Matrix & matrix2) const{\n\t\tMatrix t(rows,matrix2.columns);\n\t\tfor(int i=0;i<rows*columns;i++){\n\t\t\tt.values[i]=values[i]-matrix2.values[i];\n\t\t}\n\t\treturn t;\n\t}\n\t Matrix operator - (double value) const{\n\t\t Matrix t(rows,columns);\n\t\t for(int i=0;i<rows*columns;i++){\n\t\t\t t.values[i]=values[i]-value;\n\t\t }\n\t\t return t;\n}\n\t\n\t\t\tMatrix(int row,int column){\n           rows=row;\n           columns=column;\n\t\t\t\t values=new double [rows*columns];\n           for(int m=0;m<rows*columns;m++)\n           values[m]=0;\n        }\n        Matrix(int row,int column,double value[]){\n           rows=row;\n           columns=column;\n           values=new double [rows*columns];\n           for(int m=0;m<rows*columns;m++)\n           values[m]=value[m]; \n        }\n\t Matrix(const Matrix & matrix2){\n\t\trows=matrix2.rows;\n\t\t columns=matrix2.columns;\n\t\t values=new double[rows*columns];\n\t\t for(int m=0;m<rows*columns;m++)\n           values[m]=matrix2.values[m];\n\t\t  \n\t }\n      \n        ~Matrix(){\n           delete  [] values;\n         }\n\t\t\n\t\tvoid print(){\n\t\t\tint cnt = 0;\n\t\t\tfor (int i = 0; i < this->rows; ++ i) {\n\t\t\t\tfor(int j = 0; j < this->columns; j ++){\n\t\t\t\t\tcout <<\"    \"<<this->values[cnt];\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t\tif(i!=this->rows)putchar('\\n');\n\t\t\t}\n\t\t\t\n\t\t}\n\t   void set(int row, int column, double value){\n\t\t\t\tthis->values[(row-1)*columns+column-1] = value;\n\t\t   return;\n\t   }\n\t   \n\t  \n};",
            1590026943.4692397,
            100,
            "# 答案正确"
        ],
        [
            "6.1 (C++)",
            "王子豪",
            "#include<string.h>\ntemplate<typename T>\nclass Matrix\n{\n\tprivate:\n\tint row;\n\tint col;\n\tT * buffer;\n\tpublic:\n\tMatrix(int x,int y){\n\t\trow=x;\n\t\tcol=y;\n\t\tbuffer=new T[row*col];\n\t\tmemset(buffer,0,sizeof(T)*row*col);\n\t}\n\tMatrix(int x,int y,const T*val){\n\t\trow=x;\n\t\tcol=y;\n\t\tbuffer=new T[row*col];\n\t\tfor(int i=0;i<row*col;i++){\n\t\t\tbuffer[i]=val[i];\n\t\t}\n\t}\n\t~Matrix(){\n\t\tdelete [] buffer;\n\t}\n\tMatrix(const Matrix<T>&ma){\n\t\tif(buffer!=NULL)delete []buffer;\n\t\trow=ma.row;\n\t\tcol=ma.col;\n\t\tbuffer=new T[row*col];\n\t\tfor(int i= 0;i<row*col;i++){\n\t\t\tbuffer[i]=ma.buffer[i];\n\t\t}\n\t}\n\t\n\tvoid print(){\n\t\tfor(int i=0;i<row;i++){\n\t\t\tfor(int j=0;j<col;j++){\n\t\t\t\tcout<<\"    \";\n\t\t\t\tcout<<buffer[i*col+j];\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t}\n\tMatrix &operator =(const Matrix&ma){\n\t\tif(buffer!=NULL) delete[]buffer;\n\t\trow=ma.row;\n\t\tcol=ma.col;\n\t\tbuffer=new T[ma.row*ma.col];\n\t\tfor(int i=0;i<row*col;i++){\n\t\t\tbuffer[i]=ma.buffer[i];\n\t\t}\n\t\treturn *this;\n\t}\n\tT &get(int x,int y){\n\t\treturn buffer[(x-1)*col+y-1];\n\t}\n};",
            1590127238.9652822,
            100,
            "# 答案正确"
        ],
        [
            "6.3 (C++)",
            "王子豪",
            "#include <vector>\n#include <iostream>\n#include <string.h>\n#define INF 0x7f7f7f7f\nusing namespace std;\n\ntemplate<typename T>\nclass Matrix\n{\n\t private:\n \tint rows;\n \tint columns;\n \t vector<T> values;\n public:\n \tMatrix(int x,int y){\n  \t\trows=x;\n  \t\tcolumns=y;\n\t\tfor(int i =0 ; i < rows*columns; i++)values.push_back(0);\n  \t\t\n \t}\n\t Matrix(int x,int y,const vector<T>val){\n \t\t rows=x;\n  \t\tcolumns=y;\n  \t\tfor(int i=0;i<rows*columns;i++){\n   \t\tvalues.push_back(val[i]);\n \t\t }\n \t}\n\t ~Matrix(){\n \t\t values.clear();\n \t}\n\t Matrix(const Matrix<T>&mat){\n  \t\t values.clear();\n  \t\trows=mat.rows;\n  \t\tcolumns=mat.columns;\n  \n  \t\tfor(int i=0;i<rows*columns;i++){\n   \t\tvalues.push_back(mat.values[i]);\n \t\t }\n \t}\n \n void print(){\n  \tfor(int i=0;i<rows;i++){\n   for(int j=0;j<columns;j++){\n    cout<<\"    \";\n    cout<<values[i*columns+j];\n   }\n  \t\t cout<<endl;\n \t }\n }\n\t Matrix &operator =(const Matrix&mat){\n \t\t\tvalues.clear();\n  \t\trows = mat.rows;\n  \t\tcolumns=mat.columns;\n  \t\n  \t\tfor(int i=0;i<rows*columns;i++){\n   \t\tvalues.push_back(mat.values[i]);\n \t\t }\n \t\t return *this;\n \t}\n\t T &get(int x,int y){\n  \t\treturn values[(x-1)*columns+y-1];\n \t}\n \t\n \tMatrix transpose() {\n\t\t   vector<T> newarr;\n\t\t   \t\tfor(int i = 0; i < columns; i++){\n\t\t\t\t\tfor(int j = 0; j < rows; j++){\n\t\t\t\t\t\tnewarr.push_back(values[j*(columns)+i]) ;\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t   \t\treturn Matrix(columns, rows, newarr);\n\t   }\n\t   \n\t   //坐标表示法 (row-1)*columns+column-1\n\t   Matrix  operator * (const Matrix<T> & matrix2) const{\n\t\t  vector<T> arr;\n\t\t  for(int i = 0; i < rows*columns; i++)arr.push_back(0);\n\t\t   for(int i = 0; i < this->rows; i ++){\n\t\t\t\tfor(int j = 0; j <  matrix2.columns; j ++){\n\t\t\t\t\tfor (int l = 0, m = 0; l < matrix2.rows; l++,m++){\n       arr[i*matrix2.columns+j] += this->values[i*this->columns+l] * matrix2.values[m * matrix2.columns+j];\n                }\n\t\t\t\t}\n\t\t   }\n\t\t    Matrix<T> newmatrix(rows, matrix2.columns, arr);\n\t\t   return newmatrix;\n\t   }\n\t\tMatrix  operator * (T value)  const{\n\t\t\tvector<T> arr;\n\t\t  for(int i = 0; i < rows*columns; i++)arr.push_back(0);\n\t\t\tfor(int i = 0; i < rows*columns; i++){\n\t\t\t\tarr[i] = value * values[i];\n\t\t\t}\n\t\t\treturn Matrix<T>(rows, columns, arr);\n\t\t}\n\t\tMatrix  operator + (T value)  const{\n\t\t\tvector<T> arr;\n\t\t  for(int i = 0; i < rows*columns; i++)arr.push_back(0);\n\t\t\tfor(int i = 0; i < rows*columns; i++){\n\t\t\t\tarr[i] = value + values[i];\n\t\t\t}\n\t\t\treturn Matrix<T>(rows, columns, arr);\n\t\t}\n\t\tMatrix operator + (const Matrix<T> & matrix2) const{\n\t\tvector<T> arr;\n\t\t  for(int i = 0; i < rows*columns; i++)arr.push_back(0);\n\t\t  for(int i = 0; i < rows*columns; i++)arr[i] = values[i]+matrix2.values[i];\n\t\t  return Matrix<T> (rows,columns,arr);\n\t\t}\n\t\t\tMatrix  operator - (T value)  const{\n\t\t\tvector<T> arr;\n\t\t  for(int i = 0; i < rows*columns; i++)arr.push_back(0);\n\t\t\tfor(int i = 0; i < rows*columns; i++){\n\t\t\t\tarr[i] =  values[i] - value;\n\t\t\t}\n\t\t\treturn Matrix<T>(rows, columns, arr);\n\t\t}\n\t\tMatrix operator - (const Matrix<T> & matrix2) const{\n\t\tvector<T> arr;\n\t\t  for(int i = 0; i < rows*columns; i++)arr.push_back(0);\n\t\t  for(int i = 0; i < rows*columns; i++)arr[i] = values[i]-matrix2.values[i];\n\t\t  return Matrix<T> (rows,columns,arr);\n\t\t}\n\t\t\n\t\tMatrix max() const{\n\t\t\t \tif(rows>1){\n\t\t\t\t\t\tvector<T> newarr;\n\t\t  for(int i = 0; i < rows*columns; i++)newarr.push_back(0);\n\t\t\t\t\tint max,maxrows;\n\t\t\t \t\tfor(int i = 0; i < this->columns;i++){\n\t\t\t\t\t\tmax = 0;\n\t\t\t\t\t\tmaxrows = 0;\n\t\t\t\t\t\tfor(int j = 0 ;j < this->rows; j++){\n\t\t\t\t\t\t\tif(values[columns*j+i]>max){\n\t\t\t\t\t\t\t\tmax = values[columns*j+i];\n\t\t\t\t\t\t\t\tmaxrows = j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnewarr[i] = values[this->columns*maxrows + i];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn  Matrix(1,columns,newarr);\n\t\t\t\t}\n\t\t\t\tif(rows==1){\n\t\t\t\t\tint max = 0;\n\t\t\t\t\tfor(int i = 0; i < columns; i++){\n\t\t\t\t\t\tif(values[i] > max)max = values[i];\n\t\t\t\t\t}\n\t\t\t\t\tvector<T> newarr;\n\t\t\t\t\tnewarr.push_back(0);\n\t\t\t\t\tnewarr[0] = max;\n\t\t\t \t\treturn Matrix(1,1,newarr);\n\t\t\t\t}\n\t\t\t \t\n\t\t  }\n\t\t  \n\t\t  Matrix min() const{\n\t\t\t  if(rows>1){\n\t\t\t\t\t\tvector<T> newarr;\n\t\t  for(int i = 0; i < rows*columns; i++)newarr.push_back(0);\n\t\t\t\t\tint min,minrows;\n\t\t\t \t\tfor(int i = 0; i < this->columns;i++){\n\t\t\t\t\t\tmin = INF;\n\t\t\t\t\t\tminrows = 0;\n\t\t\t\t\t\tfor(int j = 0 ;j < this->rows; j++){\n\t\t\t\t\t\t\tif(values[columns*j+i]<min){\n\t\t\t\t\t\t\t\tmin = values[columns*j+i];\n\t\t\t\t\t\t\t\tminrows = j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnewarr[i] = this->values[this->columns*minrows + i];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn  Matrix(1,columns,newarr);\n\t\t\t\t}\n\t\t\t\tif(rows==1){\n\t\t\t\t\tint min = INF;\n\t\t\t\t\tfor(int i = 0; i < columns; i++){\n\t\t\t\t\t\tif(values[i] < min)min = values[i];\n\t\t\t\t\t}\n\t\t\t\tvector<T> newarr;\n\t\t\t\t\tnewarr.push_back(0);\n\t\t\t\t\tnewarr[0] = min;\n\t\t\t \t\treturn Matrix(1,1,newarr);\n\t\t\t\t}\n\t\t  }\n\t\t   Matrix sum() const {\n\t\t\t\tif(rows>1){\n\t\t\t\t\tvector<T> newarr;\n\t\t  for(int i = 0; i < rows*columns; i++)newarr.push_back(0);\n\t\t\t\t\tint sum;\n\t\t\t \t\tfor(int i = 0; i < this->columns;i++){\n\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\tfor(int j = 0 ;j < this->rows; j++){\n\t\t\t\t\t\t\t\tsum += values[columns*j+i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnewarr[i] = sum;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn  Matrix(1,columns,newarr);\n\t\t\t\t}\n\t\t\t  if(rows==1){\n\t\t\t\t\tint sum = 0;\n\t\t\t\t\tfor(int i = 0; i < columns; i++){\n\t\t\t\t\t\tsum += values[i];\n\t\t\t\t\t}\n\t\t\t\t\tvector<T> newarr;\n\t\t\t\t\tnewarr.push_back(0);\n\t\t\t\t\tnewarr[0] = sum;\n\t\t\t \t\treturn Matrix(1,1,newarr);\n\t\t\t\t}\n\t\t  }\n\t\t   Matrix concatenateRows(const Matrix & matrix2)const {\n\t\t   \tvector<T> newarr;\n\t\t  for(int i = 0; i < rows*columns*2; i++)newarr.push_back(0);\n\t\t   for(int i = 0 ; i < this->rows*this->columns; i++){\n\t\t\t\tnewarr[i] = this->values[i];\n\t\t   }\n\t\t    for(int i = 0 ; i < this->rows*this->columns; i++){\n\t\t\tnewarr[i+this->rows*this->columns] = matrix2.values[i];\n\t\t   }\n\t\t\treturn Matrix(rows*2,columns,newarr);\n\t   }\n\t   Matrix concatenateColumns(const Matrix & matrix2) const{\n\t\t   \tvector<T> newarr;\n\t\t  for(int i = 0; i < rows*columns*2; i++)newarr.push_back(0);\n\t\t   int cnt = 0;\n\t\t   int cnt1 = 0, cnt2 = 0;\n\t\t \tfor(int i = 0; i < this->rows; i++){\n\t\t\t\tfor(int j = 0; j < this->columns; j++, cnt1++,cnt++){\n\t\t\t\t\tnewarr[cnt] = this->values[cnt1];\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < this->columns; j++,cnt2++,cnt++){\n\t\t\t\t\tnewarr[cnt] = matrix2.values[cnt2];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Matrix(rows,columns*2,newarr);\n\t   }\n\t   Matrix getRow(int row){\n\t   \t\t vector<T> newarr;\n\t\t  for(int i = 0; i < columns; i++)newarr.push_back(0);\n\t\t  for(int i = 0; i < columns; i++)newarr[i] = values[(row-1)*columns+i];\n\t\t\treturn Matrix(1, this->columns, newarr);\n\t\t}\n\t\tMatrix getColumn(int column){\n\t\t\t vector<T> newarr;\n\t\t  for(int i = 0; i < rows; i++)newarr.push_back(0);\n\t\t\tfor(int i = 0; i < this->rows; i ++){\n\t\t\t\tnewarr[i] = this->values[column-1+ i*this->columns];\n\t\t\t}\n\t\t\treturn Matrix(this->rows,1, newarr);\n\t\t}\n\t\tMatrix reshape(int x,int y){\n\t\t\tvector<T> newarr;\n\t\t\tfor(int i = 0; i < rows*columns; i++)newarr.push_back(0);\n\t\t\tvector<T> temp;\n\t\t\tfor(int i = 0; i < columns; i++){\n\t\t\t\tfor(int j = 0; j < rows; j++){\n\t\t\t\t\ttemp.push_back(values[columns*j+i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint cnt = 0;\n\t\t\tfor(int i = 0; i < y; i++){\n\t\t\t\tfor(int j = 0; j < x; j++,cnt++){\n\t\t\t\t\tnewarr[y*j+i] = temp[cnt];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Matrix<T>(columns, rows, newarr);\n\t\t}\n};",
            1590158927.5004659,
            100,
            "# 答案正确"
        ],
        [
            "6.2 (C++)",
            "王子豪",
            "#include<string.h>\n#include<iostream>\nusing namespace std;\ntemplate<typename T>\nclass Matrix\n{\n\tprivate:\n\tint row;\n\tint col;\n\tT * buffer;\n\tpublic:\n\tMatrix(int x,int y){\n\t\trow=x;\n\t\tcol=y;\n\t\tbuffer=new T[row*col];\n\t\tmemset(buffer,0,sizeof(T)*row*col);\n\t}\n\tMatrix(int x,int y,const T*val){\n\t\trow=x;\n\t\tcol=y;\n\t\tbuffer=new T[row*col];\n\t\tfor(int i=0;i<row*col;i++){\n\t\t\tbuffer[i]=val[i];\n\t\t}\n\t}\n\t~Matrix(){\n\t\tdelete [] buffer;\n\t}\n\tMatrix(const Matrix<T>&ma){\n\t\tif(buffer!=NULL)delete []buffer;\n\t\trow=ma.row;\n\t\tcol=ma.col;\n\t\tbuffer=new T[row*col];\n\t\tfor(int i= 0;i<row*col;i++){\n\t\t\tbuffer[i]=ma.buffer[i];\n\t\t}\n\t}\n\t\n\tvoid print(){\n\t\tfor(int i=0;i<row;i++){\n\t\t\tfor(int j=0;j<col;j++){\n\t\t\t\tcout<<\"    \";\n\t\t\t\tcout<<buffer[i*col+j];\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t\t\n\t\t}\n\t}\n\tMatrix &operator =(const Matrix&ma){\n\t\tif(buffer!=NULL) delete[]buffer;\n\t\trow=ma.row;\n\t\tcol=ma.col;\n\t\tbuffer=new T[ma.row*ma.col];\n\t\tfor(int i=0;i<row*col;i++){\n\t\t\tbuffer[i]=ma.buffer[i];\n\t\t}\n\t\treturn *this;\n\t}\n\tT &get(int x,int y){\n\t\treturn buffer[(x-1)*col+y-1];\n\t}\n};",
            1590631415.0180593,
            100,
            "# 答案正确"
        ],
        [
            "7.1 (C++)",
            "王子豪",
            "#include<cmath>\nclass Triangle:public GeometricObject\n{\n\tprivate:\n\t\tdouble a;\n\t\tdouble b;\n\t\tdouble c;\n\tpublic:\n\t\tTriangle(){\n\t\t\ta=1.0;\n\t\t\tb-1.0;\n\t\t\tc=1.0;\n\t\t}\n\t\tTriangle(double a1,double b1,double c1){\n\t\t\ta=a1;\n\t\t\tb=b1;\n\t\t\tc=c1;\n\t\t}\n\t\tdouble getSide1(){\n\t\t\treturn a;\n\t\t}\n\t\tdouble getSide2(){\n\t\t\treturn b;\n\t\t}\n\t\tdouble getSide3(){\n\t\t\treturn c;\n\t\t}\n\t\tdouble getArea(){\n\t\t\tdouble s= (a + b + c) / 2;\n\t\t\treturn sqrt(s * (s - a) * (s - b) * (s - c));\n\t\t}\n\t\tdouble getPerimeter(){\n\t\t\treturn a+b+c;\n\t\t}\n}; ",
            1590724912.4744887,
            100,
            "# 答案正确"
        ],
        [
            "7.3 (C++)",
            "王子豪",
            "template <typename A, typename R>\nvector<R> map2(const vector<A> & x,const vector<A> & y, R (*map_func)(const A &,const A &)) {\n\tvector<R> res;\n\tfor (int i = 0; i < x.size(); ++ i)\n\t\tres.push_back(map_func(x[i],y[i]));\n\treturn res;\n}\ntemplate <typename A, typename R>\nvector<R> map2(const vector<A> & x,int c, R (*map_func)(const A &,const A &)) {\n\tvector<R> res;\n\tfor (int i = 0; i < x.size(); ++ i)\n\t\tres.push_back(map_func(x[i],c));\n\treturn res;\n}",
            1590727082.262316,
            100,
            "# 答案正确"
        ],
        [
            "7.2 (C++)",
            "王子豪",
            "#include <iostream>\n#include <string>\n#include <vector>\n#include<cstring>\nusing namespace std;\nvector <string> split(const string& src){\n\tvector <string> strs;\n\t int lastPosition = 0,index = -1;\n\tint len=1;\n    while (-1 != (index = src.find(' ',lastPosition)))\n    {\n        strs.push_back(src.substr(lastPosition,index - lastPosition));\n        lastPosition = index + len;\n    }\n    string lastString = src.substr(lastPosition);\n    if (!lastString.empty())\n        strs.push_back(lastString);\n    return strs;\n}",
            1591237205.9948764,
            100,
            "# 答案正确"
        ],
        [
            "8.1 (C++)",
            "王子豪",
            "class Full: public Matrix\n{\nprivate:\nint rows;\nint cols;\ndouble *val;\npublic :\n Full(int row, int column){\n rows=row;\n cols=column;\n val=new double[rows*cols];\n for(int i=0;i<rows*cols;i++){\n val[i]=0;\n }\n }\n int size(int dimension) const\n\n\t{\n\n\t\tif(dimension == 1) return rows;\n\n\t\tif(dimension == 2) return cols;\n\n\t}\n Full(int row, int column, double values[]){\n  rows=row;\n cols=column;\n val=new double[rows*cols];\n for(int i=0;i<rows*cols;i++){\n val[i]=values[i];\n }\n }\n\n double get(int row, int column) const {\n return val[row*cols+column];\n }\n void set(int row, int column, double value){\n val[(row-1)*cols+column-1]=value;\n }\n Full(const Matrix & m2){\n\n\n rows=m2.size(1);\n cols=m2.size(2);\nval=new double[rows*cols];\n for(int i=0;i<rows;i++){\nfor(int j=0;j<cols;j++){\nval[i*cols+j]=m2.get(i,j);\n}\n\n }}\n ~Full(){\n delete[]val;\n }\n void print()const{\nfor(int i=0;i<rows;i++){\nfor(int j=0;j<cols;j++){\nprintf(\"%.0lf    \",val[i*cols+j]);\n}\nprintf(\"\\n\");}\n}\nMatrix & operator = (const Matrix & m2) {\ndelete []val;\nrows=m2.size(1);\ncols=m2.size(2);\n val=new double[rows*cols];\n for(int i=0;i<rows;i++){\nfor(int j=0;j<cols;j++){\nval[i*cols+j]=m2.get(i,j);\n}\n\n }\n }\n};",
            1591434905.717459,
            100,
            "# 答案正确"
        ],
        [
            "8.3 (C++)",
            "王子豪",
            "#include<vector>\n#include<algorithm>\n#include <iostream> \nusing namespace std; \n\nbool Comp1(const Entry &a,const Entry &b)\n{\n\treturn a.row<b.row;\n}\nbool Comp2(const Entry &a,const Entry &b)\n{\n\treturn (a.row==b.row&&a.column<b.column);\n}\nclass Sparse : public Matrix\n\n{\n\nprivate:\n\n\tint _rows, _columns;\n\n\tvector<Entry> entry;\n\npublic:\n\n\tSparse(int rows, int column)\n\n\t{\n\n\t\t_rows = rows;\n\n\t\t_columns = column;\n\n\t\tentry = vector<Entry>();\n\n\t}\n\n\tint size(int dimension) const\n\n\t{\n\n\t\tif(dimension == 1) return _rows;\n\n\t\tif(dimension == 2) return _columns;\n\n\t}\n\n\tvoid set(int row, int column, double value)\n\n\t{\n\n\t\tEntry e;\n\n\t\te.row = row;\n\n\t\te.column = column;\n\n\t\te.value = value;\n\n\t\tentry.push_back(e);\n\n\t}\n\n\tdouble get(int row, int column) const\n\n\t{\n\n\t\tfor(int i=0; i < entry.size();i++)\n\n\t\t{\n\n\t\t\tif(entry[i].row == row\n\n\t\t\t\t && entry[i].column == column ){\n\n\t\t\t\treturn entry[i].value;\t\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tvoid print()\n\n\t{\n\n\t\tfor(int i=0; i < entry.size();i++)\n\n\t\t{\n\n\t\t\tcout<<\"(\"<<entry[i].row<<\",\"<<entry[i].column<<\",\"\n\n\t\t\t\t<<entry[i].value<<\")\\n\";\n\n\t\t}\n\n\t}\n\n\tSparse operator + (Sparse & sparse2)\n\n\t{\n\n\t\tSparse s(_rows, _columns);\n\n\t\tfor(int i=0; i < this->entry.size(); i++)\n\t\t{\n\t\t\tfor(int j = 0 ;j< sparse2.entry.size(); j++)\n\n\t\t\t{\n\n\t\t\t\tif(this->entry[i].row == sparse2.entry[j].row \n\n\t\t\t\t\t&& this->entry[i].column == sparse2.entry[j].column){\n\n\t\t\t\t\tEntry e;\n\n\t\t\t\t\te.row = sparse2.entry[j].row;\n\n\t\t\t\t\te.column =  sparse2.entry[j].column;\n\n\t\t\t\t\te.value = this->entry[i].value + sparse2.entry[j].value;\n\t\t\t\t\tif(e.value)\n\t\t\t\t\ts.entry.push_back(e);\n\t\t\t\t\tthis->entry[i].value = 0;\n\t\t\t\t\tsparse2.entry[j].value = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tfor(int i=0; i < this->entry.size(); i++)\n\n\t\t{\n\n\t\t\tEntry e;\n\n\t\t\te.row = this->entry[i].row;\n\n\t\t\te.column = this->entry[i].column;\n\n\t\t\te.value = this->entry[i].value;\n\n\t\t\tif(e.value)\n\n\t\t\t\ts.entry.push_back(e);\n\n\t\t}\n\n\t\tfor(int i=0; i < sparse2.entry.size(); i++)\n\n\t\t{\n\n\t\t\tEntry e;\n\n\t\t\te.row = sparse2.entry[i].row;\n\n\t\t\te.column = sparse2.entry[i].column;\n\n\t\t\te.value = sparse2.entry[i].value;\n\n\t\t\tif(e.value)\n\n\t\t\t\ts.entry.push_back(e);\n\n\t\t}\n\n\t\tsort(s.entry.begin(),s.entry.end(),Comp1);\n\n\t\tsort(s.entry.begin(),s.entry.end(),Comp2);\n\n\t\treturn s;\n\t}\n\n};\n",
            1591346177.3793876,
            100,
            "# 答案正确"
        ],
        [
            "8.4 (C++)",
            "王子豪",
            "#include<vector>\n#include<algorithm>\n#include <iostream> \nusing namespace std; \n\nbool Comp1(const Entry &a,const Entry &b)\n{\n\treturn a.row<b.row;\n}\nbool Comp2(const Entry &a,const Entry &b)\n{\n\treturn (a.row==b.row&&a.column<b.column);\n}\nclass Sparse : public Matrix\n\n{\n\nprivate:\n\n\tint _rows, _columns;\n\n\tvector<Entry> entry;\n\npublic:\n\tint size(int dimension) const\n\n\t{\n\n\t\tif(dimension == 1) return _rows;\n\n\t\tif(dimension == 2) return _columns;\n\n\t}\n\n\tSparse(int rows, int column)\n\n\t{\n\n\t\t_rows = rows;\n\n\t\t_columns = column;\n\n\t\tentry = vector<Entry>();\n\n\t}\n\n\n\n\tvoid set(int row, int column, double value)\n\n\t{\n\n\t\tEntry e;\n\n\t\te.row = row;\n\n\t\te.column = column;\n\n\t\te.value = value;\n\n\t\tentry.push_back(e);\n\n\t}\n\n\tdouble get(int row, int column) const\n\n\t{\n\n\t\tfor(int i=0; i < entry.size();i++)\n\n\t\t{\n\n\t\t\tif(entry[i].row == row\n\n\t\t\t\t && entry[i].column == column ){\n\n\t\t\t\treturn entry[i].value;\t\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tvoid print()\n\n\t{\n\n\t\tfor(int i=0; i < entry.size();i++)\n\n\t\t{\n\n\t\t\tcout<<\"(\"<<entry[i].row<<\",\"<<entry[i].column<<\",\"\n\n\t\t\t\t<<entry[i].value<<\")\\n\";\n\n\t\t}\n\n\t}\n\n\t\n\tSparse operator * (Sparse & s2)\n\t{\n\tSparse s(_rows, s2._columns);\n\tfor(int i=0; i < this->entry.size(); i++)\n\t\t{\n\t\tfor(int j=0; j<s2.entry.size(); j++)\n\n\t\t{\n\t\t\tif(this->entry[i].column == s2.entry[j].row){\n\t\t\tEntry e;\n\n\t\t\te.row = this->entry[i].row;\n\n\t\t\te.column = s2.entry[j].column;\n\n\t\t\te.value = s2.entry[j].value*this->entry[i].value;\n\t\t\tif(e.value){\n\t\t\t\tint flag=1;\n\t\t\t\tfor(int k=0;k<s.entry.size();k++){\n\t\t\t\tif(e.row==s.entry[k].row&&e.column==s.entry[k].column){\n\t\t\t\ts.entry[k].value+=e.value;\n\t\t\t\tflag=0;\n\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag){\n\t\t\t\ts.entry.push_back(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\t}\n\n\n\t\t}\n\t\t\n\t\t\t\t\n\n\t\t}\n\n\n\t\tsort(s.entry.begin(),s.entry.end(),Comp1);\n\n\t\tsort(s.entry.begin(),s.entry.end(),Comp2);\n\n\t\treturn s;\t\n\n\t\t}\n\t\n};\n",
            1591674378.0296988,
            100,
            "# 答案正确"
        ],
        [
            "8.5 (C++)",
            "王子豪",
            "#include <assert.h>\nclass Point3D :public Point2D\n{\nprivate:\ndouble z;\npublic:\nPoint3D(){\nsetX(0);\nsetY(0);\nz=0;\n}\nPoint3D(double a,double b,double c){\nsetX(a);\nsetY(b);\nz=c;\n}\ndouble getX(){\nreturn Point2D::getX();\n}\ndouble getY(){\nreturn Point2D::getY();\n}\ndouble getZ(){\nreturn z;\n}\nvirtual double distance(Point2D & point2){\nPoint3D * p2=dynamic_cast<Point3D *>(&point2);\ndouble dx = getX() - point2.getX();\ndouble dy =getY() - point2.getY();\ndouble dz=getZ()-p2->getZ();\n\t\treturn sqrt(dx * dx + dy * dy+dz * dz);\n}\n};",
            1591842615.665959,
            100,
            "# 答案正确"
        ],
        [
            "8.6 (C++)",
            "王子豪",
            "#include <iostream>\nclass MyTensor : public Tensor<double> {\n private:\n  double *data;\n  \n public:\n  MyTensor(vector<int> size):Tensor(size){\n   int cnt=1;\n   for(int i=0;i<size.size();i++){\n    cnt*=size[i];\n    \n   }\n   \n   data=new double[cnt];\n   \n  }\n  ~MyTensor(){\n   delete []data;\n  }\n  virtual double & get(const vector<int> & indexes){\n   if(indexes.size()==1) {\n    return data[indexes[0]];\n   }\n   else if(indexes.size()==2) {\n    return data[indexes[0]*sizes[1]+indexes[1]];\n   }\n   else if(indexes.size()==3){\n    return data[indexes[0]*sizes[1]*sizes[2]+indexes[1]*sizes[2]+indexes[2]];\n   }\n   else if(indexes.size()==4) {\n    return data[indexes[0]*sizes[1]*sizes[2]*sizes[3]+indexes[1]*sizes[2]*sizes[3]+indexes[2]*sizes[3]+indexes[3]];\n   }\n  }\n \n};",
            1592450936.5677974,
            100,
            "# 答案正确"
        ],
        [
            "9.1 (C++)",
            "王子豪",
            "class Circle{\n\tprivate:\n\tdouble rad;\n\tpublic:\n\tCircle(double r){\n\t\trad=r;\n\t}\n\tint  operator <(Circle c1){\n\t\tif(this->rad<c1.rad){\n\t\t\treturn 1;\n\t\t}else{\n\t\t\treturn 0;\n\t\t}\n\t}\n\tint  operator <=(Circle c1){\n\t\tif(this->rad<=c1.rad){\n\t\t\treturn 1;\n\t\t}else{\n\t\t\treturn 0;\n\t\t}\n\t}\n\tint operator >(Circle c1){\n\t\tif(this->rad>c1.rad){\n\t\t\treturn 1;\n\t\t}else{\n\t\t\treturn 0;\n\t\t}\n\t}\n\tint  operator >=(Circle c1){\n\t\tif(this->rad>=c1.rad){\n\t\t\treturn 1;\n\t\t}else{\n\t\t\treturn 0;\n\t\t}\n\t}\n\tint  operator ==(Circle c1){\n\t\tif(this->rad==c1.rad){\n\t\t\treturn 1;\n\t\t}else{\n\t\t\treturn 0;\n\t\t}\n\t}\n\tint operator !=(Circle c1){\n\t\tif(this->rad!=c1.rad){\n\t\t\treturn 1;\n\t\t}else{\n\t\t\treturn 0;\n\t\t}\n\t}\n};",
            1592532414.9901643,
            100,
            "# 答案正确"
        ],
        [
            "9.3 (C++)",
            "王子豪",
            "#include<cmath>\nclass Complex\n{\t\n\t\n\t\n\tpublic:\n double r;\n\tdouble i;\n\t\n\tdouble real(){\n\t\treturn r;\n\t}\n\tdouble imag(){\n\t\treturn i;\n\t}\n\tComplex(double n,double m){\n\t\tr=n;\n\t\ti=m;\n\t}\n\tComplex(){\n\t\tr=0;\n\t\ti=0;\n\t}\n\t\n\t\n\tComplex operator *(const Complex & c2){\n\t\tComplex t;\n\t\tt.r=this->r*c2.r-this->i*c2.i;\n\t\tt.i=this->i*c2.r+this->r*c2.i;\n\t\treturn t;\n\t}\n\tComplex operator/( const Complex &c2){\n\n\t\tComplex c;\n\n\t\tc.r=((this->r*c2.r + this->i*c2.i)*1.0) /( (pow(c2.r, 2) + pow(c2.i, 2))*1.0);\n      c.i= ((this->i*c2.r - this->r*c2.i) *1.0)/ ((pow(c2.r, 2) + pow(c2.i, 2))*1.0);\nreturn c;\n}\n\tComplex operator +=(const Complex &c2){\n\t\t\n\t\tthis->r=this->r+c2.r;\n\t\tthis->i=this->i+c2.i;\n\t\treturn *this;\n\t}\n\tComplex operator -=(const Complex &c2){\n\t\tthis->r=this->r-c2.r;\n\t\tthis->i=this->i-c2.i;\n\t\treturn *this;\n\t}\n\tComplex operator *=(const Complex &c2){\n\t\t\n\t\tdouble g=this->r*c2.r-this->i*c2.i;\n\t\tdouble k=this->i*c2.r+this->r*c2.i;\n\t\tthis->r=g;\n\t\tthis->i=k;\n\t\treturn *this;\n\t}\n\tComplex operator /=(const Complex &c){\n\t\tdouble a,b;\n\t\t\n\t\ta =( double)((this->r*c.r + this->i*c.i)*1.0) /( (pow(c.r, 2) + pow(c.i, 2))*1.0);\n      b= (double)((this->i*c.r - this->r*c.i) *1.0)/ ((pow(c.r, 2) + pow(c.i, 2))*1.0);\n\t\tthis->r=a;\n\t\tthis->i=b;\n\t\treturn *this;\n\t}\n\tint operator ==(const Complex& c2){\n\t\tif(this->r==c2.r&&this->i==c2.i){\n\t\t\treturn 1;\n\t\t}else{\n\t\t\treturn 0;\n\t\t}\n\t}\n\tint operator !=(const Complex &c2){\n\t\tif(this->r==c2.r&&this->i==c2.i){\n\t\t\treturn 0;\n\t\t}else{\n\t\t\treturn 1;\n\t\t}\n\t}\n};\nComplex operator +(const Complex& c1,const Complex& c2){\n\t\tComplex t;\n\t\tt.r=c1.r+c2.r;\n\t\tt.i=c1.i+c2.i;\n\t\treturn t;\n\t}\nComplex operator +(int v,const Complex& c2){\n\t\tComplex t;\n\t\tt.r=v+c2.r;\n\t\tt.i=c2.i;\n\t\treturn t;\n\t}\n\t\tComplex operator -(const Complex& c1,const Complex& c2){\n\t\tComplex t;\n\t\tt.r=c1.r-c2.r;\n\t\tt.i=c1.i-c2.i;\n\t\treturn t;\n\t}\nComplex operator -(const Complex& c1,int v){\n\t\tComplex t;\n\t\tt.r=c1.r-v;\n\t\tt.i=c1.i;\n\t\treturn t;\n\t}",
            1592570328.202157,
            100,
            "# 答案正确"
        ],
        [
            "9.4 (C++)",
            "王子豪",
            "class Complex\n{\t\n\t\n\t\n\tpublic:\n double r;\n\tdouble i;\n\t\n\tint real(){\n\t\treturn r;\n\t}\n\tint imag(){\n\t\treturn i;\n\t}\n\tComplex(double n,double m){\n\t\tr=n;\n\t\ti=m;\n\t}\n\tComplex(){\n\t\tr=0;\n\t\ti=0;\n\t}\n\t\n\tComplex operator *(const Complex & c2){\n\t\tComplex t;\n\t\tt.r=this->r*c2.r-this->i*c2.i;\n\t\tt.i=this->i*c2.r+this->r*c2.i;\n\t\treturn t;\n\t}\n\tComplex operator /(const Complex &c2){\n\t\tComplex t;\n\t\t t.r=((this->r*c2.r+this->i*c2.i)*1.0)/((c2.i*c2.i+c2.r*c2.r)*1.0);\n\t\t t.i=((this->i*c2.r-this->r*c2.i)*1.0)/((c2.i*c2.i+c2.r*c2.r)*1.0);\n\t\treturn t;\n\t}\n\tComplex operator +=(const Complex &c2){\n\t\t\n\t\tthis->r=this->r+c2.r;\n\t\tthis->i=this->i+c2.i;\n\t\treturn *this;\n\t}\n\tComplex operator -=(const Complex &c2){\n\t\tthis->r=this->r-c2.r;\n\t\tthis->i=this->i-c2.i;\n\t\treturn *this;\n\t}\n\tComplex operator *=(const Complex &c2){\n\t\t\n\t\tdouble g=this->r*c2.r-this->i*c2.i;\n\t\tdouble k=this->i*c2.r+this->r*c2.i;\n\t\tthis->r=g;\n\t\tthis->i=k;\n\t\treturn *this;\n\t}\n\tComplex operator /=(const Complex &c2){\n\t\t\n\t\tdouble t=((this->r*1.0*c2.r+this->i*c2.i*1.0)*1.0)/((c2.i*1.0*c2.i+c2.r*1.0*c2.r)*1.0);\n\t\tdouble x=((this->i*1.0*c2.r-this->r*c2.i*1.0)*1.0)/((c2.i*1.0*c2.i+c2.r*1.0*c2.r)*1.0);\n\t\tthis->r=t;\n\t\tthis->i=x;\n\t\treturn *this;\n\t}\n\tint operator ==(const Complex& c2){\n\t\tif(this->r==c2.r&&this->i==c2.i){\n\t\t\treturn 1;\n\t\t}else{\n\t\t\treturn 0;\n\t\t}\n\t}\n\tint operator !=(const Complex &c2){\n\t\tif(this->r==c2.r&&this->i==c2.i){\n\t\t\treturn 0;\n\t\t}else{\n\t\t\treturn 1;\n\t\t}\n\t}\n};\nComplex operator +(const Complex& c1,const Complex& c2){\n\t\tComplex t;\n\t\tt.r=c1.r+c2.r;\n\t\tt.i=c1.i+c2.i;\n\t\treturn t;\n\t}\nComplex operator +(int v,const Complex& c2){\n\t\tComplex t;\n\t\tt.r=v+c2.r;\n\t\tt.i=c2.i;\n\t\treturn t;\n\t}\n\t\tComplex operator -(const Complex& c1,const Complex& c2){\n\t\tComplex t;\n\t\tt.r=c1.r-c2.r;\n\t\tt.i=c1.i-c2.i;\n\t\treturn t;\n\t}\nComplex operator -(const Complex& c1,int v){\n\t\tComplex t;\n\t\tt.r=c1.r-v;\n\t\tt.i=c1.i;\n\t\treturn t;\n\t}\nistream & operator>>(istream &in, Complex &A){\nin >> A.r >> A.i;\nreturn in;\n}\n\tostream & operator<<(ostream &out, Complex &A){\nout << A.r <<\" + \"<< A.i<<\" i \";\nreturn out;\n}",
            1592541674.1766412,
            100,
            "# 答案正确"
        ],
        [
            "9.5 (C++)",
            "王子豪",
            "class Complex\n{\t\n\t\n\t\n\tpublic:\n double r;\n\tdouble i;\n\t\n\tint real(){\n\t\treturn r;\n\t}\n\tint imag(){\n\t\treturn i;\n\t}\n\tComplex(double n,double m){\n\t\tr=n;\n\t\ti=m;\n\t}\n\tComplex(){\n\t\tr=0;\n\t\ti=0;\n\t}\n\t\n\tComplex operator *(const Complex & c2){\n\t\tComplex t;\n\t\tt.r=this->r*c2.r-this->i*c2.i;\n\t\tt.i=this->i*c2.r+this->r*c2.i;\n\t\treturn t;\n\t}\n\tComplex operator /(const Complex &c2){\n\t\tComplex t;\n\t\t t.r=((this->r*c2.r+this->i*c2.i)*1.0)/((c2.i*c2.i+c2.r*c2.r)*1.0);\n\t\t t.i=((this->i*c2.r-this->r*c2.i)*1.0)/((c2.i*c2.i+c2.r*c2.r)*1.0);\n\t\treturn t;\n\t}\n\tComplex operator +=(const Complex &c2){\n\t\t\n\t\tthis->r=this->r+c2.r;\n\t\tthis->i=this->i+c2.i;\n\t\treturn *this;\n\t}\n\tComplex operator -=(const Complex &c2){\n\t\tthis->r=this->r-c2.r;\n\t\tthis->i=this->i-c2.i;\n\t\treturn *this;\n\t}\n\tComplex operator *=(const Complex &c2){\n\t\t\n\t\tdouble g=this->r*c2.r-this->i*c2.i;\n\t\tdouble k=this->i*c2.r+this->r*c2.i;\n\t\tthis->r=g;\n\t\tthis->i=k;\n\t\treturn *this;\n\t}\n\tComplex operator /=(const Complex &c2){\n\t\t\n\t\tdouble t=((this->r*1.0*c2.r+this->i*c2.i*1.0)*1.0)/((c2.i*1.0*c2.i+c2.r*1.0*c2.r)*1.0);\n\t\tdouble x=((this->i*1.0*c2.r-this->r*c2.i*1.0)*1.0)/((c2.i*1.0*c2.i+c2.r*1.0*c2.r)*1.0);\n\t\tthis->r=t;\n\t\tthis->i=x;\n\t\treturn *this;\n\t}\n\tint operator ==(const Complex& c2){\n\t\tif(this->r==c2.r&&this->i==c2.i){\n\t\t\treturn 1;\n\t\t}else{\n\t\t\treturn 0;\n\t\t}\n\t}\n\tint operator !=(const Complex &c2){\n\t\tif(this->r==c2.r&&this->i==c2.i){\n\t\t\treturn 0;\n\t\t}else{\n\t\t\treturn 1;\n\t\t}\n\t}\n\toperator double()const{return r;}\n\tComplex operator++(); //++i，前置形式\nComplex operator++(int);\n};\nComplex operator +(const Complex& c1,const Complex& c2){\n\t\tComplex t;\n\t\tt.r=c1.r+c2.r;\n\t\tt.i=c1.i+c2.i;\n\t\treturn t;\n\t}\nComplex operator +(int v,const Complex& c2){\n\t\tComplex t;\n\t\tt.r=v+c2.r;\n\t\tt.i=c2.i;\n\t\treturn t;\n\t}\n\t\tComplex operator -(const Complex& c1,const Complex& c2){\n\t\tComplex t;\n\t\tt.r=c1.r-c2.r;\n\t\tt.i=c1.i-c2.i;\n\t\treturn t;\n\t}\nComplex operator -(const Complex& c1,int v){\n\t\tComplex t;\n\t\tt.r=c1.r-v;\n\t\tt.i=c1.i;\n\t\treturn t;\n\t}\nistream & operator>>(istream &in, Complex& A){\nin >> A.r >> A.i;\nreturn in;\n}\n\tostream & operator<<(ostream &out,const Complex& A){\nout << A.r <<\" + \"<< A.i<<\" i \";\nreturn out;\n}\nComplex Complex :: operator ++(){\n\t\tthis->r++;\n\t\n\t\treturn *this;\n\t}\nComplex Complex :: operator ++(int){\n\t\tComplex t(*this);\n\t\tthis->r++;\n\t\t\n\t\treturn t;\n\t}",
            1592570537.1621199,
            100,
            "# 答案正确"
        ],
        [
            "9.2 (C++)",
            "王子豪",
            "class I{\n\tprivate:\n\tvector<int> data;\n\tpublic:\n\tI(int a,int b=-1,int c=-1,int d=-1){\n\t\tdata.push_back(a);\n\t\tif(b!=-1){\n\t\t\tdata.push_back(b);\n\t\t}\n\t\tif(c!=-1){\n\t\t\tdata.push_back(c);\n\t\t}\n\t\tif(d!=-1){\n\t\t\tdata.push_back(d);\n\t\t}\n\t}\n\toperator vector<int>()const{return data;}\n};",
            1592642289.2541769,
            100,
            "# 答案正确"
        ],
        [
            "9.6 (C++)",
            "王子豪",
            "class Tensor{\n\tprivate:\n\tvector<int>sizes;\n\tvector<double>data;\n\tpublic:\n\tTensor(int a,int b=-1,int c=-1,int d=-1){\n\t\tint cnt=a;\n\t\tsizes.push_back(a);\n\t\tif(b!=-1){\n\t\t\tcnt*=b;\n\t\t\tsizes.push_back(b);\n\t\t}\n\t\tif(c!=-1){\n\t\t\tcnt*=c;\n\t\t\tsizes.push_back(c);\n\t\t}\n\t\tif(d!=-1){\n\t\t\tcnt*=d;\n\t\t\tsizes.push_back(d);\n\t\t}\n\t\tfor(int i=0;i<cnt;i++){\n\t\t\tdata.push_back(0);\n\t\t}\n\t}\n\t double & operator()(int a,int b=-1,int c=-1,int d=-1){\n\t\tif(sizes.size()==1) {\n    return data[a];\n   }\n   else if(sizes.size()==2) {\n    return data[a*sizes[1]+b];\n   }\n   else if(sizes.size()==3){\n    return data[a*sizes[1]*sizes[2]+b*sizes[2]+c];\n   }\n   else if(sizes.size()==4) {\n    return data[a*sizes[1]*sizes[2]*sizes[3]+b*sizes[2]*sizes[3]+c*sizes[3]+d];\n   }\n\t}\n\t const double & operator ()(int a,int b=-1,int c=-1,int d=-1)const{\n\t\tif(sizes.size()==1) {\n    return data[a];\n   }\n   else if(sizes.size()==2) {\n    return data[a*sizes[1]+b];\n   }\n   else if(sizes.size()==3){\n    return data[a*sizes[1]*sizes[2]+b*sizes[2]+c];\n   }\n   else if(sizes.size()==4) {\n    return data[a*sizes[1]*sizes[2]*sizes[3]+b*sizes[2]*sizes[3]+c*sizes[3]+d];\n   }\n\t}\n};",
            1592643204.954089,
            100,
            "# 答案正确"
        ],
        [
            "9.7 (C++)",
            "王子豪",
            "class Tensor{\n\t\n\t\n\tpublic:\n\tint big;\n\tvector<int>sizes;\n\tvector<double>data;\n\t\n};\nistream &operator >>(istream &in,Tensor &m){\n\t\tint n;\n\t\tin>>n;\n\t\tm.big=n;\n\t\tint a,b,c,d;\n\t\tint cnt=1;\n\t\tif(n==1){\n\t\t\tin>>a;\n\t\t\tm.sizes.push_back(a);\n\t\t\tcnt=a;\n\t\t}else if(n==2){\n\t\t\tin>>a>>b;\n\t\t\tm.sizes.push_back(a);\n\t\t\tm.sizes.push_back(b);\n\t\t\tcnt=a*b;\n\t\t}else if(n==3){\n\t\t\tin>>a>>b>>c;\n\t\t\tm.sizes.push_back(a);\n\t\t\tm.sizes.push_back(b);\n\t\t\tm.sizes.push_back(c);\n\t\t\tcnt=a*b*c;\n\t\t}else{\n\t\t\tin>>a>>b>>c>>d;\n\t\t\tm.sizes.push_back(a);\n\t\t\tm.sizes.push_back(b);\n\t\t\tm.sizes.push_back(c);\n\t\t\tm.sizes.push_back(d);\n\t\t\tcnt=a*b*c*d;\n\t\t}\n\t\tfor(int i=0;i<cnt;i++){\n\t\t\tdouble t;\n\t\t\tin>>t;\n\t\t\tm.data.push_back(t);\n\t\t}\n\t\treturn in;\n\t}\n\tostream &operator <<(ostream&out,const Tensor&m){\n\t\tout<<m.big<<endl;\n\t\tfor(int i=0;i<m.big;i++){\n\t\t\tout<<m.sizes[i]<<\" \";\n\t\t}\n\t\tout<<endl;\n\t\tout<<endl;\n\t\tif(m.big==1){\n\t\t\tfor(int i=0;i<m.sizes[0];i++){\n\t\t\t\tout<<m.data[i]<<\" \";\n\t\t\t}\n\t\t\tout<<endl;\n\t\t}else if(m.big==2){\n\t\t\tfor(int i=0;i<m.sizes[0];i++){\n\t\t\t\tfor(int j=0;j<m.sizes[1];j++){\n\t\t\t\tout<<m.data[i*m.sizes[1]+j]<<\" \";\t\n\t\t\t\t}\n\t\t\t\tout<<endl;\n\t\t\t}\n\t\t}else if(m.big==3){\n\t\t\tfor(int i=0;i<m.sizes[0];i++){\n\t\t\t\tfor(int j=0;j<m.sizes[1];j++){\n\t\t\t\t\tfor(int k=0;k<m.sizes[2];k++){\n\t\t\t\t\t\tout<<m.data[i*m.sizes[1]*m.sizes[2]+j*m.sizes[2]+k]<<\" \";\n\t\t\t\t\t}\n\t\t\t\t\tout<<endl;\n\t\t\t\t}\n\t\t\t\tout<<endl;\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int i=0;i<m.sizes[0];i++){\n\t\t\t\tfor(int j=0;j<m.sizes[1];j++){\n\t\t\t\t\tfor(int k=0;k<m.sizes[2];k++){\n\t\t\t\t\t\tfor(int n=0;n<m.sizes[3];n++){\n\t\t\t\t\t\t\tout<<m.data[i*m.sizes[1]*m.sizes[2]*m.sizes[3]+j*m.sizes[2]*m.sizes[3]+k*m.sizes[3]+n]<<\" \";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tout<<endl;\n\t\t\t\t\t}\n\t\t\t\t\tout<<endl;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\treturn out;\n\t}",
            1592646093.302291,
            100,
            "# 答案正确"
        ],
        [
            "10.1 (C++)",
            "王子豪",
            "#include <stdexcept>\nclass MatrixSizesDoNotMatchException{\n \n};\ndouble Matrix::get(int row, int column) const{\n    return this->elements[(row-1)*columns+column-1];\n}\nvoid Matrix::set(int row, int column, double value){\n \n this->elements[(row-1)*columns+column-1]=value;\n}\nMatrix Matrix::operator + (const Matrix & matrix2) const{\n if(this->rows!=matrix2.rows||this->columns!=matrix2.columns) {\n  MatrixSizesDoNotMatchException a;\n  throw a;\n }\n Matrix ret(this->rows,this->columns);\n for(int i=0;i<this->rows*this->columns;i++){\n  ret.elements[i]=this->elements[i]+matrix2.elements[i];\n }\n return ret;\n}",
            1593654404.9556854,
            100,
            "# 答案正确"
        ],
        [
            "10.2 (C++)",
            "王子豪",
            "catch(out_of_range &ex){\n\tcout<<\"caught: out_of_range\"<<endl;\n}",
            1593656453.8262258,
            100,
            "# 答案正确"
        ],
        [
            "15.1 (C++)",
            "王子豪",
            "\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\nclass Table{\n \n public:\n  vector<string> headers;\n vector<vector<string> > rows;\n \n\t\n void addCol(string str){\n  headers.push_back(str);\n }\n\t\n    string json() const{\n  string newstring;\n  newstring = \"{\\n\\theaders: [\";\n   for(int i = 0; i < headers.size(); i ++){\n    newstring = newstring+\"'\"+headers[i]+\"'\"+\",\";\n   }\n   newstring += \"],\\n\\trows: [\\n\";\n   for(int i= 0; i < rows.size(); i++){\n    newstring =newstring+\"\\t\\t[\";\n    for(int j = 0; j < rows[i].size(); j++){\n     newstring =newstring+\"'\"+ rows[i][j]+\"',\";\n    }\n    newstring =newstring+\"],\\n\";\n   }\n   newstring += \"\\t],\\n}\";\n  return  newstring;\n } \n vector<string> & operator [] (int i){\n  if(i < rows.size() )return rows[i];\n  if(i >= rows.size()){\n   rows.resize(rows.size()+1);\n   return rows[i];\n  }\n }\n\n const vector<string> & operator [] (int i)const{\n  return rows[i];\n }\n \n};",
            1594265866.4021137,
            100,
            "# 答案正确"
        ],
        [
            "2020-07-09 LAB",
            "王子豪",
            "#include <iostream>\n#include <string>\nusing namespace std;\nclass Integer{\n public:\n static int sum=0; \n int value;\n Integer(){\n  value=0;\n }\n Integer(int x){\n  value=x;\n }\n static void increase_all(int a){\n  sum=a;\n }\n operator int()const {return value;}\n};\n\n\nostream & operator << (ostream & out, Integer & m){\n out<<m.value+Integer::sum;\n m.value=m.value+Integer::sum;\n return out;\n} \nistream & operator >>(istream & in, Integer & m){\nint x;\n in>>x;\n m.value=x;\n return in;\n}\n",
            1594264818.3518534,
            100,
            "In file included from main.cpp:1:0:\nsource.cpp:6:17: error: ISO C++ forbids in-class initialization of non-const static member ‘Integer::sum’\n  static int sum=0; \n                 ^\n"
        ],
        [
            "A.1 (C++)",
            "王子豪",
            "private:\n\tNode<E> * get_node(int index) const {\n\t\tif (index < 0 || index >= _size) \n\t\t\tthrow NotSuchElementException();\n\t\tif (index < _size ) {\n\t\t\tNode<E> * node = head;\n\t\t\tNode<E>* prev=NULL;\n\t\t\tfor(int i=0;i<index;i++){\n\t\t\t\tNode<E>* now=node;\n\t\t\t\tnode = node->next_node(prev);\n\t\t\t\tprev=now;\n\t\t\t} \n\t\t\treturn node;\n\t\t}\n\t\t\n\t}\n\npublic:\n\tE & get(int index) const {\n\t\tNode<E> * node = get_node(index);\n\t\treturn node->element;\n\t}\n\tvoid set(int index, const E & e) {\n\t\tNode<E> * node = get_node(index);\n\t\tnode->element = e;\n\t}\n\n\tE & getFirst() const {\n\t\treturn get(0);\n\t}\n\n\tE & getLast() const {\n\t\treturn get(_size - 1);\n\t}\n\n\tvoid remove (int index) {\n\t\tNode<E> * node = get_node(index);\n\t\tNode<E> * prev_node = get_node(index-1);\n\t\tNode<E> * next_node = get_node(index+1);\n\t\tif (prev_node != 0)prev_node->update_next_node(node,  next_node);\n\t\tif (next_node != 0) next_node->update_prev_node(node, prev_node);\n\t\tif (prev_node == 0) head = next_node;\n\t\tif (next_node == 0) tail = prev_node;\n\t\tdelete node;\n\t\t-- _size;\n\t}\n\n\tvoid removeFirst () {\n\t\tremove(0);\n\t}\n\n\tvoid removeLast () {\n\t\tremove(_size-1);\n\t}\n\n\tvoid add(int index, const E & e) {\n\t\tif (index < 0 || index > _size) \n\t\t\tthrow NotSuchElementException();\n\t\tNode<E> * node = new Node<E>();\n\t\tnode->element = e;\n\t\tNode<E> * next_node = (index == _size ? 0 : get_node(index));\n\t\tNode<E> * prev_node = (next_node == 0 ? tail :get_node(index-1) );\n\t\tnode->update_next_node(0, next_node);\n\t\tnode->update_prev_node(0, prev_node);\n\t\tif (prev_node != 0) prev_node->update_next_node(next_node,node  );\n\t\tif (next_node != 0) next_node->update_prev_node(prev_node,node );\n\t\tif (prev_node == 0) head = node;\n\t\tif (next_node == 0) tail = node;\n\t\t++ _size;\n\t}\n\n\tvoid addFirst (const E & e) {\n\t\tadd(0, e);\n\t}\n\n\tvoid addLast (const E & e) {\n\t\tadd(_size-1, e);\n\t}\n\n\t// copy and clear\n\n\tvoid clear() {\n\t\twhile (_size > 0) removeFirst();\n\t}\n\n\tvoid addAll(const LinkedList & list, int index=-1) {\n\t\tif (index == -1) index = _size;\n\t\tI(i, list._size) {\n\t\t\tNode<E> * node = list.get_node(i);\n\t\t\tadd(index + i, node->element);\n\t\t}\n\t}\n\n\tLinkedList(const LinkedList & list) : _size(0), head(0), tail(0) {\n\t\taddAll(list);\n\t}\n\n\tLinkedList & operator = (const LinkedList & list) {\n\t\tclear();\n\t\taddAll(list);\n\t\treturn *this;\n\t}\n\n\t~LinkedList() {\n\t\tclear();\n\t}\n\n\tint indexOf(const E & e) const {\n\t\tNode<E> * node = head;\n\t\tNode<E>* prev=NULL;\n\t\t\tfor(int i=0;i<_size;i++){\n\t\t\t\tNode<E>* now=node;\n\t\t\t\tif (node->element == e) return i;\n\t\t\t\tnode = node->next_node(prev);\n\t\t\t\tprev=now;\n\t\t\t} \n\t\treturn -1;\n\t}\n\n\tint lastIndexOf(const E & e) const {\n\t\tNode<E> * node = tail;\n\t\tI(i, _size) {\n\t\t\tif (node->element == e) return i;\n\t\t\tnode = node->prev_node;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tbool contains(const E & e) const {\n\t\treturn indexOf(e) >= 0;\n\t}\n\n\tvoid removeFirstOccurrence(const E & e) {\n\t\tint index = indexOf(e);\n\t\tif (index == -1)\n\t\t\tthrow NotSuchElementException();\n\t\tremove(index);\n\t}\n\n\tvoid removeLastOccurrence(const E & e) {\n\t\tint index = lastIndexOf(e);\n\t\tif (index == -1)\n\t\t\tthrow NotSuchElementException();\n\t\tremove(index);\n\t}\n",
            1594867281.718836,
            0,
            "terminate called after throwing an instance of 'NotSuchElementException'\nAborted (core dumped)\n"
        ],
        [
            "A.2 (C++)",
            "王子豪",
            "template <typename E>\nvoid LinkedList<E>::removeAll(const E & e){\n\twhile(contains(e)){\n\t\tremoveFirstOccurrence(e);\n\t}\n}\n",
            1594865889.0975146,
            100,
            "# 答案正确"
        ],
        [
            "A.5 (C++)",
            "王子豪",
            "#include <vector>\n#include <iostream>\n#include <string>\n#define I(i,n) for (size_t i = 0; i < n; ++ i)\nusing namespace std;\nclass NoSuchKeyException {};\nsize_t circular_shift(size_t bits, int shift_bits) {\n\tconst int num_bits = 8 * sizeof(size_t);\n\tshift_bits = shift_bits % num_bits;\n\treturn bits << shift_bits | bits >> (num_bits - shift_bits);\n}\n\nsize_t hash_function(const int & key) {\n\tsize_t code = 0;\n\t\n\tI(i, key)\n\t\tcode ^= circular_shift(key, i * 5);\n\treturn code;\n}\ntemplate <typename E> \nclass HT{\n\tclass Tuple\n\t{\n\tpublic:\n\t\tint key;\n\t\tE val;\n\t\tbool in_use;\n\n\t\tTuple() : in_use(false) {}\n\t};\n\tvector<Tuple> tuples;\n\tsize_t _size;\n\tsize_t canonical_index(const int & key) const {\n\t\tsize_t hash_code = hash_function(key); // needs hash_function(K)\n\t\treturn hash_code % tuples.size();\n\t}\n\tsize_t indexOfKey(const int & key) const {\n\t\tsize_t index = canonical_index(key);\n\t\twhile (true) { // will enter a dead loop if there is not empty tuple\n\t\t\tif (! tuples[index].in_use) return index;\n\t\t\tif (tuples[index].key == key) return index;\n\t\t\tindex = (index + 1) % tuples.size();\n\t\t}\n\t}\n\tpublic:\n\tHT() : _size(0) {\n\t\ttuples.resize(2);\n\t}\n\tbool containsKey(const int & key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\treturn tuples[index].in_use;\n\t}\n\n\tconst E & operator [] (const int & key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples[index].val;\n\t}\n\n\tE & operator [] (const int & key) {\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples[index].val;\n\t}\n\tvoid put(const int & key, const E & val) {\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].key = key;\n\t\ttuples[index].val = val;\n\t\tif (tuples[index].in_use) return;\n\t\ttuples[index].in_use = true;\n\t\t++ _size;\n\t\t// make sure empty > size / 2\n\t\tif (2 * _size > tuples.size())\n\t\t\t_double_tuples();\n\t}\n\t\tvoid _double_tuples() {\n\t\tvector<Tuple> non_empty_tuples;\n\t\tI(i, tuples.size())\n\t\t\tif (tuples[i].in_use)\n\t\t\t\tnon_empty_tuples.push_back(tuples[i]);\n\t\tclear();\n\t\ttuples.resize(tuples.size() * 2);\n\t\tI(i, non_empty_tuples.size())\n\t\t\tput(non_empty_tuples[i].key, non_empty_tuples[i].val);\n\t}\n\tstatic bool _between(size_t hole, size_t canonical, size_t tuple_index) {\n\t\tif (hole < tuple_index)\n\t\t\treturn canonical > hole && canonical <= tuple_index;\n\t\telse\n\t\t\treturn canonical > hole || canonical <= tuple_index;\n\t}\n\n\tvoid remove(const int & key) { \n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\ttuples[index].in_use = false;\n\t\t-- _size;\n\t\t// if there is a hole between a tuple and its canonical position\n\t\t// move the tuple to the hole\n\t\tsize_t hole = index;\n\t\tsize_t tuple_index = hole;\n\t\twhile (true) {\n\t\t\ttuple_index = (tuple_index + 1) % tuples.size();\n\t\t\tif (! tuples[tuple_index].in_use) return;\n\t\t\tsize_t canonical = canonical_index(tuples[tuple_index].key);\n\t\t\tif (_between(hole, canonical, tuple_index)) continue;\n\t\t\ttuples[hole] = tuples[tuple_index];\n\t\t\thole = tuple_index;\n\t\t\ttuples[hole].in_use = false;\n\t\t}\n\t}\n\n\tsize_t size() const { return _size; }\n    void clear() {\n\t\tI(i, tuples.size())\n\t\t\ttuples[i].in_use = false;\n\t\t_size = 0;\n\t}\n\ttemplate <typename K2>\n\tfriend ostream & operator << (ostream & out, const HT<K2> & dict);\n\n\ttemplate <typename K2>\n\tfriend istream & operator >> (istream & in, HT<K2> & dict);\n   \tvoid _inspect() const {\n\t\tI(i, tuples.size())\n\t\t\tif (tuples[i].in_use)\n\t\t\t\tcout << \"#\" << i << \" C\" << canonical_index(tuples[i].key) \n\t\t\t\t\t<< \" \" << tuples[i].key << \" \" << tuples[i].val << endl;\n\t}\n\tvector <int> getKeys(){\n\t\tvector<int>m;\n\t\tfor(int i=0;i<tuples.size();i++){\n\t\t\tif(tuples[i].in_use!=0) m.push_back(tuples[i].key);\n\t\t}\n\t\treturn m;\n\t}\n};\ntemplate <typename E>\nostream & operator << (ostream & out, const HT<E> & dict) {\n\tout << dict.size() << endl;\n\tI(i, dict.tuples.size())\n\t\tif (dict.tuples[i].in_use)\n\t\t\tout << dict.tuples[i].key << \"\\t\" << dict.tuples[i].val << endl;\n\treturn out;\n}\n\ntemplate <typename E>\nistream & operator >> (istream & in, HT<E> & dict) {\n\tdict.clear();\n\tsize_t size;\n\tin >> size;\n\tI(i, size) {\n\t\tint key;\n\t\tE val;\n\t\tin >> key >> val;\n\t\tdict.put(key, val);\n\t}\n\treturn in;\n}",
            1595474859.1691267,
            0,
            "main.cpp: In function ‘int main()’:\nmain.cpp:8:5: error: missing template arguments before ‘map’\n  HT map;\n     ^\nmain.cpp:13:2: error: ‘map’ was not declared in this scope\n  map[key1] = value1;\n  ^\n"
        ],
        [
            "A.3 (C++)",
            "王子豪",
            "#include <vector>\n#include <iostream>\n#include <string>\n#define I(i,n) for (size_t i = 0; i < n; ++ i)\nusing namespace std;\nclass NoSuchKeyException {};\nsize_t circular_shift(size_t bits, int shift_bits) {\n\tconst int num_bits = 8 * sizeof(size_t);\n\tshift_bits = shift_bits % num_bits;\n\treturn bits << shift_bits | bits >> (num_bits - shift_bits);\n}\n\nsize_t hash_function(const int & key) {\n\tsize_t code = 0;\n\t\n\tI(i, key)\n\t\tcode ^= circular_shift(key, i * 5);\n\treturn code;\n}\ntemplate <typename E> \nclass HT{\n\tclass Tuple\n\t{\n\tpublic:\n\t\tint key;\n\t\tE val;\n\t\tbool in_use;\n\n\t\tTuple() : in_use(false) {}\n\t};\n\tvector<Tuple> tuples;\n\tsize_t _size;\n\tsize_t canonical_index(const int & key) const {\n\t\tsize_t hash_code = hash_function(key); // needs hash_function(K)\n\t\treturn hash_code % tuples.size();\n\t}\n\tsize_t indexOfKey(const int & key) const {\n\t\tsize_t index = canonical_index(key);\n\t\twhile (true) { // will enter a dead loop if there is not empty tuple\n\t\t\tif (! tuples[index].in_use) return index;\n\t\t\tif (tuples[index].key == key) return index;\n\t\t\tindex = (index + 1) % tuples.size();\n\t\t}\n\t}\n\tpublic:\n\tHT() : _size(0) {\n\t\ttuples.resize(2);\n\t}\n\tbool containsKey(const int & key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\treturn tuples[index].in_use;\n\t}\n\n\tconst E & operator [] (const int & key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples[index].val;\n\t}\n\n\tE & operator [] (const int & key) {\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples[index].val;\n\t}\n\tvoid put(const int & key, const E & val) {\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].key = key;\n\t\ttuples[index].val = val;\n\t\tif (tuples[index].in_use) return;\n\t\ttuples[index].in_use = true;\n\t\t++ _size;\n\t\t// make sure empty > size / 2\n\t\tif (2 * _size > tuples.size())\n\t\t\t_double_tuples();\n\t}\n\t\tvoid _double_tuples() {\n\t\tvector<Tuple> non_empty_tuples;\n\t\tI(i, tuples.size())\n\t\t\tif (tuples[i].in_use)\n\t\t\t\tnon_empty_tuples.push_back(tuples[i]);\n\t\tclear();\n\t\ttuples.resize(tuples.size() * 2);\n\t\tI(i, non_empty_tuples.size())\n\t\t\tput(non_empty_tuples[i].key, non_empty_tuples[i].val);\n\t}\n\tstatic bool _between(size_t hole, size_t canonical, size_t tuple_index) {\n\t\tif (hole < tuple_index)\n\t\t\treturn canonical > hole && canonical <= tuple_index;\n\t\telse\n\t\t\treturn canonical > hole || canonical <= tuple_index;\n\t}\n\n\tvoid remove(const int & key) { \n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\ttuples[index].in_use = false;\n\t\t-- _size;\n\t\t// if there is a hole between a tuple and its canonical position\n\t\t// move the tuple to the hole\n\t\tsize_t hole = index;\n\t\tsize_t tuple_index = hole;\n\t\twhile (true) {\n\t\t\ttuple_index = (tuple_index + 1) % tuples.size();\n\t\t\tif (! tuples[tuple_index].in_use) return;\n\t\t\tsize_t canonical = canonical_index(tuples[tuple_index].key);\n\t\t\tif (_between(hole, canonical, tuple_index)) continue;\n\t\t\ttuples[hole] = tuples[tuple_index];\n\t\t\thole = tuple_index;\n\t\t\ttuples[hole].in_use = false;\n\t\t}\n\t}\n\n\tsize_t size() const { return _size; }\n    void clear() {\n\t\tI(i, tuples.size())\n\t\t\ttuples[i].in_use = false;\n\t\t_size = 0;\n\t}\n\ttemplate <typename K2>\n\tfriend ostream & operator << (ostream & out, const HT<K2> & dict);\n\n\ttemplate <typename K2>\n\tfriend istream & operator >> (istream & in, HT<K2> & dict);\n   \tvoid _inspect() const {\n\t\tI(i, tuples.size())\n\t\t\tif (tuples[i].in_use)\n\t\t\t\tcout << \"#\" << i << \" C\" << canonical_index(tuples[i].key) \n\t\t\t\t\t<< \" \" << tuples[i].key << \" \" << tuples[i].val << endl;\n\t}\n\tvector <int> getKeys(){\n\t\tvector<int>m;\n\t\tfor(int i=0;i<tuples.size();i++){\n\t\t\tif(tuples[i].in_use!=0) m.push_back(tuples[i].key);\n\t\t}\n\t\treturn m;\n\t}\n};\ntemplate <typename E>\nostream & operator << (ostream & out, const HT<E> & dict) {\n\tout << dict.size() << endl;\n\tI(i, dict.tuples.size())\n\t\tif (dict.tuples[i].in_use)\n\t\t\tout << dict.tuples[i].key << \"\\t\" << dict.tuples[i].val << endl;\n\treturn out;\n}\n\ntemplate <typename E>\nistream & operator >> (istream & in, HT<E> & dict) {\n\tdict.clear();\n\tsize_t size;\n\tin >> size;\n\tI(i, size) {\n\t\tint key;\n\t\tE val;\n\t\tin >> key >> val;\n\t\tdict.put(key, val);\n\t}\n\treturn in;\n}",
            1595474998.1821864,
            100,
            "# 答案正确"
        ]
    ],
    "table_name": "答案"
}