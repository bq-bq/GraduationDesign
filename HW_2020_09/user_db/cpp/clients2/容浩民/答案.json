{
    "__update_time__": 1595471317.234482,
    "field_names": [
        "题目名",
        "用户名",
        "答案",
        "提交时间",
        "分数",
        "评语"
    ],
    "field_types": [
        "text",
        "text",
        "text",
        "time",
        "number",
        "text"
    ],
    "foreign_keys": {},
    "primary_keys": [],
    "rows": [
        [
            "测试1",
            "容浩民",
            "#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\ntypedef long long ll;\nconst int N = 2e5 + 5;\n#define INF 0x3f3f3f3f\n\n\nstring s;\nint main(){\n    getline(cin, s);\n    stringstream ss(s) ;\n    string a[5];\n    for(int i = 1;i <= 3;i++){\n        ss >> a[i];\n    }\n    for(int i = 3;i >= 1;i--){\n        cout << a[i] << ' ';\n    }\n    cout << endl;\n}\n\n    \n    ",
            1587517009.0,
            100,
            "# 答案正确"
        ],
        [
            "测试2",
            "容浩民",
            "#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\ntypedef long long ll;\nconst int N = 2e5 + 5;\n#define INF 0x3f3f3f3f\n\n\nbool cmp(string a, string b){\n    int len = a.length();\n    for(int i = 0;i < len;i++){\n        if(a[i] < b[i]) return true;\n        else if(a[i] == b[i]) continue;\n        else return false;\n    }\n    return true;\n}\n\nvoid my_sort(string a[]){\n    for(int i = 1;i <= 10;i++){\n        for(int j = 1;j < 10;j++){\n            if(!cmp(a[j], a[j + 1])){\n                string temp = a[j];\n                a[j] = a[j + 1];\n                a[j + 1] = temp;\n            }\n        }\n    }\n}\n\nstring s;\nint main(){\n    getline(cin, s);\n    stringstream ss(s) ;\n    string a[15];\n    for(int i = 1;i <= 10;i++){\n        ss >> a[i];\n    }\n    my_sort(a);\n    for(int i = 1;i <= 10;i++){\n        cout << a[i] << ' ';\n    }\n    cout << endl;\n}\n\n    \n    ",
            1587608605.4223464,
            100,
            "# 答案正确"
        ],
        [
            "1.1 (C++)",
            "容浩民",
            "class Matrix5x5 {\npublic:\n    double matrix[10][10];\n    Matrix5x5();\n    double get(int row, int col);\n    void set(int row, int col, double val);\n    \n};\n\nMatrix5x5 operator + (Matrix5x5 & m1, Matrix5x5 & m2);\n\nMatrix5x5::Matrix5x5(){\n    for(int i = 0;i < 5;i++){\n        for(int j = 0;j < 5;j++){\n            matrix[i][j] = 0;\n        }\n    }\n}\n\ndouble Matrix5x5::get(int row, int col){\n    return matrix[row][col];\n}\n\nvoid Matrix5x5::set(int row, int col, double val){\n    matrix[row][col] = val;\n}\n\nMatrix5x5 operator + (Matrix5x5 & m1, Matrix5x5 & m2){\n    Matrix5x5  m3 ;\n    for(int i = 0;i < 5;i++){\n        for(int j = 0;j < 5;j++){\n            m3.matrix[i][j] = m1.matrix[i][j] + m2.matrix[i][j];\n        }\n    }\n    return m3;\n}",
            1587696870.7594023,
            100,
            "# 答案正确"
        ],
        [
            "1.2 (C++)",
            "容浩民",
            "#include <cstring>\nclass School{\npublic:\n    char name[10];\n    int age;\n    School();\n    void setName(char name[]);\n    void setAge(int year);\n    void operator ++();\n};\nSchool::School(){\n    strcpy(this->name, \"NO_NAME\");\n    this->age = 0;\n}\n\nvoid School:: setName(char name[]){\n    strcpy(this->name, name);\n}\n\nvoid School::setAge(int year){\n    this->age = year;\n}\n\nvoid School:: operator ++(){\n    this->age++;\n}",
            1588214359.2914476,
            100,
            "# 答案正确"
        ],
        [
            "2.1 (C++)",
            "容浩民",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix{\nprivate:\n    int rows;\n    int columns;\n    double ** values;\npublic:\n    Matrix(int rows, int columns){\n        this->rows = rows;\n        this->columns = columns;\n        values = new double *[rows];\n        for(int i = 0;i < rows;i++){\n            values[i] = new double[columns];\n        }\n\n        for(int i = 0;i < rows; i++){\n            for(int j = 0;j < columns;j++){\n                values[i][j] = 0;\n            }\n        }\n    }\n\n    ~Matrix(){\n        for(int i = 0;i < rows;i++){\n            delete [] values[i];\n        }\n        delete [] values;\n    }\n\n    void print(){\n        for(int i = 0;i < rows; i++){\n            for(int j = 0;j < columns; j++){\n                cout << \"    \"<<values[i][j] ;\n            }\n            cout << endl;\n        }\n    }\n};",
            1588832210.5212212,
            100,
            "# 答案正确"
        ],
        [
            "2.2 (C++)",
            "容浩民",
            "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nclass Matrix{\nprivate:\n    int rows;\n    int columns;\n    double ** values;\npublic:\n    Matrix(int rows, int columns, double value[]){\n        this->rows = rows;\n        this->columns = columns;\n        values = new double *[rows];\n        int cnt = 0;\n        for(int i = 0;i < rows;i++){\n            values[i] = new double[columns];\n        }\n\n        for(int i = 0;i < rows; i++){\n            for(int j = 0;j < columns;j++){\n                values[i][j] = value[cnt++];\n            }\n        }\n    }\n\n    ~Matrix(){\n        for(int i = 0;i < rows;i++){\n            delete [] values[i];\n        }\n        delete [] values;\n    }\n\n    void print(){\n        for(int i = 0;i < rows; i++){\n            for(int j = 0;j < columns; j++){\n                cout <<setw(5) << values[i][j] ;\n            }\n            cout << endl;\n        }\n    }\n};",
            1588832541.1571147,
            100,
            "# 答案正确"
        ],
        [
            "2.3 (C++)",
            "容浩民",
            "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nclass Matrix{\nprivate:\n    int rows;\n    int columns;\n    double ** values;\npublic:\n    Matrix(int rows, int columns, double value[]){\n        this->rows = rows;\n        this->columns = columns;\n        values = new double *[rows];\n        int cnt = 0;\n        for(int i = 0;i < rows;i++){\n            values[i] = new double[columns];\n        }\n\n        for(int i = 0;i < rows; i++){\n            for(int j = 0;j < columns;j++){\n                values[i][j] = value[cnt++];\n            }\n        }\n    }\n\n    Matrix(const Matrix & m2){\n        this->rows = m2.rows;\n        this->columns = m2.columns;\n        values = new double *[rows];\n        for(int i = 0;i < rows;i++){\n            values[i] = new double[columns];\n        }\n\n        for(int i = 0;i < rows; i++){\n            for(int j = 0;j < columns;j++){\n                values[i][j] = m2.values[i][j];\n            }\n        }\n    }\n\n    ~Matrix(){\n        for(int i = 0;i < rows;i++){\n            delete [] values[i];\n        }\n        delete [] values;\n    }\n\n    void print(){\n        for(int i = 0;i < rows; i++){\n            for(int j = 0;j < columns; j++){\n                cout << \"    \" << values[i][j] ;\n            }\n            cout << endl;\n        }\n    }\n};",
            1588832703.247383,
            100,
            "# 答案正确"
        ],
        [
            "2.5 (C++)",
            "容浩民",
            "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nclass Matrix{\nprivate:\n    int rows;\n    int columns;\n    double ** values;\npublic:\n    Matrix(int rows, int columns){\n        this->rows = rows;\n        this->columns = columns;\n        values = new double *[rows];\n        for(int i = 0;i < rows;i++){\n            values[i] = new double[columns];\n        }\n\n        for(int i = 0;i < rows; i++){\n            for(int j = 0;j < columns;j++){\n                values[i][j] = 0;\n            }\n        }\n    }\n\n    Matrix(int rows, int columns, double value[]){\n        this->rows = rows;\n        this->columns = columns;\n        values = new double *[rows];\n        int cnt = 0;\n        for(int i = 0;i < rows;i++){\n            values[i] = new double[columns];\n        }\n\n        for(int i = 0;i < rows; i++){\n            for(int j = 0;j < columns;j++){\n                values[i][j] = value[cnt++];\n            }\n        }\n    }\n\n    Matrix(const Matrix & m2){\n        this->rows = m2.rows;\n        this->columns = m2.columns;\n        values = new double *[rows];\n        for(int i = 0;i < rows;i++){\n            values[i] = new double[columns];\n        }\n\n        for(int i = 0;i < rows; i++){\n            for(int j = 0;j < columns;j++){\n                values[i][j] = m2.values[i][j];\n            }\n        }\n    }\n\n    ~Matrix(){\n        for(int i = 0;i < rows;i++){\n            delete [] values[i];\n        }\n        delete [] values;\n    }\n\n    Matrix getRow(int rows){\n        Matrix m1(1, this->columns);\n        for(int i = 0;i < this->columns;i++){\n            m1.values[0][i] = this->values[rows - 1][i];\n        }\n        return m1;\n    }\n\n    Matrix getColumn(int columns){\n        Matrix m1(this->rows, 1);\n        for(int i = 0;i < this->rows;i++){\n            m1.values[i][0] = this->values[i][columns - 1];\n        }\n        return m1;\n    }\n\n    void print(){\n        for(int i = 0;i < rows; i++){\n            for(int j = 0;j < columns; j++){\n                cout << \"    \" << values[i][j] ;\n            }\n            cout << endl;\n        }\n    }\n};",
            1588833215.1641095,
            100,
            "# 答案正确"
        ],
        [
            "2.6 (C++)",
            "容浩民",
            "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nclass Matrix{\nprivate:\n    int rows;\n    int columns;\n    double ** values;\npublic:\n    Matrix(int rows, int columns){\n        this->rows = rows;\n        this->columns = columns;\n        values = new double *[rows];\n        for(int i = 0;i < rows;i++){\n            values[i] = new double[columns];\n        }\n\n        for(int i = 0;i < rows; i++){\n            for(int j = 0;j < columns;j++){\n                values[i][j] = 0;\n            }\n        }\n    }\n\n    Matrix(int rows, int columns, double value[]){\n        this->rows = rows;\n        this->columns = columns;\n        values = new double *[rows];\n        int cnt = 0;\n        for(int i = 0;i < rows;i++){\n            values[i] = new double[columns];\n        }\n\n        for(int i = 0;i < rows; i++){\n            for(int j = 0;j < columns;j++){\n                values[i][j] = value[cnt++];\n            }\n        }\n    }\n\n    Matrix(const Matrix & m2){\n        this->rows = m2.rows;\n        this->columns = m2.columns;\n        values = new double *[rows];\n        for(int i = 0;i < rows;i++){\n            values[i] = new double[columns];\n        }\n\n        for(int i = 0;i < rows; i++){\n            for(int j = 0;j < columns;j++){\n                values[i][j] = m2.values[i][j];\n            }\n        }\n    }\n\n    ~Matrix(){\n        for(int i = 0;i < rows;i++){\n            delete [] values[i];\n        }\n        delete [] values;\n    }\n\n    Matrix getRow(int rows){\n        Matrix m1(1, this->columns);\n        for(int i = 0;i < this->columns;i++){\n            m1.values[0][i] = this->values[rows - 1][i];\n        }\n        return m1;\n    }\n\n    Matrix getColumn(int columns){\n        Matrix m1(this->rows, 1);\n        for(int i = 0;i < this->rows;i++){\n            m1.values[i][0] = this->values[i][columns - 1];\n        }\n        return m1;\n    }\n\n    Matrix concatenateRows(const Matrix & m2){\n        Matrix m1(rows + m2.rows, columns);\n        for(int i = 0;i < m1.rows;i++){\n            for(int j = 0;j < columns;j++){\n                if(i < rows){\n                    m1.values[i][j] = this->values[i][j];\n                }\n                else{\n                    m1.values[i][j] = m2.values[i - rows][j];\n                }\n            }\n        }\n        return m1;\n    }\n\n    Matrix concatenateColumns(const Matrix & m2){\n        Matrix m1(rows, columns + m2.columns);\n        for(int i = 0;i < m1.rows;i++){\n            for(int j = 0;j < m1.columns;j++){\n                if(j < columns){\n                    m1.values[i][j] = this->values[i][j];\n                }\n                else{\n                    m1.values[i][j] = m2.values[i][j - columns];\n                }\n            }\n        }\n        return m1;\n    }\n\n    void print(){\n        for(int i = 0;i < rows; i++){\n            for(int j = 0;j < columns; j++){\n                cout << \"    \" << values[i][j] ;\n            }\n            cout << endl;\n        }\n    }\n};",
            1588833655.5386689,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/08",
            "容浩民",
            "#include <iostream>\nusing namespace std;\ndouble & Tensor_get(int dimensions, int sizes[], double data[], int x0, int x1, int x2, int x3){\n        if(dimensions == 1){\n            return data[x0];\n        }else if(dimensions == 2){\n            return data[x0 * sizes[1] + x1];\n        }else if(dimensions == 3){\n            return data[x0 * sizes[1] * sizes[2] + x1 * sizes[2] + x2];\n        }else{\n            return data[x0 * sizes[1]  * sizes[2] * sizes[3] + x1 *  sizes[2]  * sizes[3] + x2 * sizes[3] + x3];\n        }\n    }",
            1588907144.7592657,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/14",
            "容浩民",
            "#include<bits/stdc++.h>\n\nusing namespace std;\nvoid Tensor_print(int dimensions, const int sizes[], const double data[]){\n        cout << \"Tensor of \";\n        for(int i = 1;i <= dimensions;i++){\n            cout << sizes[i - 1];\n            if(i != dimensions){\n                cout << \"x\";\n            }else{\n                cout << endl;\n            }\n        }\n        if(dimensions == 1){\n            for(int i = 0;i < sizes[0];i++){\n                cout << data[i] << endl;\n            }\n        }\n        else if(dimensions == 2){\n            for(int i = 0;i < sizes[0];i++){\n                for(int j = 0;j < sizes[1];j++){\n                    cout << \"    \" << data[i * sizes[0] + j];\n                }\n                cout << endl;\n            }\n        }\n        else if(dimensions == 3){\n            for(int h = 0;h < sizes[0];h++){\n                cout << \"data[\" << h << \"]\" << endl;\n                for(int i = 0;i < sizes[1];i++){\n                    for(int j = 0;j < sizes[2];j++){\n                        cout << \"    \" << data[h * sizes[0] + i * sizes[1] + j];\n                    }\n                    cout << endl;\n                }\n            }\n        }\n        else{\n            for(int m = 0;m < sizes[0];m++){\n                for(int n = 0;n < sizes[1];n++){\n                    cout << \"data[\" << m << \"]\" << \"[\" << n << \"]\" << endl;\n                    for(int i = 0;i < sizes[2];i++){\n                        for(int j = 0;j < sizes[3];j++){\n                            cout << \"    \" << data[m * sizes[0] + n * sizes[1] +  i * sizes[2] + j];\n                        }\n                        cout << endl;\n                    }\n                }\n            }\n        }\n}",
            1589423360.9208927,
            100,
            "# 答案正确"
        ],
        [
            "2.4 (C++)",
            "容浩民",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix{\nprivate:\n    int rows;\n    int columns;\n    double * values;\npublic:\n    Matrix(int rows_, int columns_){\n        this->values = new double[rows_ * columns_];\n        this->rows = rows_;\n        this->columns = columns_;\n        for(int i = 0;i < rows_ * columns_;i++){\n            values[i] = 0;\n        }\n    }\n\n    Matrix(int rows_, int columns_, double values[]){\n        this->values = new double[rows_ * columns_];\n        this->rows = rows_;\n        this->columns = columns_;\n        for(int i = 0;i < rows_ * columns_ ;i++){\n            this->values[i] = values[i];\n        }\n    }\n\n    ~Matrix(){\n        delete [] values;\n    }\n\n    void print(){\n        for(int i = 0;i < rows;i++){\n            for(int j = 0;j < columns; j++){\n                cout << \"    \" << values[i * columns + j];\n            }\n            cout << endl;\n        }\n    }\n\n    void set(int row, int column, double value){\n        values[(row - 1) * columns + column - 1] = value;\n    }\n\n    Matrix & operator = (const Matrix & m1){\n        this->rows = m1.rows;\n        this->columns = m1.columns;\n        if(this->values != 0) delete [] this->values;\n        this->values = new double[m1.rows * m1.columns];\n        for(int i = 0;i < m1.rows * m1.columns;i++){\n            this->values[i] = m1.values[i];\n        }\n        return (*this);\n    }\n};",
            1589516148.1598032,
            100,
            "# 答案正确"
        ],
        [
            "2.7 (C++)",
            "容浩民",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix{\nprivate:\n    int rows;\n    int columns;\n    double * values;\npublic:\n    Matrix(int rows_, int columns_){\n        this->values = new double[rows_ * columns_];\n        this->rows = rows_;\n        this->columns = columns_;\n        for(int i = 0;i < rows_ * columns_;i++){\n            values[i] = 0;\n        }\n    }\n\n    Matrix(int rows_, int columns_, double values[]){\n        this->values = new double[rows_ * columns_];\n        this->rows = rows_;\n        this->columns = columns_;\n        for(int i = 0;i < rows_ * columns_ ;i++){\n            this->values[i] = values[i];\n        }\n    }\n\n    Matrix(const Matrix & m2){\n        this->rows = m2.rows;\n        this->columns = m2.columns;\n        this->values = new double[m2.rows * m2.columns];\n        for(int i = 0;i < rows * columns ;i++){\n            this->values[i] = m2.values[i];\n        }\n    }\n\n    ~Matrix(){\n        delete [] values;\n    }\n\n    void print(){\n        for(int i = 0;i < rows;i++){\n            for(int j = 0;j < columns; j++){\n                cout << \"    \" << values[i * columns + j];\n            }\n            cout << endl;\n        }\n    }\n\n    void set(int row, int column, double value){\n        values[(row - 1) * columns + column - 1] = value;\n    }\n\n    Matrix & operator = (const Matrix & m1){\n        this->rows = m1.rows;\n        this->columns = m1.columns;\n        if(this->values != 0) delete [] this->values;\n        this->values = new double[m1.rows * m1.columns];\n        for(int i = 0;i < m1.rows * m1.columns;i++){\n            this->values[i] = m1.values[i];\n        }\n        return (*this);\n    }\n\n    Matrix reshape(int rows, int columns){\n        Matrix m1(rows, columns);\n        double  *data = new double[rows * columns];\n        int cnt = 0;\n        for(int i = 0;i < this->columns;i++){\n            for(int j = 0;j < this->rows;j++){\n                //cout << this->values[i + j * rows] << endl;\n                data[cnt++] = this->values[i + j * this->columns];\n            }\n        }\n\n        cnt = 0;\n        for(int i = 0;i < columns ;i++){\n            for(int j = 0;j < rows;j++){\n                m1.values[i + j * columns] = data[cnt++];\n            }\n        }\n\n        delete [] data;\n\n        return m1;\n    }\n};",
            1589519131.5363567,
            100,
            "# 答案正确"
        ],
        [
            "2.8 (C++)",
            "容浩民",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix{\nprivate:\n    int rows;\n    int columns;\n    double * values;\npublic:\n    Matrix(int rows_, int columns_){\n        this->values = new double[rows_ * columns_];\n        this->rows = rows_;\n        this->columns = columns_;\n        for(int i = 0;i < rows_ * columns_;i++){\n            values[i] = 0;\n        }\n    }\n\n    Matrix(int rows_, int columns_, double values[]){\n        this->values = new double[rows_ * columns_];\n        this->rows = rows_;\n        this->columns = columns_;\n        for(int i = 0;i < rows_ * columns_ ;i++){\n            this->values[i] = values[i];\n        }\n    }\n\n    Matrix(const Matrix & m2){\n        this->rows = m2.rows;\n        this->columns = m2.columns;\n        this->values = new double[m2.rows * m2.columns];\n        for(int i = 0;i < rows * columns ;i++){\n            this->values[i] = m2.values[i];\n        }\n    }\n\n    ~Matrix(){\n        delete [] values;\n    }\n\n    void print(){\n        for(int i = 0;i < rows;i++){\n            for(int j = 0;j < columns; j++){\n                cout << \"    \" << values[i * columns + j];\n            }\n            cout << endl;\n        }\n    }\n\n    void set(int row, int column, double value){\n        values[(row - 1) * columns + column - 1] = value;\n    }\n\n    Matrix & operator = (const Matrix & m1){\n        this->rows = m1.rows;\n        this->columns = m1.columns;\n        if(this->values != 0) delete [] this->values;\n        this->values = new double[m1.rows * m1.columns];\n        for(int i = 0;i < m1.rows * m1.columns;i++){\n            this->values[i] = m1.values[i];\n        }\n        return (*this);\n    }\n\n    Matrix reshape(int rows, int columns){\n        Matrix m1(rows, columns);\n        double  *data = new double[rows * columns];\n        int cnt = 0;\n        for(int i = 0;i < this->columns;i++){\n            for(int j = 0;j < this->rows;j++){\n                //cout << this->values[i + j * rows] << endl;\n                data[cnt++] = this->values[i + j * this->columns];\n            }\n        }\n\n        cnt = 0;\n        for(int i = 0;i < columns ;i++){\n            for(int j = 0;j < rows;j++){\n                m1.values[i + j * columns] = data[cnt++];\n            }\n        }\n\n        delete [] data;\n\n        return m1;\n    }\n\n    Matrix transpose(){\n        Matrix m1(columns, rows);\n        int cnt = 0;\n        for(int i = 0;i < rows;i++){\n            for(int j = 0;j < columns;j++){\n                m1.values[j * rows + i] = this->values[cnt++];\n            }\n        }\n        return m1;\n    }\n};",
            1589519490.6102295,
            100,
            "# 答案正确"
        ],
        [
            "2.10 (C++)",
            "容浩民",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix{\nprivate:\n    int rows;\n    int columns;\n    double * values;\npublic:\n    Matrix(int rows_, int columns_){\n        this->values = new double[rows_ * columns_];\n        this->rows = rows_;\n        this->columns = columns_;\n        for(int i = 0;i < rows_ * columns_;i++){\n            values[i] = 0;\n        }\n    }\n\n    Matrix(int rows_, int columns_, double values[]){\n        this->values = new double[rows_ * columns_];\n        this->rows = rows_;\n        this->columns = columns_;\n        for(int i = 0;i < rows_ * columns_ ;i++){\n            this->values[i] = values[i];\n        }\n    }\n\n    Matrix(const Matrix & m2){\n        this->rows = m2.rows;\n        this->columns = m2.columns;\n        this->values = new double[m2.rows * m2.columns];\n        for(int i = 0;i < rows * columns ;i++){\n            this->values[i] = m2.values[i];\n        }\n    }\n\n    ~Matrix(){\n        delete [] values;\n    }\n\n    void print(){\n        for(int i = 0;i < rows;i++){\n            for(int j = 0;j < columns; j++){\n                cout << \"    \" << values[i * columns + j];\n            }\n            cout << endl;\n        }\n    }\n\n    void set(int row, int column, double value){\n        values[(row - 1) * columns + column - 1] = value;\n    }\n\n    Matrix & operator = (const Matrix & m1){\n        this->rows = m1.rows;\n        this->columns = m1.columns;\n        if(this->values != 0) delete [] this->values;\n        this->values = new double[m1.rows * m1.columns];\n        for(int i = 0;i < m1.rows * m1.columns;i++){\n            this->values[i] = m1.values[i];\n        }\n        return (*this);\n    }\n\n    Matrix operator * (const Matrix & m2){\n        Matrix m(this->rows, m2.columns);\n        for(int i = 0;i < this->rows;i++){\n            for(int j = 0;j < m2.columns;j++){\n                for(int h = 0;h < this->columns;h++){\n                    m.values[i * m2.columns + j] += this->values[i * this->columns + h] * m2.values[h * m2.columns + j];\n                }\n            }\n        }\n        return m;\n    }\n\n    Matrix operator * (double value){\n        for(int i = 0;i < rows;i++){\n            for(int j = 0;j < columns;j++){\n                this->values[i * columns + j] *= value;\n            }\n        }\n        return (*this);\n    }\n};",
            1589520029.3920603,
            100,
            "# 答案正确"
        ],
        [
            "2.11 (C++)",
            "容浩民",
            "#include <iostream>\nusing namespace std;\n\ntemplate <typename T>\nT max_(T t1, T t2){\n    return t1 > t2 ? t1 : t2;\n}\n\ntemplate <typename T>\nT min_(T t1, T t2){\n    return t1 < t2 ? t1 : t2;\n}\n\nclass Matrix{\nprivate:\n    int rows;\n    int columns;\n    double * values;\npublic:\n    Matrix(int rows_, int columns_){\n        this->values = new double[rows_ * columns_];\n        this->rows = rows_;\n        this->columns = columns_;\n        for(int i = 0;i < rows_ * columns_;i++){\n            values[i] = 0;\n        }\n    }\n\n    Matrix(int rows_, int columns_, double values[]){\n        this->values = new double[rows_ * columns_];\n        this->rows = rows_;\n        this->columns = columns_;\n        for(int i = 0;i < rows_ * columns_ ;i++){\n            this->values[i] = values[i];\n        }\n    }\n\n    Matrix(const Matrix & m2){\n        this->rows = m2.rows;\n        this->columns = m2.columns;\n        this->values = new double[m2.rows * m2.columns];\n        for(int i = 0;i < rows * columns ;i++){\n            this->values[i] = m2.values[i];\n        }\n    }\n\n    ~Matrix(){\n        delete [] values;\n    }\n\n    void print(){\n        for(int i = 0;i < rows;i++){\n            for(int j = 0;j < columns; j++){\n                cout << \"    \" << values[i * columns + j];\n            }\n            cout << endl;\n        }\n    }\n\n    void set(int row, int column, double value){\n        values[(row - 1) * columns + column - 1] = value;\n    }\n\n    Matrix & operator = (const Matrix & m1){\n        this->rows = m1.rows;\n        this->columns = m1.columns;\n        if(this->values != 0) delete [] this->values;\n        this->values = new double[m1.rows * m1.columns];\n        for(int i = 0;i < m1.rows * m1.columns;i++){\n            this->values[i] = m1.values[i];\n        }\n        return (*this);\n    }\n\n    Matrix operator * (const Matrix & m2){\n        Matrix m(this->rows, m2.columns);\n        for(int i = 0;i < this->rows;i++){\n            for(int j = 0;j < m2.columns;j++){\n                for(int h = 0;h < this->columns;h++){\n                    m.values[i * m2.columns + j] += this->values[i * this->columns + h] * m2.values[h * m2.columns + j];\n                }\n            }\n        }\n        return m;\n    }\n\n    Matrix operator * (double value){\n        for(int i = 0;i < rows;i++){\n            for(int j = 0;j < columns;j++){\n                this->values[i * columns + j] *= value;\n            }\n        }\n        return (*this);\n    }\n\n\n    Matrix max() const{\n        if(this->rows != 1){\n            Matrix m1(1, this->columns);\n            int cnt  = 0;\n            for(int i = 0;i < columns;i++){\n                double temp = -1000;\n                for(int j = 0;j < rows;j++){\n                    temp = max_(temp, this->values[i + j * columns]);\n                }\n                m1.values[cnt++] = temp;\n            }\n            return m1;\n        }else{\n            Matrix m1(1,1);\n            double temp = -1000;\n            for(int i = 0;i < columns;i++){\n                temp = max_(temp, this->values[i]);\n            }\n            m1.values[0] = temp;\n            return m1;\n        }\n    }\n\n    Matrix min() const{\n        if(this->rows != 1){\n            Matrix m1(1, this->columns);\n            int cnt  = 0;\n            for(int i = 0;i < columns;i++){\n                double temp = 10000;\n                for(int j = 0;j < rows;j++){\n                    temp = min_(temp, this->values[i + j * columns]);\n                }\n                m1.values[cnt++] = temp;\n            }\n            return m1;\n        }else{\n            Matrix m1(1,1);\n            double temp = 10000;\n            for(int i = 0;i < columns;i++){\n                temp = min_(temp, this->values[i]);\n            }\n            m1.values[0] = temp;\n            return m1;\n        }\n    }\n\n    Matrix sum() const{\n        if(this->rows != 1){\n            Matrix m1(1, this->columns);\n            int cnt  = 0;\n            for(int i = 0;i < columns;i++){\n                double temp = 0;\n                for(int j = 0;j < rows;j++){\n                    temp += this->values[i + j * columns];\n                }\n                m1.values[cnt++] = temp;\n            }\n            return m1;\n        }else{\n            Matrix m1(1,1);\n            double temp = 0;\n            for(int i = 0;i < columns;i++){\n                temp += this->values[i];\n            }\n            m1.values[0] = temp;\n            return m1;\n        }\n    }\n};",
            1589521650.21171,
            100,
            "# 答案正确"
        ],
        [
            "2.12 (C++)",
            "容浩民",
            "#include <iostream>\n#include <cmath>\nusing namespace std;\n\n\n\nclass Matrix{\nprivate:\n    int rows;\n    int columns;\n    double * values;\npublic:\n    Matrix(int rows_, int columns_){\n        this->values = new double[rows_ * columns_];\n        this->rows = rows_;\n        this->columns = columns_;\n        for(int i = 0;i < rows_ * columns_;i++){\n            values[i] = 0;\n        }\n    }\n\n    Matrix(int rows_, int columns_, double values[]){\n        this->values = new double[rows_ * columns_];\n        this->rows = rows_;\n        this->columns = columns_;\n        for(int i = 0;i < rows_ * columns_ ;i++){\n            this->values[i] = values[i];\n        }\n    }\n\n    Matrix(const Matrix & m2){\n        this->rows = m2.rows;\n        this->columns = m2.columns;\n        this->values = new double[m2.rows * m2.columns];\n        for(int i = 0;i < rows * columns ;i++){\n            this->values[i] = m2.values[i];\n        }\n    }\n\n    ~Matrix(){\n        delete [] values;\n    }\n\n    void print(){\n        for(int i = 0;i < rows;i++){\n            for(int j = 0;j < columns; j++){\n                cout << \"    \" << values[i * columns + j];\n            }\n            cout << endl;\n        }\n    }\n\n    void set(int row, int column, double value){\n        values[(row - 1) * columns + column - 1] = value;\n    }\n\n    Matrix & operator = (const Matrix & m1){\n        this->rows = m1.rows;\n        this->columns = m1.columns;\n        if(this->values != 0) delete [] this->values;\n        this->values = new double[m1.rows * m1.columns];\n        for(int i = 0;i < m1.rows * m1.columns;i++){\n            this->values[i] = m1.values[i];\n        }\n        return (*this);\n    }\n\n    Matrix operator * (const Matrix & m2){\n        Matrix m(this->rows, m2.columns);\n        for(int i = 0;i < this->rows;i++){\n            for(int j = 0;j < m2.columns;j++){\n                for(int h = 0;h < this->columns;h++){\n                    m.values[i * m2.columns + j] += this->values[i * this->columns + h] * m2.values[h * m2.columns + j];\n                }\n            }\n        }\n        return m;\n    }\n\n    Matrix operator * (double value){\n        for(int i = 0;i < rows;i++){\n            for(int j = 0;j < columns;j++){\n                this->values[i * columns + j] *= value;\n            }\n        }\n        return (*this);\n    }\n\n    Matrix pow(double exponent){\n        Matrix m1(rows, columns);\n        for(int i = 0;i < rows;i++){\n            for(int j = 0;j < columns;j++){\n                m1.values[i * columns + j] = ::pow(this->values[i * columns + j], exponent);\n            }\n        }\n        return m1;\n    }\n\n    Matrix exp(){\n        Matrix m1(rows, columns);\n        for(int i = 0;i < rows;i++){\n            for(int j = 0;j < columns;j++){\n                m1.values[i * columns + j] = ::exp(this->values[i * columns + j]);\n            }\n        }\n        return m1;\n    }\n\n    Matrix log(){\n        Matrix m1(rows, columns);\n        for(int i = 0;i < rows;i++){\n            for(int j = 0;j < columns;j++){\n                m1.values[i * columns + j] = ::log(this->values[i * columns + j]);\n            }\n        }\n        return m1;\n    }\n\n    Matrix abs(){\n        Matrix m1(rows, columns);\n        for(int i = 0;i < rows;i++){\n            for(int j = 0;j < columns;j++){\n                m1.values[i * columns + j] = ::abs(this->values[i * columns + j]);\n            }\n        }\n        return m1;\n    }\n    \n};",
            1589522614.2747529,
            100,
            "# 答案正确"
        ],
        [
            "2.9 (C++)",
            "容浩民",
            "#include <iostream>\n\nusing namespace std;\n\n\nclass Matrix{\nprivate:\n    int rows;\n    int columns;\n    double * values;\npublic:\n    Matrix(int rows_, int columns_){\n        this->values = new double[rows_ * columns_];\n        this->rows = rows_;\n        this->columns = columns_;\n        for(int i = 0;i < rows_ * columns_;i++){\n            values[i] = 0;\n        }\n    }\n\n    Matrix(int rows_, int columns_, double values[]){\n        this->values = new double[rows_ * columns_];\n        this->rows = rows_;\n        this->columns = columns_;\n        for(int i = 0;i < rows_ * columns_ ;i++){\n            this->values[i] = values[i];\n        }\n    }\n\n    Matrix(const Matrix & m2){\n        this->rows = m2.rows;\n        this->columns = m2.columns;\n        this->values = new double[m2.rows * m2.columns];\n        for(int i = 0;i < rows * columns ;i++){\n            this->values[i] = m2.values[i];\n        }\n    }\n\n    ~Matrix(){\n        delete [] values;\n    }\n\n    void print(){\n        for(int i = 0;i < rows;i++){\n            for(int j = 0;j < columns; j++){\n                cout << \"    \" << values[i * columns + j];\n            }\n            cout << endl;\n        }\n    }\n\n    void set(int row, int column, double value){\n        values[(row - 1) * columns + column - 1] = value;\n    }\n\n    Matrix & operator = (const Matrix & m1){\n        this->rows = m1.rows;\n        this->columns = m1.columns;\n        if(this->values != 0) delete [] this->values;\n        this->values = new double[m1.rows * m1.columns];\n        for(int i = 0;i < m1.rows * m1.columns;i++){\n            this->values[i] = m1.values[i];\n        }\n        return (*this);\n    }\n\n    Matrix  operator + (const Matrix & m2) const{\n        Matrix m(this->rows, this->columns);\n        for(int i = 0;i < rows;i++){\n            for(int j = 0;j < columns;j++){\n                m.values[i * columns + j] = this->values[i * columns + j] + m2.values[i * columns + j];\n            }\n        }\n        return m;\n    }\n\n    Matrix  operator + (double value) const{\n        Matrix m(this->rows, this->columns);\n        for(int i = 0;i < rows;i++){\n            for(int j = 0;j < columns;j++){\n                m.values[i * columns + j] = this->values[i * columns + j] + value;\n            }\n        }\n        return m;\n    }\n\n    Matrix  operator -(const Matrix & m2) const{\n        Matrix m(this->rows, this->columns);\n        for(int i = 0;i < rows;i++){\n            for(int j = 0;j < columns;j++){\n                m.values[i * columns + j] = this->values[i * columns + j] - m2.values[i * columns + j];\n            }\n        }\n        return m;\n    }\n\n    Matrix  operator - (double value) const{\n        Matrix m(this->rows, this->columns);\n        for(int i = 0;i < rows;i++){\n            for(int j = 0;j < columns;j++){\n                m.values[i * columns + j] = this->values[i * columns + j] - value;\n            }\n        }\n        return m;\n    }\n};",
            1590027080.9675796,
            100,
            "# 答案正确"
        ],
        [
            "6.1 (C++)",
            "容浩民",
            "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <string.h>\nusing namespace std;\n\ntemplate <typename T>\nclass Matrix{\nprivate:\n    T * values;\n    int rows;\n    int columns;\npublic:\n    Matrix(int rows,int columns){\n        this->rows = rows;\n        this->columns = columns;\n        this->values = new T [rows * columns];\n        memset(values, 0, sizeof(T) * rows * columns);\n    }\n\n    Matrix(int rows, int columns, const T values[]){\n        this->rows = rows;\n        this->columns = columns;\n        this->values = new T [rows * columns];\n        for(int i = 0;i < rows * columns ;i++){\n            this->values[i] = values[i];\n        }\n    }\n\n    Matrix(Matrix & m2){\n        this->rows = m2.rows;\n        this->columns = m2.columns;\n        this->values = new T [rows * columns];\n        for(int i = 0;i < rows * columns ;i++){\n            this->values[i] = m2.values[i];\n        }\n    }\n\n    ~Matrix(){\n        delete [] values;\n    }\n\n    T & get(int row, int column){\n        return this->values[(row - 1) * this->rows + column - 1 ];\n    }\n\n    Matrix & operator = (Matrix & m2){\n        this->rows = m2.rows;\n        this->columns = m2.columns;\n        if(this->values != 0){\n            delete [] values;\n            this->values = new T [rows * columns];\n        } \n        for(int i = 0;i < m2.rows * m2.columns ;i++){\n            this->values[i] = m2.values[i];\n        }\n        return (*this);\n    }\n\n    void print(){\n        for(int i = 0;i < rows;i++){\n            for(int j = 0;j < columns;j++){\n                cout << \"    \" << values[i * rows + j] ;\n            }\n            cout << endl;\n        }\n    }\n};",
            1590123718.345037,
            100,
            "# 答案正确"
        ],
        [
            "6.3 (C++)",
            "容浩民",
            "#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate <typename T>\nclass Matrix{\nprivate:\n    int rows;\n    int columns;\n    vector<T> values;\npublic:\n    Matrix(int rows, int columns){\n        this->rows = rows;\n        this->columns = columns;\n        for(int i = 0;i < rows * columns;i++){\n            values.push_back(0);\n        }\n    }\n\n    Matrix(int rows,int columns, vector<T> values){\n        this->rows = rows;\n        this->columns = columns;\n        for(int i = 0;i < rows * columns;i++){\n            this->values.push_back(values[i]);\n        }\n    }\n\n    T & get(int row, int column){\n        return this->values[(row - 1) * rows + column - 1];\n    }\n\n    Matrix getColumn(int col){\n        Matrix m(this->rows, 1);\n        for(int i = 0;i < this->rows;i++){\n            m.values[i] = (this->values[i * this->columns + col - 1]);\n        }\n        return m;\n    }\n\n    Matrix getRow(int row){\n        Matrix m(1, this->columns);\n        for(int i = 0;i < this->columns;i++){\n            m.values[i] = (this->values[(row - 1) * this->columns + i]);\n        }\n        return m;\n    }\n\n    Matrix concatenateRows(Matrix & m2){\n        Matrix m(this->rows + m2.rows, this->columns);\n        for(int i = 0;i < m.rows;i++){\n            for(int j = 0;j < this->columns;j++){\n                if(i < this->rows){\n                    m.values[i * columns + j] = this->values[i * columns + j];\n                }else{\n                    m.values[i * columns + j] = m2.values[(i - this->rows) * columns + j];\n                }\n            }\n        }\n        return m;\n    }\n\n    Matrix concatenateColumns(Matrix & m2){\n        Matrix m(this->rows , this->columns + m2.columns);\n        for(int i = 0;i < m.rows;i++){\n            for(int j = 0;j < m.columns;j++){\n                if(j < this->columns){\n                    m.values[i * m.columns + j] = this->values[i * this->columns + j];\n                }else{\n                    m.values[i * m.columns + j] = m2.values[i * m2.columns + j - this->columns];\n                }\n            }\n        }\n        return m;\n    }\n\n    Matrix reshape(int row, int column){\n        Matrix m(row, column);\n        T * temp = new T [row * column];\n        int cnt = 0;\n        for(int j = 0;j < columns;j++){\n            for(int i = 0;i < rows; i++){\n                temp[cnt++] = this->values[i * columns + j];\n            }\n        }\n        cnt = 0;\n        for(int j = 0;j < column;j++){\n            for(int i = 0;i < row; i++){\n                m.values[i * column + j] = temp[cnt++];\n            }\n        }\n        delete [] temp;\n        return m;\n    }\n\n    Matrix transpose(){\n        Matrix m(this->columns, this->rows);\n        int cnt = 0;\n        for(int j = 0;j < m.columns;j++){\n            for(int i = 0;i < m.rows;i++){\n                m.values[i * m.columns + j] = this->values[cnt++];\n            }\n        }\n        return m;\n    }\n\n    Matrix operator + (Matrix & m2){\n        Matrix m(this->rows, this-> columns);\n        for(int i = 0;i < rows * columns;i++){\n            m.values[i] = this->values[i] + m2.values[i];\n        }\n        return m;\n    }\n\n    Matrix operator + (T values){\n        Matrix m(this->rows, this-> columns);\n        for(int i = 0;i < rows * columns;i++){\n            m.values[i] = this->values[i] + values;\n        }\n        return m;\n    }\n\n    Matrix operator - (Matrix & m2){\n        Matrix m(this->rows, this-> columns);\n        for(int i = 0;i < rows * columns;i++){\n            m.values[i] = this->values[i] - m2.values[i];\n        }\n        return m;\n    }\n\n    Matrix operator - (T values){\n        Matrix m(this->rows, this-> columns);\n        for(int i = 0;i < rows * columns;i++){\n            m.values[i] = this->values[i] - values;\n        }\n        return m;\n    }\n\n    Matrix operator * (T values){\n        Matrix m(this->rows, this-> columns);\n        for(int i = 0;i < rows * columns;i++){\n            m.values[i] = this->values[i] * values;\n        }\n        return m;\n    }\n\n    Matrix operator * (Matrix & m2){\n        Matrix m(this->rows, m2.columns);\n        for(int i = 0;i < this->rows;i++){\n            for(int j = 0;j < m2.columns;j++){\n                for(int k = 0;k < this->columns;k++){\n                    m.values[i * m2.columns + j] += this->values[i * this->columns + k] * m2.values[k * m2.columns + j];\n                }\n            }\n        }\n        return m;\n    }\n\n\n    Matrix max(){\n        if(this->columns == 1){\n            Matrix m(1, 1);\n            T temp = this->values[0];\n            for(int i = 0;i < this->rows;i++){\n                if(this->values[i] > temp){\n                    temp = this->values[i];\n                }\n            }\n            m.values[0] = temp;\n            return m;\n        }\n        else{\n            T t1 = 0;\n            int mc = 0;\n            for(int i = 0;i < columns;i++){\n                T temp = 0;\n                for(int j = 0;j < rows;j++){\n                    temp += this->values[j * rows + i];\n                }\n                if(temp > t1){\n                    t1 = temp;\n                    mc = i;\n                }\n            }\n            return getColumn(mc + 1);\n        }\n    }\n\n    Matrix min(){\n        if(this->columns == 1){\n            Matrix m(1, 1);\n            T temp = this->values[0];\n            for(int i = 0;i < this->rows;i++){\n                if(this->values[i] < temp){\n                    temp = this->values[i];\n                }\n            }\n            m.values[0] = temp;\n            return m;\n        }\n        else{\n            T t1 = 1000;\n            int mc = 0;\n            for(int i = 0;i < columns;i++){\n                T temp = 0;\n                for(int j = 0;j < rows;j++){\n                    temp += this->values[j * rows + i];\n                }\n                if(temp < t1){\n                    t1 = temp;\n                    mc = i;\n                }\n            }\n            return getColumn(mc + 1);\n        }\n    }\n\n    Matrix sum(){\n        if(this->rows == 1){\n            Matrix m(1, 1);\n            T temp = 0;\n            for(int i = 0;i < this->columns;i++){\n                temp += this->values[i];\n            }\n            m.values[0] = temp;\n            return m;\n        }\n        else{\n            Matrix m(1, this->columns);\n            int cnt = 0;\n            for(int i = 0;i < columns;i++){\n                int temp = 0;\n                for(int j = 0;j < rows;j++){\n                    temp += this->values[j * columns + i];\n                }\n                m.values[cnt++] = temp;\n            }\n            return m;\n        }\n    }\n\n    void print(){\n        for(int i = 0;i < rows;i++){\n            for(int j = 0;j < columns;j++){\n                cout << \"    \" << values[i * columns + j];\n            }\n            cout << endl;\n        }\n    }\n};",
            1590127463.7095141,
            100,
            "# 答案正确"
        ],
        [
            "6.2 (C++)",
            "容浩民",
            "#include <iostream>\n#include <string>\n#include <string.h>\nusing namespace std;\n\ntemplate <typename T>\nclass Matrix{\nprivate:\n    T * values;\n    int rows;\n    int columns;\npublic:\n    Matrix(int rows,int columns){\n        this->rows = rows;\n        this->columns = columns;\n        this->values = new T [rows * columns];\n        memset(values, 0, sizeof(T) * rows * columns);\n    }\n\n    Matrix(int rows, int columns, const T values[]){\n        this->rows = rows;\n        this->columns = columns;\n        this->values = new T [rows * columns];\n        for(int i = 0;i < rows * columns ;i++){\n            this->values[i] = values[i];\n        }\n    }\n\n    Matrix(Matrix & m2){\n        this->rows = m2.rows;\n        this->columns = m2.columns;\n        this->values = new T [rows * columns];\n        for(int i = 0;i < rows * columns ;i++){\n            this->values[i] = m2.values[i];\n        }\n    }\n\n    ~Matrix(){\n        delete [] values;\n    }\n\n  \n\n    void print(){\n        for(int i = 0;i < rows;i++){\n            for(int j = 0;j < columns;j++){\n                cout << \"    \" << values[i * rows + j] ;\n            }\n            cout << endl;\n        }\n    }\n};",
            1590631531.3554647,
            100,
            "# 答案正确"
        ],
        [
            "7.1 (C++)",
            "容浩民",
            "#include <iostream>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nclass Triangle : public GeometricObject{\nprivate:\n    double side1, side2, side3;\npublic:\n    Triangle(){\n        this->side1 = 1.0;\n        this->side2 = 1.0;\n        this->side3 = 1.0;\n    }\n\n    Triangle(double side1, double side2, double side3){\n        this->side1 = side1;\n        this->side2 = side2;\n        this->side3 = side3;\n    }\n\n    double getSide1(){\n        return this->side1;\n    }\n\n    double getSide2(){\n        return this->side2;\n    }\n\n    double getSide3(){\n        return this->side3;\n    }\n\n    double getArea(){\n        double s = (side1 + side2 + side3) / 2.0;\n        double area = sqrt(s * (s - side1) * (s - side2) * (s - side3));\n        return area;\n    }\n\n    double getPerimeter(){\n        return side1 + side2 + side3;\n    }\n};",
            1590725316.1158879,
            100,
            "# 答案正确"
        ],
        [
            "7.3 (C++)",
            "容浩民",
            "template <typename A, typename R>\nvector<R> map2(const vector<A> & x, const vector<A> & y,  R (*map_func)(const A & , const A &)) {\n    vector<R> res;\n    for (int i = 0; i < x.size(); ++ i)\n        res.push_back(map_func(x[i] , y[i]));\n    return res;\n}\n\ntemplate <typename A, typename R>\nvector<R> map2(const vector<A> & x, const A  & y,  R (*map_func)(const A & , const A &)) {\n    vector<R> res;\n    for (int i = 0; i < x.size(); ++ i)\n        res.push_back(map_func(x[i] , y));\n    return res;\n}",
            1590732605.8022087,
            100,
            "# 答案正确"
        ],
        [
            "7.2 (C++)",
            "容浩民",
            "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nvector<string> split(string line){\n    stringstream ss(line);\n    string temp;\n    vector <string> words;\n    while(ss >> temp){\n        words.push_back(temp);\n    }\n    return words;\n}",
            1591236659.7587705,
            100,
            "# 答案正确"
        ],
        [
            "8.1 (C++)",
            "容浩民",
            "class Full: public Matrix{\nprivate:\n    int rows;\n    int columns;\n    double * values;\npublic:\n    Full(int rows, int columns){\n        this->rows = rows;\n        this->columns = columns;\n        this->values = new double [rows * columns];\n        for(int i = 0;i < rows * columns;i++) values[i] = 0;\n    }\n\n    Full(int rows, int columns, double values[]){\n        this->rows = rows;\n        this->columns = columns;\n        this->values = new  double[rows * columns];\n        for(int i = 0;i < rows * columns;i++) this->values[i] = values[i];\n    }\n    \n    virtual int size(int dimension) const {\n        if(dimension == 2){\n            return this->rows;\n        }else{\n            return this->columns;\n        }\n    }\n    \n    virtual void set(int row, int column, double value) {\n        this->values[(row - 1) * this-> columns + column] = value;\n    }\n    \n    virtual double get(int row, int column) const {\n        return this->values[(row - 1) * columns + column - 1];\n    }\n    \n    virtual void print() const{\n        for(int i = 0;i < this->rows;i++){\n            for(int j = 0;j < this->columns;j++){\n                cout << \"    \" << this->values[i * columns + j];\n            }\n            cout << endl;\n        }\n    }\n\n    Full(const Matrix & matrix2){\n        int row = matrix2.size(2);\n        int column = matrix2.size(1);\n        this->rows = row;\n        this->columns = column;\n        this->values = new double [this->rows * this->columns];\n        for(int i = 0;i < this->rows;i++){\n            for(int j = 0;j < this->columns;j++){\n                this->values[i * columns + j] = matrix2.get(i + 1, j + 1);\n            }\n        }\n    }\n    \n    virtual Matrix & operator = (const Matrix & matrix2) {\n        for(int i = 0;i < this->rows;i++){\n            for(int j = 0;j < this->columns;j++){\n                this->values[i * columns + j] = matrix2.get(i + 1, j + 1);\n            }\n        }\n        return (*this);\n    }\n    \n    ~Full(){\n        delete [] values;\n    }\n\n\n\n};",
            1591337078.986176,
            100,
            "# 答案正确"
        ],
        [
            "8.3 (C++)",
            "容浩民",
            "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n\nbool cmp(Entry a, Entry b){\n    if(a.row == b.row){\n        return a.column < b.column;\n    }else{\n        return a.row < b.row;\n    }\n}\n\nclass Sparse: public Matrix{\nprivate:\n    int rows;\n    int columns;\n    vector<Entry> v;\npublic:\n    Sparse(int rows, int columns){\n        this->rows = rows;\n        this->columns = columns;\n    }\n\n    virtual int size(int dimension) const{\n        if(dimension == 2){\n            return this->rows;\n        }else if(dimension == 1){\n            return this->columns;\n        }else{\n            return v.size();\n        }\n    }\n\n    virtual void set(int row, int column, double value){\n        bool flag = true;\n        for(int i = 0;i < v.size();i++){\n            if(v[i].row == row && v[i].column == column){\n                flag = false;\n                v[i].value = value;\n                break;\n            }\n        }\n        if(flag){\n            Entry e;\n            e.row  = row;\n            e.column = column;\n            e.value = value;\n            v.push_back(e);\n        }\n    }\n\n    virtual double get(int row, int column) const{\n        for(int i = 0;i < v.size();i++){\n            if(v[i].row == row && v[i].column == column){\n                return v[i].value;\n            }\n        }\n        return 0;\n    }\n\n    virtual void print(){\n        sort(v.begin(), v.end(), cmp);\n        for(int i = 0;i < v.size();i++){\n            if(v[i].value != 0){\n                printf(\"(%d,%d,\", v[i].row, v[i].column);\n                cout << v[i].value << \")\" << endl;\n            }\n            \n        }\n    }\n\n    Sparse & operator + (Sparse & s2){\n        for(int i = 0;i < this->v.size();i++){\n            for(int j = 0;j < s2.v.size();j++){\n                if(this->v[i].row == s2.v[j].row && this->v[i].column == s2.v[j].column){\n                    this->v[i].value += s2.v[j].value;\n                }\n            }\n        }\n\n        for(int i = 0;i < s2.v.size();i++){\n            bool flag = true;\n            for(int j = 0;j < this->v.size();j++){\n                if(s2.v[i].row == this->v[j].row && s2.v[i].column == this->v[j].column){\n                    flag = false;\n                    break;\n                }\n            }\n            if(flag){\n                Entry e;\n                e.row = s2.v[i].row;\n                e.column = s2.v[i].column;\n                e.value = s2.v[i].value;\n                this->v.push_back(e);\n            }\n        }\n        return (*this);\n    }\n\n};",
            1591361971.858785,
            100,
            "# 答案正确"
        ],
        [
            "8.4 (C++)",
            "容浩民",
            "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nbool cmp(Entry a, Entry b){\n    if(a.row == b.row){\n        return a.column < b.column;\n    }else{\n        return a.row < b.row;\n    }\n}\n\nclass Sparse: public Matrix{\nprivate:\n    int rows;\n    int columns;\n    vector<Entry> v;\npublic:\n    Sparse(int rows, int columns){\n        this->rows = rows;\n        this->columns = columns;\n    }\n\n    virtual int size(int dimension) const{\n        if(dimension == 2){\n            return this->rows;\n        }else if(dimension == 1){\n            return this->columns;\n        }else{\n            return v.size();\n        }\n    }\n\n    virtual void set(int row, int column, double value){\n        bool flag = true;\n        for(int i = 0;i < v.size();i++){\n            if(v[i].row == row && v[i].column == column){\n                flag = false;\n                v[i].value = value;\n                break;\n            }\n        }\n        if(flag){\n            Entry e;\n            e.row  = row;\n            e.column = column;\n            e.value = value;\n            v.push_back(e);\n        }\n    }\n\n    virtual double get(int row, int column) const{\n        for(int i = 0;i < v.size();i++){\n            if(v[i].row == row && v[i].column == column){\n                return v[i].value;\n            }\n        }\n        return 0;\n    }\n\n    virtual void print(){\n        sort(v.begin(), v.end(), cmp);\n        for(int i = 0;i < v.size();i++){\n            if(v[i].value != 0){\n                printf(\"(%d,%d,\", v[i].row, v[i].column);\n                cout << v[i].value << \")\" << endl;\n            }\n            \n        }\n    }\n\n    Sparse & operator + (Sparse & s2){\n        for(int i = 0;i < this->v.size();i++){\n            for(int j = 0;j < s2.v.size();j++){\n                if(this->v[i].row == s2.v[j].row && this->v[i].column == s2.v[j].column){\n                    this->v[i].value += s2.v[j].value;\n                }\n            }\n        }\n\n        for(int i = 0;i < s2.v.size();i++){\n            bool flag = true;\n            for(int j = 0;j < this->v.size();j++){\n                if(s2.v[i].row == this->v[j].row && s2.v[i].column == this->v[j].column){\n                    flag = false;\n                    break;\n                }\n            }\n            if(flag){\n                Entry e;\n                e.row = s2.v[i].row;\n                e.column = s2.v[i].column;\n                e.value = s2.v[i].value;\n                this->v.push_back(e);\n            }\n        }\n        return (*this);\n    }\n\n    Sparse  operator * (Sparse & s2){\n        Sparse s3(this->rows, s2.size(1));\n        for(int i = 0;i < this->v.size();i++){\n            for(int j = 0;j < s2.v.size();j++){\n                if(this->v[i].column == s2.v[j].row){\n                    bool flag = true;\n                    for(int k = 0;k < s3.v.size();k++){\n                        if(s3.v[k].row == this->v[i].row && s3.v[k].column == s2.v[j].column){\n                            s3.v[k].value += this->v[i].value * s2.v[j].value;\n                            flag = false;\n                            break;\n                        }\n                    }\n                    if(flag){\n                        Entry e;\n                        e.row = this->v[i].row;\n                        e.column = s2.v[j].column;\n                        e.value = this->v[i].value * s2.v[j].value;\n                        s3.v.push_back(e);\n                    }\n                }\n            }\n        }\n        return s3;\n    }\n\n};",
            1591366040.3457186,
            100,
            "# 答案正确"
        ],
        [
            "8.5 (C++)",
            "容浩民",
            "#include <iostream>\nusing namespace std;\n\nclass Point3D:public Point2D{\nprivate:\n    double z;\npublic:\n    Point3D(){\n        setX(0);\n        setY(0);\n        this->z = 0;\n    }\n\n    Point3D(double x, double y, double z){\n        setX(x);\n        setY(y);\n        this->z = z;\n    }\n\n    double getZ(){\n        return this->z;\n    }\n\n    virtual double distance(Point2D & point2) {\n        double dx = getX() - point2.getX();\n        double dy = getY() - point2.getY();\n        double dz = this->z - dynamic_cast<Point3D &>(point2).z;\n        return sqrt(dx * dx + dy * dy + dz * dz);\n    }\n};",
            1591843061.1389356,
            100,
            "# 答案正确"
        ],
        [
            "8.6 (C++)",
            "容浩民",
            "#include <iostream>\n#include <vector>\nusing namespace std;\nclass MyTensor:public Tensor<double>{\nprivate:\n    vector<double> values;\npublic:\n    MyTensor(vector<int> sizes):Tensor<double>(sizes) {\n        int sum = 1;\n        for(int i = 0;i < sizes.size();i++){\n            sum *= sizes[i];\n        }\n        for(int i = 0;i < sum;i++){\n            values.push_back(0);\n        }\n    }\n    virtual double & get(const vector<int> & indexes){\n        int index = indexes[0];\n        for(int i = 1;i < indexes.size();i++){\n            index = sizes[i] *  index + indexes[i];\n        }\n        return values[index];\n    }\n};",
            1592448362.7927291,
            100,
            "# 答案正确"
        ],
        [
            "9.1 (C++)",
            "容浩民",
            "#include <iostream>\nusing namespace std;\n\nclass Circle{\nprivate:\n    double radius;\npublic:\n    Circle(double radius):radius(radius){}\n    int operator < (Circle & other){\n        if(this->radius < other.radius) return 1;\n        else return 0;\n    }\n\n    int operator <= (Circle & other){\n        if(this->radius <= other.radius) return 1;\n        else return 0;\n    }\n\n    int operator == (Circle & other){\n        if(this->radius == other.radius) return 1;\n        else return 0;\n    }\n\n    int operator != (Circle & other){\n        if(this->radius != other.radius) return 1;\n        else return 0;\n    }\n\n    int operator > (Circle & other){\n        if(this->radius > other.radius) return 1;\n        else return 0;\n    }\n\n    int operator >= (Circle & other){\n        if(this->radius >= other.radius) return 1;\n        else return 0;\n    }\n};",
            1592536541.5380857,
            100,
            "# 答案正确"
        ],
        [
            "9.2 (C++)",
            "容浩民",
            "class I{\nprivate:\n    vector<int> sizes;\npublic:\n    I(int x0, int x1 = -1, int x2 = -1, int x3 = -1){\n        sizes.push_back(x0);\n        if(x1 != -1){\n            sizes.push_back(x1);\n        }\n\n        if(x2 != -1){\n            sizes.push_back(x2);\n        }\n\n        if(x3 != -1){\n            sizes.push_back(x3);\n        }\n    }\n    operator vector<int> (){\n        return this->sizes;\n    }\n};",
            1592537362.0781503,
            100,
            "# 答案正确"
        ],
        [
            "9.3 (C++)",
            "容浩民",
            "#include <iostream>\n#include <cmath>\nusing namespace std;\n\n\n\nclass Complex{\nprivate:\n    double r;\n    double i;\npublic:\n    Complex(double r){\n        this->r = r;\n        this->i = 0;\n    }\n    Complex(int r){\n        this->r = (double)r;\n        this->i = 0;\n    }\n    Complex(double r, double i): r(r),i(i){}\n    double real() const{\n        return this->r;\n    }\n    double imag()const {\n        return this->i;\n    }\n\n    Complex & operator +=(const Complex & );\n\n    Complex & operator -=(const Complex & );\n\n    Complex & operator *=(const Complex & );\n\n    Complex & operator /=(const Complex & );\n\n    bool operator ==(const Complex & other){\n        if(this->r == other.r && this->i == other.r) return true;\n        else return false;\n    }\n\n    bool operator !=(const Complex & other){\n        if(this->r == other.r && this->i == other.r) return false;\n        else return true;\n    }\n\n};\n\nComplex operator +(const Complex & other1, const Complex & other2){\n    double r = other1.real() + other2.real();\n    double i = other1.imag() + other2.imag();\n    Complex t(r,i);\n    return t;\n}\n\nComplex operator -(const Complex & other1, const Complex & other2){\n    double r = other1.real() -other2.real();\n    double i = other1.imag() - other2.imag();\n    Complex t(r,i);\n    return t;\n}\n\nComplex operator *(const Complex & other1, const Complex & other2){\n    double r = other1.real() * other2.real() - other1.imag() * other2.imag();\n    double i = other1.real() * other2.imag() + other1.imag() * other2.real();\n    Complex t(r,i);\n    return t;\n}\n\nComplex operator /(const Complex & other1, const Complex & other2){\n    double r = (other1.real() * other2.real() + other1.imag() * other2.imag()) / (other2.real() * other2.real() + other2.imag() * other2.imag());\n    double i = (other1.imag() * other2.real() - other1.real() * other2.imag()) / (other2.real() * other2.real() + other2.imag() * other2.imag());\n    Complex t(r,i);\n    return t;\n}\n\nComplex & Complex::operator +=(const Complex & other){\n    *this = *this + other;\n    return (*this);\n}\n\nComplex & Complex::operator -=(const Complex & other){\n    *this = *this - other;\n    return (*this);\n}\n\nComplex & Complex::operator *=(const Complex & other){\n    *this = *this * other;\n    return (*this);\n}\n\nComplex & Complex::operator /=(const Complex & other){\n    *this = *this / other;\n    return (*this);\n}",
            1592539481.5662057,
            100,
            "# 答案正确"
        ],
        [
            "9.4 (C++)",
            "容浩民",
            "#include <iostream>\n#include <cmath>\nusing namespace std;\n\n\n\nclass Complex{\nprivate:\n    double r;\n    double i;\npublic:\n    Complex(){\n        this->r = 0;\n        this->i = 0;\n    }\n    Complex(double r){\n        this->r = r;\n        this->i = 0;\n    }\n    Complex(int r){\n        this->r = (double)r;\n        this->i = 0;\n    }\n    Complex(double r, double i): r(r),i(i){}\n    double real() const{\n        return this->r;\n    }\n    double imag()const {\n        return this->i;\n    }\n\n    Complex & operator +=(const Complex & );\n\n    Complex & operator -=(const Complex & );\n\n    Complex & operator *=(const Complex & );\n\n    Complex & operator /=(const Complex & );\n\n    bool operator ==(const Complex & other){\n        if(this->r == other.r && this->i == other.r) return true;\n        else return false;\n    }\n\n    bool operator !=(const Complex & other){\n        if(this->r == other.r && this->i == other.r) return false;\n        else return true;\n    }\n\n};\n\nComplex operator +(const Complex & other1, const Complex & other2){\n    double r = other1.real() + other2.real();\n    double i = other1.imag() + other2.imag();\n    Complex t(r,i);\n    return t;\n}\n\nComplex operator -(const Complex & other1, const Complex & other2){\n    double r = other1.real() -other2.real();\n    double i = other1.imag() - other2.imag();\n    Complex t(r,i);\n    return t;\n}\n\nComplex operator *(const Complex & other1, const Complex & other2){\n    double r = other1.real() * other2.real() - other1.imag() * other2.imag();\n    double i = other1.real() * other2.imag() + other1.imag() * other2.real();\n    Complex t(r,i);\n    return t;\n}\n\nComplex operator /(const Complex & other1, const Complex & other2){\n    double r = (other1.real() * other2.real() + other1.imag() * other2.imag()) / (other2.real() * other2.real() + other2.imag() * other2.imag());\n    double i = (other1.imag() * other2.real() - other1.real() * other2.imag()) / (other2.real() * other2.real() + other2.imag() * other2.imag());\n    Complex t(r,i);\n    return t;\n}\n\nComplex & Complex::operator +=(const Complex & other){\n    *this = *this + other;\n    return (*this);\n}\n\nComplex & Complex::operator -=(const Complex & other){\n    *this = *this - other;\n    return (*this);\n}\n\nComplex & Complex::operator *=(const Complex & other){\n    *this = *this * other;\n    return (*this);\n}\n\nComplex & Complex::operator /=(const Complex & other){\n    *this = *this / other;\n    return (*this);\n}\n\nostream & operator << (ostream & out, const Complex & c){\n    out << c.real() << \" + \" << c.imag() << \" i\";\n    return out;\n}\n\nistream & operator >>(istream & in, Complex & c){\n    double real;\n    double imag;\n    in >> real >> imag;\n    Complex t(real, imag);\n    c = t;\n    return in;\n}",
            1592539872.5381181,
            100,
            "# 答案正确"
        ],
        [
            "9.5 (C++)",
            "容浩民",
            "#include <iostream>\n#include <cmath>\nusing namespace std;\n\n\n\nclass Complex{\nprivate:\n    double r;\n    double i;\npublic:\n    Complex(){\n        this->r = 0;\n        this->i = 0;\n    }\n    Complex(double r){\n        this->r = r;\n        this->i = 0;\n    }\n    Complex(int r){\n        this->r = (double)r;\n        this->i = 0;\n    }\n    Complex(double r, double i): r(r),i(i){}\n    double real() const{\n        return this->r;\n    }\n    double imag()const {\n        return this->i;\n    }\n\n    Complex & operator +=(const Complex & );\n\n    Complex & operator -=(const Complex & );\n\n    Complex & operator *=(const Complex & );\n\n    Complex & operator /=(const Complex & );\n\n    bool operator ==(const Complex & other){\n        if(this->r == other.r && this->i == other.r) return true;\n        else return false;\n    }\n\n    bool operator !=(const Complex & other){\n        if(this->r == other.r && this->i == other.r) return false;\n        else return true;\n    }\n\n    Complex & operator ++(){\n        this->r++;\n        return(*this);\n    }\n\n    Complex operator++ (int){\n        Complex prev(*this);\n        r++;\n        return prev;\n    }\n\n    operator double() const{\n        return this->r;\n    }\n\n};\n\nComplex operator +(const Complex & other1, const Complex & other2){\n    double r = other1.real() + other2.real();\n    double i = other1.imag() + other2.imag();\n    Complex t(r,i);\n    return t;\n}\n\nComplex operator -(const Complex & other1, const Complex & other2){\n    double r = other1.real() -other2.real();\n    double i = other1.imag() - other2.imag();\n    Complex t(r,i);\n    return t;\n}\n\nComplex operator *(const Complex & other1, const Complex & other2){\n    double r = other1.real() * other2.real() - other1.imag() * other2.imag();\n    double i = other1.real() * other2.imag() + other1.imag() * other2.real();\n    Complex t(r,i);\n    return t;\n}\n\nComplex operator /(const Complex & other1, const Complex & other2){\n    double r = (other1.real() * other2.real() + other1.imag() * other2.imag()) / (other2.real() * other2.real() + other2.imag() * other2.imag());\n    double i = (other1.imag() * other2.real() - other1.real() * other2.imag()) / (other2.real() * other2.real() + other2.imag() * other2.imag());\n    Complex t(r,i);\n    return t;\n}\n\nComplex & Complex::operator +=(const Complex & other){\n    *this = *this + other;\n    return (*this);\n}\n\nComplex & Complex::operator -=(const Complex & other){\n    *this = *this - other;\n    return (*this);\n}\n\nComplex & Complex::operator *=(const Complex & other){\n    *this = *this * other;\n    return (*this);\n}\n\nComplex & Complex::operator /=(const Complex & other){\n    *this = *this / other;\n    return (*this);\n}\n\nostream & operator << (ostream & out, const Complex & c){\n    out << c.real() << \" + \" << c.imag() << \" i\";\n    return out;\n}\n\nistream & operator >>(istream & in, Complex & c){\n    double real;\n    double imag;\n    in >> real >> imag;\n    Complex t(real, imag);\n    c = t;\n    return in;\n}",
            1592540134.4029465,
            100,
            "# 答案正确"
        ],
        [
            "9.6 (C++)",
            "容浩民",
            "#include <vector>\n#include <iostream>\nusing namespace std;\n\nclass Tensor\n{\n    vector<int> sizes;\n    vector<double> values;\n    \npublic:\n    Tensor(int x0 = -1, int x1 = -1, int x2 = -1, int x3 = -1){\n        if(x0 != -1) sizes.push_back(x0);\n        if(x1 != -1) sizes.push_back(x1);\n        if(x2 != -1) sizes.push_back(x2);\n        if(x3 != -1) sizes.push_back(x3);\n        int cnt = 1;\n        for(int i = 0;i < sizes.size();i++){\n            cnt *= sizes[i];\n        }\n        for(int i = 0;i < cnt;i++){\n            values.push_back(0);\n        }\n    }\n\n    double & operator() (int x0 = -1, int x1 = -1, int x2 = -1, int x3 = -1){\n        int cnt = x0;\n        if(x1 != -1) cnt = cnt * sizes[1] + x1;\n        if(x2 != -1) cnt = cnt * sizes[2] + x2;\n        if(x3 != -1) cnt = cnt * sizes[3] + x3;\n        return values[cnt];\n    }\n};",
            1592543406.9602175,
            100,
            "# 答案正确"
        ],
        [
            "9.7 (C++)",
            "容浩民",
            "#include <vector>\n#include <iostream>\n#include <fstream>\nusing namespace std;\n\nclass Tensor\n{\n    vector<int> sizes;\n    vector<double> values;\n    \n    int _index(const vector<int> & indexes) const {\n        int index = 0;\n        for (int i = 0; i < this->sizes.size(); ++ i) {\n            index *= sizes[i];\n            index += indexes[i];\n        }\n        return index;\n    }\n    \npublic:\n    int numel() const {\n        if (this->sizes.size() == 0) return 0;\n        int size = 1;\n        for (int i = 0; i < this->sizes.size(); ++ i) size *= sizes[i];\n        return size;\n    }\n\n    int get_dimension(){\n        return this->sizes.size();\n    }\n\n    int get_size(int index){\n        return sizes[index];\n    }\n    \n    Tensor(){}\n\n    Tensor(vector<int> sizes) {\n        this->sizes = sizes;\n        this->values.resize(this->numel());\n        for (int i = 0; i < this->numel(); ++ i) this->values[i] = 0;\n    }\n    \n    double & get(const vector<int> & indexes) {\n        return values[this->_index(indexes)];\n    }\n\n    double & get(int index) {\n        return values[index];\n    }\n};\n\nistream & operator >> (istream & in, Tensor & t){\n    int dimension;\n    in >> dimension;\n    vector <int> temp;\n    for(int i = 0;i < dimension;i++){\n        int x;\n        in >> x;\n        temp.push_back(x);\n    }\n    Tensor other(temp);\n    for(int i = 0;i < other.numel();i++){\n        in >> other.get(i);\n    }\n    t = other;\n    return in;\n}\n\nostream & operator << (ostream & out ,  Tensor & t){\n    int dimension = t.get_dimension();\n    out << dimension << endl;\n\n    for(int i = 0;i < dimension;i++){\n        out << t.get_size(i) << \" \";\n    }\n    out << endl << endl;\n\n    if(dimension == 1){\n        for(int i = 0;i < t.numel();i++) out << t.get(i) << \" \";\n        out << endl;\n    }else if(dimension == 2){\n        for(int i = 0;i < t.get_size(0);i++){\n            for(int j = 0;j < t.get_size(1);j++){\n                vector<int> temp;\n                temp.push_back(i);\n                temp.push_back(j);\n                out << t.get(temp) << \" \";\n            }\n            out << endl;\n        }\n    }else if(dimension == 3){\n        for(int i = 0;i < t.get_size(0) ;i++){\n            for(int j = 0;j < t.get_size(1);j++){\n                for(int h = 0;h < t.get_size(2);h++){\n                    vector<int> temp;\n                    temp.push_back(i);\n                    temp.push_back(j);\n                    temp.push_back(h);\n                    out << t.get(temp) << \" \";\n                }\n                out << endl;\n            }\n            out << endl;\n        }\n    }else if(dimension == 4){\n        for(int i = 0;i < t.get_size(0) ;i++){\n            for(int j = 0;j < t.get_size(1);j++){\n                for(int h = 0;h < t.get_size(2);h++){\n                    for(int k = 0;k < t.get_size(3);k++){\n                        vector<int> temp;\n                        temp.push_back(i);\n                        temp.push_back(j);\n                        temp.push_back(h);\n                        temp.push_back(k);\n                        out << t.get(temp) << \" \";\n                    }\n                    out << endl;\n                }\n                out << endl;  \n            }\n        }\n    }\n    return out;\n}",
            1592546363.9308302,
            100,
            "# 答案正确"
        ],
        [
            "10.1 (C++)",
            "容浩民",
            "#include <iostream>\n#include <vector>\n#include<stdexcept>\nusing namespace std;\n\nclass MatrixSizesDoNotMatchException{};\n\n\ndouble Matrix::get(int row, int column) const{\n    if(row < 0 || row > this->rows || column < 0 || column > this->columns){\n        throw out_of_range(\"\");\n    }\n    return elements[(row - 1) * columns + column - 1];\n}\n\nvoid Matrix::set(int row, int column, double value){\n    if(row < 0 || row > this->rows || column < 0 || column > this->columns){\n        throw out_of_range(\"\");\n    }\n    elements[(row - 1) * columns + column - 1] = value;\n}\n\nMatrix Matrix::operator + (const Matrix & matrix2) const{\n    if(this->rows != matrix2.size(1) || this->columns != matrix2.size(2)){\n        throw MatrixSizesDoNotMatchException();\n    }\n    Matrix m(this->rows, this->columns);\n    for(int i = 0;i < rows;i++){\n        for(int j = 0;j < columns;j++){\n            m.set(i + 1, j + 1, this->get(i + 1, j + 1) + matrix2.get(i + 1, j + 1));\n        }\n    }\n    return m;\n}",
            1593322814.1543078,
            100,
            "# 答案正确"
        ],
        [
            "10.2 (C++)",
            "容浩民",
            "catch(NonPositiveValueException & ex2){\n            cout << \"caught: NonPositiveValueException\" << endl;\n        }catch(out_of_range & ex1){\n            cout << \"caught: out_of_range\" << endl;\n        }",
            1593656387.4654636,
            100,
            "# 答案正确"
        ],
        [
            "15.1 (C++)",
            "容浩民",
            "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\nclass Table{\nprivate:\n    vector<string> col;\n    vector<vector<string> > table_data;\npublic:\n    Table(){}\n    void addCol(const string & header){\n        col.push_back(header);\n    }\n    vector<string> & operator[](int index){\n        if(index == table_data.size()){\n            table_data.push_back({});\n        }\n        return table_data[index];\n    }\n\n    string json() const{\n        cout << '{' << endl;\n        cout << \"    headers: [\" ;\n        for(int i = 0;i < col.size();i++){\n            cout << \"'\" << col[i] << \"',\";\n        }\n        cout << \"],\" << endl;\n        cout << \"    rows: [\" << endl;\n        for(int i = 0;i < table_data.size();i++){\n            cout << \"        [\";\n            for(int j = 0;j < table_data[i].size();j++){\n                cout << \"'\" << table_data[i][j] << \"',\";\n            }\n            cout << \"],\" << endl;\n        }\n        cout << \"    ],\" << endl;\n        cout << \"}\" << endl;\n        return \"\";\n    }\n\n\n};",
            1593746275.2897675,
            100,
            "# 答案正确"
        ],
        [
            "2020-07-09 LAB",
            "容浩民",
            "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n\n\nclass Integer{\nprivate: \n    int x;\npublic:\n    static int sum;\n    Integer():x(0){}\n    Integer(int x):x(x){}\n    static void increase_all(int other){\n        sum += other;\n    }\n\n    static void increase_all(Integer & other){\n        int y = other.x;\n        sum = 2 * sum + y;\n    }\n\n\n    friend istream & operator >> (istream & in, Integer & other) {\n        in >> other.x;\n        return in;\n    }\n\n    friend ostream & operator << (ostream & out, const Integer & other) {\n        out << other.x + sum;\n        return out;\n    }\n};\n\nint Integer::sum = 0;",
            1594262894.041859,
            100,
            "# 答案正确"
        ],
        [
            "A.1 (C++)",
            "容浩民",
            "    private:\n    Node<E> * get_node(int index) const {\n        if (index < 0 || index >= _size) \n            throw NotSuchElementException();\n        if (index < _size / 2) {\n            Node<E> * node = head;\n            Node<E> * prev_node = 0;\n            Node<E> * temp;\n            I(i, index) {\n                temp = node;\n                node = node->next_node(prev_node);\n                prev_node = temp;\n            }\n            return node;\n        }\n        else {\n            Node<E> * node = tail;\n            Node<E> * next_node = 0;\n            Node<E> * temp;\n            I(i, (_size-1-index))  {\n                temp = node;\n                node = node->prev_node(next_node);\n                next_node = temp; \n            }\n            return node;\n        }\n    }\n\npublic:\n    E & get(int index) const {\n        Node<E> * node = get_node(index);\n        return node->element;\n    }\n    void set(int index, const E & e) {\n        Node<E> * node = get_node(index);\n        node->element = e;\n    }\n\n    E & getFirst() const {\n        return get(0);\n    }\n\n    E & getLast() const {\n        return get(_size - 1);\n    }\n\n    void remove (int index) {\n        Node<E> * node = get_node(index);\n        Node<E> * prev_node;\n        if(index >= 1){\n            prev_node  = get_node(index - 1);\n        }else{\n            prev_node  = 0;\n        }\n        Node<E> * next_node;\n        if(index < _size-1){\n           next_node = get_node(index + 1);\n       }else{\n            next_node = 0;\n       } \n        if (prev_node != 0) prev_node->update_next_node(node, next_node);  //prev_node->next_node = next_node;\n        if (next_node != 0) next_node->update_prev_node(node, prev_node); //   next_node->prev_node = prev_node;\n        if (prev_node == 0) head = next_node;\n        if (next_node == 0) tail = prev_node;\n        delete node;\n        -- _size;\n    }\n\n    void removeFirst () {\n        remove(0);\n    }\n\n    void removeLast () {\n        remove(_size-1);\n    }\n\n    void add(int index, const E & e) {\n        if (index < 0 || index > _size) \n            throw NotSuchElementException();\n        Node<E> * node = new Node<E>();\n        node->element = e;\n        Node<E> * next_node = (index == _size ? 0 : get_node(index));\n        Node<E> * prev_node;\n        if(next_node == 0){\n            prev_node = tail;\n        }else{\n            if(index >= 1){\n                prev_node = get_node(index - 1);\n            }else{\n                prev_node = 0;\n            }\n        }\n        //Node<E> * prev_node = (next_node == 0 ? tail : get_node(index - 1));//next_node->prev_node);\n        node->update_prev_and_next_node(prev_node, next_node);  // node->next_node = next_node;\n        //node->prev_node = prev_node;\n        if (prev_node != 0) prev_node->update_next_node(next_node, node); //prev_node->next_node = node;\n        if (next_node != 0) next_node->update_prev_node(prev_node, node); //next_node->prev_node = node;\n        if (prev_node == 0) head = node;\n        if (next_node == 0) tail = node;\n        ++ _size;\n    }\n\n    void addFirst (const E & e) {\n        add(0, e);\n    }\n\n    void addLast (const E & e) {\n        add(_size, e);\n    }\n\n    // copy and clear\n\n    void clear() {\n        while (_size > 0) removeFirst();\n    }\n\n    void addAll(const LinkedList & list, int index=-1) {\n        if (index == -1) index = _size;\n        I(i, list._size) {\n            Node<E> * node = list.get_node(i);\n            add(index + i, node->element);\n        }\n    }\n\n    LinkedList(const LinkedList & list) : _size(0), head(0), tail(0) {\n        addAll(list);\n    }\n\n    LinkedList & operator = (const LinkedList & list) {\n        clear();\n        addAll(list);\n        return *this;\n    }\n\n    ~LinkedList() {\n        clear();\n    }\n\n    int indexOf(const E & e) const {\n        Node<E> * node = head;\n        Node<E> * prev_node = 0;\n        Node<E> * temp;\n        I(i, _size) {\n            if (node->element == e) return i;\n            temp = node;\n            node = node->next_node(prev_node);\n            prev_node = temp;\n            //node = node->next_node;\n        }\n        return -1;\n    }\n\n    int lastIndexOf(const E & e) const {\n        Node<E> * node = tail;\n        Node<E> * next_node = 0;\n        Node<E> * temp;\n        I(i, _size) {\n            if (node->element == e) return i;\n            temp = node;\n            node = node->prev_node(next_node);\n            next_node = temp;\n            //node = node->prev_node;\n        }\n        return -1;\n    }\n\n    bool contains(const E & e) const {\n        return indexOf(e) >= 0;\n    }\n\n    void removeFirstOccurrence(const E & e) {\n        int index = indexOf(e);\n        if (index == -1)\n            throw NotSuchElementException();\n        remove(index);\n    }\n\n    void removeLastOccurrence(const E & e) {\n        int index = lastIndexOf(e);\n        if (index == -1)\n            throw NotSuchElementException();\n        remove(index);\n    }",
            1594358185.7901783,
            100,
            "# 答案正确"
        ],
        [
            "A.2 (C++)",
            "容浩民",
            "template<typename E>\nvoid LinkedList<E>::removeAll(const E & e){\n    while(contains(e)){\n        removeFirstOccurrence(e);\n    }\n}",
            1594865437.2609284,
            100,
            "# 答案正确"
        ],
        [
            "A.4 (C++)",
            "容浩民",
            "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define I(i,n) for (size_t i = 0; i < n; ++ i)\n\nsize_t circular_shift(size_t bits, int shift_bits) {\n    const int num_bits = 8 * sizeof(size_t);\n    shift_bits = shift_bits % num_bits;\n    return bits << shift_bits | bits >> (num_bits - shift_bits);\n}\n\nsize_t hash_function(const string & key) {\n    size_t code = 0;\n    I(i, key.size())\n        code ^= circular_shift(key[i], i * 5);\n    return code;\n}\n\nclass HT{\nprivate:\n    class Tuple{\n    public:\n        string key;\n        string val;\n        bool in_use;\n\n        Tuple():in_use(false){}\n\n        operator string(){\n            return this->val;\n        }\n\n        operator int(){\n            return stoi(val);\n        }\n    };\n\n    vector<Tuple> tuples;\n\n    size_t _size;\n\n    size_t canonical_index(const string & key) const {\n        size_t hash_code = hash_function(key); // needs hash_function(K)\n        return hash_code % tuples.size();\n    }\n\n    // the returned tuple is either empty or with the same key\n    size_t indexOfKey(const string & key) const {\n        size_t index = canonical_index(key);\n        while (true) { // will enter a dead loop if there is not empty tuple\n            if (! tuples[index].in_use) return index;\n            if (tuples[index].key == key) return index;\n            index = (index + 1) % tuples.size();\n        }\n    }\n\npublic:\n\n    HT():_size(0){\n        tuples.resize(10);\n    }\n\n    size_t size(){\n        return this->_size;\n    }\n\n    void put_(const string & key, const string & val) {\n        size_t index = indexOfKey(key);\n        tuples[index].key = key;\n        tuples[index].val = val;\n        if (tuples[index].in_use) return;\n        tuples[index].in_use = true;\n        ++ _size;\n    }\n\n    void put(const int & key, const int & val){\n        stringstream s1;\n        s1 << key;\n        stringstream s2;\n        s2 << val;\n        string key1 = s1.str();\n        string val2 = s2.str();\n        put_(key1, val2);\n    }\n\n    void put(const string & key, const int & val){\n        stringstream s2;\n        s2 << val;\n        string val2 = s2.str();\n        put_(key, val2);\n    }\n\n\n    void put(const int & key, const string & val){\n        stringstream s1;\n        s1 << key;\n        string key1 = s1.str();\n        put_(key1, val);\n    }\n\n\n    void put(const string & key, const string & val){\n        put_(key, val);\n    }\n\n\n    Tuple & operator[] (const string & key){\n        size_t index = indexOfKey(key);\n        return tuples[index];\n    }\n\n\n    Tuple & operator[] (const int & key){\n        stringstream s1;\n        s1 << key;\n        string key1 = s1.str();\n        size_t index = indexOfKey(key1);\n        return tuples[index];\n    }\n\n};",
            1594994987.1980448,
            100,
            "# 答案正确"
        ],
        [
            "A.5 (C++)",
            "容浩民",
            "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define I(i,n) for (size_t i = 0; i < n; ++ i)\n\nsize_t circular_shift(size_t bits, int shift_bits) {\n    const int num_bits = 8 * sizeof(size_t);\n    shift_bits = shift_bits % num_bits;\n    return bits << shift_bits | bits >> (num_bits - shift_bits);\n}\n\nsize_t hash_function(const string & key) {\n    size_t code = 0;\n    I(i, key.size())\n        code ^= circular_shift(key[i], i * 5);\n    return code;\n}\n\n\nclass HT{\nprivate:\n\n    size_t _size;\n    class Tuple{\n    public:\n        string key;\n        string val;\n        bool in_use;\n\n        Tuple():in_use(false){}\n\n        operator string(){\n            return this->val;\n        }\n\n        operator int(){\n            return stoi(this->val);\n        }\n\n        Tuple & operator = (const string & val){\n            this->val = val;\n            return *this;\n        }\n\n        Tuple & operator = (const int & val){\n            this->val = to_string(val);\n            return *this;\n        }\n    };\n\n    vector<Tuple> tuples;\n\n    \n\n    size_t canonical_index(const string & key) const {\n        size_t hash_code = hash_function(key); // needs hash_function(K)\n        return hash_code % tuples.size();\n    }\n\n    // the returned tuple is either empty or with the same key\n    size_t indexOfKey(const string & key) const {\n        size_t index = canonical_index(key);\n        while (true) { // will enter a dead loop if there is not empty tuple\n            if (! tuples[index].in_use) return index;\n            if (tuples[index].key == key) return index;\n            index = (index + 1) % tuples.size();\n        }\n    }\n\npublic:\n\n    HT():_size(0){\n        tuples.resize(10);\n    }\n\n    size_t size(){\n        return this->_size;\n    }\n\n    Tuple & operator[] (const string & key){\n        size_t index = indexOfKey(key);\n        if(!tuples[index].in_use){\n            tuples[index].key = key;\n            tuples[index].in_use = true;\n            _size++;\n        }\n        \n        return tuples[index];\n    }\n\n\n    Tuple & operator[] (const int & key){\n        stringstream s1;\n        s1 << key;\n        string key1 = s1.str();\n        size_t index = indexOfKey(key1);\n        if(!tuples[index].in_use){\n            tuples[index].key = key1;\n            tuples[index].in_use = true;\n            _size++;\n        }\n        return tuples[index];\n    }\n\n};",
            1594997592.0942185,
            100,
            "# 答案正确"
        ],
        [
            "A.3 (C++)",
            "容浩民",
            "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <stdexcept>\nusing namespace std;\n\n#define I(i,n) for (size_t i = 0; i < n; ++ i)\n\nclass NoSuchKeyException {};\n\nsize_t circular_shift(size_t bits, int shift_bits) {\n    const int num_bits = 8 * sizeof(size_t);\n    shift_bits = shift_bits % num_bits;\n    return bits << shift_bits | bits >> (num_bits - shift_bits);\n}\n\nsize_t hash_function(const string & key) {\n    size_t code = 0;\n    I(i, key.size())\n        code ^= circular_shift(key[i], i * 5);\n    return code;\n}\n\nsize_t hash_function(const int & key) {\n    size_t code = key;\n    return code;\n}\n\ntemplate <typename K, typename V>\nclass HashTable\n{\n    class Tuple\n    {\n    public:\n        K key;\n        V val;\n        bool in_use;\n\n        Tuple() : in_use(false) {}\n    };\n\n    vector<Tuple> tuples;\n    size_t _size;\n\n    size_t canonical_index(const K & key) const {\n        size_t hash_code = hash_function(key); // needs hash_function(K)\n        return hash_code % tuples.size();\n    }\n\n    // the returned tuple is either empty or with the same key\n    size_t indexOfKey(const K & key) const {\n        size_t index = canonical_index(key);\n        while (true) { // will enter a dead loop if there is not empty tuple\n            if (! tuples[index].in_use) return index;\n            if (tuples[index].key == key) return index;\n            index = (index + 1) % tuples.size();\n        }\n    }\n\npublic:\n    HashTable() : _size(0) {\n        tuples.resize(2);\n    }\n\n    bool containsKey(const K & key) const {\n        size_t index = indexOfKey(key);\n        return tuples[index].in_use;\n    }\n\n    const V & operator [] (const K & key) const {\n        size_t index = indexOfKey(key);\n        if (! tuples[index].in_use) \n            throw NoSuchKeyException();\n        return tuples[index].val;\n    }\n\n    V & operator [] (const K & key) {\n        size_t index = indexOfKey(key);\n        if (! tuples[index].in_use) \n            throw NoSuchKeyException();\n        return tuples[index].val;\n    }\n\n    void put(const K & key, const V & val) {\n        size_t index = indexOfKey(key);\n        tuples[index].key = key;\n        tuples[index].val = val;\n        if (tuples[index].in_use) return;\n        tuples[index].in_use = true;\n        ++ _size;\n        // make sure empty > size / 2\n        if (2 * _size > tuples.size())\n            _double_tuples();\n    }\n\n    void _double_tuples() {\n        vector<Tuple> non_empty_tuples;\n        I(i, tuples.size())\n            if (tuples[i].in_use)\n                non_empty_tuples.push_back(tuples[i]);\n        clear();\n        tuples.resize(tuples.size() * 2);\n        I(i, non_empty_tuples.size())\n            put(non_empty_tuples[i].key, non_empty_tuples[i].val);\n    }\n\n    static bool _between(size_t hole, size_t canonical, size_t tuple_index) {\n        if (hole < tuple_index)\n            return canonical > hole && canonical <= tuple_index;\n        else\n            return canonical > hole || canonical <= tuple_index;\n    }\n\n    void remove(const K & key) { \n        size_t index = indexOfKey(key);\n        if (! tuples[index].in_use) \n            throw NoSuchKeyException();\n        tuples[index].in_use = false;\n        -- _size;\n        // if there is a hole between a tuple and its canonical position\n        // move the tuple to the hole\n        size_t hole = index;\n        size_t tuple_index = hole;\n        while (true) {\n            tuple_index = (tuple_index + 1) % tuples.size();\n            if (! tuples[tuple_index].in_use) return;\n            size_t canonical = canonical_index(tuples[tuple_index].key);\n            if (_between(hole, canonical, tuple_index)) continue;\n            tuples[hole] = tuples[tuple_index];\n            hole = tuple_index;\n            tuples[hole].in_use = false;\n        }\n    }\n\n    size_t size() const { return _size; }\n\n    void clear() {\n        I(i, tuples.size())\n            tuples[i].in_use = false;\n        _size = 0;\n    }\n\n    template <typename K2, typename V2>\n    friend ostream & operator << (ostream & out, const HashTable<K2,V2> & dict);\n\n    template <typename K2, typename V2>\n    friend istream & operator >> (istream & in, HashTable<K2,V2> & dict);\n\n    void _inspect() const {\n        I(i, tuples.size())\n            if (tuples[i].in_use)\n                cout << \"#\" << i << \" C\" << canonical_index(tuples[i].key) \n                    << \" \" << tuples[i].key << \" \" << tuples[i].val << endl;\n    }\n\n    vector<K>  getKeys(){\n        vector<K> temp;\n        for(auto i : tuples){\n            if(i.in_use)    temp.push_back(i.key);\n        }\n        return temp;\n    }\n};\n\ntemplate<typename V>\nclass HT:public HashTable<int,V>{\n};",
            1595471315.2501028,
            100,
            "# 答案正确"
        ]
    ],
    "table_name": "答案"
}