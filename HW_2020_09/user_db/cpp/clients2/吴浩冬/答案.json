{
    "__update_time__": 1594867741.5340085,
    "field_names": [
        "题目名",
        "用户名",
        "答案",
        "提交时间",
        "分数",
        "评语"
    ],
    "field_types": [
        "text",
        "text",
        "text",
        "time",
        "number",
        "text"
    ],
    "foreign_keys": {},
    "primary_keys": [],
    "rows": [
        [
            "测试1",
            "吴浩冬",
            "#include <iostream> \n#include <cstring>\nusing namespace std;\nint main() {\nchar a[20],b[20],c[20];\ncin >> a >> b >> c;\ncout <<c<<\" \"<<b<<\" \"<<a;\n}",
            1587609486.9108646,
            100,
            "# 答案正确"
        ],
        [
            "测试2",
            "吴浩冬",
            "#include <iostream> \n#include <cstring>\nusing namespace std;\nint main() {\nstring s[10];\nstring temp;\nfor(int i = 0;i < 10;i++) {\n\ts[i] = new char[20];\n\tcin >> s[i];\n}\nfor (int i = 0;i < 10;i++) {\n\tfor (int j = i;j < 10;j++) {\n\t\tif(s[i] > s[j]) {\n\t\t    temp = s[i];\n\t\t    s[i] = s[j];\n\t\t    s[j] = temp;\n\t\t}\n\t}\n}\nfor (int i = 0;i < 10;i++) {\n\tcout << s[i] << \" \";\n}\n}",
            1587611841.659593,
            100,
            "# 答案正确"
        ],
        [
            "1.1 (C++)",
            "吴浩冬",
            "#include <iostream>\n#include <cstring>\nusing namespace std;\nclass Matrix5x5 {\n\tpublic:\n\t\tdouble a[5][5];\n\t\tMatrix5x5() {\n\t\t\tmemset(a,0,sizeof(a));\n\t\t}\n\t\tdouble get(int x,int y) {\n\t\t\treturn a[x][y];\n\t\t}\n\t\tvoid set(int x,int y,double value) {\n\t\t\ta[x][y] = value;\n\t\t}\n  Matrix5x5 operator+(Matrix5x5 &p) {\n        Matrix5x5 ans;\n        for (int i = 0; i < 5; ++i) {\n            for (int j = 0; j < 5; ++j) {\n                ans.a[i][j] = p.get(i, j) + a[i][j];\n            }\n        }\n        return ans;\n    }\n};",
            1588162149.484187,
            100,
            "# 答案正确"
        ],
        [
            "1.2 (C++)",
            "吴浩冬",
            "#include <iostream> \n#include <cstring>\nusing namespace std;\nclass School {\n\tpublic:\n\t\tchar name[10] = \"NO_NAME\";\n\t\tint age = 0;\n\t\tvoid setName(char Name[]) {\n\t\t\tstrcpy(name,Name);\n\t\t}\n\t\tvoid setAge(int year) {\n\t\t\tthis->age = year;\n\t\t}\n\t\tvoid operator ++() {\n\t\t\tthis->age++;\n\t\t}\n};",
            1588212894.1013565,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/08",
            "吴浩冬",
            "double & Tensor_get(int dimensions, const int sizes[],double data[], int x0, int x1,int x2, int x3){\n    switch(dimensions){\n        case 1:\n            return data[x0];\n            break;\n        case 2:\n            return data[x1*sizes[0]+x0];\n            break;\n        case 3:\n            return data[x2*sizes[1]*sizes[0]+x1*sizes[0]+x0];\n            break;\n        case 4:\n            return data[x3*sizes[2]*sizes[1]*sizes[0]+x2*sizes[1]*sizes[0]+x1*sizes[0]+x0];\n            break;\n    }\n    return data[0];\n}",
            1588907418.4259958,
            100,
            "# 答案正确"
        ],
        [
            "2.1 (C++)",
            "吴浩冬",
            "#include <iostream>\nusing namespace std; \n\nclass Matrix {\n    private:\n        int rows ;\n        int columns ;\n        double * values;\n\n    public:\n        Matrix(int row , int col);\n\t\t\tvoid print();\n\t\t\t~Matrix();\n};\n\nMatrix::Matrix(int row , int col){\n\trows = row ;\n\tcolumns = col ;\n\tvalues = new double[row*col];\n\tfor(int i = 0 ; i < row*col ; ++i){\n\t\tvalues[i] = 0 ;\n\t}\n}\n\nvoid Matrix::print(){\n\tfor(int i = 0 ; i < rows ; ++i){\n\t\tfor(int j = 0 ; j < columns ; ++j){\n\t\t\tcout<<\"    \"<<values[j];\n\t\t}\n\t\tcout<<endl ;\n\t}\n}\n\nMatrix::~Matrix(){\n\tdelete[]values ;\n}",
            1589422002.6194136,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/14",
            "吴浩冬",
            "#include <iostream>\nusing namespace std;\nvoid Tensor_print(int dimensions, const int sizes[], const double data[]) {\n\tswitch(dimensions) {\n\t\tcase 1:\n\t\t\tcout << \"Tensor of \"<< sizes[0] << endl;\n\t\t\tfor (int i = 0;i < sizes[0];i++) {\n\t\t\t\tcout << data[0] << endl;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tcout << \"Tensor of \"<< sizes[0] << \"x\" << sizes[1] << endl;\n\t\t\tfor (int i = 0;i < sizes[0];i++) {\n\t\t\t\tfor (int j = 0;j < sizes[1];j++) {\n\t\t\t\t\tcout << \"    \" << data[0];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tcout << \"Tensor of \"<< sizes[0] << \"x\" << sizes[1] << \"x\" << sizes[2] << endl;\n\t\t\tfor (int i = 0;i < sizes[0];i++) {\n\t\t\t\tcout << \"data[\" << i <<\"]\"<<endl;\n\t\t\t\tfor (int j = 0;j < sizes[1];j++) {\n\t\t\t\t\tfor (int m = 0;m < sizes[2];m++) {\n\t\t\t\t\t\tcout << \"    \" << data[0];\n\t\t\t\t\t}\n\t\t\t\t\tcout << endl;\n\t\t\t\t} \n\t\t\t}\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tcout << \"Tensor of \" << sizes[0] << \"x\" << sizes[1] << \"x\" << sizes[2] << \"x\" << sizes[3]<<endl;\n\t\t\tfor (int i = 0;i < sizes[0];i++) {\n\t\t\t\tfor (int j = 0;j < sizes[1];j++) {\n\t\t\t\t\tcout << \"data[\" << i <<\"]\"<<\"[\"<<j<<\"]\"<<endl;\n\t\t\t\t\tfor (int m = 0;m < sizes[2];m++) {\n\t\t\t\t\t\tfor (int n = 0;n < sizes[3];n++) {\n\t\t\t\t\t\t\tcout << \"    \"<<data[0];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcout << endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n}",
            1589425000.793375,
            100,
            "# 答案正确"
        ],
        [
            "2.2 (C++)",
            "吴浩冬",
            "#include <iostream>\nusing namespace std ;\n\nclass Matrix{\n    private:\n        int rows ;\n        int columns ;\n        double * values ;\n\n    public:\n        Matrix(int row , int col , double val[]) ;\n        void print() ;\n        ~Matrix() ;\n};\n\nMatrix::Matrix(int row , int col , double val[]){\n\trows = row ;\n\tcolumns = col ;\n\tvalues = new double[row*col] ;\n\tfor(int i = 0 ; i < row*col ; ++i){\n\t\tvalues[i] = val[i] ;\n\t}\n}\n\nvoid Matrix::print(){\n\tfor(int i = 0 ; i < rows ; ++i){\n\t\tfor(int j = 0 ; j < columns ; ++j){\n\t\t\tif(values[j+columns*i]<10){\n\t\t\t\tcout << \"    \" << values[j+columns*i] ;\n\t\t\t}\n\t\t\tif(values[j+columns*i]>9&&values[j+columns*i]<100){\n\t\t\t\tcout << \"   \" << values[j+columns*i] ;\n\t\t\t}\n\t\t\t\n\t\t\tif(values[j+columns*i]>99&&values[j+columns*i]<1000){\n\t\t\t\tcout << \"  \" << values[j+columns*i] ;\n\t\t\t}\n\t\t\t\n\t\t\tif(values[j+columns*i]>9&&values[j+columns*i]==1000){\n\t\t\t\tcout << \" \" << values[j+columns*i] ;\n\t\t\t}\n\t\t}\n\t\tcout << endl ;\n\t}\n}\n\nMatrix::~Matrix(){\n\tdelete[]values ;\n}",
            1589445325.3017745,
            100,
            "# 答案正确"
        ],
        [
            "2.3 (C++)",
            "吴浩冬",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix{\n\tprivate:\n\t\tint rows ;\n\t\tint columns ;\n\t\tdouble * values ;\n\t\n\tpublic:\n\t\tMatrix(int row , int col , double val[]);\n\t\tMatrix(const Matrix & matrix2);\n\t\tvoid print();\n\t\t~Matrix() ;\n};\n\nMatrix::Matrix(int row , int col , double val[]){\n\trows = row ;\n\tcolumns = col ;\n\tvalues = new double[row*col] ;\n\tfor(int i = 0 ; i < row*col ; ++i){\n\t\tvalues[i] = val[i] ;\n\t}\n}\n\nMatrix::Matrix(const Matrix & matrix2){\n\tthis->rows = matrix2.rows ;\n\tthis->columns = matrix2.columns ;\n\tvalues = new double[rows*columns] ;\n\t\n\tfor(int i = 0 ; i < rows*columns ; ++i){\n\t\tthis->values[i] = matrix2.values[i] ;\n\t}\n}\n\nvoid Matrix::print(){\n\tfor(int i = 0 ; i < rows ; ++i){\n\t\tfor(int j = 0 ; j < columns ; ++j){\n\t\t\tcout <<\"    \"<<values[j+i*columns];\n\t\t}\n\t\tcout << endl ;\n\t}\n}\n\nMatrix::~Matrix(){\n\tdelete[]values ;\n}",
            1589446190.6550953,
            100,
            "# 答案正确"
        ],
        [
            "2.5 (C++)",
            "吴浩冬",
            "#include <iostream>\nusing namespace std;\nclass Matrix{\n \tprivate:\n \t\tint rows;\n  \t \tint columns;\n \t  \tdouble * values;\n\tpublic:\n \t\tMatrix(int r, int c);\n \t\tMatrix(int r, int c, double *v);\n \t\tvoid print();\n \t\t~Matrix();\n \t\tMatrix getRow(int row);\n\t\tMatrix getColumn(int column);\n};\n \n Matrix::Matrix(int r, int c,double*v){\n  rows=r;\n  columns=c;\n  values=new double[r*c];\n for (int i = 0; i <r *c ; ++ i){\n  values[i]=v[i];\n } }\n\n\n Matrix::Matrix(int r, int c){\n  rows=r;\n  columns=c;\n  values=new double[r*c];\n for (int i = 0; i <r *c ; ++ i){\n  values[i]=0;\n } }\n \n \n Matrix Matrix::getRow(int row){\n  Matrix a(1, columns);\n  for(int i=0;i<columns;i++){\n   int t=columns*(row-1)+i;\n   a.values[i]=values[t];\n  }\n  return a;\n }\n \n Matrix Matrix::getColumn(int column){\n  Matrix a(rows,1);\n  for(int i=0;i<rows;i++){\n   int t=i*columns+column-1;\n    a.values[i]=values[t];\n  }\n  return a;\n }\nvoid Matrix::print(){\n    int count=0;\n    for(int i =0;i<rows;i++){\n     for(int j=0;j<columns;j++){\n      int n=columns*i+j;\n      if(values[n]!=0)count++;\n  }\n }\n    for (int i = 0; i < rows ; ++ i) {\n        for (int j = 0; j < columns ; ++ j) {\n            int m=columns*i+j;\n            \n           cout << \"    \"<<values[m];\n        \n    }cout << endl;}\n}\n      Matrix::~Matrix(){\n  delete[]values;\n }",
            1589446230.019308,
            100,
            "# 答案正确"
        ],
        [
            "2.6 (C++)",
            "吴浩冬",
            "#include <iostream>\nusing namespace std ;\n#include <stdlib.h>\n\nclass Matrix{\n\tprivate:\n\t\tint rows ;\n\t\tint columns ;\n\t\tdouble * values ;\n\t\n\tpublic:\n\t\tMatrix(int r, int c);\n\t\tMatrix(int row , int col , double val[]);\n\t\tMatrix(const Matrix & matrix2);\n\t\tMatrix concatenateRows(const Matrix & matrix2);\n\t\tMatrix concatenateColumns(const Matrix & matrix2);\n\t\tvoid print();\n\t\t~Matrix() ;\n/*\t\tMatrix getRow(int row);\n\t\tMatrix getColumn(int column);  */\n};\n\nMatrix::Matrix(int row , int col , double val[]){\n\trows = row ;\n\tcolumns = col ;\n\tvalues = new double[row*col] ;\n\tfor(int i = 0 ; i < row*col ; ++i){\n\t\tvalues[i] = val[i] ;\n\t}\n}\n\nMatrix::Matrix(const Matrix & matrix2){\n\tthis->rows = matrix2.rows ;\n\tthis->columns = matrix2.columns ;\n\tvalues = new double[rows*columns] ;\n\t\n\tfor(int i = 0 ; i < rows*columns ; ++i){\n\t\tthis->values[i] = matrix2.values[i] ;\n\t}\n}\n\n\nMatrix::Matrix(int r, int c){\n   rows=r;\n   columns=c;\n \tvalues=new double[r*c];\n\tfor (int i = 0; i <r *c ; ++ i){\n  \t\tvalues[i]=0;\n\t}\n}\n \nMatrix Matrix::concatenateRows(const Matrix & matrix2) {\n\tMatrix t(rows * 2 , columns);\n\tint fa ;\n   for(int i = 0 ; i < rows*2*columns ; ++i){\n\t   if(i<rows*columns){\n\t\t   t.values[i] = values[i] ;\n\t\t   fa = i+1 ;\n\t   }\n\t   else{\n\t\t   t.values[i] = matrix2.values[i-fa] ;\n\t   }\n   }      \n        \n   return t;\n}\n\n\nMatrix Matrix::concatenateColumns(const Matrix & matrix2){\n\tMatrix t(rows, columns*2);\n    int fa=0 ;\n    int c1 = 0 ;\n    int c2 = 0 ;\n    for(int i = 0 ; i < rows*2*columns ; ++i){\n\t    if(i%(columns*2)==0&&i!=0){\n            ++fa ;\n        }\n        if(i<columns*(2*fa+1)){\n            t.values[i] = values[c1];\n            ++c1 ;\n        }\n        if(i>=columns*(2*fa+1)){\n            t.values[i] = matrix2.values[c2];\n            ++c2 ;\n        }\n    }    \n         \n    return t;\n}  \n\nvoid Matrix::print(){\n\tfor(int i = 0 ; i < rows ; ++i){\n\t\tfor(int j = 0 ; j < columns ; ++j){\n\t\t\tcout <<\"    \"<<values[j+i*columns];\n\t\t}\n\t\tcout << endl ;\n\t}\n}\n\nMatrix::~Matrix(){\n\tdelete[]values ;\n}",
            1589446245.1182709,
            100,
            "# 答案正确"
        ],
        [
            "2.9 (C++)",
            "吴浩冬",
            "#include <iostream>\nusing namespace std;\nclass Matrix {\nprivate:\n\tint rows;\n\tint columns;\n\tdouble *values;\npublic:\n\tMatrix(int row,int column){\n           rows=row;\n           columns=column;\n\t\t\t\t values=new double [rows*columns];\n           for(int m=0;m<rows*columns;m++)\n           values[m]=0;\n        }\n \tMatrix(int row, int column, double value[]) {\n\t\trows = row;\n\t\tcolumns = column;\n\t\tvalues = new double[rows*columns];\n\t\tfor (int i = 0;i < rows*columns;i++) {\n\t\t\tvalues[i] = value[i];\n\t\t}\n\t}\n\tMatrix(const Matrix & matrix2) {\n\t\trows = matrix2.rows;\n\t\tcolumns = matrix2.columns;\n\t\tvalues = new double[rows*columns];\n\t\tfor (int m = 0;m < rows*columns;m++) {\n\t\t\tvalues[m] = matrix2.values[m];\n\t\t}\n\t}\n\t~Matrix() {\n\t\tdelete [] values;\n\t}\n\tvoid print() {\n\t\tint cnt = 0;\n\t\tfor (int i = 0;i < this->rows;++i) {\n\t\t\tfor (int j = 0;j < this->columns;j++) {\n\t\t\t\tcout <<\"    \"<<this ->values[cnt];\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tif(i != this->rows) {\n\t\t\t\tputchar('\\n');\n\t\t\t}\n\t\t}\n\t}\n\tMatrix operator + (const Matrix & matrix2) const {\n\t    Matrix t(rows,columns);\n\t    for (int i = 0;i < rows* columns;i++) {\n\t    \tt.values[i] =values[i] + matrix2.values[i];\n\t\t}\n\t\treturn t;\n\t}\n\tMatrix operator + (double value) const {\n\t    Matrix t(rows,columns);\n\t    for (int i = 0;i < rows*columns;i++) {\n\t    \tt.values[i] = this->values[i] + value;\n\t\t}\n\t\treturn t;\n\t}\n\tMatrix operator - (const Matrix & matrix2) const {\n\t\tMatrix t(rows,columns);\n\t\tfor(int i=0;i<rows*columns;i++){\n\t\t\tt.values[i]=values[i]-matrix2.values[i];\n\t\t}\n\t\treturn t;\n\t}\n\tMatrix operator - (double value) const{\n\t\t Matrix t(rows,columns);\n\t\t for(int i=0;i<rows*columns;i++){\n\t\t\t t.values[i]=values[i]-value;\n\t\t }\n\t\t return t;\n}\n}; ",
            1590031912.3417659,
            100,
            "# 答案正确"
        ],
        [
            "2.4 (C++)",
            "吴浩冬",
            "#include <iostream>\n#include<iomanip>\nusing namespace std;\n \nclass Matrix{\n\t private:\n        int rows = 0;\n        int columns = 0;\n        double * values;\n        \n    public:\n\t\t\tMatrix(int row,int column){\n           rows=row;\n           columns=column;\n\t\t\t\t values=new double [rows*columns];\n           for(int m=0;m<rows*columns;m++)\n           values[m]=0;\n        }\n        Matrix(int row,int column,double value[]){\n           rows=row;\n           columns=column;\n           values=new double [rows*columns];\n           for(int m=0;m<rows*columns;m++)\n           values[m]=value[m]; \n        }\n        Matrix const operator =(const Matrix & matrix){\n             delete [] values;\n\t\t\trows=matrix.rows;\n\t\t\tcolumns=matrix.columns;\n\t\t\tvalues=new double[rows*columns];\n\t\t\t for(int m=0;m<rows*columns;m++)\n           values[m]=matrix.values[m]; \n        }\n        ~Matrix(){\n           delete  [] values;\n         }\n\t\t\n\t\tvoid print(){\n\t\t\tint cnt = 0;\n\t\t\tfor (int i = 0; i < this->rows; ++ i) {\n\t\t\t\tfor(int j = 0; j < this->columns; j ++){\n\t\t\t\t\tcout <<\"    \"<<this->values[cnt];\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t\tif(i!=this->rows)putchar('\\n');\n\t\t\t}\n\t\t\t\n\t\t}\n\t   void set(int row, int column, double value){\n\t\t\t\tthis->values[(row-1)*columns+column-1] = value;\n\t\t   return;\n\t   }\n\t   \n\t  \n};",
            1590035534.399088,
            100,
            "# 答案正确"
        ],
        [
            "2.7 (C++)",
            "吴浩冬",
            "#include <iostream>\n#include<iomanip>\nusing namespace std;\n \nclass Matrix{\n\t private:\n        int rows = 0;\n        int columns = 0;\n        double * values;\n        \n    public:\n\tMatrix reshape(int row, int column) {\n\t\tdouble* t=new double[rows*columns];\n\t\tint cnt=0;\n\t\tfor(int i=0;i<columns;i++){\n\t\t\tfor(int j=0;j<rows;j++){\n\t\t\t\tt[cnt]=values[j*columns+i];\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tcnt=0;\n\t\tMatrix g(row,column);\n\t\tfor(int i=0;i<column;i++){\n\t\t\tfor(int j=0;j<row;j++){\n\t\t\t\tg.values[j*column+i]=t[cnt];\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tdelete [] t;\n\t\treturn g;\n\t}\n\t\t\tMatrix(int row,int column){\n           rows=row;\n           columns=column;\n\t\t\t\t values=new double [rows*columns];\n           for(int m=0;m<rows*columns;m++)\n           values[m]=0;\n        }\n        Matrix(int row,int column,double value[]){\n           rows=row;\n           columns=column;\n           values=new double [rows*columns];\n           for(int m=0;m<rows*columns;m++)\n           values[m]=value[m]; \n        }\n\t Matrix(const Matrix & matrix2){\n\t\trows=matrix2.rows;\n\t\t columns=matrix2.columns;\n\t\t values=new double[rows*columns];\n\t\t for(int m=0;m<rows*columns;m++)\n           values[m]=matrix2.values[m];\n\t\t  \n\t }\n      \n        ~Matrix(){\n           delete  [] values;\n         }\n\t\t\n\t\tvoid print(){\n\t\t\tint cnt = 0;\n\t\t\tfor (int i = 0; i < this->rows; ++ i) {\n\t\t\t\tfor(int j = 0; j < this->columns; j ++){\n\t\t\t\t\tcout <<\"    \"<<this->values[cnt];\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t\tif(i!=this->rows)putchar('\\n');\n\t\t\t}\n\t\t\t\n\t\t}\n\t   void set(int row, int column, double value){\n\t\t\t\tthis->values[(row-1)*columns+column-1] = value;\n\t\t   return;\n\t   }\n\t   \n\t  \n};",
            1590035569.4576843,
            100,
            "# 答案正确"
        ],
        [
            "2.8 (C++)",
            "吴浩冬",
            "#include <iostream>\n#include<iomanip>\nusing namespace std;\n \nclass Matrix{\n\t private:\n        int rows = 0;\n        int columns = 0;\n        double * values;\n        \n    public:\n\tMatrix transpose(){\n\t\tMatrix t(columns,rows);\n\t\tfor(int i=0;i<rows;i++){\n\t\t\tfor(int j=0;j<columns;j++){\n\t\t\t\tt.values[j*rows+i]=values[i*columns+j];\n\t\t\t}\n\t\t}\n\t\treturn t;\n\t}\n\tMatrix reshape(int row, int column) {\n\t\tdouble* t=new double[rows*columns];\n\t\tint cnt=0;\n\t\tfor(int i=0;i<columns;i++){\n\t\t\tfor(int j=0;j<rows;j++){\n\t\t\t\tt[cnt]=values[j*columns+i];\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tcnt=0;\n\t\tMatrix g(row,column);\n\t\tfor(int i=0;i<column;i++){\n\t\t\tfor(int j=0;j<row;j++){\n\t\t\t\tg.values[j*column+i]=t[cnt];\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tdelete [] t;\n\t\treturn g;\n\t}\n\t\t\tMatrix(int row,int column){\n           rows=row;\n           columns=column;\n\t\t\t\t values=new double [rows*columns];\n           for(int m=0;m<rows*columns;m++)\n           values[m]=0;\n        }\n        Matrix(int row,int column,double value[]){\n           rows=row;\n           columns=column;\n           values=new double [rows*columns];\n           for(int m=0;m<rows*columns;m++)\n           values[m]=value[m]; \n        }\n\t Matrix(const Matrix & matrix2){\n\t\trows=matrix2.rows;\n\t\t columns=matrix2.columns;\n\t\t values=new double[rows*columns];\n\t\t for(int m=0;m<rows*columns;m++)\n           values[m]=matrix2.values[m];\n\t\t  \n\t }\n      \n        ~Matrix(){\n           delete  [] values;\n         }\n\t\t\n\t\tvoid print(){\n\t\t\tint cnt = 0;\n\t\t\tfor (int i = 0; i < this->rows; ++ i) {\n\t\t\t\tfor(int j = 0; j < this->columns; j ++){\n\t\t\t\t\tcout <<\"    \"<<this->values[cnt];\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t\tif(i!=this->rows)putchar('\\n');\n\t\t\t}\n\t\t\t\n\t\t}\n\t   void set(int row, int column, double value){\n\t\t\t\tthis->values[(row-1)*columns+column-1] = value;\n\t\t   return;\n\t   }\n\t   \n\t  \n};",
            1590035584.934616,
            100,
            "# 答案正确"
        ],
        [
            "2.10 (C++)",
            "吴浩冬",
            "#include <iostream>\n#include<iomanip>\nusing namespace std;\n \nclass Matrix{\n\t private:\n        int rows = 0;\n        int columns = 0;\n        double * values;\n        \n    public:\n\tMatrix transpose(){\n\t\tMatrix t(columns,rows);\n\t\tfor(int i=0;i<rows;i++){\n\t\t\tfor(int j=0;j<columns;j++){\n\t\t\t\tt.values[j*rows+i]=values[i*columns+j];\n\t\t\t}\n\t\t}\n\t\treturn t;\n\t}\n\tMatrix operator * (const Matrix & matrix2) const{\n\t\tMatrix t(rows,matrix2.columns);\n\t\tfor(int i=0;i<rows;i++){\n\t\t\tfor(int j=0;j<matrix2.columns;j++){\n\t\t\t\tfor(int k=0;k<columns;k++){\n\t\t\t\t\tt.values[i*matrix2.columns+j]+=values[i*columns+k]*matrix2.values[k*matrix2.columns+j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn t;\n\t}\n\t Matrix operator * (double value) const{\n\t\t Matrix t(rows,columns);\n\t\t for(int i=0;i<rows*columns;i++){\n\t\t\t t.values[i]=values[i]*value;\n\t\t }\n\t\t return t;\n}\n\tMatrix reshape(int row, int column) {\n\t\tdouble* t=new double[rows*columns];\n\t\tint cnt=0;\n\t\tfor(int i=0;i<columns;i++){\n\t\t\tfor(int j=0;j<rows;j++){\n\t\t\t\tt[cnt]=values[j*columns+i];\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tcnt=0;\n\t\tMatrix g(row,column);\n\t\tfor(int i=0;i<column;i++){\n\t\t\tfor(int j=0;j<row;j++){\n\t\t\t\tg.values[j*column+i]=t[cnt];\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tdelete [] t;\n\t\treturn g;\n\t}\n\t\t\tMatrix(int row,int column){\n           rows=row;\n           columns=column;\n\t\t\t\t values=new double [rows*columns];\n           for(int m=0;m<rows*columns;m++)\n           values[m]=0;\n        }\n        Matrix(int row,int column,double value[]){\n           rows=row;\n           columns=column;\n           values=new double [rows*columns];\n           for(int m=0;m<rows*columns;m++)\n           values[m]=value[m]; \n        }\n\t Matrix(const Matrix & matrix2){\n\t\trows=matrix2.rows;\n\t\t columns=matrix2.columns;\n\t\t values=new double[rows*columns];\n\t\t for(int m=0;m<rows*columns;m++)\n           values[m]=matrix2.values[m];\n\t\t  \n\t }\n      \n        ~Matrix(){\n           delete  [] values;\n         }\n\t\t\n\t\tvoid print(){\n\t\t\tint cnt = 0;\n\t\t\tfor (int i = 0; i < this->rows; ++ i) {\n\t\t\t\tfor(int j = 0; j < this->columns; j ++){\n\t\t\t\t\tcout <<\"    \"<<this->values[cnt];\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t\tif(i!=this->rows)putchar('\\n');\n\t\t\t}\n\t\t\t\n\t\t}\n\t   void set(int row, int column, double value){\n\t\t\t\tthis->values[(row-1)*columns+column-1] = value;\n\t\t   return;\n\t   }\n\t   \n\t  \n};",
            1590035609.5864704,
            100,
            "# 答案正确"
        ],
        [
            "2.11 (C++)",
            "吴浩冬",
            "#include <iostream>\n#include<iomanip>\nusing namespace std;\n \nclass Matrix{\n\t private:\n        int rows = 0;\n        int columns = 0;\n        double * values;\n        \n    public:\n Matrix max() const{\n\t if(rows>1){\n\t\t Matrix t(1,columns);\n\t\t for(int i=0;i<rows;i++){\n\t\t\t for(int j=0;j<columns;j++){\n\t\t\t\t if(t.values[j]<values[i*columns+j]){\n\t\t\t\t\t t.values[j]=values[i*columns+j];\n\t\t\t\t }\n\t\t\t }\n\t\t }\n\t\t return t;\n\t }else{\n\t\t Matrix t(1,1);\n\t\t for(int i=0;i<columns;i++){\n\t\t\t if(t.values[0]<values[i]){\n\t\t\t\t t.values[0]=values[i];\n\t\t\t }\n\t\t }\n\t\t return t;\n\t }\n }\n\t Matrix min() const{\n\t if(rows>1){\n\t\t Matrix t(1,columns);\n\t\t for(int i=0;i<columns;i++){\n\t\t\t t.values[i]=100000;\n\t\t }\n\t\t for(int i=0;i<rows;i++){\n\t\t\t int flag=1;\n\t\t\t for(int j=0;j<columns;j++){\n\t\t\t\t \n\t\t\t\t if(t.values[j]>values[i*columns+j]||flag==1){\n\t\t\t\t\t t.values[j]=values[i*columns+j];\n\t\t\t\t\t flag=0;\n\t\t\t\t }\n\t\t\t }\n\t\t }\n\t\t return t;\n\t }else{\n\t\t Matrix t(1,1);\n\t\t t.values[0]=1000000;\n\t\t for(int i=0;i<columns;i++){\n\t\t\t if(t.values[0]>values[i]){\n\t\t\t\t t.values[0]=values[i];\n\t\t\t }\n\t\t }\n\t\t return t;\n\t }\n }\n\tMatrix sum() const{\n\t if(rows>1){\n\t\t Matrix t(1,columns);\n\t\t for(int i=0;i<rows;i++){\n\t\t\t for(int j=0;j<columns;j++){\n\t\t\t\t \n\t\t\t\t\t t.values[j]+=values[i*columns+j];\n\t\t\t\t \n\t\t\t }\n\t\t }\n\t\t return t;\n\t }else{\n\t\t Matrix t(1,1);\n\t\t for(int i=0;i<columns;i++){\n\t\t\t\n\t\t\t\t t.values[0]+=values[i];\n\t\t\t \n\t\t }\n\t\t return t;\n\t }\n }\n\n\n\n\tMatrix transpose(){\n\t\tMatrix t(columns,rows);\n\t\tfor(int i=0;i<rows;i++){\n\t\t\tfor(int j=0;j<columns;j++){\n\t\t\t\tt.values[j*rows+i]=values[i*columns+j];\n\t\t\t}\n\t\t}\n\t\treturn t;\n\t}\n\tMatrix operator * (const Matrix & matrix2) const{\n\t\tMatrix t(rows,matrix2.columns);\n\t\tfor(int i=0;i<rows;i++){\n\t\t\tfor(int j=0;j<matrix2.columns;j++){\n\t\t\t\tfor(int k=0;k<columns;k++){\n\t\t\t\t\tt.values[i*matrix2.columns+j]+=values[i*columns+k]*matrix2.values[k*matrix2.columns+j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn t;\n\t}\n\t Matrix operator * (double value) const{\n\t\t Matrix t(rows,columns);\n\t\t for(int i=0;i<rows*columns;i++){\n\t\t\t t.values[i]=values[i]*value;\n\t\t }\n\t\t return t;\n}\n\tMatrix reshape(int row, int column) {\n\t\tdouble* t=new double[rows*columns];\n\t\tint cnt=0;\n\t\tfor(int i=0;i<columns;i++){\n\t\t\tfor(int j=0;j<rows;j++){\n\t\t\t\tt[cnt]=values[j*columns+i];\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tcnt=0;\n\t\tMatrix g(row,column);\n\t\tfor(int i=0;i<column;i++){\n\t\t\tfor(int j=0;j<row;j++){\n\t\t\t\tg.values[j*column+i]=t[cnt];\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tdelete [] t;\n\t\treturn g;\n\t}\n\t\t\tMatrix(int row,int column){\n           rows=row;\n           columns=column;\n\t\t\t\t values=new double [rows*columns];\n           for(int m=0;m<rows*columns;m++)\n           values[m]=0;\n        }\n        Matrix(int row,int column,double value[]){\n           rows=row;\n           columns=column;\n           values=new double [rows*columns];\n           for(int m=0;m<rows*columns;m++)\n           values[m]=value[m]; \n        }\n\t Matrix(const Matrix & matrix2){\n\t\trows=matrix2.rows;\n\t\t columns=matrix2.columns;\n\t\t values=new double[rows*columns];\n\t\t for(int m=0;m<rows*columns;m++)\n           values[m]=matrix2.values[m];\n\t\t  \n\t }\n      \n        ~Matrix(){\n           delete  [] values;\n         }\n\t\t\n\t\tvoid print(){\n\t\t\tint cnt = 0;\n\t\t\tfor (int i = 0; i < this->rows; ++ i) {\n\t\t\t\tfor(int j = 0; j < this->columns; j ++){\n\t\t\t\t\tcout <<\"    \"<<this->values[cnt];\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t\tif(i!=this->rows)putchar('\\n');\n\t\t\t}\n\t\t\t\n\t\t}\n\t   void set(int row, int column, double value){\n\t\t\t\tthis->values[(row-1)*columns+column-1] = value;\n\t\t   return;\n\t   }\n\t   \n\t  \n};",
            1590035655.0137863,
            94,
            "# 答案不正确\n\n# 随机输入:\n5 7\n33 29 32 14 91 43 9 99 89 95 33 47 24 83 76 90 44 97 99 36 32 13 48 63 43 12 20 3 30 82 30 2 19 97 28 \n\n# 参考答案:\n    33    29    32    14    91    43    9\n    99    89    95    33    47    24    83\n    76    90    44    97    99    36    32\n    13    48    63    43    12    20    3\n    30    82    30    2    19    97    28\n\n    99    90    95    97    99    97    83\n\n    99\n\n    13    29    30    2    12    20    3\n\n    2\n\n    251    338    264    189    268    220    155\n\n    1685\n\n\n\n# 我的答案:\n    33    29    32    14    91    43    9\n    99    89    95    33    47    24    83\n    76    90    44    97    99    36    32\n    13    48    63    43    12    20    3\n    30    82    30    2    19    97    28\n\n    99    90    95    97    99    97    83\n\n    99\n\n    30    29    30    2    12    20    3\n\n    2\n\n    251    338    264    189    268    220    155\n\n    1685\n\n"
        ],
        [
            "6.1 (C++)",
            "吴浩冬",
            "#include<string.h>\ntemplate<typename T>\nclass Matrix\n{\n\tprivate:\n\tint row;\n\tint col;\n\tT * buffer;\n\tpublic:\n\tMatrix(int x,int y){\n\t\trow=x;\n\t\tcol=y;\n\t\tbuffer=new T[row*col];\n\t\tmemset(buffer,0,sizeof(T)*row*col);\n\t}\n\tMatrix(int x,int y,const T*val){\n\t\trow=x;\n\t\tcol=y;\n\t\tbuffer=new T[row*col];\n\t\tfor(int i=0;i<row*col;i++){\n\t\t\tbuffer[i]=val[i];\n\t\t}\n\t}\n\t~Matrix(){\n\t\tdelete [] buffer;\n\t}\n\tMatrix(const Matrix<T>&ma){\n\t\tif(buffer!=NULL)delete []buffer;\n\t\trow=ma.row;\n\t\tcol=ma.col;\n\t\tbuffer=new T[row*col];\n\t\tfor(int i= 0;i<row*col;i++){\n\t\t\tbuffer[i]=ma.buffer[i];\n\t\t}\n\t}\n\t\n\tvoid print(){\n\t\tfor(int i=0;i<row;i++){\n\t\t\tfor(int j=0;j<col;j++){\n\t\t\t\tcout<<\"    \";\n\t\t\t\tcout<<buffer[i*col+j];\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t}\n\tMatrix &operator =(const Matrix&ma){\n\t\tif(buffer!=NULL) delete[]buffer;\n\t\trow=ma.row;\n\t\tcol=ma.col;\n\t\tbuffer=new T[ma.row*ma.col];\n\t\tfor(int i=0;i<row*col;i++){\n\t\t\tbuffer[i]=ma.buffer[i];\n\t\t}\n\t\treturn *this;\n\t}\n\tT &get(int x,int y){\n\t\treturn buffer[(x-1)*col+y-1];\n\t}\n};",
            1590635164.7070708,
            100,
            "# 答案正确"
        ],
        [
            "6.2 (C++)",
            "吴浩冬",
            "#include<string.h>\n#include<iostream>\nusing namespace std;\ntemplate<typename T>\nclass Matrix\n{\n\tprivate:\n\tint row;\n\tint col;\n\tT * buffer;\n\tpublic:\n\tMatrix(int x,int y){\n\t\trow=x;\n\t\tcol=y;\n\t\tbuffer=new T[row*col];\n\t\tmemset(buffer,0,sizeof(T)*row*col);\n\t}\n\tMatrix(int x,int y,const T*val){\n\t\trow=x;\n\t\tcol=y;\n\t\tbuffer=new T[row*col];\n\t\tfor(int i=0;i<row*col;i++){\n\t\t\tbuffer[i]=val[i];\n\t\t}\n\t}\n\t~Matrix(){\n\t\tdelete [] buffer;\n\t}\n\tMatrix(const Matrix<T>&ma){\n\t\tif(buffer!=NULL)delete []buffer;\n\t\trow=ma.row;\n\t\tcol=ma.col;\n\t\tbuffer=new T[row*col];\n\t\tfor(int i= 0;i<row*col;i++){\n\t\t\tbuffer[i]=ma.buffer[i];\n\t\t}\n\t}\n\t\n\tvoid print(){\n\t\tfor(int i=0;i<row;i++){\n\t\t\tfor(int j=0;j<col;j++){\n\t\t\t\tcout<<\"    \";\n\t\t\t\tcout<<buffer[i*col+j];\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t\t\n\t\t}\n\t}\n\tMatrix &operator =(const Matrix&ma){\n\t\tif(buffer!=NULL) delete[]buffer;\n\t\trow=ma.row;\n\t\tcol=ma.col;\n\t\tbuffer=new T[ma.row*ma.col];\n\t\tfor(int i=0;i<row*col;i++){\n\t\t\tbuffer[i]=ma.buffer[i];\n\t\t}\n\t\treturn *this;\n\t}\n\tT &get(int x,int y){\n\t\treturn buffer[(x-1)*col+y-1];\n\t}\n};",
            1590635188.2277067,
            100,
            "# 答案正确"
        ],
        [
            "6.3 (C++)",
            "吴浩冬",
            "#include <vector>\n#include <iostream>\n#include <string.h>\n#define INF 0x7f7f7f7f\nusing namespace std;\n\ntemplate<typename T>\nclass Matrix\n{\n\t private:\n \tint rows;\n \tint columns;\n \t vector<T> values;\n public:\n \tMatrix(int x,int y){\n  \t\trows=x;\n  \t\tcolumns=y;\n\t\tfor(int i =0 ; i < rows*columns; i++)values.push_back(0);\n  \t\t\n \t}\n\t Matrix(int x,int y,const vector<T>val){\n \t\t rows=x;\n  \t\tcolumns=y;\n  \t\tfor(int i=0;i<rows*columns;i++){\n   \t\tvalues.push_back(val[i]);\n \t\t }\n \t}\n\t ~Matrix(){\n \t\t values.clear();\n \t}\n\t Matrix(const Matrix<T>&mat){\n  \t\t values.clear();\n  \t\trows=mat.rows;\n  \t\tcolumns=mat.columns;\n  \n  \t\tfor(int i=0;i<rows*columns;i++){\n   \t\tvalues.push_back(mat.values[i]);\n \t\t }\n \t}\n \n void print(){\n  \tfor(int i=0;i<rows;i++){\n   for(int j=0;j<columns;j++){\n    cout<<\"    \";\n    cout<<values[i*columns+j];\n   }\n  \t\t cout<<endl;\n \t }\n }\n\t Matrix &operator =(const Matrix&mat){\n \t\t\tvalues.clear();\n  \t\trows = mat.rows;\n  \t\tcolumns=mat.columns;\n  \t\n  \t\tfor(int i=0;i<rows*columns;i++){\n   \t\tvalues.push_back(mat.values[i]);\n \t\t }\n \t\t return *this;\n \t}\n\t T &get(int x,int y){\n  \t\treturn values[(x-1)*columns+y-1];\n \t}\n \t\n \tMatrix transpose() {\n\t\t   vector<T> newarr;\n\t\t   \t\tfor(int i = 0; i < columns; i++){\n\t\t\t\t\tfor(int j = 0; j < rows; j++){\n\t\t\t\t\t\tnewarr.push_back(values[j*(columns)+i]) ;\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t   \t\treturn Matrix(columns, rows, newarr);\n\t   }\n\t   \n\t   //坐标表示法 (row-1)*columns+column-1\n\t   Matrix  operator * (const Matrix<T> & matrix2) const{\n\t\t  vector<T> arr;\n\t\t  for(int i = 0; i < rows*columns; i++)arr.push_back(0);\n\t\t   for(int i = 0; i < this->rows; i ++){\n\t\t\t\tfor(int j = 0; j <  matrix2.columns; j ++){\n\t\t\t\t\tfor (int l = 0, m = 0; l < matrix2.rows; l++,m++){\n       arr[i*matrix2.columns+j] += this->values[i*this->columns+l] * matrix2.values[m * matrix2.columns+j];\n                }\n\t\t\t\t}\n\t\t   }\n\t\t    Matrix<T> newmatrix(rows, matrix2.columns, arr);\n\t\t   return newmatrix;\n\t   }\n\t\tMatrix  operator * (T value)  const{\n\t\t\tvector<T> arr;\n\t\t  for(int i = 0; i < rows*columns; i++)arr.push_back(0);\n\t\t\tfor(int i = 0; i < rows*columns; i++){\n\t\t\t\tarr[i] = value * values[i];\n\t\t\t}\n\t\t\treturn Matrix<T>(rows, columns, arr);\n\t\t}\n\t\tMatrix  operator + (T value)  const{\n\t\t\tvector<T> arr;\n\t\t  for(int i = 0; i < rows*columns; i++)arr.push_back(0);\n\t\t\tfor(int i = 0; i < rows*columns; i++){\n\t\t\t\tarr[i] = value + values[i];\n\t\t\t}\n\t\t\treturn Matrix<T>(rows, columns, arr);\n\t\t}\n\t\tMatrix operator + (const Matrix<T> & matrix2) const{\n\t\tvector<T> arr;\n\t\t  for(int i = 0; i < rows*columns; i++)arr.push_back(0);\n\t\t  for(int i = 0; i < rows*columns; i++)arr[i] = values[i]+matrix2.values[i];\n\t\t  return Matrix<T> (rows,columns,arr);\n\t\t}\n\t\t\tMatrix  operator - (T value)  const{\n\t\t\tvector<T> arr;\n\t\t  for(int i = 0; i < rows*columns; i++)arr.push_back(0);\n\t\t\tfor(int i = 0; i < rows*columns; i++){\n\t\t\t\tarr[i] =  values[i] - value;\n\t\t\t}\n\t\t\treturn Matrix<T>(rows, columns, arr);\n\t\t}\n\t\tMatrix operator - (const Matrix<T> & matrix2) const{\n\t\tvector<T> arr;\n\t\t  for(int i = 0; i < rows*columns; i++)arr.push_back(0);\n\t\t  for(int i = 0; i < rows*columns; i++)arr[i] = values[i]-matrix2.values[i];\n\t\t  return Matrix<T> (rows,columns,arr);\n\t\t}\n\t\t\n\t\tMatrix max() const{\n\t\t\t \tif(rows>1){\n\t\t\t\t\t\tvector<T> newarr;\n\t\t  for(int i = 0; i < rows*columns; i++)newarr.push_back(0);\n\t\t\t\t\tint max,maxrows;\n\t\t\t \t\tfor(int i = 0; i < this->columns;i++){\n\t\t\t\t\t\tmax = 0;\n\t\t\t\t\t\tmaxrows = 0;\n\t\t\t\t\t\tfor(int j = 0 ;j < this->rows; j++){\n\t\t\t\t\t\t\tif(values[columns*j+i]>max){\n\t\t\t\t\t\t\t\tmax = values[columns*j+i];\n\t\t\t\t\t\t\t\tmaxrows = j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnewarr[i] = values[this->columns*maxrows + i];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn  Matrix(1,columns,newarr);\n\t\t\t\t}\n\t\t\t\tif(rows==1){\n\t\t\t\t\tint max = 0;\n\t\t\t\t\tfor(int i = 0; i < columns; i++){\n\t\t\t\t\t\tif(values[i] > max)max = values[i];\n\t\t\t\t\t}\n\t\t\t\t\tvector<T> newarr;\n\t\t\t\t\tnewarr.push_back(0);\n\t\t\t\t\tnewarr[0] = max;\n\t\t\t \t\treturn Matrix(1,1,newarr);\n\t\t\t\t}\n\t\t\t \t\n\t\t  }\n\t\t  \n\t\t  Matrix min() const{\n\t\t\t  if(rows>1){\n\t\t\t\t\t\tvector<T> newarr;\n\t\t  for(int i = 0; i < rows*columns; i++)newarr.push_back(0);\n\t\t\t\t\tint min,minrows;\n\t\t\t \t\tfor(int i = 0; i < this->columns;i++){\n\t\t\t\t\t\tmin = INF;\n\t\t\t\t\t\tminrows = 0;\n\t\t\t\t\t\tfor(int j = 0 ;j < this->rows; j++){\n\t\t\t\t\t\t\tif(values[columns*j+i]<min){\n\t\t\t\t\t\t\t\tmin = values[columns*j+i];\n\t\t\t\t\t\t\t\tminrows = j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnewarr[i] = this->values[this->columns*minrows + i];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn  Matrix(1,columns,newarr);\n\t\t\t\t}\n\t\t\t\tif(rows==1){\n\t\t\t\t\tint min = INF;\n\t\t\t\t\tfor(int i = 0; i < columns; i++){\n\t\t\t\t\t\tif(values[i] < min)min = values[i];\n\t\t\t\t\t}\n\t\t\t\tvector<T> newarr;\n\t\t\t\t\tnewarr.push_back(0);\n\t\t\t\t\tnewarr[0] = min;\n\t\t\t \t\treturn Matrix(1,1,newarr);\n\t\t\t\t}\n\t\t  }\n\t\t   Matrix sum() const {\n\t\t\t\tif(rows>1){\n\t\t\t\t\tvector<T> newarr;\n\t\t  for(int i = 0; i < rows*columns; i++)newarr.push_back(0);\n\t\t\t\t\tint sum;\n\t\t\t \t\tfor(int i = 0; i < this->columns;i++){\n\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\tfor(int j = 0 ;j < this->rows; j++){\n\t\t\t\t\t\t\t\tsum += values[columns*j+i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnewarr[i] = sum;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn  Matrix(1,columns,newarr);\n\t\t\t\t}\n\t\t\t  if(rows==1){\n\t\t\t\t\tint sum = 0;\n\t\t\t\t\tfor(int i = 0; i < columns; i++){\n\t\t\t\t\t\tsum += values[i];\n\t\t\t\t\t}\n\t\t\t\t\tvector<T> newarr;\n\t\t\t\t\tnewarr.push_back(0);\n\t\t\t\t\tnewarr[0] = sum;\n\t\t\t \t\treturn Matrix(1,1,newarr);\n\t\t\t\t}\n\t\t  }\n\t\t   Matrix concatenateRows(const Matrix & matrix2)const {\n\t\t   \tvector<T> newarr;\n\t\t  for(int i = 0; i < rows*columns*2; i++)newarr.push_back(0);\n\t\t   for(int i = 0 ; i < this->rows*this->columns; i++){\n\t\t\t\tnewarr[i] = this->values[i];\n\t\t   }\n\t\t    for(int i = 0 ; i < this->rows*this->columns; i++){\n\t\t\tnewarr[i+this->rows*this->columns] = matrix2.values[i];\n\t\t   }\n\t\t\treturn Matrix(rows*2,columns,newarr);\n\t   }\n\t   Matrix concatenateColumns(const Matrix & matrix2) const{\n\t\t   \tvector<T> newarr;\n\t\t  for(int i = 0; i < rows*columns*2; i++)newarr.push_back(0);\n\t\t   int cnt = 0;\n\t\t   int cnt1 = 0, cnt2 = 0;\n\t\t \tfor(int i = 0; i < this->rows; i++){\n\t\t\t\tfor(int j = 0; j < this->columns; j++, cnt1++,cnt++){\n\t\t\t\t\tnewarr[cnt] = this->values[cnt1];\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < this->columns; j++,cnt2++,cnt++){\n\t\t\t\t\tnewarr[cnt] = matrix2.values[cnt2];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Matrix(rows,columns*2,newarr);\n\t   }\n\t   Matrix getRow(int row){\n\t   \t\t vector<T> newarr;\n\t\t  for(int i = 0; i < columns; i++)newarr.push_back(0);\n\t\t  for(int i = 0; i < columns; i++)newarr[i] = values[(row-1)*columns+i];\n\t\t\treturn Matrix(1, this->columns, newarr);\n\t\t}\n\t\tMatrix getColumn(int column){\n\t\t\t vector<T> newarr;\n\t\t  for(int i = 0; i < rows; i++)newarr.push_back(0);\n\t\t\tfor(int i = 0; i < this->rows; i ++){\n\t\t\t\tnewarr[i] = this->values[column-1+ i*this->columns];\n\t\t\t}\n\t\t\treturn Matrix(this->rows,1, newarr);\n\t\t}\n\t\tMatrix reshape(int x,int y){\n\t\t\tvector<T> newarr;\n\t\t\tfor(int i = 0; i < rows*columns; i++)newarr.push_back(0);\n\t\t\tvector<T> temp;\n\t\t\tfor(int i = 0; i < columns; i++){\n\t\t\t\tfor(int j = 0; j < rows; j++){\n\t\t\t\t\ttemp.push_back(values[columns*j+i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint cnt = 0;\n\t\t\tfor(int i = 0; i < y; i++){\n\t\t\t\tfor(int j = 0; j < x; j++,cnt++){\n\t\t\t\t\tnewarr[y*j+i] = temp[cnt];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Matrix<T>(columns, rows, newarr);\n\t\t}\n};",
            1590662470.0851321,
            100,
            "# 答案正确"
        ],
        [
            "7.1 (C++)",
            "吴浩冬",
            "#include<cmath>\nclass Triangle:public GeometricObject\n{\n\tprivate:\n\t\tdouble a;\n\t\tdouble b;\n\t\tdouble c;\n\tpublic:\n\t\tTriangle(){\n\t\t\ta=1.0;\n\t\t\tb-1.0;\n\t\t\tc=1.0;\n\t\t}\n\t\tTriangle(double a1,double b1,double c1){\n\t\t\ta=a1;\n\t\t\tb=b1;\n\t\t\tc=c1;\n\t\t}\n\t\tdouble getSide1(){\n\t\t\treturn a;\n\t\t}\n\t\tdouble getSide2(){\n\t\t\treturn b;\n\t\t}\n\t\tdouble getSide3(){\n\t\t\treturn c;\n\t\t}\n\t\tdouble getArea(){\n\t\t\tdouble s= (a + b + c) / 2;\n\t\t\treturn sqrt(s * (s - a) * (s - b) * (s - c));\n\t\t}\n\t\tdouble getPerimeter(){\n\t\t\treturn a+b+c;\n\t\t}\n}; ",
            1591236605.347683,
            100,
            "# 答案正确"
        ],
        [
            "7.3 (C++)",
            "吴浩冬",
            "template <typename A, typename R>\nvector<R> map2(const vector<A> & x,const vector<A> & y, R (*map_func)(const A &,const A &)) {\n\tvector<R> res;\n\tfor (int i = 0; i < x.size(); ++ i)\n\t\tres.push_back(map_func(x[i],y[i]));\n\treturn res;\n}\ntemplate <typename A, typename R>\nvector<R> map2(const vector<A> & x,int c, R (*map_func)(const A &,const A &)) {\n\tvector<R> res;\n\tfor (int i = 0; i < x.size(); ++ i)\n\t\tres.push_back(map_func(x[i],c));\n\treturn res;\n}",
            1591236654.9918532,
            100,
            "# 答案正确"
        ],
        [
            "7.2 (C++)",
            "吴浩冬",
            "#include <iostream>\n#include <string>\n#include <vector>\n#include<cstring>\nusing namespace std;\nvector <string> split(const string& src){\n\tvector <string> strs;\n\t int lastPosition = 0,index = -1;\n\tint len=1;\n    while (-1 != (index = src.find(' ',lastPosition)))\n    {\n        strs.push_back(src.substr(lastPosition,index - lastPosition));\n        lastPosition = index + len;\n    }\n    string lastString = src.substr(lastPosition);\n    if (!lastString.empty())\n        strs.push_back(lastString);\n    return strs;\n}",
            1591237869.4562025,
            100,
            "# 答案正确"
        ],
        [
            "8.1 (C++)",
            "吴浩冬",
            "class Full : public Matrix\n{\nprivate:\nint rows;\nint cols;\ndouble *val;\npublic :\n Full(int row, int column){\n rows=row;\n cols=column;\n val=new double[rows*cols];\n for(int i=0;i<rows*cols;i++){\n val[i]=0;\n }\n }\n int size(int dimension) const\n\n\t{\n\n\t\tif(dimension == 1) return rows;\n\n\t\tif(dimension == 2) return cols;\n\n\t}\n Full(int row, int column, double values[]){\n  rows=row;\n cols=column;\n val=new double[rows*cols];\n for(int i=0;i<rows*cols;i++){\n val[i]=values[i];\n }\n }\n\n double get(int row, int column) const {\n return val[row*cols+column];\n }\n void set(int row, int column, double value){\n val[(row-1)*cols+column-1]=value;\n }\n Full(const Matrix & m2){\n\n\n rows=m2.size(1);\n cols=m2.size(2);\nval=new double[rows*cols];\n for(int i=0;i<rows;i++){\nfor(int j=0;j<cols;j++){\nval[i*cols+j]=m2.get(i,j);\n}\n\n }}\n ~Full(){\n delete[]val;\n }\n void print()const{\nfor(int i=0;i<rows;i++){\nfor(int j=0;j<cols;j++){\nprintf(\"%.0lf    \",val[i*cols+j]);\n}\nprintf(\"\\n\");}\n}\nMatrix & operator = (const Matrix & m2) {\ndelete []val;\nrows=m2.size(1);\ncols=m2.size(2);\n val=new double[rows*cols];\n for(int i=0;i<rows;i++){\nfor(int j=0;j<cols;j++){\nval[i*cols+j]=m2.get(i,j);\n}\n\n }\n }\n};",
            1591843460.7455435,
            100,
            "# 答案正确"
        ],
        [
            "8.3 (C++)",
            "吴浩冬",
            "#include<vector>\n#include<algorithm>\n#include <iostream> \nusing namespace std; \n\nbool Comp1(const Entry &a,const Entry &b)\n{\n\treturn a.row<b.row;\n}\nbool Comp2(const Entry &a,const Entry &b)\n{\n\treturn (a.row==b.row&&a.column<b.column);\n}\nclass Sparse : public Matrix\n\n{\n\nprivate:\n\n\tint _rows, _columns;\n\n\tvector<Entry> entry;\n\npublic:\n\n\tSparse(int rows, int column)\n\n\t{\n\n\t\t_rows = rows;\n\n\t\t_columns = column;\n\n\t\tentry = vector<Entry>();\n\n\t}\n\n\tint size(int dimension) const\n\n\t{\n\n\t\tif(dimension == 1) return _rows;\n\n\t\tif(dimension == 2) return _columns;\n\n\t}\n\n\tvoid set(int row, int column, double value)\n\n\t{\n\n\t\tEntry e;\n\n\t\te.row = row;\n\n\t\te.column = column;\n\n\t\te.value = value;\n\n\t\tentry.push_back(e);\n\n\t}\n\n\tdouble get(int row, int column) const\n\n\t{\n\n\t\tfor(int i=0; i < entry.size();i++)\n\n\t\t{\n\n\t\t\tif(entry[i].row == row\n\n\t\t\t\t && entry[i].column == column ){\n\n\t\t\t\treturn entry[i].value;\t\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tvoid print()\n\n\t{\n\n\t\tfor(int i=0; i < entry.size();i++)\n\n\t\t{\n\n\t\t\tcout<<\"(\"<<entry[i].row<<\",\"<<entry[i].column<<\",\"\n\n\t\t\t\t<<entry[i].value<<\")\\n\";\n\n\t\t}\n\n\t}\n\n\tSparse operator + (Sparse & sparse2)\n\n\t{\n\n\t\tSparse s(_rows, _columns);\n\n\t\tfor(int i=0; i < this->entry.size(); i++)\n\t\t{\n\t\t\tfor(int j = 0 ;j< sparse2.entry.size(); j++)\n\n\t\t\t{\n\n\t\t\t\tif(this->entry[i].row == sparse2.entry[j].row \n\n\t\t\t\t\t&& this->entry[i].column == sparse2.entry[j].column){\n\n\t\t\t\t\tEntry e;\n\n\t\t\t\t\te.row = sparse2.entry[j].row;\n\n\t\t\t\t\te.column =  sparse2.entry[j].column;\n\n\t\t\t\t\te.value = this->entry[i].value + sparse2.entry[j].value;\n\t\t\t\t\tif(e.value)\n\t\t\t\t\ts.entry.push_back(e);\n\t\t\t\t\tthis->entry[i].value = 0;\n\t\t\t\t\tsparse2.entry[j].value = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tfor(int i=0; i < this->entry.size(); i++)\n\n\t\t{\n\n\t\t\tEntry e;\n\n\t\t\te.row = this->entry[i].row;\n\n\t\t\te.column = this->entry[i].column;\n\n\t\t\te.value = this->entry[i].value;\n\n\t\t\tif(e.value)\n\n\t\t\t\ts.entry.push_back(e);\n\n\t\t}\n\n\t\tfor(int i=0; i < sparse2.entry.size(); i++)\n\n\t\t{\n\n\t\t\tEntry e;\n\n\t\t\te.row = sparse2.entry[i].row;\n\n\t\t\te.column = sparse2.entry[i].column;\n\n\t\t\te.value = sparse2.entry[i].value;\n\n\t\t\tif(e.value)\n\n\t\t\t\ts.entry.push_back(e);\n\n\t\t}\n\n\t\tsort(s.entry.begin(),s.entry.end(),Comp1);\n\n\t\tsort(s.entry.begin(),s.entry.end(),Comp2);\n\n\t\treturn s;\n\t}\n\n};\n",
            1591843511.174453,
            100,
            "# 答案正确"
        ],
        [
            "8.4 (C++)",
            "吴浩冬",
            "#include<vector>\n#include<algorithm>\n#include <iostream> \nusing namespace std; \n\nbool Comp1(const Entry &a,const Entry &b)\n{\n\treturn a.row<b.row;\n}\nbool Comp2(const Entry &a,const Entry &b)\n{\n\treturn (a.row==b.row&&a.column<b.column);\n}\nclass Sparse : public Matrix\n\n{\n\nprivate:\n\n\tint _rows, _columns;\n\n\tvector<Entry> entry;\n\npublic:\n\tint size(int dimension) const\n\n\t{\n\n\t\tif(dimension == 1) return _rows;\n\n\t\tif(dimension == 2) return _columns;\n\n\t}\n\n\tSparse(int rows, int column)\n\n\t{\n\n\t\t_rows = rows;\n\n\t\t_columns = column;\n\n\t\tentry = vector<Entry>();\n\n\t}\n\n\n\n\tvoid set(int row, int column, double value)\n\n\t{\n\n\t\tEntry e;\n\n\t\te.row = row;\n\n\t\te.column = column;\n\n\t\te.value = value;\n\n\t\tentry.push_back(e);\n\n\t}\n\n\tdouble get(int row, int column) const\n\n\t{\n\n\t\tfor(int i=0; i < entry.size();i++)\n\n\t\t{\n\n\t\t\tif(entry[i].row == row\n\n\t\t\t\t && entry[i].column == column ){\n\n\t\t\t\treturn entry[i].value;\t\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tvoid print()\n\n\t{\n\n\t\tfor(int i=0; i < entry.size();i++)\n\n\t\t{\n\n\t\t\tcout<<\"(\"<<entry[i].row<<\",\"<<entry[i].column<<\",\"\n\n\t\t\t\t<<entry[i].value<<\")\\n\";\n\n\t\t}\n\n\t}\n\n\t\n\tSparse operator * (Sparse & s2)\n\t{\n\tSparse s(_rows, s2._columns);\n\tfor(int i=0; i < this->entry.size(); i++)\n\t\t{\n\t\tfor(int j=0; j<s2.entry.size(); j++)\n\n\t\t{\n\t\t\tif(this->entry[i].column == s2.entry[j].row){\n\t\t\tEntry e;\n\n\t\t\te.row = this->entry[i].row;\n\n\t\t\te.column = s2.entry[j].column;\n\n\t\t\te.value = s2.entry[j].value*this->entry[i].value;\n\t\t\tif(e.value){\n\t\t\t\tint flag=1;\n\t\t\t\tfor(int k=0;k<s.entry.size();k++){\n\t\t\t\tif(e.row==s.entry[k].row&&e.column==s.entry[k].column){\n\t\t\t\ts.entry[k].value+=e.value;\n\t\t\t\tflag=0;\n\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag){\n\t\t\t\ts.entry.push_back(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\t}\n\n\n\t\t}\n\t\t\n\t\t\t\t\n\n\t\t}\n\n\n\t\tsort(s.entry.begin(),s.entry.end(),Comp1);\n\n\t\tsort(s.entry.begin(),s.entry.end(),Comp2);\n\n\t\treturn s;\t\n\n\t\t}\n\t\n};\n",
            1591843535.5511324,
            100,
            "# 答案正确"
        ],
        [
            "8.5 (C++)",
            "吴浩冬",
            "#include <assert.h>\nclass Point3D :public Point2D\n{\nprivate:\ndouble z;\npublic:\nPoint3D(){\nsetX(0);\nsetY(0);\nz=0;\n}\nPoint3D(double a,double b,double c){\nsetX(a);\nsetY(b);\nz=c;\n}\ndouble getX(){\nreturn Point2D::getX();\n}\ndouble getY(){\nreturn Point2D::getY();\n}\ndouble getZ(){\nreturn z;\n}\nvirtual double distance(Point2D & point2){\nPoint3D * p2=dynamic_cast<Point3D *>(&point2);\ndouble dx = getX() - point2.getX();\ndouble dy =getY() - point2.getY();\ndouble dz=getZ()-p2->getZ();\n\t\treturn sqrt(dx * dx + dy * dy+dz * dz);\n}\n};",
            1591843783.6639254,
            100,
            "# 答案正确"
        ],
        [
            "10.2 (C++)",
            "吴浩冬",
            "catch(out_of_range &ex){\n\tcout<<\"caught: out_of_range\"<<endl;\n}",
            1593656990.2417092,
            100,
            "# 答案正确"
        ],
        [
            "10.1 (C++)",
            "吴浩冬",
            "#include <stdexcept>\nclass MatrixSizesDoNotMatchException{\n \n};\ndouble Matrix::get(int row, int column) const{\n    return this->elements[(row-1)*columns+column-1];\n}\nvoid Matrix::set(int row, int column, double value){\n \n this->elements[(row-1)*columns+column-1]=value;\n}\nMatrix Matrix::operator + (const Matrix & matrix2) const{\n if(this->rows!=matrix2.rows||this->columns!=matrix2.columns) {\n  MatrixSizesDoNotMatchException a;\n  throw a;\n }\n Matrix ret(this->rows,this->columns);\n for(int i=0;i<this->rows*this->columns;i++){\n  ret.elements[i]=this->elements[i]+matrix2.elements[i];\n }\n return ret;\n}",
            1593657026.6296809,
            100,
            "# 答案正确"
        ],
        [
            "15.1 (C++)",
            "吴浩冬",
            "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\nclass Table\n{\n    friend ostream & operator << (ostream & out, const Table & table);\n    \n\t  private:\n \t   int row_size;\n      vector< vector <string> > tab;\n      vector<string> col;\n\t\n    public:\n  \t Table()\n    {\n        tab.resize(1);\n     \t\t\n    }\n    void addCol(string s)\n    {\n        col.push_back(s); \n    }\n    vector<string>& operator[](int n)\n    {  \n\t \t  \n        if (tab.size() == n + 1 ) \n\t\t{\n\t\t\tvector<string> temp;\n\t\t\ttab.push_back(temp);\n\t\t}\n        return tab[n];\n    }\n    string json()const\n    {\n        string s = \"{\\n    headers: [\";\n        for(int i = 0; i < col.size(); i++)\n        {\n            s = s + (\"'\" + col[i]+ \"'\" + \",\");\n        }\n        s=s+\"],\\n\";\n        s=s+\"    rows: [\\n\";\n       for(int i = 0 ; i< tab.size()-1; i++)\n        {\n            string a = \"       [\";\n            for (int j = 0; j < tab[i].size(); j++)\n            {\n                a = a + (\"'\" + tab[i][j] + \"',\"); \n            }\n            a=a+\"],\\n\";\n            s =s + a;\n        }\n        s = s + \"    ],\\n}\"; \n        return s; \n    }\n    \n};",
            1594262253.4685898,
            100,
            "# 答案正确"
        ],
        [
            "2020-07-09 LAB",
            "吴浩冬",
            "#include <vector>\n#include <iostream>\nusing namespace std;\nint val = 0;\nclass Integer{\n\tpublic:\n\tfriend ostream &operator<< ( ostream &output, Integer &c) {\n\t\tc.num += val;\n\t\toutput << c.num;\n\t\t\n\t\treturn output;\n\t}\n};\n\tstatic void increase_all(Integer a) {\n\t\tval = a.num;\n\t};",
            1594264868.8062449,
            0,
            "In file included from main.cpp:1:0:\nsource.cpp: In function ‘std::ostream& operator<<(std::ostream&, Integer&)’:\nsource.cpp:8:5: error: ‘class Integer’ has no member named ‘num’\n   c.num += val;\n     ^\nsource.cpp:9:15: error: ‘class Integer’ has no member named ‘num’\n   output << c.num;\n               ^\nsource.cpp: In function ‘void increase_all(Integer)’:\nsource.cpp:15:11: error: ‘class Integer’ has no member named ‘num’\n   val = a.num;\n           ^\nmain.cpp: In function ‘int main()’:\nmain.cpp:8:14: error: conversion from ‘int’ to non-scalar type ‘Integer’ requested\n  Integer x = 10;\n              ^\nmain.cpp:10:6: error: no match for ‘operator>>’ (operand types are ‘std::istream {aka std::basic_istream<char>}’ and ‘Integer’)\n  cin >> y;\n      ^\nIn file included from /usr/include/c++/5/iostream:40:0,\n                 from source.cpp:2,\n                 from main.cpp:1:\n/usr/include/c++/5/istream:120:7: note: candidate: std::basic_istream<_CharT, _Traits>::__istream_type& std::basic_istream<_CharT, _Traits>::operator>>(std::basic_istream<_CharT, _Traits>::__istream_type& (*)(std::basic_istream<_CharT, _Traits>::__istream_type&)) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_istream<_CharT, _Traits>::__istream_type = std::basic_istream<char>]\n       operator>>(__istream_type& (*__pf)(__istream_type&))\n       ^\n/usr/include/c++/5/istream:120:7: note:   no known conversion for argument 1 from ‘Integer’ to ‘std::basic_istream<char>::__istream_type& (*)(std::basic_istream<char>::__istream_type&) {aka std::basic_istream<char>& (*)(std::basic_istream<char>&)}’\n/usr/include/c++/5/istream:124:7: note: candidate: std::basic_istream<_CharT, _Traits>::__istream_type& std::basic_istream<_CharT, _Traits>::operator>>(std::basic_istream<_CharT, _Traits>::__ios_type& (*)(std::basic_istream<_CharT, _Traits>::__ios_type&)) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_istream<_CharT, _Traits>::__istream_type = std::basic_istream<char>; std::basic_istream<_CharT, _Traits>::__ios_type = std::basic_ios<char>]\n       operator>>(__ios_type& (*__pf)(__ios_type&))\n       ^\n/usr/include/c++/5/istream:124:7: note:   no known conversion for argument 1 from ‘Integer’ to ‘std::basic_istream<char>::__ios_type& (*)(std::basic_istream<char>::__ios_type&) {aka std::basic_ios<char>& (*)(std::basic_ios<char>&)}’\n/usr/include/c++/5/istream:131:7: note: candidate: std::basic_istream<_CharT, _Traits>::__istream_type& std::basic_istream<_CharT, _Traits>::operator>>(std::ios_base& (*)(std::ios_base&)) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_istream<_CharT, _Traits>::__istream_type = std::basic_istream<char>]\n       operator>>(ios_base& (*__pf)(ios_base&))\n       ^\n/usr/include/c++/5/istream:131:7: note:   no known conversion for argument 1 from ‘Integer’ to ‘std::ios_base& (*)(std::ios_base&)’\n/usr/include/c++/5/istream:168:7: note: candidate: std::basic_istream<_CharT, _Traits>::__istream_type& std::basic_istream<_CharT, _Traits>::operator>>(bool&) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_istream<_CharT, _Traits>::__istream_type = std::basic_istream<char>]\n       operator>>(bool& __n)\n       ^\n/usr/include/c++/5/istream:168:7: note:   no known conversion for argument 1 from ‘Integer’ to ‘bool&’\n/usr/include/c++/5/istream:172:7: note: candidate: std::basic_istream<_CharT, _Traits>& std::basic_istream<_CharT, _Traits>::operator>>(short int&) [with _CharT = char; _Traits = std::char_traits<char>]\n       operator>>(short& __n);\n       ^\n/usr/include/c++/5/istream:172:7: note:   no known conversion for argument 1 from ‘Integer’ to ‘short int&’\n/usr/include/c++/5/istream:175:7: note: candidate: std::basic_istream<_CharT, _Traits>::__istream_type& std::basic_istream<_CharT, _Traits>::operator>>(short unsigned int&) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_istream<_CharT, _Traits>::__istream_type = std::basic_istream<char>]\n       operator>>(unsigned short& __n)\n       ^\n/usr/include/c++/5/istream:175:7: note:   no known conversion for argument 1 from ‘Integer’ to ‘short unsigned int&’\n/usr/include/c++/5/istream:179:7: note: candidate: std::basic_istream<_CharT, _Traits>& std::basic_istream<_CharT, _Traits>::operator>>(int&) [with _CharT = char; _Traits = std::char_traits<char>]\n       operator>>(int& __n);\n       ^\n/usr/include/c++/5/istream:179:7: note:   no known conversion for argument 1 from ‘Integer’ to ‘int&’\n/usr/include/c++/5/istream:182:7: note: candidate: std::basic_istream<_CharT, _Traits>::__istream_type& std::basic_istream<_CharT, _Traits>::operator>>(unsigned int&) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_istream<_CharT, _Traits>::__istream_type = std::basic_istream<char>]\n       operator>>(unsigned int& __n)\n       ^\n/usr/include/c++/5/istream:182:7: note:   no known conversion for argument 1 from ‘Integer’ to ‘unsigned int&’\n/usr/include/c++/5/istream:186:7: note: candidate: std::basic_istream<_CharT, _Traits>::__istream_type& std::basic_istream<_CharT, _Traits>::operator>>(long int&) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_istream<_CharT, _Traits>::__istream_type = std::basic_istream<char>]\n       operator>>(long& __n)\n       ^\n/usr/include/c++/5/istream:186:7: note:   no known conversion for argument 1 from ‘Integer’ to ‘long int&’\n/usr/include/c++/5/istream:190:7: note: candidate: std::basic_istream<_CharT, _Traits>::__istream_type& std::basic_istream<_CharT, _Traits>::operator>>(long unsigned int&) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_istream<_CharT, _Traits>::__istream_type = std::basic_istream<char>]\n       operator>>(unsigned long& __n)\n       ^\n/usr/include/c++/5/istream:190:7: note:   no known conversion for argument 1 from ‘Integer’ to ‘long unsigned int&’\n/usr/include/c++/5/istream:195:7: note: candidate: std::basic_istream<_CharT, _Traits>::__istream_type& std::basic_istream<_CharT, _Traits>::operator>>(long long int&) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_istream<_CharT, _Traits>::__istream_type = std::basic_istream<char>]\n       operator>>(long long& __n)\n       ^\n/usr/include/c++/5/istream:195:7: note:   no known conversion for argument 1 from ‘Integer’ to ‘long long int&’\n/usr/include/c++/5/istream:199:7: note: candidate: std::basic_istream<_CharT, _Traits>::__istream_type& std::basic_istream<_CharT, _Traits>::operator>>(long long unsigned int&) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_istream<_CharT, _Traits>::__istream_type = std::basic_istream<char>]\n       operator>>(unsigned long long& __n)\n       ^\n/usr/include/c++/5/istream:199:7: note:   no known conversion for argument 1 from ‘Integer’ to ‘long long unsigned int&’\n/usr/include/c++/5/istream:214:7: note: candidate: std::basic_istream<_CharT, _Traits>::__istream_type& std::basic_istream<_CharT, _Traits>::operator>>(float&) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_istream<_CharT, _Traits>::__istream_type = std::basic_istream<char>]\n       operator>>(float& __f)\n       ^\n/usr/include/c++/5/istream:214:7: note:   no known conversion for argument 1 from ‘Integer’ to ‘float&’\n/usr/include/c++/5/istream:218:7: note: candidate: std::basic_istream<_CharT, _Traits>::__istream_type& std::basic_istream<_CharT, _Traits>::operator>>(double&) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_istream<_CharT, _Traits>::__istream_type = std::basic_istream<char>]\n       operator>>(double& __f)\n       ^\n/usr/include/c++/5/istream:218:7: note:   no known conversion for argument 1 from ‘Integer’ to ‘double&’\n/usr/include/c++/5/istream:222:7: note: candidate: std::basic_istream<_CharT, _Traits>::__istream_type& std::basic_istream<_CharT, _Traits>::operator>>(long double&) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_istream<_CharT, _Traits>::__istream_type = std::basic_istream<char>]\n       operator>>(long double& __f)\n       ^\n/usr/include/c++/5/istream:222:7: note:   no known conversion for argument 1 from ‘Integer’ to ‘long double&’\n/usr/include/c++/5/istream:235:7: note: candidate: std::basic_istream<_CharT, _Traits>::__istream_type& std::basic_istream<_CharT, _Traits>::operator>>(void*&) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_istream<_CharT, _Traits>::__istream_type = std::basic_istream<char>]\n       operator>>(void*& __p)\n       ^\n/usr/include/c++/5/istream:235:7: note:   no known conversion for argument 1 from ‘Integer’ to ‘void*&’\n/usr/include/c++/5/istream:259:7: note: candidate: std::basic_istream<_CharT, _Traits>& std::basic_istream<_CharT, _Traits>::operator>>(std::basic_istream<_CharT, _Traits>::__streambuf_type*) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_istream<_CharT, _Traits>::__streambuf_type = std::basic_streambuf<char>]\n       operator>>(__streambuf_type* __sb);\n       ^\n/usr/include/c++/5/istream:259:7: note:   no known conversion for argument 1 from ‘Integer’ to ‘std::basic_istream<char>::__streambuf_type* {aka std::basic_streambuf<char>*}’\nIn file included from /usr/include/c++/5/string:53:0,\n                 from /usr/include/c++/5/bits/locale_classes.h:40,\n                 from /usr/include/c++/5/bits/ios_base.h:41,\n                 from /usr/include/c++/5/ios:42,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from source.cpp:2,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/basic_string.tcc:1441:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> std::basic_istream<_CharT, _Traits>& std::operator>>(std::basic_istream<_CharT, _Traits>&, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)\n     operator>>(basic_istream<_CharT, _Traits>& __in,\n     ^\n/usr/include/c++/5/bits/basic_string.tcc:1441:5: note:   template argument deduction/substitution failed:\nmain.cpp:10:9: note:   ‘Integer’ is not derived from ‘std::__cxx11::basic_string<_CharT, _Traits, _Alloc>’\n  cin >> y;\n         ^\nIn file included from /usr/include/c++/5/istream:934:0,\n                 from /usr/include/c++/5/iostream:40,\n                 from source.cpp:2,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/istream.tcc:955:5: note: candidate: template<class _CharT2, class _Traits2> std::basic_istream<_CharT, _Traits>& std::operator>>(std::basic_istream<_CharT, _Traits>&, _CharT2*)\n     operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s)\n     ^\n/usr/include/c++/5/bits/istream.tcc:955:5: note:   template argument deduction/substitution failed:\nmain.cpp:10:9: note:   mismatched types ‘_CharT2*’ and ‘Integer’\n  cin >> y;\n         ^\nIn file included from /usr/include/c++/5/istream:934:0,\n                 from /usr/include/c++/5/iostream:40,\n                 from source.cpp:2,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/istream.tcc:923:5: note: candidate: template<class _CharT, class _Traits> std::basic_istream<_CharT, _Traits>& std::operator>>(std::basic_istream<_CharT, _Traits>&, _CharT&)\n     operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c)\n     ^\n/usr/include/c++/5/bits/istream.tcc:923:5: note:   template argument deduction/substitution failed:\nmain.cpp:10:9: note:   deduced conflicting types for parameter ‘_CharT’ (‘char’ and ‘Integer’)\n  cin >> y;\n         ^\nIn file included from /usr/include/c++/5/iostream:40:0,\n                 from source.cpp:2,\n                 from main.cpp:1:\n/usr/include/c++/5/istream:756:5: note: candidate: template<class _Traits> std::basic_istream<char, _Traits>& std::operator>>(std::basic_istream<char, _Traits>&, unsigned char&)\n     operator>>(basic_istream<char, _Traits>& __in, unsigned char& __c)\n     ^\n/usr/include/c++/5/istream:756:5: note:   template argument deduction/substitution failed:\nmain.cpp:10:9: note:   cannot convert ‘y’ (type ‘Integer’) to type ‘unsigned char&’\n  cin >> y;\n         ^\nIn file included from /usr/include/c++/5/iostream:40:0,\n                 from source.cpp:2,\n                 from main.cpp:1:\n/usr/include/c++/5/istream:761:5: note: candidate: template<class _Traits> std::basic_istream<char, _Traits>& std::operator>>(std::basic_istream<char, _Traits>&, signed char&)\n     operator>>(basic_istream<char, _Traits>& __in, signed char& __c)\n     ^\n/usr/include/c++/5/istream:761:5: note:   template argument deduction/substitution failed:\nmain.cpp:10:9: note:   cannot convert ‘y’ (type ‘Integer’) to type ‘signed char&’\n  cin >> y;\n         ^\nIn file included from /usr/include/c++/5/iostream:40:0,\n                 from source.cpp:2,\n                 from main.cpp:1:\n/usr/include/c++/5/istream:803:5: note: candidate: template<class _Traits> std::basic_istream<char, _Traits>& std::operator>>(std::basic_istream<char, _Traits>&, unsigned char*)\n     operator>>(basic_istream<char, _Traits>& __in, unsigned char* __s)\n     ^\n/usr/include/c++/5/istream:803:5: note:   template argument deduction/substitution failed:\nmain.cpp:10:9: note:   cannot convert ‘y’ (type ‘Integer’) to type ‘unsigned char*’\n  cin >> y;\n         ^\nIn file included from /usr/include/c++/5/iostream:40:0,\n                 from source.cpp:2,\n                 from main.cpp:1:\n/usr/include/c++/5/istream:808:5: note: candidate: template<class _Traits> std::basic_istream<char, _Traits>& std::operator>>(std::basic_istream<char, _Traits>&, signed char*)\n     operator>>(basic_istream<char, _Traits>& __in, signed char* __s)\n     ^\n/usr/include/c++/5/istream:808:5: note:   template argument deduction/substitution failed:\nmain.cpp:10:9: note:   cannot convert ‘y’ (type ‘Integer’) to type ‘signed char*’\n  cin >> y;\n         ^\nIn file included from /usr/include/c++/5/iostream:40:0,\n                 from source.cpp:2,\n                 from main.cpp:1:\n/usr/include/c++/5/istream:924:5: note: candidate: std::basic_istream<_CharT, _Traits>& std::operator>>(std::basic_istream<_CharT, _Traits>&&, _Tp&) [with _CharT = char; _Traits = std::char_traits<char>; _Tp = Integer] <near match>\n     operator>>(basic_istream<_CharT, _Traits>&& __is, _Tp& __x)\n     ^\n/usr/include/c++/5/istream:924:5: note:   conversion of argument 1 would be ill-formed:\nmain.cpp:10:9: error: cannot bind ‘std::istream {aka std::basic_istream<char>}’ lvalue to ‘std::basic_istream<char>&&’\n  cin >> y;\n         ^\nmain.cpp:12:2: error: ‘increase_all’ is not a member of ‘Integer’\n  Integer::increase_all(100);\n  ^\nmain.cpp:14:2: error: ‘increase_all’ is not a member of ‘Integer’\n  Integer::increase_all(y);\n  ^\n"
        ],
        [
            "A.2 (C++)",
            "吴浩冬",
            "template <typename E>\nvoid LinkedList<E>::removeAll(const E & e){\n\twhile(contains(e)){\n\t\tremoveFirstOccurrence(e);\n\t}\n}\n",
            1594867740.7229931,
            100,
            "# 答案正确"
        ]
    ],
    "table_name": "答案"
}