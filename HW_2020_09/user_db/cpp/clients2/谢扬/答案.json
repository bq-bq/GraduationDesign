{
    "__update_time__": 1595475596.5948057,
    "field_names": [
        "题目名",
        "用户名",
        "答案",
        "提交时间",
        "分数",
        "评语"
    ],
    "field_types": [
        "text",
        "text",
        "text",
        "time",
        "number",
        "text"
    ],
    "foreign_keys": {},
    "primary_keys": [],
    "rows": [
        [
            "测试1",
            "谢扬",
            "#include <iostream>\n#include <string>\n\nusing std::cin;\nusing std::cout;\nusing std::endl;\nusing std::string;\n//using std::array;\nconst int ArSize=3;\nint main()\n{\n\tstring str[ArSize];\n\t//array<string,ArSize>str;\n\tint i;\n\tfor ( i=0; i<ArSize; ++i)\n\t\tcin>>str[i];\n\tfor (i=ArSize-1;i>=0;--i)\n\t\tcout<<str[i]<<\" \";\n\tcout<<endl;\n\treturn 0;\n}",
            1587563151.3082948,
            100,
            "# 答案正确"
        ],
        [
            "测试2",
            "谢扬",
            "#include <iostream>\n#include <string>\nusing std::cin;\nusing std::cout;\nusing std::endl;\nusing std::string;\nconst int ArSize=10;\nint main()\n{\nstring str[ArSize];\nstring temp;\nint i;\nfor (i=0; i<ArSize;++i)\n{\ncin>>str[i];\n}\nfor (i=1;i<ArSize;++i)\n{\nfor(int j=i;j>0;--j)\n{\nif(str[j]<str[j-1]){temp=str[j-1];str[j-1]=str[j];str[j]=temp;}\n}\n}\nfor (i=0; i<ArSize;++i)\n{\ncout<<str[i]<<\" \";\n}\ncout<<endl;\nreturn 0;\n}",
            1587608915.0034142,
            100,
            "# 答案正确"
        ],
        [
            "1.1 (C++)",
            "谢扬",
            "class Matrix5x5\n{\n\tprivate:\n\tdouble**matrix;\n\tconst int ArSize=5;\n\tpublic:\n\tMatrix5x5();\n\tMatrix5x5(double*const *m1,double*const*m2);\n    double get(int, int)const;\n    void set(int, int, double);\n    Matrix5x5 operator + (const Matrix5x5 &)const;\n    Matrix5x5&operator=(const Matrix5x5&);\n\t~Matrix5x5();\n};\nMatrix5x5::Matrix5x5()\n{\n\tmatrix=new double*[ArSize];\n\tfor (int i=0;i<ArSize;++i)\n\t{\n\t\tmatrix[i]=new double[ArSize]{};\n\t}\n}\nMatrix5x5::Matrix5x5(double*const *m1,double*const*m2)\n{\n\tmatrix=new double*[ArSize];\n\tfor (int i=0;i<ArSize;++i)\n\t{\n\t\tmatrix[i]=new double[ArSize]{};\n\t}\n\tfor (int row=0;row<ArSize;++row)\n\t{\n\t\tfor (int col=0;col<ArSize;++col)\n\t\t{\n\t\t\tmatrix[row][col]=m1[row][col]+m2[row][col];\n\t\t}\n\t}\n\t\n}\nMatrix5x5::~Matrix5x5()\n{\n\tfor (int i=0;i<ArSize;++i)\n\t{\n\t\tdelete[]matrix[i];\n\t}\n\tdelete[]matrix;\n}\ndouble Matrix5x5::get(int i, int j)const\n{\n\treturn matrix[i][j];\n}\n\nvoid Matrix5x5::set(int row, int col, double value)\n{\n\tmatrix[row][col]=value;\n}\nMatrix5x5 Matrix5x5::operator + (const Matrix5x5 & m)const\n{\n\treturn Matrix5x5(matrix,m.matrix);\n}\nMatrix5x5&Matrix5x5::operator=(const Matrix5x5&m)\n{\n\tif(this==&m)return *this;\n\tfor (int row=0;row<ArSize;++row)\n\t{\n\t\tfor (int col=0;col<ArSize;++col)\n\t\t{\n\t\t\tmatrix[row][col]=m.matrix[row][col];\n\t\t}\n\t}\n\treturn *this;\n}",
            1587699371.763365,
            100,
            "# 答案正确"
        ],
        [
            "1.2 (C++)",
            "谢扬",
            "#include<string>\nusing std::string;\nclass School\n{\n\tpublic:\n\tint age;\n\tstring name;\n\tSchool():age(0),name(\"NO_NAME\"){}\n\t\n    void setName(char m_name[]){name=m_name;}\n    void setAge(int year){age=year;}\n    void operator ++ ()\n\t{++age;}\n};",
            1588212700.3856373,
            100,
            "# 答案正确"
        ],
        [
            "2.1 (C++)",
            "谢扬",
            "#include<iostream>\nusing std::cin;\nusing std::cout;\nusing std::endl;\nclass Matrix\n{\n\tprivate:\n\t\tint rows,columns;\n\t\tdouble*values;//析构函数/复制构造函数/重载赋值运算府\n\tpublic:\n\tMatrix(int m_rows=0, int m_columns=0):rows(m_rows),columns(m_columns)\n\t{columns<0?(values=nullptr):(values=new double[columns]{});}\n\tbool print();\n\t~Matrix();\n};\nbool Matrix::print()\n{\n\tif(rows<0||columns<0)return false;\n\tfor(int row=0;row<rows;++row)\n\t{\n\t\tfor(int column=0;column<columns;++column)\n\t\tcout<<values[column]<<\"    \";\n\t\tcout<<endl;\n\t}\n\treturn true;\n}\nMatrix::~Matrix()\n{\n\tdelete[]values;\n}\n",
            1588826919.46084,
            100,
            "# 答案正确"
        ],
        [
            "2.2 (C++)",
            "谢扬",
            "#include<iostream>\nusing std::cin;\nusing std::cout;\nusing std::endl;\nclass Matrix\n{\n\tprivate:\n\t\tint rows,columns;\n\t\tdouble*values;//析构函数/复制构造函数/重载赋值运算府\n\tpublic:\n\tMatrix(int m_rows=0, int m_columns=0,double*m_values=nullptr):rows(m_rows),columns(m_columns),values(m_values)\n\t{if(columns<0||rows<0)values=nullptr;}\n\tbool print();\n};\nbool Matrix::print()\n{\n\tif(rows<0||columns<0)return false;\n\tfor(int row=0;row<rows*columns;++row)\n\t{cout.width(5);\n\t\tcout<<values[row];\n\t\tif(row%columns==columns-1)cout<<endl;\n\t}\n\treturn true;\n}\n",
            1588827965.5655549,
            100,
            "# 答案正确"
        ],
        [
            "2.3 (C++)",
            "谢扬",
            "#include<iostream>\nusing std::cin;\nusing std::cout;\nusing std::endl;\nclass Matrix\n{\n\tprivate:\n\t\tint rows,columns;\n\t\tdouble*values;//析构函数/复制构造函数/重载赋值运算府\n\tpublic:\n\tMatrix(int m_rows=0, int m_columns=0,double*m_values=nullptr):rows(m_rows),columns(m_columns),values(m_values)\n\t{if(columns<0||rows<0)values=nullptr;}\n\tbool print();\n};\nbool Matrix::print()\n{\n\tif(rows<0||columns<0)return false;\n\tfor(int row=0;row<rows*columns;++row)\n\t{\n\t\tcout<<values[row]<<\"    \";\n\t\tif(row%columns==columns-1)cout<<endl;\n\t}\n\treturn true;\n}\n",
            1588829198.4498596,
            100,
            "# 答案正确"
        ],
        [
            "2.5 (C++)",
            "谢扬",
            "#include<iostream>\nusing std::cin;\nusing std::cout;\nusing std::endl;\nclass Matrix  \n{\n\tprivate:\n\t\tint rows,columns;\n\t\tdouble*values;\n\t\t//析构函数/复制构造函数/重载赋值运算府\n\tpublic:\n\tMatrix(int m_rows=0, int m_columns=0,double*m_values=nullptr);\n\tMatrix(const Matrix&copy);\n\t~Matrix(){delete[]values;}\n\tbool print();\n\tMatrix getRow(int row);\n\tMatrix getColumn(int col);\n};\nMatrix::Matrix(int m_rows, int m_columns,double*m_values):rows(m_rows),columns(m_columns)\n{\n\tif(rows>0&&columns>0)\n\t{values=new double[rows*columns];\n\tfor(int i=0;i<rows*columns;++i)values[i]=m_values[i];\n\t }\n\telse values=nullptr;\n}\nMatrix::Matrix(const Matrix&copy):rows(copy.rows),columns(copy.columns)\n{\n\tvalues=new double[rows*columns];\n\tfor(int i=0;i<rows*columns;++i)values[i]=copy.values[i];\n}\nbool Matrix::print()\n{\n\tif(rows<0||columns<0)return false;\n\tfor(int row=0;row<rows*columns;++row)\n\t{\n\t\tcout<<values[row]<<\"    \";\n\t\tif(row%columns==columns-1)cout<<endl;\n\t}\n\treturn true;\n}\n\nMatrix Matrix::getRow(int row)\n{\n\tif(row<=0)return Matrix();\n\treturn Matrix(1,columns,values+columns*(row-1));\n}\nMatrix Matrix::getColumn(int col)\n{\n\tif(col<=0)return Matrix();\n\tdouble*temp=new double[rows];\n\tfor(int i=0;i<rows;++i)temp[i]=(values+columns*i)[col-1];\n\treturn Matrix(rows,1,temp);\n}",
            1588851133.5956624,
            100,
            "# 答案正确"
        ],
        [
            "2.6 (C++)",
            "谢扬",
            "#include<iostream>\nusing std::cin;\nusing std::cout;\nusing std::endl;\nclass Matrix  \n{\n\tprivate:\n\t\tint rows,columns;\n\t\tdouble*values;\n\t\t//析构函数/复制构造函数/重载赋值运算府\n\tpublic:\n\tMatrix(int m_rows=0, int m_columns=0,double*m_values=nullptr);\n\tMatrix(const Matrix&copy);\n\t~Matrix(){delete[]values;}\n\tbool print();\n\tMatrix concatenateRows(const Matrix & matrix2) const;\n\t Matrix concatenateColumns(const Matrix & matrix2) const;\n\tMatrix getRow(int row);\n\tMatrix getColumn(int col);\n};\nMatrix Matrix::concatenateRows(const Matrix & matrix2) const\n{\n\tdouble*temp=new double[rows*columns*2];\n\tint i;\n\tfor(i=0;i<rows*columns;++i)temp[i]=values[i];\n\tfor(i=0;i<rows*columns;++i)(temp+rows*columns)[i]=matrix2.values[i];\n\treturn Matrix(rows*2,columns,temp);\n}\nMatrix Matrix::concatenateColumns(const Matrix & matrix2) const\n{\n\tdouble*temp=new double[rows*columns*2];\n\tint j;\n\tfor(int i=0;i<rows;++i)\n\t{\n\t\tfor( j=0;j<columns;++j)(temp+columns*2*i)[j]=(values+columns*i)[j];\n\t\tfor( j=0;j<columns;++j)(temp+columns*2*i+columns)[j]=(matrix2.values+columns*i)[j];\n\t}\n\treturn Matrix(rows,columns*2,temp);\n}\nMatrix::Matrix(int m_rows, int m_columns,double*m_values):rows(m_rows),columns(m_columns)\n{\n\tif(rows>0&&columns>0)\n\t{values=new double[rows*columns];\n\tfor(int i=0;i<rows*columns;++i)values[i]=m_values[i];\n\t }\n\telse values=nullptr;\n}\nMatrix::Matrix(const Matrix&copy):rows(copy.rows),columns(copy.columns)\n{\n\tvalues=new double[rows*columns];\n\tfor(int i=0;i<rows*columns;++i)values[i]=copy.values[i];\n}\nbool Matrix::print()\n{\n\tif(rows<0||columns<0)return false;\n\tfor(int row=0;row<rows*columns;++row)\n\t{\n\t\tcout<<values[row]<<\"    \";\n\t\tif(row%columns==columns-1)cout<<endl;\n\t}\n\treturn true;\n}\n\nMatrix Matrix::getRow(int row)\n{\n\tif(row<=0)return Matrix();\n\treturn Matrix(1,columns,values+columns*(row-1));\n}\nMatrix Matrix::getColumn(int col)\n{\n\tif(col<=0)return Matrix();\n\tdouble*temp=new double[rows];\n\tfor(int i=0;i<rows;++i)temp[i]=(values+columns*i)[col-1];\n\treturn Matrix(rows,1,temp);\n}",
            1588853820.034561,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/08",
            "谢扬",
            "double & Tensor_get(int dimensions, const int sizes[],  double data[], int x0, int x1, int x2, int x3)\n{\n\tswitch(dimensions)\n\t{\n\t\tcase 1:return data[x0];\n\t\tcase 2:return (data+x0*sizes[1])[x1];\n\t\tcase 3:return (data+x0*sizes[1]*sizes[2]+x1*sizes[2])[x2];\n\t\tcase 4:return (data+x0*sizes[1]*sizes[2]*sizes[3]+x1*sizes[2]*sizes[3]+x2*sizes[3])[x3];\n\t}\n}",
            1588908102.5276015,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/14",
            "谢扬",
            "#include<iostream>\nusing std::cout;\nusing std::endl;\nvoid Tensor_print(int dimensions, const int *sizes, const double *data)\n{\n\tint i,j,k;cout<<\"Tensor of \"<<sizes[0];\n\tswitch(dimensions)\n\t{\n\t\tcase 1:cout<<endl;for(i=0;i<sizes[0];++i){\n\t\t\tcout<<data[i]<<endl;\n\t\t}break;\n\t\tcase 2:cout<<\"x\"<<sizes[1]<<endl;for(i=0;i<sizes[0];++i)\n\t\t{\n\t\t\tfor(j=0;j<sizes[1];++j){cout.width(7);cout<<data[j];}\n\t\t\tcout<<endl;\n\t\t}break;\n\t\tcase 3:cout<<\"x\"<<sizes[1]<<\"x\"<<sizes[2]<<endl;\n\t\t\tfor(i=0;i<sizes[0];++i)\n\t\t{cout<<\"data[\"<<i<<\"]\\n\";\n\t\t\tfor(j=0;j<sizes[1];++j){\n\t\t\t\tfor(k=0;k<sizes[2];++k)\n\t\t\t\t{\n\t\t\t\t\tcout.width(7);cout<<data[k];\n\t\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t\t}break;\n\t\tcase 4:cout<<\"x\"<<sizes[1]<<\"x\"<<sizes[2]<<\"x\"<<sizes[3]<<endl;\n\t\t\tfor(i=0;i<sizes[0];++i)\n\t\t\t{\n\t\t\t\tfor(j=0;j<sizes[1];++j)\n\t\t\t\t{\n\t\t\t\t\tcout<<\"data[\"<<i<<\"][\"<<j<<\"]\\n\";\n\t\t\t\t\tfor(k=0;k<sizes[2];++k)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(int l=0;l<sizes[3];++l){cout.width(7);cout<<data[k];}cout<<endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\t\t\n\t}\n}\n\n",
            1589424962.820339,
            100,
            "# 答案正确"
        ],
        [
            "2.4 (C++)",
            "谢扬",
            "/*#ifndef MATRIX_H_\n#define MATRIX_H_*/\n#include<iostream>\nusing std::cin;\nclass Matrix\n{\n\tprivate:\n\t\n    int rows;\n\tint columns;\n    double * values;\n\tpublic:\n\t\tMatrix():rows(0),columns(0),values(nullptr){}\n\t\tMatrix(int row,int col);\n\t\tMatrix(int row, int col, double values[]);\n\t\tMatrix(const Matrix&m);\n\t\t~Matrix(){delete[]values;}\n\t\tMatrix&operator=(const Matrix&m);\n\t\tbool set(int row, int column, double value);\n\t\tbool print()const;\n};\nMatrix::Matrix(int row,int col):rows(row),columns(col)\n{\n\trows*columns<=0?(values=nullptr):(values=new double[rows*columns]{});\n}\nMatrix::Matrix(int row, int col, double val[]):rows(row),columns(col)\n\t{\n\t\trows*columns<=0?(values=nullptr):(values=new double[rows*columns]);\n\t\tif(values)\n\t\tfor(int i=0;i<rows*columns;++i)values[i]=val[i];\n\t}\nMatrix::Matrix(const Matrix&m):rows(m.rows),columns(m.columns)\n\t\t{\n\t\t\trows*columns<=0?(values=nullptr):(values=new double[rows*columns]);\n\t\t\tif(values)\n\t\tfor(int i=0;i<rows*columns;++i)values[i]=m.values[i];\n\t\t}\nMatrix&Matrix::operator=(const Matrix&m)\n{\n\tif(this==&m)return *this;\n\trows=m.rows;\n\tcolumns=m.columns;\n\trows*columns<=0?(values=nullptr):(values=new double[rows*columns]);\n\tif(values)\n\t\tfor(int i=0;i<rows*columns;++i)values[i]=m.values[i];\n\treturn *this;\n}\nbool Matrix::print()const\n{\n\tif(rows*columns<=0)return false;\n\tfor(int i=0;i<rows;++i)\n\t{\n\t\tfor(int j=0;j<columns;++j)std::cout<<(values+columns*i)[j]<<\"    \";\n\t\tstd::cout<<std::endl;\n\t}\n\treturn true;\n}\nbool Matrix::set(int row, int col, double value)\n{\n\t\n\tif(rows*columns<=0||row*col<=0||row*col>rows*columns)return false;\n\t(values+(row-1)*columns)[col-1]=value;\n\treturn true;\n}\n// #endif",
            1589510817.48116,
            100,
            "# 答案正确"
        ],
        [
            "2.7 (C++)",
            "谢扬",
            "#include<iostream>\nusing std::cin;\nusing std::cout;\nusing std::endl;\nclass Matrix\n{\n\tprivate:\n\t\n    int rows;\n\tint columns;\n    double * values;\n\tpublic:\n\t\tMatrix():rows(0),columns(0),values(nullptr){}\n\t\tMatrix(int row,int col);\n\t\tMatrix(int row, int col, double values[]);\n\t\tMatrix(const Matrix&m);\n\t\t~Matrix(){delete[]values;}\n\t\tMatrix&operator=(const Matrix&m);\n\t\tbool set(int row, int column, double value);\n\t\tbool print()const;\n\t\tMatrix reshape(int row, int col) const;\n};\nMatrix::Matrix(int row,int col):rows(row),columns(col)\n{\n\trows*columns<=0?(values=nullptr):(values=new double[rows*columns]{});\n}\nMatrix::Matrix(int row, int col, double val[]):rows(row),columns(col)\n\t{\n\t\trows*columns<=0?(values=nullptr):(values=new double[rows*columns]);\n\t\tif(values)\n\t\tfor(int i=0;i<rows*columns;++i)values[i]=val[i];\n\t}\nMatrix::Matrix(const Matrix&m):rows(m.rows),columns(m.columns)\n\t\t{\n\t\t\trows*columns<=0?(values=nullptr):(values=new double[rows*columns]);\n\t\tfor(int i=0;i<rows*columns;++i)values[i]=m.values[i];\n\t\t}\nMatrix&Matrix::operator=(const Matrix&m)\n{\n\tif(this==&m)return *this;\n\trows=m.rows;\n\tcolumns=m.columns;\n\trows*columns<=0?(values=nullptr):(values=new double[rows*columns]);\n\tif(values)\n\t\tfor(int i=0;i<rows*columns;++i)values[i]=m.values[i];\n\treturn *this;\n}\nbool Matrix::print()const\n{\n\tif(rows*columns<=0)return false;\n\tfor(int i=0;i<rows;++i)\n\t{\n\t\tfor(int j=0;j<columns;++j)std::cout<<(values+columns*i)[j]<<\"    \";\n\t\tstd::cout<<std::endl;\n\t}\n\treturn true;\n}\nbool Matrix::set(int row, int col, double value)\n{\n\t\n\tif(rows*columns<=0||row*col<=0||row*col>rows*columns)return false;\n\t(values+(row-1)*columns)[col-1]=value;\n\treturn true;\n}\nMatrix Matrix::reshape(int row, int col) const\n{double*val=new double[rows*columns];\n\tfor(int j=0;j<col;++j)\n\t{\n\t\tfor(int i=0;i<row;i++)\n\t\t{(val+col*i)[j]=(j*row+i+1)%rows?(values+columns*((j*row+i+1)%rows-1))[(j*row+i+1)/rows]:(values+columns*(rows-1))[(j*row+i+1)/rows-1];}\n\t}\n \t Matrix m(row,col,val);\n \tdelete[]val;\n return m;\n}\n",
            1589519066.2165718,
            100,
            "# 答案正确"
        ],
        [
            "2.8 (C++)",
            "谢扬",
            "/*#ifndef MATRIX_H_\n#define MATRIX_H_*/\n#include<iostream>\nusing std::cin;\nusing std::cout;\nusing std::endl;\nclass Matrix\n{\n\tprivate:\n\t\n    int rows;\n\tint columns;\n    double * values;\n\tpublic:\n\t\tMatrix():rows(0),columns(0),values(nullptr){}\n\t\tMatrix(int row,int col);\n\t\tMatrix(int row, int col, double values[]);\n\t\tMatrix(const Matrix&m);\n\t\t~Matrix(){delete[]values;}\n\t\tMatrix&operator=(const Matrix&m);\n\t\tbool set(int row, int column, double value);\n\t\tbool print()const;\n\t\tMatrix transpose();\n};\nMatrix::Matrix(int row,int col):rows(row),columns(col)\n{\n\trows*columns<=0?(values=nullptr):(values=new double[rows*columns]{});\n}\nMatrix::Matrix(int row, int col, double val[]):rows(row),columns(col)\n\t{\n\t\trows*columns<=0?(values=nullptr):(values=new double[rows*columns]);\n\t\tif(values)\n\t\tfor(int i=0;i<rows*columns;++i)values[i]=val[i];\n\t}\nMatrix::Matrix(const Matrix&m):rows(m.rows),columns(m.columns)\n\t\t{\n\t\t\trows*columns<=0?(values=nullptr):(values=new double[rows*columns]);\n\t\t\tif(values)\n\t\tfor(int i=0;i<rows*columns;++i)values[i]=m.values[i];\n\t\t}\nMatrix&Matrix::operator=(const Matrix&m)\n{\n\tif(this==&m)return *this;\n\trows=m.rows;\n\tcolumns=m.columns;\n\trows*columns<=0?(values=nullptr):(values=new double[rows*columns]);\n\tif(values)\n\t\tfor(int i=0;i<rows*columns;++i)values[i]=m.values[i];\n\treturn *this;\n}\nbool Matrix::print()const\n{\n\tif(rows*columns<=0)return false;\n\tfor(int i=0;i<rows;++i)\n\t{\n\t\tfor(int j=0;j<columns;++j)std::cout<<(values+columns*i)[j]<<\"    \";\n\t\tstd::cout<<std::endl;\n\t}\n\treturn true;\n}\nbool Matrix::set(int row, int col, double value)\n{\n\t\n\tif(rows*columns<=0||row*col<=0||row*col>rows*columns)return false;\n\t(values+(row-1)*columns)[col-1]=value;\n\treturn true;\n}\nMatrix Matrix::transpose()\n{\n\tdouble*val=new double[rows*columns];\n\tfor(int i=0;i<columns;++i)\n\t{\n\t\tfor(int j=0;j<rows;++j)(val+rows*i)[j]=(values+columns*j)[i];\n\t}\n\tMatrix m(columns,rows,val);\n\tdelete[]val;\n\treturn m;\n}\n// #endif",
            1589521521.5728378,
            100,
            "# 答案正确"
        ],
        [
            "2.10 (C++)",
            "谢扬",
            "/*#ifndef MATRIX_H_\n#define MATRIX_H_*/\n#include<iostream>\nusing std::cin;\nusing std::cout;\nusing std::endl;\nclass Matrix\n{\n\tprivate:\n\t\n    int rows;\n\tint columns;\n    double * values;\n\tpublic:\n\t\tMatrix():rows(0),columns(0),values(nullptr){}\n\t\tMatrix(int row,int col);\n\t\tMatrix(int row, int col, double values[]);\n\t\tMatrix(const Matrix&m);\n\t\t~Matrix(){delete[]values;}\n\t\tMatrix&operator=(const Matrix&m);\n\t\tbool set(int row, int column, double value);\n\t\tbool print()const;\n\t\tMatrix operator * (const Matrix & matrix2) const;\n\t\tfriend Matrix operator * (const Matrix & m,double value);\n};\nMatrix::Matrix(int row,int col):rows(row),columns(col)\n{\n\trows*columns<=0?(values=nullptr):(values=new double[rows*columns]{});\n}\nMatrix::Matrix(int row, int col, double val[]):rows(row),columns(col)\n\t{\n\t\trows*columns<=0?(values=nullptr):(values=new double[rows*columns]);\n\t\tif(values)\n\t\tfor(int i=0;i<rows*columns;++i)values[i]=val[i];\n\t}\nMatrix::Matrix(const Matrix&m):rows(m.rows),columns(m.columns)\n\t\t{\n\t\t\trows*columns<=0?(values=nullptr):(values=new double[rows*columns]);\n\t\t\tif(values)\n\t\tfor(int i=0;i<rows*columns;++i)values[i]=m.values[i];\n\t\t}\nMatrix&Matrix::operator=(const Matrix&m)\n{\n\tif(this==&m)return *this;\n\trows=m.rows;\n\tcolumns=m.columns;\n\trows*columns<=0?(values=nullptr):(values=new double[rows*columns]);\n\tif(values)\n\t\tfor(int i=0;i<rows*columns;++i)values[i]=m.values[i];\n\treturn *this;\n}\nbool Matrix::print()const\n{\n\tif(rows*columns<=0)return false;\n\tfor(int i=0;i<rows;++i)\n\t{\n\t\tfor(int j=0;j<columns;++j)std::cout<<(values+columns*i)[j]<<\"    \";\n\t\tstd::cout<<std::endl;\n\t}\n\treturn true;\n}\nbool Matrix::set(int row, int col, double value)\n{\n\t\n\tif(rows*columns<=0||row*col<=0||row*col>rows*columns)return false;\n\t(values+(row-1)*columns)[col-1]=value;\n\treturn true;\n}\nMatrix Matrix::operator * (const Matrix & m) const\n{\n\tdouble*val=new double[rows*m.columns];\n\tint sum(0);\n\tfor(int i=0;i<rows;++i)\n\t{\n\t\tfor(int j=0;j<m.columns;++j)\n\t\t{\n\t\t\tfor(int k=0;k<columns;++k)sum+=(values+columns*i)[k]*(m.values+m.columns*k)[j];\n\t\t\t(val+m.columns*i)[j]=sum;\n\t\t\tsum=0;\n\t\t}\n\t}\n\tMatrix m2(rows,m.columns,val);\n\tdelete[]val;\n\treturn m2;\n}\nMatrix operator * (const Matrix & m,double value)\n{\n\tdouble*val=new double[m.rows*m.columns];\n\n\tfor(int i=0;i<m.rows;++i)\n\t{\n\t\tfor(int j=0;j<m.columns;++j)(val+m.columns*i)[j]=(m.values+m.columns*i)[j]*value;\n\t}\n\tMatrix m2(m.rows,m.columns,val);\n\tdelete[]val;\n\treturn m2;\n}\n// #endif",
            1589526743.7116957,
            100,
            "# 答案正确"
        ],
        [
            "2.11 (C++)",
            "谢扬",
            "/*#ifndef MATRIX_H_\n#define MATRIX_H_*/\n#include<iostream>\nusing std::cin;\nusing std::cout;\nusing std::endl;\nclass Matrix\n{\n\tprivate:\n\t\n    int rows;\n\tint columns;\n    double * values;\n\tpublic:\n\t\tMatrix():rows(0),columns(0),values(nullptr){}\n\t\tMatrix(int row,int col);\n\t\tMatrix(int row, int col, double values[]);\n\t\tMatrix(const Matrix&m);\n\t\t~Matrix(){delete[]values;}\n\t\tMatrix&operator=(const Matrix&m);\n\t\tbool set(int row, int column, double value);\n\t\tbool print()const;\n\t\tMatrix max() const;\n\t\tMatrix min() const;\n\t\tMatrix sum() const;\n};\nMatrix::Matrix(int row,int col):rows(row),columns(col)\n{\n\trows*columns<=0?(values=nullptr):(values=new double[rows*columns]{});\n}\nMatrix::Matrix(int row, int col, double val[]):rows(row),columns(col)\n\t{\n\t\trows*columns<=0?(values=nullptr):(values=new double[rows*columns]);\n\t\tif(values)\n\t\tfor(int i=0;i<rows*columns;++i)values[i]=val[i];\n\t}\nMatrix::Matrix(const Matrix&m):rows(m.rows),columns(m.columns)\n\t\t{\n\t\t\trows*columns<=0?(values=nullptr):(values=new double[rows*columns]);\n\t\t\tif(values)\n\t\tfor(int i=0;i<rows*columns;++i)values[i]=m.values[i];\n\t\t}\nMatrix&Matrix::operator=(const Matrix&m)\n{\n\tif(this==&m)return *this;\n\trows=m.rows;\n\tcolumns=m.columns;\n\trows*columns<=0?(values=nullptr):(values=new double[rows*columns]);\n\tif(values)\n\t\tfor(int i=0;i<rows*columns;++i)values[i]=m.values[i];\n\treturn *this;\n}\nbool Matrix::print()const\n{\n\tif(rows*columns<=0)return false;\n\tfor(int i=0;i<rows;++i)\n\t{\n\t\tfor(int j=0;j<columns;++j)std::cout<<(values+columns*i)[j]<<\"    \";\n\t\tstd::cout<<std::endl;\n\t}\n\treturn true;\n}\nbool Matrix::set(int row, int col, double value)\n{\n\t\n\tif(rows*columns<=0||row*col<=0||row*col>rows*columns)return false;\n\t(values+(row-1)*columns)[col-1]=value;\n\treturn true;\n}\nMatrix Matrix::max() const\n{\n\tdouble max;\n\tif(rows==1)\n\t{\n\t\t max=values[0];\n\t\tfor(int i=1;i<columns;++i)if(values[i]>max)max=values[i];\n\t\tdouble*val=&max;\n\t\treturn Matrix(rows,rows,val);\n\t}\n\telse{\n\t\tdouble*val=new double[columns];\n\t\tfor(int i=0;i<columns;++i)\n\t\t{\n\t\t\tmax=values[i];\n\t\t\tfor(int j=0;j<rows;++j)if(max<(values+columns*j)[i])max=(values+columns*j)[i];\n\t\t\tval[i]=max;\n\t\t}\n\t\tMatrix m(1,columns,val);\n\t\tdelete[]val;\n\t\treturn m;\n\t}\n}\nMatrix Matrix::min() const\n{\n\tdouble min;\n\tif(rows==1)\n\t{\n\t\tmin=values[0];\n\t\tfor(int i=1;i<columns;++i)if(values[i]<min)min=values[i];\n\t\tdouble*val=&min;\n\t\treturn Matrix(rows,rows,val);\n\t}\n\telse{\n\t\tdouble*val=new double[columns];\n\t\tfor(int i=0;i<columns;++i)\n\t\t{\n\t\t\tmin=values[i];\n\t\t\tfor(int j=0;j<rows;++j)if(min>(values+columns*j)[i])min=(values+columns*j)[i];\n\t\t\tval[i]=min;\n\t\t}\n\t\tMatrix m(1,columns,val);\n\t\tdelete[]val;\n\t\treturn m;\n\t}\n}\nMatrix Matrix::sum() const\n{\n\tdouble sum(0.0);\n\tif(rows==1)\n\t{\n\t\t\n\t\tfor(int i=0;i<columns;++i)sum+=values[i];\n\t\tdouble*val=&sum;\n\t\treturn Matrix(rows,rows,val);\n\t}\n\telse{\n\t\tdouble*val=new double[columns];\n\t\tfor(int i=0;i<columns;++i)\n\t\t{\n\t\t\tfor(int j=0;j<rows;++j)sum+=(values+columns*j)[i];\n\t\t\tval[i]=sum;\n\t\t\tsum=0.0;\n\t\t}\n\t\tMatrix m(1,columns,val);\n\t\tdelete[]val;\n\t\treturn m;\n\t}\n}\n// #endif",
            1589550951.1018384,
            100,
            "# 答案正确"
        ],
        [
            "2.12 (C++)",
            "谢扬",
            "/*#ifndef MATRIX_H_\n#define MATRIX_H_*/\n#include<iostream>\n#include<cmath>\nusing std::cin;\nusing std::cout;\nusing std::endl;\nclass Matrix\n{\n\tprivate:\n\t\n    int rows;\n\tint columns;\n    double * values;\n\tpublic:\n\t\tMatrix():rows(0),columns(0),values(nullptr){}\n\t\tMatrix(int row,int col);\n\t\tMatrix(int row, int col, double values[]);\n\t\tMatrix(const Matrix&m);\n\t\t~Matrix(){delete[]values;}\n\t\tMatrix&operator=(const Matrix&m);\n\t\tbool set(int row, int column, double value);\n\t\tbool print()const;\n\t\tMatrix pow(double exponent)const;\n\t\t Matrix exp()const;\n\t\tMatrix log()const;\n\t\tMatrix abs()const;\n};\nMatrix::Matrix(int row,int col):rows(row),columns(col)\n{\n\trows*columns<=0?(values=nullptr):(values=new double[rows*columns]{});\n}\nMatrix::Matrix(int row, int col, double val[]):rows(row),columns(col)\n\t{\n\t\trows*columns<=0?(values=nullptr):(values=new double[rows*columns]);\n\t\tif(values)\n\t\tfor(int i=0;i<rows*columns;++i)values[i]=val[i];\n\t}\nMatrix::Matrix(const Matrix&m):rows(m.rows),columns(m.columns)\n\t\t{\n\t\t\trows*columns<=0?(values=nullptr):(values=new double[rows*columns]);\n\t\t\tif(values)\n\t\tfor(int i=0;i<rows*columns;++i)values[i]=m.values[i];\n\t\t}\nMatrix&Matrix::operator=(const Matrix&m)\n{\n\tif(this==&m)return *this;\n\trows=m.rows;\n\tcolumns=m.columns;\n\trows*columns<=0?(values=nullptr):(values=new double[rows*columns]);\n\tif(values)\n\t\tfor(int i=0;i<rows*columns;++i)values[i]=m.values[i];\n\treturn *this;\n}\nbool Matrix::print()const\n{\n\tif(rows*columns<=0)return false;\n\tfor(int i=0;i<rows;++i)\n\t{\n\t\tfor(int j=0;j<columns;++j)std::cout<<(values+columns*i)[j]<<\"    \";\n\t\tstd::cout<<std::endl;\n\t}\n\treturn true;\n}\nbool Matrix::set(int row, int col, double value)\n{\n\t\n\tif(rows*columns<=0||row*col<=0||row*col>rows*columns)return false;\n\t(values+(row-1)*columns)[col-1]=value;\n\treturn true;\n}\nMatrix Matrix::pow(double exponent)const\n{\n\tdouble*val=new double[rows*columns];\n\tfor(int i=0;i<rows;++i)\n\t{\n\t\tfor(int j=0;j<columns;++j)(val+columns*i)[j]=std::pow((values+columns*i)[j],exponent);\n\t}\n\tMatrix m(rows,columns,val);\n\tdelete[]val;\n\treturn m;\n}\n Matrix Matrix::exp()const{\n\t double*val=new double[rows*columns];\n\tfor(int i=0;i<rows;++i)\n\t{\n\t\tfor(int j=0;j<columns;++j)(val+columns*i)[j]=std::exp((values+columns*i)[j]);\n\t}\n\tMatrix m(rows,columns,val);\n\tdelete[]val;\n\treturn m;\n }\nMatrix Matrix::log()const\n{\n\t double*val=new double[rows*columns];\n\tfor(int i=0;i<rows;++i)\n\t{\n\t\tfor(int j=0;j<columns;++j)(val+columns*i)[j]=std::log((values+columns*i)[j]);\n\t}\n\tMatrix m(rows,columns,val);\n\tdelete[]val;\n\treturn m;\n}\nMatrix Matrix::abs()const\n{\n\tdouble*val=new double[rows*columns];\n\tfor(int i=0;i<rows;++i)\n\t{\n\t\tfor(int j=0;j<columns;++j)(val+columns*i)[j]=std::abs((values+columns*i)[j]);\n\t}\n\tMatrix m(rows,columns,val);\n\tdelete[]val;\n\treturn m;\n}\n// #endif",
            1589552814.6575522,
            100,
            "# 答案正确"
        ],
        [
            "2.9 (C++)",
            "谢扬",
            "#include<iostream>\nusing std::cin;\nusing std::cout;\nusing std::endl;\nclass Matrix\n{\n\tprivate:\n\t\n    int rows;\n\tint columns;\n    double * values;\n\tpublic:\n\t\tMatrix():rows(0),columns(0),values(nullptr){}\n\t\tMatrix(int row,int col);\n\t\tMatrix(int row, int col, double values[]);\n\t\tMatrix(const Matrix&m);\n\t\t~Matrix(){delete[]values;}\n\t\tMatrix&operator=(const Matrix&m);\n\t\tbool set(int row, int column, double value);\n\t\tbool print()const;\nMatrix operator+(const Matrix&m)const;\nfriend Matrix operator+(const Matrix&m,double val);\nMatrix operator-(const Matrix&m)const;\nMatrix operator-(double val)const;\n};\nMatrix Matrix::operator+(const Matrix&m)const\n{\ndouble*val=new double[rows*columns];\nfor(int i=0;i<rows*columns;++i)val[i]=values[i]+m.values[i];\nMatrix m2(rows,columns,val);\ndelete[]val;\nreturn m2;\n}\nMatrix operator+(const Matrix&m,double val)\n{\ndouble*va=new double[m.rows*m.columns];\nfor(int i=0;i<m.rows*m.columns;++i)va[i]=m.values[i]+val;\nMatrix m2(m.rows,m.columns,va);\ndelete[]va;\nreturn m2;\n}\nMatrix Matrix::operator-(const Matrix&m)const\n{\ndouble*val=new double[rows*columns];\nfor(int i=0;i<rows*columns;++i)val[i]=values[i]-m.values[i];\nMatrix m2(rows,columns,val);\ndelete[]val;\nreturn m2;\n}\nMatrix Matrix::operator-(double val)const\n{\ndouble*va=new double[rows*columns];\nfor(int i=0;i<rows*columns;++i)va[i]=values[i]-val;\nMatrix m2(rows,columns,va);\ndelete[]va;\nreturn m2;\n}\nMatrix::Matrix(int row,int col):rows(row),columns(col)\n{\n\trows*columns<=0?(values=nullptr):(values=new double[rows*columns]{});\n}\nMatrix::Matrix(int row, int col, double val[]):rows(row),columns(col)\n\t{\n\t\trows*columns<=0?(values=nullptr):(values=new double[rows*columns]);\n\t\tif(values)\n\t\tfor(int i=0;i<rows*columns;++i)values[i]=val[i];\n\t}\nMatrix::Matrix(const Matrix&m):rows(m.rows),columns(m.columns)\n\t\t{\n\t\t\trows*columns<=0?(values=nullptr):(values=new double[rows*columns]);\n\t\t\tif(values)\n\t\tfor(int i=0;i<rows*columns;++i)values[i]=m.values[i];\n\t\t}\nMatrix&Matrix::operator=(const Matrix&m)\n{\n\tif(this==&m)return *this;\n\trows=m.rows;\n\tcolumns=m.columns;\n\trows*columns<=0?(values=nullptr):(values=new double[rows*columns]);\n\tif(values)\n\t\tfor(int i=0;i<rows*columns;++i)values[i]=m.values[i];\n\treturn *this;\n}\nbool Matrix::print()const\n{\n\tif(rows*columns<=0)return false;\n\tfor(int i=0;i<rows;++i)\n\t{\n\t\tfor(int j=0;j<columns;++j)std::cout<<(values+columns*i)[j]<<\"    \";\n\t\tstd::cout<<std::endl;\n\t}\n\treturn true;\n}\nbool Matrix::set(int row, int col, double value)\n{\n\t\n\tif(rows*columns<=0||row*col<=0||row*col>rows*columns)return false;\n\t(values+(row-1)*columns)[col-1]=value;\n\treturn true;\n}\n// #endif:::",
            1590029558.049926,
            100,
            "# 答案正确"
        ],
        [
            "6.1 (C++)",
            "谢扬",
            "/*#ifndef MATRIX_TEM_H_\n#define MATRIX_TEM_H_\n*/\ntemplate<class T>\nclass Matrix\n{\n\tprivate:\n\t\tint rows,columns;\n\t\tT*values;\n\tpublic:\n\t\tMatrix():rows(0),columns(0),values(nullptr){};\n\t\t Matrix(int row,int col);\n\t\tMatrix(int row,int col,const T*val);\n\t\tMatrix(const Matrix&m);\n\t\t~Matrix(){delete[]values;}\n\t\tMatrix&operator=(const Matrix&m);\n\t\tvoid print()const;\n\t\tT&get(int row,int col);\n};\n// string or char \ntemplate<>\nclass Matrix<string>\n{\n\n\tprivate:\n\t\tint rows,columns;\n\t\tstring*values;\n\tpublic:\n\t\tMatrix():rows(0),columns(0),values(nullptr){};\n\t\tMatrix(int row,int col);\n\t\tMatrix(int row,int col,const string*val);\n\t\tMatrix(const Matrix&m);\n\t\t~Matrix(){delete[]values;}\n\t\tMatrix&operator=(const Matrix&m);\n\t\tvoid print()const;\n\t\tstring&get(int row,int col);\n};\nMatrix<string>::Matrix(int row,int col):rows(row),columns(col)\n{\n\trows*columns<=0?(values=nullptr):(values=new string[rows*columns]{\" \"});\n}\nMatrix<string>::Matrix(int row,int col,const string*val):rows(row),columns(col)\n{rows*columns<=0?(values=nullptr):(values=new string[rows*columns]);\n\tif(values)\n\t\tfor(int i=0;i<rows*columns;++i)\n\t\t\tvalues[i]=val[i];\n}\n\nMatrix<string>::Matrix(const Matrix&m):rows(m.rows),columns(m.columns)\n{\n\trows*columns<=0?(values=nullptr):(values=new string[rows*columns]);\n\tif(values)\n\t\tfor(int i=0;i<rows*columns;++i)\n\t\t\tvalues[i]=m.values[i];\n}\n\nMatrix<string>&Matrix<string>::operator=(const Matrix<string>&m)\n{\n\tif(this==&m)return*this;\n\trows=m.rows;\n\tcolumns=m.columns;\n\tdelete[]values;\n\trows*columns<=0?(values=nullptr):(values=new string[rows*columns]);\n\tif(values)\n\t\tfor(int i=0;i<rows*columns;++i)\n\t\t\tvalues[i]=m.values[i];\n\treturn*this;\n}\n\nvoid Matrix<string>::print()const\n{\n\tfor(int i=0;i<rows;++i)\n\t{\n\t\tfor(int j=0;j<columns;++j)\n\t\t{\n\t\t\tcout<<\"    \"\n\t\t\t<<(values+columns*i)[j];\n\t\t}\n\t\tcout<<endl;\n\t}\n}\n\nstring&Matrix<string>::get(int row,int col)\n{\n\treturn (values+columns*(row-1))[col-1];\n}\n\n//num\ntemplate<class T>\nMatrix<T>::Matrix(int row,int col):rows(row),columns(col)\n{\n\trows*columns<=0?(values=nullptr):(values=new T[rows*columns]{});\n}\n\ntemplate<class T>\nMatrix<T>::Matrix(int row,int col,const T*val):rows(row),columns(col)\n{rows*columns<=0?(values=nullptr):(values=new T[rows*columns]);\n\tif(values)\n\t\tfor(int i=0;i<rows*columns;++i)\n\t\t\tvalues[i]=val[i];\n}\ntemplate<class T>\nMatrix<T>::Matrix(const Matrix&m):rows(m.rows),columns(m.columns)\n{\n\trows*columns<=0?(values=nullptr):(values=new T[rows*columns]);\n\tif(values)\n\t\tfor(int i=0;i<rows*columns;++i)\n\t\t\tvalues[i]=m.values[i];\n}\ntemplate<class T>\nMatrix<T>&Matrix<T>::operator=(const Matrix<T>&m)\n{\n\tif(this==&m)return*this;\n\trows=m.rows;\n\tcolumns=m.columns;\n\tdelete[]values;\n\trows*columns<=0?(values=nullptr):(values=new T[rows*columns]);\n\tif(values)\n\t\tfor(int i=0;i<rows*columns;++i)\n\t\t\tvalues[i]=m.values[i];\n\treturn*this;\n}\ntemplate<class T>\nvoid Matrix<T>::print()const\n{\n\tfor(int i=0;i<rows;++i)\n\t{\n\t\tfor(int j=0;j<columns;++j)\n\t\t{\n\t\t\tcout<<\"    \"\n\t\t\t<<(values+columns*i)[j];\n\t\t}\n\t\tcout<<endl;\n\t}\n}\ntemplate<class T>\nT&Matrix<T>::get(int row,int col)\n{\n\treturn (values+columns*(row-1))[col-1];\n}\n//#endif",
            1590146791.2707887,
            100,
            "# 答案正确"
        ],
        [
            "6.3 (C++)",
            "谢扬",
            "/*#ifndef MATRIX_TEM_H_\n#define MATRIX_TEM_H_\n*/\n#include<iostream>\n#include<vector>\nusing std::string;\nusing std::vector;\nusing std::cin;\nusing std::cout;\nusing std::endl;\ntemplate<class T>\nclass Matrix\n{\n\tprivate:\n\t\tusing d1=vector<T>;\n\t\tint rows,columns;\n\t\td1 values;\n\tpublic:\n\t\tMatrix():rows(0),columns(0){};\n\t\t Matrix(int row,int col);\n\t\tMatrix(int row,int col,const d1&val);\n\t\tvoid print()const;\n\t\tT&get(int row,int col);\n\t\tconst T&get(int row,int col)const;\n\t\tMatrix getColumn(int col)const;\n\t\tMatrix getRow(int row)const;\n\t\tMatrix concatenateRows(const Matrix&m)const;\n\t\tMatrix concatenateColumns(const Matrix&m)const;\n\t\tMatrix reshape(int row,int col)const;\n\t\tMatrix transpose()const;\n\t\tMatrix operator+(const Matrix&m)const;\n\t\ttemplate<class v,class u>friend  v operator+(const v&m,const u& factor);\n\t\tMatrix operator-(const Matrix&m)const;\n\t\tMatrix operator-(const T&m)const;\n\t\ttemplate<class u,class v>friend u operator*(const u&m,const v&factor);\n\t\tMatrix operator*(const Matrix&m)const;\n\t\tMatrix max()const;\n\t\tMatrix min()const;\n\t\tMatrix sum()const;\n};\n//num\ntemplate<class T>\nMatrix<T>::Matrix(int row,int col):rows(row),columns(col)\n{\n\tif(rows*columns>0)values=d1(rows*columns);\n\n}\n\ntemplate<class T>\nMatrix<T>::Matrix(int row,int col,const d1&val):rows(row),columns(col)\n{if(rows*columns>0)values=val;\n\n}\n\ntemplate<class T>\nvoid Matrix<T>::print()const\n{\n\tfor(int i=0;i<columns*rows;++i)\n\t{\n\t\t\n\t\t\tcout<<\"    \"\n\t\t\t<<values[i];\n\tif(i%columns==columns-1)\n\t\tcout<<endl;\n\t}\n}\ntemplate<class T>\nT&Matrix<T>::get(int row,int col)\n{\n\t return values[columns*(row-1)+col-1];\n}\ntemplate<class T>\nconst T&Matrix<T>::get(int row,int col)const\n{ return values[columns*(row-1)+col-1];}\ntemplate<class T>\nMatrix<T> Matrix<T>::getColumn(int col)const\n{d1 val;\nfor(int i=0;i<rows;++i)val.push_back(values[columns*i+col-1]);\nreturn Matrix<T>(rows,1,val); }\ntemplate<class T>\nMatrix<T> Matrix<T>::getRow(int row)const\n{d1 val;\nfor(int i=0;i<columns;++i)val.push_back(values[columns*(row-1)+i]);\nreturn Matrix<T>(1,columns,val);}\ntemplate<class T>\nMatrix<T> Matrix<T>::concatenateRows(const Matrix<T>&m)const\n{\n\td1 val;\n\tint i;\nfor(i=0;i<rows*columns;++i)val.push_back(values[i]);\n\tfor(i=0;i<m.rows*m.columns;++i)val.push_back(m.values[i]);\nreturn Matrix<T>(rows+m.rows,columns,val);\n}\ntemplate<class T>\nMatrix<T> Matrix<T>::concatenateColumns(const Matrix<T>&m)const\n{\n\td1 val;\n\tint j;\n\tfor(int i=0;i<rows;++i)\n\t{\n\t\tfor(j=0;j<columns;++j)val.push_back(values[columns*i+j]);\n\t\t\n\t\tfor(j=0;j<columns;++j)val.push_back(m.values[columns*i+j]);\n\t\t\n\t}\n\treturn Matrix<T>(rows,columns+m.columns,val);\n}\ntemplate<class T>\nMatrix<T> Matrix<T>::reshape(int row,int col)const\n{\n\td1 val;\n\tint i;\nfor(i=0;i<rows*columns;++i)\n\t(row*(i%col)+i/col+1)%rows?val.push_back(values[columns*((row*(i%col)+i/col+1)%rows-1)+(row*(i%col)+i/col+1)/rows]):val.push_back(values[columns*(rows-1)+(row*(i%col)+i/col+1)/rows-1]);\n\treturn Matrix<T>(row,col,val);\n}\ntemplate<class T>\nMatrix<T> Matrix<T>:: transpose()const\n{\n\td1 val;\n\tint i;\nfor(i=0;i<rows*columns;++i)\n\tval.push_back(values[columns*(i%columns)+i/columns]);\n\treturn Matrix<T>(columns,rows,val);\n}\ntemplate<class T>\nMatrix<T> Matrix<T>::operator+(const Matrix<T>&m)const\n{d1 val;\n\tint i;\nfor(i=0;i<rows*columns;++i)\n\tval.push_back(values[i]+m.values[i]);\n\treturn Matrix<T>(rows,columns,val);}\n\ntemplate<class v,class u>\nv operator+(const v&m,const u&factor)\n{typename v::d1 val;\n\tint i;\nfor(i=0;i<m.rows*m.columns;++i)\n\tval.push_back(m.values[i]+factor);\n\treturn v(m.rows,m.columns,val);}\ntemplate<class v,class u>\nv operator*(const v&m,const u&factor)\n{\n\ttypename v::d1 val;\n\tint i;\nfor(i=0;i<m.rows*m.columns;++i)\n\tval.push_back(m.values[i]*factor);\n\treturn v(m.rows,m.columns,val);\n}\n\ntemplate<class T>\nMatrix<T> Matrix<T>::operator-(const Matrix<T>&m)const\n{d1 val;\n\tint i;\nfor(i=0;i<rows*columns;++i)\n\tval.push_back(values[i]-m.values[i]);\n\treturn Matrix<T>(rows,columns,val);}\ntemplate<class T>\nMatrix<T> Matrix<T>::operator-(const T&m)const\n{d1 val;\n\tint i;\nfor(i=0;i<rows*columns;++i)\n\tval.push_back(values[i]-m);\n\treturn Matrix<T>(rows,columns,val);}\ntemplate<class T>\nMatrix<T> Matrix<T>::operator*(const Matrix<T>&m)const\n{\n\td1 val;\n\tint i,sum;\nfor(i=0;i<rows*m.columns;++i)\n{\n\tsum=0;\n\tfor(int j=0;j<columns;++j)sum+=values[columns*(i/columns)+j]*m.values[columns*j+i%columns];\n\t\tval.push_back(sum);\n}\n\treturn Matrix<T>(rows,m.columns,val);\n}\ntemplate<class T>\nMatrix<T> Matrix<T>::max()const\n{\n\tT maximal;\n\tint i;\n\tswitch(rows)\n{\n\tcase 1:maximal=values[0];for(i=1;i<columns;++i)if(values[i]>maximal)maximal=values[i];return Matrix<T>(1,1,d1(1,maximal));\n\t\tdefault:d1 val;for(i=0;i<columns;++i)\n\t\t{maximal=values[i];\n\t\t\tfor(int j=0;j<rows;++j)\n\t\t\tif(maximal<values[columns*j+i])maximal=values[columns*j+i];\n\t\t \tval.push_back(maximal);\n\t\t}\n\t\t\treturn Matrix<T>(1,columns,val);\n}}\ntemplate<class T>\nMatrix<T> Matrix<T>::min()const\n{\n\t\n\tT minimal;\n\tint i;\n\tswitch(rows)\n{\n\tcase 1:minimal=values[0];for(i=1;i<columns;++i)if(values[i]<minimal)minimal=values[i];return Matrix<T>(1,1,d1(1,minimal));\n\t\tdefault:d1 val;for(i=0;i<columns;++i)\n\t\t{minimal=values[i];\n\t\t\tfor(int j=0;j<rows;++j)\n\t\t\tif(minimal>values[columns*j+i])minimal=values[columns*j+i];\n\t\t \tval.push_back(minimal);\n\t\t}\n\t\t\treturn Matrix<T>(1,columns,val);\n}\n}\ntemplate<class T>\nMatrix<T> Matrix<T>::sum()const\n{\n\t\n\tint i,sums(0);\n\tswitch(rows)\n{\n\tcase 1:for(i=0;i<columns;++i)sums+=values[i];return Matrix<T>(1,1,d1(1,sums));\n\t\tdefault:d1 val;for(i=0;i<columns;++i)\n\t\t{sums=0;\n\t\t\tfor(int j=0;j<rows;++j)\n\t\t\tsums+=values[columns*j+i];\n\t\t \tval.push_back(sums);\n\t\t}\n\t\t\treturn Matrix<T>(1,columns,val);\n}\n}\n//#endif",
            1590195642.9776967,
            100,
            "# 答案正确"
        ],
        [
            "6.2 (C++)",
            "谢扬",
            "/*#ifndef MATRIX_TEM_H_\n#define MATRIX_TEM_H_\n*/\n#include<iostream>\n#include<string>\nusing std::cin;\nusing std::cout;\nusing std::endl;\nusing std::string;\ntemplate<class T>\nclass Matrix\n{\n\tprivate:\n\t\tint rows,columns;\n\t\tT*values;\n\tpublic:\n\t\tMatrix():rows(0),columns(0),values(nullptr){};\n\t\t Matrix(int row,int col);\n\t\tMatrix(int row,int col,const T*val);\n\t\tMatrix(const Matrix&m);\n\t\t~Matrix(){delete[]values;}\n\t\tMatrix&operator=(const Matrix&m);\n\t\tvoid print()const;\n\t\tT&get(int row,int col);\n};\n// string or char \ntemplate<>\nclass Matrix<string>\n{\n\n\tprivate:\n\t\tint rows,columns;\n\t\tstring*values;\n\tpublic:\n\t\tMatrix():rows(0),columns(0),values(nullptr){};\n\t\tMatrix(int row,int col);\n\t\tMatrix(int row,int col,const string*val);\n\t\tMatrix(const Matrix&m);\n\t\t~Matrix(){delete[]values;}\n\t\tMatrix&operator=(const Matrix&m);\n\t\tvoid print()const;\n\t\tstring&get(int row,int col);\n};\nMatrix<string>::Matrix(int row,int col):rows(row),columns(col)\n{\n\trows*columns<=0?(values=nullptr):(values=new string[rows*columns]{\" \"});\n}\nMatrix<string>::Matrix(int row,int col,const string*val):rows(row),columns(col)\n{rows*columns<=0?(values=nullptr):(values=new string[rows*columns]);\n\tif(values)\n\t\tfor(int i=0;i<rows*columns;++i)\n\t\t\tvalues[i]=val[i];\n}\n\nMatrix<string>::Matrix(const Matrix&m):rows(m.rows),columns(m.columns)\n{\n\trows*columns<=0?(values=nullptr):(values=new string[rows*columns]);\n\tif(values)\n\t\tfor(int i=0;i<rows*columns;++i)\n\t\t\tvalues[i]=m.values[i];\n}\n\nMatrix<string>&Matrix<string>::operator=(const Matrix<string>&m)\n{\n\tif(this==&m)return*this;\n\trows=m.rows;\n\tcolumns=m.columns;\n\tdelete[]values;\n\trows*columns<=0?(values=nullptr):(values=new string[rows*columns]);\n\tif(values)\n\t\tfor(int i=0;i<rows*columns;++i)\n\t\t\tvalues[i]=m.values[i];\n\treturn*this;\n}\n\nvoid Matrix<string>::print()const\n{\n\tfor(int i=0;i<rows;++i)\n\t{\n\t\tfor(int j=0;j<columns;++j)\n\t\t{\n\t\t\tcout<<\"    \"\n\t\t\t<<(values+columns*i)[j];\n\t\t}\n\t\tcout<<endl;\n\t}\n}\n\nstring&Matrix<string>::get(int row,int col)\n{\n\treturn (values+columns*(row-1))[col-1];\n}\n\n//num\ntemplate<class T>\nMatrix<T>::Matrix(int row,int col):rows(row),columns(col)\n{\n\trows*columns<=0?(values=nullptr):(values=new T[rows*columns]{});\n}\n\ntemplate<class T>\nMatrix<T>::Matrix(int row,int col,const T*val):rows(row),columns(col)\n{rows*columns<=0?(values=nullptr):(values=new T[rows*columns]);\n\tif(values)\n\t\tfor(int i=0;i<rows*columns;++i)\n\t\t\tvalues[i]=val[i];\n}\ntemplate<class T>\nMatrix<T>::Matrix(const Matrix&m):rows(m.rows),columns(m.columns)\n{\n\trows*columns<=0?(values=nullptr):(values=new T[rows*columns]);\n\tif(values)\n\t\tfor(int i=0;i<rows*columns;++i)\n\t\t\tvalues[i]=m.values[i];\n}\ntemplate<class T>\nMatrix<T>&Matrix<T>::operator=(const Matrix<T>&m)\n{\n\tif(this==&m)return*this;\n\trows=m.rows;\n\tcolumns=m.columns;\n\tdelete[]values;\n\trows*columns<=0?(values=nullptr):(values=new T[rows*columns]);\n\tif(values)\n\t\tfor(int i=0;i<rows*columns;++i)\n\t\t\tvalues[i]=m.values[i];\n\treturn*this;\n}\ntemplate<class T>\nvoid Matrix<T>::print()const\n{\n\tfor(int i=0;i<rows;++i)\n\t{\n\t\tfor(int j=0;j<columns;++j)\n\t\t{\n\t\t\tcout<<\"    \"\n\t\t\t<<(values+columns*i)[j];\n\t\t}\n\t\tcout<<endl;\n\t}\n}\ntemplate<class T>\nT&Matrix<T>::get(int row,int col)\n{\n\treturn (values+columns*(row-1))[col-1];\n}\n//#endif",
            1590631609.2696042,
            100,
            "# 答案正确"
        ],
        [
            "7.1 (C++)",
            "谢扬",
            "/*#ifndef TRIANGLE_H_\n#define TRIANGLE_H_*/\n#include<cmath>\nclass Triangle:public GeometricObject\n{\n\tprivate:\n\t\tdouble side1,side2,side3;\n\t\tdouble perimeter,area;\n\tpublic:\n\t\tTriangle():GeometricObject(){side1=side2=side3=1.0;perimeter=side1+side2+side3;double s=perimeter/2;area=sqrt(s*(s-side1)*(s-side2)*(s-side3));}\n\t\tTriangle(double s1,double s2,double s3 ):side1(s1),side2(s2),side3(s3){perimeter=side1+side2+side3;double s=perimeter/2;area=sqrt(s*(s-side1)*(s-side2)*(s-side3));}\n\t\tdouble getSide1()const{return side1;}\n\t\tdouble getSide2()const{return side2;}\n\t\tdouble getSide3()const{return side3;}\n\t\tdouble getArea()const{return area;}\n\t\tdouble getPerimeter()const{return perimeter;}\n};\n//#endif",
            1590994202.3159006,
            100,
            "# 答案正确"
        ],
        [
            "7.3 (C++)",
            "谢扬",
            "/*#ifndef MAP2_H_\n#define MAP2_H_*/\n\ntemplate<class T>\nvector<T>map2(const vector<T>&data1,const vector<T>&data2,T(*func)(const T&,const T&))\n{\n\tvector<T>sum;\n\tfor(int i=0;i<data1.size();++i)sum.push_back(func(data1[i],data2[i]));\n\treturn sum;\n}\n\ntemplate<class T>\nvector<T>map2(const vector<T>&data1,const T&data2,T(*func)(const T&,const T&))\n{\n\tvector<T>sum;\n\tfor(int i=0;i<data1.size();++i)sum.push_back(func(data1[i],data2));\n\treturn sum;\n}\n//#endif",
            1591008822.7951956,
            100,
            "# 答案正确"
        ],
        [
            "7.2 (C++)",
            "谢扬",
            "\n#include<string>\n#include<vector>\nusing std::string;\nusing std::vector;\nvector<string>split(const string&str,const string&delimeter=\" \");\nvector<string>split(const string&str,const string&delimeter)\n{\n\tint start=0;\n\tint end;\n\tvector<string> words;\n\twhile(start<str.size())\n\t{\n\t\tend=str.find(delimeter,start);\n\t\tif(end==string::npos){words.push_back(str.substr(start));start=str.size();}\n\t\telse if(end==start)start+=delimeter.size();\n\t\telse {words.push_back(str.substr(start,end-start));\n\t\t\t  start=end+delimeter.size();}\n\t}\n\treturn words;\n}\n",
            1591238591.6981823,
            100,
            "# 答案正确"
        ],
        [
            "8.1 (C++)",
            "谢扬",
            "/*#ifndef FULL_H_\n#define FULL_H_*/\nclass Full:public Matrix\n{\n\tprivate:\n\t\tint rows,columns;\n\t\tdouble*values;\n\tpublic :\n\t\tFull():rows(0),columns(0),values(nullptr){}\n\t\tFull(int row,int col);\n\t\tFull(int row,int col,double*val);\n\t\tFull(const Matrix&m);\n\t\t~Full(){delete[]values;}\n\t\tint size(int dimension) const ;\n\t\n\t void set(int row, int column, double value) ;\n\t\n\t double get(int row, int column) const;\n\t\n\tvoid print() const ;\n\t\n\tMatrix & operator = (const Matrix & matrix2) ;\n};\nFull::Full(int row,int col):rows(row),columns(col)\n{\n\tvalues=new double[rows*columns]{};\n}\nFull::Full(int row,int col,double*val):rows(row),columns(col)\n{\n\tvalues=new double[rows*columns];\n\tfor(int i=0;i<rows*columns;++i)values[i]=val[i];\n}\nFull::Full(const Matrix&m):rows(m.size(1)),columns(m.size(2))\n{\n\tvalues=new double[rows*columns];\n\tfor(int i=0;i<rows*columns;++i)values[i]=m.get((i+1)%columns?(i+1)/columns+1:(i+1)/columns,(i+1)%columns?(i+1)%columns:columns);\n}\nint Full::size(int dimension) const\n{\n\tswitch(dimension)\n\t{\n\t\tcase 1:return rows;\n\t\tcase 2:return columns;\n\t}\n}\nvoid Full::set(int row, int column, double value)\n{\n\t(values+(row-1)*columns)[column-1]=value;\n}\ndouble Full::get(int row, int column) const\n{\n\treturn (values+(row-1)*columns)[column-1];\n}\nvoid Full::print() const \n{\n\tfor(int i=0;i<rows;++i)\n\t{\n\t\tfor(int j=0;j<columns;++j)cout<<(values+i*columns)[j]<<\"    \";\n\t\tcout<<endl;\n\t}\n}\nMatrix & Full::operator = (const Matrix & m)\n{\n\tif(this==&m)return *this;\n\tdelete[]values;\n\trows=m.size(1);\n\tcolumns=m.size(2);\n\tvalues=new double[rows*columns];\n\tfor(int i=0;i<rows*columns;++i)values[i]=m.get((i+1)%columns?(i+1)/columns+1:(i+1)/columns,(i+1)%columns?(i+1)%columns:columns);\n\treturn *this;\t\n}\n//#endif",
            1591332636.0035303,
            100,
            "# 答案正确"
        ],
        [
            "8.3 (C++)",
            "谢扬",
            "/*#ifndef FULL_H_\n#define FULL_H_*/\n#include<vector>\n#include<iostream>\nusing std::cout;\nusing std::vector;\nclass Sparse:public Matrix\n{\n\tprivate:\n\t\tint rows,columns;\n\t\tusing nonzero=vector<Entry>;\n\t\tnonzero values;\n\tpublic :\n\t\tSparse():rows(0),columns(0){}\n\t\tSparse(int row,int col):rows(row),columns(col){}\n\t\tint size(int dimension) const ;\n\t void set(int row, int column, double value) ;\n\t double get(int row, int column) const;\n\tvoid print()  ;\n\t Sparse operator + (const Sparse & s);\n};\nint Sparse::size(int dimension) const\n{\n\tswitch(dimension)\n\t{\n\t\tcase 1:return rows;\n\t\tcase 2:return columns;\n\t}\n}\nvoid Sparse::set(int row, int column, double value)\n{\n\tif(value){\n\tEntry data;\n\tdata.row=row;\n\tdata.column=column;\n\tdata.value=value;\n\tvalues.push_back(data);}\n}\ndouble Sparse::get(int row, int column) const\n{\n\tfor(int i=0;i<values.size();++i)\n\t\tif(values[i].row==row&&values[i].column==column)return values[i].value;\n\treturn 0;\n}\nvoid Sparse::print()  \n{\n\tint i;\n\tEntry temp;\n\tfor(i=1;i<values.size();++i)\n\t{\n\t\tfor(int j=i;j>0;--j)\n\t\t\tif(values[j].row<values[j-1].row)\n\t\t\t{temp=values[j-1];values[j-1]=values[j];values[j]=temp;}\n\t\telse if(values[j].row==values[j-1].row&&values[j].column<values[j-1].column){temp=values[j-1];values[j-1]=values[j];values[j]=temp;}\n\t}\n\tfor(i=0;i<values.size();++i)\n\t{\n\t\t\n\t\tcout<<\"(\"<<values[i].row<<\",\"<<values[i].column<<\",\"<<values[i].value<<\")\\n\";\n\t}\n}\n Sparse Sparse::operator + (const Sparse & s)\n {\n\t vector<int>added(s.values.size());\n\t int i,flag;\n\t Sparse res(rows,columns);\n\t\t for(i=0;i<values.size();++i)\n\t\t {\tflag=0;\n\t\t\t for(int j=0;j<s.values.size();++j)\n\t\t\t\tif( values[i].row==s.values[j].row&&values[i].column==s.values[j].column){flag=1;added[j]=1;if(values[i].value+s.values[j].value)res.set(values[i].row,values[i].column,values[i].value+s.values[j].value);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t }\n\t\t\t if(!flag)res.set(values[i].row,values[i].column,values[i].value);\n\t\t }\n\t \t for(i=0;i<s.values.size();++i)if(!added[i])res.set(s.values[i].row,s.values[i].column,s.values[i].value);\n\t\t return res;\n }\n//#endif",
            1591349844.4949446,
            100,
            "# 答案正确"
        ],
        [
            "8.4 (C++)",
            "谢扬",
            "/*#ifndef FULL_H_\n#define FULL_H_*/\n#include<vector>\n#include<iostream>\n#include<map>\nusing std::cout;\nusing std::vector;\nusing std::map;\nclass Sparse:public Matrix\n{\n\tprivate:\n\t\tint rows,columns;\n\t\tusing nonzero=vector<Entry>;\n\t\tnonzero values;\n\tpublic :\n\t\tSparse():rows(0),columns(0){}\n\t\tSparse(int row,int col):rows(row),columns(col){}\n\t\tint size(int dimension) const ;\n\t void set(int row, int column, double value) ;\n\t double get(int row, int column) const;\n\tvoid print()  ;\n\t Sparse operator *(const Sparse & s);\n};\nint Sparse::size(int dimension) const\n{\n\tswitch(dimension)\n\t{\n\t\tcase 1:return rows;\n\t\tcase 2:return columns;\n\t}\n}\nvoid Sparse::set(int row, int column, double value)\n{\n\tif(value){\n\tEntry data;\n\tdata.row=row;\n\tdata.column=column;\n\tdata.value=value;\n\tvalues.push_back(data);}\n}\ndouble Sparse::get(int row, int column) const\n{\n\tfor(int i=0;i<values.size();++i)\n\t\tif(values[i].row==row&&values[i].column==column)return values[i].value;\n\treturn 0;\n}\nvoid Sparse::print()  \n{\n\tint i;\n\tEntry temp;\n\tfor(i=1;i<values.size();++i)\n\t{\n\t\tfor(int j=i;j>0;--j)\n\t\t\tif(values[j].row<values[j-1].row)\n\t\t\t{temp=values[j-1];values[j-1]=values[j];values[j]=temp;}\n\t\telse if(values[j].row==values[j-1].row&&values[j].column<values[j-1].column){temp=values[j-1];values[j-1]=values[j];values[j]=temp;}\n\t}\n\tfor(i=0;i<values.size();++i)\n\t{\n\t\t\n\t\tcout<<\"(\"<<values[i].row<<\",\"<<values[i].column<<\",\"<<values[i].value<<\")\\n\";\n\t}\n}\n Sparse Sparse::operator *(const Sparse & s)\n {\n\t using r=int;\n\t using col=int;\n\t map<r,nonzero>each_row;\n\t map<col,nonzero>each_col;\n\t int i,j,flag;\n\t double sum;\n\t for(i=0;i<values.size();++i)\n\t {\n\t\t each_row[values[i].row].push_back(values[i]); \n\t }\n\t for(i=0;i<s.values.size();++i)\n\t {\n\t\t each_col[s.values[i].column].push_back(s.values[i]); \n\t }\n\t Sparse res(rows,s.columns);\n\tfor(map<r,nonzero>::iterator it=each_row.begin();it!=each_row.end();++it)\n\t{sum=0;\n\t\tfor(map<col,nonzero>::iterator it2=each_col.begin();it2!=each_col.end();++it2)\n\t\t{sum=0;\n\t\t\tfor(i=0;i<it2->second.size();++i)\n\t\t\t\tfor(j=0;j<it->second.size();++j)\t\tif(it2->second[i].row==it->second[j].column)sum+=it2->second[i].value*it->second[j].value;\n\t\t res.set(it->first,it2->first,sum);\n\t\t}\n\t}\n\t\t return res;\n }\n//#endif",
            1591410928.0253716,
            100,
            "# 答案正确"
        ],
        [
            "8.5 (C++)",
            "谢扬",
            "//#ifndef POINT3D_H_\n//#define POINT3D_H_\nclass Point3D:public Point2D\n{\n\tprivate:\n\t\tdouble z;\n\tpublic:\n\t\tPoint3D():z(0){}\n\t\tPoint3D(double x1,double x2, double x3):z(x3){setX(x1);setY(x2);}\n\t\tvoid setZ(double m_z){z=m_z;}\n\t\tdouble getZ(){return z;}\n\t\tdouble distance(Point2D & point2) {double dx = getX() - point2.getX();\n\t\tdouble dy = getY() - point2.getY();\n\t\tPoint3D& p2=static_cast<Point3D&>(point2);\n\t\tdouble dz=z-p2.z;\n\t\treturn sqrt(dx * dx + dy * dy+dz*dz);}\n\t\t\n};\n//#endif",
            1591843633.8101866,
            100,
            "# 答案正确"
        ],
        [
            "8.6 (C++)",
            "谢扬",
            "//#ifndef MYTENSOR_H_\n//#define MYTENSOR_H_\n#include<iostream>\nusing std::cin;\nusing std::cout;\nusing std::endl;\nclass MyTensor :public Tensor<double>\n{\n\tprivate:vector<double> data;\n\tpublic:\n\t\tMyTensor(vector<int> m_sizes);\n\t\tdouble & get(const vector<int> & indexes);\n};\n\nMyTensor::MyTensor(vector<int> m_sizes):Tensor<double>(m_sizes)\n{\n\tint product(1);\n\tfor(int i=0; i<sizes.size(); ++i)\n\t\tproduct*=sizes[i]+1;\n\tdata.resize(product);\n}\n\ndouble & MyTensor::get(const vector<int> & indexes)\n{\n\tswitch(indexes.size())\n\t{\n\t\tcase 1:return data[indexes[0]];\n\t\tcase 2:return data[indexes[0]*(sizes[1]+1)+indexes[1]];\n\t\tcase 3:return data[indexes[0]*(sizes[1]+1)*(sizes[2]+1)+indexes[1]*(sizes[2]+1)+indexes[2]];\n\t\tcase 4:return data[indexes[0]*(sizes[1]+1)*(sizes[2]+1)*(sizes[3]+1)+indexes[1]*(sizes[2]+1)*(sizes[3]+1)+indexes[2]*(sizes[3]+1)+indexes[3]];\n\t}\n}\n//#endif",
            1592448987.567035,
            100,
            "# 答案正确"
        ],
        [
            "9.1 (C++)",
            "谢扬",
            "/*#ifndef CIRCLE_H_\n#define CIRCLE_H_*/\nclass Circle\n{\n\tprivate:double radius;\n\tpublic:\n\t\tCircle(double r=0.0):radius(r){};\n\t\tbool operator< (const Circle& yuan){return radius<yuan.radius;}\n\t\tbool operator<= (const Circle& yuan){return radius<=yuan.radius;}\n\t\tbool operator> (const Circle& yuan){return radius>yuan.radius;}\n\t\tbool operator>= (const Circle& yuan){return radius>=yuan.radius;}\n\t\tfriend bool operator== (const Circle& circle1, const Circle& circle2){return circle1.radius==circle2.radius;}\n\t\tfriend bool operator!= (const Circle& circle1, const Circle& circle2){return circle1.radius!=circle2.radius;}\n\t\n};\n//#endif",
            1592541331.486065,
            100,
            "# 答案正确"
        ],
        [
            "9.2 (C++)",
            "谢扬",
            "/*#ifndef I_H_\n#define I_H_*/\nclass I\n{\n\tprivate:vector<int>sizes;\n\tpublic:\n\t\tI(int i1, int i2=-1, int i3=-1, int i4=-1);\n\t\toperator vector<int>()const{return sizes;}\n};\nI::I(int i1, int i2, int i3, int i4)\n{\n\tsizes.push_back(i1);\n\tif(i2==-1)return;\n\t\tsizes.push_back(i2);\n\tif(i3==-1)\n\treturn;\n\tsizes.push_back(i3);\n\tif(i4==-1)return;\n\tsizes.push_back(i4);\n\t\n}\n//#endif",
            1592542277.7067974,
            100,
            "# 答案正确"
        ],
        [
            "9.3 (C++)",
            "谢扬",
            "/*#ifndef COMPLEX_H_\n#define COMPLEX_H_*/\nclass Complex\n{\n\tprivate:\n\t\tdouble rea,image;\n\tpublic:\n\t\tComplex(double r=0.0, double i=0.0):rea(r),image(i){}\n\t\tdouble real()const{return rea;}\n\t\tdouble imag()const{return image;}\n\t\tfriend Complex operator+(const Complex& z1, const Complex& z2);\n\t\tfriend Complex operator*(const Complex& z1, const Complex& z2);\n\t\tComplex operator- (const Complex& z2)const;\n\t\tComplex operator/ (const Complex& z2)const;\n\t\tComplex& operator*= (const Complex& z2);\n\t\tComplex& operator/= (const Complex& z2);\n\t\tComplex& operator-= (const Complex& z2);\n\t\tComplex& operator+= (const Complex& z2);\n\t\tfriend bool operator== (const Complex& z1, const Complex& z2){return z1.rea==z2.rea && z1.image==z2.image;}\n\t\tfriend bool operator!= (const Complex& z1, const Complex& z2){return z1.rea!=z2.rea || z2.image!=z2.image;}\n};\nComplex operator+(const Complex& z1, const Complex& z2)\n{\n\treturn Complex(z1.rea+z2.rea, z1.image+z2.image);\n}\nComplex operator*(const Complex& z1, const Complex& z2)\n{\n\treturn Complex(z1.rea*z2.rea-z1.image*z2.image, z1.rea*z2.image+z1.image*z2.rea);\n}\nComplex Complex::operator- (const Complex& z2)const\n{\n\treturn Complex(rea-z2.rea,image-z2.image);\n}\nComplex Complex::operator/ (const Complex& z2)const\n{\n\treturn Complex((rea*z2.rea+image*z2.image)/(z2.rea*z2.rea+z2.image*z2.image),(z2.rea*image-rea*z2.image)/(z2.rea*z2.rea+z2.image*z2.image)); \n}\nComplex& Complex::operator*= (const Complex& z2)\n{\n\treturn *this=*this*z2;\n}\nComplex& Complex::operator/= (const Complex& z2)\n{\n\treturn *this=*this/z2;\n}\nComplex& Complex::operator-= (const Complex& z2)\n{\n\treturn *this=*this-z2;\n}\nComplex& Complex::operator+= (const Complex& z2)\n{\n\treturn *this=*this+z2;\n}\n//#endif",
            1592556674.4190638,
            100,
            "# 答案正确"
        ],
        [
            "9.4 (C++)",
            "谢扬",
            "/*#ifndef COMPLEX_H_\n#define COMPLEX_H_*/\nclass Complex\n{\n\tprivate:\n\t\tdouble rea,image;\n\tpublic:\n\t\tComplex(double r=0.0, double i=0.0):rea(r),image(i){}\n\t\tdouble real()const{return rea;}\n\t\tdouble imag()const{return image;}\n\t\tfriend Complex operator+(const Complex& z1, const Complex& z2);\n\t\tfriend Complex operator*(const Complex& z1, const Complex& z2);\n\t\tfriend istream& operator>> (istream& is, Complex& z)\n\t\t{\n\t\t\tis>>z.rea>>z.image;\n\t\t\treturn is;\n\t\t}\n\t\tfriend ostream& operator<< (ostream& os, Complex& z)\n\t\t{\n\t\t\tos<<z.rea<<\" + \"<<z.image<<\" i\" ;\n\t\t\treturn os;\n\t\t}\n\t\tComplex operator- (const Complex& z2)const;\n\t\tComplex operator/ (const Complex& z2)const;\n\t\tComplex& operator*= (const Complex& z2);\n\t\tComplex& operator/= (const Complex& z2);\n\t\tComplex& operator-= (const Complex& z2);\n\t\tComplex& operator+= (const Complex& z2);\n\t\tfriend bool operator== (const Complex& z1, const Complex& z2){return z1.rea==z2.rea && z1.image==z2.image;}\n\t\tfriend bool operator!= (const Complex& z1, const Complex& z2){return z1.rea!=z2.rea || z2.image!=z2.image;}\n};\nComplex operator+(const Complex& z1, const Complex& z2)\n{\n\treturn Complex(z1.rea+z2.rea, z1.image+z2.image);\n}\nComplex operator*(const Complex& z1, const Complex& z2)\n{\n\treturn Complex(z1.rea*z2.rea-z1.image*z2.image, z1.rea*z2.image+z1.image*z2.rea);\n}\nComplex Complex::operator- (const Complex& z2)const\n{\n\treturn Complex(rea-z2.rea,image-z2.image);\n}\nComplex Complex::operator/ (const Complex& z2)const\n{\n\treturn Complex((rea*z2.rea+image*z2.image)/(z2.rea*z2.rea+z2.image*z2.image),(z2.rea*image-rea*z2.image)/(z2.rea*z2.rea+z2.image*z2.image)); \n}\nComplex& Complex::operator*= (const Complex& z2)\n{\n\treturn *this=*this*z2;\n}\nComplex& Complex::operator/= (const Complex& z2)\n{\n\treturn *this=*this/z2;\n}\nComplex& Complex::operator-= (const Complex& z2)\n{\n\treturn *this=*this-z2;\n}\nComplex& Complex::operator+= (const Complex& z2)\n{\n\treturn *this=*this+z2;\n}\n//#endif",
            1592557178.7126677,
            100,
            "# 答案正确"
        ],
        [
            "9.5 (C++)",
            "谢扬",
            "/*#ifndef COMPLEX_H_\n#define COMPLEX_H_*/\nclass Complex\n{\n\tprivate:\n\t\tdouble rea,image;\n\tpublic:\n\t\texplicit Complex(double r=0.0, double i=0.0):rea(r),image(i){}\n\t\tdouble real()const{return rea;}\n\t\tdouble imag()const{return image;}\n\t\tfriend Complex operator+(const Complex& z1, const Complex& z2);\n\t\tfriend Complex operator*(const Complex& z1, const Complex& z2);\n\t\tfriend istream& operator>> (istream& is, Complex& z)\n\t\t{\n\t\t\tis>>z.rea>>z.image;\n\t\t\treturn is;\n\t\t}\n\t\tfriend ostream& operator<< (ostream& os, const Complex& z)\n\t\t{\n\t\t\tos<<z.rea<<\" + \"<<z.image<<\" i\" ;\n\t\t\treturn os;\n\t\t}\n\t\tComplex operator- (const Complex& z2)const;\n\t\tComplex operator/ (const Complex& z2)const;\n\t\tComplex& operator*= (const Complex& z2);\n\t\tComplex& operator/= (const Complex& z2);\n\t\tComplex& operator-= (const Complex& z2);\n\t\tComplex& operator+= (const Complex& z2);\n\t\tComplex& operator++ (){return *this=*this+Complex(1.0);}\n\t\tComplex operator++ (int){Complex z(*this);\n\t\t\t\t\t\t\t\t *this=*this+Complex(1.0);return z;}\n\t\toperator double(){return rea;}\n\t\tfriend bool operator== (const Complex& z1, const Complex& z2){return z1.rea==z2.rea && z1.image==z2.image;}\n\t\tfriend bool operator!= (const Complex& z1, const Complex& z2){return z1.rea!=z2.rea || z2.image!=z2.image;}\n};\nComplex operator+(const Complex& z1, const Complex& z2)\n{\n\treturn Complex(z1.rea+z2.rea, z1.image+z2.image);\n}\nComplex operator*(const Complex& z1, const Complex& z2)\n{\n\treturn Complex(z1.rea*z2.rea-z1.image*z2.image, z1.rea*z2.image+z1.image*z2.rea);\n}\nComplex Complex::operator- (const Complex& z2)const\n{\n\treturn Complex(rea-z2.rea,image-z2.image);\n}\nComplex Complex::operator/ (const Complex& z2)const\n{\n\treturn Complex((rea*z2.rea+image*z2.image)/(z2.rea*z2.rea+z2.image*z2.image),(z2.rea*image-rea*z2.image)/(z2.rea*z2.rea+z2.image*z2.image)); \n}\nComplex& Complex::operator*= (const Complex& z2)\n{\n\treturn *this=*this*z2;\n}\nComplex& Complex::operator/= (const Complex& z2)\n{\n\treturn *this=*this/z2;\n}\nComplex& Complex::operator-= (const Complex& z2)\n{\n\treturn *this=*this-z2;\n}\nComplex& Complex::operator+= (const Complex& z2)\n{\n\treturn *this=*this+z2;\n}\n//#endif",
            1592559417.549959,
            100,
            "# 答案正确"
        ],
        [
            "9.6 (C++)",
            "谢扬",
            "class Tensor\n{\n\tprivate:vector<int>sizes;\n\tclass Indexes\n\t{\n\t\tprivate:\n\t\t\tvector<int>indexes;\n\t\tpublic :\n\t\t\tIndexes(int i1, int i2=-1, int i3=-1, int i4=-1);\n\t\t\tconst vector<int>& use_indexes()const{return indexes;}\n\t\tconst int& operator[](int i)const{return indexes[i];}\n\t};\n\tvector<double>data;\n\tint total_size()const;\n\tint get_index(const Indexes& id)const;\n\tpublic:\n\t\tTensor(int i1, int i2=-1, int i3=-1, int i4=-1);\n\t\tdouble& operator() (int i1, int i2=-1, int i3=-1, int i4=-1);\n\t\tconst double& operator() (int i1, int i2=-1, int i3=-1, int i4=-1)const;\n};\nint Tensor::get_index(const Indexes& id)const\n{\n\tint index(0);\n\tfor(int i=0; i<sizes.size(); ++i)\n\t{\n\t\tindex*=sizes[i];\n\t\tindex+=id[i];\n\t}\n\treturn index;\n}\nTensor::Indexes::Indexes(int i1, int i2, int i3, int i4)\n{\n\tindexes.push_back(i1);\n\tif(i2==-1)return;\n\tindexes.push_back(i2);\n\tif(i3==-1)return;\n\tindexes.push_back(i3);\n\tif(i4==-1)return;\n\tindexes.push_back(i4);\t\n}\nint Tensor::total_size()const\n{\n\tif(!sizes.size())return 0;\n\tint total=1;\n\tfor(int i=0; i<sizes.size(); ++i)\n\t\ttotal*=sizes[i];\n\treturn total;\n}\nTensor::Tensor(int i1, int i2, int i3, int i4)\n{\n\tIndexes size(i1,i2,i3,i4);\n\tsizes=size.use_indexes();\n\tdata.resize(total_size());\n}\ndouble& Tensor::operator() (int i1, int i2, int i3, int i4)\n{\n\tIndexes i(i1,i2,i3,i4);\n\treturn data[get_index(i)];\n}\nconst double& Tensor::operator() (int i1, int i2, int i3, int i4)const\n{\n\tIndexes i(i1,i2,i3,i4);\n\treturn data[get_index(i)];\n}\n",
            1592570159.338128,
            100,
            "# 答案正确"
        ],
        [
            "9.7 (C++)",
            "谢扬",
            "class Tensor\n{\n\tprivate:\n\tint dimensions;\n\tvector<int>sizes;\n\tvector<double>data;\n\tint size(const vector<int>& val)const;\n\tvoid print()const{for(int i=0; i<sizes.size(); ++i)cout<<sizes[i]<<\" \";cout<<\"\\n\\n\";}\n\tpublic:\n\t\tTensor():dimensions(0){}\n\t\tfriend istream& operator>> (istream& is, Tensor& t);\n\t\tfriend ostream& operator<< (ostream& os, const Tensor t);\n};\nistream& operator>> (istream& is, Tensor& t)\n{\n\tis>>t.dimensions;\n\tt.sizes.resize(t.dimensions);\n\tfor(int i=0; i<t.dimensions; ++i)is>>t.sizes[i];\n\tt.data.resize(t.size(t.sizes));\n\tvector<int> ahead=t.sizes;\n\tahead.resize(t.dimensions-2);\n\tfor(int i=0; i<t.size(ahead); ++i)\n\t\tfor(int j=0; j<t.sizes[t.dimensions-2]; ++j)\n\t\t\tfor(int k=0; k<t.sizes[t.dimensions-1]; ++k)\n\t\t\t\tis >> t.data[i*t.sizes[t.dimensions-2]*t.sizes[t.dimensions-1]+j*t.sizes[t.dimensions-1]+k];\n  return is;\n}\n ostream& operator<< (ostream& os, const Tensor t)\n {\n\t os<<t.dimensions<<endl;\n\t t.print();\n\t vector<int> ahead=t.sizes;\n\tahead.resize(t.dimensions-2);\n\t for(int i=0; i<t.size(ahead); ++i){\n\t\tfor(int j=0; j<t.sizes[t.dimensions-2]; ++j)\n\t\t{for(int k=0; k<t.sizes[t.dimensions-1]; ++k)\n\t\t\t\tos << t.data[i*t.sizes[t.dimensions-2]*t.sizes[t.dimensions-1]+j*t.sizes[t.dimensions-1]+k]<<\" \";\n\t os<<endl;}os<<\"\\n\";}\n\t return os;\n }\nint Tensor::size(const vector<int>& val)const\n{\n\tif(!val.size())return 0;\n\tint total=1;\n\tfor(int i=0; i<val.size(); ++i)\n\t\ttotal*=val[i];\n\treturn total;\n}\n\n",
            1592575102.7974353,
            100,
            "# 答案正确"
        ],
        [
            "10.1 (C++)",
            "谢扬",
            "#include<stdexcept>\nusing std::out_of_range;\nclass MatrixSizesDoNotMatchException:std::logic_error\n{public:\n\tMatrixSizesDoNotMatchException(const char* s):logic_error(s){}\n};\ndouble Matrix::get(int row, int column) const\n{\n\tif (row <= 0 || column <= 0 || row > rows || column > columns) throw out_of_range(\"out_of_range\");\n\treturn elements[(row - 1) * columns + column - 1];\n}\n\t\nvoid Matrix::set(int row, int column, double value)\n{\n\tif (row <= 0 || column <= 0 || row > rows || column > columns) throw out_of_range(\"out_of_range\");\n    elements[(row - 1) * columns + column - 1] = value;\n}\n\t\nMatrix Matrix::operator + (const Matrix & matrix2) const\n{\n\tif (rows != matrix2.rows || columns != matrix2.columns)\n\t\tthrow MatrixSizesDoNotMatchException(\"caught: MatrixSizesDoNotMatchException\");\n\tMatrix res(rows, columns);\n\tfor (int i = 0; i < rows * columns; ++i)\n\t\tres.elements[i] = elements[i] + matrix2.elements[i];\n\treturn res;\n}",
            1593332567.554061,
            100,
            "# 答案正确"
        ],
        [
            "10.2 (C++)",
            "谢扬",
            "catch (NonPositiveValueException& ex)\n{\n\tcout<<\"caught: NonPositiveValueException\\n\";\n}\ncatch (out_of_range& ex)\n{\n\tcout<<\"caught: out_of_range\\n\";\n}",
            1593656259.578237,
            100,
            "# 答案正确"
        ],
        [
            "15.1 (C++)",
            "谢扬",
            "/*#ifndef TABLE_H_\n#define TABLE_H_*/\n#include <iostream>\n#include <string>\n#include <vector>\n#include <stdexcept>\nusing namespace std;\nclass Table\n{\n\tprivate:\n\t\tvector<string> header;\n\t\tint columns, rows;\n\t\tvector<vector<string>> contents;\n\tpublic:\n\t\tTable();\n\t\tint addCol(const string& head);\n\t\tconst vector<string>& operator[](int id)const;\n\t\tvector<string>& operator[](int id);\n\t\tstring json()const;\n};\nTable::Table(){rows = columns = 0;}\nint Table::addCol(const string& head)\n{\n\theader.push_back(head);\n\tcolumns++;\n\treturn columns;\n}\nconst vector<string>& Table::operator[](int id)const\n{\n\tif (id < 0 || id >= contents.size()) throw out_of_range(\"ID is negative which is not allowed\");\n\treturn contents[id];\n}\nvector<string>& Table::operator[](int id)\n{\n\tif (id < 0 || id > contents.size()) throw out_of_range(\"ID is negative which is not allowed\");\n\tif (id == contents.size()) {contents.push_back(vector<string> (columns)); rows++;}\n\treturn contents[id];\n}\nstring Table::json()const\n{\n\tint i;\n\tfor (i = 0; i < rows; ++i)\n\t\tif (contents[i].size() > columns)\n\t\t\tthrow out_of_range(\"Num of string shouldn't overcome the tables' columns!\");\n\tstring format = \"{\\n       headers: [\";\n\tfor (i = 0; i < header.size(); ++i)\n\t{\n\t\tformat += \"'\"; format += header[i]; format += \"',\";\n\t}\n\tformat += \"],\\n       rows: [\\n\";\n\tfor (i = 0; i < rows; ++i)\n\t{\n\t\tformat += \"               [\"; \n\t\tfor (int j = 0; j < columns; ++j)\n\t\t{format += \"'\"; format += contents[i][j]; format += \"',\";}\n\t\tformat += \"],\\n\";\n\t}\n\tformat += \"       ],\\n}\";\n\treturn format;\n}\n//#endif",
            1593781164.5565796,
            100,
            "# 答案正确"
        ],
        [
            "2020-07-09 LAB",
            "谢扬",
            "/*#ifndef INTEGER_H_\n#define INTEGER_H_*/\n#include <iostream>\nclass Integer\n{\n\tprivate:\n\t\tstatic int increasement;\n\t\tint data_now;\n\tpublic:\n\t\tInteger(int num = 0): data_now(num){}\n\t\tstatic void increase_all(const Integer& integer){increasement += integer.data_now + increasement;} \n\t\tfriend std::istream& operator >>(std::istream& is, Integer& integer){is >> integer.data_now; return is;}\n\t\tfriend std::ostream& operator <<(std::ostream& os, const Integer& integer){os << integer.data_now + increasement; return os;}\n};\nint Integer::increasement;\n//#endif",
            1594264669.9243286,
            100,
            "# 答案正确"
        ],
        [
            "A.1 (C++)",
            "谢扬",
            "void addFirst(const E& val)\n{\n\tNode<E>* node = new Node<E>;\n\tnode -> element = val;\n\tnode -> update_prev_and_next_node(nullptr, head);\n\tif (head)\n\t\thead -> update_prev_node(nullptr, node);\n\thead = node;\n\tif (!tail)\n\t\ttail = node;\n\t++ _size;\n}\nvoid addLast(const E& val)\n{\n\tNode<E>* node = new Node<E>;\n\tnode -> element = val;\n\tnode -> update_prev_and_next_node(tail, nullptr);\n\tif (tail)\n\ttail -> update_next_node(nullptr, node);\n\ttail = node;\n\tif (!head)\n\t\thead = node;\n\t++ _size;\n}\nvoid removeFirst()\n{\n\tif (_size <= 0) throw NotSuchElementException();\n\tNode<E>* temp = head;\n\thead = head -> next_node(nullptr);\n\tif (head)\n\thead -> update_prev_node(temp, nullptr);\n\telse tail = nullptr;\n\tdelete temp;\n\t-- _size;\n}\nvoid removeLast()\n{\n\tif (_size <= 0) throw NotSuchElementException();\n\tNode<E>* temp = tail;\n\ttail = tail -> prev_node(nullptr);\n\tif (tail)\n\ttail -> update_next_node(temp, nullptr);\n\telse head = nullptr;\n\tdelete temp;\n\t-- _size;\n}\nvoid removeFirstOccurrence(const E& val)\n{\n\tNode<E>* node = head;\n\tNode<E>* prev_node , *temp;\n\tprev_node = temp = nullptr;\n\twhile (node)\n\t{\n\t\tif (node -> element == val)\n\t\t\tbreak;\n\t\ttemp = node;\n\t\tnode = node -> next_node(prev_node);\n\t\tprev_node = temp;\n\t}\n\tif (!node) throw NotSuchElementException();\n\tif (!prev_node) removeFirst();\n\telse if (node == tail) removeLast();\n\telse\n\t{\n\t\ttemp = node -> next_node(prev_node);\n\t\tprev_node -> update_next_node(node, temp);\n\t\ttemp -> update_prev_node(node, prev_node);\n\t\tdelete node;\n\t\t-- _size;\n\t}\n}\nconst E& get(int index) const\n{\n\tif (index < 0 || index >= _size) throw NotSuchElementException();\n\tNode<E>* node1 = head;\n\tNode<E>* node2 = tail;\n\tNode<E>* prev_node1, *next_node2, *temp;\n\ttemp = prev_node1 = next_node2 = nullptr;\n\tif (index < _size / 2)\n\t{\n\t\t I(i, index) //for (int i = 0; i < index; ++i)\n\t    {\n\t\t\ttemp = node1;\n\t\t\tnode1 = node1 -> next_node(prev_node1);\n\t\t\tprev_node1 = temp;\n\t    }\n\t\treturn node1 -> element;\n\t}\n\telse \n\t{\n\t\t I(i, _size - 1 - index) //for (int i = 0; i < _size - 1 - index; ++i)\n\t\t{\n\t\t\ttemp = node2;\n\t\t\tnode2 = node2 -> prev_node(next_node2);\n\t\t\tnext_node2 = temp;\n\t\t}\n\t\treturn node2 -> element;\n\t}\n}\nLinkedList(const LinkedList& list):_size(0)\n{\n\thead = tail = nullptr;\n\tcopy_all(list);\n}\nprivate: \n\tvoid copy_all(const LinkedList& list)\n\t{\n\t\tif (list._size)\n\t\t{\n\t\t\t I(i, list._size) //for (int i = 0; i < _size; ++i)\n\t\t\t\taddLast(list.get(i));\n\t\t}\n\t}\n\tvoid delete_all()\n\t{\n\t\tint size =  _size;\n\t\t  I(i, size)//for (int i = 0; i < _size; ++i) \n\t\t\tremoveLast();\n\t}\npublic:\nLinkedList& operator= (const LinkedList& list)\n{\n\tif (this == &list) return *this;\n\tdelete_all();\n\tcopy_all(list);\n\treturn *this;\n}\n~LinkedList(){delete_all();}",
            1594438957.8258526,
            100,
            "# 答案正确"
        ],
        [
            "A.2 (C++)",
            "谢扬",
            "template <typename E>\nvoid LinkedList<E>::removeAll(const E & e)\n{\n\twhile (contains(e))\n\t{\n\t\tremove(indexOf(e));\n\t}\n}",
            1594865846.684003,
            100,
            "# 答案正确"
        ],
        [
            "A.4 (C++)",
            "谢扬",
            "/*#ifndef HT_H_\n#define HT_H_*/\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <stdexcept>\nusing std::vector;\nusing std::stringstream;\nusing std::istream;\nusing std::ostream;\nusing std::string;\nusing std::logic_error;\ntemplate<class T>\nvoid to_string(const T& k1, string& k2);\ntemplate<class T>\nvoid to_int(const T& k1, int& k2);\n#define Loop(i,n) for (int i = 0; i < n; ++ i) \nclass HT\n{\n\tpublic:\n\t\tclass Tuple\n\t\t{\n\t\t\tpublic:\n\t\t\t\tint key, value;\n\t\t\t\tbool in_use;\n\t\t\t\tTuple():in_use(false){}\n\t\t\t\tTuple(int key, int value):key(key)\n\t\t\t\t, value(value), in_use(true){}\n\t\t\t\toperator int()const{return value;}\n\t\t\t\toperator string()const{string str; to_string(value, str); return str;}\n\t\t};\n    private:\n\t\tvector<Tuple> tuples;\n\t\tint in_use_size;\n\t\n\t\tint Hash_Function(int key)const;\n\t\tint indexOfkey(int key)const;\n\t\tvoid double_tuples();\n\tpublic:\n\t\tHT(int initial_totalSize = 9):in_use_size(0){tuples.resize(initial_totalSize);}\n\t\ttemplate<class T1, class T2>\n\t\tvoid put(const T1& key, const T2& value);\n\t\tint size()const {return in_use_size;}\n\t\ttemplate<class T>\n\t\tconst Tuple& operator [](const T& key)const;\n};\ntemplate<class T>\nconst HT::Tuple& HT::operator [](const T& k)const\n{\n\tint key ;\n\tto_int(k, key);\n\tint index = indexOfkey(key);\n\tif (!tuples[index].in_use) throw logic_error(\"Not such key!\\n\");\n\treturn tuples[index];\t\n}\nint HT::Hash_Function(int key)const // generate hash_code\n{\n\treturn key % tuples.size();\n}\nint HT::indexOfkey(int key)const // arrange index\n{\n\t\tint index = Hash_Function(key);\n\t\twhile (tuples[index].in_use && tuples[index].key != key)\n\t\t{\n\t\t\tindex = (index + 1) % tuples.size();\n\t\t}\n\t\treturn index;\n}\ntemplate<class T>\nvoid to_int(const T& k1, int& k2)\n{\n\tstringstream ss;\n\tss << k1; ss >> k2;\n}\ntemplate<class T>\nvoid to_string(const T& k1, string& k2)\n{\n\tstringstream ss;\n\tss << k1; ss >> k2;\n}\ntemplate<class T1, class T2>\nvoid HT::put(const T1& k, const T2& val)\n{\n\tint key, value;\n\tto_int(k, key); to_int(val, value);\n\tint index = indexOfkey(key);\n\tTuple tuple(key, value);\n\ttuples[index] = tuple; ++ in_use_size;\n\tif (2 * in_use_size > tuples.size() )\n\t\tdouble_tuples();\n\treturn;\n}\nvoid HT::double_tuples()\n{\n\tvector<Tuple> notEmpty_tuples;\n\tLoop(i, tuples.size()) if (tuples[i].in_use) notEmpty_tuples.push_back(tuples[i]);\n\tint preSize = tuples.size();\n\ttuples.clear();\n\ttuples.resize(2 * preSize);\n\tin_use_size = 0;\n\tLoop(i, notEmpty_tuples.size()) put(notEmpty_tuples[i].key, notEmpty_tuples[i].value);\n}\n//#endif",
            1595140572.6821263,
            100,
            "# 答案正确"
        ],
        [
            "A.5 (C++)",
            "谢扬",
            "/*#ifndef HT_H_\n#define HT_H_*/\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <stdexcept>\nusing std::vector;\nusing std::stringstream;\nusing std::istream;\nusing std::ostream;\nusing std::string;\nusing std::logic_error;\nusing std::cout;\nusing std::endl;\n#define Loop(i,n) for (int i = 0; i < n; ++ i) \ntemplate <class T1, class T2>\nvoid convert(const T1& wait_for_convert, T2& goal) ;\nclass HT\n{\n\tpublic:\n\t\tclass IntOrString\n\t\t{\n\t\t\tpublic:\n\t\t\t\tenum Mode{Int, String};\n\t\t\tprivate:\n\t\t\t\tMode type;\n\t\t\t\tint int_val;\n\t\t\t\tstring str_val;\n\t\t\t\ttemplate <class T1, class T2>\n\t\t\t\tfriend void convert(const T1& wait_for_convert, T2& goal) // from T1 to T2\n\t\t\t\t{ stringstream ss; ss << wait_for_convert; ss >> goal;}\n\t\t\tpublic:\n\t\t\t\tIntOrString(){}\n\t\t\t\tIntOrString(int val): type(Int), int_val(val){}\t\n\t\t\t\tIntOrString(const string& val): type(String), str_val(val){}\n\t\t\t\tIntOrString(const IntOrString& intOrString):type(intOrString.type), int_val(intOrString.int_val), str_val(intOrString.str_val){}\n\t\t\t\toperator int()const;\n\t\t\t\toperator string()const;\n\t\t\t\tMode Type()const{return type;}\n\t\t};\n\tprivate:\n\t\tclass Tuple\n\t\t{\n\t\t\tprivate:\n\t\t\t\tIntOrString key, value;\n\t\t\t\tbool in_use;\n\t\t\tpublic:\n\t\t\t\tTuple(const IntOrString& k):key(k), in_use(true){}\n\t\t\t\tTuple():in_use(false){}\n\t\t\t\tbool In_use()const{return in_use;}\n\t\t\t\tconst IntOrString& Key()const{return key;}\n\t\t\t\tIntOrString& Value(){return value;}\n\t\t\t\tconst IntOrString& Value()const{return value;}\n\t\t};\n\t\tvector<Tuple> tuples;\n\t\tint in_use_size;\n\t\n\t\tint hash_function(const IntOrString& key)const;\n\t\tint indexOfkey(const IntOrString& key)const;\n\t\tvoid double_tuples();\n\tpublic:\n\t\tHT(int initial_size = 9):in_use_size(0){tuples.resize(initial_size);}\n\t\tint size()const{return in_use_size;}\n\t\tIntOrString& operator [](const IntOrString& key);\n\t\tconst IntOrString& operator [](const IntOrString& key)const;\n};\nHT::IntOrString::operator int()const\n{\n\tswitch(type)\n\t{\n\t\tcase Int: return int_val;\n\t\tcase String: {int val; convert(str_val, val);\n\t\t\t\t\treturn val;}\n\t}\n}\nHT::IntOrString::operator string()const\n{\n\tswitch(type)\n\t{\n\t\tcase Int: {string val; convert(int_val, val); return val;}\n\t\tcase String: return str_val;\n\t}\n}\nint HT::hash_function(const IntOrString& key)const\n{\n\tswitch (key.Type())\n\t{\n\t\tcase IntOrString::Int: return int(key) % tuples.size();\n\t\tcase IntOrString::String: return (int(key) + 1) % tuples.size();\n\t}\n}\nint HT::indexOfkey(const IntOrString& key)const\n{\n\tint index = hash_function(key);\n\twhile (tuples[index].In_use() && (tuples[index].Key().Type() != key.Type() || int(tuples[index].Key()) != int(key) ))\n\t\tindex = (index + 1) % tuples.size();\n\treturn index;\n}\nvoid HT::double_tuples()\n{\n\tvector<Tuple> notEmpty;\n\tLoop(i, tuples.size())\n\t\tif (tuples[i].In_use())\n\t\t\tnotEmpty.push_back(tuples[i]);\n\tint prevSize = tuples.size();\n\ttuples.clear();\n\tin_use_size = 0;\n\ttuples.resize(2 * prevSize);\n\tLoop(i, notEmpty.size())\n\t\t(*this)[notEmpty[i].Key()] = notEmpty[i].Value();\n}\nHT::IntOrString& HT::operator [](const IntOrString& key)\n{\n\tint index = indexOfkey(key);\n\tif (tuples[index].In_use()) return tuples[index].Value();\n\t++ in_use_size;\n\tTuple tuple(key);\n\ttuples[index] = tuple;\n\tif (2 * in_use_size > tuples.size())\n\t\tdouble_tuples();\n\treturn tuples[index].Value();\n}\nconst HT::IntOrString& HT::operator [](const IntOrString& key)const\n{\n\tint index = indexOfkey(key);\n\tif (!tuples[index].In_use()) throw logic_error(\"Not such key!\\n\");\n\treturn tuples[index].Value();\n}\n// #endif",
            1595211573.4902034,
            100,
            "# 答案正确"
        ],
        [
            "A.3 (C++)",
            "谢扬",
            "\n#include <vector>\n#include <stdexcept>\n#include <iostream>\nusing std::vector;\nusing std::cout;\nusing std::endl;\nusing std::logic_error;\n#define Loop(i, n) for (int i = 0; i < n; ++ i) \ntemplate<class E>\n\tclass HT\n\t{\n\t\tprivate:\n\t\t\tstruct Tuple\n\t\t\t{\n\t\t\t\t\tint key;\n\t\t\t\t    E value;\n\t\t\t\t\tbool in_use;\n\t\t\t\t\n\t\t\t\t\tTuple():in_use(false){}\n\t\t\t\t\tTuple(int key, const E& value):key(key), value(value), in_use(true){}\n\t\t\t};\n\t\tvector<Tuple> tuples;\n\t\tint in_use_size;\n\t\t\n\t\tint hash_function(int key)const{return key % tuples.size();}\n\t\tint indexOfkey(int key)const;\n\t\tvoid double_tuples();\n\t\tint get(int key)const{Loop(i,tuples.size())if(tuples[i].key == key)return i;}\n\t\tpublic:\n\t\t\tHT(int initial_size = 2001):in_use_size(0){tuples.resize(initial_size);}\n\t\t\tvoid put(int key, const E& value);\n\t\t\tconst E& operator[](int key)const;\n\t\t\tint size()const{return in_use_size;}\n\t\t\tvoid remove(int key);\n\t\t\tvector<int> getKeys()const;\n\t\t\tbool containsKey(int key)const;\n\t};\ntemplate<class E>\nint HT<E>::indexOfkey(int key)const\n{\n\tint index = hash_function(key);\n\twhile (tuples[index].in_use && tuples[index].key != key)\n\t{\n\t\tindex = (index + 1) % tuples.size();\n\t}\n\treturn index;\n}\ntemplate<class E>\nvoid  HT<E>::put(int key, const E& value)\n{\n\tint index = indexOfkey(key);\n\tTuple tuple(key, value);\n\ttuples[index] = tuple;\n\t++ in_use_size;\n\tif (2 * in_use_size > tuples.size())\n\t\tdouble_tuples();\n}\ntemplate<class E>\n\tvoid  HT<E>::double_tuples()\n\t{\n\t\tvector<Tuple> notEmpty;\n\t\tint preSize = tuples.size();\n\t\tLoop(i, preSize)\n\t\t\tif (tuples[i].in_use)\n\t\t\t\tnotEmpty.push_back(tuples[i]);\n\t\ttuples.clear();\n\t\tin_use_size = 0;\n\t\ttuples.resize(2 * preSize);\n\t\tLoop(i, notEmpty.size())\n\t\t\tput(notEmpty[i].key, notEmpty[i].value);\n\t}\ntemplate<class E>\nconst E& HT<E>::operator[](int key)const\n{\n\tint index = indexOfkey(key);\n\tif (!tuples[index].in_use) throw logic_error(\"Not such key!\\n\");\n\treturn tuples[index].value;\n}\ntemplate<class E>\nvoid HT<E>::remove(int key)\n{\n\n\tint index = get(key);\n\t\n\n\tif (!tuples[index].in_use) throw logic_error(\"Not such key!\\n\");\n\tfor (int i = index + 1; i < tuples.size() && tuples[i].in_use ; ++i)\n\t\tif (i != hash_function(tuples[i].key) && hash_function(tuples[i].key) <= index)\n\t\t{Tuple temp; temp = tuples[index]; tuples[index] = tuples[i]; tuples[i] = temp; index = i;}\n\t\t\t\n\ttuples[index] = tuples[tuples.size() - 1];\n\ttuples.pop_back();\n\t--in_use_size;\n\t\n}\ntemplate<class E>\nvector<int> HT<E>::getKeys()const\n{\n\tvector<int> Keys;\n\tLoop(i, tuples.size())\n\t\tif (tuples[i].in_use)\n\t\t\t{Keys.push_back(tuples[i].key);;}\n\t\t\n\treturn Keys;\n}\ntemplate<class E>\nbool HT<E>::containsKey(int key)const\n{\n\tint index = indexOfkey(key);\n\tif (tuples[index].in_use) return true;\n\treturn false\n\t}",
            1595475595.2941365,
            0,
            "In file included from main.cpp:2:0:\nsource.cpp: In member function ‘bool HT<E>::containsKey(int) const’:\nsource.cpp:113:2: error: expected ‘;’ before ‘}’ token\n  }\n  ^\n"
        ]
    ],
    "table_name": "答案"
}