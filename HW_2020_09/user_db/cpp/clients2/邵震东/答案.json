{
    "__update_time__": 1594299219.2983103,
    "field_names": [
        "题目名",
        "用户名",
        "答案",
        "提交时间",
        "分数",
        "评语"
    ],
    "field_types": [
        "text",
        "text",
        "text",
        "time",
        "number",
        "text"
    ],
    "foreign_keys": {},
    "primary_keys": [],
    "rows": [
        [
            "测试1",
            "邵震东",
            "#include <iostream>\n#include <string>\n\nint main()\n{\n\tstd::string str1, str2, str3;\n\tstd::cin >> str1;\n\tstd::cin >> str2;\n\tstd::cin >> str3;\n\tstd::cout << str3 << ' ' << str2 << ' ' << str1 << std::endl;\n\treturn 0;\n}",
            1587609980.2833812,
            100,
            "# 答案正确"
        ],
        [
            "测试2",
            "邵震东",
            "#include <iostream>\n#include <string>\n\nint main()\n{\n    const int ArSize = 10;\n    std::string words[ArSize];\n    for (int i = 0; i < ArSize; i++) {\n        std::cin >> words[i];\n    }\n    for (int i = 0; i < ArSize; i++) {\n        for (int j = 0; j < ArSize - 1; j++) {\n            if (words[j] > words[j + 1]) {\n                std::string temp = words[j];\n                words[j] = words[j + 1];\n                words[j + 1] = temp;\n            }\n        }\n    }\n    for (int i = 0; i < ArSize; i++) {\n        std::cout << words[i] << ' ';\n    }\n}",
            1587611754.415408,
            100,
            "# 答案正确"
        ],
        [
            "1.1 (C++)",
            "邵震东",
            "class Matrix5x5{\n/*private:\n    double arr[5][5] = { 0 };\npublic:*/\npublic:\n\tdouble arr[5][5] = {{ 0 }};\n\n    double get(int x, int y)\n    {\n        return arr[x][y];\n    }\n    void set(int x, int y, double value)\n    {\n        arr[x][y] = value;\n    }\n    Matrix5x5 operator + (Matrix5x5 & m2)\n    {\n        Matrix5x5 m3;\n        for (int i = 0; i < 5; i++) {\n            for (int j = 0; j < 5; j++) {\n                m3.arr[i][j] = this->arr[i][j] + m2.arr[i][j];\n            }\n        }\n        return m3;\n    }\n};",
            1587698927.8193972,
            100,
            "# 答案正确"
        ],
        [
            "1.2 (C++)",
            "邵震东",
            "#include <string>\n\nclass School\n{\npublic:\n    std::string name = \"NO_NAME\";\n    int age = 0;\n\n    void setName(char * str)\n    {\n        name = str;\n    }\n\n    void setAge(int num)\n    {\n        age = num;\n    }\n\n    void operator ++()\n    {\n        age++;\n    }\n};",
            1588213281.922468,
            100,
            "# 答案正确"
        ],
        [
            "2.1 (C++)",
            "邵震东",
            "#include <iostream>\n\nclass Matrix {\nprivate:\n    int rows;\n    int columns;\n    double * values;\npublic:\n    Matrix() = default;\n    Matrix(int row, int column)\n    {\n        rows = row;\n        columns = column;\n        this->values = new double [row * column];\n        for (int i = 0; i < row * column; ++i) {\n            *(values + i) = 0;\n        }\n    }\n    ~Matrix() { delete [] values; }\n    void print() const\n    {\n        for (int i = 0; i < rows * columns; ) {\n            for (int j = 0; j < columns; ++j) {\n                if (j == columns - 1)\n                    std::cout << *(values + i);\n                else\n                    std::cout << *(values + i) << \"    \";\n                ++i;\n            }\n            std::cout << std::endl;\n        }\n    }\n};\n\nusing namespace std;",
            1588825707.466007,
            100,
            "# 答案正确"
        ],
        [
            "2.2 (C++)",
            "邵震东",
            "#include <iostream>\n#include <iomanip>\n\nclass Matrix {\nprivate:\n    int rows;\n    int columns;\n    double * values;\npublic:\n    Matrix() = default;\n    Matrix(int row, int column, double * value)\n    {\n        rows = row;\n        columns = column;\n        this->values = new double [row * column];\n        for (int i = 0; i < row * column; ++i) {\n            *(values + i) = *(value + i);\n        }\n    }\n    ~Matrix() { delete [] values; }\n    void print() const\n    {\n        for (int i = 0; i < rows * columns; ) {\n            for (int j = 0; j < columns; ++j) {\n                std::cout << std::setw(5);\n                std::cout << *(values + i);\n                ++i;\n            }\n            std::cout << std::endl;\n        }\n    }\n};\n\nusing namespace std;",
            1588826261.7367978,
            100,
            "# 答案正确"
        ],
        [
            "2.3 (C++)",
            "邵震东",
            "#include <iostream>\n\nclass Matrix {\nprivate:\n    int rows;\n    int columns;\n    double * values;\npublic:\n    Matrix() = default;\n    Matrix(const Matrix & matrix2)\n    {\n        columns = matrix2.columns;\n        rows = matrix2.rows;\n        this->values = new double [matrix2.rows * matrix2.columns];\n        for (int i = 0; i < matrix2.rows * matrix2.columns; ++i) {\n            *(values + i) = *(matrix2.values + i);\n        }\n    }\n    Matrix(int row, int column, double * value)\n    {\n        rows = row;\n        columns = column;\n        this->values = new double [row * column];\n        for (int i = 0; i < row * column; ++i) {\n            *(values + i) = *(value + i);\n        }\n    }\n\t~Matrix()\n\t{\n\t\tdelete [] values;\n\t}\n    void print() const\n    {\n        for (int i = 0; i < rows * columns; ) {\n            for (int j = 0; j < columns; ++j) {\n                //std::cout << std::setw(5);\n                std::cout << \"    \" << *(values + i);\n                ++i;\n            }\n            std::cout << std::endl;\n        }\n    }\n};\n\nusing namespace std;",
            1589453620.507878,
            100,
            "# 答案正确"
        ],
        [
            "2.5 (C++)",
            "邵震东",
            "#include <iostream>\n#include <iomanip>\n\nclass Matrix {\nprivate:\n    int rows;\n    int columns;\n    double * values;\npublic:\n    Matrix() = default;\n    Matrix(int row, int column)\n    {\n        rows = row;\n        columns = column;\n        this->values = new double [row * column];\n        for (int i = 0; i < row * column; ++i) {\n            *(values + i) = 0;\n        }\n    }\n    Matrix(int row, int column, double * value)\n    {\n        rows = row;\n        columns = column;\n        this->values = new double [row * column];\n        for (int i = 0; i < row * column; ++i) {\n            *(values + i) = *(value + i);\n        }\n    }\n    ~Matrix()\n    {\n        delete[] values;\n    }\n    void print() const\n    {\n        for (int i = 0; i < rows * columns; ) {\n            for (int j = 0; j < columns; ++j) {\n                //std::cout << std::setw(5);\n                std::cout << \"    \" << this->values[i];\n                ++i;\n            }\n            std::cout << std::endl;\n        }\n    }\n    Matrix getRow(int row)\n    {\n        Matrix print;\n        double *elem = new double [this->columns];\n        for (int i = 0; i < this->columns; ++i) {\n            *(elem + i) = *(this->values + i + (row - 1) * this->columns);\n        }\n        print.rows = 1;\n        print.columns = this->columns;\n        print.values = elem;\n        return print;\n    }\n    Matrix getColumn(int column)\n    {\n        Matrix print;\n        double *elem = new double [this->columns];\n        for (int i = 0; i < this->rows; ++i) {\n            *(elem + i) = *(this->values + (this->columns * i) + column - 1);\n        }\n        print.rows = this->rows;\n        print.columns = 1;\n        print.values = elem;\n        return print;\n    }\n};\n\nusing namespace std;",
            1588843033.1287405,
            100,
            "# 答案正确"
        ],
        [
            "2.6 (C++)",
            "邵震东",
            "#include <iostream>\n#include <iomanip>\n\nclass Matrix {\nprivate:\n    int rows;\n    int columns;\n    double * values;\npublic:\n    Matrix() = default;\n    Matrix(int row, int column)\n    {\n        rows = row;\n        columns = column;\n        this->values = new double [row * column];\n        for (int i = 0; i < row * column; ++i) {\n            *(values + i) = 0;\n        }\n    }\n    Matrix(int row, int column, double * value)\n    {\n        rows = row;\n        columns = column;\n        this->values = new double [row * column];\n        for (int i = 0; i < row * column; ++i) {\n            *(values + i) = *(value + i);\n        }\n    }\n    ~Matrix()\n    {\n        delete[] values;\n    }\n    void print() const\n    {\n        for (int i = 0; i < rows * columns; ) {\n            for (int j = 0; j < columns; ++j) {\n                //std::cout << std::setw(5);\n                std::cout << \"    \" << this->values[i];\n                ++i;\n            }\n            std::cout << std::endl;\n        }\n    }\n    Matrix concatenateColumns(const Matrix &mtr) const\n    {\n        Matrix print;\n        print.columns = this->columns + mtr.columns;\n        print.rows = this->rows;\n        double *elem = new double [(this->columns + mtr.columns) * this->rows];\n        for (int i = 0, i1 = 0, i2 = 0; i < ((this->columns + mtr.columns) * this->rows); ) {\n            for (int j = 0; j < this->columns; ++j) {\n                elem[i] = this->values[i1];\n                ++i;\n                ++i1;\n            }\n            for (int j = 0; j < mtr.columns; ++j) {\n                elem[i] = mtr.values[i2];\n                ++i;\n                ++i2;\n            }\n        }\n        print.values = elem;\n        return print;\n    }\n    Matrix concatenateRows(const Matrix &mtr) const\n    {\n        Matrix print;\n        int i;\n        print.columns = this->columns;\n        print.rows = this->rows + mtr.rows;\n        double *elem = new double [this->columns * (this->rows + mtr.rows)];\n        for (i = 0; i < (this->columns * this->rows); ++i) {\n            elem[i] = this->values[i];\n        }\n        for (int j = 0; j < (this->columns * mtr.rows); ++j) {\n            elem[i + j] = mtr.values[j];\n        }\n        print.values = elem;\n        return print;\n    }\n};\n\nusing namespace std;",
            1589451321.798873,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/08",
            "邵震东",
            "double & Tensor_get(int dimensions, int sizes[], double data[], int x0, int x1, int x2, int x3)\n{\n    if (dimensions == 1) {\n        return data[x0];\n    }\n    else if (dimensions == 2) {\n        return data[x0 * sizes[1] + x1];\n    }\n    else if (dimensions == 3) {\n        return data[x0 * sizes[1] * sizes[2] + x1 * sizes[2] + x2];\n    }\n    else if (dimensions == 4) {\n        return data[x0 * sizes[1] * sizes[2] * sizes[3] + x1 * sizes[2] * sizes[3] + x2 * sizes[3] + x3];\n    }\n}\n",
            1588907413.0378602,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/14",
            "邵震东",
            "#include <iostream>\n\nvoid Tensor_print(int dimensions, const int sizes[], const double data[])\n{\n    switch (dimensions) {\n        case 1:\n        {\n            std::cout << \"Tensor of \" << sizes[0] << std::endl;\n            for (int i = 0; i < sizes[0]; ++i) {\n                std::cout << data[i] << std::endl;\n            }\n            break;\n        }\n        case 2:\n        {\n            std::cout << \"Tensor of \" << sizes[0] << 'x' << sizes[1] << std::endl;\n            int ctr = 0;\n            for (int i = 0; i < sizes[0]; ++i) {\n                for (int j = 0; j < sizes[1]; ++j) {\n                    std::cout << \"    \" << data[ctr];\n                    ++ctr;\n                }\n                std::cout << std::endl;\n            }\n            break;\n        }\n        case 3:\n        {\n            std::cout << \"Tensor of \" << sizes[0] << 'x' << sizes[1] << 'x' << sizes[2] << std::endl;\n            int ctr = 0;\n            for (int i = 0; i < sizes[0]; ++i) {\n                std::cout << \"data[\" << i << ']' << std::endl;\n                for (int j = 0; j < sizes[1]; ++j) {\n                    for (int k = 0; k < sizes[2]; ++k) {\n                        std::cout << \"    \" << data[ctr];\n                        ++ctr;\n                    }\n                    std::cout << std::endl;\n                }\n            }\n            break;\n        }\n        case 4:\n        {\n            std::cout << \"Tensor of \" << sizes[0] << 'x' << sizes[1] << 'x' << sizes[2] << 'x' << sizes[3] << std::endl;\n            int ctr = 0;\n            for (int i = 0; i < sizes[0]; ++i) {\n                for (int j = 0; j < sizes[1]; ++j) {\n                    std::cout << \"data[\" << i << \"][\" << j << ']' << std::endl;\n                    for (int k = 0; k < sizes[2]; ++k) {\n                        for (int l = 0; l < sizes[3]; ++l) {\n                            std::cout << \"    \" << data[ctr];\n                            ++ctr;\n                        }\n                        std::cout << std::endl;\n                    }\n                }\n            }\n            break;\n        }\n    }\n}",
            1589423694.9870372,
            100,
            "# 答案正确"
        ],
        [
            "2.4 (C++)",
            "邵震东",
            "#ifndef PROJECT_SOURCE_HPP\n#define PROJECT_SOURCE_HPP\n#include <iostream>\n#include <string>\n\nclass Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    double * values;\npublic:\n    Matrix() = default;\n    Matrix(int nRows, int nColumns) :\n        rows(nRows), columns(nColumns)\n    {\n        this->values = new double [rows * columns];\n        for (int i = 0; i < rows * columns; ++i) {\n            *(values + i) = 0;\n        }\n    }\n    Matrix(int nRows, int nColumns, double * values) :\n            rows(nRows), columns(nColumns)\n    {\n        this->values = new double [rows * columns];\n        for (int i = 0; i < rows * columns; ++i) {\n            *(this->values + i) = *(values + i);\n        }\n    }\n    Matrix &operator = (Matrix &matrix)\n    {\n        this->rows = matrix.rows;\n        this->columns = matrix.columns;\n        double * sum;\n        sum = new double [matrix.rows * matrix.columns];\n        for (int i = 0; i < matrix.rows * matrix.columns; ++i) {\n            *(sum + i) = *(matrix.values + i);\n        }\n        delete [] this->values;\n        values = sum;\n        return *this;\n    }\n\n    void print()\n    {\n        int cnt = 0;\n        for (int i = 0; i < this->rows; ++i) {\n            for (int j = 0; j < this->columns; ++j) {\n                std::cout << \"    \" << *(this->values + cnt);\n                ++cnt;\n            }\n            std::cout << std::endl;\n        }\n    }\n    void set(int row, int column, double value)\n    {\n        *(this->values + (row - 1) * this->columns + column - 1) = value;\n    }\n    ~Matrix() { delete [] this->values; }\n};\n\nusing namespace std;\n#endif",
            1589514669.6394644,
            100,
            "# 答案正确"
        ],
        [
            "2.7 (C++)",
            "邵震东",
            "#ifndef PROJECT_SOURCE_HPP\n#define PROJECT_SOURCE_HPP\n#include <iostream>\n\nclass Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    double * values;\npublic:\n    Matrix() = default;\n    Matrix(int nRows, int nColumns) :\n            rows(nRows), columns(nColumns)\n    {\n        this->values = new double [rows * columns];\n        for (int i = 0; i < rows * columns; ++i) {\n            *(values + i) = 0;\n        }\n    }\n    Matrix(int nRows, int nColumns, double * values) :\n            rows(nRows), columns(nColumns)\n    {\n        this->values = new double [rows * columns];\n        for (int i = 0; i < rows * columns; ++i) {\n            *(this->values + i) = *(values + i);\n        }\n    }\n    Matrix(const Matrix & matrix2)\n    {\n        this->columns = matrix2.columns;\n        this->rows = matrix2.rows;\n        this->values = new double [rows * columns];\n        for (int i = 0; i < rows * columns; ++i)\n            *(values + i) = *(matrix2.values + i);\n    }\n    ~Matrix() { delete [] values; }\n    void print() const\n    {\n        int i, j, ctr = 0;\n        for (i = 0; i < rows; ++i) {\n            for (j = 0; j < columns; ++j) {\n                std::cout << \"    \" << *(values + ctr);\n                ++ctr;\n            }\n            std::cout << std::endl;\n        }\n    }\n    Matrix reshape(int, int) const;\n};\n\nMatrix Matrix::reshape(int rows, int columns) const\n{\n    Matrix another;\n    another.columns = columns;\n    another.rows = rows;\n    another.values = new double [rows * columns];\n    double arr[rows][columns];\n    double array[this->rows][this->columns];\n    for (int i = 0; i < this->rows; ++i) {\n        for (int j = 0; j < this->columns; ++j) {\n            array[i][j] = *(this->values + i * this->columns + j);\n            //std::cout << \"    \" << array[i][j];\n        }\n        //std::cout << std::endl;\n    }\n    int cnt1 = 0;\n    int cnt2 = 0;\n    for (int i = 0; i < this->columns; ++i) {\n        for (int j = 0; j < this->rows; ++j) {\n            arr[cnt1][cnt2] = array[j][i];\n            //std::cout << \"    \" << array[i][j] << ' ' << arr[cnt1][cnt2];\n            ++cnt1;\n            if (cnt1 > rows) {\n                cnt1 = 0;\n                ++cnt2;\n                --j;\n            }\n        }\n        //std::cout << std::endl;\n    }\n    int cnt = 0;\n    for (int i = 0; i < rows; ++i) {\n        for (int j = 0; j < columns; ++j) {\n            *(another.values + cnt) = arr[i][j];\n            ++cnt;\n            //std::cout << \"    \" << arr[i][j];\n        }\n        //std::cout << std::endl;\n    }\n    return another;\n}\n\nusing namespace std;\n#endif",
            1589861251.4378285,
            100,
            "# 答案正确"
        ],
        [
            "2.8 (C++)",
            "邵震东",
            "#ifndef PROJECT_SOURCE_HPP\n#define PROJECT_SOURCE_HPP\n#include <iostream>\n\nclass Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    double * values;\npublic:\n    Matrix() = default;\n    Matrix(int nRows, int nColumns) :\n            rows(nRows), columns(nColumns)\n    {\n        this->values = new double [rows * columns];\n        for (int i = 0; i < rows * columns; ++i) {\n            *(values + i) = 0;\n        }\n    }\n    Matrix(int nRows, int nColumns, double * values) :\n            rows(nRows), columns(nColumns)\n    {\n        this->values = new double [rows * columns];\n        for (int i = 0; i < rows * columns; ++i) {\n            *(this->values + i) = *(values + i);\n        }\n    }\n    Matrix(const Matrix & matrix2)\n    {\n        this->columns = matrix2.columns;\n        this->rows = matrix2.rows;\n        this->values = new double [rows * columns];\n        for (int i = 0; i < rows * columns; ++i)\n            *(values + i) = *(matrix2.values + i);\n    }\n    ~Matrix() { delete [] values; }\n    void print() const\n    {\n        int i, j, ctr = 0;\n        for (i = 0; i < rows; ++i) {\n            for (j = 0; j < columns; ++j) {\n                std::cout << \"    \" << *(values + ctr);\n                ++ctr;\n            }\n            std::cout << std::endl;\n        }\n    }\n    Matrix transpose() const;\n};\n\nMatrix Matrix::transpose() const\n{\n    Matrix another;\n    another.columns = this->rows;\n    another.rows = this->columns;\n    another.values = new double [rows * columns];\n    double array[this->columns][this->rows];\n    int cnt = 0;\n    for (int j = 0; j < this->rows; ++j) {\n        for (int i = 0; i < this->columns; ++i) {\n            array[i][j] = *(this->values + cnt);\n            //std::cout << \"    \" << *(this->values + cnt);\n            ++cnt;\n        }\n        //std::cout << std::endl;\n    }\n    for (int i = 0; i < this->columns; ++i) {\n        for (int j = 0; j < this->rows; ++j) {\n            //std::cout << \"    \" << array[j][i];\n        }\n        //std::cout << std::endl;\n    }\n    cnt = 0;\n    for (int i = 0; i < this->columns; ++i) {\n        for (int j = 0; j < this->rows; ++j) {\n            *(another.values + cnt) = array[i][j];\n            ++cnt;\n        }\n    }\n    return another;\n}\n\nusing namespace std;\n#endif",
            1589862507.9985316,
            100,
            "# 答案正确"
        ],
        [
            "2.10 (C++)",
            "邵震东",
            "#ifndef PROJECT_SOURCE_HPP\n#define PROJECT_SOURCE_HPP\n#include <iostream>\n\nclass Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    double * values;\npublic:\n    Matrix() = default;\n    Matrix(int nRows, int nColumns) :\n            rows(nRows), columns(nColumns)\n    {\n        this->values = new double [rows * columns];\n        for (int i = 0; i < rows * columns; ++i) {\n            *(values + i) = 0;\n        }\n    }\n    Matrix(int nRows, int nColumns, double * values) :\n            rows(nRows), columns(nColumns)\n    {\n        this->values = new double [rows * columns];\n        for (int i = 0; i < rows * columns; ++i) {\n            *(this->values + i) = *(values + i);\n        }\n    }\n    Matrix(const Matrix & matrix2)\n    {\n        this->columns = matrix2.columns;\n        this->rows = matrix2.rows;\n        this->values = new double [rows * columns];\n        for (int i = 0; i < rows * columns; ++i)\n            *(values + i) = *(matrix2.values + i);\n    }\n    ~Matrix() { delete [] values; }\n    void print() const\n    {\n        int i, j, ctr = 0;\n        for (i = 0; i < rows; ++i) {\n            for (j = 0; j < columns; ++j) {\n                std::cout << \"    \" << *(values + ctr);\n                ++ctr;\n            }\n            std::cout << std::endl;\n        }\n    }\n    Matrix operator * (const Matrix & matrix2) const\n    {\n        Matrix matrix;\n        matrix.rows = this->rows;\n        matrix.columns = matrix2.columns;\n        double * array = new double [matrix.rows * matrix.columns];\n        double arr1[rows][columns], arr2[matrix2.rows][matrix2.columns], arr3[matrix.rows][matrix.columns];\n        int i, j, cnt;\n        for (i = 0, cnt = 0; i < rows; ++i) {\n            for (j = 0; j < columns; ++j) {\n                arr1[i][j] = *(this->values + cnt);\n                ++cnt;\n            }\n        }\n        for (i = 0, cnt = 0; i < rows; ++i) {\n            for (j = 0; j < columns; ++j) {\n                arr1[i][j] = *(values + cnt);\n                ++cnt;\n            }\n        }\n        for (i = 0, cnt = 0; i < matrix2.rows; ++i) {\n            for (j = 0; j < matrix2.columns; ++j) {\n                arr2[i][j] = *(matrix2.values + cnt);\n                ++cnt;\n            }\n        }\n        for (i = 0, cnt = 0; i < matrix.rows; ++i) {\n            for (j = 0; j < matrix.columns; ++j) {\n                double sum = 0;\n                for (int index = 0; index < columns; ++index) {\n                    sum += arr1[i][index] * arr2[index][j];\n                }\n                arr3[i][j] = sum;\n            }\n        }\n        for (i = 0, cnt = 0; i < matrix.rows; ++i) {\n            for (j = 0; j < matrix.columns; ++j) {\n                array[cnt] = arr3[i][j];\n\t\t\t\t++cnt;\n                //std::cout << \"    \" << arr3[i][j];\n            }\n            //std::cout << std::endl;\n        }\n\t\tmatrix.values = array;\n        return matrix;\n    }\n    Matrix operator * (double value) const\n    {\n        Matrix matrix;\n        matrix.rows = this->rows;\n        matrix.columns = this->columns;\n        matrix.values = new double [matrix.rows * matrix.columns];\n        for (int i = 0; i < rows * columns; ++i) {\n            *(matrix.values + i) = *(this->values + i) * value;\n        }\n        return matrix;\n    }\n};\n\nusing namespace std;\n#endif",
            1589885394.5207055,
            100,
            "# 答案正确"
        ],
        [
            "2.11 (C++)",
            "邵震东",
            "#ifndef PROJECT_SOURCE_HPP\n#define PROJECT_SOURCE_HPP\n#include <iostream>\n\nclass Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    double * values;\npublic:\n    Matrix() = default;\n    Matrix(int nRows, int nColumns) :\n            rows(nRows), columns(nColumns)\n    {\n        this->values = new double [rows * columns];\n        for (int i = 0; i < rows * columns; ++i) {\n            *(values + i) = 0;\n        }\n    }\n    Matrix(int nRows, int nColumns, double * values) :\n            rows(nRows), columns(nColumns)\n    {\n        this->values = new double [rows * columns];\n        for (int i = 0; i < rows * columns; ++i) {\n            *(this->values + i) = *(values + i);\n        }\n    }\n    Matrix(const Matrix & matrix2)\n    {\n        this->columns = matrix2.columns;\n        this->rows = matrix2.rows;\n        this->values = new double [rows * columns];\n        for (int i = 0; i < rows * columns; ++i)\n            *(values + i) = *(matrix2.values + i);\n    }\n    ~Matrix() { delete [] values; }\n    void print() const\n    {\n        int i, j, ctr = 0;\n        for (i = 0; i < rows; ++i) {\n            for (j = 0; j < columns; ++j) {\n                std::cout << \"    \" << *(values + ctr);\n                ++ctr;\n            }\n            std::cout << std::endl;\n        }\n    }\n    Matrix max() const;\n    Matrix sum() const;\n    Matrix min() const;\n};\n\nMatrix Matrix::max() const\n{\n    Matrix max;\n    switch (this->rows) {\n        case 1:\n            max.rows = 1;\n            max.columns = 1;\n            max.values = new double [max.rows * max.columns];\n            max.values[0] = *(this->values);\n            for (int i = 0; i < this->columns; ++i) {\n                max.values[0] = (*(this->values + i) > *(max.values)) ? *(this->values + i) : *(max.values);\n            }\n            break;\n        default:\n            max.rows = 1;\n            max.columns = this->columns;\n            max.values = new double [max.rows * max.columns];\n            double array[this->rows][this->columns];\n            int cnt = 0;\n            for (int i = 0; i < this->rows; ++i) {\n                for (int j = 0; j < this->columns; ++j) {\n                    array[i][j] = *(this->values + cnt);\n                    ++cnt;\n                }\n            }\n            for (int i = 0; i < max.columns; ++i) {\n                *(max.values + i) = array[0][i];\n                for (int j = 0; j < this->rows; ++j) {\n                    max.values[i] = (array[j][i] > max.values[i]) ? array[j][i] : max.values[i];\n                }\n            }\n    }\n    return max;\n}\n\nMatrix Matrix::min() const\n{\n    Matrix min;\n    switch (this->rows) {\n        case 1:\n            min.rows = 1;\n            min.columns = 1;\n            min.values = new double [min.rows * min.columns];\n            *(min.values) = *(this->values);\n            for (int i = 0; i < this->columns; ++i) {\n                *(min.values) = (*(this->values + i) < *(min.values)) ? *(this->values + i) : *(min.values);\n            }\n            break;\n        default:\n            min.rows = 1;\n            min.columns = this->columns;\n            min.values = new double [min.rows * min.columns];\n            double array[this->rows][this->columns];\n            int cnt = 0;\n            for (int i = 0; i < this->rows; ++i) {\n                for (int j = 0; j < this->columns; ++j) {\n                    array[i][j] = this->values[cnt];\n                    ++cnt;\n                }\n            }\n            for (int i = 0; i < min.columns; ++i) {\n                min.values[i] = array[0][i];\n                for (int j = 0; j < this->rows; ++j) {\n                    min.values[i] = (array[j][i] < min.values[i]) ? array[j][i] : min.values[i];\n                }\n            }\n    }\n    return min;\n}\n\nMatrix Matrix::sum() const\n{\n    Matrix sum;\n    switch (this->rows) {\n        case 1:\n            sum.rows = 1;\n            sum.columns = 1;\n            sum.values = new double [sum.rows * sum.columns];\n            sum.values[0] = 0;\n            for (int i = 0; i < this->columns; ++i) {\n                sum.values[0] += this->values[i];\n            }\n            break;\n        default:\n            sum.rows = 1;\n            sum.columns = this->columns;\n            sum.values = new double [sum.rows * sum.columns];\n            double array[this->rows][this->columns];\n            int cnt = 0;\n            for (int i = 0; i < this->rows; ++i) {\n                for (int j = 0; j < this->columns; ++j) {\n                    array[i][j] = this->values[cnt];\n                    ++cnt;\n                }\n            }\n            for (int i = 0; i < sum.columns; ++i) {\n                sum.values[i] = 0;\n                for (int j = 0; j < this->rows; ++j) {\n                    sum.values[i] += array[j][i];\n                }\n            }\n    }\n    return sum;\n}\n\nusing namespace std;\n#endif",
            1589950060.7388108,
            100,
            "# 答案正确"
        ],
        [
            "2.12 (C++)",
            "邵震东",
            "#ifndef PROJECT_SOURCE_HPP\n#define PROJECT_SOURCE_HPP\n#include <iostream>\n#include <cmath>\n\nclass Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    double * values;\npublic:\n    Matrix() = default;\n    Matrix(int nRows, int nColumns) :\n            rows(nRows), columns(nColumns)\n    {\n        this->values = new double [rows * columns];\n        for (int i = 0; i < rows * columns; ++i) {\n            *(values + i) = 0;\n        }\n    }\n    Matrix(int nRows, int nColumns, double * values) :\n            rows(nRows), columns(nColumns)\n    {\n        this->values = new double [rows * columns];\n        for (int i = 0; i < rows * columns; ++i) {\n            *(this->values + i) = *(values + i);\n        }\n    }\n    Matrix(const Matrix & matrix2)\n    {\n        this->columns = matrix2.columns;\n        this->rows = matrix2.rows;\n        this->values = new double [rows * columns];\n        for (int i = 0; i < rows * columns; ++i)\n            *(values + i) = *(matrix2.values + i);\n    }\n    ~Matrix() { delete [] values; }\n    void print() const\n    {\n        int i, j, ctr = 0;\n        for (i = 0; i < rows; ++i) {\n            for (j = 0; j < columns; ++j) {\n                std::cout << \"    \" << *(values + ctr);\n                ++ctr;\n            }\n            std::cout << std::endl;\n        }\n    }\n    Matrix pow(double);\n    Matrix exp();\n    Matrix log();\n    Matrix abs();\n};\n\nMatrix Matrix::pow(double expoent)\n{\n    Matrix power;\n    power.rows = this->rows;\n    power.columns = this->columns;\n    power.values = new double [power.rows * power.columns];\n    for (int i = 0; i < power.rows * power.columns; ++i) {\n        *(power.values + i) = ::pow(*(this->values + i), expoent);\n    }\n    return power;\n}\n\nMatrix Matrix::exp()\n{\n    Matrix exp;\n    exp.rows = this->rows;\n    exp.columns = this->columns;\n    exp.values = new double [exp.rows * exp.columns];\n    for (int i = 0; i < exp.rows * exp.columns; ++i) {\n        *(exp.values + i) = ::exp(*(this->values + i));\n    }\n    return exp;\n}\n\nMatrix Matrix::log()\n{\n    Matrix log;\n    log.rows = this->rows;\n    log.columns = this->columns;\n    log.values = new double [log.rows * log.columns];\n    for (int i = 0; i < log.rows * log.columns; ++i) {\n        *(log.values + i) = ::log(*(this->values + i));\n    }\n    return log;\n}\n\nMatrix Matrix::abs()\n{\n    Matrix abs;\n    abs.rows = this->rows;\n    abs.columns = this->columns;\n    abs.values = new double [abs.rows * abs.columns];\n    for (int i = 0; i < abs.rows * abs.columns; ++i) {\n        *(abs.values + i) = ::fabs(*(this->values + i));\n    }\n    return abs;\n}\n\nusing namespace std;\n#endif",
            1589952311.1312375,
            100,
            "# 答案正确"
        ],
        [
            "2.9 (C++)",
            "邵震东",
            "#ifndef PROJECT_SOURCE_HPP\n#define PROJECT_SOURCE_HPP\n#include <iostream>\n\nclass Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    double * values;\npublic:\n    Matrix() = default;\n    Matrix(int nRows, int nColumns) :\n            rows(nRows), columns(nColumns)\n    {\n        this->values = new double [rows * columns];\n        for (int i = 0; i < rows * columns; ++i) {\n            *(values + i) = 0;\n        }\n    }\n    Matrix(int nRows, int nColumns, double * values) :\n            rows(nRows), columns(nColumns)\n    {\n        this->values = new double [rows * columns];\n        for (int i = 0; i < rows * columns; ++i) {\n            *(this->values + i) = *(values + i);\n        }\n    }\n    Matrix(const Matrix & matrix2)\n    {\n        this->columns = matrix2.columns;\n        this->rows = matrix2.rows;\n        this->values = new double [rows * columns];\n        for (int i = 0; i < rows * columns; ++i)\n            *(values + i) = *(matrix2.values + i);\n    }\n    ~Matrix() { delete [] values; }\n    void print() const\n    {\n        int i, j, ctr = 0;\n        for (i = 0; i < rows; ++i) {\n            for (j = 0; j < columns; ++j) {\n                std::cout << \"    \" << *(values + ctr);\n                ++ctr;\n            }\n            std::cout << std::endl;\n        }\n    }\n    Matrix operator + (const Matrix&);\n    Matrix operator + (double);\n    Matrix operator - (const Matrix&);\n    Matrix operator - (double);\n};\n\nMatrix Matrix::operator + (const Matrix & matrix2)\n{\n    Matrix sum;\n    sum.rows = this->rows;\n    sum.columns = this->columns;\n    sum.values = new double [sum.rows * sum.columns];\n    for (int i = 0; i < sum.rows * sum.columns; ++i) {\n        *(sum.values + i) = *(this->values + i) + *(matrix2.values + i);\n    }\n    return sum;\n}\n\nMatrix Matrix::operator + (double value)\n{\n    Matrix sum;\n    sum.rows = this->rows;\n    sum.columns = this->columns;\n    sum.values = new double [sum.rows * sum.columns];\n    for (int i = 0; i < sum.rows * sum.columns; ++i) {\n        *(sum.values + i) = *(this->values + i) + value;\n    }\n    return sum;\n}\n\nMatrix Matrix::operator - (const Matrix & matrix2)\n{\n    Matrix sum;\n    sum.rows = this->rows;\n    sum.columns = this->columns;\n    sum.values = new double [sum.rows * sum.columns];\n    for (int i = 0; i < sum.rows * sum.columns; ++i) {\n        *(sum.values + i) = *(this->values + i) - *(matrix2.values + i);\n    }\n    return sum;\n}\n\nMatrix Matrix::operator - (double value)\n{\n    Matrix sum;\n    sum.rows = this->rows;\n    sum.columns = this->columns;\n    sum.values = new double [sum.rows * sum.columns];\n    for (int i = 0; i < sum.rows * sum.columns; ++i) {\n        *(sum.values + i) = *(this->values + i) - value;\n    }\n    return sum;\n}\n\nusing namespace std;\n#endif",
            1590027897.2598844,
            100,
            "# 答案正确"
        ],
        [
            "6.1 (C++)",
            "邵震东",
            "template <typename T>\nclass Matrix\n{\npublic:\n    using values_type = T;\nprivate:\n    int rows;\n    int columns;\n    values_type * values;\npublic:\n    Matrix(int nRows, int nColumns) :\n        rows(nRows), columns(nColumns)\n    {\n        values = new values_type [rows * columns];\n        for (int i = 0; i < rows * columns; ++i)\n            *(values + i) = values_type();\n    }\n    Matrix(int rows, int columns, const values_type * values) :\n        rows(rows), columns(columns)\n    {\n        this->values = new values_type [rows * columns];\n        for (int i = 0; i < rows * columns; ++i)\n            *(this->values + i) = *(values + i);\n    }\n    Matrix(const Matrix<values_type> & matrix2) :\n        rows(matrix2.rows), columns(matrix2.columns)\n    {\n        this->values = new values_type [rows * columns];\n        for (int i = 0; i < rows * columns; ++i)\n            *(values + i) = *(matrix2.values + i);\n    }\n    ~Matrix() { delete [] values; }\n    Matrix<values_type> & operator = (const Matrix<values_type> & matrix2)\n    {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        for (int i = 0; i < rows * columns; ++i)\n            *(this->values + i) = *(matrix2.values + i);\n        return *this;\n    }\n    void print()\n    {\n        int cnt = 0;\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < columns; ++j) {\n                cout << \"    \" << *(values + cnt);\n                ++cnt;\n            }\n            cout << endl;\n        }\n    }\n    values_type & get(int row, int column)\n    {\n        return *(values + (row - 1) * this->columns + column - 1);\n    }\n};",
            1590589885.5989337,
            100,
            "# 答案正确"
        ],
        [
            "6.2 (C++)",
            "邵震东",
            "#ifndef _PROJECT_SOURCE_HPP_\n#define _PROJECT_SOURCE_HPP_\n#include <iostream>\n#include <vector>\n\ntemplate<typename T>\nclass Matrix\n{\npublic:\n    using values_type = T;\nprivate:\n    int rows;\n    int columns;\n    values_type * values;\npublic:\n    Matrix(int nRows, int nColumns) :\n        rows(nRows), columns(nColumns)\n    {\n        this->values = new values_type [rows * columns];\n        for (int i = 0; i < rows * columns; ++i)\n            *(values + i) = values_type();\n    }\n    ~Matrix() { delete [] this->values; }\n    void print()\n    {\n        int cnt = 0;\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < columns; ++j) {\n                std::cout << \"    \" << *(values + cnt);\n                ++cnt;\n            }\n            std::cout << std::endl;\n        }\n    }\n\n};\n\nusing namespace std;\n#endif",
            1590631895.6314702,
            100,
            "# 答案正确"
        ],
        [
            "6.3 (C++)",
            "邵震东",
            "#ifndef _PROJECT_SOURCE_HPP_\n#define _PROJECT_SOURCE_HPP_\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\ntemplate <typename T>\nclass Matrix{\nprivate:\n\tint rows;\n\tint columns;\n\tvector<T> values;\npublic:\n\tMatrix(int rows,int columns){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\t//this->values = new T(rows * columns);\n\t\tfor(int i = 0; i < rows * columns; i ++)\n\t\t\tthis->values.push_back(T());//this->values[i] = T();\n\t}\n\tMatrix(Matrix<T> & s){\n\t\tthis->rows = s.rows;\n\t\tthis->columns = s.columns;\n\t\t//this->values = new T(s.rows * s.columns);\n\t\tfor(int i = 0; i < this->rows * this->columns; i ++)\n\t\t\tthis->values.push_back(s.values[i]);//this->values[i] = s.values[i];\n\t}\n\t~Matrix(){\n\t\tthis->values.clear();//delete [] this->values;\n\t}\n\tMatrix(int rows,int columns,const vector<T> s2){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\t//this->values = new T(rows * columns);\n\t\tfor(int i = 0 ; i < rows * columns; i ++)\n\t\t\tvalues.push_back(s2[i]);//values[i] = s2[i];\n\t}\n\tMatrix & operator =(Matrix<T> & s2){\n\t\tif(this->values.size() != 0)//if(this->values != NULL)\n\t\t\tthis->values.clear();//\tdelete [] this->values;\n\t\tthis->rows = s2.rows;\n\t\tthis->columns = s2.columns;\n\t\t//this->values = new T(this->rows * this->columns);\n\t\tfor(int i = 0; i < this->rows * this->columns;i ++)\n\t\t\tthis->values.push_back(s2.values[i]);//this->values[i] = s2.values[i];\n\t\treturn (*this);\n\t}\n\tT& get(int row, int column){\n\t\treturn values[(row-1) * this->columns + column - 1];\n\t}\n\tvoid print(){\n\t\tfor(int i = 0; i < this->rows * this->columns; i ++){\n\t\t\tif(i != 0 && i % columns == 0)\n\t\t\t\tcout << endl;\n\t\t\tcout << \"    \" << values[i];\n\t\t}\n\t\tcout << endl;\n\t}\n\tMatrix getColumn(int column){\n\t\tvector<T> store;\n\t\tfor(int i = 0; i < this->rows; i ++){\n\t\t\tstore.push_back(this->values[i * this->columns + column - 1]);\n\t\t}\n\t\tMatrix s(this->rows,1,store);\n\t\tstore.clear();\n\t\treturn s;\n\t}\n\tMatrix getRow(int row){\n\t\tvector<T> store;\n\t\tfor(int i = 0; i < this->columns; i ++){\n\t\t\tstore.push_back(this->values[(row - 1)* this->columns + i]);\n\t\t}\n\t\tMatrix s(1,this->columns,store);\n\t\tstore.clear();\n\t\treturn s;\n\t}\n\tMatrix concatenateRows(Matrix<T> & s1){\n\t\tvector<T> store;\n\t\tfor(int i = 0; i < this->values.size() + s1.values.size(); i ++){\n\t\t\tif(i < this->values.size())\n\t\t\t\tstore.push_back(this->values[i]);\n\t\t\telse\n\t\t\t\tstore.push_back(s1.values[i - this->values.size()]);\n\t\t}\n\t\tMatrix s(this->rows + s1.rows, this->columns,store);\n\t\tstore.clear();\n\t\treturn s;\n\t} \n\tMatrix concatenateColumns(Matrix<T> & s1){\n\t\tint flagrow = 0; \n\t\tint flagcolumn = 0; \n\t\tint pointrow = 0; \n\t\tint pointcolumn = 0;\n\t\tvector<T> store;\n\t\tfor(int i = 0; i < this->values.size() + s1.values.size(); i ++){\n\t\t\tif(pointcolumn == s1.columns){\n\t\t\t\tpointrow ++;\n\t\t\t\tpointcolumn = 0;\n\t\t\t}\n\t\t\tif(flagcolumn == this-> columns){\n\t\t\t\tflagrow ++;\n\t\t\t\tflagcolumn = 0;\n\t\t\t}\n\t\t\tif(i % (this->columns + s1.columns) < this->columns){\n\t\t\t\tstore.push_back(this->values[flagrow * this->columns + flagcolumn]);\n\t\t\t\tflagcolumn ++;\n\t\t\t}\t\n\t\t\telse{\n\t\t\t\tstore.push_back(s1.values[pointrow * s1.columns + pointcolumn]);\n\t\t\t\tpointcolumn ++;\n\t\t\t}\n\t\t}\n\t\tMatrix s(this->rows,this->columns + s1.columns,store);\n\t\tstore.clear();\n\t\treturn s;\n\t}\n\tMatrix reshape(int newrows,int newcolumns){\n\t\tvector<T> store;\n\t\tfor(int i = 0; i < newrows * newcolumns; i ++)\n\t\t\tstore.push_back(T());\n\t\tint flagrow = 0;\n\t\tint flagcolumn = 0;\n\t\tint pointcolumn = 0;\n\t\tint pointrow = 0;\n\t\twhile(flagcolumn < newcolumns){\n\t\t\tif(flagrow == newrows){\n\t\t\t\tflagcolumn ++;\n\t\t\t\tflagrow = 0;\n\t\t\t}\n\t\t\tif(pointrow == this->rows){\n\t\t\t\tpointcolumn ++;\n\t\t\t\tpointrow = 0;\n\t\t\t}\n\t\t\tstore[flagrow * newcolumns + flagcolumn] = this->values[pointrow * this->columns + pointcolumn];\n\t\t\tflagrow ++;\n\t\t\tpointrow ++;\n\t\t}\n\t\tMatrix s(newrows,newcolumns,store);\n\t\tstore.clear();\n\t\treturn s;\n\t}\n\tMatrix transpose(){\n\t\tvector<T> store;\n\t\tint flagrow = 0;\n\t\tint flagcolumn = 0;\n\t\tfor(int i = 0; i < this->rows * this->columns; i ++){\n\t\t\tif(flagrow == this->rows){\n\t\t\t\tflagrow = 0;\n\t\t\t\tflagcolumn ++;\n\t\t\t}\n\t\t\tstore.push_back(this->values[flagrow * this->columns + flagcolumn]);\n\t\t\tflagrow ++;\n\t\t}\n\t\tMatrix s(this->columns,this->rows,store);\n\t\tstore.clear();\n\t\treturn s;\n\t}\n\tMatrix operator +(Matrix<T> s1){\n\t\tvector<T> store;\n\t\tfor(int i = 0; i < s1.rows * s1.columns; i ++)\n\t\t\tstore.push_back(s1.values[i] + this->values[i]);\n\t\tMatrix s(s1.rows,s1.columns,store);\n\t\tstore.clear();\n\t\treturn s;\n\t}\n\tMatrix operator +(int x){\n\t\tvector<T> store;\n\t\tfor(int i = 0; i < this->rows * this->columns; i ++)\n\t\t\tstore.push_back(this->values[i] + x);\n\t\tMatrix s(this->rows, this->columns, store);\n\t\tstore.clear();\n\t\treturn s;\n\t}\n\tMatrix operator -(Matrix<T> s1){\n\t\tvector<T> store;\n\t\tfor(int i = 0; i < s1.rows * s1.columns; i ++)\n\t\t\tstore.push_back(this->values[i] - s1.values[i]);\n\t\tMatrix s(s1.rows,s1.columns,store);\n\t\tstore.clear();\n\t\treturn s;\n\t}\n\tMatrix operator -(int x){\n\t\tvector<T> store;\n\t\tfor(int i = 0; i < this->rows * this->columns; i ++)\n\t\t\tstore.push_back(this->values[i] - x);\n\t\tMatrix s(this->rows, this->columns, store);\n\t\tstore.clear();\n\t\treturn s;\n\t}\n\tMatrix operator *(int x){\n\t\tvector<T> store;\n\t\tfor(int i = 0; i < this->rows * this->columns; i ++)\n\t\t\tstore.push_back(this->values[i] * x);\n\t\tMatrix s(this->rows,this->columns,store);\n\t\tstore.clear();\n\t\treturn s;\n\t}\n\tMatrix operator *(Matrix<T> s1){\n\t\tint flagrow = 0;\n\t\tint pointcolumn = 0;\n\t\tvector<T> store;\n\t\tT cnt = T();\n\t\tfor(int i = 0; i < this->rows * s1.columns; i ++){\n\t\t\tif(pointcolumn == s1.columns){\n\t\t\t\tpointcolumn = 0;\n\t\t\t\tflagrow ++;\n\t\t\t}\n\t\t\tfor(int j = 0; j < this->columns; j ++){\n\t\t\t\tcnt += this->values[flagrow * this->columns + j] * s1.values[j * s1.columns + pointcolumn];\n\t\t\t}\n\t\t\tpointcolumn ++;\n\t\t\tstore.push_back(cnt);\n\t\t\tcnt = T();\n\t\t}\n\t\tMatrix s(this->rows, s1.columns,store);\n\t\tstore.clear();\n\t\treturn s;\n\t}\n\tMatrix max(){\n\t\tif(this->rows == 1){\n\t\t\tT cnt = this->values[0];\n\t\t\tvector<T> store;\n\t\t\tfor(int i = 1; i < this->columns; i ++){\n\t\t\t\tif(cnt < this->values[i])\n\t\t\t\t\tcnt = this->values[i];\n\t\t\t}\n\t\t\tstore.push_back(cnt);\n\t\t\tMatrix s(1,1,store);\n\t\t\tstore.clear();\n\t\t\treturn s;\n\t\t}\n\t\telse{\n\t\t\tvector<T> store;\n\t\t\tfor(int i = 0; i < this->columns; i ++){\n\t\t\t\tT cnt = this->values[i];\n\t\t\t\tfor(int j = 1; j < this->rows; j ++){\n\t\t\t\t\tif(cnt < this->values[j * this->columns + i])\n\t\t\t\t\t\tcnt = this->values[j * this->columns + i];\n\t\t\t\t}\n\t\t\t\tstore.push_back(cnt);\n\t\t\t}\n\t\t\tMatrix s(1,this->columns,store);\n\t\t\tstore.clear();\n\t\t\treturn s;\n\t\t}\n\t}\n\tMatrix min(){\n\t\tif(this->rows == 1){\n\t\t\tT cnt = this->values[0];\n\t\t\tvector<T> store;\n\t\t\tfor(int i = 1; i < this->columns; i ++){\n\t\t\t\tif(cnt > this->values[i])\n\t\t\t\t\tcnt = this->values[i];\n\t\t\t}\n\t\t\tstore.push_back(cnt);\n\t\t\tMatrix s(1,1,store);\n\t\t\tstore.clear();\n\t\t\treturn s;\n\t\t}\n\t\telse{\n\t\t\tvector<T> store;\n\t\t\tfor(int i = 0; i < this->columns; i ++){\n\t\t\t\tT cnt = this->values[i];\n\t\t\t\tfor(int j = 1; j < this->rows; j ++){\n\t\t\t\t\tif(cnt > this->values[j * this->columns + i])\n\t\t\t\t\t\tcnt = this->values[j * this->columns + i];\n\t\t\t\t}\n\t\t\t\tstore.push_back(cnt);\n\t\t\t}\n\t\t\tMatrix s(1,this->columns,store);\n\t\t\tstore.clear();\n\t\t\treturn s;\n\t\t}\n\t}\n\tMatrix sum(){\n\t\tif(this->rows == 1){\n\t\t\tT cnt = T();\n\t\t\tvector<T> store;\n\t\t\tfor(int i = 0; i < this->columns; i ++)\n\t\t\t\tcnt += this->values[i];\n\t\t\tstore.push_back(cnt);\n\t\t\tMatrix s(1,1,store);\n\t\t\tstore.clear();\n\t\t\treturn s;\n\t\t}\n\t\telse{\n\t\t\tT cnt = T();\n\t\t\tvector<T> store;\n\t\t\tfor(int i = 0; i < this->columns; i ++){\n\t\t\t\tfor(int j = 0; j < this->rows; j ++){\n\t\t\t\t\tcnt += this->values[j * this->columns + i];\n\t\t\t\t}\n\t\t\t\tstore.push_back(cnt);\n\t\t\t\tcnt = T();\n\t\t\t}\n\t\t\tMatrix s(1,this->columns,store);\n\t\t\tstore.clear();\n\t\t\treturn s;\n\t\t}\n\t}\n};\n#endif\n",
            1590668313.0775473,
            100,
            "# 答案正确"
        ],
        [
            "7.1 (C++)",
            "邵震东",
            "#include <cmath>\n\nclass Triangle : public GeometricObject\n{\nprivate:\n    double side1 = 1;\n    double side2 = 1;\n    double side3 = 1;\npublic:\n    Triangle(double s1 = 1, double s2 = 1, double s3 = 1) :\n        side1(s1), side2(s2), side3(s3) { }\n    double getSide1() { return side1; }\n    double getSide2() { return side2; }\n    double getSide3() { return side3; }\n    double getArea()\n    {\n        double s, area;\n        s = (side1 + side2 + side3) / 2;\n        area = sqrt(s * (s - side1) * (s - side2) * (s - side3));\n        return area;\n    }\n    double getPerimeter() { return side1 + side2 + side3; }\n};",
            1590726772.292813,
            100,
            "# 答案正确"
        ],
        [
            "7.2 (C++)",
            "邵震东",
            "#ifndef _PROJECT_SOURCE_HPP_\n#define _PROJECT_SOURCE_HPP_\n#include <string>\n#include <vector>\n\nstd::vector<std::string> split (const std::string & line, const std::string & delimiter = \" \")\n{\n    std::vector<std::string> words;\n    int st = 0;\n    while (st < line.size() ) {\n        int end = line.find(delimiter, st);\n        if (end == st) st += delimiter.size();\n        else {\n            if (end == -1) {\n                words.push_back(line.substr(st));\n                break;\n            }\n            words.push_back(line.substr(st, end-st));\n            st = end + delimiter.size();\n        }\n    }\n    return words;\n}\n\n#endif",
            1591239814.9826605,
            100,
            "# 答案正确"
        ],
        [
            "7.3 (C++)",
            "邵震东",
            "#ifndef _PROJECT_SOURCE_HPP_\n#define _PROJECT_SOURCE_HPP_\n\ntemplate <typename A, typename R>\nvector<R> map2(const vector<A> & x, const vector<A> & y, R (*map_func)(const A &, const A &)) {\n    vector<R> res;\n    for (int i = 0; i < x.size(); ++ i)\n        res.push_back(map_func(x[i], y[i]));\n    return res;\n}\n\ntemplate <typename A, typename R>\nvector<R> map2(const vector<A> & x, const int y, R (*map_func)(const A &, const A &)) {\n    vector<R> res;\n    for (int i = 0; i < x.size(); ++ i)\n        res.push_back(map_func(x[i], y));\n    return res;\n}\n\n#endif",
            1591272313.3422458,
            100,
            "# 答案正确"
        ],
        [
            "8.1 (C++)",
            "邵震东",
            "#ifndef _PROJECT_SOURCE_HPP_\n#define _PROJECT_SOURCE_HPP_\n\n//virtual int size(int dimension) const = 0;\n//\n//virtual void set(int row, int column, double value) = 0;\n//\n//virtual double get(int row, int column) const = 0;\n//\n//virtual void print() const = 0;\n//\n//virtual Matrix & operator = (const Matrix & matrix2) = 0;\n\nclass Full : public Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    double * values;\npublic:\n    Full() = default;\n    Full(int rows, int columns) :\n        rows(rows), columns(columns)\n    {\n        values = new double [rows * columns];\n        for (int i = 0; i < rows * columns; ++i)\n            *(values + i) = 0;\n    }\n    Full(int rows, int columns, double * values) :\n        rows(rows), columns(columns)\n    {\n        this->values = new double [rows * columns];\n        for (int i = 0; i < rows * columns; ++i)\n            *(this->values + i) = *(values + i);\n    }\n    Full(const Matrix & matrix2)\n    {\n        rows = matrix2.size(1);\n        columns = matrix2.size(2);\n        values = new double [rows * columns];\n        for (int i = 0; i < rows; ++i)\n            for (int j = 0; j < columns; ++j)\n                *(values + (i * columns) + j) = matrix2.get(i, j);\n    }\n    ~Full() { delete [] this->values; }\n    int size(int demension) const\n    {\n        switch (demension)\n        {\n            case 1:\n                return rows;\n            case 2:\n                return columns;\n        }\n    }\n    double get(int row, int column) const\n    {\n        return *(values + row * columns + column);\n    }\n    void print() const\n    {\n        int cnt = 0;\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < columns; ++j) {\n                cout << \"    \" << *(values + cnt);\n                ++cnt;\n            }\n            cout << endl;\n        }\n    }\n    Matrix & operator = (const Matrix & matrix2)\n    {\n        int cnt = 0;\n        this->rows = matrix2.size(1);\n        this->columns = matrix2.size(2);\n        // this->values = new double [this->rows * this->columns];\n        for (int i = 0; i < this->rows; ++i)\n            for (int j = 0; j < this->columns; ++j) {\n                *(values + cnt) = matrix2.get(i, j);\n                ++cnt;\n            }\n        return *(this);\n    }\n    void set(int row, int column, double value)\n    {\n        *(this->values + (row - 1) * columns + column - 1) = value;\n    }\n};\n\n#endif",
            1591801155.7190263,
            100,
            "# 答案正确"
        ],
        [
            "8.3 (C++)",
            "邵震东",
            "#ifndef _PROJECT_SOURCE_HPP_\n#define _PROJECT_SOURCE_HPP_\n#include <vector>\n#include <iostream>\n\nclass Sparse : public Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    std::vector<Entry> values;\n    size_t values_max = 10;\n    size_t values_curt = 0;\npublic:\n    Sparse(int rows, int columns) : rows(rows), columns(columns) { }\n    Sparse & operator + (const Sparse & matrix2)\n    {\n        for (int i = 0; i < values_curt; ++i) {\n            for (int j = 0; j < matrix2.values_curt; ++j) {\n                if (values[i].row == matrix2.values[j].row && values[i].column == matrix2.values[j].column)\n                    values[i].value += matrix2.values[j].value;\n            }\n        }\n        for (int i = 0; i < matrix2.values_curt; ++i) {\n            int ifFound = 0;\n            for (int j = 0; j < values_curt; ++j) {\n                if (matrix2.values[i].row == values[j].row && matrix2.values[i].column == values[j].column)\n                    ifFound = 1;\n            }\n            if (ifFound == 0)\n                set(matrix2.values[i].row, matrix2.values[i].column, matrix2.values[i].value);\n        }\n        return *(this);\n    }\n    int size(int dimension) const\n    {\n        switch (dimension) {\n            case 1:\n                return this->rows;\n                break;\n            case 2:\n                return this->columns;\n            default:\n                return 0;\n                break;\n        }\n    }\n    void set(int row, int column, double value)\n    {\n        Entry val;\n        val.row = row;\n        val.column = column;\n        val.value = value;\n        if (value != 0 && values_curt <= values_max){\n            values.push_back(val);\n            ++values_curt;\n        }\n    }\n    double get(int row, int column) const\n    {\n        for (int i = 0; i < values_max; ++i) {\n            if (values[i].row == row && values[i].column == column)\n                return values[i].value;\n        }\n        return 0;\n    }\n    void print()\n    {\n        for (int i = 0; i < values_curt; ++i) {\n            for (int j = 0; j < values_curt - 1; ++j) {\n                if (values[j].row > values[j + 1].row) {\n                    Entry temp = values[j];\n                    values[j] = values[j + 1];\n                    values[j + 1] = temp;\n                } else if (values[j].row == values[j + 1].row && values[j].column > values[j + 1].column) {\n                    Entry temp = values[j];\n                    values[j] = values[j + 1];\n                    values[j + 1] = temp;\n                }\n            }\n        }\n        for (int i = 0; i < values_curt; ++i) {\n            if (values[i].row > 0 && values[i].column > 0 && values[i].value != 0)\n                std::cout << '(' << values[i].row << ',' << values[i].column << ',' << values[i].value\n                << ')' << std::endl;\n        }\n    }\n};\n\n#endif\n",
            1591835430.6530087,
            100,
            "# 答案正确"
        ],
        [
            "8.5 (C++)",
            "邵震东",
            "#ifndef _PROJECT_SOURCE_HPP_\n#define _PROJECT_SOURCE_HPP_\n\nclass Point3D : public Point2D\n{\nprivate:\n    double z;\npublic:\n    Point3D() : z(0), Point2D() { }\n    Point3D(double x, double y, double z) : z(z)\n    {\n        setX(x);\n        setY(y);\n    }\n    double getZ() { return z; }\n    void setZ(double z) { this->z = z; }\n    double distance(Point2D & point2)\n    {\n        Point3D & point3 = dynamic_cast<Point3D &>(point2);\n        double dx = getX() - point2.getX();\n        double dy = getY() - point2.getY();\n        double dz = getZ() - point3.getZ();\n        return sqrt(dx * dx + dy * dy + dz * dz);\n    }\n};\n\n#endif\n",
            1591843258.8862875,
            100,
            "# 答案正确"
        ],
        [
            "8.4 (C++)",
            "邵震东",
            "#ifndef _PROJECT_SOURCE_HPP_\n#define _PROJECT_SOURCE_HPP_\n#include <vector>\n#include <iostream>\n\nclass Sparse : public Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    std::vector<Entry> values;\n    size_t values_max = 10;\n    size_t values_curt = 0;\npublic:\n    Sparse(int rows, int columns) : rows(rows), columns(columns) { }\n    Sparse & operator * (const Sparse & matrix2)\n    {\n        Sparse matrix3(rows, matrix2.columns);\n        for (int i = 0; i < values_curt; ++i) {\n            int ifFound = 0;\n            for (int j = 0; j < matrix2.values_curt; ++j) {\n                if (values[i].column == matrix2.values[j].row) {\n                    for (int k = 1; k <= matrix3.values_curt; ++k) {\n                        if (matrix3.values[k - 1].row == values[i].row && matrix3.values[k - 1].column == matrix2.values[j].column)\n                            ifFound = k;\n                    }\n                    if (ifFound == 0)\n                        matrix3.set(values[i].row, matrix2.values[j].column, values[i].value * matrix2.values[j].value);\n                    else\n                        matrix3.values[ifFound - 1].value += values[i].value * matrix2.values[j].value;\n                }\n            }\n        }\n//        *(this) = matrix3;\n//        return *(this);\n        static Sparse matrix4 = matrix3;\n        return matrix4;\n    }\n    int size(int dimension) const\n    {\n        switch (dimension) {\n            case 1:\n                return this->rows;\n                break;\n            case 2:\n                return this->columns;\n            default:\n                return 0;\n                break;\n        }\n    }\n    void set(int row, int column, double value)\n    {\n        Entry val;\n        val.row = row;\n        val.column = column;\n        val.value = value;\n        if (value != 0 && values_curt <= values_max){\n            values.push_back(val);\n            ++values_curt;\n        }\n    }\n    double get(int row, int column) const\n    {\n        for (int i = 0; i < values_max; ++i) {\n            if (values[i].row == row && values[i].column == column)\n                return values[i].value;\n        }\n        return 0;\n    }\n    void print()\n    {\n        for (int i = 0; i < values_curt; ++i) {\n            for (int j = 0; j < values_curt - 1; ++j) {\n                if (values[j].row > values[j + 1].row) {\n                    Entry temp = values[j];\n                    values[j] = values[j + 1];\n                    values[j + 1] = temp;\n                } else if (values[j].row == values[j + 1].row && values[j].column > values[j + 1].column) {\n                    Entry temp = values[j];\n                    values[j] = values[j + 1];\n                    values[j + 1] = temp;\n                }\n            }\n        }\n        for (int i = 0; i < values_curt; ++i) {\n            if (values[i].row > 0 && values[i].column > 0 && values[i].value != 0)\n                std::cout << '(' << values[i].row << ',' << values[i].column << ',' << values[i].value\n                          << ')' << std::endl;\n        }\n    }\n};\n\n#endif\n",
            1591852336.3105524,
            100,
            "# 答案正确"
        ],
        [
            "8.6 (C++)",
            "邵震东",
            "#ifndef _PROJECT_SOURCE_HPP_\n#define _PROJECT_SOURCE_HPP_\n#include <iostream>\n#include <vector>\nusing namespace std;\nclass MyTensor:public Tensor<double>{\nprivate:\n    vector<double> values;\npublic:\n    MyTensor(vector<int> sizes):Tensor<double>(sizes) {\n        int sum = 1;\n        for(int i = 0;i < sizes.size();i++){\n            sum *= sizes[i];\n        }\n        for(int i = 0;i < sum;i++){\n            values.push_back(0);\n        }\n    }\n    virtual double & get(const vector<int> & indexes){\n        int index = indexes[0];\n        for(int i = 1;i < indexes.size();i++){\n            index = sizes[i] *  index + indexes[i];\n        }\n        return values[index];\n    }\n};\n#endif",
            1592451557.1861799,
            100,
            "# 答案正确"
        ],
        [
            "9.1 (C++)",
            "邵震东",
            "#ifndef _PROJECT_SOURCE_HPP_\n#define _PROJECT_SOURCE_HPP_\n\nclass Circle\n{\nprivate:\n    double radii;\npublic:\n    Circle(double radius) : radii(radius) { }\n    //(<, <=, ==, !=, >, >=)\n    int operator < (Circle & circle2)\n    {\n        return this->radii < circle2.radii ? 1 : 0;\n    }\n    int operator <= (Circle & circle2)\n    {\n        return this->radii <= circle2.radii ? 1 : 0;\n    }\n    int operator == (Circle & circle2)\n    {\n        return this->radii == circle2.radii ? 1 : 0;\n    }\n    int operator != (Circle & circle2)\n    {\n        return this->radii != circle2.radii ? 1 : 0;\n    }\n    int operator > (Circle & circle2)\n    {\n        return this->radii > circle2.radii ? 1 : 0;\n    }\n    int operator >= (Circle & circle2)\n    {\n        return this->radii >= circle2.radii ? 1 : 0;\n    }\n};\n\n#endif //_PROJECT_SOURCE_HPP_",
            1592566786.4981503,
            100,
            "# 答案正确"
        ],
        [
            "9.2 (C++)",
            "邵震东",
            "#ifndef _PROJECT_SOURCE_HPP_\n#define _PROJECT_SOURCE_HPP_\n\nclass I : public vector<int>//, Tensor\n{\npublic:\n    I(int x, int y = -1, int z = -1, int w = -1)\n    {\n        this->push_back(x);\n        if (y != -1)\n            this->push_back(y);\n        if (z != -1)\n            this->push_back(z);\n        if (w != -1)\n            this->push_back(w);\n    }\n};\n\n#endif //_PROJECT_SOURCE_HPP_",
            1592644143.0444298,
            100,
            "# 答案正确"
        ],
        [
            "9.3 (C++)",
            "邵震东",
            "#ifndef _PROJECT_SOURCE_HPP_\n#define _PROJECT_SOURCE_HPP_\n\nclass Complex\n{\nprivate:\n    double re;\n    double im;\npublic:\n    Complex() = default;\n    Complex(double real = 0, double imag = 0) :\n        re(real), im(imag) { }\n    Complex(const Complex & complex2) :\n        re(complex2.real()), im(complex2.imag()) { }\n    Complex operator + (const Complex & complex2) const\n    {\n        Complex complex(0, 0);\n        complex.re = this->re + complex2.re;\n        complex.im = this->im + complex2.im;\n        return complex;\n    }\n    Complex operator - (const Complex & complex2) const\n    {\n        Complex complex(0, 0);\n        complex.re = this->re - complex2.re;\n        complex.im = this->im - complex2.im;\n        return complex;\n    }\n    Complex operator * (const Complex & complex2) const\n    {\n        Complex complex(0, 0);\n        complex.re = this->re * complex2.re - this->im * complex2.im;\n        complex.im = this->re * complex2.im + this->im * complex2.re;\n        return complex;\n    }\n    Complex operator / (const Complex & complex2) const\n    {\n        Complex complex(0, 0);\n        complex.re = (this->re * complex2.re + this->im * complex2.im) / (complex2.im * complex2.im + complex2.re * complex2.re);\n        complex.im = (this->im * complex2.re - this->re * complex2.im) / (complex2.im * complex2.im + complex2.re * complex2.re);\n        return complex;\n    }\n    Complex & operator += (const Complex & complex2)\n    {\n        this->re += complex2.re;\n        this->im += complex2.im;\n        return (*this);\n    }\n    Complex & operator -= (const Complex & complex2)\n    {\n        this->re -= complex2.re;\n        this->im -= complex2.im;\n        return (*this);\n    }\n    Complex & operator *= (const Complex & complex2)\n    {\n        // cout << this->real() << \" + \" << this->imag() << \"i\" << endl;\n        // cout << complex2.real() << \" + \" << complex2.imag() << \"i\" << endl;\n        // this->re = this->re * complex2.re - this->im * complex2.im;\n        // this->im = this->re * complex2.im + this->im * complex2.re;\n        (*this) = (*this) * complex2;\n        return (*this);\n    }\n    Complex & operator /= (const Complex & complex2)\n    {\n        // this->re = (this->re * complex2.re + this->im * complex2.im) / (complex2.im * complex2.im + complex2.re * complex2.re);\n        // //cout << this->real() << \" + \" << this->imag() << \"i\" << endl;\n        // //cout << complex2.real() << \" + \" << complex2.imag() << \"i\" << endl;\n        // this->im = (this->im * complex2.re - this->re * complex2.im) / (complex2.im * complex2.im + complex2.re * complex2.re);\n        // //cout << this->real() << \" + \" << this->imag() << \"i\" << endl;\n        (*this) = (*this) / complex2;\n        return (*this);\n    }\n    bool operator == (const Complex & complex2) const\n    {\n        return this->re == complex2.re && this->im == complex2.im ? true : false;\n    }\n    bool operator != (const Complex & complex2) const\n    {\n        return this->re != complex2.re || this->im != complex2.im ? true : false;\n    }\n    double real() const { return this->re; }\n    double imag() const { return this->im; }\n};\n\nComplex operator + (const double num, const Complex & complex2)\n{\n    Complex complex(complex2.real() + num, complex2.imag());\n    return complex;\n}\nComplex operator - (const Complex & complex2, const double num)\n{\n    Complex complex(complex2.real() - num, complex2.imag());\n    return complex;\n}\n\n#endif //_PROJECT_SOURCE_HPP_\n",
            1592650259.3901417,
            100,
            "# 答案正确"
        ],
        [
            "9.4 (C++)",
            "邵震东",
            "#ifndef _PROJECT_SOURCE_HPP_\n#define _PROJECT_SOURCE_HPP_\n\nclass Complex\n{\nprivate:\n    double re;\n    double im;\npublic:\n    // Complex() : re(0), im(0) { }\n    Complex(double real = 0, double imag = 0) :\n            re(real), im(imag) { }\n    Complex(const Complex & complex2) :\n            re(complex2.re), im(complex2.im) { }\n    Complex operator + (const Complex & complex2) const\n    {\n        Complex complex(0, 0);\n        complex.re = this->re + complex2.re;\n        complex.im = this->im + complex2.im;\n        return complex;\n    }\n    Complex operator - (const Complex & complex2) const\n    {\n        Complex complex(0, 0);\n        complex.re = this->re - complex2.re;\n        complex.im = this->im - complex2.im;\n        return complex;\n    }\n    friend istream & operator >> (istream &, Complex &);\n    friend ostream & operator << (ostream &, Complex &);\n};\n\nistream & operator >> (istream & in, Complex & complex2)\n{\n    in >> complex2.re >> complex2.im;\n    return in;\n}\nostream & operator << (ostream & out, Complex & complex2)\n{\n    out << complex2.re << \" + \" << complex2.im << \" i\";\n    return out;\n}\n\n#endif //_PROJECT_SOURCE_HPP_\n",
            1592659079.8380575,
            100,
            "# 答案正确"
        ],
        [
            "9.5 (C++)",
            "邵震东",
            "#ifndef _PROJECT_SOURCE_HPP_\n#define _PROJECT_SOURCE_HPP_\n\nclass Complex\n{\nprivate:\n    double re;\n    double im;\npublic:\n    // Complex() : re(0), im(0) { }\n    Complex(double real = 0, double imag = 0) :\n            re(real), im(imag) { }\n    Complex(const Complex & complex2) :\n            re(complex2.re), im(complex2.im) { }\n    Complex & operator ++ ()\n    {\n        ++this->re;\n        return (*this);\n    }\n    Complex & operator ++ (int)\n    {\n        static Complex prev(*this);\n        this->re++;\n        return (Complex&)prev;\n    }\n    operator double ()\n    {\n        return re;\n    }\n    friend istream & operator >> (istream &, Complex &);\n    friend ostream & operator << (ostream &, Complex &);\n};\n\nistream & operator >> (istream & in, Complex & complex2)\n{\n    in >> complex2.re >> complex2.im;\n    return in;\n}\nostream & operator << (ostream & out, Complex & complex2)\n{\n    out << complex2.re << \" + \" << complex2.im << \" i\";\n    return out;\n}\n\n#endif //_PROJECT_SOURCE_HPP_\n",
            1592668462.9985318,
            100,
            "# 答案正确"
        ],
        [
            "9.6 (C++)",
            "邵震东",
            "#ifndef _PROJECT_SOURCE_HPP_\n#define _PROJECT_SOURCE_HPP_\n#include <cmath>\n\nclass Tensor\n{\nprivate:\n    vector<int> size;\n    double * values;\npublic:\n    Tensor(int x, int y = -1, int z = -1, int w = -1)\n    {\n            size.push_back(x);\n        if (y != -1)\n            size.push_back(y);\n        if (z != -1)\n            size.push_back(z);\n        if (w != -1)\n            size.push_back(w);\n        values = new double [abs(x * y * z * w)];\n    }\n    ~Tensor() { delete [] values; }\n    double & operator () (int x, int y = -1, int z = -1, int w = -1)\n    {\n        int index = 0;\n        switch (size.size()) {\n            case 4:\n                index = w + z * size[3] + y * size[2] * size[3] + x * size[1] * size[2] * size[3];\n                break;\n            case 3:\n                index = z + y * size[2] + x * size[1] * size[2];\n                break;\n            case 2:\n                index = y + x * size[1];\n                break;\n            case 1:\n                index = x;\n                break;\n            default:\n                index = 0;\n        }\n        return values[index];\n    }\n};\n\n#endif //_PROJECT_SOURCE_HPP_\n",
            1592669645.262144,
            100,
            "# 答案正确"
        ],
        [
            "9.7 (C++)",
            "邵震东",
            "#ifndef _PROJECT_SOURCE_HPP_\n#define _PROJECT_SOURCE_HPP_\n#include <cmath>\n\nclass Tensor\n{\nprivate:\n    int dim;\n    vector<int> size;\n    double * values;\npublic:\n    Tensor() = default;\n    ~Tensor() { delete [] values; }\n    double & operator () (int x, int y = -1, int z = -1, int w = -1)\n    {\n        int index = 0;\n        switch (size.size()) {\n            case 4:\n                index = w + z * size[3] + y * size[2] * size[3] + x * size[1] * size[2] * size[3];\n                break;\n            case 3:\n                index = z + y * size[2] + x * size[1] * size[2];\n                break;\n            case 2:\n                index = y + x * size[1];\n                break;\n            case 1:\n                index = x;\n                break;\n            default:\n                index = 0;\n        }\n        return values[index];\n    }\n    friend istream & operator >> (istream &, Tensor &);\n    friend ostream & operator << (ostream &, Tensor &);\n};\n\nistream & operator >> (istream & in, Tensor & matrix)\n{\n    in >> matrix.dim;\n    for (int i = 0; i < matrix.dim; ++i) {\n        int sizes = 0;\n        in >> sizes;\n        matrix.size.push_back(sizes);\n    }\n    int sizes = 1;\n    for (int i = 0; i < matrix.dim; ++i) {\n        sizes *= matrix.size[i];\n    }\n    matrix.values = new double [sizes];\n\n    for (int i = 0; i < sizes; ++i) {\n        in >> *(matrix.values + i);\n    }\n    return in;\n}\nostream & operator << (ostream & out, Tensor & matrix)\n{\n    out << matrix.dim << endl;\n    for (int i = 0; i < matrix.dim; ++i)\n        out << matrix.size[i] << ' ';\n    out << endl << endl;\n    int cnt = 0;\n    int times = 1;\n    if (matrix.dim == 4)\n        times = matrix.size[0] * matrix.size[1];\n    else if (matrix.dim == 3)\n        times = matrix.size[0];\n    for (int index = 0; index < times; ++index) {\n        for (int i = 0; i < matrix.size[matrix.dim - 2]; ++i) {\n            for (int j = 0; j < matrix.size[matrix.dim - 1]; ++j) {\n                out << *(matrix.values + cnt) << ' ';\n                ++cnt;\n            }\n            out << endl;\n        }\n        out << endl;\n    }\n    return out;\n}\n\n#endif //_PROJECT_SOURCE_HPP_\n",
            1592671203.3273516,
            100,
            "# 答案正确"
        ],
        [
            "10.1 (C++)",
            "邵震东",
            "#ifndef _PROJECT_SOURCE_HPP_\n#define _PROJECT_SOURCE_HPP_\n#include <stdexcept>\n\nclass MatrixSizesDoNotMatchException {};\n\ndouble Matrix::get(int row, int column) const\n{\n    if (row > this->rows || column > this->columns)\n        throw out_of_range(\"1\");\n    else {\n        return this->elements[column - 1 + (row - 1) * this->size(2)];\n    }\n}\n\nvoid Matrix::set(int row, int column, double value)\n{\n    if (row > this->rows || column > this->columns)\n        throw MatrixSizesDoNotMatchException();\n    else {\n        this->elements[column - 1 + (row - 1) * this->size(2)] = value;\n    }\n}\n\nMatrix Matrix::operator + (const Matrix & matrix2) const\n{\n    if (this->rows != matrix2.rows || this->columns != matrix2.columns)\n        throw MatrixSizesDoNotMatchException();\n    else {\n        Matrix matrix(rows, columns);\n        for (int i = 0; i < rows; ++ i) {\n            for (int j = 0; j < columns; ++ j) {\n                double value;\n                value = this->get(i + 1, j + 1) + matrix2.get(i + 1, j + 1);\n                matrix.set(i + 1, j + 1, value);\n            }\n        }\n        return matrix;\n    }\n}\n\n#endif\n",
            1593618462.4448223,
            100,
            "# 答案正确"
        ],
        [
            "10.2 (C++)",
            "邵震东",
            "#ifndef _PROJECT_SOURCE_HPP_\n#define _PROJECT_SOURCE_HPP_\n\ncatch(out_of_range & ex) {\n    string er = ex.what();\n    if ( er == \"index\" )\n        cout << \"caught: out_of_range\" << endl;\n    else\n    \tcout << \"caught: NonPositiveValueException\" << endl;\n}\n\n#endif\n",
            1593659561.3220367,
            100,
            "# 答案正确"
        ],
        [
            "2020-07-09 LAB",
            "邵震东",
            "#ifndef _PROJECT_SOURCE_HPP_\n#define _PROJECT_SOURCE_HPP_\n#include <iostream>\nusing namespace std;\n\nclass Integer {\nprivate:\n    int x;\npublic:\n    static int sum;\n    Integer(): x(0) {}\n    Integer(int x): x(x) {}\n\n    static void increase_all(int other) {\n        sum += other;\n    }\n\n    static void increase_all(Integer & other) {\n        int y = other.x;\n        sum = sum + sum + y;\n    }\n\n    friend istream & operator >> (istream & in, Integer & other) {\n        in >> other.x;\n        return in;\n    }\n\n    friend ostream & operator << (ostream & out, const Integer & other) {\n        out << other.x + sum;\n        return out;\n    }\n};\n\nint Integer::sum = 0;\n\n#endif\n",
            1594265663.0558238,
            100,
            "# 答案正确"
        ],
        [
            "15.1 (C++)",
            "邵震东",
            "#ifndef _PROJECT_SOURCE_HPP_\n#define _PROJECT_SOURCE_HPP_\n#include <iostream>\n#include <vector>\n#include <string>\n\n//std::ostream & operator << (std::ostream & out, void fuc())\n//{\n//    return out;\n//}\n\nstruct element\n{\n    std::vector<std::string> ele;\n};\n\nclass Table\n{\nprivate:\n    std::vector<std::string> str;\n    std::vector<element> val;\npublic:\n    Table() = default;\n    std::vector<std::string> operator [] (int index)\n    {\n        if (index > this->val.size())\n            return val[0].ele;\n        else\n            return val[index].ele;\n    }\n    void addCol(const char* str)\n    {\n        this->str.push_back(str);\n    }\n    std::ostream & json() const\n    {\n        std::cout << \"{\\n\" << \"\\theaders: ['\" << str[0] << \"','\" << str[1] << \"',],\" << \"}\\n\"\n            << \"rows: [\" << \"\\t\\t['\" << val[0].ele[0] << \"','\" << val[0].ele[1] << \"',],\\n\"\n            << \"rows: [\" << \"\\t\\t['\" << val[1].ele[0] << \"','\" << val[1].ele[1] << \"',],\\n\"\n            << \"\\t],\\n}\";\n        return std::cout;\n    }\n};\n\n#endif\n",
            1594299218.1143343,
            0,
            "main.cpp: In function ‘std::ostream& operator<<(std::ostream&, const Table&)’:\nmain.cpp:9:6: error: no match for ‘operator<<’ (operand types are ‘std::ostream {aka std::basic_ostream<char>}’ and ‘std::ostream {aka std::basic_ostream<char>}’)\n  out << table.json() << endl;\n      ^\nIn file included from /usr/include/c++/5/iostream:39:0,\n                 from source.cpp:3,\n                 from main.cpp:1:\n/usr/include/c++/5/ostream:628:5: note: candidate: std::basic_ostream<_CharT, _Traits>& std::operator<<(std::basic_ostream<_CharT, _Traits>&&, const _Tp&) [with _CharT = char; _Traits = std::char_traits<char>; _Tp = std::basic_ostream<char>] <near match>\n     operator<<(basic_ostream<_CharT, _Traits>&& __os, const _Tp& __x)\n     ^\n/usr/include/c++/5/ostream:628:5: note:   conversion of argument 1 would be ill-formed:\nmain.cpp:9:20: error: cannot bind ‘std::ostream {aka std::basic_ostream<char>}’ lvalue to ‘std::basic_ostream<char>&&’\n  out << table.json() << endl;\n                    ^\nmain.cpp:9:6: note: candidate: operator<<(int, int) <built-in>\n  out << table.json() << endl;\n      ^\nmain.cpp:9:6: note:   no known conversion for argument 2 from ‘std::ostream {aka std::basic_ostream<char>}’ to ‘int’\nIn file included from /usr/include/c++/5/iostream:39:0,\n                 from source.cpp:3,\n                 from main.cpp:1:\n/usr/include/c++/5/ostream:108:7: note: candidate: std::basic_ostream<_CharT, _Traits>::__ostream_type& std::basic_ostream<_CharT, _Traits>::operator<<(std::basic_ostream<_CharT, _Traits>::__ostream_type& (*)(std::basic_ostream<_CharT, _Traits>::__ostream_type&)) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_ostream<_CharT, _Traits>::__ostream_type = std::basic_ostream<char>]\n       operator<<(__ostream_type& (*__pf)(__ostream_type&))\n       ^\n/usr/include/c++/5/ostream:108:7: note:   no known conversion for argument 1 from ‘std::ostream {aka std::basic_ostream<char>}’ to ‘std::basic_ostream<char>::__ostream_type& (*)(std::basic_ostream<char>::__ostream_type&) {aka std::basic_ostream<char>& (*)(std::basic_ostream<char>&)}’\n/usr/include/c++/5/ostream:117:7: note: candidate: std::basic_ostream<_CharT, _Traits>::__ostream_type& std::basic_ostream<_CharT, _Traits>::operator<<(std::basic_ostream<_CharT, _Traits>::__ios_type& (*)(std::basic_ostream<_CharT, _Traits>::__ios_type&)) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_ostream<_CharT, _Traits>::__ostream_type = std::basic_ostream<char>; std::basic_ostream<_CharT, _Traits>::__ios_type = std::basic_ios<char>]\n       operator<<(__ios_type& (*__pf)(__ios_type&))\n       ^\n/usr/include/c++/5/ostream:117:7: note:   no known conversion for argument 1 from ‘std::ostream {aka std::basic_ostream<char>}’ to ‘std::basic_ostream<char>::__ios_type& (*)(std::basic_ostream<char>::__ios_type&) {aka std::basic_ios<char>& (*)(std::basic_ios<char>&)}’\n/usr/include/c++/5/ostream:127:7: note: candidate: std::basic_ostream<_CharT, _Traits>::__ostream_type& std::basic_ostream<_CharT, _Traits>::operator<<(std::ios_base& (*)(std::ios_base&)) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_ostream<_CharT, _Traits>::__ostream_type = std::basic_ostream<char>]\n       operator<<(ios_base& (*__pf) (ios_base&))\n       ^\n/usr/include/c++/5/ostream:127:7: note:   no known conversion for argument 1 from ‘std::ostream {aka std::basic_ostream<char>}’ to ‘std::ios_base& (*)(std::ios_base&)’\n/usr/include/c++/5/ostream:166:7: note: candidate: std::basic_ostream<_CharT, _Traits>::__ostream_type& std::basic_ostream<_CharT, _Traits>::operator<<(long int) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_ostream<_CharT, _Traits>::__ostream_type = std::basic_ostream<char>]\n       operator<<(long __n)\n       ^\n/usr/include/c++/5/ostream:166:7: note:   no known conversion for argument 1 from ‘std::ostream {aka std::basic_ostream<char>}’ to ‘long int’\n/usr/include/c++/5/ostream:170:7: note: candidate: std::basic_ostream<_CharT, _Traits>::__ostream_type& std::basic_ostream<_CharT, _Traits>::operator<<(long unsigned int) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_ostream<_CharT, _Traits>::__ostream_type = std::basic_ostream<char>]\n       operator<<(unsigned long __n)\n       ^\n/usr/include/c++/5/ostream:170:7: note:   no known conversion for argument 1 from ‘std::ostream {aka std::basic_ostream<char>}’ to ‘long unsigned int’\n/usr/include/c++/5/ostream:174:7: note: candidate: std::basic_ostream<_CharT, _Traits>::__ostream_type& std::basic_ostream<_CharT, _Traits>::operator<<(bool) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_ostream<_CharT, _Traits>::__ostream_type = std::basic_ostream<char>]\n       operator<<(bool __n)\n       ^\n/usr/include/c++/5/ostream:174:7: note:   no known conversion for argument 1 from ‘std::ostream {aka std::basic_ostream<char>}’ to ‘bool’\nIn file included from /usr/include/c++/5/ostream:638:0,\n                 from /usr/include/c++/5/iostream:39,\n                 from source.cpp:3,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/ostream.tcc:91:5: note: candidate: std::basic_ostream<_CharT, _Traits>& std::basic_ostream<_CharT, _Traits>::operator<<(short int) [with _CharT = char; _Traits = std::char_traits<char>]\n     basic_ostream<_CharT, _Traits>::\n     ^\n/usr/include/c++/5/bits/ostream.tcc:91:5: note:   no known conversion for argument 1 from ‘std::ostream {aka std::basic_ostream<char>}’ to ‘short int’\nIn file included from /usr/include/c++/5/iostream:39:0,\n                 from source.cpp:3,\n                 from main.cpp:1:\n/usr/include/c++/5/ostream:181:7: note: candidate: std::basic_ostream<_CharT, _Traits>::__ostream_type& std::basic_ostream<_CharT, _Traits>::operator<<(short unsigned int) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_ostream<_CharT, _Traits>::__ostream_type = std::basic_ostream<char>]\n       operator<<(unsigned short __n)\n       ^\n/usr/include/c++/5/ostream:181:7: note:   no known conversion for argument 1 from ‘std::ostream {aka std::basic_ostream<char>}’ to ‘short unsigned int’\nIn file included from /usr/include/c++/5/ostream:638:0,\n                 from /usr/include/c++/5/iostream:39,\n                 from source.cpp:3,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/ostream.tcc:105:5: note: candidate: std::basic_ostream<_CharT, _Traits>& std::basic_ostream<_CharT, _Traits>::operator<<(int) [with _CharT = char; _Traits = std::char_traits<char>]\n     basic_ostream<_CharT, _Traits>::\n     ^\n/usr/include/c++/5/bits/ostream.tcc:105:5: note:   no known conversion for argument 1 from ‘std::ostream {aka std::basic_ostream<char>}’ to ‘int’\nIn file included from /usr/include/c++/5/iostream:39:0,\n                 from source.cpp:3,\n                 from main.cpp:1:\n/usr/include/c++/5/ostream:192:7: note: candidate: std::basic_ostream<_CharT, _Traits>::__ostream_type& std::basic_ostream<_CharT, _Traits>::operator<<(unsigned int) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_ostream<_CharT, _Traits>::__ostream_type = std::basic_ostream<char>]\n       operator<<(unsigned int __n)\n       ^\n/usr/include/c++/5/ostream:192:7: note:   no known conversion for argument 1 from ‘std::ostream {aka std::basic_ostream<char>}’ to ‘unsigned int’\n/usr/include/c++/5/ostream:201:7: note: candidate: std::basic_ostream<_CharT, _Traits>::__ostream_type& std::basic_ostream<_CharT, _Traits>::operator<<(long long int) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_ostream<_CharT, _Traits>::__ostream_type = std::basic_ostream<char>]\n       operator<<(long long __n)\n       ^\n/usr/include/c++/5/ostream:201:7: note:   no known conversion for argument 1 from ‘std::ostream {aka std::basic_ostream<char>}’ to ‘long long int’\n/usr/include/c++/5/ostream:205:7: note: candidate: std::basic_ostream<_CharT, _Traits>::__ostream_type& std::basic_ostream<_CharT, _Traits>::operator<<(long long unsigned int) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_ostream<_CharT, _Traits>::__ostream_type = std::basic_ostream<char>]\n       operator<<(unsigned long long __n)\n       ^\n/usr/include/c++/5/ostream:205:7: note:   no known conversion for argument 1 from ‘std::ostream {aka std::basic_ostream<char>}’ to ‘long long unsigned int’\n/usr/include/c++/5/ostream:220:7: note: candidate: std::basic_ostream<_CharT, _Traits>::__ostream_type& std::basic_ostream<_CharT, _Traits>::operator<<(double) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_ostream<_CharT, _Traits>::__ostream_type = std::basic_ostream<char>]\n       operator<<(double __f)\n       ^\n/usr/include/c++/5/ostream:220:7: note:   no known conversion for argument 1 from ‘std::ostream {aka std::basic_ostream<char>}’ to ‘double’\n/usr/include/c++/5/ostream:224:7: note: candidate: std::basic_ostream<_CharT, _Traits>::__ostream_type& std::basic_ostream<_CharT, _Traits>::operator<<(float) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_ostream<_CharT, _Traits>::__ostream_type = std::basic_ostream<char>]\n       operator<<(float __f)\n       ^\n/usr/include/c++/5/ostream:224:7: note:   no known conversion for argument 1 from ‘std::ostream {aka std::basic_ostream<char>}’ to ‘float’\n/usr/include/c++/5/ostream:232:7: note: candidate: std::basic_ostream<_CharT, _Traits>::__ostream_type& std::basic_ostream<_CharT, _Traits>::operator<<(long double) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_ostream<_CharT, _Traits>::__ostream_type = std::basic_ostream<char>]\n       operator<<(long double __f)\n       ^\n/usr/include/c++/5/ostream:232:7: note:   no known conversion for argument 1 from ‘std::ostream {aka std::basic_ostream<char>}’ to ‘long double’\n/usr/include/c++/5/ostream:245:7: note: candidate: std::basic_ostream<_CharT, _Traits>::__ostream_type& std::basic_ostream<_CharT, _Traits>::operator<<(const void*) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_ostream<_CharT, _Traits>::__ostream_type = std::basic_ostream<char>]\n       operator<<(const void* __p)\n       ^\n/usr/include/c++/5/ostream:245:7: note:   no known conversion for argument 1 from ‘std::ostream {aka std::basic_ostream<char>}’ to ‘const void*’\nIn file included from /usr/include/c++/5/ostream:638:0,\n                 from /usr/include/c++/5/iostream:39,\n                 from source.cpp:3,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/ostream.tcc:119:5: note: candidate: std::basic_ostream<_CharT, _Traits>& std::basic_ostream<_CharT, _Traits>::operator<<(std::basic_ostream<_CharT, _Traits>::__streambuf_type*) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_ostream<_CharT, _Traits>::__streambuf_type = std::basic_streambuf<char>]\n     basic_ostream<_CharT, _Traits>::\n     ^\n/usr/include/c++/5/bits/ostream.tcc:119:5: note:   no known conversion for argument 1 from ‘std::ostream {aka std::basic_ostream<char>}’ to ‘std::basic_ostream<char>::__streambuf_type* {aka std::basic_streambuf<char>*}’\nmain.cpp:8:11: note: candidate: std::ostream& operator<<(std::ostream&, const Table&)\n ostream & operator << (ostream & out, const Table & table) {\n           ^\nmain.cpp:8:11: note:   no known conversion for argument 2 from ‘std::ostream {aka std::basic_ostream<char>}’ to ‘const Table&’\nIn file included from /usr/include/c++/5/iostream:39:0,\n                 from source.cpp:3,\n                 from main.cpp:1:\n/usr/include/c++/5/ostream:574:5: note: candidate: template<class _Traits> std::basic_ostream<char, _Traits>& std::operator<<(std::basic_ostream<char, _Traits>&, const unsigned char*)\n     operator<<(basic_ostream<char, _Traits>& __out, const unsigned char* __s)\n     ^\n/usr/include/c++/5/ostream:574:5: note:   template argument deduction/substitution failed:\nmain.cpp:9:19: note:   cannot convert ‘(& table)->Table::json()’ (type ‘std::ostream {aka std::basic_ostream<char>}’) to type ‘const unsigned char*’\n  out << table.json() << endl;\n                   ^\nIn file included from /usr/include/c++/5/iostream:39:0,\n                 from source.cpp:3,\n                 from main.cpp:1:\n/usr/include/c++/5/ostream:569:5: note: candidate: template<class _Traits> std::basic_ostream<char, _Traits>& std::operator<<(std::basic_ostream<char, _Traits>&, const signed char*)\n     operator<<(basic_ostream<char, _Traits>& __out, const signed char* __s)\n     ^\n/usr/include/c++/5/ostream:569:5: note:   template argument deduction/substitution failed:\nmain.cpp:9:19: note:   cannot convert ‘(& table)->Table::json()’ (type ‘std::ostream {aka std::basic_ostream<char>}’) to type ‘const signed char*’\n  out << table.json() << endl;\n                   ^\nIn file included from /usr/include/c++/5/iostream:39:0,\n                 from source.cpp:3,\n                 from main.cpp:1:\n/usr/include/c++/5/ostream:556:5: note: candidate: template<class _Traits> std::basic_ostream<char, _Traits>& std::operator<<(std::basic_ostream<char, _Traits>&, const char*)\n     operator<<(basic_ostream<char, _Traits>& __out, const char* __s)\n     ^\n/usr/include/c++/5/ostream:556:5: note:   template argument deduction/substitution failed:\nmain.cpp:9:19: note:   cannot convert ‘(& table)->Table::json()’ (type ‘std::ostream {aka std::basic_ostream<char>}’) to type ‘const char*’\n  out << table.json() << endl;\n                   ^\nIn file included from /usr/include/c++/5/ostream:638:0,\n                 from /usr/include/c++/5/iostream:39,\n                 from source.cpp:3,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/ostream.tcc:321:5: note: candidate: template<class _CharT, class _Traits> std::basic_ostream<_CharT, _Traits>& std::operator<<(std::basic_ostream<_CharT, _Traits>&, const char*)\n     operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s)\n     ^\n/usr/include/c++/5/bits/ostream.tcc:321:5: note:   template argument deduction/substitution failed:\nmain.cpp:9:19: note:   cannot convert ‘(& table)->Table::json()’ (type ‘std::ostream {aka std::basic_ostream<char>}’) to type ‘const char*’\n  out << table.json() << endl;\n                   ^\nIn file included from /usr/include/c++/5/iostream:39:0,\n                 from source.cpp:3,\n                 from main.cpp:1:\n/usr/include/c++/5/ostream:539:5: note: candidate: template<class _CharT, class _Traits> std::basic_ostream<_CharT, _Traits>& std::operator<<(std::basic_ostream<_CharT, _Traits>&, const _CharT*)\n     operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s)\n     ^\n/usr/include/c++/5/ostream:539:5: note:   template argument deduction/substitution failed:\nmain.cpp:9:20: note:   mismatched types ‘const _CharT*’ and ‘std::basic_ostream<char>’\n  out << table.json() << endl;\n                    ^\nIn file included from /usr/include/c++/5/iostream:39:0,\n                 from source.cpp:3,\n                 from main.cpp:1:\n/usr/include/c++/5/ostream:519:5: note: candidate: template<class _Traits> std::basic_ostream<char, _Traits>& std::operator<<(std::basic_ostream<char, _Traits>&, unsigned char)\n     operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)\n     ^\n/usr/include/c++/5/ostream:519:5: note:   template argument deduction/substitution failed:\nmain.cpp:9:19: note:   cannot convert ‘(& table)->Table::json()’ (type ‘std::ostream {aka std::basic_ostream<char>}’) to type ‘unsigned char’\n  out << table.json() << endl;\n                   ^\nIn file included from /usr/include/c++/5/iostream:39:0,\n                 from source.cpp:3,\n                 from main.cpp:1:\n/usr/include/c++/5/ostream:514:5: note: candidate: template<class _Traits> std::basic_ostream<char, _Traits>& std::operator<<(std::basic_ostream<char, _Traits>&, signed char)\n     operator<<(basic_ostream<char, _Traits>& __out, signed char __c)\n     ^\n/usr/include/c++/5/ostream:514:5: note:   template argument deduction/substitution failed:\nmain.cpp:9:19: note:   cannot convert ‘(& table)->Table::json()’ (type ‘std::ostream {aka std::basic_ostream<char>}’) to type ‘signed char’\n  out << table.json() << endl;\n                   ^\nIn file included from /usr/include/c++/5/iostream:39:0,\n                 from source.cpp:3,\n                 from main.cpp:1:\n/usr/include/c++/5/ostream:508:5: note: candidate: template<class _Traits> std::basic_ostream<char, _Traits>& std::operator<<(std::basic_ostream<char, _Traits>&, char)\n     operator<<(basic_ostream<char, _Traits>& __out, char __c)\n     ^\n/usr/include/c++/5/ostream:508:5: note:   template argument deduction/substitution failed:\nmain.cpp:9:19: note:   cannot convert ‘(& table)->Table::json()’ (type ‘std::ostream {aka std::basic_ostream<char>}’) to type ‘char’\n  out << table.json() << endl;\n                   ^\nIn file included from /usr/include/c++/5/iostream:39:0,\n                 from source.cpp:3,\n                 from main.cpp:1:\n/usr/include/c++/5/ostream:502:5: note: candidate: template<class _CharT, class _Traits> std::basic_ostream<_CharT, _Traits>& std::operator<<(std::basic_ostream<_CharT, _Traits>&, char)\n     operator<<(basic_ostream<_CharT, _Traits>& __out, char __c)\n     ^\n/usr/include/c++/5/ostream:502:5: note:   template argument deduction/substitution failed:\nmain.cpp:9:19: note:   cannot convert ‘(& table)->Table::json()’ (type ‘std::ostream {aka std::basic_ostream<char>}’) to type ‘char’\n  out << table.json() << endl;\n                   ^\nIn file included from /usr/include/c++/5/iostream:39:0,\n                 from source.cpp:3,\n                 from main.cpp:1:\n/usr/include/c++/5/ostream:497:5: note: candidate: template<class _CharT, class _Traits> std::basic_ostream<_CharT, _Traits>& std::operator<<(std::basic_ostream<_CharT, _Traits>&, _CharT)\n     operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c)\n     ^\n/usr/include/c++/5/ostream:497:5: note:   template argument deduction/substitution failed:\nmain.cpp:9:20: note:   deduced conflicting types for parameter ‘_CharT’ (‘char’ and ‘std::basic_ostream<char>’)\n  out << table.json() << endl;\n                    ^\nIn file included from /usr/include/c++/5/bits/ios_base.h:46:0,\n                 from /usr/include/c++/5/ios:42,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from source.cpp:3,\n                 from main.cpp:1:\n/usr/include/c++/5/system_error:209:5: note: candidate: template<class _CharT, class _Traits> std::basic_ostream<_CharT, _Traits>& std::operator<<(std::basic_ostream<_CharT, _Traits>&, const std::error_code&)\n     operator<<(basic_ostream<_CharT, _Traits>& __os, const error_code& __e)\n     ^\n/usr/include/c++/5/system_error:209:5: note:   template argument deduction/substitution failed:\nmain.cpp:9:19: note:   cannot convert ‘(& table)->Table::json()’ (type ‘std::ostream {aka std::basic_ostream<char>}’) to type ‘const std::error_code&’\n  out << table.json() << endl;\n                   ^\nIn file included from /usr/include/c++/5/string:52:0,\n                 from /usr/include/c++/5/bits/locale_classes.h:40,\n                 from /usr/include/c++/5/bits/ios_base.h:41,\n                 from /usr/include/c++/5/ios:42,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from source.cpp:3,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/basic_string.h:5172:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> std::basic_ostream<_CharT, _Traits>& std::operator<<(std::basic_ostream<_CharT, _Traits>&, const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)\n     operator<<(basic_ostream<_CharT, _Traits>& __os,\n     ^\n/usr/include/c++/5/bits/basic_string.h:5172:5: note:   template argument deduction/substitution failed:\nmain.cpp:9:20: note:   ‘std::ostream {aka std::basic_ostream<char>}’ is not derived from ‘const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>’\n  out << table.json() << endl;\n                    ^\n"
        ]
    ],
    "table_name": "答案"
}