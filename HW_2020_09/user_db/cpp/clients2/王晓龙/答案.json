{
    "__update_time__": 1595854674.9003954,
    "field_names": [
        "题目名",
        "用户名",
        "答案",
        "提交时间",
        "分数",
        "评语"
    ],
    "field_types": [
        "text",
        "text",
        "text",
        "time",
        "number",
        "text"
    ],
    "foreign_keys": {},
    "primary_keys": [],
    "rows": [
        [
            "测试2",
            "王晓龙",
            "#include<iostream>\n#include<string>\n#include<cstring>\nusing namespace std;\nchar sorted(int n,char *words);   //冒泡排序\n\nmain()\n{\n    char words[10][46];          //最长的一个单词45个字母\n    int i;\n\n\n    for(i=0;i<10;i++)\n     {\n        cin >> words[i];\n        if (words[i][1] == ' ' && words[i][0] == ' ')\n            break;\n     }\n    n=10;\n    sorted(n,*words);\n}\n\nchar sorted(int n,char *words)   //冒泡排序\n{\n\n    char exwords[n][46];\n    int j,k,nm,fuck;\n    char flag[46];\n    for(j=0;j<n+1;j++)\n       for(k=0;k<46;k++)\n        exwords[j][k] = *(words+46*j+k);\n\n    for(j=0;j<n-1;j++)\n        for(k=0;k<n-1-j;k++)\n            {\n                for(nm=0;nm<46;nm++)\n                    {\n                        if(exwords[k][nm]<exwords[k+1][nm])\n                            break;\n                        if(exwords[k][nm]==exwords[k+1][nm])\n                            continue;\n                        if(exwords[k][nm]>exwords[k+1][nm])\n                           {\n\n                                for(fuck=0;fuck<46;fuck++)\n                                    {\n                                        flag[fuck] = exwords[k][fuck];\n                                        exwords[k][fuck] = exwords[k+1][fuck];\n                                        exwords[k+1][fuck] = flag[fuck];\n                                    }\n                                break;\n                           }\n\n\n\n\n\n\n                    }\n\n\n            }\n\n    for(j=0;j<n+1;j++)\n        cout << exwords[j] <<endl;\n\n\n}\n",
            1587612077.4274936,
            50,
            "In file included from main.cpp:1:0:\nsource.cpp: In function ‘int main()’:\nsource.cpp:19:5: error: ‘n’ was not declared in this scope\n     n=10;\n     ^\n"
        ],
        [
            "1.1 (C++)",
            "王晓龙",
            "class Matrix5x5{\n\t\n\tpublic:\n\tdouble  arr[5][5];\n\tdouble get(int row,int col){\n\t\t\n\t\treturn this->arr[row][col];\n\t}\n\tvoid set(int row ,int col, double value){\n\t\t\n\t\tthis->arr[row][col]=value;\n\t}\n    Matrix5x5 operator + (Matrix5x5 & a){\n\t\tfor (int i = 0; i < 5 ; ++ i){\n\t\t\tfor (int j = 0; j < 5 ; ++ j){\n\t\t\t\ta.arr[i][j] += this->arr[i][j];\n\t\t\t} \n\t\t} \n\t\treturn a;\n\t}\n};\n",
            1587702524.6353219,
            100,
            "# 答案正确"
        ],
        [
            "1.2 (C++)",
            "王晓龙",
            "#include <iostream>\nusing namespace std;\n#include <cstring>\nclass School\n{\n\tpublic:\n\tchar name[10];\n\tint age;\n\tvoid setName( ){\n\t\tSchool school;\n\t\tstrcpy(school.name,name);\n\t}\n\t\t\n\t\t\n    void setAge( ){\n\t\tcin >> this->age;\n\t\t\n\t}\n    void operator ++ ()\n\t{\n\t\t setName();\n\t\t setAge(){\n\t\tcin>>this->age++;\n\t\t}\n\t}\n}\n",
            1588216053.2111967,
            0,
            "In file included from main.cpp:1:0:\nsource.cpp:26:1: error: expected ‘;’ after class definition\n }\n ^\nsource.cpp: In member function ‘void School::operator++()’:\nsource.cpp:22:12: error: expected ‘;’ before ‘{’ token\n    setAge(){\n            ^\nmain.cpp: In function ‘int main()’:\nmain.cpp:15:21: error: no matching function for call to ‘School::setName(char [10])’\n  school.setName(name);\n                     ^\nIn file included from main.cpp:1:0:\nsource.cpp:9:7: note: candidate: void School::setName()\n  void setName( ){\n       ^\nsource.cpp:9:7: note:   candidate expects 0 arguments, 1 provided\nmain.cpp:18:19: error: no matching function for call to ‘School::setAge(int&)’\n  school.setAge(age);\n                   ^\nIn file included from main.cpp:1:0:\nsource.cpp:15:10: note: candidate: void School::setAge()\n     void setAge( ){\n          ^\nsource.cpp:15:10: note:   candidate expects 0 arguments, 1 provided\n"
        ],
        [
            "2020/05/08",
            "王晓龙",
            "double & Tensor_get(int dimensions, int sizes[], double data[], int x0 , int x1 = -1, int x2 = -1, int x3 = -1){\n\tdata[0] = x0;\n\tdata[1] = x1 + data[0] * 10;\n\tdata[2] = x2 + data[1] * 10;\n\tdata[3] = x3 + data[2] * 10;\n\t\n\tif(x1 == -1)return data[0];\n\telse if(x2 == -1)return data[1];\n\telse if(x3 == -1)return data[2];\n\telse return data[3];\n}",
            1588907571.0597131,
            100,
            "# 答案正确"
        ],
        [
            "2.2 (C++)",
            "王晓龙",
            "#include <iostream>\n#include<iomanip>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tdouble mat[40][40];\n\tMatrix(int rows, int columns, double values[]){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tint count = 0;\n\t\tfor (int i = 0; i < rows; ++ i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tmat[i][j] = values[count];\n\t\t\t\t++count;\n\t\t\t}\n\t\t} \n\t}\n\tvoid print(){\n\t\tfor (int i = 0; i < this-> rows; ++ i){\n\t\t\tfor(int j = 0; j < this->columns; ++j){\n\t\t\t\tcout << setw(5) << mat[i][j] ;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t} \n\t}\n\t~Matrix(){\n\t\t\n\t}\n};",
            1589364813.1109781,
            100,
            "# 答案正确"
        ],
        [
            "2.1 (C++)",
            "王晓龙",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix{\n\tprivate:\n\t\tint rows;\n\t\tint columns;\n\t\tdouble * values;\n\tpublic:\n\t\tdouble mat[50][50];\n\t\tMatrix(int rows, int columns){\n\t\t\tthis -> rows = rows;\n\t\t\tthis -> columns = columns;\n\t\t\tfor(int i = 0; i < rows; ++i){\n\t\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\t\tmat [i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvoid print(){\n\t\t\tfor(int i = 0; i < rows; ++i){\n\t\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\t\tcout << mat[i][j] << \"    \";\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t\t~Matrix(){\n\t\t\t\n\t\t}\n};",
            1589364844.8673506,
            100,
            "# 答案正确"
        ],
        [
            "2.3 (C++)",
            "王晓龙",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tdouble mat[10][10];\n\tMatrix(int rows, int columns, double values[]){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tint count = 0;\n\t\tfor (int i = 0; i < rows; ++ i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tmat[i][j] = values[count];\n\t\t\t\t++count;\n\t\t\t}\n\t\t} \n\t}\n\tMatrix(const Matrix & matrix2){\n\t\tthis->rows = matrix2.rows ;\n\t\tthis->columns = matrix2.columns ;\n\t\tfor (int i = 0; i < rows; ++ i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tthis->mat[i][j] = matrix2.mat[i][j] ;\n\t\t\t}\n\t\t} \n\t}\n\tvoid print(){\n\t\tfor(int i = 0; i < rows; ++i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tcout << mat[i][j] << \"    \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\t~Matrix(){\n\t\t\n\t}\n};",
            1589365621.658783,
            100,
            "# 答案正确"
        ],
        [
            "2.5 (C++)",
            "王晓龙",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tdouble mat[50][50];\n\tMatrix(int rows, int columns){\n\t\tthis -> rows = rows;\n\t\tthis -> columns = columns;\n\t\tfor(int i = 0; i < rows; ++i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tmat [i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tMatrix(int rows, int columns, double values[]){\n\t\tint count;\n\t\tthis -> rows = rows;\n\t\tthis -> columns = columns;\n\t\tfor(int i = 0; i < rows; ++i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tcount = i * columns + j;\n\t\t\t\tmat [i][j] = values[count];\n\t\t\t}\n\t\t}\n\t}\n\tvoid print(){\n\t\tfor(int i = 0; i < rows; ++i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tcout << mat[i][j] << \"    \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tMatrix getRow(int row){\n\t\tMatrix matr(1,columns);\n\t\tfor(int i = 0; i < columns; ++i){\n\t\t\tmatr.mat[0][i] = mat[row-1][i];\n\t\t}\n\t\treturn matr;\n\t}\n\tMatrix getColumn(int column){\n\t\tMatrix matr(rows,1);\n\t\tfor(int i = 0; i < rows; ++i){\n\t\t\tmatr.mat[i][0] = mat[i][column-1];\n\t\t}\n\t\treturn matr;\n\t}\n\t~Matrix(){\n\t\t\n\t}\n};",
            1589365794.9591064,
            100,
            "# 答案正确"
        ],
        [
            "2.6 (C++)",
            "王晓龙",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tdouble mat[50][50];\n\tMatrix(int rows, int columns){\n\t\tthis -> rows = rows;\n\t\tthis -> columns = columns;\n\t\tfor(int i = 0; i < rows; ++i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tmat [i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\t  Matrix(int rows, int columns, double values[]){\n\t\tint count;\n\t\tthis -> rows = rows;\n\t\tthis -> columns = columns;\n\t\tfor(int i = 0; i < rows; ++i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tcount = i * columns + j;\n\t\t\t\tmat [i][j] = values[count];\n\t\t\t}\n\t\t}\n\t}\n\t  void print(){\n\t\tfor(int i = 0; i < rows; ++i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tcout << mat[i][j] << \"    \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tMatrix concatenateRows(const Matrix & matrix2) const{\n\t\tMatrix m(this->rows + matrix2.rows,this->columns);\n\t\tfor(int i = 0; i < (this->rows + matrix2.rows); ++i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tif(i < this->rows){\n\t\t\t\t\tm.mat[i][j] = this->mat[i][j];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tm.mat[i][j] = matrix2.mat[i-this->rows][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn m;\n\t}\n\tMatrix concatenateColumns(const Matrix & matrix2) const{\n\t\tMatrix m(this->rows ,this->columns + matrix2.columns);\n\t\tfor(int i = 0; i < this->rows; ++i){\n\t\t\tfor(int j = 0; j < (columns+ matrix2.columns); ++j){\n\t\t\t\tif(j < this->columns){\n\t\t\t\t\tm.mat[i][j] = this->mat[i][j];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tm.mat[i][j] = matrix2.mat[i][j - this->columns];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn m;\n\t}\n\t~Matrix(){\n\t\t\n\t}\n};",
            1589366238.4138637,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/14",
            "王晓龙",
            "#include <iostream>\nusing namespace std;\nvoid Tensor_print(int dimensions, const int sizes[4], const double data[]){\n\tint h;\n\tint j;\n\tint i;\n\tint k;\n\t\n\tif(dimensions == 1){\n\t\tcout << \"Tensor of \" << sizes[0] << endl;\n\t\tfor (i = 0; i < sizes[0]; ++i) {\n\t\t\tcout << data[i] << endl;\n\t\t}\n\t}\n\t\n\t\n\telse if(dimensions == 2){\n\t\tcout << \"Tensor of \" << sizes[0] << \"x\" << sizes[1] << endl;\n\t\tfor (i = 0; i < sizes[0]; ++i){\n\t\t\tfor(j = 0; j < sizes[1]; ++j){\n\t\t\t  cout << \"    \" << data[i*sizes[1] + j] ;\n\t\t\t}\n\t\t\t  cout << endl;\n\t\t} \n\t}\n\t\n\t\n\telse if(dimensions == 3){\n\t\tcout << \"Tensor of \" << sizes[0] << \"x\" << sizes[1] << \"x\" << sizes[2] << endl;\n\t\tfor ( i = 0; i < sizes[0]; ++i ) {\n\t\t\tcout << \"data[\" << i << \"]\" << endl;  \n\t\t\tfor( j = 0; j < sizes[1]; ++j){\n\t\t\t\tfor(k = 0; k < sizes[2]; ++k){\n\t\t\t\t\tcout << \"    \" << data[0] ;\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\telse{\n\t\tcout << \"Tensor of \" <<sizes[0] << \"x\" <<sizes[1] <<\"x\"<<sizes[2]<<\"x\"<<sizes[3] << endl;\n\t\tfor(h = 0; h < sizes[0]; ++h){\n\t\t\tfor (i = 0; i < sizes[1]; ++i) {\n\t\t\t\tcout << \"data[\" << h << \"]\" << \"[\" << i << \"]\" <<endl;\n\t\t\t\tfor(j = 0; j < sizes[2]; ++j){\n\t\t\t\t\tfor(k = 0; k < sizes[3]; ++k){\n\t\t\t\t\t\tcout << \"    \"<< data[0] ;\n\t\t\t\t\t}\n\t\t\t\t\tcout << endl;\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\n\t\t}\n\t\t\n\t}\n}",
            1589427438.4649374,
            62,
            "# 答案不正确\n\n# 随机输入:\n5.3\n9.4\n5.7\n2.4\n\n\n# 参考答案:\nTensor of 5\n5.3\n5.3\n5.3\n5.3\n5.3\n\nTensor of 3x4\n    9.4    9.4    9.4    9.4\n    9.4    9.4    9.4    9.4\n    9.4    9.4    9.4    9.4\n\nTensor of 3x4x5\ndata[0]\n    5.7    5.7    5.7    5.7    5.7\n    5.7    5.7    5.7    5.7    5.7\n    5.7    5.7    5.7    5.7    5.7\n    5.7    5.7    5.7    5.7    5.7\ndata[1]\n    5.7    5.7    5.7    5.7    5.7\n    5.7    5.7    5.7    5.7    5.7\n    5.7    5.7    5.7    5.7    5.7\n    5.7    5.7    5.7    5.7    5.7\ndata[2]\n    5.7    5.7    5.7    5.7    5.7\n    5.7    5.7    5.7    5.7    5.7\n    5.7    5.7    5.7    5.7    5.7\n    5.7    5.7    5.7    5.7    5.7\n\nTensor of 2x3x4x5\ndata[0][0]\n    2.4    2.4    2.4    2.4    2.4\n    2.4    2.4    2.4    2.4    2.4\n    2.4    2.4    2.4    2.4    2.4\n    2.4    2.4    2.4    2.4    2.4\ndata[0][1]\n    2.4    2.4    2.4    2.4    2.4\n    2.4    2.4    2.4    2.4    2.4\n    2.4    2.4    2.4    2.4    2.4\n    2.4    2.4    2.4    2.4    2.4\ndata[0][2]\n    2.4    2.4    2.4    2.4    2.4\n    2.4    2.4    2.4    2.4    2.4\n    2.4    2.4    2.4    2.4    2.4\n    2.4    2.4    2.4    2.4    2.4\ndata[1][0]\n    2.4    2.4    2.4    2.4    2.4\n    2.4    2.4    2.4    2.4    2.4\n    2.4    2.4    2.4    2.4    2.4\n    2.4    2.4    2.4    2.4    2.4\ndata[1][1]\n    2.4    2.4    2.4    2.4    2.4\n    2.4    2.4    2.4    2.4    2.4\n    2.4    2.4    2.4    2.4    2.4\n    2.4    2.4    2.4    2.4    2.4\ndata[1][2]\n    2.4    2.4    2.4    2.4    2.4\n    2.4    2.4    2.4    2.4    2.4\n    2.4    2.4    2.4    2.4    2.4\n    2.4    2.4    2.4    2.4    2.4\n\n\n# 我的答案:\nTensor of 5\n5.3\n5.3\n5.3\n5.3\n5.3\n\nTensor of 3x4\n    9.4    9.4    9.4    9.4\n    9.4    9.4    9.4    9.4\n    9.4    9.4    9.4    9.4\n\nTensor of 3x4x5\ndata[0]\n    5.7    5.7    5.7    5.7    5.7\n    5.7    5.7    5.7    5.7    5.7\n    5.7    5.7    5.7    5.7    5.7\n    5.7    5.7    5.7    5.7    5.7\n\ndata[1]\n    5.7    5.7    5.7    5.7    5.7\n    5.7    5.7    5.7    5.7    5.7\n    5.7    5.7    5.7    5.7    5.7\n    5.7    5.7    5.7    5.7    5.7\n\ndata[2]\n    5.7    5.7    5.7    5.7    5.7\n    5.7    5.7    5.7    5.7    5.7\n    5.7    5.7    5.7    5.7    5.7\n    5.7    5.7    5.7    5.7    5.7\n\n\nTensor of 2x3x4x5\ndata[0][0]\n    2.4    2.4    2.4    2.4    2.4\n    2.4    2.4    2.4    2.4    2.4\n    2.4    2.4    2.4    2.4    2.4\n    2.4    2.4    2.4    2.4    2.4\n\ndata[0][1]\n    2.4    2.4    2.4    2.4    2.4\n    2.4    2.4    2.4    2.4    2.4\n    2.4    2.4    2.4    2.4    2.4\n    2.4    2.4    2.4    2.4    2.4\n\ndata[0][2]\n    2.4    2.4    2.4    2.4    2.4\n    2.4    2.4    2.4    2.4    2.4\n    2.4    2.4    2.4    2.4    2.4\n    2.4    2.4    2.4    2.4    2.4\n\ndata[1][0]\n    2.4    2.4    2.4    2.4    2.4\n    2.4    2.4    2.4    2.4    2.4\n    2.4    2.4    2.4    2.4    2.4\n    2.4    2.4    2.4    2.4    2.4\n\ndata[1][1]\n    2.4    2.4    2.4    2.4    2.4\n    2.4    2.4    2.4    2.4    2.4\n    2.4    2.4    2.4    2.4    2.4\n    2.4    2.4    2.4    2.4    2.4\n\ndata[1][2]\n    2.4    2.4    2.4    2.4    2.4\n    2.4    2.4    2.4    2.4    2.4\n    2.4    2.4    2.4    2.4    2.4\n    2.4    2.4    2.4    2.4    2.4\n\n"
        ],
        [
            "2.4 (C++)",
            "王晓龙",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tdouble mat[10][10];\n\tMatrix(int rows, int columns){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tfor (int i = 0; i < rows; ++ i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tmat[i][j] = 0;\n\t\t\t}\n\t\t} \n\t}\n\tMatrix(int rows, int columns, double values[]){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tint count = 0;\n\t\tfor (int i = 0; i < rows; ++ i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tmat[i][j] = values[count];\n\t\t\t\t++count;\n\t\t\t}\n\t\t} \n\t}\n\tvoid set(int row, int column, double value){\n\t\tmat[row-1][column-1] = value;\n\t}\n\tvoid print(){\n\t\tfor(int i = 0; i < rows; ++i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tcout << mat[i][j] << \"    \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\t~Matrix(){\n\t\t\n\t}\n};",
            1589973415.5000968,
            100,
            "# 答案正确"
        ],
        [
            "2.7 (C++)",
            "王晓龙",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tdouble arr[25][25];\n\tMatrix(int rows, int columns){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tfor (int i = 0; i < rows; ++ i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tarr[i][j] = 0;\n\t\t\t}\n\t\t} \n\t}\n\tMatrix(int rows, int columns, double values[]){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tint flag = 0;\n\t\tfor (int i = 0; i < rows; ++ i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tarr[i][j] = values[flag];\n\t\t\t\t++flag;\n\t\t\t}\n\t\t} \n\t}\n\tMatrix(const Matrix & matrix2){\n\t\tthis->rows = matrix2.rows;\n\t\tthis->columns = matrix2.columns;\n\t\tfor (int i = 0; i < rows; ++ i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\t this->arr[i][j]= matrix2.arr[i][j];\n\t\t\t}\n\t\t} \n\t}\n\tvoid print(){\n\t\tfor(int i = 0; i < rows; ++i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tcout << \"    \" << arr[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tMatrix reshape(int rows, int columns)const{\n\t\tMatrix mat(rows,columns);\n\t\tdouble arr1[100];\n\t\tint flag = 0;\n\t\tfor(int i = 0; i < this->columns; ++i){\n\t\t\tfor(int j = 0; j < this-> rows; ++j){\n\t\t\t\tarr1[flag] = arr[j][i];\n\t\t\t\t++flag;\n\t\t\t}\n\t\t}\n\t\tflag = 0;\n\t\tfor(int i = 0; i < columns; ++i){\n\t\t\tfor(int j = 0; j < rows; ++j){\n\t\t\t\tmat.arr[j][i] = arr1[flag];\n\t\t\t\t++flag;\n\t\t\t}\n\t\t}\n\t\treturn mat;\n\t}\n\t~Matrix(){\n\t\t\n\t}\n};",
            1590059849.373195,
            100,
            "# 答案正确"
        ],
        [
            "2.8 (C++)",
            "王晓龙",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tdouble mat[10][10];\n\tMatrix(int rows, int columns){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tfor (int i = 0; i < rows; ++ i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tmat[i][j] = 0;\n\t\t\t}\n\t\t} \n\t}\n\tMatrix(int rows, int columns, double values[]){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tint count = 0;\n\t\tfor (int i = 0; i < rows; ++ i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tmat[i][j] = values[count];\n\t\t\t\t++count;\n\t\t\t}\n\t\t} \n\t}\n\tvoid set(int row, int column, double value){\n\t\tmat[row-1][column-1] = value;\n\t}\n\tvoid print(){\n\t\tfor(int i = 0; i < rows; ++i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tcout << mat[i][j] << \"    \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t\n\t}\nMatrix transpose( )\n{\n  for(int i = 0; i < columns; ++i){\n\t\t\tfor(int j = 0; j < rows; ++j){\n\t\t\t\tcout << mat[j][i] << \"    \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n}\n\t~Matrix(){\n\t\t\n\t}\n};",
            1589976820.038205,
            100,
            "# 答案正确"
        ],
        [
            "2.9 (C++)",
            "王晓龙",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tdouble arr[25][25];\n\tMatrix(int rows, int columns){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tfor (int i = 0; i < rows; ++ i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tarr[i][j] = 0;\n\t\t\t}\n\t\t} \n\t}\n\tMatrix(int rows, int columns, double values[]){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tint flag = 0;\n\t\tfor (int i = 0; i < rows; ++ i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tarr[i][j] = values[flag];\n\t\t\t\t++flag;\n\t\t\t}\n\t\t} \n\t}\n\tMatrix(const Matrix & matrix2){\n\t\tthis->rows = matrix2.rows;\n\t\tthis->columns = matrix2.columns;\n\t\tfor (int i = 0; i < rows; ++ i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tthis->arr[i][j]= matrix2.arr[i][j];\n\t\t\t}\n\t\t} \n\t}\n\tvoid print(){\n\t\tfor(int i = 0; i < rows; ++i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tcout << arr[i][j] << \"    \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tMatrix operator + (const Matrix & matrix2) const{\n\t\tMatrix mat(rows,columns);\n\t\tfor(int i = 0; i < rows; ++i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tmat.arr[i][j] = this->arr[i][j] + matrix2.arr[i][j];\n\t\t\t}\n\t\t}\n\t\treturn mat;\n\t}\n\tMatrix operator - (const Matrix & matrix2) const{\n\t\tMatrix mat(rows,columns);\n\t\tfor(int i = 0; i < rows; ++i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tmat.arr[i][j] = this->arr[i][j] - matrix2.arr[i][j];\n\t\t\t}\n\t\t}\n\t\treturn mat;\n\t}\n\tMatrix operator + (double value) const{\n\t\tMatrix mat(rows,columns);\n\t\tfor(int i = 0; i < rows; ++i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tmat.arr[i][j] = this->arr[i][j] + value;\n\t\t\t}\n\t\t}\n\t\treturn mat;\n\t}\n\tMatrix operator - (double value) const{\n\t\tMatrix mat(rows,columns);\n\t\tfor(int i = 0; i < rows; ++i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tmat.arr[i][j] = this->arr[i][j] - value;\n\t\t\t}\n\t\t}\n\t\treturn mat;\n\t}\n\t~Matrix(){\n\t\t\n\t}\n};\n",
            1590030741.8338253,
            100,
            "# 答案正确"
        ],
        [
            "2.10 (C++)",
            "王晓龙",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tdouble arr[25][25];\n\tMatrix(int rows, int columns){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tfor (int i = 0; i < rows; ++ i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tarr[i][j] = 0;\n\t\t\t}\n\t\t} \n\t}\n\tMatrix(int rows, int columns, double values[]){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tint flag = 0;\n\t\tfor (int i = 0; i < rows; ++ i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tarr[i][j] = values[flag];\n\t\t\t\t++flag;\n\t\t\t}\n\t\t} \n\t}\n\tMatrix(const Matrix & matrix2){\n\t\tthis->rows = matrix2.rows;\n\t\tthis->columns = matrix2.columns;\n\t\tfor (int i = 0; i < rows; ++ i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\t this->arr[i][j]= matrix2.arr[i][j];\n\t\t\t}\n\t\t} \n\t}\n\tvoid print(){\n\t\tfor(int i = 0; i < rows; ++i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tcout << \"    \" << arr[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tMatrix operator * (const Matrix & matrix2) const{\n\t\tMatrix mat(this->rows, matrix2.columns);\n\t\tfor(int i = 0; i < this->rows; ++i){\n\t\t\tfor(int j = 0; j < matrix2.columns; ++j){\n\t\t\t\tdouble sum = 0;\n\t\t\t\tfor(int k = 0; k < this->columns; ++k){\n\t\t\t\t\tsum = sum + this->arr[i][k] * matrix2.arr[k][j];\n\t\t\t\t}\n\t\t\t\tmat.arr[i][j] = sum;\n\t\t\t}\n\t\t}\n\t\treturn mat;\n\t}\n\tMatrix operator * (double value) const{\n\t\tMatrix mat(this->rows,this->columns);\n\t\tfor(int i = 0; i < rows;++i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tmat.arr[i][j] = this->arr[i][j] * value;\n\t\t\t}\n\t\t}\n\t\treturn mat;\n\t}\n\t~Matrix(){\n\t\t\n\t}\n};",
            1590060275.3989482,
            100,
            "# 答案正确"
        ],
        [
            "2.11 (C++)",
            "王晓龙",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tdouble arr[25][25];\n\tMatrix(int rows, int columns){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tfor (int i = 0; i < rows; ++ i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tarr[i][j] = 0;\n\t\t\t}\n\t\t} \n\t}\n\tMatrix(int rows, int columns, double values[]){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tint flag = 0;\n\t\tfor (int i = 0; i < rows; ++ i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tarr[i][j] = values[flag];\n\t\t\t\t++flag;\n\t\t\t}\n\t\t} \n\t}\n\tMatrix(const Matrix & matrix2){\n\t\tthis->rows = matrix2.rows;\n\t\tthis->columns = matrix2.columns;\n\t\tfor (int i = 0; i < rows; ++ i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\t this->arr[i][j]= matrix2.arr[i][j];\n\t\t\t}\n\t\t} \n\t}\n\tvoid print(){\n\t\tfor(int i = 0; i < rows; ++i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tcout << \"    \" << arr[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tMatrix max() const{\n\t\tif(this->rows == 1){\n\t\t\tMatrix mat(1,1);\n\t\t\tdouble max = 0;\n\t\t\tfor(int i = 0; i < this->columns; ++i){\n\t\t\t\tif(this->arr[0][i] > max)max = this->arr[0][i];\n\t\t\t}\n\t\t\tmat.arr[0][0] = max;\n\t\t\treturn mat;\n\t\t}\n\t\telse{\n\t\t\tMatrix mat(1,this->columns);\n\t\t\tfor(int i = 0; i < columns; ++i){\n\t\t\t\tdouble max = 0;\n\t\t\t\tfor(int j = 0; j < this-> rows; ++j){\n\t\t\t\t\tif(this->arr[j][i] > max)max = this->arr[j][i];\n\t\t\t\t}\n\t\t\t\tmat.arr[0][i] = max;\n\t\t\t}\n\t\t\treturn mat;\n\t\t}\n\t}\n\tMatrix min() const{\n\t\tif(this->rows == 1){\n\t\t\tMatrix mat(1,1);\n\t\t\tdouble min = 10000;\n\t\t\tfor(int i = 0; i < this->columns; ++i){\n\t\t\t\tif(this->arr[0][i] < min)min = this->arr[0][i];\n\t\t\t}\n\t\t\tmat.arr[0][0] = min;\n\t\t\treturn mat;\n\t\t}\n\t\telse{\n\t\t\tMatrix mat(1,this->columns);\n\t\t\tfor(int i = 0; i < columns; ++i){\n\t\t\t\tdouble min = 10000;\n\t\t\t\tfor(int j = 0; j < this-> rows; ++j){\n\t\t\t\t\tif(this->arr[j][i] < min)min = this->arr[j][i];\n\t\t\t\t}\n\t\t\t\tmat.arr[0][i] = min;\n\t\t\t}\n\t\t\treturn mat;\n\t\t}\n\t}\n\tMatrix sum() const{\n\t\tif(this->rows == 1){\n\t\t\tMatrix mat(1,1);\n\t\t\tdouble sum = 0;\n\t\t\tfor(int i = 0; i < this->columns; ++i){\n\t\t\t\tsum = sum + this->arr[0][i];\n\t\t\t}\n\t\t\tmat.arr[0][0] = sum;\n\t\t\treturn mat;\n\t\t}\n\t\telse{\n\t\t\tMatrix mat(1,this->columns);\n\t\t\tfor(int i = 0; i < columns; ++i){\n\t\t\t\tdouble sum = 0;\n\t\t\t\tfor(int j = 0; j < this-> rows; ++j){\n\t\t\t\t\tsum = sum + this->arr[j][i];\n\t\t\t\t}\n\t\t\t\tmat.arr[0][i] = sum;\n\t\t\t}\n\t\t\treturn mat;\n\t\t}\n\t}\n\t~Matrix(){\n\t\t\n\t}\n};",
            1590060761.9019818,
            100,
            "# 答案正确"
        ],
        [
            "2.12 (C++)",
            "王晓龙",
            "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tdouble arr[25][25];\n\tMatrix(int rows, int columns){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tfor (int i = 0; i < rows; ++ i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tarr[i][j] = 0;\n\t\t\t}\n\t\t} \n\t}\n\tMatrix(int rows, int columns, double values[]){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tint flag = 0;\n\t\tfor (int i = 0; i < rows; ++ i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tarr[i][j] = values[flag];\n\t\t\t\t++flag;\n\t\t\t}\n\t\t} \n\t}\n\tMatrix(const Matrix & matrix2){\n\t\tthis->rows = matrix2.rows;\n\t\tthis->columns = matrix2.columns;\n\t\tfor (int i = 0; i < rows; ++ i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\t this->arr[i][j]= matrix2.arr[i][j];\n\t\t\t}\n\t\t} \n\t}\n\tvoid print(){\n\t\tfor(int i = 0; i < rows; ++i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tcout << \"    \" << arr[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tMatrix pow(double exponent){\n\t\tMatrix mat(this->rows,this->columns);\n\t\tfor(int i = 0; i < this->rows; ++i){\n\t\t\tfor(int j = 0; j < this->columns; ++j){\n\t\t\t\tdouble value;\n\t\t\t\tmat.arr[i][j] = std:: pow(this->arr[i][j],exponent);\n\t\t\t}\n\t\t}\n\t\treturn mat;\n\t}\n\tMatrix exp(){\n\t\tMatrix mat(this->rows,this->columns);\n\t\tfor(int i = 0; i < this->rows; ++i){\n\t\t\tfor(int j = 0; j < this->columns; ++j){\n\t\t\t\tdouble value;\n\t\t\t\tmat.arr[i][j] = std:: exp(this->arr[i][j]);\n\t\t\t}\n\t\t}\n\t\treturn mat;\n\t}\n\tMatrix log(){\n\t\tMatrix mat(this->rows,this->columns);\n\t\tfor(int i = 0; i < this->rows; ++i){\n\t\t\tfor(int j = 0; j < this->columns; ++j){\n\t\t\t\tdouble value;\n\t\t\t\tmat.arr[i][j] = std:: log(this->arr[i][j]);\n\t\t\t}\n\t\t}\n\t\treturn mat;\n\t}\n\tMatrix abs(){\n\t\tMatrix mat(this->rows,this->columns);\n\t\tfor(int i = 0; i < this->rows; ++i){\n\t\t\tfor(int j = 0; j < this->columns; ++j){\n\t\t\t\tdouble value;\n\t\t\t\tmat.arr[i][j] = std:: abs(this->arr[i][j]);\n\t\t\t}\n\t\t}\n\t\treturn mat;\n\t}\n\t~Matrix(){\n\t\t\n\t}\n};",
            1590060992.5851312,
            100,
            "# 答案正确"
        ],
        [
            "6.2 (C++)",
            "王晓龙",
            "#include <iostream>\nusing namespace std;\ntemplate<typename T>\nclass Matrix{\nprivate:\n\tint rows;\n\tint columns;\n\tT * values;\npublic:\n\tT mt[25][25];\n\tMatrix(int rows, int columns){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tfor (int i = 0; i < rows; ++ i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tmt[i][j] = 0;\n\t\t\t}\n\t\t} \n\t}\n\tvoid print(){\n\t\tfor (int i = 0; i < rows; ++ i){\n\t\t\tfor(int j = 0; j < columns; ++j){\n\t\t\t\tcout << \"    \"<<mt[i][j] ;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t} \n\t}\n\t~Matrix(){\n\t\t\n\t}\n};",
            1590636144.1767652,
            100,
            "# 答案正确"
        ],
        [
            "7.2 (C++)",
            "王晓龙",
            "//#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n split(const string & line){\n\tvector<string> words;\n\tint start = 0;\n\tstring a = \" \";\n\twhile(start < line.size()){\n\t\tint count = 0;\n\t\tint end = line.find(a, start);\n\t\tif(start == end){\n\t\t\t++start;\n\t\t}\n\t\telse{\n\t\t\tif(end == -1){\n\t\t\t\twords[count] = line.substr(start);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twords[count] = line.substr(start,end-start);\n\t\t\t++count;\n\t\t\tstart = end + a.size();\n\t\t}\n\t\t\n\t}\n\treturn words;\n}",
            1591241977.3086584,
            0,
            "In file included from main.cpp:1:0:\nsource.cpp:6:27: error: ISO C++ forbids declaration of ‘split’ with no type [-fpermissive]\n  split(const string & line){\n                           ^\nsource.cpp: In function ‘int split(const string&)’:\nsource.cpp:27:9: error: cannot convert ‘std::vector<std::__cxx11::basic_string<char> >’ to ‘int’ in return\n  return words;\n         ^\nmain.cpp: In function ‘void test()’:\nmain.cpp:10:30: error: conversion from ‘int’ to non-scalar type ‘std::vector<std::__cxx11::basic_string<char> >’ requested\n  vector<string> words = split(line);\n                              ^\n"
        ],
        [
            "7.1 (C++)",
            "王晓龙",
            "#include <cmath>\nusing namespace std;\n\nclass Triangle : public GeometricObject\n{\nprivate:\n\tdouble side1;\n\tdouble side2;\n\tdouble side3;\npublic:\n\tTriangle(){\n\t\tside1 = side2 = side3 = 1.0;\n\t}\n\tTriangle(double a, double b, double c){\n\t\tside1 = a;\n\t\tside2 = b;\n\t\tside3 = c;\n\t}\n\tdouble getSide1(){\n\t\treturn side1;\n\t}\n\tdouble getSide2(){\n\t\treturn side2;\n\t}\n\tdouble getSide3(){\n\t\treturn side3;\n\t}\n\tdouble getArea(){\n\t\tdouble s = (side1 + side2 + side3) / 2;\n\t\treturn sqrt(s * (s - side1) * (s - side2) * (s - side3));\n\t}\n\tdouble getPerimeter(){\n\t\treturn side1+side2+side3;\n\t}\n};\n\n",
            1591242075.0561945,
            100,
            "# 答案正确"
        ],
        [
            "7.3 (C++)",
            "王晓龙",
            "template <typename A>\nvector<A> map2(const vector<A> & x, const vector<A> &y, A (*map_func)(const A &, const A &)){\n\tvector<A>res ;\n\tfor (int i = 0; i < x.size(); ++ i){\n\t\tres.push_back(map_func(x[i],y[i]));\n\t} \n\treturn res;\n}\ntemplate <typename A>\nvector<A> map2(const vector<A> & x, int y, A (*map_func)(const A &, const A &)){\n\tvector<A>res ;\n\tfor (int i = 0; i < x.size(); ++ i){\n\t\tres.push_back(map_func(x[i],y));\n\t} \n\treturn res;\n}\n",
            1591242214.8290725,
            100,
            "# 答案正确"
        ],
        [
            "8.5 (C++)",
            "王晓龙",
            "#include <cmath>\nclass Point3D: public Point2D\n{\nprivate:\n\tdouble z;\npublic:\n\tPoint3D(){\n\t\tsetX(0);\n\t\tsetY(0);\n\t\tz = 0;\n\t}\n\tPoint3D(double a, double b, double c){\n\t\tsetX(a);\n\t\tsetY(b);\n\t\tz = c;\n\t}\n\tdouble getZ(){\n\t\treturn z;\n\t}\n\tdouble distance(Point2D & point2){\n\t\tPoint3D & a = dynamic_cast<Point3D &> (point2);\n\t\tdouble dx, dy, dz;\n\t\tdx = getX() - a.getX();\n\t\tdy = getY() - a.getY();\n\t\tdz = this->z - a.getZ();\n\t\treturn sqrt(dx * dx + dy * dy + dz * dz);\n\t}\n};",
            1591846786.947143,
            100,
            "# 答案正确"
        ],
        [
            "8.1 (C++)",
            "王晓龙",
            "#include<bits/stdc++.h>\nusing namespace std;\nclass Full: public Matrix\n{\nprivate:\n\tint rows;\n\tint column;\n\tdouble * values;\npublic:\n\tFull(int rows, int column){\n\t\tthis->rows = rows;\n\t\tthis->column = column;\n\t\tthis->values = new double[rows*column+1];\n\t\tfor(int i = 0; i < rows*column; ++i){\n\t\t\tthis->values[i] = 0;\n\t\t}\n\t}\n\tFull(int rows, int column, double values[]){\n\t\tthis->rows = rows;\n\t\tthis->column = column;\n\t\tthis->values = new double[rows*column+1];\n\t\tfor(int i = 0; i < rows*column; ++i){\n\t\t\tthis->values[i] = values[i];\n\t\t}\n\t}\n\tFull(const Matrix & matrix2){\n\t\tthis->rows = matrix2.size(1);\n\t\tthis->column = matrix2.size(2);\n\t\tthis->values = new double[rows*column+1];\n\t\tfor(int i = 0; i < rows; ++i){\n\t\t\tfor(int j = 0; j < column; ++j){\n\t\t\t\tthis->values[i*column+j] = matrix2.get(i,j);\n\t\t\t}\n\t\t}\n\t}\n\t~Full(){\n\t\tdelete []this->values;\n\t}\n\tint size(int dimension) const{\n\t\tif(dimension == 1)return rows;\n\t\telse return column;\n\t}\n\tvoid set(int row, int column, double value){\n\t\tthis->values[(row-1)*this->column + column-1] = value;\n\t}\n\tdouble get(int row, int column) const{\n\t\treturn this->values[row*this->column + column];\n\t}\n\tvoid print() {\n\t\tint count = 0;\n\t\tfor(int i = 0; i < rows; ++i){\n\t\t\tfor(int j = 0; j < column; ++j){\n\t\t\t\tcout << \"    \" <<values[count];\n\t\t\t\t++count;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tvoid print() const{\n\t\tint count = 0;\n\t\tfor(int i = 0; i < rows; ++i){\n\t\t\tfor(int j = 0; j < column; ++j){\n\t\t\t\tcout << \"    \" <<values[count];\n\t\t\t\t++count;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tMatrix & operator = (const Matrix & matrix2){\n\t\tif(this->values){\n\t\t\tdelete []values;\n\t\t}\n\t\tthis->rows = matrix2.size(1);\n\t\tthis->column = matrix2.size(2);\n\t\tthis->values = new double[rows*column+1];\n\t\tfor(int i = 0; i < rows; ++i){\n\t\t\tfor(int j = 0; j < column; ++j){\n\t\t\t\tthis->values[i*column+j] = matrix2.get(i,j);\n\t\t\t}\n\t\t}\n\t\treturn *this;\n\t}\n};",
            1591873781.032863,
            100,
            "# 答案正确"
        ],
        [
            "8.3 (C++)",
            "王晓龙",
            "#include <iostream>\n#include<vector>\nusing namespace std;\n\nclass Sparse: public Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tvector<Entry> values;\npublic:\n\tSparse(int rows, int columns){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t}\n\tint size(int dimension) const{\n\t\tif(dimension == 1)return rows;\n\t\telse return columns;\n\t}\n\tvoid set(int row, int column, double value){\n\t\t\tEntry *a = new Entry;\t\n\t\t\ta[0].row = row;\n\t\t\ta[0].column = column;\n\t\t\ta[0].value = value;\n\t\t\tthis->values.push_back(a[0]);\n\t\t\tdelete a;\n\t}\n\tdouble get(int row, int column) const{\n\t\tint i = 0;\n\t\twhile(i < this->values.size()){\n\t\t\tif(values[i].row == row && values[i].column == column){\n\t\t\t\treturn values[i].value;\n\t\t\t}\n\t\t\t++i;\n\t\t}\n\t\treturn 0;\n\t}\n\tvoid print(){\n\t\tint i = 0;\n\t\twhile(i <  this->values.size()){\n\t\t\tfor(int j = i + 1; j < this->values.size(); ++j){\n\t\t\t\tif(values[i].row > values[j].row){\n\t\t\t\t\tswap(this->values[i],this->values[j]);\n\t\t\t\t}\n\t\t\t\telse if(values[i].row == values[j].row){\n\t\t\t\t\tif(values[i].column > values[j].column){\n\t\t\t\t\t\tswap(this->values[i],this->values[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t++i;\n\t\t}\n\t\ti = 0;\n\t\twhile(i < this->values.size() ){\n\t\t\tcout << \"(\" << values[i].row << \",\" << values[i].column << \",\" << values[i].value << \")\" << endl;\n\t\t\t++i;\n\t\t}\n\t}\n\tSparse & operator + (Sparse & sparse2){\n\t\tint len1 = this->values.size();\n\t\tint len2 = sparse2.values.size();\n\t\tint c = len1;\n\t\tfor(int i = 0; i < len2; ++i){\n\t\t\tint flag = 0;\n\t\t\tfor(int j = 0; j < len1; ++j){\n\t\t\t\tif(sparse2.values[i].row == this->values[j].row && sparse2.values[i].column == this->values[j].column){\n\t\t\t\t\tif(this->values[j].value + sparse2.values[i].value == 0){\n\t\t\t\t\t\tthis->values.erase(this->values.begin()+j);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tthis->values[j].value = this->values[j].value + sparse2.values[i].value;\n\t\t\t\t\t}\n\t\t\t\t\tflag = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag == 0){\n\t\t\t\tset(sparse2.values[i].row,sparse2.values[i].column,sparse2.values[i].value);\n\t\t\t}\n\t\t}\n\t\treturn *this;\n\t}\n};",
            1591873936.7042584,
            100,
            "# 答案正确"
        ],
        [
            "8.4 (C++)",
            "王晓龙",
            "#include <iostream>\n#include<vector>\nusing namespace std;\n\nclass Sparse: public Matrix\n{\nprivate:\n\tint rows;\n\tint columns;\n\tvector<Entry> values;\npublic:\n\tSparse(int rows, int columns){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t}\n\tint size(int dimension) const{\n\t\tif(dimension == 1)return rows;\n\t\telse return columns;\n\t}\n\tvoid set(int row, int column, double value){\n\t\t\tEntry *a = new Entry;\t\n\t\t\ta[0].row = row;\n\t\t\ta[0].column = column;\n\t\t\ta[0].value = value;\n\t\t\tthis->values.push_back(a[0]);\n\t\t\tdelete a;\n\t}\n\tdouble get(int row, int column) const{\n\t\tint i = 0;\n\t\twhile(i < this->values.size()){\n\t\t\tif(values[i].row == row && values[i].column == column){\n\t\t\t\treturn values[i].value;\n\t\t\t}\n\t\t\t++i;\n\t\t}\n\t\treturn 0;\n\t}\n\tint getp(int row, int column){\n\t\tint i = 0;\n\t\twhile(i < this->values.size()){\n\t\t\tif(values[i].row == row && values[i].column == column){\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\t++i;\n\t\t}\n\t\treturn -1;\n\t}\n\tvoid print(){\n\t\tint i = 0;\n\t\twhile(i <  this->values.size()){\n\t\t\tfor(int j = i + 1; j < this->values.size(); ++j){\n\t\t\t\tif(values[i].row > values[j].row){\n\t\t\t\t\tswap(this->values[i],this->values[j]);\n\t\t\t\t}\n\t\t\t\telse if(values[i].row == values[j].row){\n\t\t\t\t\tif(values[i].column > values[j].column){\n\t\t\t\t\t\tswap(this->values[i],this->values[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t++i;\n\t\t}\n\t\ti = 0;\n\t\twhile(i < this->values.size() ){\n\t\t\tcout << \"(\" << values[i].row << \",\" << values[i].column << \",\" << values[i].value << \")\" << endl;\n\t\t\t++i;\n\t\t}\n\t}\n\tSparse & operator * (Sparse & sparse2){\n\t\tvector<Entry> ans;\n\t\tint len1 = this->values.size();\n\t\tint len2 = sparse2.values.size();\n\t\tint i = 0;\n\t\tfor(int i = 0; i < len1; ++i){\n\t\t\tfor(int j = 0; j < len2; ++j){\n\t\t\t\tint f = this->values[i].row;\n\t\t\t\tint b = this->values[i].column;\n\t\t\t\tdouble c = this->values[i].value;\n\t\t\t\tif(b == sparse2.values[j].row){\n\t\t\t\t\tdouble sum = this->values[i].value * sparse2.values[j].value;\n\t\t\t\t\tint flag = 0;\n\t\t\t\t\tint k = 0;\n\t\t\t\t\twhile(k < ans.size()){\n\t\t\t\t\t\tif(ans[k].row == f && ans[k].column == sparse2.values[j].column){\n\t\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t++k;\n\t\t\t\t\t}\n\t\t\t\t\tif(flag == 1){\n\t\t\t\t\t\tans[k].value = ans[k].value + sum;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tEntry *a = new Entry;\t\n\t\t\t\t\t\ta[0].row = f;\n\t\t\t\t\t\ta[0].column = sparse2.values[j].column;\n\t\t\t\t\t\ta[0].value = sum;\n\t\t\t\t\t\tans.push_back(a[0]);\n\t\t\t\t\t\tdelete a;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tthis->values = ans;\n\t\treturn *this;\n\t}\n};",
            1591874017.643843,
            100,
            "# 答案正确"
        ],
        [
            "8.6 (C++)",
            "王晓龙",
            "#include<vector>\n#include<iostream>\nusing namespace std;\nclass MyTensor : public Tensor<double>\n{\nprivate:\n    vector<double> cap;\n\npublic:\n    MyTensor(vector<int> indexes) : Tensor(indexes)\n    {\n        int num = 1;\n        for (int i = 0; i < indexes.size(); i++)\n        {\n            num *= indexes[i];\n        }\n        cap.resize(num);\n    }\n    ~MyTensor(){};\n    double &get(const vector<int> &indexes)\n    {\n        int pos = 0;\n        for (int i = 0; i < indexes.size(); i++)\n        {\n            if (i == indexes.size() - 1)\n            {\n                pos += indexes[i];\n                break;\n            }\n            int temp = indexes[i];\n            for (int j = i + 1; j < indexes.size(); j++)\n            {\n                temp *= sizes[j];\n            }\n            pos += temp;\n        }\n        return cap[pos];\n    }\n};",
            1592451445.0922644,
            100,
            "# 答案正确"
        ],
        [
            "9.1 (C++)",
            "王晓龙",
            "#include <iostream>\nusing namespace std;\nclass Circle{\nprivate:\n\tdouble r;\npublic:\n\tCircle(double r){\n\t\tthis->r = r;\n\t}\n\tint operator <(const Circle & a){\n\t\tif(this->r < a.r){return 1;}\n\t\telse {return 0;}\n\t}\n\tint operator <=(const Circle & a){\n\t\tif(this->r <= a.r){return 1;}else {return 0;}\n\t}\n\tint operator ==(const Circle & a){\n\t\tif(this->r == a.r){return 1;}else {return 0;}\n\t}\n\tint operator !=(const Circle & a){\n\t\tif(this->r != a.r){return 1;}else {return 0;}\n\t}\n\tint operator >(const Circle & a){\n\t\tif(this->r > a.r){return 1;}else {return 0;}\n\t}\n\tint operator >=(const Circle & a){\n\t\tif(this->r >= a.r){return 1;}else {return 0;}\n\t}\n};",
            1592986997.8382819,
            100,
            "# 答案正确"
        ],
        [
            "9.7 (C++)",
            "王晓龙",
            "#include <iostream>\nusing namespace std;\nclass Circle{\nprivate:\n\tdouble r;\npublic:\n\tCircle(double r){\n\t\tthis->r = r;\n\t}\n\tint operator <(const Circle & a){\n\t\tif(this->r < a.r){return 1;}\n\t\telse {return 0;}\n\t}\n\tint operator <=(const Circle & a){\n\t\tif(this->r <= a.r){return 1;}else {return 0;}\n\t}\n\tint operator ==(const Circle & a){\n\t\tif(this->r == a.r){return 1;}else {return 0;}\n\t}\n\tint operator !=(const Circle & a){\n\t\tif(this->r != a.r){return 1;}else {return 0;}\n\t}\n\tint operator >(const Circle & a){\n\t\tif(this->r > a.r){return 1;}else {return 0;}\n\t}\n\tint operator >=(const Circle & a){\n\t\tif(this->r >= a.r){return 1;}else {return 0;}\n\t}\n};",
            1592986881.2664342,
            0,
            "main.cpp: In function ‘int main()’:\nmain.cpp:10:2: error: ‘Tensor’ was not declared in this scope\n  Tensor t3;\n  ^\nmain.cpp:11:9: error: ‘t3’ was not declared in this scope\n  cin >> t3;\n         ^\nmain.cpp:14:9: error: expected ‘;’ before ‘t4’\n  Tensor t4;\n         ^\nmain.cpp:15:9: error: ‘t4’ was not declared in this scope\n  cin >> t4;\n         ^\n"
        ],
        [
            "9.2 (C++)",
            "王晓龙",
            "class I{\nprivate:\n\tvector<int> x;\npublic:\n\tI(int a = -1, int b = -1, int c = -1, int d = -1){\n\t\tif(a != -1)x.push_back(a);\n\t\tif(b != -1)x.push_back(b);\n\t\tif(c != -1)x.push_back(c);\n\t\tif(d != -1)x.push_back(d);\n\t}\n\toperator vector<int>(){\n\t\treturn x;\n\t}\n};",
            1592987075.322095,
            100,
            "# 答案正确"
        ],
        [
            "9.3 (C++)",
            "王晓龙",
            "class Complex{\nprivate:\n\tfloat rea;\n\tfloat ima;\npublic:\n\tComplex(float r, float i){\n\t\tthis->rea = r;\n\t\tthis->ima = i;\n\t}\n\tComplex(int r){\n\t\tthis->rea = r;\n\t\tthis->ima = 0;\n\t}\n\tfloat real(){\n\t\treturn this->rea;\n\t}\n\tfloat imag(){\n\t\treturn this->ima;\n\t}\n\tComplex operator * (const Complex & other){\n\t\tfloat re = this->rea * other.rea - this->ima * other.ima;\n\t\tfloat im = this->ima * other.rea + this->rea * other.ima;\n\t\tComplex a(re,im);\n\t\treturn a;\n\t}\n\tComplex operator / (const Complex & other){\n\t\tfloat re = (this->rea * other.rea + this->ima * other.ima)/ (other.rea * other.rea + other.ima * other.ima);\n\t\tfloat im = (this->ima * other.rea - this->rea * other.ima)/ (other.rea * other.rea + other.ima * other.ima);\n\t\tComplex a(re,im);\n\t\treturn a;\n\t}\n\tComplex & operator += (const Complex & other){\n\t\tthis->rea = this->rea + other.rea;\n\t\tthis->ima = this->ima + other.ima;\n\t\treturn *this;\n\t}\n\tComplex & operator -= (const Complex & other){\n\t\tthis->rea = this->rea - other.rea;\n\t\tthis->ima = this->ima - other.ima;\n\t\treturn *this;\n\t}\n\tComplex & operator *= (const Complex & other){\n\t\tfloat re = this->rea * other.rea - this->ima * other.ima;\n\t\tfloat im = this->ima * other.rea + this->rea * other.ima;\n\t\tthis->rea = re;\n\t\tthis->ima = im;\n\t\treturn *this;\n\t}\n\tComplex & operator /= (const Complex & other){\n\t\tfloat re = (this->rea * other.rea + this->ima * other.ima)/ (other.rea * other.rea + other.ima * other.ima);\n\t\tfloat im = (this->ima * other.rea - this->rea * other.ima)/ (other.rea * other.rea + other.ima * other.ima);\n\t\tthis->rea = re;\n\t\tthis->ima = im;\n\t\treturn *this;\n\t}\n\tint operator == (const Complex & other){\n\t\tif(this->rea == other.rea && this->ima == other.ima){\n\t\t\treturn 1;\n\t\t}\n\t\telse return 0;\n\t}\n\tint operator !=(const Complex & other){\n\t\tif(this->rea != other.rea || this->ima != other.ima){\n\t\t\treturn 1;\n\t\t}\n\t\telse return 0;\n\t}\n};\n  Complex operator + (Complex a, Complex b){\n\tfloat re = a.real() + b.real();\n\tfloat im = a.imag() + b.imag();\n\tComplex c(re,im);\n\treturn c;\n}\n  Complex operator - (Complex a, Complex b){\n\tfloat re = a.real() - b.real();\n\tfloat im = a.imag() - b.imag();\n\tComplex c(re,im);\n\treturn c;\n}",
            1592987416.1460786,
            100,
            "# 答案正确"
        ],
        [
            "9.4 (C++)",
            "王晓龙",
            "class Complex{\nprivate:\n\tfloat rea;\n\tfloat ima;\npublic:\n\tComplex(){\n\t\tthis->rea = 0;\n\t\tthis->ima = 0;\n\t}\n\tvoid set(float a, float b){\n\t\trea = a;\n\t\tima = b;\n\t}\n\tfloat real(){\n\t\treturn this->rea;\n\t}\n\tfloat imag(){\n\t\treturn this->ima;\n\t}\n};\nComplex operator + (Complex a, Complex b){\n\tfloat re = a.real() + b.real();\n\tfloat im = a.imag() + b.imag();\n\tComplex c;\n\tc.set(re,im);\n\treturn c;\n}\nComplex operator - (Complex a, Complex b){\n\tfloat re = a.real() - b.real();\n\tfloat im = a.imag() - b.imag();\n\tComplex c;\n\tc.set(re,im);\n\treturn c;\n}\nistream & operator >>(istream & in, Complex & m){\n\tfloat a,b;\n\tin >> a >> b;\n\tm.set(a,b);\n\treturn in;\n}\nostream & operator <<(ostream & out, Complex & m){\n\tout << m.real()<<\" \" << \"+\" << \" \"<<m.imag() << \" \"<< \"i\" ;\n\treturn out;\n}",
            1593058267.3143268,
            100,
            "# 答案正确"
        ],
        [
            "9.5 (C++)",
            "王晓龙",
            "class Complex{\nprivate:\n\tfloat rea;\n\tfloat ima;\npublic:\n\tComplex(){\n\t\tthis->rea = 0;\n\t\tthis->ima = 0;\n\t}\n\tvoid set(float a, float b){\n\t\trea = a;\n\t\tima = b;\n\t}\n\tfloat real(){\n\t\treturn this->rea;\n\t}\n\tfloat imag(){\n\t\treturn this->ima;\n\t}\n\tComplex & operator ++(){\n\t\tthis->rea = this->rea + 1;\n\t\treturn *this;\n\t}\n\tComplex operator ++(int){\n\t\tComplex a;\n\t\ta.rea = this->rea;\n\t\ta.ima = this->ima;\n\t\tthis->rea = this->rea + 1;\n\t\treturn a;\n\t}\n\toperator double(){\n\t\treturn rea;\n\t}\n\t~Complex(){\n\t\t\n\t}\n};\nComplex operator + (Complex a, Complex b){\n\tfloat re = a.real() + b.real();\n\tfloat im = a.imag() + b.imag();\n\tComplex c;\n\tc.set(re,im);\n\treturn c;\n}\nComplex operator - (Complex a, Complex b){\n\tfloat re = a.real() - b.real();\n\tfloat im = a.imag() - b.imag();\n\tComplex c;\n\tc.set(re,im);\n\treturn c;\n}\nistream & operator >>(istream & in, Complex & m){\n\tfloat a,b;\n\tin >> a >> b;\n\tm.set(a,b);\n\treturn in;\n}\nostream & operator <<(ostream & out, Complex m){\n\tout << m.real()<<\" \" << \"+\" << \" \"<<m.imag() << \" \"<< \"i\" ;\n\treturn out;\n}",
            1593058324.760701,
            100,
            "# 答案正确"
        ],
        [
            "10.2 (C++)",
            "王晓龙",
            "catch(NonPositiveValueException & er){\n\tcout << \"caught: NonPositiveValueException\" << endl;\n}\ncatch(std::out_of_range & er){\n\tcout << \"caught: out_of_range\"<<endl;\n}\n",
            1593659789.5703177,
            100,
            "# 答案正确"
        ],
        [
            "10.1 (C++)",
            "王晓龙",
            "#include<stdexcept>\nclass MatrixSizesDoNotMatchException{};\n\ndouble Matrix::get(int row, int column)const{\n\t\n\treturn elements[(row-1) * size(2)+column-1];\n}\nvoid Matrix::set(int row, int column, double value){\n\t\n\telements[(row-1) * size(2)+column-1] = value;\n}\nMatrix Matrix::operator + (const Matrix & matrix2)const{\n\tif(this->size(1) != matrix2.size(1) || this->size(2) != matrix2.size(2)){\n\t\tthrow MatrixSizesDoNotMatchException();\n\t}\n\tMatrix ans(matrix2.size(1),matrix2.size(2));\n\tfor (int i = 0; i < rows * columns;  ++ i) {\n\t\t\tans.elements[i] = this->elements[i] + matrix2.elements[i];\n\t}\n\treturn ans;\n}\n\n\n",
            1593693177.9772174,
            93,
            "# 答案不正确\n\n# 随机输入:\n5 2\n1 7 \n1 9 \n4 7 \n5 5 \n5 7 \n\n6 6\n1 1\n\n5 2\n9 3 \n1 4 \n4 4 \n4 4 \n4 8 \n\n5 2\n4 2 \n1 7 \n3 6 \n1 3 \n9 4 \n\n\n# 参考答案:\ncaught: out_of_range\nvalue = 1\n(5,2)\n 10 10\n 2 13\n 8 11\n 9 9\n 9 15\n(5,2)\n 5 9\n 2 16\n 7 13\n 6 8\n 14 11\n\n\n# 我的答案:\nvalue = -1.83255e-06\nvalue = 1\n(5,2)\n 10 10\n 2 13\n 8 11\n 9 9\n 9 15\n(5,2)\n 5 9\n 2 16\n 7 13\n 6 8\n 14 11\n"
        ],
        [
            "2020-07-09 LAB",
            "王晓龙",
            "#include<iostream>\n#include<vector>\nusing namespace std;\n\nclass Integer{\nprivate:\n    int num;\n    static vector<Integer*> index;\npublic:\n    Integer(): num(0){\n        index.push_back(this);\n    }\n    Integer(int x): num(x){\n        index.push_back(this);\n    }\n    void change_value(const int& x){num = x;}\n    int get_value()const{return num;}\n    static void increase_all(const Integer& x){\n        for(int i = 0;i < index.size();i++){\n            index[i]->change_value(index[i]->get_value()+x.get_value());\n        }\n    }\n};\nvector<Integer*> Integer::index = vector<Integer*>();\n\nistream& operator >> (istream& in,Integer& x){\n    int num;\n    in >> num;\n    x.change_value(num);\n    return in;\n}\nostream& operator << (ostream& out,Integer& x){\n    out << x.get_value();\n    return out;\n}",
            1594265907.221229,
            100,
            "# 答案正确"
        ],
        [
            "15.1 (C++)",
            "王晓龙",
            "#include <string>\n#include <vector>\nusing namespace std;\nstring tostr(vector<string> value)\n{\n\tstring tmp;\n\tstring result;\n\tresult.push_back('\\t');\n\tresult.push_back('\\t');\n\tresult.push_back('[');\n\tfor (int i = 0; i < value.size(); i++)\n\t{\n\t\ttmp = value[i];\n\t\tresult.push_back('\\'');\n\t\tfor (int j = 0; j < tmp.size(); j++)\n\t\t\tresult.push_back(tmp[j]);\n\t\t   result.push_back('\\'');\n\t\t   result.push_back(',');\n\t}\n\tresult.insert(result.size(), \"],\\n\");\n\treturn result;\n}\n\nclass Table\n{\n\t\n\tvector<string> head;\n\tvector<vector<string>> value;\n\npublic:\n\tvoid addCol(string str)\n\t{\n\t\thead.push_back(str);\n\t};\n\t\n\tTable()\n\t{\n\t\thead.resize(0);\n\t\tvalue.resize(0);\n\t}\n\t\n\tstring json()const\n\t{\n\t\tstring result;\n\t\tresult = \"{\\n\\theaders: [\";\n\t\tstring tmp;\n\t\tfor (int i = 0; i < head.size();i++)\n\t\t{\n\t\t\ttmp = head[i];\n\t\t\tresult.push_back('\\'');\n\t\t\t\n\t\t\tfor (int j = 0; j < tmp.size();j++)\n\t\t\t\tresult.push_back(tmp[j]);\n\t\t\t   result.push_back('\\'');\n\t\t\t   result.push_back(',');\n\t\t}\n\t\tresult.insert(result.size(), \"],\\n\\trows: [\\n\");\n\t\tfor (int i = 0; i < value.size();i++)\n\t\t\tresult.insert(result.size(), tostr(value[i]));\n\n\t\t  result.insert(result.size(), \"\\t],\\n}\");\n\n        return result;\n\t}\n\tvector<string> & operator[](int index)\n\t{\n\t\tif(index < value.size()){}\n\t\telse{value.resize(index+1);\t}\n\t\treturn value[index];\n\t}\n};\n",
            1594296141.0508442,
            100,
            "# 答案正确"
        ],
        [
            "A.2 (C++)",
            "王晓龙",
            "template <typename E>\nvoid LinkedList<E>:: removeAll(const E & e){\n  if(contains( e)==false) return;\n  removeFirstOccurrence(e);\n  removeAll(e);\n}",
            1594870099.5622861,
            100,
            "# 答案正确"
        ],
        [
            "A.1 (C++)",
            "王晓龙",
            "LinkedList(const LinkedList &o) : _size(0), head(0), tail(0) { addAll(o);\n\t\t\n\t}\n\n\tLinkedList & operator= (const LinkedList & o){\n\t\tclear();\n\t\taddAll(o);\n\t}\n\t~LinkedList() { clear(); }\n\tvoid clear(){\n\t\twhile(_size > 0)\n\t\t\tremoveFirst();\n\t}\n\tvoid addAll(const LinkedList & o){\n\t\tNode<E> *temp = o.head;\n\t\tNode<E> *prev = 0;\n\t\tNode<E> *next = temp->next_node(prev);\n\t\tfor (int i = 0; i < o._size-1;i++){\n\t\t\tadd( i, temp->element);\n\t\t\tprev = temp;\n\t\t\ttemp = next;\n\t\t\tnext = next->next_node(prev);\n\t\t}\n\t\tadd(o._size, temp->element);\n\t}\n\tvoid print(const LinkedList &o)\n\t{\n\t\tNode<E> *temp = o.head;\n\t\tNode<E> *prev = 0;\n\t\tNode<E> *next = temp->next_node(prev);\n\t\tfor (int i = 0; i < o._size-1;i++){\n\t\t\tcout << temp->element << \" \";\n\t\t\tprev = temp;\n\t\t\ttemp = next;\n\t\t\tnext = next->next_node(prev);\n\t\t}\n\t\tcout <<temp->element<< endl;\n\t}\n\t\n\tvoid add(int index,const E o){\n\t\tNode<E> *node = new Node<E>();\n\t\tnode->element = o;\n\t\tif(this->head == 0){\n\t\t\tthis->head = node;\n\t\t\tthis->tail = this->head;\n\t\t}else if(index==0 && this->head != 0){\n\t\t\thead->update_prev_node(0, node);\n\t\t\tnode->update_next_node(0, head);\n\t\t\thead = node;\n\t\t}else if(index=this->_size){\n\t\t\tNode<E> *temp = this->tail;\n\t\t\tNode<E> *next = 0;\n\t\t\tnext = node;\n\t\t\tnode->update_prev_node(0, temp);\n\t\t\ttemp->update_next_node(0, next);\n\t\t\ttail = node;\n\t\t}\n\t\t++_size;\n\t}\n\tvoid remove(int index){\n\t\t\n\t\tif(index==0){\n\t\t\tNode<E> *temp = this->head;\n\t\t\tNode<E> *next = temp->next_node(0);\n\t\t\tNode<E> *prev = 0;\n\t\t\tif(next!=0){\n\t\t\tnext->update_prev_node(head,0);}\n\t\t\thead = next;\n\t\t\tdelete temp;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tNode<E> *temp = this->tail;\n\t\t\tNode<E> *prev = temp->prev_node(0);\n\t\t\tthis->tail = prev;\n\t\t\tprev->update_next_node(temp, 0);\n\t\t\tdelete temp;\n\t\t}\n\t\tthis->_size--;\n\t}\n\tvoid addFirst(E val){\n\t\tadd(0, val);\n\t}\n\tvoid addLast(E val){\n\t\tadd(_size, val);\n\t}\n\tvoid removeFirstOccurrence(int val){\n\t\tNode<E> *temp = this->head;\n\t\tNode<E> *next = temp->next_node(0);\n\t\tNode<E> *prev = 0;\n\t\tif(this->tail->element == val){\n\t\t\tremoveLast();\n\t\t\treturn;\n\t\t}else if(this->head->element==val){\n\t\t\tremoveFirst();\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 0; i < this->_size-1;i++){\n\t\t\tprev = temp, temp = next;\n\t\t\tnext = temp->next_node(prev);\n\t\t\tif (temp->element == val)\n\t\t\t\tbreak;\n\t\t}\n\t\tprev->update_next_node(temp, next);\n\t\tnext->update_prev_node(temp, prev);\n\t\tdelete temp;\n\t\tthis->_size--;\n\t}\n\tint get(int index){\n\t\tNode<E> *temp = this->head;\n\t\tNode<E> *prev = 0;\n\t\tNode<E> *next = temp->next_node(prev);\n\t\tif(index==this->_size-1)\n\t\t\treturn this->tail->element;\n\t\telse if(index==0){\n\t\t\treturn temp->element;\n\t\t}\n\t\treturn temp->element;\n\t}\n\tvoid removeLast() { remove(this->_size);\n\t\t\n\t}\n\tvoid removeFirst() { remove(0);\n\t\t\n\t}",
            1594900363.4799848,
            100,
            "# 答案正确"
        ],
        [
            "A.3 (C++)",
            "王晓龙",
            "#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate <typename E>\nclass Tuple\n{\npublic:\n   int key;\n   E val;\n   bool in_use;\n   Tuple()\n  {\n  in_use = false;\n  }\n};\n\ntemplate <typename E>\nclass HT\n{\nprivate:\n  vector<Tuple<E>> tuples;\n  int _size;\n\npublic:\n\t\n\t\n  HT(){\n  tuples.resize(4000);\n  _size = 0;\n }\n\t\n\t\n int hashfunction(int key){\n  int hashcode = 0;\n  while (key){\n   hashcode = (hashcode << 5) + (key % 10);\n   key /= 10;\n  }\n  return hashcode % tuples.size();\n }\n\t\n\t\n int indexofkey(int key){\n\t \n  int index = hashfunction(key);\n  while (true){\n   if (tuples[index].in_use == false)\n    return index;\n   if (tuples[index].key == key)\n    return index;\n   index = (index + 1) % tuples.size();\n  }\n }\n\t\n\t\n void put(int key, E val){\n\t \n  int index = indexofkey(key);\n  tuples[index].val = val;\n  tuples[index].key = key;\n  if (tuples[index].in_use == false){\n   tuples[index].in_use = true;\n   _size++;\n  }\n }\n\t\n\t\n int size(){\n  return _size;\n }\n\t\n\t\n bool containsKey(int key){\n\t \n  int index = indexofkey(key);\n  return tuples[index].in_use == true;\n }\n\t\n E operator[](int key){\n\t \n  int index = indexofkey(key);\n  return tuples[index].val;\n }\n\t\n vector<int> getKeys(){\n\t \n  vector<int> ans;\n  for (int i = 0; i < tuples.size(); i++){\n   if (tuples[i].in_use){\n    ans.push_back(tuples[i].key);\n   }\n  }\n  return ans;\n }\n\t\n void remove(int key){\n\t \n  int index = indexofkey(key);\n  tuples[index].in_use = false;\n  _size--;\n }\n};",
            1595475021.6256337,
            100,
            "# 答案正确"
        ],
        [
            "A.4 (C++)",
            "王晓龙",
            "#include <iostream>\n#include <sstream>\nusing namespace std;\n\nclass Tuple\n{\npublic:\n\tint key,val;\n\tTuple() {}\n\tTuple(int k, int v){\n\tkey = k;\n\tval = v;\n\t}\n\t\n\toperator int(){\n\treturn this->val;\n\t}\n\t\n\toperator string(){\n\tstring result;\n\tstringstream as;\n\tas << this->val;\n\tas >> result;\n\treturn result;\n\t}\n};\n\nclass HT{\n  private:\n\tTuple dict[10];\n\tint _size;\n  public:\n\t HT(): _size(0) {}\n\t~HT(){}\n\t\n\ttemplate<typename K,typename V>\n\t\tvoid put(K key,V val){\n\t\t\tint ke,va,fd;\n\t\t\tke = str_to_int(key);\n\t\t\tva = str_to_int(val);\n\t\t   fd=ke+va;\n\t\t\tTuple ling(ke, va);\n\t\t\tdict[this->_size] = ling;\n\t\t\tthis->_size++;\n\t\t   fd--;\n\t\t}\n\t\n\t\tint size(){\n\t\t\treturn this->_size;\n\t\t}\n\t\n\t\tint str_to_int(int str) { \n      return str; }\n\t\n\t\tint str_to_int(string str){\n\t\t\tstringstream as;\n\t\t\tas << str;\n\t\t\tint res;\n\t\t\tas >> res;\n\t\t\treturn res;\n\t\t}\n\n\t\tstring int_to_str(string v) { \n\t\treturn v; }\n\t\n\t\tstring int_to_str(int v){\n\t\t\tstring result;\n\t\t\tstringstream as;\n\t\t\tas << v;\n\t\t\tas >> result;\n\t\t\treturn result;\n\t\t}\n        \n\t\ttemplate < typename V>\n\t\tTuple operator[](const V &index)\n\t\t{\n\t\t\tint ling,flag;\n\t\t\tflag=0;\n\t\t\tling = str_to_int(index);\n\t\t\tfor (int i = 0; i <= 10;i++){\n\t\t\t\tif(dict[i].key == ling){\n\t\t\t\t\treturn dict[i];\n\t\t\t\t\tflag++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n};",
            1595853781.3181982,
            100,
            "# 答案正确"
        ],
        [
            "A.5 (C++)",
            "王晓龙",
            "#include <iostream>\n#include <sstream>\nusing namespace std;\n\n\nclass Tuple\n{\npublic:\n\tint key;\n\tint val;\n\tbool ud;\n\t\t\tTuple() : ud(false){}\n\t\t\tTuple(int k, int v){\n\t\t\t\tud = true;\n\t\t\t\tkey = k;\n\t\t\t\tval = v;\n\t\t\t}\n\t\t\toperator int(){\n\t\t\t\treturn this->val;\n\t\t\t}\n\t\n\t\t\toperator string(){\n\t\t\t\tstring otcome;\n\t\t\t\tstringstream as;\n\t\t\t\tas << this->val;\n\t\t\t\tas >> otcome;\n\t\t\t\treturn otcome;\n\t\t\t}\n\t\n\t\t\tint str_to_int(string &str){\n\t\t\t\tstringstream as;\n\t\t\t\tas << str;\n\t\t\t\tint res;\n\t\t\t\tas >> res;\n\t\t\t\treturn res;\n\t\t\t}\n\t\n\t\t\tint str_to_int(int a) {\n\t\t\treturn a; }\n\t\n\t\t\ttemplate<typename K>\n\t\t\tTuple& operator= (K oth)\n\t\t\t{\n\t\t\t\tthis->val = str_to_int(oth);\n\t\t\t\tthis->ud = true;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t};\n\n#define max_index 100\n#define min_index 1\n\nclass HT{\n\tprivate:\n\t\tTuple dict[max_index+2];\n\t\tint _size;\npublic:\n\t\tHT(): _size(0) {}\n\t\t~HT(){}\n\t\tsize_t size(){\n\t\t\tsize_t count=0;\n\t\t\t int flag=0;\n\t\t\tfor (size_t i = 0; i <= max_index;i++)\n\t\t\t\tif(dict[i].ud==true)\n\t\t\t\t\tcount++;\n\t\t\t   else  flag++;\n\t\t\t\treturn count;\n\t\t}\n\t\n\t\tint str_to_int(int str) { return str; }\n\t\tint str_to_int(string str){\n\t\t\tstringstream as;\n\t\t\tas << str;\n\t\t\tint res;\n\t\t\tas >> res;\n\t\t\treturn res;\n\t\t}\n\t\n\t\tint find_index(int key){\n\t\t  return key%max_index;\n\t\t}\n\t\n\t\ttemplate < typename V>\n\t\tTuple & operator[](const V &index){\n\t\t\tint ling;\n\t\t\tling = str_to_int(index);\n\t\t\treturn dict[find_index(ling)];\n\t\t}\n\t\t\n};",
            1595854673.161158,
            100,
            "# 答案正确"
        ]
    ],
    "table_name": "答案"
}