{
    "__update_time__": 1594265699.5496697,
    "field_names": [
        "题目名",
        "用户名",
        "答案",
        "提交时间",
        "分数",
        "评语"
    ],
    "field_types": [
        "text",
        "text",
        "text",
        "time",
        "number",
        "text"
    ],
    "foreign_keys": {},
    "primary_keys": [],
    "rows": [
        [
            "2.1 (C++)",
            "彭跃江",
            "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nclass Matrix {\nprivate:\n    int rows;\n    int columns;\n    double * values;\npublic:\n    Matrix(int rows, int columns)\n    {\n        this->rows = rows;\n        this->columns = columns;\n        this->values = new double [rows * columns];\n        for(int i = 0; i < rows * columns; i++){\n            values[i] = 0;\n        }\n    }\n    void print() const\n    {\n\t\tint ctr, j;\n        for (ctr = 0; ctr < this->rows * this->columns; ) {\n            for (j = 0; j < columns; ++j) {\n                if (j == columns - 1)\n                    cout << values[ctr];\n                else\n                    cout << values[ctr] << \"    \";\n                ctr += 1;\n            }\n            cout << endl;\n        }\n    }\n    ~Matrix() \n\t{\n\t\tdelete [] values;\n\t}\n};",
            1589456939.6991026,
            100,
            "# 答案正确"
        ],
        [
            "2.2 (C++)",
            "彭跃江",
            "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nclass Matrix {\nprivate:\n    int rows;\n    int columns;\n    double * values;\npublic:\n    Matrix(int rows, int columns, double * values)\n    {\n        this->rows = rows;\n        this->columns = columns;\n\t\tint numElem = rows * columns;\n        this->values = new double [numElem];\n        for(int i = 0; i < numElem; ++i)\n            this->values[i] = values[i];\n    }\n    void print() const\n    {\n\t\tint i, j;\n        for(i = 0; i < this->rows * this->columns; ){\n            for (j = 0; j < this->columns; ++j) {\n                cout << setw(5);\n                cout << this->values[i];\n                i += 1;\n            }\n            cout << endl;\n        }\n    }\n    ~Matrix()\n\t{\n\t\tdelete [] values;\n\t}\n};",
            1589458901.6280787,
            100,
            "# 答案正确"
        ],
        [
            "2.3 (C++)",
            "彭跃江",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix {\nprivate:\n    int rows;\n    int columns;\n    double * values;\npublic:\n    Matrix(const Matrix & matrix2)\n    {\n        this->columns = matrix2.columns;\n        this->rows = matrix2.rows;\n        this->values = new double [matrix2.rows * matrix2.columns];\n        for(int i = 0; i < matrix2.rows * matrix2.columns; ++i)\n            this->values[i] = matrix2.values[i];\n    }\n    Matrix(int rows, int columns, double * values)\n    {\n        this->rows = rows;\n        this->columns = columns;\n\t\tint numElem = rows * columns;\n        this->values = new double [numElem];\n        for(int i = 0; i < numElem; ++i)\n            this->values[i] = values[i];\n    }\n    void print() const\n    {\n\t\tint i, j;\n        for(i = 0; i < rows * columns; ){\n            for(j = 0; j < columns; ++j){\n                cout << \"    \" << this->values[i];\n                i++;\n            }\n            cout << endl;\n        }\n    }\n\t~Matrix()\n\t{\n\t\tdelete [] values;\n\t}\n};",
            1589453599.4490466,
            100,
            "# 答案正确"
        ],
        [
            "2.5 (C++)",
            "彭跃江",
            "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nclass Matrix {\nprivate:\n    int rows;\n    int columns;\n    double * values;\npublic:\n    Matrix() = default;\n    Matrix(int rows, int columns)\n    {\n        this->rows = rows;\n        this->columns = columns;\n\t\tint numElem = rows * columns;\n        this->values = new double [numElem];\n        for(int i = 0; i < numElem; i++)\n            this->values[i] = 0;\n    }\n    Matrix(int rows, int columns, double * values)\n    {\n        this->rows = rows;\n        this->columns = columns;\n\t\tint numElem = rows * columns;\n        this->values = new double [numElem];\n        for(int i = 0; i < numElem; i++)\n            this->values[i] = values[i];\n    }\n    void print() const\n    {\n\t\tint i, j;\n        for(i = 0; i < rows * columns; ){\n            for(j = 0; j < columns; j++){\n                cout << \"    \" << this->values[i];\n                i++;\n            }\n            cout << endl;\n        }\n    }\n    Matrix getRow(int rows)\n    {\n        Matrix ptr;\n        double *each = new double [this->columns];\n        for (int i = 0; i < this->columns; ++i) {\n            each[i] = this->values[i + (rows - 1) * this->columns];\n        }\n        ptr.rows = 1;\n        ptr.columns = this->columns;\n        ptr.values = each;\n        return ptr;\n    }\n    Matrix getColumn(int columns)\n    {\n        Matrix ptr;\n        double *each = new double [this->columns];\n        for (int i = 0; i < this->rows; ++i) {\n            each[i] = this->values[(this->columns * i) + columns - 1];\n        }\n        ptr.rows = this->rows;\n        ptr.columns = 1;\n        ptr.values = each;\n        return ptr;\n    }\n    ~Matrix()\n    {\n        delete[] values;\n    }\n};",
            1589459281.7500012,
            100,
            "# 答案正确"
        ],
        [
            "2.6 (C++)",
            "彭跃江",
            "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nclass Matrix {\nprivate:\n    int rows;\n    int columns;\n    double * values;\npublic:\n    Matrix() = default;\n    Matrix(int row, int column)\n    {\n        rows = row;\n        columns = column;\n        this->values = new double [row * column];\n        for (int i = 0; i < row * column; ++i) {\n            *(values + i) = 0;\n        }\n    }\n    Matrix(int row, int column, double * value)\n    {\n        rows = row;\n        columns = column;\n        this->values = new double [row * column];\n        for (int i = 0; i < row * column; ++i) {\n            *(values + i) = *(value + i);\n        }\n    }\n    void print() const\n    {\n        for (int i = 0; i < rows * columns; ) {\n            for (int j = 0; j < columns; ++j) {\n                //std::cout << std::setw(5);\n                std::cout << \"    \" << this->values[i];\n                ++i;\n            }\n            std::cout << std::endl;\n        }\n    }\n    Matrix concatenateColumns(const Matrix &mtr) const\n    {\n        Matrix print;\n        print.columns = this->columns + mtr.columns;\n        print.rows = this->rows;\n        double *elem = new double [(this->columns + mtr.columns) * this->rows];\n        for (int i = 0, i1 = 0, i2 = 0; i < ((this->columns + mtr.columns) * this->rows); ) {\n            for (int j = 0; j < this->columns; ++j) {\n                elem[i] = this->values[i1];\n                ++i;\n                ++i1;\n            }\n            for (int j = 0; j < mtr.columns; ++j) {\n                elem[i] = mtr.values[i2];\n                ++i;\n                ++i2;\n            }\n        }\n        print.values = elem;\n        return print;\n    }\n    Matrix concatenateRows(const Matrix &mtr) const\n    {\n        Matrix print;\n        int i;\n        print.columns = this->columns;\n        print.rows = this->rows + mtr.rows;\n        double *elem = new double [this->columns * (this->rows + mtr.rows)];\n        for (i = 0; i < (this->columns * this->rows); ++i) {\n            elem[i] = this->values[i];\n        }\n        for (int j = 0; j < (this->columns * mtr.rows); ++j) {\n            elem[i + j] = mtr.values[j];\n        }\n        print.values = elem;\n        return print;\n    }\n    ~Matrix()\n    {\n        delete[] values;\n    }\n};\n",
            1589455082.7415082,
            100,
            "# 答案正确"
        ],
        [
            "2.9 (C++)",
            "彭跃江",
            "#pragma once\n#include <iostream>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    double * values;\npublic:\n    Matrix() = default;\n    Matrix(int, int);\n    Matrix(int, int, double*);\n    Matrix(const Matrix&);\n\t~Matrix();\n    void print() const;\n    Matrix operator + (const Matrix&);\n    Matrix operator + (double);\n    Matrix operator - (const Matrix&);\n    Matrix operator - (double);\n};\n\nMatrix::Matrix(int row, int column) :\n            rows(row), columns(column)\n    {\n        values = new double [rows * columns];\n        for (int i = 0; i < rows * columns; ++i)\n            values[i] = 0;\n    }\n\t\nMatrix::Matrix(int row, int column, double * _values) :\n        rows(row), columns(column)\n{\n    values = new double [rows * columns];\n    for (int i = 0; i < rows * columns; ++i)\n        values[i] = _values[i];\n}\n\t\nMatrix::Matrix(const Matrix & matrix2)\n{\n\trows = matrix2.rows;\n\tcolumns = matrix2.columns;\n\tvalues = new double [rows * columns];\n\tfor (int i = 0; i < rows * columns; ++i)\n        values[i] = matrix2.values[i];\n\t}\n\t\nMatrix::~Matrix()\n{\n\tdelete [] this->values;\n}\n\t\nvoid Matrix::print() const\n{\n\tint index = 0;\n\tfor (int i = 0; i < rows; ++i) {\n\t\tfor (int j = 0; j < columns; ++j) {\n\t\t\tstd::cout << \"    \" << values[index];\n\t\t\t++index;\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nMatrix Matrix::operator + (const Matrix & matrix2)\n{\n    Matrix matrix;\n    matrix.rows = rows;\n    matrix.columns = columns;\n\tint volumn = matrix.rows * matrix.columns;\n    matrix.values = new double [volumn];\n    for (int i = 0; i < volumn; ++i) {\n        matrix.values[i] = this->values[i] + matrix2.values[i];\n    }\n    return matrix;\n}\n\nMatrix Matrix::operator + (double value)\n{\n    Matrix matrix;\n    matrix.rows = rows;\n    matrix.columns = columns;\n\tint volumn = matrix.rows * matrix.columns;\n    matrix.values = new double [volumn];\n    for (int i = 0; i < volumn; ++i) {\n        matrix.values[i] = this->values[i] + value;\n    }\n    return matrix;\n}\n\nMatrix Matrix::operator - (const Matrix & matrix2)\n{\n    Matrix matrix;\n    matrix.rows = rows;\n    matrix.columns = columns;\n\tint volumn = matrix.rows * matrix.columns;\n    matrix.values = new double [volumn];\n    for (int i = 0; i < volumn; ++i) {\n        matrix.values[i] = this->values[i] - matrix2.values[i];\n    }\n    return matrix;\n}\n\nMatrix Matrix::operator - (double value)\n{\n    Matrix matrix;\n    matrix.rows = rows;\n    matrix.columns = columns;\n\tint volumn = matrix.rows * matrix.columns;\n    matrix.values = new double [volumn];\n    for (int i = 0; i < volumn; ++i) {\n        matrix.values[i] = this->values[i] - value;\n    }\n    return matrix;\n}\n",
            1590029621.582709,
            100,
            "# 答案正确"
        ],
        [
            "2.4 (C++)",
            "彭跃江",
            "#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    double * values;\npublic:\n    Matrix() = default;\n    Matrix(int, int);\n\tMatrix(int, int, double*);\n\t~Matrix();\n\tMatrix &operator = (Matrix &);\n\tvoid print();\n\tvoid set(int, int, double);\n};\n\nMatrix::Matrix(int row, int column) :\n        rows(row), columns(column)\n{\n\tvalues = new double [rows * columns];\n\tfor (int i = 0; i < rows * columns; ++i) {\n\t\tvalues[i] = 0;\n\t}\n}\n\nMatrix::Matrix(int nRows, int nColumns, double * values) :\n\trows(nRows), columns(nColumns)\n{\n\tthis->values = new double [rows * columns];\n\tfor (int i = 0; i < rows * columns; ++i) {\n\t\t*(this->values + i) = *(values + i);\n\t}\n}\n\nMatrix & Matrix::operator = (Matrix &matrix)\n{\n\trows = matrix.rows;\n\tcolumns = matrix.columns;\n\tdouble * another;\n\tanother = new double [matrix.rows * matrix.columns];\n\tfor (int i = 0; i < matrix.rows * matrix.columns; ++i) {\n\t    another[i] = matrix.values[i];\n\t}\n\tdelete [] this->values;\n\tvalues = another;\n\treturn *this;\n}\n\nvoid Matrix::print()\n{\n\tint index, i, j;\n\tfor (i = 0, index = 0; i < this->rows; ++i) {\n\t\tfor (j = 0; j < this->columns; ++j) {\n\t\t\tcout << \"    \" << values[index];\n\t\t\t++index;\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nvoid Matrix::set(int row, int column, double value)\n{\n\tint index = (row - 1) * this->columns + column - 1;\n\tthis->values[index] = value;\n}\n\nMatrix::~Matrix() { delete [] values; }\n",
            1590063270.05589,
            100,
            "# 答案正确"
        ],
        [
            "2.7 (C++)",
            "彭跃江",
            "#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    double * values;\npublic:\n    Matrix() = default;\n    Matrix(int, int);\n\tMatrix(int, int, double*);\n\t~Matrix();\n\tvoid print();\n\tMatrix reshape(int, int) const;\n};\n\nMatrix::Matrix(int row, int column) :\n        rows(row), columns(column)\n{\n\tvalues = new double [rows * columns];\n\tfor (int i = 0; i < rows * columns; ++i) {\n\t\tvalues[i] = 0;\n\t}\n}\n\nMatrix::Matrix(int nRows, int nColumns, double * values) :\n\trows(nRows), columns(nColumns)\n{\n\tthis->values = new double [rows * columns];\n\tfor (int i = 0; i < rows * columns; ++i) {\n\t\t*(this->values + i) = *(values + i);\n\t}\n}\n\nvoid Matrix::print()\n{\n\tint index, i, j;\n\tfor (i = 0, index = 0; i < this->rows; ++i) {\n\t\tfor (j = 0; j < this->columns; ++j) {\n\t\t\tcout << \"    \" << values[index];\n\t\t\t++index;\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nMatrix Matrix::reshape(int rows, int columns) const\n{\n    Matrix another;\n    another.columns = columns;\n    another.rows = rows;\n    another.values = new double [rows * columns];\n    double arr[rows][columns];\n    double array[this->rows][this->columns];\n    for (int i = 0; i < this->rows; ++i) {\n        for (int j = 0; j < this->columns; ++j) {\n            array[i][j] = *(this->values + i * this->columns + j);\n        }\n    }\n    int cnt1 = 0;\n    int cnt2 = 0;\n    for (int i = 0; i < this->columns; ++i) {\n        for (int j = 0; j < this->rows; ++j) {\n            arr[cnt1][cnt2] = array[j][i];\n            ++cnt1;\n            if (cnt1 > rows) {\n                cnt1 = 0;\n                ++cnt2;\n                --j;\n            }\n        }\n    }\n    int cnt = 0;\n    for (int i = 0; i < rows; ++i) {\n        for (int j = 0; j < columns; ++j) {\n            *(another.values + cnt) = arr[i][j];\n            ++cnt;\n        }\n    }\n    return another;\n}\n\nMatrix::~Matrix() { delete [] values; }\n",
            1590063896.5721831,
            100,
            "# 答案正确"
        ],
        [
            "2.8 (C++)",
            "彭跃江",
            "#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    double * values;\npublic:\n    Matrix() = default;\n    Matrix(int, int);\n\tMatrix(int, int, double*);\n\t~Matrix();\n\tvoid print();\n\tMatrix transpose() const\n\t{\n\t    Matrix matrix;\n    \tmatrix.columns = rows;\n    \tmatrix.rows = columns;\n\t\tint volume = rows * columns;\n    \tmatrix.values = new double [volume];\n    \tdouble array[this->columns][this->rows];\n    \tint index = 0;\n    \tfor (int j = 0; j < this->rows; ++j) {\n    \t    for (int i = 0; i < this->columns; ++i) {\n    \t        array[i][j] = this->values[index];\n    \t        ++index;\n    \t    }\n    \t}\n\t\tint i;\n    \tfor (i = 0, index = 0; i < this->columns; ++i) {\n    \t    for (int j = 0; j < this->rows; ++j) {\n    \t        matrix.values[index] = array[i][j];\n    \t        ++index;\n    \t    }\n    \t}\n    \treturn matrix;\n\t}\n};\n\nMatrix::Matrix(int row, int column) :\n        rows(row), columns(column)\n{\n\tvalues = new double [rows * columns];\n\tfor (int i = 0; i < rows * columns; ++i) {\n\t\tvalues[i] = 0;\n\t}\n}\n\nMatrix::Matrix(int nRows, int nColumns, double * values) :\n\trows(nRows), columns(nColumns)\n{\n\tthis->values = new double [rows * columns];\n\tfor (int i = 0; i < rows * columns; ++i) {\n\t\t*(this->values + i) = *(values + i);\n\t}\n}\n\nvoid Matrix::print()\n{\n\tint index, i, j;\n\tfor (i = 0, index = 0; i < this->rows; ++i) {\n\t\tfor (j = 0; j < this->columns; ++j) {\n\t\t\tcout << \"    \" << values[index];\n\t\t\t++index;\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nMatrix::~Matrix() { delete [] values; }\n",
            1590064223.7096844,
            100,
            "# 答案正确"
        ],
        [
            "2.10 (C++)",
            "彭跃江",
            "#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    double * values;\npublic:\n    Matrix() = default;\n    Matrix(int, int);\n\tMatrix(int, int, double*);\n\t~Matrix();\n\tvoid print();\n\tMatrix operator * (const Matrix & matrix2) const\n    \t{\n    \t    Matrix another;\n    \t   \tanother.rows = this->rows;\n    \t    another.columns = matrix2.columns;\n    \t    double * array = new double [another.rows * another.columns];\n    \t    double arr1[rows][columns], arr2[matrix2.rows][matrix2.columns], arr3[another.rows][another.columns];\n    \t    int i, j, cnt;\n    \t    for (i = 0, cnt = 0; i < rows; ++i) {\n    \t        for (j = 0; j < columns; ++j) {\n    \t            arr1[i][j] = *(this->values + cnt);\n    \t            ++cnt;\n    \t        }\n    \t    }\n    \t    for (i = 0, cnt = 0; i < rows; ++i) {\n    \t        for (j = 0; j < columns; ++j) {\n    \t            arr1[i][j] = *(values + cnt);\n    \t            ++cnt;\n    \t        }\n    \t    }\n    \t    for (i = 0, cnt = 0; i < matrix2.rows; ++i) {\n    \t        for (j = 0; j < matrix2.columns; ++j) {\n    \t            arr2[i][j] = *(matrix2.values + cnt);\n    \t            ++cnt;\n    \t        }\n    \t    }\n    \t    for (i = 0, cnt = 0; i < another.rows; ++i) {\n    \t        for (j = 0; j < another.columns; ++j) {\n    \t            double sum = 0;\n    \t            for (int index = 0; index < columns; ++index) {\n    \t                sum += arr1[i][index] * arr2[index][j];\n    \t            }\n    \t            arr3[i][j] = sum;\n    \t        }\n    \t    }\n    \t    for (i = 0, cnt = 0; i < another.rows; ++i) {\n    \t        for (j = 0; j < another.columns; ++j) {\n    \t            array[cnt] = arr3[i][j];\n\t\t\t\t\t++cnt;\n    \t        }\n    \t    }\n\t\t\tanother.values = array;\n    \t    return another;\n    \t}\n    \tMatrix operator * (double value) const\n    \t{\n    \t    Matrix another;\n    \t    another.rows = this->rows;\n    \t    another.columns = this->columns;\n    \t    another.values = new double [another.rows * another.columns];\n    \t    for (int i = 0; i < rows * columns; ++i) {\n    \t        another.values[i] = values[i] * value;\n    \t    }\n    \t    return another;\n    \t}\n};\n\nMatrix::Matrix(int row, int column) :\n        rows(row), columns(column)\n{\n\tvalues = new double [rows * columns];\n\tfor (int i = 0; i < rows * columns; ++i) {\n\t\tvalues[i] = 0;\n\t}\n}\n\nMatrix::Matrix(int nRows, int nColumns, double * values) :\n\trows(nRows), columns(nColumns)\n{\n\tthis->values = new double [rows * columns];\n\tfor (int i = 0; i < rows * columns; ++i) {\n\t\t*(this->values + i) = *(values + i);\n\t}\n}\n\nvoid Matrix::print()\n{\n\tint index, i, j;\n\tfor (i = 0, index = 0; i < this->rows; ++i) {\n\t\tfor (j = 0; j < this->columns; ++j) {\n\t\t\tcout << \"    \" << values[index];\n\t\t\t++index;\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nMatrix::~Matrix() { delete [] values; }\n",
            1590064562.132567,
            100,
            "# 答案正确"
        ],
        [
            "2.11 (C++)",
            "彭跃江",
            "#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    double * values;\npublic:\n    Matrix() = default;\n    Matrix(int, int);\n\tMatrix(int, int, double*);\n\t~Matrix();\n\tvoid print();\n\tMatrix max() const;\n\tMatrix sum() const;\n\tMatrix min() const;\n};\n\nMatrix::Matrix(int row, int column) :\n        rows(row), columns(column)\n{\n\tvalues = new double [rows * columns];\n\tfor (int i = 0; i < rows * columns; ++i) {\n\t\tvalues[i] = 0;\n\t}\n}\n\nMatrix::Matrix(int nRows, int nColumns, double * values) :\n\trows(nRows), columns(nColumns)\n{\n\tthis->values = new double [rows * columns];\n\tfor (int i = 0; i < rows * columns; ++i) {\n\t\t*(this->values + i) = *(values + i);\n\t}\n}\n\nvoid Matrix::print()\n{\n\tint index, i, j;\n\tfor (i = 0, index = 0; i < this->rows; ++i) {\n\t\tfor (j = 0; j < this->columns; ++j) {\n\t\t\tcout << \"    \" << values[index];\n\t\t\t++index;\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nMatrix Matrix::max() const\n{\n    Matrix max;\n    if (rows == 1) {\n\t\tmax.rows = 1;\n\t\tmax.columns = 1;\n\t\tmax.values = new double [max.rows * max.columns];\n\t\tmax.values[0] = *(this->values);\n\t\tfor (int i = 0; i < this->columns; ++i) \n\t\t\tmax.values[0] = (*(this->values + i) > *(max.values)) ? *(this->values + i) : *(max.values);\n\t}\n\telse {\n\t\tmax.rows = 1;\n\t\tmax.columns = this->columns;\n\t\tmax.values = new double [max.rows * max.columns];\n\t\tdouble array[this->rows][this->columns];\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i < this->rows; ++i) {\n\t\t\tfor (int j = 0; j < this->columns; ++j) {\n\t\t\t\tarray[i][j] = *(this->values + cnt);\n\t\t\t\t++cnt;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < max.columns; ++i) {\n\t\t\t*(max.values + i) = array[0][i];\n\t\t\tfor (int j = 0; j < this->rows; ++j)\n\t\t\t\tmax.values[i] = (array[j][i] > max.values[i]) ? array[j][i] : max.values[i];\n\t\t}\n\t}\n    return max;\n}\n\nMatrix Matrix::min() const\n{\n    Matrix min;\n    switch (this->rows) {\n        case 1:\n            min.rows = 1;\n            min.columns = 1;\n            min.values = new double [min.rows * min.columns];\n            *(min.values) = *(this->values);\n            for (int i = 0; i < this->columns; ++i) {\n                *(min.values) = (*(this->values + i) < *(min.values)) ? *(this->values + i) : *(min.values);\n            }\n            break;\n        default:\n            min.rows = 1;\n            min.columns = this->columns;\n            min.values = new double [min.rows * min.columns];\n            double array[this->rows][this->columns];\n            int cnt = 0;\n            for (int i = 0; i < this->rows; ++i) {\n                for (int j = 0; j < this->columns; ++j) {\n                    array[i][j] = this->values[cnt];\n                    ++cnt;\n                }\n            }\n            for (int i = 0; i < min.columns; ++i) {\n                min.values[i] = array[0][i];\n                for (int j = 0; j < this->rows; ++j) {\n                    min.values[i] = (array[j][i] < min.values[i]) ? array[j][i] : min.values[i];\n                }\n            }\n    }\n    return min;\n}\n\nMatrix Matrix::sum() const\n{\n    Matrix sum;\n    switch (this->rows) {\n        case 1:\n            sum.rows = 1;\n            sum.columns = 1;\n            sum.values = new double [sum.rows * sum.columns];\n            sum.values[0] = 0;\n            for (int i = 0; i < this->columns; ++i) {\n                sum.values[0] += this->values[i];\n            }\n            break;\n        default:\n            sum.rows = 1;\n            sum.columns = this->columns;\n            sum.values = new double [sum.rows * sum.columns];\n            double array[this->rows][this->columns];\n            int cnt = 0;\n            for (int i = 0; i < this->rows; ++i) {\n                for (int j = 0; j < this->columns; ++j) {\n                    array[i][j] = this->values[cnt];\n                    ++cnt;\n                }\n            }\n            for (int i = 0; i < sum.columns; ++i) {\n                sum.values[i] = 0;\n                for (int j = 0; j < this->rows; ++j) {\n                    sum.values[i] += array[j][i];\n                }\n            }\n    }\n    return sum;\n}\n\nMatrix::~Matrix() { delete [] values; }\n",
            1590065101.430914,
            100,
            "# 答案正确"
        ],
        [
            "2.12 (C++)",
            "彭跃江",
            "#include <iostream>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nclass Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    double * values;\npublic:\n    Matrix() = default;\n    Matrix(int, int);\n\tMatrix(int, int, double*);\n\t~Matrix();\n\tvoid print();\n\tMatrix pow(double expoent)\n\t{\n\t    Matrix p;\n\t    p.rows = this->rows;\n\t    p.columns = this->columns;\n\t    p.values = new double [p.rows * p.columns];\n\t    for (int i = 0; i < p.rows * p.columns; ++i) {\n\t        *(p.values + i) = ::pow(*(this->values + i), expoent);\n\t    }\n\t    return p;\n\t}\n\t\n\tMatrix exp()\n\t{\n\t    Matrix e;\n\t    e.rows = this->rows;\n\t    e.columns = this->columns;\n\t    e.values = new double [e.rows * e.columns];\n\t    for (int i = 0; i < e.rows * e.columns; ++i) {\n\t        *(e.values + i) = ::exp(*(this->values + i));\n\t    }\n\t    return e;\n\t}\n\t\n\tMatrix log()\n\t{\n\t    Matrix l;\n\t    l.rows = this->rows;\n\t    l.columns = this->columns;\n\t    l.values = new double [l.rows * l.columns];\n\t    for (int i = 0; i < l.rows * l.columns; ++i) {\n\t\t        *(l.values + i) = ::log(*(this->values + i));\n   \t\t}\n    \treturn l;\n\t}\n\n\tMatrix abs()\n\t{\n\t    Matrix a;\n\t    a.rows = this->rows;\n\t\ta.columns = this->columns;\n    \ta.values = new double [a.rows * a.columns];\n    \tfor (int i = 0; i < a.rows * a.columns; ++i) {\n    \t    *(a.values + i) = ::fabs(*(this->values + i));\n    \t}\n    \treturn a;\n\t}\n};\n\nMatrix::Matrix(int row, int column) :\n        rows(row), columns(column)\n{\n\tvalues = new double [rows * columns];\n\tfor (int i = 0; i < rows * columns; ++i) {\n\t\tvalues[i] = 0;\n\t}\n}\n\nMatrix::Matrix(int nRows, int nColumns, double * values) :\n\trows(nRows), columns(nColumns)\n{\n\tthis->values = new double [rows * columns];\n\tfor (int i = 0; i < rows * columns; ++i) {\n\t\t*(this->values + i) = *(values + i);\n\t}\n}\n\nvoid Matrix::print()\n{\n\tint index, i, j;\n\tfor (i = 0, index = 0; i < this->rows; ++i) {\n\t\tfor (j = 0; j < this->columns; ++j) {\n\t\t\tcout << \"    \" << values[index];\n\t\t\t++index;\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nMatrix::~Matrix() { delete [] values; }\n",
            1590065395.0716796,
            100,
            "# 答案正确"
        ],
        [
            "6.2 (C++)",
            "彭跃江",
            "#include <iostream>\nusing namespace std;\n\ntemplate<typename T> class Matrix {\nprivate:\n    int rows;\n    int columns;\n    T * values;\npublic:\n    Matrix(int rows, int columns) :\n        rows(rows), columns(columns)\n    {\n        values = new T [rows * columns];\n        for (int i = 0; i < rows * columns; ++i)\n            values[i] = T();\n    }\n    ~Matrix() { delete [] values; }\n    void print()\n    {\n        int index = 0;\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < columns; ++j) {\n                cout << \"    \" << values[index];\n                ++index;\n            }\n            cout << endl;\n        }\n    }\n\n};\n",
            1590632189.242832,
            100,
            "# 答案正确"
        ],
        [
            "6.1 (C++)",
            "彭跃江",
            "template <typename T>\nclass Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    T * values;\npublic:\n    Matrix(int rows, int columns)\n    {\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n        values = new T [rows * columns];\n        for (int i = 0; i < rows * columns; ++i)\n            values[i] = T();\n    }\n    Matrix(int rows, int columns, const T * values)\n    {\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n        this->values = new T [rows * columns];\n        for (int i = 0; i < rows * columns; ++i)\n            this->values[i] = values[i];\n    }\n    Matrix(const Matrix<T> & matrix2) :\n        rows(matrix2.rows), columns(matrix2.columns)\n    {\n        this->values = new T [rows * columns];\n        for (int i = 0; i < rows * columns; ++i)\n            values[i] = matrix2.values[i];\n    }\n    ~Matrix() { delete [] values; }\n    Matrix<T> & operator = (const Matrix<T> & matrix2)\n    {\n        this->rows = matrix2.rows;\n        this->columns = matrix2.columns;\n        for (int i = 0; i < rows * columns; ++i)\n            this->values[i] = matrix2.values[i];\n        return *this;\n    }\n    void print()\n    {\n        int index = 0;\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < columns; ++j) {\n                cout << \"    \" << values[index];\n                index += 1;\n            }\n            cout << endl;\n        }\n    }\n    T & get(int row, int column)\n    {\n        return values[(row - 1) * this->columns + column - 1];\n    }\n};",
            1590668579.0039325,
            100,
            "# 答案正确"
        ],
        [
            "6.3 (C++)",
            "彭跃江",
            "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\ntemplate <typename T>\nclass Matrix{\nprivate:\n\tint rows;\n\tint columns;\n\tvector<T> values;\npublic:\n\tMatrix(int rows,int columns){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\t//this->values = new T(rows * columns);\n\t\tfor(int i = 0; i < rows * columns; i ++)\n\t\t\tthis->values.push_back(T());//this->values[i] = T();\n\t}\n\tMatrix(Matrix<T> & s){\n\t\tthis->rows = s.rows;\n\t\tthis->columns = s.columns;\n\t\t//this->values = new T(s.rows * s.columns);\n\t\tfor(int i = 0; i < this->rows * this->columns; i ++)\n\t\t\tthis->values.push_back(s.values[i]);//this->values[i] = s.values[i];\n\t}\n\t~Matrix(){\n\t\tthis->values.clear();//delete [] this->values;\n\t}\n\tMatrix(int rows,int columns,const vector<T> s2){\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\t//this->values = new T(rows * columns);\n\t\tfor(int i = 0 ; i < rows * columns; i ++)\n\t\t\tvalues.push_back(s2[i]);//values[i] = s2[i];\n\t}\n\tMatrix & operator =(Matrix<T> & s2){\n\t\tif(this->values.size() != 0)//if(this->values != NULL)\n\t\t\tthis->values.clear();//\tdelete [] this->values;\n\t\tthis->rows = s2.rows;\n\t\tthis->columns = s2.columns;\n\t\t//this->values = new T(this->rows * this->columns);\n\t\tfor(int i = 0; i < this->rows * this->columns;i ++)\n\t\t\tthis->values.push_back(s2.values[i]);//this->values[i] = s2.values[i];\n\t\treturn (*this);\n\t}\n\tT& get(int row, int column){\n\t\treturn values[(row-1) * this->columns + column - 1];\n\t}\n\tvoid print(){\n\t\tfor(int i = 0; i < this->rows * this->columns; i ++){\n\t\t\tif(i != 0 && i % columns == 0)\n\t\t\t\tcout << endl;\n\t\t\tcout << \"    \" << values[i];\n\t\t}\n\t\tcout << endl;\n\t}\n\tMatrix getColumn(int column){\n\t\tvector<T> store;\n\t\tfor(int i = 0; i < this->rows; i ++){\n\t\t\tstore.push_back(this->values[i * this->columns + column - 1]);\n\t\t}\n\t\tMatrix s(this->rows,1,store);\n\t\tstore.clear();\n\t\treturn s;\n\t}\n\tMatrix getRow(int row){\n\t\tvector<T> store;\n\t\tfor(int i = 0; i < this->columns; i ++){\n\t\t\tstore.push_back(this->values[(row - 1)* this->columns + i]);\n\t\t}\n\t\tMatrix s(1,this->columns,store);\n\t\tstore.clear();\n\t\treturn s;\n\t}\n\tMatrix concatenateRows(Matrix<T> & s1){\n\t\tvector<T> store;\n\t\tfor(int i = 0; i < this->values.size() + s1.values.size(); i ++){\n\t\t\tif(i < this->values.size())\n\t\t\t\tstore.push_back(this->values[i]);\n\t\t\telse\n\t\t\t\tstore.push_back(s1.values[i - this->values.size()]);\n\t\t}\n\t\tMatrix s(this->rows + s1.rows, this->columns,store);\n\t\tstore.clear();\n\t\treturn s;\n\t} \n\tMatrix concatenateColumns(Matrix<T> & s1){\n\t\tint flagrow = 0; \n\t\tint flagcolumn = 0; \n\t\tint pointrow = 0; \n\t\tint pointcolumn = 0;\n\t\tvector<T> store;\n\t\tfor(int i = 0; i < this->values.size() + s1.values.size(); i ++){\n\t\t\tif(pointcolumn == s1.columns){\n\t\t\t\tpointrow ++;\n\t\t\t\tpointcolumn = 0;\n\t\t\t}\n\t\t\tif(flagcolumn == this-> columns){\n\t\t\t\tflagrow ++;\n\t\t\t\tflagcolumn = 0;\n\t\t\t}\n\t\t\tif(i % (this->columns + s1.columns) < this->columns){\n\t\t\t\tstore.push_back(this->values[flagrow * this->columns + flagcolumn]);\n\t\t\t\tflagcolumn ++;\n\t\t\t}\t\n\t\t\telse{\n\t\t\t\tstore.push_back(s1.values[pointrow * s1.columns + pointcolumn]);\n\t\t\t\tpointcolumn ++;\n\t\t\t}\n\t\t}\n\t\tMatrix s(this->rows,this->columns + s1.columns,store);\n\t\tstore.clear();\n\t\treturn s;\n\t}\n\tMatrix reshape(int newrows,int newcolumns){\n\t\tvector<T> store;\n\t\tfor(int i = 0; i < newrows * newcolumns; i ++)\n\t\t\tstore.push_back(T());\n\t\tint flagrow = 0;\n\t\tint flagcolumn = 0;\n\t\tint pointcolumn = 0;\n\t\tint pointrow = 0;\n\t\twhile(flagcolumn < newcolumns){\n\t\t\tif(flagrow == newrows){\n\t\t\t\tflagcolumn ++;\n\t\t\t\tflagrow = 0;\n\t\t\t}\n\t\t\tif(pointrow == this->rows){\n\t\t\t\tpointcolumn ++;\n\t\t\t\tpointrow = 0;\n\t\t\t}\n\t\t\tstore[flagrow * newcolumns + flagcolumn] = this->values[pointrow * this->columns + pointcolumn];\n\t\t\tflagrow ++;\n\t\t\tpointrow ++;\n\t\t}\n\t\tMatrix s(newrows,newcolumns,store);\n\t\tstore.clear();\n\t\treturn s;\n\t}\n\tMatrix transpose(){\n\t\tvector<T> store;\n\t\tint flagrow = 0;\n\t\tint flagcolumn = 0;\n\t\tfor(int i = 0; i < this->rows * this->columns; i ++){\n\t\t\tif(flagrow == this->rows){\n\t\t\t\tflagrow = 0;\n\t\t\t\tflagcolumn ++;\n\t\t\t}\n\t\t\tstore.push_back(this->values[flagrow * this->columns + flagcolumn]);\n\t\t\tflagrow ++;\n\t\t}\n\t\tMatrix s(this->columns,this->rows,store);\n\t\tstore.clear();\n\t\treturn s;\n\t}\n\tMatrix operator +(Matrix<T> s1){\n\t\tvector<T> store;\n\t\tfor(int i = 0; i < s1.rows * s1.columns; i ++)\n\t\t\tstore.push_back(s1.values[i] + this->values[i]);\n\t\tMatrix s(s1.rows,s1.columns,store);\n\t\tstore.clear();\n\t\treturn s;\n\t}\n\tMatrix operator +(int x){\n\t\tvector<T> store;\n\t\tfor(int i = 0; i < this->rows * this->columns; i ++)\n\t\t\tstore.push_back(this->values[i] + x);\n\t\tMatrix s(this->rows, this->columns, store);\n\t\tstore.clear();\n\t\treturn s;\n\t}\n\tMatrix operator -(Matrix<T> s1){\n\t\tvector<T> store;\n\t\tfor(int i = 0; i < s1.rows * s1.columns; i ++)\n\t\t\tstore.push_back(this->values[i] - s1.values[i]);\n\t\tMatrix s(s1.rows,s1.columns,store);\n\t\tstore.clear();\n\t\treturn s;\n\t}\n\tMatrix operator -(int x){\n\t\tvector<T> store;\n\t\tfor(int i = 0; i < this->rows * this->columns; i ++)\n\t\t\tstore.push_back(this->values[i] - x);\n\t\tMatrix s(this->rows, this->columns, store);\n\t\tstore.clear();\n\t\treturn s;\n\t}\n\tMatrix operator *(int x){\n\t\tvector<T> store;\n\t\tfor(int i = 0; i < this->rows * this->columns; i ++)\n\t\t\tstore.push_back(this->values[i] * x);\n\t\tMatrix s(this->rows,this->columns,store);\n\t\tstore.clear();\n\t\treturn s;\n\t}\n\tMatrix operator *(Matrix<T> s1){\n\t\tint flagrow = 0;\n\t\tint pointcolumn = 0;\n\t\tvector<T> store;\n\t\tT cnt = T();\n\t\tfor(int i = 0; i < this->rows * s1.columns; i ++){\n\t\t\tif(pointcolumn == s1.columns){\n\t\t\t\tpointcolumn = 0;\n\t\t\t\tflagrow ++;\n\t\t\t}\n\t\t\tfor(int j = 0; j < this->columns; j ++){\n\t\t\t\tcnt += this->values[flagrow * this->columns + j] * s1.values[j * s1.columns + pointcolumn];\n\t\t\t}\n\t\t\tpointcolumn ++;\n\t\t\tstore.push_back(cnt);\n\t\t\tcnt = T();\n\t\t}\n\t\tMatrix s(this->rows, s1.columns,store);\n\t\tstore.clear();\n\t\treturn s;\n\t}\n\tMatrix max(){\n\t\tif(this->rows == 1){\n\t\t\tT cnt = this->values[0];\n\t\t\tvector<T> store;\n\t\t\tfor(int i = 1; i < this->columns; i ++){\n\t\t\t\tif(cnt < this->values[i])\n\t\t\t\t\tcnt = this->values[i];\n\t\t\t}\n\t\t\tstore.push_back(cnt);\n\t\t\tMatrix s(1,1,store);\n\t\t\tstore.clear();\n\t\t\treturn s;\n\t\t}\n\t\telse{\n\t\t\tvector<T> store;\n\t\t\tfor(int i = 0; i < this->columns; i ++){\n\t\t\t\tT cnt = this->values[i];\n\t\t\t\tfor(int j = 1; j < this->rows; j ++){\n\t\t\t\t\tif(cnt < this->values[j * this->columns + i])\n\t\t\t\t\t\tcnt = this->values[j * this->columns + i];\n\t\t\t\t}\n\t\t\t\tstore.push_back(cnt);\n\t\t\t}\n\t\t\tMatrix s(1,this->columns,store);\n\t\t\tstore.clear();\n\t\t\treturn s;\n\t\t}\n\t}\n\tMatrix min(){\n\t\tif(this->rows == 1){\n\t\t\tT cnt = this->values[0];\n\t\t\tvector<T> store;\n\t\t\tfor(int i = 1; i < this->columns; i ++){\n\t\t\t\tif(cnt > this->values[i])\n\t\t\t\t\tcnt = this->values[i];\n\t\t\t}\n\t\t\tstore.push_back(cnt);\n\t\t\tMatrix s(1,1,store);\n\t\t\tstore.clear();\n\t\t\treturn s;\n\t\t}\n\t\telse{\n\t\t\tvector<T> store;\n\t\t\tfor(int i = 0; i < this->columns; i ++){\n\t\t\t\tT cnt = this->values[i];\n\t\t\t\tfor(int j = 1; j < this->rows; j ++){\n\t\t\t\t\tif(cnt > this->values[j * this->columns + i])\n\t\t\t\t\t\tcnt = this->values[j * this->columns + i];\n\t\t\t\t}\n\t\t\t\tstore.push_back(cnt);\n\t\t\t}\n\t\t\tMatrix s(1,this->columns,store);\n\t\t\tstore.clear();\n\t\t\treturn s;\n\t\t}\n\t}\n\tMatrix sum(){\n\t\tif(this->rows == 1){\n\t\t\tT cnt = T();\n\t\t\tvector<T> store;\n\t\t\tfor(int i = 0; i < this->columns; i ++)\n\t\t\t\tcnt += this->values[i];\n\t\t\tstore.push_back(cnt);\n\t\t\tMatrix s(1,1,store);\n\t\t\tstore.clear();\n\t\t\treturn s;\n\t\t}\n\t\telse{\n\t\t\tT cnt = T();\n\t\t\tvector<T> store;\n\t\t\tfor(int i = 0; i < this->columns; i ++){\n\t\t\t\tfor(int j = 0; j < this->rows; j ++){\n\t\t\t\t\tcnt += this->values[j * this->columns + i];\n\t\t\t\t}\n\t\t\t\tstore.push_back(cnt);\n\t\t\t\tcnt = T();\n\t\t\t}\n\t\t\tMatrix s(1,this->columns,store);\n\t\t\tstore.clear();\n\t\t\treturn s;\n\t\t}\n\t}\n};",
            1590668593.2713065,
            100,
            "# 答案正确"
        ],
        [
            "7.2 (C++)",
            "彭跃江",
            "#include <string>\n#include <vector>\n\nstd::vector<std::string> split (const std::string & line, const std::string & delimiter = \" \")\n{\n    std::vector<std::string> words;\n    int st = 0;\n    while (st < line.size() ) {\n        int end = line.find(delimiter, st);\n        if (end == st) st += delimiter.size();\n        else {\n            if (end == -1) {\n                words.push_back(line.substr(st));\n                break;\n            }\n            words.push_back(line.substr(st, end-st));\n            st = end + delimiter.size();\n        }\n    }\n    return words;\n}\n",
            1591239849.1725988,
            100,
            "# 答案正确"
        ],
        [
            "7.1 (C++)",
            "彭跃江",
            "#include <cmath>\n\nclass Triangle : public GeometricObject\n{\nprivate:\n    double side1 = 1;\n    double side2 = 1;\n    double side3 = 1;\npublic:\n    Triangle(double s1 = 1, double s2 = 1, double s3 = 1) :\n        side1(s1), side2(s2), side3(s3) { }\n    double getSide1() { return side1; }\n    double getSide2() { return side2; }\n    double getSide3() { return side3; }\n    double getArea()\n    {\n        double s, area;\n        s = (side1 + side2 + side3) / 2;\n        area = sqrt(s * (s - side1) * (s - side2) * (s - side3));\n        return area;\n    }\n    double getPerimeter() { return side1 + side2 + side3; }\n};",
            1591272401.391032,
            100,
            "# 答案正确"
        ],
        [
            "7.3 (C++)",
            "彭跃江",
            "template <typename A, typename R>\nvector<R> map2(const vector<A> & x, const vector<A> & y, R (*map_func)(const A &, const A &)) {\n    vector<R> res;\n    for (int i = 0; i < x.size(); ++ i)\n        res.push_back(map_func(x[i], y[i]));\n    return res;\n}\n\ntemplate <typename A, typename R>\nvector<R> map2(const vector<A> & x, const int y, R (*map_func)(const A &, const A &)) {\n    vector<R> res;\n    for (int i = 0; i < x.size(); ++ i)\n        res.push_back(map_func(x[i], y));\n    return res;\n}\n",
            1591272423.4067233,
            100,
            "# 答案正确"
        ],
        [
            "8.5 (C++)",
            "彭跃江",
            "class Point3D : public Point2D\n{\nprivate:\n    double z;\npublic:\n    Point3D() : Point2D()\n\t{\n\t\tz = 0;\n\t}\n    Point3D(double x, double y, double z)\n    {\n        setX(x);\n        setY(y);\n\t\tsetZ(z);\n    }\n    double getZ()\n\t{\n\t\treturn z;\n\t}\n    void setZ(double z)\n\t{\n\t\tthis->z = z;\n\t}\n    double distance(Point2D & point2)\n    {\n        Point3D & ptr = dynamic_cast<Point3D &>(point2);\n        double dx = getX() - point2.getX();\n        double dy = getY() - point2.getY();\n        double dz = getZ() - ptr.getZ();\n        return sqrt(dx * dx + dy * dy + dz * dz);\n    }\n};",
            1591843403.6602342,
            100,
            "# 答案正确"
        ],
        [
            "8.1 (C++)",
            "彭跃江",
            "class Full : public Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    double * values;\npublic:\n    Full() = default;\n    Full(int rows, int columns)\n    {\n\t\t\tthis->rows = rows;\n\t\t\tthis->columns = columns;\n        values = new double [rows * columns];\n        for (int i = 0; i < rows * columns; ++i)\n            *(values + i) = 0;\n    }\n    Full(int rows, int columns, double * values) :\n        rows(rows), columns(columns)\n    {\n        this->values = new double [rows * columns];\n        for (int i = 0; i < rows * columns; ++i)\n            *(this->values + i) = *(values + i);\n    }\n    Full(const Matrix & matrix2)\n    {\n        rows = matrix2.size(1);\n        columns = matrix2.size(2);\n        values = new double [rows * columns];\n        for (int i = 0; i < rows; ++i)\n            for (int j = 0; j < columns; ++j)\n                *(values + (i * columns) + j) = matrix2.get(i, j);\n    }\n    ~Full() { delete [] this->values; }\n    int size(int demension) const\n    {\n        switch (demension)\n        {\n            case 1:\n                return rows;\n            case 2:\n                return columns;\n        }\n    }\n    double get(int row, int column) const\n    {\n        return *(values + row * columns + column);\n    }\n    void print() const\n    {\n        int cnt = 0;\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < columns; ++j) {\n                cout << \"    \" << *(values + cnt);\n                ++cnt;\n            }\n            cout << endl;\n        }\n    }\n    Matrix & operator = (const Matrix & matrix2)\n    {\n        int cnt = 0;\n        this->rows = matrix2.size(1);\n        this->columns = matrix2.size(2);\n        // this->values = new double [this->rows * this->columns];\n        for (int i = 0; i < this->rows; ++i)\n            for (int j = 0; j < this->columns; ++j) {\n                *(values + cnt) = matrix2.get(i, j);\n                ++cnt;\n            }\n        return *(this);\n    }\n    void set(int row, int column, double value)\n    {\n        *(this->values + (row - 1) * columns + column - 1) = value;\n    }\n};",
            1591872799.7668858,
            100,
            "# 答案正确"
        ],
        [
            "8.3 (C++)",
            "彭跃江",
            "#include <iostream>\n#include <vector>\n\nclass Sparse : public Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    std::vector<Entry> values;\n    size_t values_max = 10;\n    size_t values_curt = 0;\npublic:\n    Sparse(int rows, int columns) : rows(rows), columns(columns) { }\n    Sparse & operator + (const Sparse & matrix2)\n    {\n        for (int i = 0; i < values_curt; ++i) {\n            for (int j = 0; j < matrix2.values_curt; ++j) {\n                if (values[i].row == matrix2.values[j].row && values[i].column == matrix2.values[j].column)\n                    values[i].value += matrix2.values[j].value;\n            }\n        }\n        for (int i = 0; i < matrix2.values_curt; ++i) {\n            int ifFound = 0;\n            for (int j = 0; j < values_curt; ++j) {\n                if (matrix2.values[i].row == values[j].row && matrix2.values[i].column == values[j].column)\n                    ifFound = 1;\n            }\n            if (ifFound == 0)\n                set(matrix2.values[i].row, matrix2.values[i].column, matrix2.values[i].value);\n        }\n        return *(this);\n    }\n    int size(int dimension) const\n    {\n        switch (dimension) {\n            case 1:\n                return this->rows;\n                break;\n            case 2:\n                return this->columns;\n            default:\n                return 0;\n                break;\n        }\n    }\n    void set(int row, int column, double value)\n    {\n        Entry val;\n        val.row = row;\n        val.column = column;\n        val.value = value;\n        if (value != 0 && values_curt <= values_max){\n            values.push_back(val);\n            ++values_curt;\n        }\n    }\n    double get(int row, int column) const\n    {\n        for (int i = 0; i < values_max; ++i) {\n            if (values[i].row == row && values[i].column == column)\n                return values[i].value;\n        }\n        return 0;\n    }\n    void print()\n    {\n        for (int i = 0; i < values_curt; ++i) {\n            for (int j = 0; j < values_curt - 1; ++j) {\n                if (values[j].row > values[j + 1].row) {\n                    Entry temp = values[j];\n                    values[j] = values[j + 1];\n                    values[j + 1] = temp;\n                } else if (values[j].row == values[j + 1].row && values[j].column > values[j + 1].column) {\n                    Entry temp = values[j];\n                    values[j] = values[j + 1];\n                    values[j + 1] = temp;\n                }\n            }\n        }\n        for (int i = 0; i < values_curt; ++i) {\n            if (values[i].row > 0 && values[i].column > 0 && values[i].value != 0)\n                std::cout << '(' << values[i].row << ',' << values[i].column << ',' << values[i].value\n                << ')' << std::endl;\n        }\n    }\n};",
            1591872842.8275867,
            100,
            "# 答案正确"
        ],
        [
            "8.4 (C++)",
            "彭跃江",
            "#include <vector>\n#include <iostream>\n\nclass Sparse : public Matrix\n{\nprivate:\n    int rows;\n    int columns;\n    std::vector<Entry> values;\n    size_t values_max = 10;\n    size_t values_curt = 0;\npublic:\n    Sparse(int rows, int columns) : rows(rows), columns(columns) { }\n    Sparse & operator * (const Sparse & matrix2)\n    {\n        Sparse matrix3(rows, matrix2.columns);\n        for (int i = 0; i < values_curt; ++i) {\n            int ifFound = 0;\n            for (int j = 0; j < matrix2.values_curt; ++j) {\n                if (values[i].column == matrix2.values[j].row) {\n                    for (int k = 1; k <= matrix3.values_curt; ++k) {\n                        if (matrix3.values[k - 1].row == values[i].row && matrix3.values[k - 1].column == matrix2.values[j].column)\n                            ifFound = k;\n                    }\n                    if (ifFound == 0)\n                        matrix3.set(values[i].row, matrix2.values[j].column, values[i].value * matrix2.values[j].value);\n                    else\n                        matrix3.values[ifFound - 1].value += values[i].value * matrix2.values[j].value;\n                }\n            }\n        }\n//        *(this) = matrix3;\n//        return *(this);\n        static Sparse matrix4 = matrix3;\n        return matrix4;\n    }\n    int size(int dimension) const\n    {\n        switch (dimension) {\n            case 1:\n                return this->rows;\n                break;\n            case 2:\n                return this->columns;\n            default:\n                return 0;\n                break;\n        }\n    }\n    void set(int row, int column, double value)\n    {\n        Entry val;\n        val.row = row;\n        val.column = column;\n        val.value = value;\n        if (value != 0 && values_curt <= values_max){\n            values.push_back(val);\n            ++values_curt;\n        }\n    }\n    double get(int row, int column) const\n    {\n        for (int i = 0; i < values_max; ++i) {\n            if (values[i].row == row && values[i].column == column)\n                return values[i].value;\n        }\n        return 0;\n    }\n    void print()\n    {\n        for (int i = 0; i < values_curt; ++i) {\n            for (int j = 0; j < values_curt - 1; ++j) {\n                if (values[j].row > values[j + 1].row) {\n                    Entry temp = values[j];\n                    values[j] = values[j + 1];\n                    values[j + 1] = temp;\n                } else if (values[j].row == values[j + 1].row && values[j].column > values[j + 1].column) {\n                    Entry temp = values[j];\n                    values[j] = values[j + 1];\n                    values[j + 1] = temp;\n                }\n            }\n        }\n        for (int i = 0; i < values_curt; ++i) {\n            if (values[i].row > 0 && values[i].column > 0 && values[i].value != 0)\n                std::cout << '(' << values[i].row << ',' << values[i].column << ',' << values[i].value\n                          << ')' << std::endl;\n        }\n    }\n};",
            1591872864.2525764,
            100,
            "# 答案正确"
        ],
        [
            "8.6 (C++)",
            "彭跃江",
            "#include <iostream>\n#include <vector>\nusing namespace std;\nclass MyTensor:public Tensor<double>{\nprivate:\n    vector<double> values;\npublic:\n    MyTensor(vector<int> sizes):Tensor<double>(sizes) {\n        int sum = 1;\n        for(int i = 0;i < sizes.size();i++){\n            sum *= sizes[i];\n        }\n        for(int i = 0;i < sum;i++){\n            values.push_back(0);\n        }\n    }\n    virtual double & get(const vector<int> & indexes){\n        int index = indexes[0];\n        for(int i = 1;i < indexes.size();i++){\n            index = sizes[i] *  index + indexes[i];\n        }\n        return values[index];\n    }\n};",
            1592451587.4667087,
            100,
            "# 答案正确"
        ],
        [
            "9.1 (C++)",
            "彭跃江",
            "class Circle\n{\nprivate:\n    double radii;\npublic:\n    Circle(double radius) : radii(radius) { }\n    int operator < (Circle & circle2)\n    {\n        return this->radii < circle2.radii ? 1 : 0;\n    }\n    int operator <= (Circle & circle2)\n    {\n        return this->radii <= circle2.radii ? 1 : 0;\n    }\n    int operator == (Circle & circle2)\n    {\n        return this->radii == circle2.radii ? 1 : 0;\n    }\n    int operator != (Circle & circle2)\n    {\n        return this->radii != circle2.radii ? 1 : 0;\n    }\n    int operator > (Circle & circle2)\n    {\n        return this->radii > circle2.radii ? 1 : 0;\n    }\n    int operator >= (Circle & circle2)\n    {\n        return this->radii >= circle2.radii ? 1 : 0;\n    }\n};",
            1593086957.1047814,
            100,
            "# 答案正确"
        ],
        [
            "9.2 (C++)",
            "彭跃江",
            "class I : public vector<int>//, Tensor\n{\npublic:\n    I(int x, int y = -1, int z = -1, int w = -1)\n    {\n        this->push_back(x);\n        if (y != -1)\n            this->push_back(y);\n        if (z != -1)\n            this->push_back(z);\n        if (w != -1)\n            this->push_back(w);\n    }\n};",
            1593086980.3700085,
            100,
            "# 答案正确"
        ],
        [
            "9.3 (C++)",
            "彭跃江",
            "class Complex\n{\nprivate:\n    double re;\n    double im;\npublic:\n    Complex() = default;\n    Complex(double real = 0, double imag = 0) :\n        re(real), im(imag) { }\n    Complex(const Complex & complex2) :\n        re(complex2.real()), im(complex2.imag()) { }\n    Complex operator + (const Complex & complex2) const\n    {\n        Complex complex(0, 0);\n        complex.re = this->re + complex2.re;\n        complex.im = this->im + complex2.im;\n        return complex;\n    }\n    Complex operator - (const Complex & complex2) const\n    {\n        Complex complex(0, 0);\n        complex.re = this->re - complex2.re;\n        complex.im = this->im - complex2.im;\n        return complex;\n    }\n    Complex operator * (const Complex & complex2) const\n    {\n        Complex complex(0, 0);\n        complex.re = this->re * complex2.re - this->im * complex2.im;\n        complex.im = this->re * complex2.im + this->im * complex2.re;\n        return complex;\n    }\n    Complex operator / (const Complex & complex2) const\n    {\n        Complex complex(0, 0);\n        complex.re = (this->re * complex2.re + this->im * complex2.im) / (complex2.im * complex2.im + complex2.re * complex2.re);\n        complex.im = (this->im * complex2.re - this->re * complex2.im) / (complex2.im * complex2.im + complex2.re * complex2.re);\n        return complex;\n    }\n    Complex & operator += (const Complex & complex2)\n    {\n        this->re += complex2.re;\n        this->im += complex2.im;\n        return (*this);\n    }\n    Complex & operator -= (const Complex & complex2)\n    {\n        this->re -= complex2.re;\n        this->im -= complex2.im;\n        return (*this);\n    }\n    Complex & operator *= (const Complex & complex2)\n    {\n        (*this) = (*this) * complex2;\n        return (*this);\n    }\n    Complex & operator /= (const Complex & complex2)\n    {\n        (*this) = (*this) / complex2;\n        return (*this);\n    }\n    bool operator == (const Complex & complex2) const\n    {\n        return this->re == complex2.re && this->im == complex2.im ? true : false;\n    }\n    bool operator != (const Complex & complex2) const\n    {\n        return this->re != complex2.re || this->im != complex2.im ? true : false;\n    }\n    double real() const { return this->re; }\n    double imag() const { return this->im; }\n};\n\nComplex operator + (const double num, const Complex & complex2)\n{\n    Complex complex(complex2.real() + num, complex2.imag());\n    return complex;\n}\nComplex operator - (const Complex & complex2, const double num)\n{\n    Complex complex(complex2.real() - num, complex2.imag());\n    return complex;\n}\n",
            1593087016.524303,
            100,
            "# 答案正确"
        ],
        [
            "9.4 (C++)",
            "彭跃江",
            "class Complex\n{\nprivate:\n    double re;\n    double im;\npublic:\n    Complex(double real = 0, double imag = 0) :\n            re(real), im(imag) { }\n    Complex(const Complex & complex2) :\n            re(complex2.re), im(complex2.im) { }\n    Complex operator + (const Complex & complex2) const\n    {\n        Complex complex(0, 0);\n        complex.re = this->re + complex2.re;\n        complex.im = this->im + complex2.im;\n        return complex;\n    }\n    Complex operator - (const Complex & complex2) const\n    {\n        Complex complex(0, 0);\n        complex.re = this->re - complex2.re;\n        complex.im = this->im - complex2.im;\n        return complex;\n    }\n    friend istream & operator >> (istream &, Complex &);\n    friend ostream & operator << (ostream &, Complex &);\n};\n\nistream & operator >> (istream & in, Complex & complex2)\n{\n    in >> complex2.re >> complex2.im;\n    return in;\n}\nostream & operator << (ostream & out, Complex & complex2)\n{\n    out << complex2.re << \" + \" << complex2.im << \" i\";\n    return out;\n}",
            1593087132.2519822,
            100,
            "# 答案正确"
        ],
        [
            "9.5 (C++)",
            "彭跃江",
            "class Complex\n{\nprivate:\n    double re;\n    double im;\npublic:\n    Complex(double real = 0, double imag = 0) :\n            re(real), im(imag) { }\n    Complex(const Complex & complex2) :\n            re(complex2.re), im(complex2.im) { }\n    Complex & operator ++ ()\n    {\n        ++this->re;\n        return (*this);\n    }\n    Complex & operator ++ (int)\n    {\n        static Complex prev(*this);\n        this->re++;\n        return (Complex&)prev;\n    }\n    operator double ()\n    {\n        return re;\n    }\n    friend istream & operator >> (istream &, Complex &);\n    friend ostream & operator << (ostream &, Complex &);\n};\n\nistream & operator >> (istream & in, Complex & complex2)\n{\n    in >> complex2.re >> complex2.im;\n    return in;\n}\nostream & operator << (ostream & out, Complex & complex2)\n{\n    out << complex2.re << \" + \" << complex2.im << \" i\";\n    return out;\n}",
            1593087375.8102906,
            100,
            "# 答案正确"
        ],
        [
            "9.6 (C++)",
            "彭跃江",
            "class Tensor\n{\nprivate:\n    vector<int> size;\n    double * values;\npublic:\n    Tensor(int x, int y = -1, int z = -1, int w = -1)\n    {\n            size.push_back(x);\n        if (y != -1)\n            size.push_back(y);\n        if (z != -1)\n            size.push_back(z);\n        if (w != -1)\n            size.push_back(w);\n        values = new double [abs(x * y * z * w)];\n    }\n    ~Tensor() { delete [] values; }\n    double & operator () (int x, int y = -1, int z = -1, int w = -1)\n    {\n        int index = 0;\n        switch (size.size()) {\n            case 4:\n                index = w + z * size[3] + y * size[2] * size[3] + x * size[1] * size[2] * size[3];\n                break;\n            case 3:\n                index = z + y * size[2] + x * size[1] * size[2];\n                break;\n            case 2:\n                index = y + x * size[1];\n                break;\n            case 1:\n                index = x;\n                break;\n            default:\n                index = 0;\n        }\n        return values[index];\n    }\n};",
            1593087179.870113,
            100,
            "# 答案正确"
        ],
        [
            "9.7 (C++)",
            "彭跃江",
            "#include <cmath>\n\nclass Tensor\n{\nprivate:\n    int dim;\n    vector<int> size;\n    double * values;\npublic:\n    Tensor() = default;\n    ~Tensor() { delete [] values; }\n    double & operator () (int x, int y = -1, int z = -1, int w = -1)\n    {\n        int index = 0;\n        switch (size.size()) {\n            case 4:\n                index = w + z * size[3] + y * size[2] * size[3] + x * size[1] * size[2] * size[3];\n                break;\n            case 3:\n                index = z + y * size[2] + x * size[1] * size[2];\n                break;\n            case 2:\n                index = y + x * size[1];\n                break;\n            case 1:\n                index = x;\n                break;\n            default:\n                index = 0;\n        }\n        return values[index];\n    }\n    friend istream & operator >> (istream &, Tensor &);\n    friend ostream & operator << (ostream &, Tensor &);\n};\n\nistream & operator >> (istream & in, Tensor & matrix)\n{\n    in >> matrix.dim;\n    for (int i = 0; i < matrix.dim; ++i) {\n        int sizes = 0;\n        in >> sizes;\n        matrix.size.push_back(sizes);\n    }\n    int sizes = 1;\n    for (int i = 0; i < matrix.dim; ++i) {\n        sizes *= matrix.size[i];\n    }\n    matrix.values = new double [sizes];\n\n    for (int i = 0; i < sizes; ++i) {\n        in >> *(matrix.values + i);\n    }\n    return in;\n}\nostream & operator << (ostream & out, Tensor & matrix)\n{\n    out << matrix.dim << endl;\n    for (int i = 0; i < matrix.dim; ++i)\n        out << matrix.size[i] << ' ';\n    out << endl << endl;\n    int cnt = 0;\n    int times = 1;\n    if (matrix.dim == 4)\n        times = matrix.size[0] * matrix.size[1];\n    else if (matrix.dim == 3)\n        times = matrix.size[0];\n    for (int index = 0; index < times; ++index) {\n        for (int i = 0; i < matrix.size[matrix.dim - 2]; ++i) {\n            for (int j = 0; j < matrix.size[matrix.dim - 1]; ++j) {\n                out << *(matrix.values + cnt) << ' ';\n                ++cnt;\n            }\n            out << endl;\n        }\n        out << endl;\n    }\n    return out;\n}",
            1593087202.5500965,
            100,
            "# 答案正确"
        ],
        [
            "10.1 (C++)",
            "彭跃江",
            "#include <stdexcept>\n\nclass MatrixSizesDoNotMatchException {};\n\ndouble Matrix::get(int row, int column) const\n{\n    if (row > this->rows || column > this->columns)\n        throw out_of_range(\"index\");\n    else {\n        return this->elements[column - 1 + (row - 1) * this->size(2)];\n    }\n}\n\nvoid Matrix::set(int row, int column, double value)\n{\n    if (row > this->rows || column > this->columns)\n        throw MatrixSizesDoNotMatchException();\n    else {\n        this->elements[column - 1 + (row - 1) * this->size(2)] = value;\n    }\n}\n\nMatrix Matrix::operator + (const Matrix & matrix2) const\n{\n    if (this->rows != matrix2.rows || this->columns != matrix2.columns)\n        throw MatrixSizesDoNotMatchException();\n    else {\n        Matrix matrix(rows, columns);\n        for (int i = 0; i < rows; ++ i) {\n            for (int j = 0; j < columns; ++ j) {\n                double value;\n                value = this->get(i + 1, j + 1) + matrix2.get(i + 1, j + 1);\n                matrix.set(i + 1, j + 1, value);\n            }\n        }\n        return matrix;\n    }\n}",
            1593659377.773693,
            100,
            "# 答案正确"
        ],
        [
            "10.2 (C++)",
            "彭跃江",
            "catch(out_of_range & ex) {\n    string er = ex.what();\n    if ( er == \"index\" )\n        cout << \"caught: out_of_range\" << endl;\n    else\n    \tcout << \"caught: NonPositiveValueException\" << endl;\n}",
            1593659538.2766898,
            100,
            "# 答案正确"
        ],
        [
            "2020-07-09 LAB",
            "彭跃江",
            "#include <iostream>\nusing namespace std;\n\nclass Integer {\nprivate:\n    int x;\npublic:\n    static int sum;\n    Integer(): x(0) {}\n    Integer(int x): x(x) {}\n\n    static void increase_all(int other) {\n        sum += other;\n    }\n\n    static void increase_all(Integer & other) {\n        int y = other.x;\n        sum = sum + sum + y;\n    }\n\n    friend istream & operator >> (istream & in, Integer & other) {\n        in >> other.x;\n        return in;\n    }\n\n    friend ostream & operator << (ostream & out, const Integer & other) {\n        out << other.x + sum;\n        return out;\n    }\n};\n\nint Integer::sum = 0;",
            1594265698.7577019,
            100,
            "# 答案正确"
        ]
    ],
    "table_name": "答案"
}