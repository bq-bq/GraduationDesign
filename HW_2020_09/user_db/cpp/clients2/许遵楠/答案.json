{
    "__update_time__": 1595470613.8826592,
    "field_names": [
        "题目名",
        "用户名",
        "答案",
        "提交时间",
        "分数",
        "评语"
    ],
    "field_types": [
        "text",
        "text",
        "text",
        "time",
        "number",
        "text"
    ],
    "foreign_keys": {},
    "primary_keys": [],
    "rows": [
        [
            "测试1",
            "许遵楠",
            "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\n\tstring w1, w2, w3;\n\tcin >> w1 >> w2 >> w3;\n\tcout << w3 << ' ' << w2 << ' ' << w1;\n\treturn 0;\n}",
            1587517955.0,
            100,
            "# 答案正确"
        ],
        [
            "测试2",
            "许遵楠",
            "#include <iostream>\n#include <string>\nusing namespace std;\nvoid sort(string *s) {\n    string tmp;\n    for (int i = 0; i < 10; ++i)\n        for (int j = 0; j < 9 - i; ++j)\n            if (s[j] > s[j + 1]) {\n                tmp = s[j];\n                s[j] = s[j + 1];\n                s[j + 1] = tmp;\n            }\n}\nint main() {\n    string s[10];\n    for (int i = 0; i < 10; ++i)\n        cin >> s[i];\n    sort(s);\n    for (int i = 0; i < 10; ++i)\n        cout << s[i] << ' ';\n    return 0;\n}",
            1587608595.032594,
            100,
            "# 答案正确"
        ],
        [
            "1.1 (C++)",
            "许遵楠",
            "class Matrix5x5 {\n  public:\n    Matrix5x5() {\n        for (int i = 0; i < 5; ++i)\n            for (int j = 0; j < 5; ++j)\n                mat[i][j] = 0;\n    }\n    double get(int i, int j) {\n        return mat[i][j];\n    }\n    void set(int i, int j, double val) {\n        mat[i][j] = val;\n    }\n\n  private:\n    double mat[5][5];\n};\nMatrix5x5 operator+(Matrix5x5 &mat1, Matrix5x5 &mat2) {\n    Matrix5x5 tmp;\n    for (int i = 0; i < 5; ++i)\n        for (int j = 0; j < 5; ++j)\n            tmp.set(i, j, mat1.get(i, j) + mat2.get(i, j));\n    return tmp;\n}",
            1587696734.5736623,
            100,
            "# 答案正确"
        ],
        [
            "1.2 (C++)",
            "许遵楠",
            "#include <iostream>\n#include <string>\nusing namespace std;\nclass School {\n  public:\n    School() {\n        this->age = 0;\n        this->name = \"NO_NAME\";\n    }\n    void setName(char name[]) {\n        this->name = name;\n    }\n    void setAge(int age) {\n        this->age = age;\n    }\n    void operator++() {\n        ++this->age;\n    }\n\n    string name;\n    int age;\n};",
            1588212611.1612322,
            100,
            "# 答案正确"
        ],
        [
            "2.1 (C++)",
            "许遵楠",
            "#include <iostream>\nusing namespace std;\nclass Matrix {\n  public:\n    Matrix() {\n        rows = columns = 0;\n        values = 0;\n    }\n    Matrix(int r, int c) {\n        rows = r;\n        columns = c;\n        values = new double[r * c];\n        for (int i = 0; i < r; ++i)\n            for (int j = 0; j < c; ++j)\n                values[i * columns + j] = 0;\n    }\n    ~Matrix() {\n        if (values != 0)\n            delete[] values;\n    }\n    void print() {\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < columns; ++j)\n                cout << \"    \" << values[i * columns + j];\n            cout << endl;\n        }\n    }\n\n  private:\n    int rows, columns;\n    double *values;\n};",
            1588825139.4148598,
            100,
            "# 答案正确"
        ],
        [
            "2.2 (C++)",
            "许遵楠",
            "#include <iomanip>\n#include <iostream>\nusing namespace std;\nclass Matrix {\n  public:\n    Matrix() {\n        rows = columns = 0;\n        values = 0;\n    }\n    Matrix(int r, int c, double *val) {\n        rows = r;\n        columns = c;\n        values = new double[r * c];\n        for (int i = 0; i < r; ++i)\n            for (int j = 0; j < c; ++j)\n                values[i * columns + j] = val[i * columns + j];\n    }\n    ~Matrix() {\n        if (values != 0)\n            delete[] values;\n    }\n    void print() {\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < columns; ++j)\n                cout << setw(5) << values[i * columns + j];\n            cout << endl;\n        }\n    }\n\n  private:\n    double *values;\n    int rows, columns;\n};",
            1588825417.5190067,
            100,
            "# 答案正确"
        ],
        [
            "2.3 (C++)",
            "许遵楠",
            "#include <iostream>\nusing namespace std;\nclass Matrix {\n  public:\n    Matrix() {\n        rows = columns = 0;\n        values = 0;\n    }\n    Matrix(int r, int c, double *val) {\n        rows = r;\n        columns = c;\n        values = new double[r * c];\n        for (int i = 0; i < r; ++i)\n            for (int j = 0; j < c; ++j)\n                values[i * columns + j] = val[i * columns + j];\n    }\n    Matrix(const Matrix &matrix2) {\n        rows = matrix2.get_r();\n        columns = matrix2.get_c();\n        values = new double[rows * columns];\n        for (int i = 0; i < rows; ++i)\n            for (int j = 0; j < columns; ++j)\n                values[i * columns + j] = matrix2.get_v(i, j);\n    }\n    ~Matrix() {\n        if (values != 0)\n            delete[] values;\n    }\n    int get_r() const {\n        return rows;\n    }\n    int get_c() const {\n        return columns;\n    }\n    double get_v(int i, int j) const {\n        return values[i * columns + j];\n    }\n    void print() {\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < columns; ++j)\n                cout << \"    \" << values[i * columns + j];\n            cout << endl;\n        }\n    }\n\n  private:\n    int rows, columns;\n    double *values;\n};",
            1588826035.4439518,
            100,
            "# 答案正确"
        ],
        [
            "2.5 (C++)",
            "许遵楠",
            "#include <iostream>\nusing namespace std;\nclass Matrix {\n  public:\n    Matrix() {\n        rows = columns = 0;\n        values = 0;\n    }\n    Matrix(int r, int c) {\n        rows = r;\n        columns = c;\n        values = new double[r * c];\n        for (int i = 0; i < r; ++i)\n            for (int j = 0; j < c; ++j)\n                values[i * columns + j] = 0;\n    }\n    Matrix(int r, int c, double *val) {\n        rows = r;\n        columns = c;\n        values = new double[r * c];\n        for (int i = 0; i < r; ++i)\n            for (int j = 0; j < c; ++j)\n                values[i * columns + j] = val[i * columns + j];\n    }\n    Matrix(const Matrix &matrix2) {\n        rows = matrix2.get_r();\n        columns = matrix2.get_c();\n        values = new double[rows * columns];\n        for (int i = 0; i < rows; ++i)\n            for (int j = 0; j < columns; ++j)\n                values[i * columns + j] = matrix2.get_v(i, j);\n    }\n    ~Matrix() {\n        if (values != 0)\n            delete[] values;\n    }\n    int get_r() const {\n        return rows;\n    }\n    int get_c() const {\n        return columns;\n    }\n    double get_v(int i, int j) const {\n        return values[i * columns + j];\n    }\n    void set_v(int i, double val) {\n        values[i] = val;\n    }\n    void print() {\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < columns; ++j)\n                cout << \"    \" << values[i * columns + j];\n            cout << endl;\n        }\n    }\n    Matrix getRow(int row) {\n        Matrix gr = Matrix(1, columns);\n        for (int i = 0; i < columns; ++i)\n            gr.set_v(i, get_v(row - 1, i));\n        return gr;\n    }\n    Matrix getColumn(int columns) {\n        Matrix gc = Matrix(rows, 1);\n        for (int i = 0; i < rows; ++i)\n            gc.set_v(i, get_v(i, columns - 1));\n        return gc;\n    }\n\n  private:\n    int rows, columns;\n    double *values;\n};",
            1588826962.357066,
            100,
            "# 答案正确"
        ],
        [
            "2.6 (C++)",
            "许遵楠",
            "#include <iostream>\nusing namespace std;\nclass Matrix {\n  public:\n    Matrix() {\n        rows = columns = 0;\n        values = 0;\n    }\n    Matrix(int r, int c) {\n        rows = r;\n        columns = c;\n        values = new double[r * c];\n        for (int i = 0; i < r; ++i)\n            for (int j = 0; j < c; ++j)\n                values[i * columns + j] = 0;\n    }\n    Matrix(int r, int c, double *val) {\n        rows = r;\n        columns = c;\n        values = new double[r * c];\n        for (int i = 0; i < r; ++i)\n            for (int j = 0; j < c; ++j)\n                values[i * columns + j] = val[i * columns + j];\n    }\n    Matrix(const Matrix &matrix2) {\n        rows = matrix2.get_r();\n        columns = matrix2.get_c();\n        values = new double[rows * columns];\n        for (int i = 0; i < rows; ++i)\n            for (int j = 0; j < columns; ++j)\n                values[i * columns + j] = matrix2.get_v(i, j);\n    }\n    ~Matrix() {\n        if (values != 0)\n            delete[] values;\n    }\n    int get_r() const {\n        return rows;\n    }\n    int get_c() const {\n        return columns;\n    }\n    double get_v(int i, int j) const {\n        return values[i * columns + j];\n    }\n    void set_v(int i, double val) {\n        values[i] = val;\n    }\n    void print() {\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < columns; ++j)\n                cout << \"    \" << values[i * columns + j];\n            cout << endl;\n        }\n    }\n    Matrix getRow(int row) {\n        Matrix gr = Matrix(1, columns);\n        for (int i = 0; i < columns; ++i)\n            gr.set_v(i, get_v(row - 1, i));\n        return gr;\n    }\n    Matrix getColumn(int columns) {\n        Matrix gc = Matrix(rows, 1);\n        for (int i = 0; i < rows; ++i)\n            gc.set_v(i, get_v(i, columns - 1));\n        return gc;\n    }\n    Matrix concatenateRows(const Matrix &matrix2) const {\n        Matrix con = Matrix(rows + matrix2.get_r(), columns);\n        for (int i = 0; i < rows + matrix2.get_r(); ++i)\n            for (int j = 0; j < columns; ++j) {\n                if (i < rows)\n                    con.set_v(i * columns + j, get_v(i, j));\n                else\n                    con.set_v(i * columns + j, matrix2.get_v(i - rows, j));\n            }\n        return con;\n    }\n    Matrix concatenateColumns(const Matrix &matrix2) const {\n        Matrix con = Matrix(rows, columns + matrix2.get_c());\n        for (int i = 0; i < rows; ++i)\n            for (int j = 0; j < columns + matrix2.get_c(); ++j) {\n                if (j < columns)\n                    con.set_v(i * con.get_c() + j, get_v(i, j));\n                else\n                    con.set_v(i * con.get_c() + j, matrix2.get_v(i, j - columns));\n            }\n        return con;\n    }\n\n  private:\n    int rows, columns;\n    double *values;\n};",
            1588829928.2923822,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/08",
            "许遵楠",
            "double &Tensor_get(int dimensions, const int sizes[], const double data[], int x0, int x1, int x2, int x3) {\n    int index = 0;\n    if (dimensions == 1)\n        index = x0;\n    if (dimensions == 2)\n        index = x0 * sizes[1] + x1;\n    if (dimensions == 3)\n        index = x0 * (sizes[2] * sizes[1]) + x1 * sizes[2] + x2;\n    if (dimensions == 4)\n        index = x0 * (sizes[3] * sizes[2] * sizes[1]) + x1 * (sizes[3] * sizes[2]) + x2 * sizes[3] + x3;\n    return (double &) data[index];\n}",
            1588907626.5532377,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/14",
            "许遵楠",
            "#include <iostream>\nusing namespace std;\nvoid Tensor_print(int dimensions, const int sizes[], const double data[]) {\n    if (dimensions == 1) {\n        cout << \"Tensor of \" << sizes[0] << endl;\n        for (int i = 0; i < sizes[0]; ++i)\n            cout << data[i] << endl;\n    } else if (dimensions == 2) {\n        cout << \"Tensor of \" << sizes[0] << 'x' << sizes[1] << endl;\n        for (int i = 0; i < sizes[0]; ++i) {\n            for (int j = 0; j < sizes[1]; ++j)\n                cout << \"    \" << data[i * sizes[1] + j];\n            cout << endl;\n        }\n    } else if (dimensions == 3) {\n        cout << \"Tensor of \" << sizes[0] << 'x' << sizes[1] << 'x' << sizes[2] << endl;\n        for (int i = 0; i < sizes[0]; ++i) {\n            cout << \"data[\" << i << ']' << endl;\n            for (int j = 0; j < sizes[1]; ++j) {\n                for (int k = 0; k < sizes[2]; ++k)\n                    cout << \"    \" << data[i * sizes[1] * sizes[2] + j * sizes[2] + k];\n                cout << endl;\n            }\n        }\n    } else {\n        cout << \"Tensor of \" << sizes[0] << 'x' << sizes[1] << 'x' << sizes[2] << 'x' << sizes[3] << endl;\n        for (int i = 0; i < sizes[0]; ++i) {\n            for (int j = 0; j < sizes[1]; ++j) {\n                cout << \"data[\" << i << ']' << '[' << j << ']' << endl;\n                for (int k = 0; k < sizes[2]; ++k) {\n                    for (int w = 0; w < sizes[3]; ++w)\n                        cout << \"    \" << data[i * sizes[1] * sizes[2] * sizes[3] + j * sizes[2] * sizes[3] + k * sizes[3] + w];\n                    cout << endl;\n                }\n            }\n        }\n    }\n}",
            1589423342.7327967,
            100,
            "# 答案正确"
        ],
        [
            "2.4 (C++)",
            "许遵楠",
            "#include <iostream>\nusing namespace std;\nclass Matrix {\n  public:\n    Matrix() {\n        rows = columns = 0;\n        values = 0;\n    }\n    Matrix(int r, int c) {\n        rows = r;\n        columns = c;\n        if (r * c != 0) {\n            values = new double[r * c];\n            for (int i = 0; i < r; ++i)\n                for (int j = 0; j < c; ++j)\n                    values[i * columns + j] = 0;\n        } else\n\t\t\t\tvalues = 0;\n    }\n    Matrix(int r, int c, double values[]) {\n        rows = r;\n        columns = c;\n        this->values = new double[r * c];\n        for (int i = 0; i < r; ++i)\n            for (int j = 0; j < c; ++j)\n                this->values[i * columns + j] = values[i * columns + j];\n    }\n    Matrix(const Matrix &matrix2) {\n        rows = matrix2.get_r();\n        columns = matrix2.get_c();\n        values = new double[rows * columns];\n        for (int i = 0; i < rows; ++i)\n            for (int j = 0; j < columns; ++j)\n                values[i * columns + j] = matrix2.get_v(i, j);\n    }\n    Matrix operator=(const Matrix &matrix2) {\n        if (this != &matrix2) {\n            this->rows = matrix2.get_r();\n            this->columns = matrix2.get_c();\n            this->values = new double[rows * columns];\n            for (int i = 0; i < rows; ++i)\n                for (int j = 0; j < columns; ++j)\n                    this->values[i * columns + j] = matrix2.get_v(i, j);\n        }\n        return *this;\n    }\n    void set(int row, int column, double value) {\n        values[(row - 1) * this->columns + (column - 1)] = value;\n    }\n    void print() {\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < columns; ++j)\n                cout << \"    \" << values[i * columns + j];\n            cout << endl;\n        }\n    }\n    ~Matrix() {\n        delete[] values;\n\t\t\tvalues = 0;\n    }\n    int get_r() const {\n        return rows;\n    }\n    int get_c() const {\n        return columns;\n    }\n    double get_v(int i, int j) const {\n        return values[i * columns + j];\n    }\n\n  private:\n    int rows, columns;\n    double *values;\n};",
            1589512174.0865855,
            100,
            "# 答案正确"
        ],
        [
            "2.7 (C++)",
            "许遵楠",
            "#include <iostream>\nusing namespace std;\nclass Matrix {\n  public:\n    Matrix() {\n        rows = columns = 0;\n        values = 0;\n    }\n    Matrix(int r, int c) {\n        rows = r;\n        columns = c;\n        if (r * c != 0) {\n            values = new double[r * c];\n            for (int i = 0; i < r; ++i)\n                for (int j = 0; j < c; ++j)\n                    values[i * columns + j] = 0;\n        } else\n            values = 0;\n    }\n    Matrix(int r, int c, double values[]) {\n        rows = r;\n        columns = c;\n        this->values = new double[r * c];\n        for (int i = 0; i < r; ++i)\n            for (int j = 0; j < c; ++j)\n                this->values[i * columns + j] = values[i * columns + j];\n    }\n    Matrix(const Matrix &matrix2) {\n        rows = matrix2.get_r();\n        columns = matrix2.get_c();\n        values = new double[rows * columns];\n        for (int i = 0; i < rows; ++i)\n            for (int j = 0; j < columns; ++j)\n                values[i * columns + j] = matrix2.get_v(i, j);\n    }\n\n    void set(int i, double value) {\n        values[i] = value;\n    }\n    void print() {\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < columns; ++j)\n                cout << \"    \" << values[i * columns + j];\n            cout << endl;\n        }\n    }\n    ~Matrix() {\n        delete[] values;\n        values = 0;\n    }\n    void set_r(int row) {\n        this->rows = row;\n    }\n    void set_c(int column) {\n        this->columns = column;\n    }\n    int get_r() const {\n        return rows;\n    }\n    int get_c() const {\n        return columns;\n    }\n    double get_v(int i, int j) const {\n        return values[i * columns + j];\n    }\n    Matrix reshape(int rows, int columns) const {\n        Matrix tmp(rows, columns);\n        int u = 0, v = 0;\n        for (int j = 0; j < columns; ++j)\n            for (int i = 0; i < rows; ++i) {\n                tmp.set(i * columns + j, this->get_v(u, v));\n                ++u;\n                if (u == this->get_r()) {\n                    u = 0;\n                    ++v;\n                }\n            }\n        return tmp;\n    }\n\n  private:\n    int rows, columns;\n    double *values;\n};",
            1589513433.7141154,
            100,
            "# 答案正确"
        ],
        [
            "2.8 (C++)",
            "许遵楠",
            "#include <iostream>\nusing namespace std;\nclass Matrix {\n  public:\n    Matrix() {\n        rows = columns = 0;\n        values = 0;\n    }\n    Matrix(int r, int c) {\n        rows = r;\n        columns = c;\n        if (r * c != 0) {\n            values = new double[r * c];\n            for (int i = 0; i < r; ++i)\n                for (int j = 0; j < c; ++j)\n                    values[i * columns + j] = 0;\n        } else\n            values = 0;\n    }\n    Matrix(int r, int c, double values[]) {\n        rows = r;\n        columns = c;\n        this->values = new double[r * c];\n        for (int i = 0; i < r; ++i)\n            for (int j = 0; j < c; ++j)\n                this->values[i * columns + j] = values[i * columns + j];\n    }\n    Matrix(const Matrix &matrix2) {\n        rows = matrix2.get_r();\n        columns = matrix2.get_c();\n        values = new double[rows * columns];\n        for (int i = 0; i < rows; ++i)\n            for (int j = 0; j < columns; ++j)\n                values[i * columns + j] = matrix2.get_v(i, j);\n    }\n\n    void set(int i, double value) {\n        values[i] = value;\n    }\n    void print() {\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < columns; ++j)\n                cout << \"    \" << values[i * columns + j];\n            cout << endl;\n        }\n    }\n    ~Matrix() {\n        delete[] values;\n        values = 0;\n    }\n    void set_r(int row) {\n        this->rows = row;\n    }\n    void set_c(int column) {\n        this->columns = column;\n    }\n    int get_r() const {\n        return rows;\n    }\n    int get_c() const {\n        return columns;\n    }\n    double get_v(int i, int j) const {\n        return values[i * columns + j];\n    }\n    Matrix transpose() {\n        int r = this->get_c();\n        int c = this->get_r();\n        Matrix tmp(r, c);\n        int u = 0, v = 0;\n\n        for (int j = 0; j < c; ++j)\n            for (int i = 0; i < r; ++i) {\n                tmp.set(i * c + j, this->get_v(u, v));\n                ++v;\n                if (v == r) {\n                    v = 0;\n                    ++u;\n                }\n            }\n        return tmp;\n    }\n\n  private:\n    int rows, columns;\n    double *values;\n};",
            1589514015.5877335,
            100,
            "# 答案正确"
        ],
        [
            "2.10 (C++)",
            "许遵楠",
            "#include <iostream>\nusing namespace std;\nclass Matrix {\n  public:\n    Matrix() {\n        rows = columns = 0;\n        values = 0;\n    }\n    Matrix(int r, int c) {\n        rows = r;\n        columns = c;\n        if (r * c != 0) {\n            values = new double[r * c];\n            for (int i = 0; i < r; ++i)\n                for (int j = 0; j < c; ++j)\n                    values[i * columns + j] = 0;\n        } else\n            values = 0;\n    }\n    Matrix(int r, int c, double values[]) {\n        rows = r;\n        columns = c;\n        this->values = new double[r * c];\n        for (int i = 0; i < r; ++i)\n            for (int j = 0; j < c; ++j)\n                this->values[i * columns + j] = values[i * columns + j];\n    }\n    Matrix(const Matrix &matrix2) {\n        rows = matrix2.get_r();\n        columns = matrix2.get_c();\n        values = new double[rows * columns];\n        for (int i = 0; i < rows; ++i)\n            for (int j = 0; j < columns; ++j)\n                values[i * columns + j] = matrix2.get_v(i, j);\n    }\n\n    void set(int i, double value) {\n        values[i] = value;\n    }\n    void print() {\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < columns; ++j)\n                cout << \"    \" << values[i * columns + j];\n            cout << endl;\n        }\n    }\n    ~Matrix() {\n        delete[] values;\n        values = 0;\n    }\n    void set_r(int row) {\n        this->rows = row;\n    }\n    void set_c(int column) {\n        this->columns = column;\n    }\n    int get_r() const {\n        return rows;\n    }\n    int get_c() const {\n        return columns;\n    }\n    double get_v(int i, int j) const {\n        return values[i * columns + j];\n    }\n    Matrix transpose() {\n        int r = this->get_c();\n        int c = this->get_r();\n        Matrix tmp(r, c);\n        int u = 0, v = 0;\n\n        for (int j = 0; j < c; ++j)\n            for (int i = 0; i < r; ++i) {\n                tmp.set(i * c + j, this->get_v(u, v));\n                ++v;\n                if (v == r) {\n                    v = 0;\n                    ++u;\n                }\n            }\n        return tmp;\n    }\n    Matrix operator*(double value) const {\n        Matrix tmp(*this);\n        for (int i = 0; i < rows; ++i)\n            for (int j = 0; j < columns; ++j)\n                tmp.set(i * columns + j, this->get_v(i, j) * value);\n        return tmp;\n    }\n    Matrix operator*(const Matrix &matrix2) const {\n        int c = matrix2.get_c();\n        Matrix tmp(rows, c);\n        for (int i = 0; i < rows; ++i)\n            for (int j = 0; j < c; ++j) {\n                int sum = 0;\n                for (int k = 0; k < columns; ++k)\n                    sum += this->get_v(i, k) * matrix2.get_v(k, j);\n                tmp.set(i * c + j, sum);\n            }\n\n        return tmp;\n    }\n\n  private:\n    int rows, columns;\n    double *values;\n};",
            1589514682.5947132,
            100,
            "# 答案正确"
        ],
        [
            "2.11 (C++)",
            "许遵楠",
            "#include <iostream>\nusing namespace std;\nclass Matrix {\n  public:\n    Matrix() {\n        rows = columns = 0;\n        values = 0;\n    }\n    Matrix(int r, int c) {\n        rows = r;\n        columns = c;\n        if (r * c != 0) {\n            values = new double[r * c];\n            for (int i = 0; i < r; ++i)\n                for (int j = 0; j < c; ++j)\n                    values[i * columns + j] = 0;\n        } else\n            values = 0;\n    }\n    Matrix(int r, int c, double values[]) {\n        rows = r;\n        columns = c;\n        this->values = new double[r * c];\n        for (int i = 0; i < r; ++i)\n            for (int j = 0; j < c; ++j)\n                this->values[i * columns + j] = values[i * columns + j];\n    }\n    Matrix(const Matrix &matrix2) {\n        rows = matrix2.get_r();\n        columns = matrix2.get_c();\n        values = new double[rows * columns];\n        for (int i = 0; i < rows; ++i)\n            for (int j = 0; j < columns; ++j)\n                values[i * columns + j] = matrix2.get_v(i, j);\n    }\n\n    void set(int i, double value) {\n        values[i] = value;\n    }\n    void print() {\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < columns; ++j)\n                cout << \"    \" << values[i * columns + j];\n            cout << endl;\n        }\n    }\n    ~Matrix() {\n        delete[] values;\n        values = 0;\n    }\n    void set_r(int row) {\n        this->rows = row;\n    }\n    void set_c(int column) {\n        this->columns = column;\n    }\n    int get_r() const {\n        return rows;\n    }\n    int get_c() const {\n        return columns;\n    }\n    double get_v(int i, int j) const {\n        return values[i * columns + j];\n    }\n    Matrix sum() const {\n        if (rows != 1) {\n            Matrix ss = Matrix(1, columns);\n            for (int i = 0; i < columns; ++i) {\n                int s = 0;\n                for (int j = 0; j < rows; ++j)\n                    s += this->get_v(j, i);\n                ss.set(i, s);\n            }\n            return ss;\n        } else {\n            Matrix ss = Matrix(1, 1);\n            int s = 0;\n            for (int j = 0; j < columns; ++j)\n                s += this->get_v(0, j);\n            ss.set(0, s);\n            return ss;\n        }\n    }\n    Matrix min() const {\n        if (rows != 1) {\n            int *count_min = new int[columns];\n            for (int i = 0; i < columns; ++i) {\n                count_min[i] = values[i];\n                for (int j = 1; j < rows; ++j)\n                    if (count_min[i] > values[j * columns + i])\n                        count_min[i] = values[j * columns + i];\n            }\n            Matrix ss = Matrix(1, columns);\n            for (int i = 0; i < columns; ++i)\n                ss.set(i, count_min[i]);\n            delete[] count_min;\n            return ss;\n        } else {\n            Matrix ss = Matrix(1, 1);\n            int val = this->values[0];\n            for (int j = 1; j < columns; ++j)\n                if (val > this->values[j])\n                    val = this->values[j];\n            ss.set(0, val);\n            return ss;\n        }\n    }\n    Matrix max() const {\n        if (rows != 1) {\n            int *count_max = new int[columns];\n            for (int i = 0; i < columns; ++i) {\n                count_max[i] = values[i];\n                for (int j = 1; j < rows; ++j)\n                    if (count_max[i] < values[j * columns + i])\n                        count_max[i] = values[j * columns + i];\n            }\n            Matrix ss = Matrix(1, columns);\n            for (int i = 0; i < columns; ++i)\n                ss.set(i, count_max[i]);\n            delete[] count_max;\n            return ss;\n        } else {\n            Matrix ss = Matrix(1, 1);\n            int val = this->values[0];\n            for (int j = 1; j < columns; ++j)\n                if (val < this->values[j])\n                    val = this->values[j];\n            ss.set(0, val);\n            return ss;\n        }\n    }\n\n  private:\n    int rows, columns;\n    double *values;\n};",
            1589519392.0427163,
            100,
            "# 答案正确"
        ],
        [
            "2.12 (C++)",
            "许遵楠",
            "#include <cmath>\n#include <iostream>\nusing namespace std;\n\nclass Matrix {\n  public:\n    Matrix() {\n        rows = columns = 0;\n        values = 0;\n    }\n    Matrix(int r, int c) {\n        rows = r;\n        columns = c;\n        if (r * c != 0) {\n            values = new double[r * c];\n            for (int i = 0; i < r; ++i)\n                for (int j = 0; j < c; ++j)\n                    values[i * columns + j] = 0;\n        } else\n            values = 0;\n    }\n    Matrix(int r, int c, double values[]) {\n        rows = r;\n        columns = c;\n        this->values = new double[r * c];\n        for (int i = 0; i < r; ++i)\n            for (int j = 0; j < c; ++j)\n                this->values[i * columns + j] = values[i * columns + j];\n    }\n    Matrix(const Matrix &matrix2) {\n        rows = matrix2.get_r();\n        columns = matrix2.get_c();\n        values = new double[rows * columns];\n        for (int i = 0; i < rows; ++i)\n            for (int j = 0; j < columns; ++j)\n                values[i * columns + j] = matrix2.get_v(i, j);\n    }\n\n    void set(int i, double value) {\n        values[i] = value;\n    }\n    void print() {\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < columns; ++j)\n                cout << \"    \" << values[i * columns + j];\n            cout << endl;\n        }\n    }\n    ~Matrix() {\n        delete[] values;\n        values = 0;\n    }\n    void set_r(int row) {\n        this->rows = row;\n    }\n    void set_c(int column) {\n        this->columns = column;\n    }\n    int get_r() const {\n        return rows;\n    }\n    int get_c() const {\n        return columns;\n    }\n    double get_v(int i, int j) const {\n        return values[i * columns + j];\n    }\n    Matrix pow(double exponent) {\n        Matrix tmp(*this);\n        for (int i = 0; i < rows; ++i)\n            for (int j = 0; j < columns; ++j)\n                tmp.set(i * columns + j, std::pow(this->get_v(i, j), exponent));\n        return tmp;\n    }\n    Matrix exp() {\n        Matrix tmp(*this);\n        for (int i = 0; i < rows; ++i)\n            for (int j = 0; j < columns; ++j)\n                tmp.set(i * columns + j, std::exp(this->get_v(i, j)));\n        return tmp;\n    }\n\n    Matrix log() {\n        Matrix tmp(*this);\n        for (int i = 0; i < rows; ++i)\n            for (int j = 0; j < columns; ++j)\n                tmp.set(i * columns + j, std::log(this->get_v(i, j)));\n        return tmp;\n    }\n    Matrix abs() {\n        Matrix tmp(*this);\n        for (int i = 0; i < rows; ++i)\n            for (int j = 0; j < columns; ++j)\n                tmp.set(i * columns + j, std::abs(this->get_v(i, j)));\n        return tmp;\n    }\n\n  private:\n    int rows, columns;\n    double *values;\n};",
            1589520193.8295364,
            100,
            "# 答案正确"
        ],
        [
            "2.9 (C++)",
            "许遵楠",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix {\n  public:\n    Matrix() {\n        rows = columns = 0;\n        values = 0;\n    }\n    Matrix(int r, int c) {\n        rows = r;\n        columns = c;\n        if (r * c != 0) {\n            values = new double[r * c];\n            for (int i = 0; i < r; ++i)\n                for (int j = 0; j < c; ++j)\n                    values[i * columns + j] = 0;\n        } else\n            values = 0;\n    }\n    Matrix(int r, int c, double values[]) {\n        rows = r;\n        columns = c;\n        this->values = new double[r * c];\n        for (int i = 0; i < r; ++i)\n            for (int j = 0; j < c; ++j)\n                this->values[i * columns + j] = values[i * columns + j];\n    }\n    Matrix(const Matrix &matrix2) {\n        rows = matrix2.get_r();\n        columns = matrix2.get_c();\n        values = new double[rows * columns];\n        for (int i = 0; i < rows; ++i)\n            for (int j = 0; j < columns; ++j)\n                values[i * columns + j] = matrix2.get_v(i, j);\n    }\n\n    void set(int i, double value) {\n        values[i] = value;\n    }\n    void print() {\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < columns; ++j)\n                cout << \"    \" << values[i * columns + j];\n            cout << endl;\n        }\n    }\n    ~Matrix() {\n        if (values)\n            delete[] values;\n    }\n    void set_r(int row) {\n        this->rows = row;\n    }\n    void set_c(int column) {\n        this->columns = column;\n    }\n    int get_r() const {\n        return rows;\n    }\n    int get_c() const {\n        return columns;\n    }\n    double get_v(int i, int j) const {\n        return values[i * columns + j];\n    }\n    Matrix operator+(const Matrix &matrix2) const {\n        Matrix tmp(*this);\n        for (int i = 0; i < rows; ++i)\n            for (int j = 0; j < columns; ++j)\n                tmp.set(i * columns + j, this->get_v(i, j) + matrix2.get_v(i, j));\n        return tmp;\n    }\n    Matrix operator+(double value) const {\n        Matrix tmp(*this);\n        for (int i = 0; i < rows; ++i)\n            for (int j = 0; j < columns; ++j)\n                tmp.set(i * columns + j, this->get_v(i, j) + value);\n        return tmp;\n    }\n    Matrix operator-(const Matrix &matrix2) const {\n        Matrix tmp(*this);\n        for (int i = 0; i < rows; ++i)\n            for (int j = 0; j < columns; ++j)\n                tmp.set(i * columns + j, this->get_v(i, j) - matrix2.get_v(i, j));\n        return tmp;\n    }\n    Matrix operator-(double value) const {\n        Matrix tmp(*this);\n        for (int i = 0; i < rows; ++i)\n            for (int j = 0; j < columns; ++j)\n                tmp.set(i * columns + j, this->get_v(i, j) - value);\n        return tmp;\n    }\n\n  private:\n    int rows, columns;\n    double *values;\n};",
            1590027274.5703802,
            100,
            "# 答案正确"
        ],
        [
            "6.1 (C++)",
            "许遵楠",
            "#include <iostream>\n#include <string>\nusing namespace std;\ntemplate <typename T>\nclass Matrix {\n  public:\n    Matrix() {\n        this->rows = this->columns = 0;\n        values = 0;\n    }\n    Matrix(int r, int c) {\n        this->rows = r;\n        this->columns = c;\n        if (r * c != 0) {\n            values = new T[r * c];\n            for (int i = 0; i < r; ++i)\n                for (int j = 0; j < c; ++j)\n                    values[i * this->columns + j] = T();\n        } else\n            values = 0;\n    }\n    Matrix(int r, int c, const T values[]) {\n        this->rows = r;\n        this->columns = c;\n        this->values = new T[r * c];\n        for (int i = 0; i < r; ++i)\n            for (int j = 0; j < c; ++j)\n                this->values[i * this->columns + j] = values[i * this->columns + j];\n    }\n    Matrix(const Matrix &matrix2) {\n        rows = matrix2.get_r();\n        columns = matrix2.get_c();\n        values = new T[rows * columns];\n        for (int i = 0; i < rows; ++i)\n            for (int j = 0; j < columns; ++j)\n                values[i * columns + j] = matrix2.get_v(i, j);\n    }\n    Matrix &operator=(const Matrix &matrix2) {\n        if (this == &matrix2)\n            return *this;\n        for (int i = 0; i < rows; ++i)\n            for (int j = 0; j < columns; ++j)\n                values[i * columns + j] = matrix2.get_v(i, j);\n        return *this;\n    }\n    void set(int i, T value) {\n        values[i] = value;\n    }\n    void print() {\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < columns; ++j)\n                cout << \"    \" << values[i * columns + j];\n            cout << endl;\n        }\n    }\n    ~Matrix() {\n        if (values)\n            delete[] values;\n    }\n    int get_r() const {\n        return rows;\n    }\n    int get_c() const {\n        return columns;\n    }\n    T get_v(int i, int j) const {\n        return values[i * columns + j];\n    }\n    T &get(int i, int j) {\n        return values[(i - 1) * columns + (j - 1)];\n    }\n\n  private:\n    int rows, columns;\n    T *values;\n};\n",
            1590631646.7583172,
            100,
            "# 答案正确"
        ],
        [
            "6.3 (C++)",
            "许遵楠",
            "#include <iostream>\n#include <vector>\nusing namespace std;\ntemplate <typename T>\nclass Matrix {\n  public:\n    Matrix() {\n        this->rows = this->columns = 0;\n    }\n    Matrix(int r, int c) {\n        this->rows = r;\n        this->columns = c;\n        values.assign(r * c, T());\n    }\n    Matrix(int r, int c, vector<T> val) {\n        this->rows = r;\n        this->columns = c;\n        this->values.assign(val.begin(), val.end());\n    }\n    Matrix(const Matrix &matrix2) {\n        rows = matrix2.get_r();\n        columns = matrix2.get_c();\n        values.assign(rows * columns, 0);\n        for (int i = 0; i < rows; ++i)\n            for (int j = 0; j < columns; ++j)\n                values[i * columns + j] = matrix2.get_v(i, j);\n    }\n    Matrix &operator=(const Matrix &matrix2) {\n        if (this == &matrix2)\n            return *this;\n        for (int i = 0; i < rows; ++i)\n            for (int j = 0; j < columns; ++j)\n                values[i * columns + j] = matrix2.get_v(i, j);\n        return *this;\n    }\n    Matrix getColumn(int x) {\n        Matrix tmp(rows, 1);\n        for (int i = 0; i < rows; ++i)\n            tmp.set(i, values[i * columns + x - 1]);\n        return tmp;\n    }\n    Matrix getRow(int x) {\n        Matrix tmp(1, columns);\n        for (int i = 0; i < columns; ++i)\n            tmp.set(i, values[(x - 1) * columns + i]);\n        return tmp;\n    }\n    Matrix concatenateRows(const Matrix &matrix2) const {\n        Matrix con = Matrix(rows + matrix2.get_r(), columns);\n        for (int i = 0; i < rows + matrix2.get_r(); ++i)\n            for (int j = 0; j < columns; ++j) {\n                if (i < rows)\n                    con.set(i * columns + j, get_v(i, j));\n                else\n                    con.set(i * columns + j, matrix2.get_v(i - rows, j));\n            }\n        return con;\n    }\n    Matrix concatenateColumns(const Matrix &matrix2) const {\n        Matrix con = Matrix(rows, columns + matrix2.get_c());\n        for (int i = 0; i < rows; ++i)\n            for (int j = 0; j < columns + matrix2.get_c(); ++j) {\n                if (j < columns)\n                    con.set(i * con.get_c() + j, get_v(i, j));\n                else\n                    con.set(i * con.get_c() + j, matrix2.get_v(i, j - columns));\n            }\n        return con;\n    }\n    Matrix reshape(int rows, int columns) const {\n        Matrix tmp(rows, columns);\n        int u = 0, v = 0;\n        for (int j = 0; j < columns; ++j)\n            for (int i = 0; i < rows; ++i) {\n                tmp.set(i * columns + j, this->get_v(u, v));\n                ++u;\n                if (u == this->get_r()) {\n                    u = 0;\n                    ++v;\n                }\n            }\n        return tmp;\n    }\n    Matrix transpose() {\n        int r = this->get_c();\n        int c = this->get_r();\n        Matrix tmp(r, c);\n        int u = 0, v = 0;\n\n        for (int j = 0; j < c; ++j)\n            for (int i = 0; i < r; ++i) {\n                tmp.set(i * c + j, this->get_v(u, v));\n                ++v;\n                if (v == r) {\n                    v = 0;\n                    ++u;\n                }\n            }\n        return tmp;\n    }\n    Matrix operator+(const Matrix &matrix2) const {\n        Matrix tmp(*this);\n        for (int i = 0; i < rows; ++i)\n            for (int j = 0; j < columns; ++j)\n                tmp.set(i * columns + j, this->get_v(i, j) + matrix2.get_v(i, j));\n        return tmp;\n    }\n    Matrix operator+(double value) const {\n        Matrix tmp(*this);\n        for (int i = 0; i < rows; ++i)\n            for (int j = 0; j < columns; ++j)\n                tmp.set(i * columns + j, this->get_v(i, j) + value);\n        return tmp;\n    }\n    Matrix operator-(const Matrix &matrix2) const {\n        Matrix tmp(*this);\n        for (int i = 0; i < rows; ++i)\n            for (int j = 0; j < columns; ++j)\n                tmp.set(i * columns + j, this->get_v(i, j) - matrix2.get_v(i, j));\n        return tmp;\n    }\n    Matrix operator-(double value) const {\n        Matrix tmp(*this);\n        for (int i = 0; i < rows; ++i)\n            for (int j = 0; j < columns; ++j)\n                tmp.set(i * columns + j, this->get_v(i, j) - value);\n        return tmp;\n    }\n    Matrix operator*(double value) const {\n        Matrix tmp(*this);\n        for (int i = 0; i < rows; ++i)\n            for (int j = 0; j < columns; ++j)\n                tmp.set(i * columns + j, this->get_v(i, j) * value);\n        return tmp;\n    }\n    Matrix operator*(const Matrix &matrix2) const {\n        int c = matrix2.get_c();\n        Matrix tmp(rows, c);\n        for (int i = 0; i < rows; ++i)\n            for (int j = 0; j < c; ++j) {\n                T sum = 0;\n                for (int k = 0; k < columns; ++k)\n                    sum += this->get_v(i, k) * matrix2.get_v(k, j);\n                tmp.set(i * c + j, sum);\n            }\n\n        return tmp;\n    }\n    Matrix sum() const {\n        if (rows != 1) {\n            Matrix ss = Matrix(1, columns);\n            for (int i = 0; i < columns; ++i) {\n                T s = 0;\n                for (int j = 0; j < rows; ++j)\n                    s += this->get_v(j, i);\n                ss.set(i, s);\n            }\n            return ss;\n        } else {\n            Matrix ss = Matrix(1, 1);\n            T s = 0;\n            for (int j = 0; j < columns; ++j)\n                s += this->get_v(0, j);\n            ss.set(0, s);\n            return ss;\n        }\n    }\n    Matrix min() const {\n        if (rows != 1) {\n            T *count_min = new T[columns];\n            for (int i = 0; i < columns; ++i) {\n                count_min[i] = values[i];\n                for (int j = 1; j < rows; ++j)\n                    if (count_min[i] > values[j * columns + i])\n                        count_min[i] = values[j * columns + i];\n            }\n            Matrix ss = Matrix(1, columns);\n            for (int i = 0; i < columns; ++i)\n                ss.set(i, count_min[i]);\n            delete[] count_min;\n            return ss;\n        } else {\n            Matrix ss = Matrix(1, 1);\n            T val = this->values[0];\n            for (int j = 1; j < columns; ++j)\n                if (val > this->values[j])\n                    val = this->values[j];\n            ss.set(0, val);\n            return ss;\n        }\n    }\n    Matrix max() const {\n        if (rows != 1) {\n            T *count_max = new T[columns];\n            for (int i = 0; i < columns; ++i) {\n                count_max[i] = values[i];\n                for (int j = 1; j < rows; ++j)\n                    if (count_max[i] < values[j * columns + i])\n                        count_max[i] = values[j * columns + i];\n            }\n            Matrix ss = Matrix(1, columns);\n            for (int i = 0; i < columns; ++i)\n                ss.set(i, count_max[i]);\n            delete[] count_max;\n            return ss;\n        } else {\n            Matrix ss = Matrix(1, 1);\n            T val = this->values[0];\n            for (int j = 1; j < columns; ++j)\n                if (val < this->values[j])\n                    val = this->values[j];\n            ss.set(0, val);\n            return ss;\n        }\n    }\n    void set(int i, T value) {\n        values[i] = value;\n    }\n    void print() {\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < columns; ++j)\n                cout << \"    \" << values[i * columns + j];\n            cout << endl;\n        }\n    }\n    ~Matrix() {\n    }\n    int get_r() const {\n        return rows;\n    }\n    int get_c() const {\n        return columns;\n    }\n    T get_v(int i, int j) const {\n        return values[i * columns + j];\n    }\n    T &get(int i, int j) {\n        return values[(i - 1) * columns + (j - 1)];\n    }\n\n  private:\n    int rows, columns;\n    vector<T> values;\n};",
            1590631702.2568083,
            100,
            "# 答案正确"
        ],
        [
            "6.2 (C++)",
            "许遵楠",
            "#include <iostream>\nusing namespace std;\ntemplate <typename T>\nclass Matrix {\n  public:\n    Matrix() {\n        this->rows = this->columns = 0;\n        values = 0;\n    }\n    Matrix(int r, int c) {\n        this->rows = r;\n        this->columns = c;\n        if (r * c != 0) {\n            values = new T[r * c];\n            for (int i = 0; i < r; ++i)\n                for (int j = 0; j < c; ++j)\n                    values[i * this->columns + j] = T();\n        } else\n            values = 0;\n    }\n    ~Matrix() {\n        if (values)\n            delete[] values;\n    }\n    void print() {\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < columns; ++j)\n                cout << \"    \" << values[i * columns + j];\n            cout << endl;\n        }\n    }\n\n  private:\n    int rows, columns;\n    T *values;\n};",
            1590631568.6407995,
            100,
            "# 答案正确"
        ],
        [
            "7.1 (C++)",
            "许遵楠",
            "#include <cmath>\nclass Triangle : public GeometricObject {\n  public:\n    Triangle() {\n        side1 = side2 = side3 = 1.0;\n    }\n    Triangle(double _side1 = 1.0, double _side2 = 1.0, double _side3 = 1.0) {\n        side1 = _side1, side2 = _side2, side3 = _side3;\n    }\n    ~Triangle() {\n    }\n    double getSide1() {\n        return side1;\n    }\n    double getSide2() {\n        return side2;\n    }\n    double getSide3() {\n        return side3;\n    }\n    double getArea() {\n        double s = getPerimeter() / 2;\n        return sqrt(s * (s - side1) * (s - side2) * (s - side3));\n    }\n    double getPerimeter() {\n        return side1 + side2 + side3;\n    }\n\n  private:\n    double side1, side2, side3;\n};",
            1590721888.5867784,
            100,
            "# 答案正确"
        ],
        [
            "7.3 (C++)",
            "许遵楠",
            "#include <iostream>\n#include <vector>\nusing namespace std;\ntemplate <typename A, typename R>\nvector<R> map2(const vector<A> &x, const vector<A> &y, R (*map_func)(const A &x, const A &y)) {\n    vector<R> res;\n    for (int i = 0; i < x.size(); ++i)\n        res.push_back(map_func(x[i], y[i]));\n    return res;\n}\ntemplate <typename A, typename R>\nvector<R> map2(const vector<A> &x, const A y, R (*map_func)(const A &x, const A &y)) {\n    vector<R> res;\n    for (int i = 0; i < x.size(); ++i)\n        res.push_back(map_func(x[i], y));\n    return res;\n}",
            1590723999.111408,
            100,
            "# 答案正确"
        ],
        [
            "7.2 (C++)",
            "许遵楠",
            "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\nvector<string> split(string line) {\n    vector<string> words;\n    int pos = 0, ep;\n    while (pos < line.size()) {\n        if (line[pos] == ' ') {\n            ++pos;\n            continue;\n        }\n        ep = line.find(\" \", pos);\n        if (ep == -1) {\n            words.push_back(line.substr(pos));\n            break;\n        }\n        words.push_back(line.substr(pos, ep - pos));\n        pos = ep + 1;\n    }\n    return words;\n}",
            1591237321.100384,
            100,
            "# 答案正确"
        ],
        [
            "8.1 (C++)",
            "许遵楠",
            "#include <iostream>\nusing namespace std;\nclass Full : public Matrix {\n  public:\n    Full(int rows, int columns) {\n        this->rows = rows, this->columns = columns;\n        if (rows * columns != 0) {\n            values = new double[rows * columns];\n            for (int i = 0; i < rows; ++i)\n                for (int j = 0; j < columns; ++j)\n                    set(i, j, 0);\n        } else\n            values = 0;\n    }\n    Full(int rows, int columns, double values[]) {\n        this->rows = rows;\n        this->columns = columns;\n        this->values = new double[rows * columns];\n        for (int i = 0; i < rows; ++i)\n            for (int j = 0; j < columns; ++j)\n                set(i, j, values[i * this->columns + j]);\n    }\n    Full(const Matrix &matrix2) {\n        rows = matrix2.size(1);\n        columns = matrix2.size(2);\n        values = new double[rows * columns];\n        for (int i = 0; i < rows; ++i)\n            for (int j = 0; j < columns; ++j)\n                set(i, j, matrix2.get(i, j));\n    }\n    ~Full() {\n        if (values)\n            delete[] values;\n    }\n    int size(int dimension) const {\n        if (dimension == 1)\n            return rows;\n        else\n            return columns;\n    }\n\n    void set(int row, int column, double value) {\n        values[row * this->columns + column] = value;\n    }\n\n    double get(int row, int column) const {\n        return values[row * this->columns + column];\n    }\n\n    void print() const {\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < columns; ++j)\n                cout << \"    \" << get(i, j);\n            cout << endl;\n        }\n    }\n    Matrix &operator=(const Matrix &matrix2) {\n        if (this == &matrix2)\n            return *this;\n        for (int i = 0; i < rows; ++i)\n            for (int j = 0; j < columns; ++j)\n                set(i, j, matrix2.get(i, j));\n        return *this;\n    }\n\n  private:\n    double *values;\n    int rows, columns;\n};",
            1591351550.0704563,
            100,
            "# 答案正确"
        ],
        [
            "8.3 (C++)",
            "许遵楠",
            "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\nbool cmp(Entry e1, Entry e2) {\n    if (e1.row != e2.row)\n        return e1.row < e2.row;\n    else\n        return e1.column < e2.column;\n}\nclass Sparse : public Matrix {\n  public:\n    Sparse(int rows, int column) {\n        this->rows = rows, this->columns = column;\n    }\n    Sparse operator+(Sparse &sparse2) {\n        bool flag;\n        int len = values.size();\n        for (auto val : sparse2.values) {\n            flag = true;\n            for (int i = 0; i < len; ++i) {\n                if (values[i].row == val.row && values[i].column == val.column) {\n                    values[i].value += val.value;\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag)\n                set(val.row, val.column, val.value);\n        }\n        return *this;\n    }\n    int size(int dimension) const {\n        if (dimension == 1)\n            return rows;\n        else\n            return columns;\n    }\n\n    void set(int row, int column, double value) {\n        Entry tmp;\n        tmp.row = row, tmp.column = column, tmp.value = value;\n        values.push_back(tmp);\n    }\n\n    double get(int row, int column) const {\n        for (auto val : values) {\n            if (val.row == row && val.column == column)\n                return val.value;\n        }\n        return 0;\n    }\n\n    void print() {\n        sort(values.begin(), values.end(), cmp);\n        for (auto val : values)\n            if (val.value != 0)\n                cout << '(' << val.row << ',' << val.column << ',' << val.value << ')' << endl;\n    }\n\n    vector<Entry> values;\n\n  private:\n    int rows, columns;\n};",
            1591332129.5316892,
            100,
            "# 答案正确"
        ],
        [
            "8.4 (C++)",
            "许遵楠",
            "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\nbool cmp(Entry e1, Entry e2) {\n    if (e1.row != e2.row)\n        return e1.row < e2.row;\n    else\n        return e1.column < e2.column;\n}\nclass Sparse : public Matrix {\n  public:\n    Sparse(int rows, int column) {\n        this->rows = rows, this->columns = column;\n    }\n    Sparse operator*(Sparse &sparse2) {\n        int len = values.size();\n        double prev, now;\n        bool flag;\n        vector<Entry> pre(values.begin(), values.end());\n        for (int i = 0; i < len; ++i) {\n            prev = pre[i].value;\n            now = values[i].value = 0;\n            for (auto val : sparse2.values) {\n                if (values[i].column == val.row) {\n                    now = val.value * prev;\n                    flag = true;\n                    for (int k = 0; k < (int) values.size(); ++k) {\n                        if (values[k].row == values[i].row && values[k].column == val.column) {\n                            values[k].value += now;\n                            flag = false;\n                            break;\n                        }\n                    }\n                    if (flag)\n                        set(values[i].row, val.column, now);\n                }\n            }\n        }\n        return *this;\n    }\n    int size(int dimension) const {\n        if (dimension == 1)\n            return rows;\n        else\n            return columns;\n    }\n\n    void set(int row, int column, double value) {\n        Entry tmp;\n        tmp.row = row, tmp.column = column, tmp.value = value;\n        values.push_back(tmp);\n    }\n\n    double get(int row, int column) const {\n        for (auto val : values) {\n            if (val.row == row && val.column == column)\n                return val.value;\n        }\n        return 0;\n    }\n\n    void print() {\n        sort(values.begin(), values.end(), cmp);\n        for (auto val : values)\n            if (val.value != 0)\n                cout << '(' << val.row << ',' << val.column << ',' << val.value << ')' << endl;\n    }\n\n    vector<Entry> values;\n\n  private:\n    int rows, columns;\n};",
            1591333346.7148094,
            100,
            "# 答案正确"
        ],
        [
            "8.5 (C++)",
            "许遵楠",
            "#include <cmath>\nclass Point3D : public Point2D {\n  private:\n    double z;\n\n  public:\n    Point3D() : z(0) {\n        setX(0);\n        setY(0);\n    }\n    Point3D(double tx, double ty, double tz) : z(tz) {\n        setX(tx);\n        setY(ty);\n    }\n    double getZ() {\n        return z;\n    }\n    double distance(Point2D &point2) {\n        Point3D *p2 = dynamic_cast<Point3D *>(&point2);\n        double dx = getX() - p2->getX();\n        double dy = getY() - p2->getY();\n        double dz = getZ() - p2->getZ();\n        return sqrt(dx * dx + dy * dy + dz * dz);\n    }\n};",
            1591842196.7344491,
            100,
            "# 答案正确"
        ],
        [
            "8.6 (C++)",
            "许遵楠",
            "#include <iostream>\n#include <vector>\nusing namespace std;\nvoid _assert(bool valid, const char err_msg[]) {\n    if (valid) return;\n    cout << err_msg << endl;\n    exit(1);\n}\nclass MyTensor : public Tensor<double> {\n  private:\n    vector<double> data;\n\n  public:\n    MyTensor(vector<int> sizes) : Tensor(sizes) {\n        int sum = 1;\n        for (auto s : sizes)\n            sum *= s;\n        data.assign(sum, 0);\n    }\n    double &get(const vector<int> &indexes) {\n        int dimension = indexes.size(), index = indexes[0];\n\t\t// 检查有否越界\n        _assert(indexes[0] >= 0 && indexes[0] < this->sizes[0], \"第0维越界\");\n        _assert((dimension < 2) || (indexes[1] >= 0 && indexes[1] < this->sizes[1]), \"第1维越界\");\n        _assert((dimension < 3) || (indexes[2] >= 0 && indexes[2] < this->sizes[2]), \"第2维越界\");\n        _assert((dimension < 4) || (indexes[3] >= 0 && indexes[3] < this->sizes[3]), \"第3维越界\");\n        if (dimension > 1) index = index * this->sizes[1] + indexes[1];\n        if (dimension > 2) index = index * this->sizes[2] + indexes[2];\n        if (dimension > 3) index = index * this->sizes[3] + indexes[3];\n        return this->data[index];\n    }\n};",
            1592448875.67413,
            100,
            "# 答案正确"
        ],
        [
            "9.1 (C++)",
            "许遵楠",
            "#include <iostream>\nusing namespace std;\nclass Circle {\n  private:\n    double r;\n\n  public:\n    Circle(double radius) : r(radius) {}\n    bool operator<(const Circle c2) const{ return r < c2.r; }\n    bool operator<=(const Circle c2) const{ return r <= c2.r; }\n    bool operator>=(const Circle c2) const{ return r >= c2.r; }\n    bool operator>(const Circle c2) const{ return r > c2.r; }\n    bool operator==(const Circle c2) const{ return r == c2.r; }\n    bool operator!=(const Circle c2) const{ return r != c2.r; }\n};",
            1592532995.6303737,
            100,
            "# 答案正确"
        ],
        [
            "9.2 (C++)",
            "许遵楠",
            "#include <iostream>\n#include <vector>\nusing namespace std;\nclass I {\n  private:\n    vector<int> indexes;\n\n  public:\n    I(int i1, int i2 = -1, int i3 = -1, int i4 = -1) {\n        indexes.push_back(i1);\n        if (i2 != -1) indexes.push_back(i2);\n        if (i3 != -1) indexes.push_back(i3);\n        if (i4 != -1) indexes.push_back(i4);\n    }\n\n    operator vector<int>() const { return indexes; }\n};",
            1592533471.863649,
            100,
            "# 答案正确"
        ],
        [
            "9.3 (C++)",
            "许遵楠",
            "#include <iostream>\nusing namespace std;\n\nclass Complex {\n  private:\n    double r, i;\n\n  public:\n    Complex(double re, double im) : r(re), i(im) {}\n    double real() { return r; }\n    double imag() { return i; }\n    Complex operator+(Complex c2) {\n        Complex c3(r + c2.r, i + c2.i);\n        return c3;\n    }\n    Complex operator+=(Complex c2) {\n        r += c2.r;\n        i += c2.i;\n        return *this;\n    }\n    Complex operator-(Complex c2) {\n        Complex c3(r - c2.r, i - c2.i);\n        return c3;\n    }\n    Complex operator-=(Complex c2) {\n        r -= c2.r;\n        i -= c2.i;\n        return *this;\n    }\n    Complex operator*(Complex c2) {\n        Complex c3(r * c2.r - i * c2.i, r * c2.i + i * c2.r);\n        return c3;\n    }\n    Complex operator*=(Complex c2) {\n        double tr = r * c2.r - i * c2.i;\n        double ti = r * c2.i + i * c2.r;\n        r = tr, i = ti;\n        return *this;\n    }\n    Complex operator/(Complex c2) {\n        Complex c3((r * c2.r + i * c2.i) / (c2.i * c2.i + c2.r * c2.r), (i * c2.r - r * c2.i) / (c2.i * c2.i + c2.r * c2.r));\n        return c3;\n    }\n    Complex operator/=(Complex c2) {\n        double tr = (r * c2.r + i * c2.i) / (c2.i * c2.i + c2.r * c2.r);\n        double ti = (i * c2.r - r * c2.i) / (c2.i * c2.i + c2.r * c2.r);\n        r = tr, i = ti;\n        return *this;\n    }\n    Complex operator+(double num) {\n        Complex c3(r + num, i);\n        return c3;\n    }\n    Complex operator-(double num) {\n        Complex c3(r - num, i);\n        return c3;\n    }\n    bool operator==(Complex c2) { return r == c2.r && i == c2.i; }\n    bool operator!=(Complex c2) { return r != c2.r || i != c2.i; }\n};\n\nComplex operator+(double num, Complex c) {\n    Complex c3(num + c.real(), c.imag());\n    return c3;\n}\n\nComplex operator-(double num, Complex c) {\n    Complex c3(num - c.real(), c.imag());\n    return c3;\n}",
            1592538576.2501037,
            100,
            "# 答案正确"
        ],
        [
            "9.4 (C++)",
            "许遵楠",
            "#include <iostream>\nusing namespace std;\n\nclass Complex {\n  private:\n    double r, i;\n\n  public:\n    Complex(double re = 0, double im = 0) : r(re), i(im) {}\n    double &real() { return r; }\n    double &imag() { return i; }\n\n    Complex operator+(Complex c2) {\n        Complex c3(r + c2.r, i + c2.i);\n        return c3;\n    }\n    Complex operator-(Complex c2) {\n        Complex c3(r - c2.r, i - c2.i);\n        return c3;\n    }\n    friend istream &operator>>(istream &in, Complex &c);\n    friend ostream &operator<<(ostream &out, Complex &c);\n};\n\nistream &operator>>(istream &in, Complex &c) {\n    in >> c.r >> c.i;\n    return in;\n}\n\nostream &operator<<(ostream &out, Complex &c) {\n    out << c.r << \" + \" << c.i << \" i\";\n    return out;\n}",
            1592536717.0420926,
            100,
            "# 答案正确"
        ],
        [
            "9.6 (C++)",
            "许遵楠",
            "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Tensor {\n  private:\n    vector<int> sizes;\n    vector<double> datas;\n\n  public:\n    Tensor(int i1, int i2 = -1, int i3 = -1, int i4 = -1) {\n        int n = 1;\n        sizes.push_back(i1);\n        if (i2 != -1) sizes.push_back(i2);\n        if (i3 != -1) sizes.push_back(i3);\n        if (i4 != -1) sizes.push_back(i4);\n        for (auto i : sizes)\n            n *= i;\n        datas.assign(n, 0);\n    }\n    double &operator()(int i1, int i2 = -1, int i3 = -1, int i4 = -1) {\n        int index = i1;\n        if (i2 != -1) index = index * this->sizes[1] + i2;\n        if (i3 != -1) index = index * this->sizes[2] + i3;\n        if (i4 != -1) index = index * this->sizes[3] + i4;\n        return this->datas[index];\n    }\n};",
            1592540078.3022642,
            100,
            "# 答案正确"
        ],
        [
            "9.5 (C++)",
            "许遵楠",
            "#include <iostream>\nusing namespace std;\n\nclass Complex {\n  private:\n    double r, i;\n\n  public:\n    Complex(double re = 0, double im = 0) : r(re), i(im) {}\n    Complex &operator++() {\n        ++r;\n        return *this;\n    }\n    Complex operator++(int) {\n        Complex res(r++, i);\n        return res;\n    }\n    operator double() const { return r; }\n    friend istream &operator>>(istream &in, Complex &c);\n    friend ostream &operator<<(ostream &out, const Complex &c);\n};\n\nistream &operator>>(istream &in, Complex &c) {\n    in >> c.r >> c.i;\n    return in;\n}\n\nostream &operator<<(ostream &out, const Complex &c) {\n    out << c.r << \" + \" << c.i << \" i\";\n    return out;\n}",
            1592542155.9020853,
            100,
            "# 答案正确"
        ],
        [
            "9.7 (C++)",
            "许遵楠",
            "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Tensor {\n  private:\n    vector<int> sizes;\n    vector<double> datas;\n\n  public:\n    Tensor() {}\n    Tensor(int i1, int i2 = -1, int i3 = -1, int i4 = -1) {\n        int n = 1;\n        sizes.push_back(i1);\n        if (i2 != -1) sizes.push_back(i2);\n        if (i3 != -1) sizes.push_back(i3);\n        if (i4 != -1) sizes.push_back(i4);\n        for (auto i : sizes)\n            n *= i;\n        datas.assign(n, 0);\n    }\n    double &operator()(int i1, int i2 = -1, int i3 = -1, int i4 = -1) {\n        int index = i1;\n        if (i2 != -1) index = index * this->sizes[1] + i2;\n        if (i3 != -1) index = index * this->sizes[2] + i3;\n        if (i4 != -1) index = index * this->sizes[3] + i4;\n        return this->datas[index];\n    }\n    friend istream &operator>>(istream &in, Tensor &T);\n    friend ostream &operator<<(ostream &out, Tensor &T);\n};\n\nistream &operator>>(istream &in, Tensor &T) {\n    int n, i1, i2, i3, i4;\n    in >> n;\n    if (n == 1) {\n        cin >> i1;\n        T = Tensor(i1);\n        for (int i = 0; i < i1; ++i)\n            in >> T(i);\n    } else if (n == 2) {\n        cin >> i1 >> i2;\n        T = Tensor(i1, i2);\n        for (int i = 0; i < i1; ++i)\n            for (int j = 0; j < i2; ++j)\n                in >> T(i, j);\n    } else if (n == 3) {\n        cin >> i1 >> i2 >> i3;\n        T = Tensor(i1, i2, i3);\n        for (int i = 0; i < i1; ++i)\n            for (int j = 0; j < i2; ++j)\n                for (int k = 0; k < i3; ++k)\n                    in >> T(i, j, k);\n    } else if (n == 4) {\n        cin >> i1 >> i2 >> i3 >> i4;\n        T = Tensor(i1, i2, i3, i4);\n        for (int i = 0; i < i1; ++i)\n            for (int j = 0; j < i2; ++j)\n                for (int k = 0; k < i3; ++k)\n                    for (int w = 0; w < i4; ++w)\n                        in >> T(i, j, k, w);\n    }\n    return in;\n}\n\nostream &operator<<(ostream &out, Tensor &T) {\n    int n, i1, i2, i3, i4;\n    n = T.sizes.size();\n    out << n << endl;\n    for (int i = 0; i < n; ++i)\n        cout << T.sizes[i] << ' ';\n    cout << endl\n         << endl;\n    if (n == 1) {\n        i1 = T.sizes[0];\n        for (int i = 0; i < i1; ++i)\n            out << T(i) << ' ';\n    } else if (n == 2) {\n        i1 = T.sizes[0], i2 = T.sizes[1];\n        for (int i = 0; i < i1; ++i) {\n            for (int j = 0; j < i2; ++j)\n                out << T(i, j) << ' ';\n            cout << endl;\n        }\n    } else if (n == 3) {\n        i1 = T.sizes[0], i2 = T.sizes[1], i3 = T.sizes[2];\n        for (int i = 0; i < i1; ++i) {\n            for (int j = 0; j < i2; ++j) {\n                for (int k = 0; k < i3; ++k)\n                    out << T(i, j, k) << ' ';\n                cout << endl;\n            }\n            cout << endl;\n        }\n    } else if (n == 4) {\n        i1 = T.sizes[0], i2 = T.sizes[1], i3 = T.sizes[2], i4 = T.sizes[3];\n        for (int i = 0; i < i1; ++i) {\n            for (int j = 0; j < i2; ++j) {\n                for (int k = 0; k < i3; ++k) {\n                    for (int w = 0; w < i4; ++w)\n                        out << T(i, j, k, w) << ' ';\n                    cout << endl;\n                }\n                cout << endl;\n            }\n        }\n    }\n    return out;\n}",
            1592544586.82814,
            100,
            "# 答案正确"
        ],
        [
            "10.1 (C++)",
            "许遵楠",
            "#include <iostream>\n#include <stdexcept>\nusing namespace std;\nclass MatrixSizesDoNotMatchException {\n  public:\n    MatrixSizesDoNotMatchException() {}\n};\ndouble Matrix::get(int row, int column) const {\n    --row;\n    --column;\n    if (row < 0 || row >= rows || column < 0 || column >= columns)\n        throw out_of_range(\"out of range\");\n    return elements[row * columns + column];\n}\n\nvoid Matrix::set(int row, int column, double value) {\n    --row;\n    --column;\n    if (row < 0 || row >= rows || column < 0 || column >= columns)\n        throw out_of_range(\"out of range\");\n    elements[row * columns + column] = value;\n}\n\nMatrix Matrix::operator+(const Matrix &matrix2) const {\n    if (rows != matrix2.size(1) || columns != matrix2.size(2))\n        throw MatrixSizesDoNotMatchException();\n    Matrix res(rows, columns);\n    for (int i = 0; i < rows; ++i)\n        for (int j = 0; j < columns; ++j)\n            res.set(i + 1, j + 1, get(i + 1, j + 1) + matrix2.get(i + 1, j + 1));\n    return res;\n}",
            1593312254.6909308,
            100,
            "# 答案正确"
        ],
        [
            "10.2 (C++)",
            "许遵楠",
            "catch (NonPositiveValueException &ex) {\n\tcout << \"caught: NonPositiveValueException\" << endl;\n} catch (out_of_range &ex) {\n\tcout << \"caught: out_of_range\" << endl; \n}",
            1593655445.178147,
            100,
            "# 答案正确"
        ],
        [
            "15.1 (C++)",
            "许遵楠",
            "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\nclass Table {\n  public:\n    Table() {}\n    void addCol(string s) {\n        head.push_back(s);\n    }\n    vector<string> &operator[](int i) {\n        if (i >= (int) dat.size()) {\n            dat.push_back({});\n            return dat[dat.size() - 1];\n        } else\n            return dat[i];\n    }\n    string json() const {\n        string res;\n        res += \"{\\n\";\n        res += \"\theaders: [\";\n        for (auto h : head)\n            res += (\"'\" + h + \"',\");\n        res += \"],\\n\trows: [\\n\";\n        for (auto col : dat) {\n            res += \"\t\t[\";\n            for (auto row : col)\n                res += (\"'\" + row + \"',\");\n            res += \"],\\n\";\n        }\n        res += \"\t],\\n}\";\n        return res;\n    }\n\n  private:\n    vector<vector<string>> dat;\n    vector<string> head;\n};",
            1593743394.2919,
            100,
            "# 答案正确"
        ],
        [
            "2020-07-09 LAB",
            "许遵楠",
            "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Integer {\n  private:\n    int data;\n    static vector<Integer *> obj;\n\n  public:\n    Integer(int x = 0) : data(x) {\n        obj.push_back(this);\n    }\n    static void increase_all(int x) {\n        for (int i = 0; i < (int) obj.size(); ++i)\n            obj[i]->data += x;\n    }\n    static void increase_all(Integer y) {\n        for (int i = 0; i < (int) obj.size(); ++i)\n            obj[i]->data += y.data;\n    }\n    Integer operator=(int x) {\n        data = x;\n        return *this;\n    }\n    friend istream &operator>>(istream &in, Integer &T);\n    friend ostream &operator<<(ostream &out, Integer &T);\n};\n\nistream &operator>>(istream &in, Integer &T) {\n    in >> T.data;\n    return in;\n}\n\nostream &operator<<(ostream &out, Integer &T) {\n    out << T.data;\n    return out;\n}\nvector<Integer *> Integer::obj{};",
            1594262261.6074169,
            100,
            "# 答案正确"
        ],
        [
            "A.1 (C++)",
            "许遵楠",
            "  private:\n    Node<E> *get_node(int index) const {\n        if (index < 0 || index >= _size)\n            throw NotSuchElementException();\n        if (index < _size / 2) {\n            Node<E> *node = head;\n            Node<E> *pre1 = 0, *pre2 = 0;\n            I(i, index) {\n                pre1 = node;\n                node = node->next_node(pre2);\n                pre2 = pre1;\n            }\n            return node;\n        } else {\n            Node<E> *node = tail;\n            Node<E> *nxt1 = 0, *nxt2 = 0;\n            I(i, (_size - 1 - index)) {\n                nxt1 = node;\n                node = node->prev_node(nxt2);\n                nxt2 = nxt1;\n            }\n            return node;\n        }\n    }\n\n  public:\n    E &get(int index) const {\n        Node<E> *node = get_node(index);\n        return node->element;\n    }\n    void set(int index, const E &e) {\n        Node<E> *node = get_node(index);\n        node->element = e;\n    }\n\n    E &getFirst() const {\n        return get(0);\n    }\n\n    E &getLast() const {\n        return get(_size - 1);\n    }\n\n    void remove(int index) {\n        Node<E> *node = get_node(index);\n        Node<E> *nxt = (index + 1 >= _size ? 0 : get_node(index + 1));\n        Node<E> *prev_node = node->prev_node(nxt);\n        Node<E> *pre = (index - 1 < 0 ? 0 : get_node(index - 1));\n        Node<E> *next_node = node->next_node(pre);\n        if (prev_node != 0) {\n            prev_node->update_next_node(node, next_node);\n            prev_node->update_prev_and_next_node(prev_node->prev_node(next_node), next_node);\n        }\n        if (next_node != 0) {\n            next_node->update_prev_node(node, prev_node);\n            next_node->update_prev_and_next_node(prev_node, next_node->next_node(prev_node));\n        }\n        node->update_prev_and_next_node(prev_node, next_node);\n        if (prev_node == 0) head = next_node;\n        if (next_node == 0) tail = prev_node;\n        delete node;\n        --_size;\n    }\n\n    void removeFirst() {\n        remove(0);\n    }\n\n    void removeLast() {\n        remove(_size - 1);\n    }\n\n    void add(int index, const E &e) {\n        if (index < 0 || index > _size)\n            throw NotSuchElementException();\n        Node<E> *node = new Node<E>();\n        node->element = e;\n        Node<E> *next_node = (index == _size ? 0 : get_node(index));\n        Node<E> *nxt = (index + 1 >= _size ? 0 : get_node(index + 1));\n        Node<E> *prev_node = (next_node == 0 ? tail : next_node->prev_node(nxt));\n        node->update_next_node(0, next_node);\n        node->update_prev_node(0, prev_node);\n        node->update_prev_and_next_node(prev_node, next_node);\n        if (prev_node != 0) {\n            prev_node->update_next_node(nxt, node);\n            prev_node->update_prev_and_next_node(prev_node->prev_node(node), node);\n        }\n        if (next_node != 0) {\n            next_node->update_prev_node(next_node->prev_node(nxt), node);\n            next_node->update_prev_and_next_node(node, next_node->next_node(node));\n        }\n        if (prev_node == 0) head = node;\n        if (next_node == 0) tail = node;\n        ++_size;\n    }\n\n    void addFirst(const E &e) {\n        add(0, e);\n    }\n\n    void addLast(const E &e) {\n        add(_size, e);\n    }\n\n    // copy and clear\n\n    void clear() {\n        while (_size > 0)\n            removeFirst();\n    }\n\n    void addAll(const LinkedList &list, int index = -1) {\n        if (index == -1) index = _size;\n        I(i, list._size) {\n            Node<E> *node = list.get_node(i);\n            add(index + i, node->element);\n        }\n    }\n\n    LinkedList(const LinkedList &list) : _size(0), head(0), tail(0) {\n        addAll(list);\n    }\n\n    LinkedList &operator=(const LinkedList &list) {\n        clear();\n        addAll(list);\n        return *this;\n    }\n\n    ~LinkedList() {\n        clear();\n    }\n\n    int indexOf(const E &e) const {\n        Node<E> *node = head;\n        Node<E> *pre1 = 0, *pre2 = 0;\n        I(i, _size) {\n            if (node->element == e) return i;\n            pre1 = node;\n            node = node->next_node(pre2);\n            pre2 = pre1;\n        }\n        return -1;\n    }\n\n    int lastIndexOf(const E &e) const {\n        Node<E> *node = tail;\n        Node<E> *nxt1 = 0, *nxt2 = 0;\n        I(i, _size) {\n            if (node->element == e) return i;\n            nxt1 = node;\n            node = node->prev_node(nxt2);\n            nxt2 = nxt1;\n        }\n        return -1;\n    }\n\n    bool contains(const E &e) const {\n        return indexOf(e) >= 0;\n    }\n\n    void removeFirstOccurrence(const E &e) {\n        int index = indexOf(e);\n        if (index == -1)\n            throw NotSuchElementException();\n        remove(index);\n    }\n\n    void removeLastOccurrence(const E &e) {\n        int index = lastIndexOf(e);\n        if (index == -1)\n            throw NotSuchElementException();\n        remove(index);\n    }",
            1594367200.4919002,
            100,
            "# 答案正确"
        ],
        [
            "A.2 (C++)",
            "许遵楠",
            "template <typename E>\nvoid LinkedList<E>::removeAll(const E &e) {\n    int index = indexOf(e);\n    while (index != -1) {\n        remove(index);\n        index = indexOf(e);\n    }\n}",
            1594866615.0262823,
            100,
            "# 答案正确"
        ],
        [
            "A.4 (C++)",
            "许遵楠",
            "#include <iostream>\n#include <map>\n#include <string>\nusing namespace std;\n\nclass NoSuchKeyException {};\n\nclass Magicbox {\n  public:\n    int _val_int;\n    string _val_string;\n    Magicbox(int v = -1, string s = \"\") : _val_int(v), _val_string(s) {}\n    operator int() { return _val_int; }\n    operator string() { return _val_string; }\n};\n\nclass HT {\n  private:\n    map<int, int> _mii;\n    map<string, int> _msi;\n    map<int, string> _mis;\n    map<string, string> _mss;\n    size_t _size;\n    Magicbox _tmp;\n\n  public:\n    HT() : _size(0), _tmp() {}\n\n    size_t size() const {\n        return _size;\n    }\n\n    void put(int k, int v) {\n        _mii[k] = v;\n        ++_size;\n    }\n\n    void put(string k, int v) {\n        _msi[k] = v;\n        ++_size;\n    }\n\n    void put(int k, string v) {\n        _mis[k] = v;\n        ++_size;\n    }\n\n    void put(string k, string v) {\n        _mss[k] = v;\n        ++_size;\n    }\n\n    Magicbox &operator[](const int &key) {\n        if (_mii.find(key) != _mii.end())\n            _tmp._val_int = _mii[key];\n        else if (_mis.find(key) != _mis.end())\n            _tmp._val_string = _mis[key];\n        else\n            throw NoSuchKeyException();\n        return _tmp;\n    }\n\n    Magicbox &operator[](const string &key) {\n        if (_msi.find(key) != _msi.end())\n            _tmp._val_int = _msi[key];\n        else if (_mss.find(key) != _mss.end())\n            _tmp._val_string = _mss[key];\n        else\n            throw NoSuchKeyException();\n        return _tmp;\n    }\n};",
            1595034801.414225,
            100,
            "# 答案正确"
        ],
        [
            "A.5 (C++)",
            "许遵楠",
            "#include <iostream>\n#include <map>\n#include <string>\nusing namespace std;\n\nclass NoSuchKeyException {};\nclass StateError {};\n\nclass Magicbox {\n  private:\n    int _isuse;\n    int _val_int, _flag_int;\n    string _val_string, _flag_string;\n    friend class HT;\n\n  public:\n    Magicbox() : _isuse(0) {}\n    operator int() { return _val_int; }\n    operator string() { return _val_string; }\n    Magicbox &operator=(int val) {\n        _val_int = val;\n        this->_isuse += 1;\n        return *this;\n    }\n    Magicbox &operator=(string val) {\n        _val_string = val;\n        this->_isuse += 4;\n        return *this;\n    }\n};\n\nclass HT {\n  private:\n    map<int, int> _mii;\n    map<string, int> _msi;\n    map<int, string> _mis;\n    map<string, string> _mss;\n    size_t _size;\n    Magicbox _tmp;\n    void _check() {\n        if (_tmp._isuse == 0)\n            return;\n        else if (_tmp._isuse == 1 || _tmp._isuse == 3)\n            throw NoSuchKeyException();\n        else if (_tmp._isuse == 2)\n            _mii[_tmp._flag_int] = _tmp._val_int;\n        else if (_tmp._isuse == 4)\n            _msi[_tmp._flag_string] = _tmp._val_int;\n        else if (_tmp._isuse == 5)\n            _mis[_tmp._flag_int] = _tmp._val_string;\n        else if (_tmp._isuse == 7)\n            _mss[_tmp._flag_string] = _tmp._val_string;\n        else\n            throw StateError();\n        _tmp._isuse = 0;\n    }\n\n  public:\n    HT() : _size(0), _tmp() {}\n\n    size_t size() const {\n        return _size;\n    }\n\n    Magicbox &operator[](const int &key) {\n        _check();\n        if (_mii.find(key) != _mii.end())\n            _tmp._val_int = _mii[key];\n        else if (_mis.find(key) != _mis.end())\n            _tmp._val_string = _mis[key];\n        else {\n            _tmp._flag_int = key;\n            _tmp._isuse = 1;\n            ++_size;\n        }\n        return _tmp;\n    }\n\n    Magicbox &operator[](const string &key) {\n        _check();\n        if (_msi.find(key) != _msi.end())\n            _tmp._val_int = _msi[key];\n        else if (_mss.find(key) != _mss.end())\n            _tmp._val_string = _mss[key];\n        else {\n            _tmp._flag_string = key;\n            _tmp._isuse = 3;\n            ++_size;\n        }\n        return _tmp;\n    }\n};",
            1595035082.016697,
            100,
            "# 答案正确"
        ],
        [
            "A.3 (C++)",
            "许遵楠",
            "#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <stdexcept>\n#include <string>\n#include <vector>\nusing namespace std;\nclass NoSuchKeyException {};\n#define I(i, n) for (size_t i = 0; i < n; ++i)\n\nsize_t hash_function(const int &key) {\n    return key * key;\n}\n\ntemplate <typename V>\nclass HT {\n    class Tuple {\n      public:\n        int key;\n        V val;\n        bool in_use;\n\n        Tuple() : in_use(false) {}\n    };\n\n    vector<Tuple> tuples;\n    size_t _size;\n\n    size_t canonical_index(const int &key) const {\n        size_t hash_code = hash_function(key); // needs hash_function(K)\n        return hash_code % tuples.size();\n    }\n\n    // the returned tuple is either empty or with the same key\n    size_t indexOfKey(const int &key) const {\n        size_t index = canonical_index(key);\n        while (true) { // will enter a dead loop if there is not empty tuple\n            if (!tuples[index].in_use) return index;\n            if (tuples[index].key == key) return index;\n            index = (index + 1) % tuples.size();\n        }\n    }\n\n  public:\n    HT() : _size(0) {\n        tuples.resize(2);\n    }\n\n    bool containsKey(const int &key) const {\n        size_t index = indexOfKey(key);\n        return tuples[index].in_use;\n    }\n\n    const V &operator[](const int &key) const {\n        size_t index = indexOfKey(key);\n        if (!tuples[index].in_use)\n            throw NoSuchKeyException();\n        return tuples[index].val;\n    }\n\n    V &operator[](const int &key) {\n        size_t index = indexOfKey(key);\n        if (!tuples[index].in_use)\n            throw NoSuchKeyException();\n        return tuples[index].val;\n    }\n\n    void put(const int &key, const V &val) {\n        size_t index = indexOfKey(key);\n        tuples[index].key = key;\n        tuples[index].val = val;\n        if (tuples[index].in_use) return;\n        tuples[index].in_use = true;\n        ++_size;\n        // make sure empty > size / 2\n        if (2 * _size > tuples.size())\n            _double_tuples();\n    }\n\n    void _double_tuples() {\n        vector<Tuple> non_empty_tuples;\n        I(i, tuples.size())\n        if (tuples[i].in_use)\n            non_empty_tuples.push_back(tuples[i]);\n        clear();\n        tuples.resize(tuples.size() * 2);\n        I(i, non_empty_tuples.size())\n        put(non_empty_tuples[i].key, non_empty_tuples[i].val);\n    }\n\n    static bool _between(size_t hole, size_t canonical, size_t tuple_index) {\n        if (hole < tuple_index)\n            return canonical > hole && canonical <= tuple_index;\n        else\n            return canonical > hole || canonical <= tuple_index;\n    }\n\n    void remove(const int &key) {\n        size_t index = indexOfKey(key);\n        if (!tuples[index].in_use)\n            throw NoSuchKeyException();\n        tuples[index].in_use = false;\n        --_size;\n        // if there is a hole between a tuple and its canonical position\n        // move the tuple to the hole\n        size_t hole = index;\n        size_t tuple_index = hole;\n        while (true) {\n            tuple_index = (tuple_index + 1) % tuples.size();\n            if (!tuples[tuple_index].in_use) return;\n            size_t canonical = canonical_index(tuples[tuple_index].key);\n            if (_between(hole, canonical, tuple_index)) continue;\n            tuples[hole] = tuples[tuple_index];\n            hole = tuple_index;\n            tuples[hole].in_use = false;\n        }\n    }\n\n    size_t size() const { return _size; }\n\n    void clear() {\n        I(i, tuples.size())\n        tuples[i].in_use = false;\n        _size = 0;\n    }\n\n    void _inspect() const {\n        I(i, tuples.size())\n        if (tuples[i].in_use)\n            cout << \"#\" << i << \" C\" << canonical_index(tuples[i].key)\n                 << \" \" << tuples[i].key << \" \" << tuples[i].val << endl;\n    }\n\n    vector<int> getKeys() {\n        vector<int> res;\n        for (int i = 0; i < tuples.size(); ++i)\n            if (tuples[i].in_use)\n                res.push_back(tuples[i].key);\n        return res;\n    }\n};",
            1595470611.890182,
            100,
            "# 答案正确"
        ]
    ],
    "table_name": "答案"
}