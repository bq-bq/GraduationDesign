{
    "__update_time__": 1595065380.333869,
    "field_names": [
        "题目名",
        "用户名",
        "答案",
        "提交时间",
        "分数",
        "评语"
    ],
    "field_types": [
        "text",
        "text",
        "text",
        "time",
        "number",
        "text"
    ],
    "foreign_keys": {},
    "primary_keys": [],
    "rows": [
        [
            "6.2 (C++)",
            "萧锘汶",
            "#include <iostream> \n#include<string.h>\nusing namespace std;\ntemplate <typename T>\nclass Matrix{\n private:\n  int rows;\n  int columns;\n  T* values;\n public:\n  Matrix(int row,int column){\n   rows = row;\n   columns = column;\n   values = new T[row*column];\n   memset(values,0,sizeof(T)*rows*columns);\n  }\n  ~Matrix(){\n   delete [] values;\n  }\n  void print(void){\n   for(int i = 0; i < rows*columns;i++){\n    cout<<\"    \"<<values[i];\n    if((i + 1)% columns == 0)cout<<endl;\n   }\n  }\n};",
            1590637015.5755935,
            100,
            "# 答案正确"
        ],
        [
            "6.1 (C++)",
            "萧锘汶",
            "#include <iostream>\n#include <string>\n#include <cstring>\nusing namespace std;\n\ntemplate <typename T>\nclass Matrix{\n\tprivate:\n    \tint row ;\n    \tint col ;\n    \tT *val;\t\n\tpublic:\n    \tMatrix(int row_ = 0,int col_= 0){\n        \tthis->row = row_ ;\n        \tthis->col = col_ ;\n\t\t    this -> val = new T[row*col] ;\n        \tmemset(val,0,row*col*sizeof(T)) ;\n    \t}\n    \tMatrix(int row_, int col_, const T val_[]){\n  \t    \tthis->row = row_ ;\n        \tthis->col = col_ ;\n        \tthis -> val = new T[row*col] ;\n        \tfor(int i = 0 ; i < row ; i ++){\n            \tfor(int k = 0 ; k < col ; k ++){\n\t                this->val[i*col+k] =val_[i*col+k] ;\n    \t        }\n        \t}\n    \t}\n    \t~Matrix() {\n  \t\t\tdelete[] val ;\n    \t}\n    \tvoid print(){\n        \tfor(int i = 0 ; i < row ; i ++){\n\t            for(int k = 0 ; k < col ; k ++){\n\t                cout << \"    \"<<val[i*col+k] ;\n    \t        }\n        \t    cout << endl ;\n        \t}\n    \t}\n    \tMatrix &operator =(const Matrix &m2){\n\t\t\tdelete[]val ;                       \n        \tthis->row =m2.row;\n        \tthis->col =m2.col;\n  \t\t\tthis -> val = new T[row*col] ;\n        \tfor(int i = 0 ; i < row ; i ++){\n\t            for(int k = 0 ; k < col ; k ++){\n                \tthis->val[i*col+k] =m2.val[i*col+k];\n            \t}\n        \t}\n  \t\t\treturn *this ;\n   \t\t}\n \t\tMatrix (Matrix &m2) {                    \n  \t\t\tthis->row =m2.row;\n      \t\tthis->col =m2.col;\n  \t\t\tval= new T[row*col] ;\n        \tfor(int i = 0 ; i < row ; i ++){\n\t            for(int k = 0 ; k < col ; k ++){\n\t                val[i*col+k] =m2.val[i*col+k] ;\n    \t        }\n  \t     \t}\n\t\t}\n   \t\tT &get(int x, int y) {\n        \treturn this->val[(y-1)*col+x-1] ;\n    \t}\n};",
            1590656986.76767,
            100,
            "# 答案正确"
        ],
        [
            "7.2 (C++)",
            "萧锘汶",
            "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nvector<string>split(const string & line,const string & deli=\" \"){\n\tvector<string>words;\n\tint a = 0;\n\twhile (a < line.size()){\n\t\tint end = line.find(deli,a);\n\t\tif(end == a){\n\t\t\ta = a + deli.size();\n\t\t}\n\t\telse{\n\t\t\tif(end == -1){\n\t\t\t\twords.push_back(line.substr(a));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twords.push_back(line.substr(a,end-a));\n\t\t\ta = end + deli.size();\n\t\t}\n\t}\n\treturn words;\n}",
            1591241309.2131271,
            100,
            "# 答案正确"
        ],
        [
            "7.3 (C++)",
            "萧锘汶",
            "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\ntemplate <typename A,typename R>\nvector<R>map2(vector<A> & x,vector<A> & y,R (*map_func)(const A &,const A &)){\n\tvector<R> res;\n\tfor (int i = 0; i < x.size(); ++ i){\n\t\tres.push_back(map_func(x[i],y[i]));\n\t} \n\treturn res;\n}\n\t\t\t  \ntemplate <typename A,typename R>\nvector<R>map2(vector<A> & x,int y,R (*map_func)(const A &,const int &)){\n\tvector<R> res;\n\tfor (int i = 0; i < x.size(); ++ i){\n\t\tres.push_back(map_func(x[i],y));\n\t} \n\treturn res;\n}\t\t\t  ",
            1591266500.885411,
            100,
            "# 答案正确"
        ],
        [
            "8.5 (C++)",
            "萧锘汶",
            "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nclass Point3D: public Point2D\n{\nprivate:\n\tdouble z;\npublic: \n\tPoint3D(){\n\t\tx = 0;\n\t\ty = 0;\n\t\tz = 0;\n\t}\n\tdouble getZ(){\n\t\treturn z;\n\t}\n\tvoid setZ(double z){\n\t\tthis->z = z;\n\t}\n\tdouble distance(Point2D & point2) {\n\t\tdouble dx = x - point2.x;\n\t\tdouble dy = y - point2.y;\n\t\tdouble dz = z - point2.z;\n\t\treturn sqrt(dx * dx + dy * dy + dz * dz);\n\t}\n};",
            1591846629.27435,
            0,
            "main.cpp: In constructor ‘Point3D::Point3D()’:\nmain.cpp:6:9: error: ‘double Point2D::x’ is private\n  double x;\n         ^\nIn file included from main.cpp:39:0:\nsource.cpp:11:3: error: within this context\n   x = 0;\n   ^\nmain.cpp:7:9: error: ‘double Point2D::y’ is private\n  double y;\n         ^\nIn file included from main.cpp:39:0:\nsource.cpp:12:3: error: within this context\n   y = 0;\n   ^\nmain.cpp: In member function ‘virtual double Point3D::distance(Point2D&)’:\nmain.cpp:6:9: error: ‘double Point2D::x’ is private\n  double x;\n         ^\nIn file included from main.cpp:39:0:\nsource.cpp:22:15: error: within this context\n   double dx = x - point2.x;\n               ^\nmain.cpp:6:9: error: ‘double Point2D::x’ is private\n  double x;\n         ^\nIn file included from main.cpp:39:0:\nsource.cpp:22:26: error: within this context\n   double dx = x - point2.x;\n                          ^\nmain.cpp:7:9: error: ‘double Point2D::y’ is private\n  double y;\n         ^\nIn file included from main.cpp:39:0:\nsource.cpp:23:15: error: within this context\n   double dy = y - point2.y;\n               ^\nmain.cpp:7:9: error: ‘double Point2D::y’ is private\n  double y;\n         ^\nIn file included from main.cpp:39:0:\nsource.cpp:23:26: error: within this context\n   double dy = y - point2.y;\n                          ^\nsource.cpp:24:26: error: ‘class Point2D’ has no member named ‘z’\n   double dz = z - point2.z;\n                          ^\nmain.cpp: In function ‘int main()’:\nmain.cpp:63:27: error: no matching function for call to ‘Point3D::Point3D(double&, double&, double&)’\n  Point3D point1(x1, y1, z1);\n                           ^\nIn file included from main.cpp:39:0:\nsource.cpp:10:2: note: candidate: Point3D::Point3D()\n  Point3D(){\n  ^\nsource.cpp:10:2: note:   candidate expects 0 arguments, 3 provided\nsource.cpp:5:7: note: candidate: constexpr Point3D::Point3D(const Point3D&)\n class Point3D: public Point2D\n       ^\nsource.cpp:5:7: note:   candidate expects 1 argument, 3 provided\nsource.cpp:5:7: note: candidate: constexpr Point3D::Point3D(Point3D&&)\nsource.cpp:5:7: note:   candidate expects 1 argument, 3 provided\nmain.cpp:64:27: error: no matching function for call to ‘Point3D::Point3D(double&, double&, double&)’\n  Point3D point2(x2, y2, z2);\n                           ^\nIn file included from main.cpp:39:0:\nsource.cpp:10:2: note: candidate: Point3D::Point3D()\n  Point3D(){\n  ^\nsource.cpp:10:2: note:   candidate expects 0 arguments, 3 provided\nsource.cpp:5:7: note: candidate: constexpr Point3D::Point3D(const Point3D&)\n class Point3D: public Point2D\n       ^\nsource.cpp:5:7: note:   candidate expects 1 argument, 3 provided\nsource.cpp:5:7: note: candidate: constexpr Point3D::Point3D(Point3D&&)\nsource.cpp:5:7: note:   candidate expects 1 argument, 3 provided\n"
        ],
        [
            "8.1 (C++)",
            "萧锘汶",
            "class Full: public Matrix\n{\n\tint rows;\n\tint columns;\n\tdouble* values;\npublic:\n\tFull(int row,int column){\n\t\trows = row;\n\t\tcolumns = column;\n\t\tvalues = new double[rows * columns];\n\t\tmemset(values,0,sizeof(double) * rows * columns);\n\t}\n\tFull(int row,int column,const double value[]){\n\t\trows = row;\n\t\tcolumns = column;\n\t\tvalues = new double[row * column];\n\t\tfor (int i = 0; i < row * column; ++ i) {\n\t\t\tvalues[i] = value[i];\n\t\t}\n\t}\n\tFull(const Matrix & matrix2){\n\t\tFull & matrix1 = (Full &) matrix2;\n\t\trows = matrix1.rows;\n\t\tcolumns = matrix1.columns;\n\t\tvalues = new double[rows * columns];\n\t\tfor (int i = 0; i < rows * columns; ++ i){\n\t\t\tvalues[i] = matrix1.values[i];\n\t\t} \n\t}\n\t~Full(){\n\t\tdelete [] values;\n\t}\n\tvirtual void print(){\n\t\tfor (int i = 0; i < rows * columns; ++ i){\n\t\t\tcout << \"    \" << values[i];\n\t\t\tif((i + 1) % columns == 0){\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t} \n\t}\n\tvirtual int size(int dimension){\n\t\tif(dimension == 1){\n\t\t\treturn rows;\n\t\t}\n\t\tif(dimension == 2){\n\t\t\treturn columns;\n\t\t}\n\t}\n\tvirtual double get(int row,int column){\n\t\treturn values[(row - 1) * columns + column - 1];\n\t}\n\tvirtual Full & operator = (Matrix & matrix2){\n\t\tFull matrix1 = (Full &) matrix2;\n\t\trows = matrix1.rows;\n\t\tcolumns = matrix1.columns;\n\t\tdelete [] values;\n\t\tvalues = new double[rows * columns];\n\t\tfor (int i = 0; i < columns * rows; ++ i){\n\t\t\tvalues[i] = matrix1.values[i];\n\t\t} \n\t\treturn matrix1;\n\t}\n};",
            1591879224.2196655,
            0,
            "In file included from main.cpp:21:0:\nsource.cpp: In constructor ‘Full::Full(int, int)’:\nsource.cpp:11:50: error: ‘memset’ was not declared in this scope\n   memset(values,0,sizeof(double) * rows * columns);\n                                                  ^\nsource.cpp: In member function ‘virtual Full& Full::operator=(Matrix&)’:\nsource.cpp:53:27: error: cannot allocate an object of abstract type ‘Full’\n   Full matrix1 = (Full &) matrix2;\n                           ^\nsource.cpp:1:7: note:   because the following virtual functions are pure within ‘Full’:\n class Full: public Matrix\n       ^\nmain.cpp:10:14: note: \tvirtual int Matrix::size(int) const\n  virtual int size(int dimension) const = 0;\n              ^\nmain.cpp:12:15: note: \tvirtual void Matrix::set(int, int, double)\n  virtual void set(int row, int column, double value) = 0;\n               ^\nmain.cpp:14:17: note: \tvirtual double Matrix::get(int, int) const\n  virtual double get(int row, int column) const = 0;\n                 ^\nmain.cpp:16:15: note: \tvirtual void Matrix::print() const\n  virtual void print() const = 0;\n               ^\nmain.cpp:18:19: note: \tvirtual Matrix& Matrix::operator=(const Matrix&)\n  virtual Matrix & operator = (const Matrix & matrix2) = 0;\n                   ^\nIn file included from main.cpp:21:0:\nsource.cpp:53:8: error: cannot declare variable ‘matrix1’ to be of abstract type ‘Full’\n   Full matrix1 = (Full &) matrix2;\n        ^\nsource.cpp:53:8: warning: reference to local variable ‘matrix1’ returned [-Wreturn-local-addr]\nmain.cpp: At global scope:\nmain.cpp:23:1: error: invalid abstract return type ‘Full’\n Full readMatrix() {\n ^\nmain.cpp: In function ‘Full readMatrix()’:\nmain.cpp:23:6: error: invalid abstract return type for function ‘Full readMatrix()’\n Full readMatrix() {\n      ^\nmain.cpp:31:7: error: cannot declare variable ‘matrix’ to be of abstract type ‘Full’\n  Full matrix(rows, columns, values);\n       ^\nmain.cpp:32:9: error: cannot allocate an object of abstract type ‘Full’\n  return matrix;\n         ^\nmain.cpp: In function ‘int main()’:\nmain.cpp:41:7: error: cannot declare variable ‘full1’ to be of abstract type ‘Full’\n  Full full1(3, 3);\n       ^\nmain.cpp:46:38: error: cannot allocate an object of abstract type ‘Full’\n  const Matrix & matrix2 = readMatrix();\n                                      ^\nmain.cpp:50:15: error: cannot allocate an object of abstract type ‘Full’\n  Full full3 = matrix2;\n               ^\nmain.cpp:50:7: error: cannot declare variable ‘full3’ to be of abstract type ‘Full’\n  Full full3 = matrix2;\n       ^\n"
        ],
        [
            "8.4 (C++)",
            "萧锘汶",
            "#define f(i,start,n) for(int i = start;i < n;i++)\n#include<vector>\n#include<iostream>\nusing namespace std;\nclass Sparse:public Matrix{\nprivate:\n    int rows;\n    int columns;\n    vector<Entry> entry;\npublic:\n    Sparse(int row, int column): rows(row),columns(column){}\n    Sparse(const Sparse& other){\n        rows = other.rows;\n        columns = other.columns;\n        entry = other.entry;\n    }\n    int find(const int row,const int column,const vector<Entry> entry) const{\n        f(i,0,entry.size()){\n            if(row == entry[i].row && column == entry[i].column) return i;\n        }\n        return -1;\n    }\n    int finnd(const int row,const vector<Entry> entry,const int start) const{\n        f(i,start,entry.size()){\n            if(row == entry[i].row) return i;\n        }\n        return -1;\n    }\n    Sparse operator + (Sparse & sparse2){\n        Sparse ans(rows,columns);\n        f(i,0,entry.size()){\n            Entry temp = entry[i];\n            int index = find(entry[i].row,entry[i].column,sparse2.entry);\n            if(index != -1){\n                temp.value += sparse2.entry[index].value;\n            }\n            if(temp.value != 0) ans.entry.push_back(temp);\n        }\n        f(i,0,sparse2.entry.size()){\n            if(find(sparse2.entry[i].row,sparse2.entry[i].column,entry) == -1) ans.entry.push_back(sparse2.entry[i]);\n        }\n        return ans;\n    }\n    Sparse operator * (Sparse & sparse2){\n        Sparse ans(rows,sparse2.columns);\n        f(i,0,entry.size()){\n            int index = -1;\n            while(index < (int)sparse2.entry.size()){\n                index = finnd(entry[i].column,sparse2.entry,index + 1);\n                if(index == -1){\n                    break;\n                }\n                Entry temp;\n                temp.row = entry[i].row;\n                temp.column = sparse2.entry[index].column;\n                temp.value = entry[i].value * sparse2.entry[index].value;\n                int iindex = find(temp.row,temp.column,ans.entry);\n                if(iindex == -1) ans.entry.push_back(temp);\n                else ans.entry[iindex].value += temp.value;\n            }\n        }\n        return ans;\n    }\n    virtual int size(int dimension) const{\n        if(dimension == 1) return rows;\n        else return columns;\n    }\n    virtual void set(int row, int column, double value){\n        int index = find(row,column,entry);\n        if(index == -1){\n            Entry temp{row,column,value};\n            entry.push_back(temp);\n        }\n        else{\n            entry[index].value = value;\n        }\n    }\n\tvirtual double get(int row, int column) const{\n\t    int index = find(row,column,entry);\n\t    return entry[index].value;\n\t}\n\tvirtual void print(){\n        f(i,0,(int)entry.size() - 1){\n            f(j,i+1,(int)entry.size()){\n                if(entry[i].row > entry[j].row || (entry[i].row == entry[j].row && entry[i].column > entry[j].column)){\n                    Entry temp;\n                    temp = entry[i];\n                    entry[i] = entry[j];\n                    entry[j] = temp;\n                }\n            }\n        }\n        f(i,0,(int)entry.size()){\n            cout << \"(\" << entry[i].row << \",\" << entry[i].column << \",\" << entry[i].value << \")\" << endl;\n        }\n\t}\n};\t",
            1591878378.2758656,
            100,
            "# 答案正确"
        ],
        [
            "8.3 (C++)",
            "萧锘汶",
            "#define f(i,start,n) for(int i = start;i < n;i++)\n#include<vector>\n#include<iostream>\nusing namespace std;\nclass Sparse:public Matrix{\nprivate:\n    int rows;\n    int columns;\n    vector<Entry> entry;\npublic:\n    Sparse(int row, int column): rows(row),columns(column){}\n    Sparse(const Sparse& other){\n        rows = other.rows;\n        columns = other.columns;\n        entry = other.entry;\n    }\n    int find(const int row,const int column,const vector<Entry> entry) const{\n        f(i,0,entry.size()){\n            if(row == entry[i].row && column == entry[i].column) return i;\n        }\n        return -1;\n    }\n    int finnd(const int row,const vector<Entry> entry,const int start) const{\n        f(i,start,entry.size()){\n            if(row == entry[i].row) return i;\n        }\n        return -1;\n    }\n    Sparse operator + (Sparse & sparse2){\n        Sparse ans(rows,columns);\n        f(i,0,entry.size()){\n            Entry temp = entry[i];\n            int index = find(entry[i].row,entry[i].column,sparse2.entry);\n            if(index != -1){\n                temp.value += sparse2.entry[index].value;\n            }\n            if(temp.value != 0) ans.entry.push_back(temp);\n        }\n        f(i,0,sparse2.entry.size()){\n            if(find(sparse2.entry[i].row,sparse2.entry[i].column,entry) == -1) ans.entry.push_back(sparse2.entry[i]);\n        }\n        return ans;\n    }\n    virtual int size(int dimension) const{\n        if(dimension == 1) return rows;\n        else return columns;\n    }\n    virtual void set(int row, int column, double value){\n        int index = find(row,column,entry);\n        if(index == -1){\n            Entry temp{row,column,value};\n            entry.push_back(temp);\n        }\n        else{\n            entry[index].value = value;\n        }\n    }\n\tvirtual double get(int row, int column) const{\n\t    int index = find(row,column,entry);\n\t    return entry[index].value;\n\t}\n\tvirtual void print(){\n        f(i,0,(int)entry.size() - 1){\n            f(j,i+1,(int)entry.size()){\n                if(entry[i].row > entry[j].row || (entry[i].row == entry[j].row && entry[i].column > entry[j].column)){\n                    Entry temp;\n                    temp = entry[i];\n                    entry[i] = entry[j];\n                    entry[j] = temp;\n                }\n            }\n        }\n        f(i,0,(int)entry.size()){\n            cout << \"(\" << entry[i].row << \",\" << entry[i].column << \",\" << entry[i].value << \")\" << endl;\n        }\n\t}\n};",
            1591878499.9259615,
            100,
            "# 答案正确"
        ],
        [
            "8.6 (C++)",
            "萧锘汶",
            "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass MyTensor:public Tensor{\nprivate:\n\tdouble * num;\npublic:\n\tMyTensor(vector<int> size):Tensor<double>(i){\n\t\tvector<int> sizes;\n\t\tsizes = size;\n\t\tint a = 1;\n\t\tfor (int i = 0; i < sizes.size(); ++ i){\n\t\t\ta *= sizes[i];\n\t\t} \n\t\tnum = new double [a];\n\t}\n\tvirtual double & get(const vector<int>& indexes){\n\t\tint b = 0;\n\t\tfor (int i = 0; i < sizes.size(); ++ i){\n\t\t\tint c = 1;\n\t\t\tfor (int j = 0; j < sizes.size(); ++ j){\n\t\t\t\tc *= indexes[j];\n\t\t\t} \n\t\t\tb += c;\n\t\t} \n\t\tb += indexes[sizes.size() - 1];\n\t\treturn num[b];\n\t}\n\t~MyTensor(){\n\t\tdelete [] data;\n\t}\n};",
            1592451578.6487052,
            0,
            "In file included from main.cpp:14:0:\nsource.cpp:5:29: error: expected class-name before ‘{’ token\n class MyTensor:public Tensor{\n                             ^\nsource.cpp: In constructor ‘MyTensor::MyTensor(std::vector<int>)’:\nsource.cpp:9:29: error: type ‘Tensor<double>’ is not a direct base of ‘MyTensor’\n  MyTensor(vector<int> size):Tensor<double>(i){\n                             ^\nsource.cpp:9:44: error: ‘i’ was not declared in this scope\n  MyTensor(vector<int> size):Tensor<double>(i){\n                                            ^\nsource.cpp: In member function ‘virtual double& MyTensor::get(const std::vector<int>&)’:\nsource.cpp:20:23: error: ‘sizes’ was not declared in this scope\n   for (int i = 0; i < sizes.size(); ++ i){\n                       ^\nsource.cpp:27:16: error: ‘sizes’ was not declared in this scope\n   b += indexes[sizes.size() - 1];\n                ^\nsource.cpp: In destructor ‘MyTensor::~MyTensor()’:\nsource.cpp:31:13: error: ‘data’ was not declared in this scope\n   delete [] data;\n             ^\nmain.cpp: In function ‘int main()’:\nmain.cpp:28:24: error: invalid initialization of reference of type ‘Tensor<double>&’ from expression of type ‘MyTensor’\n  Tensor<double> & t1 = mt1;\n                        ^\nmain.cpp:33:24: error: invalid initialization of reference of type ‘Tensor<double>&’ from expression of type ‘MyTensor’\n  Tensor<double> & t2 = mt2;\n                        ^\n"
        ],
        [
            "9.1 (C++)",
            "萧锘汶",
            "#include <iostream>\nusing namespace std;\n\nclass Circle{\nprivate:\n    double radii;\npublic:\n    Circle(double radius): radii(radius){}\n    int operator <(Circle c2){\n        if(radii < c2.radii) return 1;\n        else return 0;\n    }\n    int operator <=(Circle c2){\n        if(radii <= c2.radii) return 1;\n        else return 0;\n    }\n    int operator ==(Circle c2){\n        if(radii == c2.radii) return 1;\n        else return 0;\n    }\n    int operator !=(Circle c2){\n        if(radii != c2.radii) return 1;\n        else return 0;\n    }\n    int operator >(Circle c2){\n        if(radii > c2.radii) return 1;\n        else return 0;\n    }\n    int operator >=(Circle c2){\n        if(radii >= c2.radii) return 1;\n        else return 0;\n    }\n};",
            1593082747.3169718,
            100,
            "# 答案正确"
        ],
        [
            "9.2 (C++)",
            "萧锘汶",
            "class I{\nprivate:\n    vector<int> sizes;\npublic:\n    I(int a,int b,int c){\n        sizes.push_back(a);\n        sizes.push_back(b);\n        sizes.push_back(c);\n    }\n    I(int a,int b,int c,int d){\n        sizes.push_back(a);\n        sizes.push_back(b);\n        sizes.push_back(c);\n        sizes.push_back(d);\n    }\n    operator vector<int>()const{\n        return sizes;\n    }\n};",
            1593082824.1005225,
            100,
            "# 答案正确"
        ],
        [
            "9.3 (C++)",
            "萧锘汶",
            "class Complex{\nprivate:\n    double a;\n    double b;\npublic:\n    Complex(double x): a(x),b(0){}\n    Complex(double a,double b): a(a),b(b){}\n    Complex(const Complex& ano): a(ano.a),b(ano.b){}\n    double real()const{return a;}\n    double imag()const{return b;}\n    Complex& operator =(const Complex& ano){\n        a = ano.a;\n        b = ano.b;\n        return (*this);\n    }\n    Complex operator -(const Complex& ano) const{\n        Complex temp(a - ano.a,b - ano.b);\n        return temp;\n    }\n    Complex operator *(const Complex& ano) const{\n        double aa = a * ano.a - b * ano.b;\n        double bb = a * ano.b + ano.a * b;\n        Complex temp(aa,bb);\n        return temp;\n    }\n    Complex operator /(const Complex& ano) const{\n        double aa = (a * ano.a + b * ano.b) / (ano.a * ano.a + ano.b * ano.b);\n        double bb = (-a * ano.b + ano.a * b) / (ano.a * ano.a + ano.b * ano.b);\n        Complex temp(aa,bb);\n        return temp;\n    }\n    Complex& operator +=(const Complex& ano){\n        a += ano.a;\n        b += ano.b;\n        return (*this);\n    }\n    Complex& operator -=(const Complex& ano){\n        a -= ano.a;\n        b -= ano.b;\n        return (*this);\n    }\n    Complex& operator *=(const Complex& ano){\n        double aa = a * ano.a - b * ano.b;\n        double bb = a * ano.b + ano.a * b;\n        a = aa;\n        b = bb;\n        return (*this);\n    }\n    Complex& operator /=(const Complex& ano){\n        double aa = (a * ano.a + b * ano.b) / (ano.a * ano.a + ano.b * ano.b);\n        double bb = (-a * ano.b + ano.a * b) / (ano.a * ano.a + ano.b * ano.b);\n        a = aa;\n        b = bb;\n        return (*this);\n    }\n    bool operator ==(const Complex& ano){\n        if(a == ano.a && b == ano.b) return true;\n        else return false;\n    }\n    bool operator !=(const Complex& ano){\n        if(a == ano.a && b == ano.b) return false;\n        else return true;\n    }\n};\n\nComplex operator +(const Complex& a,const Complex& b){\n    Complex temp(a.real() + b.real(),a.imag() + b.imag());\n    return temp;\n}",
            1593082860.2931066,
            100,
            "# 答案正确"
        ],
        [
            "9.4 (C++)",
            "萧锘汶",
            "class Complex{\nprivate:\n    double a;\n    double b;\npublic:\n    Complex():a(0),b(0){}\n    Complex(double x): a(x),b(0){}\n    Complex(double a,double b): a(a),b(b){}\n    Complex(const Complex& ano): a(ano.a),b(ano.b){}\n    double real()const{return a;}\n    double imag()const{return b;}\n    Complex& operator =(const Complex& ano){\n        a = ano.a;\n        b = ano.b;\n        return (*this);\n    }\n    Complex operator -(const Complex& ano) const{\n        Complex temp(a - ano.a,b - ano.b);\n        return temp;\n    }\n    Complex operator *(const Complex& ano) const{\n        double aa = a * ano.a - b * ano.b;\n        double bb = a * ano.b + ano.a * b;\n        Complex temp(aa,bb);\n        return temp;\n    }\n    Complex operator /(const Complex& ano) const{\n        double aa = (a * ano.a + b * ano.b) / (ano.a * ano.a + ano.b * ano.b);\n        double bb = (-a * ano.b + ano.a * b) / (ano.a * ano.a + ano.b * ano.b);\n        Complex temp(aa,bb);\n        return temp;\n    }\n    Complex& operator +=(const Complex& ano){\n        a += ano.a;\n        b += ano.b;\n        return (*this);\n    }\n    Complex& operator -=(const Complex& ano){\n        a -= ano.a;\n        b -= ano.b;\n        return (*this);\n    }\n    Complex& operator *=(const Complex& ano){\n        double aa = a * ano.a - b * ano.b;\n        double bb = a * ano.b + ano.a * b;\n        a = aa;\n        b = bb;\n        return (*this);\n    }\n    Complex& operator /=(const Complex& ano){\n        double aa = (a * ano.a + b * ano.b) / (ano.a * ano.a + ano.b * ano.b);\n        double bb = (-a * ano.b + ano.a * b) / (ano.a * ano.a + ano.b * ano.b);\n        a = aa;\n        b = bb;\n        return (*this);\n    }\n    bool operator ==(const Complex& ano){\n        if(a == ano.a && b == ano.b) return true;\n        else return false;\n    }\n    bool operator !=(const Complex& ano){\n        if(a == ano.a && b == ano.b) return false;\n        else return true;\n    }\n\n};\n\nComplex operator +(const Complex& a,const Complex& b){\n    Complex temp(a.real() + b.real(),a.imag() + b.imag());\n    return temp;\n}\nistream& operator >> (istream& in,Complex& com){\n    double a,b;\n    in >> a >> b;\n    Complex temp(a,b);\n    com = temp;\n    return in;\n}\nostream& operator << (ostream& out,Complex& com){\n    out <<  com.real() << \" + \" << com.imag() << \" i\";\n    return out;\n}",
            1593082885.5341587,
            100,
            "# 答案正确"
        ],
        [
            "9.5 (C++)",
            "萧锘汶",
            "class Complex{\nprivate:\n    double a;\n    double b;\npublic:\n    Complex():a(0),b(0){}\n    Complex(double x): a(x),b(0){}\n    Complex(double a,double b): a(a),b(b){}\n    Complex(const Complex& ano): a(ano.a),b(ano.b){}\n    double real()const{return a;}\n    double imag()const{return b;}\n    Complex& operator =(const Complex& ano){\n        a = ano.a;\n        b = ano.b;\n        return (*this);\n    }\n    Complex operator -(const Complex& ano) const{\n        Complex temp(a - ano.a,b - ano.b);\n        return temp;\n    }\n    Complex operator *(const Complex& ano) const{\n        double aa = a * ano.a - b * ano.b;\n        double bb = a * ano.b + ano.a * b;\n        Complex temp(aa,bb);\n        return temp;\n    }\n    Complex operator /(const Complex& ano) const{\n        double aa = (a * ano.a + b * ano.b) / (ano.a * ano.a + ano.b * ano.b);\n        double bb = (-a * ano.b + ano.a * b) / (ano.a * ano.a + ano.b * ano.b);\n        Complex temp(aa,bb);\n        return temp;\n    }\n    Complex& operator +=(const Complex& ano){\n        a += ano.a;\n        b += ano.b;\n        return (*this);\n    }\n    Complex& operator -=(const Complex& ano){\n        a -= ano.a;\n        b -= ano.b;\n        return (*this);\n    }\n    Complex& operator *=(const Complex& ano){\n        double aa = a * ano.a - b * ano.b;\n        double bb = a * ano.b + ano.a * b;\n        a = aa;\n        b = bb;\n        return (*this);\n    }\n    Complex& operator /=(const Complex& ano){\n        double aa = (a * ano.a + b * ano.b) / (ano.a * ano.a + ano.b * ano.b);\n        double bb = (-a * ano.b + ano.a * b) / (ano.a * ano.a + ano.b * ano.b);\n        a = aa;\n        b = bb;\n        return (*this);\n    }\n    bool operator ==(const Complex& ano){\n        if(a == ano.a && b == ano.b) return true;\n        else return false;\n    }\n    bool operator !=(const Complex& ano){\n        if(a == ano.a && b == ano.b) return false;\n        else return true;\n    }\n    Complex& operator ++(){\n        a++;\n        return (*this);\n    }\n    Complex operator ++(int){\n        Complex temp(*this);\n        a++;\n        return temp;\n    }\n    operator double(){\n        return a;\n    }\n};\n\nComplex operator +(const Complex& a,const Complex& b){\n    Complex temp(a.real() + b.real(),a.imag() + b.imag());\n    return temp;\n}\nistream& operator >> (istream& in,Complex& com){\n    double a,b;\n    in >> a >> b;\n    Complex temp(a,b);\n    com = temp;\n    return in;\n}\nostream& operator << (ostream& out,const Complex& com){\n    out <<  com.real() << \" + \" << com.imag() << \" i\";\n    return out;\n}",
            1593082945.2461782,
            100,
            "# 答案正确"
        ],
        [
            "9.6 (C++)",
            "萧锘汶",
            "class Tensor{\nprivate:\n    vector<int> sizes;\n    double* data;\npublic:\n    Tensor(int a,int b,int c){\n        sizes.push_back(a);\n        sizes.push_back(b);\n        sizes.push_back(c);\n        data = new double[a * b * c];\n    }\n    Tensor(int a,int b,int c,int d){\n        sizes.push_back(a);\n        sizes.push_back(b);\n        sizes.push_back(c);\n        sizes.push_back(d);\n        data = new double[a * b * c * d];\n    }\n    ~Tensor(){\n        delete []data;\n    }\n    double& operator ()(int a,int b,int c){\n        int s = (a * sizes[1] + b) * sizes[2] + c;\n        return data[s];\n    }\n    double& operator ()(int a,int b,int c,int d){\n        int s = ((a * sizes[1] + b) * sizes[2] + c) * sizes[3] + d;\n        return data[s];\n    }\n};",
            1593082966.2239773,
            100,
            "# 答案正确"
        ],
        [
            "9.7 (C++)",
            "萧锘汶",
            "class Tensor\n{\nprivate:\n    int dimention;\n\tvector<int> sizes;\n\tvector<double> values;\npublic:\n\tTensor() = default;\n\tTensor(int dimention,vector<int> sizes,vector<double> values):  dimention(dimention),sizes(sizes),values(values){}\n\tint allsize() const {\n\t\tif (this->sizes.size() == 0) return 0;\n\t\tint size = 1;\n\t\tfor (int i = 0; i < this->sizes.size(); ++ i) size *= sizes[i];\n\t\treturn size;\n\t}\n\tint di() const{return dimention;}\n    int size(int i) const{return sizes[i];}\n\tdouble get(int i) const {return values[i];}\n\tTensor& operator =(Tensor& ano){\n        dimention = ano.dimention;\n        sizes = ano.sizes;\n        values = ano.values;\n        return (*this);\n\t}\n};\nistream& operator >>(istream& in,Tensor& t){\n    int dimention;\n    in >> dimention;\n    vector<int> sizes;\n    vector<double> values;\n    int allsize = 1;\n    for(int i = 0;i < dimention;i++){\n        int temp;\n        in >> temp;\n        allsize *= temp;\n        sizes.push_back(temp);\n    }\n    for(int i = 0;i < allsize;i++){\n        double temp;\n        in >> temp;\n        values.push_back(temp);\n    }\n    Tensor temp(dimention,sizes,values);\n    t = temp;\n    return in;\n}\nostream& operator <<(ostream& out,const Tensor& t){\n    out << t.di() << endl;\n    for(int i = 0;i < t.di();i++){\n        out << t.size(i) << \" \";\n    }\n    out << endl << endl;\n    int sum = 1;\n    for(int i = 0;i < t.di() - 2;i++){\n        sum *= t.size(i);\n    }\n    int index = 0;\n    for(int i = 0;i < sum;i++){\n        for(int j = 0;j < t.size(t.di() - 2);j++){\n            for(int k = 0;k < t.size(t.di() - 1);k++){\n                out << t.get(index++) << \" \";\n            }\n            out << endl;\n        }\n        out << endl;\n    }\n    return out;\n}",
            1593083017.1102078,
            100,
            "# 答案正确"
        ],
        [
            "10.2 (C++)",
            "萧锘汶",
            "\tcatch(NonPositiveValueException & ex){\n\t\tcout << \"caught\" << ':' << ' ' << \"NonPositiveValueException\" << endl;\n\t}\n\tcatch(out_of_range & index){\n\t\tcout << \"caught\" << ':' << ' ' << \"out_of_range\" << endl;\n\t}",
            1593660017.4717925,
            100,
            "# 答案正确"
        ],
        [
            "2020-07-09 LAB",
            "萧锘汶",
            "#include<iostream>\n#include<vector>\nusing namespace std;\n\nclass Integer{\nprivate:\n    int num;\n    static vector<Integer*> index;\npublic:\n    Integer(): num(0){\n        index.push_back(this);\n    }\n    Integer(int x): num(x){\n        index.push_back(this);\n    }\n    void change_value(const int& x){\n\t\tnum = x;\n\t}\n    int get_value()const{\n\t\treturn num;\n\t}\n    static void increase_all(const Integer& x){\n        for(int i = 0;i < index.size();i++){\n            index[i]->change_value(index[i]->get_value()+x.get_value());\n        }\n    }\n};\nvector<Integer*> Integer::index = vector<Integer*>();\n\nistream& operator >> (istream& in,Integer& x){\n    int num;\n    in >> num;\n    x.change_value(num);\n    return in;\n}\nostream& operator << (ostream& out,Integer& x){\n    out << x.get_value();\n    return out;\n}",
            1594263208.3463933,
            100,
            "# 答案正确"
        ],
        [
            "A.2 (C++)",
            "萧锘汶",
            "template<typename E>\nvoid LinkedList<E>:: removeALL(const E & e){\n\tNode<E> * prev_node = get_node(e - 1);\n\tNode<E> * node = prev_node->next_node;\n\tprev_node->next_node = node->next_node;\n\tdelete node;\n\t-- _size;\n}",
            1594870739.7941983,
            0,
            "In file included from main.cpp:173:0:\nsource.cpp:2:43: error: no ‘void LinkedList<E>::removeALL(const E&)’ member function declared in class ‘LinkedList<E>’\n void LinkedList<E>:: removeALL(const E & e){\n                                           ^\n"
        ],
        [
            "A.4 (C++)",
            "萧锘汶",
            "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <stdexcept>\nusing namespace std;\n\nclass NoSuchKeyExceotion{};\n\nsize_t circular_shift(size_t bits,int shift_bits){\n\tconst int num_bits = 8 * sizeof(size_t);\n\tshift_bits = shift_bits % num_bits;\n\treturn bits < < shift_bits | bits > > (num_bits - shift_bits);\n}\n\nsize_t hash_funtion(const string & key){\n\tsize_t code = 0;\n\tfor (int i = 0; i < key.size(); ++ i){\n\t\tcode ^= circular_shift(key[i],i * 5);\n\t} \n\treturn code;\n}\n\nclass Tuple\n{\n\tstring key;\n\tint val;\n\tbool in_use;\n\t\n\tTuple():in_use(false){};\n};\nclass HT\n{\n\tvector<Tuple>tuples;\n\tsize_t _size;\n\t\n\tsize_t canonical_index(const string & key)const{\n\t\tsize_t hash_code = hash_funtion(key);\n\t\treturn hash_code % tuples.size();\n\t}\n\t\n\tsize_t indexOfKey(const string & key)const{\n\t\tsize_t index = canonical_index(key);\n\t\twhile(ture){\n\t\t\tif(!tuples[index].in_use) return index;\n\t\t\tif(tuples[index].key == key) return index;\n\t\t\tindex = (index + 1) % tuples.size();\n \t\t}\n\t}\n\t\npublic:\n\tHT():size(0){\n\t\ttuples.resize(2);\n\t}\n\t\n\tbool containsKey(const string & key)const{\n\t\tsize_t index = indexOfKey(key);\n\t\treturn tuples[index].in_use;\n\t}\n\t\n\tconst int & operator [] (const string & key)const{\n\t\tsize_t index = indexOfKey(key);\n\t\tif(!tuples[index].in_use){\n\t\t\tthrow NoSuchKeyExceotion();\n\t\t}\n\t\treturn tuples[index].val;\n\t}\n\t\n\tvoid put(const string & key,const int & val){\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].key = key;\n\t\ttuples[index].val = val;\n\t\tif(tuples[index].in_use)return;\n\t\ttuples[index].in_use = ture;\n\t\t++ _size;\n\t\tif(2 * _size > tuples.size()) _double_tuples();\n\t}\n\t\n\tvoid _double_tuples(){\n\t\tvector<Tuple>non_empty_tuples;\n\t\tfor (int i = 0; i < tuples.size(); ++ i){\n\t\t\tif(tuples.in_use){\n\t\t\t\tnon_empty_tuples.push_back(tuples[i]);\n\t\t\t} \n\t\t} \n\t\tclear();\n\t\ttuples,resize(tuples.size() * 2);\n\t\tfor (int i = 0; i < non_empty_tuples.size(); ++ i){\n\t\t\tput(non_empty_tuples[i].key,non_empty_tuples[i].val);\n\t\t} \n\t}\n\t\n\tstatic bool _between(size_t hole,size_t canonical,size_t tuple_index){\n\t\tif(hole < tuple_index){\n\t\t\treturn canonical > hole && canonical <= tuple_index;\n\t\t}\n\t\telse{\n\t\t\treturn canonical > hole || canonical <= tuple_index;\n\t\t}\n\t}\n\t\n\tvoid remove(const string & key){\n\t\tsize_t index = indexOfKey(key);\n\t\tif(!tuples[index].in_use){\n\t\t\tthrow NoSuchKeyExceotion();\n\t\t}\n\t\ttuples[index].in_use = false;\n\t\t-- _size;\n\t\tsize_t hole = index;\n\t\tsize_t tuple_index = hole;\n\t\twhile(true){\n\t\t\ttuple_index = (tuple_index + 1) % tuples.size();\n\t\t\tif(!tuples[tuple_index].in_use)return;\n\t\t\tsize_t canonical = canonical_index(tuples[tuple_index].key);\n\t\t\tif(_between(hole,canonical,tuple_index))continue;\n\t\t\ttuples[hole] = tuples[tuple_index];\n\t\t\thole = tuple_index;\n\t\t\ttuple[hole].in_use = false;\n\t\t}\n\t}\n\t\n\tsize_t size() const{\n\t\treturn _size;\n\t}\n\t\n\tvoid clear(){\n\t\tfor(int i = 0;i < tuples.size();++ i){\n\t\t\ttuples[i].in_use = false;\n\t\t}\n\t\t_size = 0;\n\t}\n\t\n\t\n};",
            1595065379.2007377,
            0,
            "In file included from main.cpp:1:0:\nsource.cpp: In function ‘size_t circular_shift(size_t, int)’:\nsource.cpp:14:16: error: expected primary-expression before ‘<’ token\n  return bits < < shift_bits | bits > > (num_bits - shift_bits);\n                ^\nsource.cpp:14:38: error: expected primary-expression before ‘>’ token\n  return bits < < shift_bits | bits > > (num_bits - shift_bits);\n                                      ^\nsource.cpp: In member function ‘size_t HT::indexOfKey(const string&) const’:\nsource.cpp:45:9: error: ‘ture’ was not declared in this scope\n   while(ture){\n         ^\nsource.cpp:29:7: error: ‘bool Tuple::in_use’ is private\n  bool in_use;\n       ^\nsource.cpp:46:22: error: within this context\n    if(!tuples[index].in_use) return index;\n                      ^\nsource.cpp:27:9: error: ‘std::__cxx11::string Tuple::key’ is private\n  string key;\n         ^\nsource.cpp:47:21: error: within this context\n    if(tuples[index].key == key) return index;\n                     ^\nsource.cpp: In constructor ‘HT::HT()’:\nsource.cpp:53:7: error: class ‘HT’ does not have any field named ‘size’\n  HT():size(0){\n       ^\nsource.cpp: In member function ‘bool HT::containsKey(const string&) const’:\nsource.cpp:29:7: error: ‘bool Tuple::in_use’ is private\n  bool in_use;\n       ^\nsource.cpp:59:24: error: within this context\n   return tuples[index].in_use;\n                        ^\nsource.cpp: In member function ‘const int& HT::operator[](const string&) const’:\nsource.cpp:29:7: error: ‘bool Tuple::in_use’ is private\n  bool in_use;\n       ^\nsource.cpp:64:21: error: within this context\n   if(!tuples[index].in_use){\n                     ^\nsource.cpp:28:6: error: ‘int Tuple::val’ is private\n  int val;\n      ^\nsource.cpp:67:24: error: within this context\n   return tuples[index].val;\n                        ^\nsource.cpp: In member function ‘void HT::put(const string&, const int&)’:\nsource.cpp:27:9: error: ‘std::__cxx11::string Tuple::key’ is private\n  string key;\n         ^\nsource.cpp:72:17: error: within this context\n   tuples[index].key = key;\n                 ^\nsource.cpp:28:6: error: ‘int Tuple::val’ is private\n  int val;\n      ^\nsource.cpp:73:17: error: within this context\n   tuples[index].val = val;\n                 ^\nsource.cpp:29:7: error: ‘bool Tuple::in_use’ is private\n  bool in_use;\n       ^\nsource.cpp:74:20: error: within this context\n   if(tuples[index].in_use)return;\n                    ^\nsource.cpp:29:7: error: ‘bool Tuple::in_use’ is private\n  bool in_use;\n       ^\nsource.cpp:75:17: error: within this context\n   tuples[index].in_use = ture;\n                 ^\nsource.cpp:75:26: error: ‘ture’ was not declared in this scope\n   tuples[index].in_use = ture;\n                          ^\nsource.cpp: In member function ‘void HT::_double_tuples()’:\nsource.cpp:83:14: error: ‘class std::vector<Tuple>’ has no member named ‘in_use’\n    if(tuples.in_use){\n              ^\nsource.cpp:88:34: error: ‘resize’ was not declared in this scope\n   tuples,resize(tuples.size() * 2);\n                                  ^\nsource.cpp:27:9: error: ‘std::__cxx11::string Tuple::key’ is private\n  string key;\n         ^\nsource.cpp:90:28: error: within this context\n    put(non_empty_tuples[i].key,non_empty_tuples[i].val);\n                            ^\nsource.cpp:28:6: error: ‘int Tuple::val’ is private\n  int val;\n      ^\nsource.cpp:90:52: error: within this context\n    put(non_empty_tuples[i].key,non_empty_tuples[i].val);\n                                                    ^\nsource.cpp: In member function ‘void HT::remove(const string&)’:\nsource.cpp:29:7: error: ‘bool Tuple::in_use’ is private\n  bool in_use;\n       ^\nsource.cpp:105:21: error: within this context\n   if(!tuples[index].in_use){\n                     ^\nsource.cpp:29:7: error: ‘bool Tuple::in_use’ is private\n  bool in_use;\n       ^\nsource.cpp:108:17: error: within this context\n   tuples[index].in_use = false;\n                 ^\nsource.cpp:29:7: error: ‘bool Tuple::in_use’ is private\n  bool in_use;\n       ^\nsource.cpp:114:28: error: within this context\n    if(!tuples[tuple_index].in_use)return;\n                            ^\nsource.cpp:27:9: error: ‘std::__cxx11::string Tuple::key’ is private\n  string key;\n         ^\nsource.cpp:115:59: error: within this context\n    size_t canonical = canonical_index(tuples[tuple_index].key);\n                                                           ^\nsource.cpp:119:9: error: missing template arguments before ‘[’ token\n    tuple[hole].in_use = false;\n         ^\nsource.cpp: In member function ‘void HT::clear()’:\nsource.cpp:29:7: error: ‘bool Tuple::in_use’ is private\n  bool in_use;\n       ^\nsource.cpp:129:14: error: within this context\n    tuples[i].in_use = false;\n              ^\nmain.cpp: In function ‘int main()’:\nmain.cpp:13:22: error: no matching function for call to ‘HT::put(int&, int&)’\n  map.put(key1, value1);\n                      ^\nIn file included from main.cpp:1:0:\nsource.cpp:70:7: note: candidate: void HT::put(const string&, const int&)\n  void put(const string & key,const int & val){\n       ^\nsource.cpp:70:7: note:   no known conversion for argument 1 from ‘int’ to ‘const string& {aka const std::__cxx11::basic_string<char>&}’\nmain.cpp:18:22: error: no matching function for call to ‘HT::put(std::__cxx11::string&, std::__cxx11::string&)’\n  map.put(key2, value2);\n                      ^\nIn file included from main.cpp:1:0:\nsource.cpp:70:7: note: candidate: void HT::put(const string&, const int&)\n  void put(const string & key,const int & val){\n       ^\nsource.cpp:70:7: note:   no known conversion for argument 2 from ‘std::__cxx11::string {aka std::__cxx11::basic_string<char>}’ to ‘const int&’\nmain.cpp:23:22: error: no matching function for call to ‘HT::put(int&, std::__cxx11::string&)’\n  map.put(key3, value3);\n                      ^\nIn file included from main.cpp:1:0:\nsource.cpp:70:7: note: candidate: void HT::put(const string&, const int&)\n  void put(const string & key,const int & val){\n       ^\nsource.cpp:70:7: note:   no known conversion for argument 1 from ‘int’ to ‘const string& {aka const std::__cxx11::basic_string<char>&}’\nmain.cpp:31:18: error: no match for ‘operator[]’ (operand types are ‘HT’ and ‘int’)\n  cout << (int)map[key1] << endl;\n                  ^\nIn file included from main.cpp:1:0:\nsource.cpp:62:14: note: candidate: const int& HT::operator[](const string&) const\n  const int & operator [] (const string & key)const{\n              ^\nsource.cpp:62:14: note:   no known conversion for argument 1 from ‘int’ to ‘const string& {aka const std::__cxx11::basic_string<char>&}’\nmain.cpp:32:26: error: no matching function for call to ‘std::__cxx11::basic_string<char>::basic_string(const int&)’\n  cout << (string)map[key2] << endl;\n                          ^\nIn file included from /usr/include/c++/5/string:52:0,\n                 from /usr/include/c++/5/bits/locale_classes.h:40,\n                 from /usr/include/c++/5/bits/ios_base.h:41,\n                 from /usr/include/c++/5/ios:42,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from source.cpp:1,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/basic_string.h:534:9: note: candidate: template<class _InputIterator, class> std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(_InputIterator, _InputIterator, const _Alloc&)\n         basic_string(_InputIterator __beg, _InputIterator __end,\n         ^\n/usr/include/c++/5/bits/basic_string.h:534:9: note:   template argument deduction/substitution failed:\nmain.cpp:32:26: note:   candidate expects 3 arguments, 1 provided\n  cout << (string)map[key2] << endl;\n                          ^\nIn file included from /usr/include/c++/5/string:52:0,\n                 from /usr/include/c++/5/bits/locale_classes.h:40,\n                 from /usr/include/c++/5/bits/ios_base.h:41,\n                 from /usr/include/c++/5/ios:42,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from source.cpp:1,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/basic_string.h:511:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&&, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\n       basic_string(basic_string&& __str, const _Alloc& __a)\n       ^\n/usr/include/c++/5/bits/basic_string.h:511:7: note:   candidate expects 2 arguments, 1 provided\n/usr/include/c++/5/bits/basic_string.h:507:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\n       basic_string(const basic_string& __str, const _Alloc& __a)\n       ^\n/usr/include/c++/5/bits/basic_string.h:507:7: note:   candidate expects 2 arguments, 1 provided\n/usr/include/c++/5/bits/basic_string.h:503:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(std::initializer_list<_Tp>, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\n       basic_string(initializer_list<_CharT> __l, const _Alloc& __a = _Alloc())\n       ^\n/usr/include/c++/5/bits/basic_string.h:503:7: note:   no known conversion for argument 1 from ‘const int’ to ‘std::initializer_list<char>’\n/usr/include/c++/5/bits/basic_string.h:476:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\n       basic_string(basic_string&& __str) noexcept\n       ^\n/usr/include/c++/5/bits/basic_string.h:476:7: note:   no known conversion for argument 1 from ‘const int’ to ‘std::__cxx11::basic_string<char>&&’\n/usr/include/c++/5/bits/basic_string.h:464:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, _CharT, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int]\n       basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc())\n       ^\n/usr/include/c++/5/bits/basic_string.h:464:7: note:   candidate expects 3 arguments, 1 provided\n/usr/include/c++/5/bits/basic_string.h:454:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const _CharT*, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>] <near match>\n       basic_string(const _CharT* __s, const _Alloc& __a = _Alloc())\n       ^\n/usr/include/c++/5/bits/basic_string.h:454:7: note:   conversion of argument 1 would be ill-formed:\nmain.cpp:32:26: error: invalid conversion from ‘int’ to ‘const char*’ [-fpermissive]\n  cout << (string)map[key2] << endl;\n                          ^\nIn file included from /usr/include/c++/5/string:52:0,\n                 from /usr/include/c++/5/bits/locale_classes.h:40,\n                 from /usr/include/c++/5/bits/ios_base.h:41,\n                 from /usr/include/c++/5/ios:42,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from source.cpp:1,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/basic_string.h:444:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const _CharT*, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int]\n       basic_string(const _CharT* __s, size_type __n,\n       ^\n/usr/include/c++/5/bits/basic_string.h:444:7: note:   candidate expects 3 arguments, 1 provided\n/usr/include/c++/5/bits/basic_string.h:426:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int]\n       basic_string(const basic_string& __str, size_type __pos,\n       ^\n/usr/include/c++/5/bits/basic_string.h:426:7: note:   candidate expects 4 arguments, 1 provided\n/usr/include/c++/5/bits/basic_string.h:410:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int]\n       basic_string(const basic_string& __str, size_type __pos,\n       ^\n/usr/include/c++/5/bits/basic_string.h:410:7: note:   candidate expects 3 arguments, 1 provided\n/usr/include/c++/5/bits/basic_string.h:398:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\n       basic_string(const basic_string& __str)\n       ^\n/usr/include/c++/5/bits/basic_string.h:398:7: note:   no known conversion for argument 1 from ‘const int’ to ‘const std::__cxx11::basic_string<char>&’\n/usr/include/c++/5/bits/basic_string.h:390:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\n       basic_string(const _Alloc& __a)\n       ^\n/usr/include/c++/5/bits/basic_string.h:390:7: note:   no known conversion for argument 1 from ‘const int’ to ‘const std::allocator<char>&’\n/usr/include/c++/5/bits/basic_string.h:379:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string() [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\n       basic_string()\n       ^\n/usr/include/c++/5/bits/basic_string.h:379:7: note:   candidate expects 0 arguments, 1 provided\nmain.cpp:33:21: error: no match for ‘operator[]’ (operand types are ‘HT’ and ‘int’)\n  cout << (string)map[key3] << endl;\n                     ^\nIn file included from main.cpp:1:0:\nsource.cpp:62:14: note: candidate: const int& HT::operator[](const string&) const\n  const int & operator [] (const string & key)const{\n              ^\nsource.cpp:62:14: note:   no known conversion for argument 1 from ‘int’ to ‘const string& {aka const std::__cxx11::basic_string<char>&}’\n/usr/include/c++/5/bits/stl_construct.h: In instantiation of ‘void std::_Construct(_T1*, _Args&& ...) [with _T1 = Tuple; _Args = {}]’:\n/usr/include/c++/5/bits/stl_uninitialized.h:519:18:   required from ‘static _ForwardIterator std::__uninitialized_default_n_1<_TrivialValueType>::__uninit_default_n(_ForwardIterator, _Size) [with _ForwardIterator = Tuple*; _Size = long unsigned int; bool _TrivialValueType = false]’\n/usr/include/c++/5/bits/stl_uninitialized.h:575:20:   required from ‘_ForwardIterator std::__uninitialized_default_n(_ForwardIterator, _Size) [with _ForwardIterator = Tuple*; _Size = long unsigned int]’\n/usr/include/c++/5/bits/stl_uninitialized.h:637:44:   required from ‘_ForwardIterator std::__uninitialized_default_n_a(_ForwardIterator, _Size, std::allocator<_Tp>&) [with _ForwardIterator = Tuple*; _Size = long unsigned int; _Tp = Tuple]’\n/usr/include/c++/5/bits/vector.tcc:549:35:   required from ‘void std::vector<_Tp, _Alloc>::_M_default_append(std::vector<_Tp, _Alloc>::size_type) [with _Tp = Tuple; _Alloc = std::allocator<Tuple>; std::vector<_Tp, _Alloc>::size_type = long unsigned int]’\n/usr/include/c++/5/bits/stl_vector.h:676:21:   required from ‘void std::vector<_Tp, _Alloc>::resize(std::vector<_Tp, _Alloc>::size_type) [with _Tp = Tuple; _Alloc = std::allocator<Tuple>; std::vector<_Tp, _Alloc>::size_type = long unsigned int]’\nsource.cpp:54:18:   required from here\nsource.cpp:31:2: error: ‘Tuple::Tuple()’ is private\n  Tuple():in_use(false){};\n  ^\nIn file included from /usr/include/c++/5/vector:62:0,\n                 from source.cpp:4,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/stl_construct.h:75:7: error: within this context\n     { ::new(static_cast<void*>(__p)) _T1(std::forward<_Args>(__args)...); }\n       ^\n"
        ]
    ],
    "table_name": "答案"
}