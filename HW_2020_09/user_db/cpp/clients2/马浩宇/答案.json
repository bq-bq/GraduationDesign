{
    "__update_time__": 1595477084.8009884,
    "field_names": [
        "题目名",
        "用户名",
        "答案",
        "提交时间",
        "分数",
        "评语"
    ],
    "field_types": [
        "text",
        "text",
        "text",
        "time",
        "number",
        "text"
    ],
    "foreign_keys": {},
    "primary_keys": [],
    "rows": [
        [
            "测试1",
            "马浩宇",
            "#include <iostream>\nusing namespace std;\n\nint main () {\n    string a, b, c;\n    cin >> a >> b >> c;\n    cout << c << ' ' << b << ' ' << a << endl;\n}",
            1587516671.0,
            100,
            "# 答案正确"
        ],
        [
            "测试2",
            "马浩宇",
            "#include <iostream>\nusing namespace std;\n\nint main () {\n   string a[10];\n   for(int i = 0 ; i < 10 ; i ++) cin >> a[i];\n   for(int i = 0 ; i < 10 ; i ++) {\n      for(int j = i + 1 ; j < 10 ; j ++) {\n          if(a[i] > a[j]) {\n             string temp = a[i];\n             a[i] = a[j];\n             a[j] = temp;\n          }\n      }\n   }\n   for(int i = 0 ; i < 10 ; i ++) \n        cout << a[i] << ' ';\n   cout << endl;\n}",
            1587608627.0591698,
            100,
            "# 答案正确"
        ],
        [
            "1.1 (C++)",
            "马浩宇",
            "class Matrix5x5 \n{\n\tpublic:\n\t\tdouble matrix[5][5];\n\t\tMatrix5x5() {\n\t\t\tfor(int i = 0 ; i < 5 ; i ++) {\n\t\t\t\tfor(int j = 0 ; j < 5 ; j ++) {\n\t\t\t\t\tmatrix[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvoid set(int i, int j, double value) {\n\t\t\tmatrix[i][j] = value;\n\t\t}\n\t\tdouble get(int i, int j) {\n\t\t\treturn matrix[i][j];\t\n\t\t}\n};\n\nMatrix5x5 operator + (Matrix5x5 &a, Matrix5x5 &b) {\n\tMatrix5x5 c;\n\tfor(int i = 0 ; i < 5 ; i ++) {\n\t\tfor(int j = 0 ; j < 5 ; j++) {\n\t\t\tc.matrix[i][j] = a.matrix[i][j] + b.matrix[i][j];\n\t\t}\n\t}\n\treturn c;\n}",
            1587696827.338006,
            100,
            "# 答案正确"
        ],
        [
            "1.2 (C++)",
            "马浩宇",
            "class School{\n\tpublic:\n\t\tchar name[10];\n\t\tint age;\n\t\tSchool(): age(0),name(\"NO_NAME\"){}\n\t\tvoid setName (char name1[]) {\n\t\t\tfor(int i = 0 ; i < 10 ; i ++) name[i] = 0;\n\t\t\tint i = 0;\n\t\t\twhile(name1[i] != 0) {\n\t\t\t\tname[i] = name1[i];\n\t\t\t\ti ++;\n\t\t\t}\n\t\t}\n\t\tvoid setAge (int year) {\n\t\t\tage = year;\n\t\t}\n\t\tvoid operator ++ () {\n\t\t\t(*this).age ++;\t\n\t\t}\n};",
            1588212942.4794981,
            100,
            "# 答案正确"
        ],
        [
            "2.1 (C++)",
            "马浩宇",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix \n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tMatrix(int row, int column){\n\t\tvalues = new double [row * column];\n        rows = row;\n        columns = column;\n\t\tfor(int i = 0 ; i < row * column ; i ++) {\n\t\t\tvalues[i] = 0;\n\t\t}\n\t}\n\tvoid print() {\n\t\tfor(int i = 0 ; i < rows ; i ++) {\n\t\t\tfor(int j = i * columns ; j < i * columns + columns ; j ++ ) {\n\t\t\t\tcout << \"    \" << values[j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n    ~Matrix() {\n\t\tdelete [] values;\n\t}\n};",
            1588828657.8061814,
            100,
            "# 答案正确"
        ],
        [
            "2.2 (C++)",
            "马浩宇",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix \n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tMatrix(int row, int column, double value[]){\n\t\tvalues = new double [row * column];\n        rows = row;\n        columns = column;\n\t\tfor(int i = 0 ; i < row * column ; i ++) {\n\t\t\tvalues[i] = value[i];\n\t\t}\n\t}\n\tvoid print() {\n\t\tfor(int i = 0 ; i < rows ; i ++) {\n\t\t\tfor(int j = i * columns ; j < i * columns + columns ; j ++ ) {\n\t\t\t\tcout.width(5);\n\t\t\t\tcout << values[j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n    ~Matrix() {\n\t\tdelete [] values;\n\t}\n};",
            1588828640.7844255,
            100,
            "# 答案正确"
        ],
        [
            "2.3 (C++)",
            "马浩宇",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix \n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tMatrix(int row, int column, double value[]){\n\t\tvalues = new double [row * column];\n        rows = row;\n        columns = column;\n\t\tfor(int i = 0 ; i < row * column ; i ++) {\n\t\t\tvalues[i] = value[i];\n\t\t}\n\t}\n\tMatrix(const Matrix & matrix2) {\n\t\tint row = matrix2.rows;\n\t\tint column = matrix2.columns;\n\t\tvalues = new double [row * column];\n\t\trows = row;\n      columns = column;\n\t\tfor(int i = 0 ; i < row * column ; i ++) {\n\t\t\tvalues[i] = matrix2.values[i];\n\t\t}\n\t}\n\tvoid print() {\n\t\tfor(int i = 0 ; i < rows ; i ++) {\n\t\t\tfor(int j = i * columns ; j < i * columns + columns ; j ++ ) {\n\t\t\t\tcout << \"    \" << values[j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n    ~Matrix() {\n\t\tdelete [] values;\n\t}\n};",
            1588828854.1040206,
            100,
            "# 答案正确"
        ],
        [
            "2.5 (C++)",
            "马浩宇",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix \n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tMatrix(int row, int column){\n\t\tvalues = new double [row * column];\n        rows = row;\n        columns = column;\n\t\tfor(int i = 0 ; i < row * column ; i ++) {\n\t\t\tvalues[i] = 0;\n\t\t}\n\t}\n\tMatrix(int row, int column, double value[]){\n\t\tvalues = new double [row * column];\n        rows = row;\n        columns = column;\n\t\tfor(int i = 0 ; i < row * column ; i ++) {\n\t\t\tvalues[i] = value[i];\n\t\t}\n\t}\n\tvoid print() {\n\t\tfor(int i = 0 ; i < rows ; i ++) {\n\t\t\tfor(int j = i * columns ; j < i * columns + columns ; j ++ ) {\n\t\t\t\tcout << \"    \" << values[j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n   ~Matrix() {\n\t\tdelete [] values;\n\t}\n\tMatrix getRow(int row) {\n\t\tMatrix temp(1, columns);\n\t\tfor(int i = 0 ; i < columns ; i ++) {\n\t\t\ttemp.values[i] = values[(row - 1) * columns + i];\n\t\t}\n\t\treturn temp;\n\t}\n\tMatrix getColumn(int column) {\n\t\tMatrix temp(rows, 1);\n\t\tfor(int i = 0 ; i < rows ; i ++) {\n\t\t\ttemp.values[i] = values[i * columns];\n\t\t}\n\t\treturn temp;\n\t}\n};",
            1588829330.9585817,
            100,
            "# 答案正确"
        ],
        [
            "2.6 (C++)",
            "马浩宇",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix \n{\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tMatrix(int row, int column, double value[]){\n\t\tvalues = new double [row * column];\n        rows = row;\n        columns = column;\n\t\tfor(int i = 0 ; i < row * column ; i ++) {\n\t\t\tvalues[i] = value[i];\n\t\t}\n\t}\n\tMatrix(const Matrix & matrix2) {\n\t\tint row = matrix2.rows;\n\t\tint column = matrix2.columns;\n\t\tvalues = new double [row * column];\n\t\trows = row;\n      columns = column;\n\t\tfor(int i = 0 ; i < row * column ; i ++) {\n\t\t\tvalues[i] = matrix2.values[i];\n\t\t}\n\t}\n\tvoid print() {\n\t\tfor(int i = 0 ; i < rows ; i ++) {\n\t\t\tfor(int j = i * columns ; j < i * columns + columns ; j ++ ) {\n\t\t\t\tcout << \"    \" << values[j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n    ~Matrix() {\n\t\tdelete [] values;\n\t}\n\tMatrix concatenateRows(const Matrix & matrix2) const {\n\t\tdouble temp1 [rows * columns + matrix2.rows * matrix2.columns];\n\t\tfor(int i = 0 ; i < rows * columns + matrix2.rows * matrix2.columns ; i ++) {\n\t\t\tif(i < rows * columns) {\n\t\t\t\ttemp1[i] = values[i];\n\t\t\t}\n\t\t\telse temp1[i] = matrix2.values[i - rows * columns];\n\t\t}\n\t\tMatrix temp(rows + matrix2.rows, columns, temp1);\n\t\treturn temp;\n\t}\n\tMatrix concatenateColumns(const Matrix & matrix2) const {\n\t\tdouble temp1 [rows * columns + matrix2.rows * matrix2.columns];\n\t\tint count = 0;\n\t\tint flag = 0;\n\t\tint count1 = 0;\n\t\tint count2 = 0;\n\t\tfor(int i = 0 ; i < rows * columns + matrix2.rows * matrix2.columns ; i ++,count++) {\n\t\t\tif((flag % 2 == 0 && count == columns) || (flag % 2 == 1 && count == matrix2.columns)) {\n\t\t\t\tcount = 0;\n\t\t\t\tflag ++;\n\t\t\t}\n\t\t\tif(flag % 2 == 0) {\n\t\t\t\ttemp1[i] = values[count1++];\n\t\t\t}\n\t\t\telse temp1[i] = matrix2.values[count2++];\n\t\t}\n\t\tMatrix temp(rows, columns + matrix2.columns, temp1);\n\t\treturn temp;\n\t}\n};",
            1588830546.8432314,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/08",
            "马浩宇",
            "double & Tensor_get(int dimensions, const int sizes[], double data[], int x0, int x1, int x2, int x3) {\n\tif(dimensions == 1) {\n\t\treturn data[x0];\n\t}\n\tif(dimensions == 2) {\n\t\treturn data[x0*sizes[1]+x1];\n\t}\n\tif(dimensions == 3) {\n\t\treturn data[x0*sizes[1]*sizes[2] + x1*sizes[2] + x2];\n\t}\n\tif(dimensions == 4) {\n\t\treturn data[x0*sizes[1]*sizes[2]*sizes[3] + x1*sizes[2]*sizes[3] + x2*sizes[3] + x3];\n\t}\n}",
            1588905549.9092903,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/14",
            "马浩宇",
            "#include <iostream>\nusing namespace std;\n\nvoid Tensor_print(int dimensions, const int sizes[], const double data[]) {\n\tif(dimensions == 1) {\n\t\tcout << \"Tensor of \" << sizes[0] << endl;\n\t\tfor(int i = 0 ; i < sizes[0] ; i ++) cout << data[i] << endl;\n\t}\n\tif(dimensions == 2) {\n\t\tcout << \"Tensor of \" << sizes[0] << \"x\" << sizes[1] << endl;\n\t\tfor(int i = 0 ; i < sizes[0] ; i ++) {\n\t\t\tfor(int j = 0 ; j < sizes[1] ; j ++) {\n\t\t\t\tcout << \"    \" << data[i*sizes[1] + j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tif(dimensions == 3) {\n\t\tcout << \"Tensor of \" << sizes[0] << \"x\" << sizes[1] << \"x\" << sizes[2] << endl;\n\t\tint count = 0;\n\t\twhile(count < sizes[0]) {\n\t\t\tcout << \"data[\" << count << \"]\" << endl;\n\t\t\tfor(int i = 0 ; i < sizes[1] ; i ++) {\n\t\t\t\tfor(int j = 0 ; j < sizes[2] ; j ++) {\n\t\t\t\t\tcout << \"    \" << data[i*sizes[2] + j];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\tcount ++;\n\t\t}\n\t}\n\tif(dimensions == 4) {\n\t\tcout << \"Tensor of \" << sizes[0] << \"x\" << sizes[1] << \"x\" << sizes[2] << \"x\" << sizes[3] << endl;\n\t\tfor(int m = 0 ; m < sizes[0] ; m ++) {\n\t\t\tfor(int n = 0 ; n < sizes[1] ; n ++){\n\t\t\t\tcout << \"data[\" << m << \"][\" << n << \"]\" <<endl;\n\t\t\t\tfor(int i = 0 ; i < sizes[2] ; i ++) {\n\t\t\t\t\tfor(int j = 0 ; j < sizes[3] ; j ++) {\n\t\t\t\t\t\tcout << \"    \" << data[i*sizes[3] + j];\n\t\t\t\t\t}\n\t\t\t\t\tcout << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
            1589423944.8717635,
            100,
            "# 答案正确"
        ],
        [
            "2.4 (C++)",
            "马浩宇",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix {\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tMatrix(int row, int column) {\n\t\trows = row;\n\t\tcolumns = column;\n\t\tvalues = new double [row * column];\n\t\tfor(int i = 0 ; i < row * column ; i ++) values[i] = 0;\n\t}\n\tMatrix(int row, int column, double value[]) {\n\t\trows = row;\n\t\tcolumns = column;\n\t\tvalues = new double [row * column];\n\t\tfor(int i = 0 ; i < row * column ; i ++) values[i] = value[i];\n\t}\n\t~Matrix(){\n\t\tdelete[] values;\n\t}\n\tvoid print() {\n\t\tfor(int i = 0 ; i < rows ; i ++) {\n\t\t\tfor(int j = 0 ; j < columns ; j ++) {\n\t\t\t\tcout << \"    \" << values[i * columns + j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tvoid set(int row, int column, double value) {\n\t\tvalues[(row - 1) * columns + column - 1] = value;\n\t}\n\tMatrix& operator = (const Matrix & temp) {\n\t\tdelete [] values;\n\t\tvalues = new double [temp.rows * temp.columns];\n\t\trows = temp.rows;\n\t\tcolumns = temp.columns;\n\t\tfor(int i = 0 ; i < rows * columns ; i ++) {\n\t\t\tvalues[i] = temp.values[i];\n\t\t}\n\t\treturn * this;\n\t}\n};",
            1589515001.8972394,
            100,
            "# 答案正确"
        ],
        [
            "2.7 (C++)",
            "马浩宇",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix {\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tMatrix(const Matrix & matrix2) {\n\t\trows = matrix2.rows;\n\t\tcolumns = matrix2.columns;\n\t\tvalues = new double [rows * columns];\n\t\tfor(int i = 0 ; i < rows * columns ; i ++) values[i] = matrix2.values[i];\n\t}\n\tMatrix(int row, int column, double value[]) {\n\t\trows = row;\n\t\tcolumns = column;\n\t\tvalues = new double [row * column];\n\t\tfor(int i = 0 ; i < row * column ; i ++) values[i] = value[i];\n\t}\n\t~Matrix(){\n\t\tdelete[] values;\n\t}\n\tvoid print() {\n\t\tfor(int i = 0 ; i < rows ; i ++) {\n\t\t\tfor(int j = 0 ; j < columns ; j ++) {\n\t\t\t\tcout << \"    \" << values[i * columns + j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n    Matrix reshape(int row, int column) const {\n        double *value = new double [rows * columns];\n\t    int count = 0;\n\t    for(int i = 0 ; i < columns ; i ++) {\n\t\t    for(int j = 0 ; j < rows ; j ++) {\n\t\t\t    value[count++] = values[j*columns + i];\n\t\t    }\n\t    }\n\t    count = 0;\n        double *value1 = new double [row * column];\n\t    for(int i = 0 ; i < columns ; i ++) {\n\t\t    for(int j = 0 ; j < rows ; j ++) {\n\t\t\t    value1[count ++] = value[j*columns + i];\n\t\t    }\n\t    }\n        Matrix temp (row, column, value1);\n        delete []value1;\n        delete []value;\n        return temp;\n    }\n};",
            1589515111.7246885,
            100,
            "# 答案正确"
        ],
        [
            "2.8 (C++)",
            "马浩宇",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix {\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tMatrix(const Matrix & matrix2) {\n\t\trows = matrix2.rows;\n\t\tcolumns = matrix2.columns;\n\t\tvalues = new double [rows * columns];\n\t\tfor(int i = 0 ; i < rows * columns ; i ++) values[i] = matrix2.values[i];\n\t}\n\tMatrix(int row, int column, double value[]) {\n\t\trows = row;\n\t\tcolumns = column;\n\t\tvalues = new double [row * column];\n\t\tfor(int i = 0 ; i < row * column ; i ++) values[i] = value[i];\n\t}\n\t~Matrix(){\n\t\tdelete[] values;\n\t}\n\tvoid print() {\n\t\tfor(int i = 0 ; i < rows ; i ++) {\n\t\t\tfor(int j = 0 ; j < columns ; j ++) {\n\t\t\t\tcout << \"    \" << values[i * columns + j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n    Matrix transpose() const {\n        double *value = new double [rows * columns];\n\t    int count = 0;\n\t    for(int i = 0 ; i < columns ; i ++) {\n\t\t    for(int j = 0 ; j < rows ; j ++) {\n\t\t\t    value[count++] = values[j*columns + i];\n\t\t    }\n\t    }\n        Matrix temp (columns, rows, value);\n        delete []value;\n        return temp;\n    }\n};",
            1589519183.8501856,
            100,
            "# 答案正确"
        ],
        [
            "2.10 (C++)",
            "马浩宇",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix {\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tMatrix(const Matrix & matrix2) {\n\t\trows = matrix2.rows;\n\t\tcolumns = matrix2.columns;\n\t\tvalues = new double [rows * columns];\n\t\tfor(int i = 0 ; i < rows * columns ; i ++) values[i] = matrix2.values[i];\n\t}\n\tMatrix(int row, int column, double value[]) {\n\t\trows = row;\n\t\tcolumns = column;\n\t\tvalues = new double [row * column];\n\t\tfor(int i = 0 ; i < row * column ; i ++) values[i] = value[i];\n\t}\n\t~Matrix(){\n\t\tdelete[] values;\n\t}\n\tvoid print() {\n\t\tfor(int i = 0 ; i < rows ; i ++) {\n\t\t\tfor(int j = 0 ; j < columns ; j ++) {\n\t\t\t\tcout << \"    \" << values[i * columns + j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n    Matrix operator *(double value) const {\n        double *value1 = new double [rows*columns];\n        for(int i = 0 ; i < rows * columns ; i ++) value1[i] = values[i] * value;\n        Matrix temp(rows, columns, value1);\n        delete [] value1;\n        return temp;\n    }\n    Matrix operator * (const Matrix & matrix2) const {\n        double *value1 = new double [rows * matrix2.columns];\n        int count = 0;\n        for(int i = 0 ; i < rows ; i ++) {\n            for(int j = 0 ; j < matrix2.columns ; j ++) {\n                double temp = 0;\n                for(int k = 0 ; k < columns ; k ++) {\n                   temp += values[i*columns + k] * matrix2.values[k*matrix2.columns + j]; \n                }\n                value1[count++] = temp;\n            }\n        }\n        Matrix a(rows, matrix2.columns, value1);\n        delete [] value1;\n        return a;\n    }\n};",
            1589520143.9298449,
            100,
            "# 答案正确"
        ],
        [
            "2.12 (C++)",
            "马浩宇",
            "#include <iostream>\n#include <cmath>\nusing namespace std;\n\ndouble ex(double x) {\n    return exp(x);\n}\n\ndouble ab(double x) {\n    return abs(x);\n}\n\ndouble ln(double x) {\n    return log(x);\n}\n\ndouble power(double x, double n) {\n    return pow(x,n);\n}\n\nclass Matrix {\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tMatrix(const Matrix & matrix2) {\n\t\trows = matrix2.rows;\n\t\tcolumns = matrix2.columns;\n\t\tvalues = new double [rows * columns];\n\t\tfor(int i = 0 ; i < rows * columns ; i ++) values[i] = matrix2.values[i];\n\t}\n\tMatrix(int row, int column, double value[]) {\n\t\trows = row;\n\t\tcolumns = column;\n\t\tvalues = new double [row * column];\n\t\tfor(int i = 0 ; i < row * column ; i ++) values[i] = value[i];\n\t}\n\t~Matrix(){\n\t\tdelete[] values;\n\t}\n\tvoid print() {\n\t\tfor(int i = 0 ; i < rows ; i ++) {\n\t\t\tfor(int j = 0 ; j < columns ; j ++) {\n\t\t\t\tcout << \"    \" << values[i * columns + j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n    Matrix pow(double exponent) {\n        double* value1 = new double [rows*columns];\n        for(int i = 0 ; i < rows * columns ; i ++) {\n            value1[i] = power(values[i],exponent);\n        }\n        Matrix temp(rows, columns, value1);\n        delete[] value1;\n        return temp;\n    }\n    Matrix exp() {\n        double* value1 = new double [rows*columns];\n        for(int i = 0 ; i < rows * columns ; i ++) {\n            value1[i] = ex(values[i]);\n        }\n        Matrix temp(rows, columns, value1);\n        delete[] value1;\n        return temp;\n    }\n    Matrix abs() {\n        double* value1 = new double [rows*columns];\n        for(int i = 0 ; i < rows * columns ; i ++) {\n            value1[i] = ab(values[i]);\n        }\n        Matrix temp(rows, columns, value1);\n        delete[] value1;\n        return temp;\n    }\n    Matrix log() {\n        double* value1 = new double [rows*columns];\n        for(int i = 0 ; i < rows * columns ; i ++) {\n            value1[i] = ln(values[i]);\n        }\n        Matrix temp(rows, columns, value1);\n        delete[] value1;\n        return temp;\n    }\n};",
            1589522286.0779667,
            100,
            "# 答案正确"
        ],
        [
            "2.11 (C++)",
            "马浩宇",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix {\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tMatrix(const Matrix & matrix2) {\n\t\trows = matrix2.rows;\n\t\tcolumns = matrix2.columns;\n\t\tvalues = new double [rows * columns];\n\t\tfor(int i = 0 ; i < rows * columns ; i ++) values[i] = matrix2.values[i];\n\t}\n\tMatrix(int row, int column, double value[]) {\n\t\trows = row;\n\t\tcolumns = column;\n\t\tvalues = new double [row * column];\n\t\tfor(int i = 0 ; i < row * column ; i ++) values[i] = value[i];\n\t}\n\t~Matrix(){\n\t\tdelete[] values;\n\t}\n\tvoid print() {\n\t\tfor(int i = 0 ; i < rows ; i ++) {\n\t\t\tfor(int j = 0 ; j < columns ; j ++) {\n\t\t\t\tcout << \"    \" << values[i * columns + j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n    Matrix max() const {\n        if(rows == 1) {\n            double *value2 = new double [1];\n            double max = -1;\n            for(int i = 0 ; i < columns ; i ++) {\n                if(values[i] > max) max = values[i];\n            }\n            value2[0] = max;\n            Matrix temp(1, 1, value2);\n            delete [] value2;\n            return temp;\n        }\n        double * value1 = new double[columns];\n        int count = 0;\n        for(int i = 0 ; i < columns ; i ++) {\n            double max = -1;\n            for(int j = 0 ; j < rows ; j ++) {\n                if(values[j * columns + i] > max) \n                    max = values[j * columns + i];\n            }\n            value1[count++] = max;\n        }\n        Matrix temp(1, columns,value1);\n        delete [] value1;\n        return temp;\n    }\n    Matrix min() const {\n        if(rows == 1) {\n            double *value2 = new double [1];\n            double min = 9999;\n            for(int i = 0 ; i < columns ; i ++) {\n                if(values[i] < min) min = values[i];\n            }\n            value2[0] = min;\n            Matrix temp(1, 1, value2);\n            delete [] value2;\n            return temp;\n        }\n        double * value1 = new double[columns];\n        int count = 0;\n        for(int i = 0 ; i < columns ; i ++) {\n            double min = 9999;\n            for(int j = 0 ; j < rows ; j ++) {\n                if(values[j * columns + i] < min) \n                    min = values[j * columns + i];\n            }\n            value1[count++] = min;\n        }\n        Matrix temp(1, columns,value1);\n        delete [] value1;\n        return temp;\n    }\n    Matrix sum() const {\n        if(rows == 1) {\n            double *value2 = new double [1];\n            double sum = 0;\n            for(int i = 0 ; i < columns ; i ++) {\n                sum += values[i];\n            }\n            value2[0] = sum;\n            Matrix temp(1, 1, value2);\n            delete [] value2;\n            return temp;\n        }\n        double * value1 = new double[columns];\n        int count = 0;\n        for(int i = 0 ; i < columns ; i ++) {\n            double sum = 0;\n            for(int j = 0 ; j < rows ; j ++) {\n                sum += values[j * columns + i];\n            }\n            value1[count++] = sum;\n        }\n        Matrix temp(1, columns,value1);\n        delete [] value1;\n        return temp;\n    }\n};",
            1589523081.4902215,
            100,
            "# 答案正确"
        ],
        [
            "2.9 (C++)",
            "马浩宇",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix {\nprivate:\n\tint rows;\n\tint columns;\n\tdouble * values;\npublic:\n\tMatrix(const Matrix & matrix2) {\n\t\trows = matrix2.rows;\n\t\tcolumns = matrix2.columns;\n\t\tvalues = new double [rows * columns];\n\t\tfor(int i = 0 ; i < rows * columns ; i ++) values[i] = matrix2.values[i];\n\t}\n\tMatrix(int row, int column, double value[]) {\n\t\trows = row;\n\t\tcolumns = column;\n\t\tvalues = new double [row * column];\n\t\tfor(int i = 0 ; i < row * column ; i ++) values[i] = value[i];\n\t}\n\t~Matrix(){\n\t\tdelete[] values;\n\t}\n\tvoid print() {\n\t\tfor(int i = 0 ; i < rows ; i ++) {\n\t\t\tfor(int j = 0 ; j < columns ; j ++) {\n\t\t\t\tcout << \"    \" << values[i * columns + j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n    Matrix operator + (const Matrix & matrix2) const {\n        double * value1 = new double [rows * columns];\n        for(int i = 0 ; i < rows * columns ; i ++) value1[i] = values[i] + matrix2.values[i];\n        Matrix temp(rows, columns, value1);\n        delete[]value1;\n        return temp;\n    }\n    Matrix operator - (const Matrix & matrix2) const {\n        double * value1 = new double [rows * columns];\n        for(int i = 0 ; i < rows * columns ; i ++) value1[i] = values[i] - matrix2.values[i];\n        Matrix temp(rows, columns, value1);\n        delete[]value1;\n        return temp;\n    }\n    Matrix operator - (double value) const {\n        double * value1 = new double [rows * columns];\n        for(int i = 0 ; i < rows * columns ; i ++) value1[i] = values[i] - value;\n        Matrix temp(rows, columns, value1);\n        delete[]value1;\n        return temp;\n    }\n    Matrix operator + (double value) const {\n        double * value1 = new double [rows * columns];\n        for(int i = 0 ; i < rows * columns ; i ++) value1[i] = values[i] + value;\n        Matrix temp(rows, columns, value1);\n        delete[]value1;\n        return temp;\n    }\n};",
            1590027057.550887,
            100,
            "# 答案正确"
        ],
        [
            "6.1 (C++)",
            "马浩宇",
            "#include <cstring>\nusing namespace std;\n\ntemplate <typename T>\nclass Matrix {\nprivate:\n\tint rows;\n\tint columns;\n\tT * values;\npublic:\n\tMatrix(int row, int column) {\n\t\trows = row;\n\t\tcolumns = column;\n\t\tvalues = new T [rows * columns];\n\t\tmemset(values,0,rows*columns*sizeof(T));\n\t}\n\tMatrix(const Matrix & matrix2) {\n\t\trows = matrix2.rows;\n\t\tcolumns = matrix2.columns;\n\t\tvalues = new T [rows * columns];\n\t\tfor(int i = 0 ; i < rows * columns ; i ++) values[i] = matrix2.values[i];\n\t}\n\tMatrix(int row, int column,const T value[]) {\n\t\trows = row;\n\t\tcolumns = column;\n\t\tvalues = new T [row * column];\n\t\tfor(int i = 0 ; i < row * column ; i ++) values[i] = value[i];\n\t}\n\t~Matrix(){\n\t\tdelete[] values;\n\t}\n\tvoid print() {\n\t\tfor(int i = 0 ; i < rows ; i ++) {\n\t\t\tfor(int j = 0 ; j < columns ; j ++) {\n\t\t\t\tcout << \"    \" << values[i * columns + j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\t\n\tMatrix & operator = (const Matrix & matrix2) {\n\t\tif(values != 0) delete[] values;\n\t\trows = matrix2.rows;\n\t\tcolumns = matrix2.columns;\n\t\tvalues = new T [rows*columns];\n\t\tfor(int i = 0 ; i < rows * columns ; i ++) values[i] = matrix2.values[i];\n\t\treturn *this;\n\t}\n\tT & get(int row, int column) {\n\t\treturn values[(row-1)*columns + column - 1];\n\t}\n};",
            1590123815.584821,
            100,
            "# 答案正确"
        ],
        [
            "6.3 (C++)",
            "马浩宇",
            "#include <iostream>\n#include <cstring>\n#include <vector>\nusing namespace std;\n\ntemplate <typename T>\nclass Matrix {\nprivate:\n\tint rows;\n\tint columns;\n\tvector<T> values;\npublic:\n\tMatrix(int row, int column) {\n\t\trows = row;\n\t\tcolumns = column;\n\t\tfor(int i = 0 ; i < rows * columns ; i ++) values.push_back(0);\n\t}\n\tMatrix(const Matrix & matrix2) {\n\t\trows = matrix2.rows;\n\t\tcolumns = matrix2.columns;\n\t\tfor(int i = 0 ; i < rows * columns ; i ++) values.push_back(matrix2.values[i]);\n\t}\n\tMatrix(int row, int column,vector<T> value) {\n\t\trows = row;\n\t\tcolumns = column;\n\t\tfor(int i = 0 ; i < row * column ; i ++) values.push_back(value[i]);\n\t}\n\t~Matrix(){\n\t}\n\tvoid print() {\n\t\tfor(int i = 0 ; i < rows ; i ++) {\n\t\t\tfor(int j = 0 ; j < columns ; j ++) {\n\t\t\t\tcout << \"    \" << values[i * columns + j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tMatrix & operator = (const Matrix & matrix2) {\n\t\tif(values.size() != 0) {\n\t\t\tvector<T> ().swap(values);\n\t\t}\n\t\trows = matrix2.rows;\n\t\tcolumns = matrix2.columns;\n\t\tfor(int i = 0 ; i < rows * columns ; i ++) values.push_back(matrix2.values[i]);\n\t\treturn *this;\n\t}\n\tMatrix getRow(int row) {\n\t\tvector<T> value1;\n\t\tfor(int i = 0 ; i < columns ; i++) {\n\t\t\tvalue1.push_back(values[columns *(row - 1) + i]);\n\t\t}\n\t\tMatrix temp(1,columns,value1);\n\t\treturn temp;\n\t}\n\tMatrix getColumn(int column) {\n\t\tvector<T> value1;\n\t\tfor(int i = 0 ; i < columns ; i++) {\n\t\t\tvalue1.push_back(values[i*columns + column - 1]);\n\t\t}\n\t\tMatrix temp(rows,1,value1);\n\t\treturn temp;\n\t}\n\tMatrix reshape (int row, int column) const {\n\t\tT* value = new T [rows * columns];\n\t\tint count = 0;\n\t\tfor(int i = 0 ; i < columns ; i++) {\n\t\t\tfor(int j = 0 ; j < rows ; j++) {\n\t\t\t\tvalue[count++] = values[j*columns + i];\n\t\t\t}\n\t\t}\n\t\tvector<T> value1;\n\t\tfor(int i = 0 ; i < columns ; i++) {\n\t\t\tfor(int j = 0 ; j < rows ; j++) {\n\t\t\t\tvalue1.push_back(value[j*columns + i]);\n\t\t\t}\n\t\t}\n\t\tMatrix temp(row, column, value1);\n\t\tdelete[] value;\n\t\treturn temp;\n\t}\n\tMatrix concatenateRows(Matrix & b) {\n\t\tvector<T> value1;\n\t\tfor(int i = 0 ; i < rows*columns + b.rows * b.columns ; i ++) {\n\t\t\tif(i < rows * columns) value1.push_back(values[i]);\n\t\t\telse value1.push_back(b.values[i - rows * columns]);\n\t\t}\n\t\tMatrix temp(rows + b.rows, columns, value1);\n\t\treturn temp;\n\t}\n\tMatrix concatenateColumns(Matrix & b) {\n\t\tvector<T> value1;\n\t\tfor(int i = 0 ; i < rows ; i ++) {\n\t\t\tfor(int j = 0 ; j < columns + b.columns ; j ++) {\n\t\t\t\tif(j < columns) {\n\t\t\t\t\tvalue1.push_back(values[i*columns + j]);\n\t\t\t\t}\n\t\t\t\telse value1.push_back (b.values[i*b.columns + j - columns]);\n\t\t\t}\n\t\t}\n\t\tMatrix temp(rows, columns + b.columns, value1);\n\t\treturn temp;\n\t}\n\tMatrix transpose() {\n\t\tvector<T> value1;\n\t\tfor(int i = 0 ; i < columns ; i++) {\n\t\t\tfor(int j = 0 ; j < rows ; j++) {\n\t\t\t\tvalue1.push_back(values[j*columns + i]);\n\t\t\t}\n\t\t}\n\t\tMatrix temp(rows, columns, value1);\n\t\treturn temp;\n\t}\n\tMatrix operator +(Matrix & b) {\n\t\tvector<T> value1;\n\t\tfor(int i = 0 ; i < rows * columns ; i ++) value1.push_back(values[i] + b.values[i]);\n\t\tMatrix temp(rows, columns, value1);\n\t\treturn temp;\n\t}\n\tMatrix operator -(Matrix & b) {\n\t\tvector<T> value1;\n\t\tfor(int i = 0 ; i < rows * columns ; i ++) value1.push_back(values[i] - b.values[i]);\n\t\tMatrix temp(rows, columns, value1);\n\t\treturn temp;\n\t}\n\tMatrix operator -(T value) {\n\t\tvector<T> value1;\n\t\tfor(int i = 0 ; i < rows * columns ; i ++) value1.push_back(values[i] - value);\n\t\tMatrix temp(rows, columns, value1);\n\t\treturn temp;\n\t}\n\tMatrix operator +(T value) {\n\t\tvector<T> value1;\n\t\tfor(int i = 0 ; i < rows * columns ; i ++) value1.push_back(values[i] + value);\n\t\tMatrix temp(rows, columns, value1);\n\t\treturn temp;\n\t}\n\tMatrix operator *(T value) {\n\t\tvector<T> value1;\n\t\tfor(int i = 0 ; i < rows * columns ; i ++) value1.push_back(values[i] * value);\n\t\tMatrix temp(rows, columns, value1);\n\t\treturn temp;\n\t}\n\tMatrix operator *(Matrix & b) {\n\t\tvector<T> value1;\n\t\tfor(int i = 0 ; i < rows ; i ++) {\n\t\t\tfor(int j = 0 ; j < b.columns ; j ++) {\n\t\t\t\tT sum = 0;\n\t\t\t\tfor(int k = 0 ; k < columns ; k ++) {\n\t\t\t\t\tsum += values[i*columns + k] * b.values[k*b.columns + j];\n\t\t\t\t}\n\t\t\t\tvalue1.push_back(sum);\n\t\t\t}\n\t\t}\n\t\tMatrix temp(rows, columns, value1);\n\t\treturn temp;\n\t}\n\tMatrix max() {\n        vector<T> value1;\n\t\tif(rows == 1) {\n\t\t\tT max = 0;\n\t\t\tfor(int i = 0 ; i < columns ; i ++) {\n\t\t\t\tif(max < values[i]) max = values[i];\n\t\t\t}\n\t\t\tvalue1.push_back(max);\n\t\t\tMatrix temp (1,1,value1);\n\t\t\treturn temp;\n\t\t}\n\t\telse {\n\t\t\tfor(int i = 0 ; i < columns ; i ++) {\n\t\t\t\tT max = 0;\n\t\t\t\tfor(int j = 0 ; j < rows ; j++) {\n\t\t\t\t\tif(max < values[j*columns + i]) max = values[j*columns + i];\n\t\t\t\t}\n\t\t\t\tvalue1.push_back(max);\n\t\t\t}\n\t\t\tMatrix temp (1,columns,value1);\n\t\t\treturn temp;\n\t\t}\n\t}\n\tMatrix min() {\n\t\tvector<T> value1;\n\t\tif(rows == 1) {\n\t\t\tT min = 999;\n\t\t\tfor(int i = 0 ; i < columns ; i ++) {\n\t\t\t\tif(min > values[i]) min = values[i];\n\t\t\t}\n\t\t\tvalue1.push_back(min);\n\t\t\tMatrix temp (1,1,value1);\n\t\t\treturn temp;\n\t\t}\n\t\telse {\n\t\t\tfor(int i = 0 ; i < columns ; i ++) {\n\t\t\t\tT min = 999;\n\t\t\t\tfor(int j = 0 ; j < rows ; j++) {\n\t\t\t\t\tif(min > values[j*columns + i]) min = values[j*columns + i];\n\t\t\t\t}\n\t\t\t\tvalue1.push_back(min);\n\t\t\t}\n\t\t\tMatrix temp (1,columns,value1);\n\t\t\treturn temp;\n\t\t}\n\t}\n\tMatrix sum() {\n\t\tvector<T> value1;\n\t\tif(rows == 1) {\n\t\t\tT sum = 0;\n\t\t\tfor(int i = 0 ; i < columns ; i ++) {\n\t\t\t\tsum += values[i];\n\t\t\t}\n\t\t\tvalue1.push_back(sum);\n\t\t\tMatrix temp (1,1,value1);\n\t\t\treturn temp;\n\t\t}\n\t\telse {\n\t\t\tfor(int i = 0 ; i < columns ; i ++) {\n\t\t\t\tT sum = 0;\n\t\t\t\tfor(int j = 0 ; j < rows ; j++) {\n\t\t\t\t\tsum += values[j*columns + i];\n\t\t\t\t}\n\t\t\t\tvalue1.push_back(sum);\n\t\t\t}\n\t\t\tMatrix temp (1,columns,value1);\n\t\t\treturn temp;\n\t\t}\n\t}\n\tT & get(int row, int column) {\n\t\treturn values[(row-1)*columns + column - 1];\n\t}\n};",
            1590210845.5248435,
            100,
            "# 答案正确"
        ],
        [
            "6.2 (C++)",
            "马浩宇",
            "#include <cstring>\n#include <iostream>\nusing namespace std;\n\ntemplate <typename T>\nclass Matrix {\nprivate:\n\tint rows;\n\tint columns;\n\tT * values;\npublic:\n\tMatrix(int row, int column) {\n\t\trows = row;\n\t\tcolumns = column;\n\t\tvalues = new T [rows * columns];\n\t\tfor (int i = 0; i < rows * columns; ++ i) values[i] = T();\n\t}\n\t~Matrix(){\n\t\tdelete[] values;\n\t}\n\tvoid print() {\n\t\tfor(int i = 0 ; i < rows ; i ++) {\n\t\t\tfor(int j = 0 ; j < columns ; j ++) {\n\t\t\t\tcout << \"    \" << values[i * columns + j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n};",
            1590632002.354862,
            100,
            "# 答案正确"
        ],
        [
            "7.1 (C++)",
            "马浩宇",
            "#include <cmath>\nclass Triangle : public GeometricObject \n{\nprivate:\n    double side1;\n    double side2;\n    double side3;\npublic:\n    Triangle() {\n        side1 = 1;\n        side2 = 1;\n        side3 = 1;\n    }\n    Triangle(double _side1, double _side2, double _side3) {\n        side1 = _side1;\n        side2 = _side2;\n        side3 = _side3;\n    }\n    ~Triangle() {\n    }\n    double getSide1() {\n        return side1;\n    }\n    double getSide2() {\n        return side2;\n    }\n    double getSide3() {\n        return side3;\n    }\n    double getArea(){\n        double temp = (side1 + side2 + side3) / 2;\n        double area = sqrt(temp * (temp - side1) * (temp - side2) * (temp - side3));\n        return area;\n    }\n    double getPerimeter() {\n        return side1 + side2 + side3;\n    }\n};",
            1590724216.000935,
            100,
            "# 答案正确"
        ],
        [
            "7.3 (C++)",
            "马浩宇",
            "template <typename A, typename R, typename T>\nvector<R> map2(const vector<A> & x,const vector<T> & y, R (*map_func)(const A &, const T &)) {\n\tvector<R> res;\n\tfor (int i = 0; i < x.size(); ++ i)\n\t\tres.push_back(map_func(x[i],y[i]));\n\treturn res;\n}\n\ntemplate <typename A, typename R, typename T>\nvector<R> map2(const vector<A> & x,const T & y, R (*map_func)(const A &, const T &)) {\n\tvector<R> res;\n\tfor (int i = 0; i < x.size(); ++ i)\n\t\tres.push_back(map_func(x[i],y));\n\treturn res;\n}",
            1590724701.3420708,
            100,
            "# 答案正确"
        ],
        [
            "7.2 (C++)",
            "马浩宇",
            "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nvector<string> split (const string & line , const string & delimiter = \" \") {\n    vector<string> res;\n    int start = 0;\n    while(start < line.size()) {\n        int end = line.find(delimiter, start);\n        if(end == start) start += delimiter.size();\n        else{\n            if(end == -1) {\n                res.push_back(line.substr(start));\n                break;\n            }\n            else {\n                res.push_back(line.substr(start, end - start));\n                start = end + delimiter.size();\n            }\n        }\n    }\n    return res;\n}\n",
            1591236729.7950168,
            100,
            "# 答案正确"
        ],
        [
            "8.1 (C++)",
            "马浩宇",
            "#include <vector>\nusing namespace std;\n\nclass Full : public Matrix {\nprivate:\n\tint rows;\n\tint columns;\n\tvector<double> values;\npublic:\n\tFull (int row, int column) {\n\t\trows = row;\n\t\tcolumns = column;\n\t\tfor(int i = 0 ; i < rows * columns ; i ++) values.push_back(0);\n\t}\n\tFull (const Matrix & matrix2) {\n\t\trows = matrix2.size(1);\n\t\tcolumns = matrix2.size(2);\n\t\tfor(int i = 0 ; i < rows ; i ++) {\n            for(int j = 0 ; j < columns ; j ++) {\n                values.push_back(matrix2.get(i+1,j+1));\n            }\n        }\n\t}\n\tFull (int row, int column, double* value) {\n\t\trows = row;\n\t\tcolumns = column;\n\t\tfor(int i = 0 ; i < row * column ; i ++) values.push_back(value[i]);\n\t}\n\t~Full(){\n\t}\n    int size(int dimension) const {\n        if(dimension == 1) return rows;\n        else return columns;\n    }\n\tvoid print() const {\n\t\tfor(int i = 0 ; i < rows ; i ++) {\n\t\t\tfor(int j = 0 ; j < columns ; j ++) {\n\t\t\t\tcout << \"    \" << values[i * columns + j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n    double get(int row, int column) const {\n        return values[(row - 1)*columns + column - 1];\n    }\n    void set(int row, int column, double value) {\n        values[(row - 1)*columns + column - 1] = value;\n    }\n\tMatrix & operator = (const Matrix & matrix2) {\n\t\tif(values.size() != 0) {\n\t\t\tvector<double> ().swap(values);\n\t\t}\n\t\trows = matrix2.size(1);\n\t\tcolumns = matrix2.size(2);\n\t\tfor(int i = 0 ; i < rows ; i ++) {\n            for(int j = 0 ; j < columns ; j ++) {\n                values.push_back(matrix2.get(i+1,j+1));\n            }\n        }\n\t\treturn *this;\n\t}\n};",
            1591338939.912884,
            100,
            "# 答案正确"
        ],
        [
            "8.3 (C++)",
            "马浩宇",
            "#include <vector>\n#include <iostream>\nusing namespace std;\n\nclass Sparse :public Matrix{\n    private:\n        int rows,columns;\n        vector<Entry> values;\n    public:\n        Sparse(int row, int column){\n            rows = row;\n            columns = column;\n        }\n        virtual int size(int dimension) const{\n            if(dimension == 1) return rows;\n            else if(dimension == 2) return columns;\n        }\n        virtual void set(int row, int column, double value){\n            if(value == 0) return;\n            for(int i = 0; i < values.size(); i++){\n                if(values[i].row == row && values[i].column == column){\n                    values[i].value += value;\n                    if(values[i].value == 0) \n                        values.erase(values.begin() + i);\n                    return;\n                }\n            }\n            Entry temp;\n            temp.row = row; \n            temp.column = column;\n            temp.value = value;\n            values.push_back(temp);\n        }\n        virtual double get(int row, int column) const{\n            for(int i = 0; i < values.size(); i++){\n                if(values[i].row == row && values[i].column == column)\n                    return values[i].value;\n            }\n            return 0;\n        }\n        bool find_big(Entry a1, Entry a2){\n            if(a1.row < a2.row) return 1;\n            if(a1.row > a2.row) return 0;\n            if(a1.column < a2.column) return 1;\n            if(a1.column > a2.column) return 0;\n        }\n        virtual void print(){\n            for(int i = 0; i < values.size(); i++){\n                for(int j = 0; j < values.size(); j++){\n                    if(find_big(values[i], values[j])){\n                        Entry temp = values[i];\n                        values[i] = values[j];\n                        values[j] = temp;\n                    }\n                }\n            }\n            for(int i = 0; i < values.size(); i++){\n                cout << \"(\" << values[i].row << \",\" << values[i].column;\n                cout << \",\" << values[i].value << \")\" << endl;\n            }\n        }\n        Sparse operator + (Sparse & sparse2){\n            Sparse temp(rows, columns);\n            for(int i = 0 ; i < values.size() ; ++i)\n                temp.set(values[i].row, values[i].column, values[i].value);\n            for(int i = 0 ; i < sparse2.values.size() ; ++i)\n                temp.set(sparse2.values[i].row, sparse2.values[i].column, sparse2.values[i].value);\n            return temp;\n        }\n};",
            1591788511.251922,
            100,
            "# 答案正确"
        ],
        [
            "8.4 (C++)",
            "马浩宇",
            "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Sparse :public Matrix{\n    private:\n        int rows,columns;\n        vector<Entry> values;\n    public:\n        Sparse(int row, int column){\n            rows = row;\n            columns = column;\n        }\n        virtual int size(int dimension) const{\n            if(dimension == 1) return rows;\n            else if(dimension == 2) return columns;\n        }\n        virtual void set(int row, int column, double value){\n            if(value == 0) return;\n            for(int i = 0; i < values.size(); i++){\n                if(values[i].row == row && values[i].column == column){\n                    values[i].value += value;\n                    if(values[i].value == 0) \n                        values.erase(values.begin() + i);\n                    return;\n                }\n            }\n            Entry temp;\n            temp.row = row; \n            temp.column = column;\n            temp.value = value;\n            values.push_back(temp);\n        }\n        virtual double get(int row, int column) const{\n            for(int i = 0; i < values.size(); i++){\n                if(values[i].row == row && values[i].column == column)\n                    return values[i].value;\n            }\n            return 0;\n        }\n        int find_big(Entry a1 , Entry a2){\n            if(a1.row < a2.row) return 1;\n            if(a1.row > a2.row) return 0;\n            if(a1.column < a2.column) return 1;\n            if(a1.column > a2.column) return 0;\n        }\n        virtual void print(){\n            for(int i = 0; i < values.size(); i++){\n                for(int j = 0; j < values.size(); j++){\n                    if(find_big(values[i], values[j])){\n                        Entry temp = values[i];\n                        values[i] = values[j];\n                        values[j] = temp;\n                    }\n                }\n            }\n            for(int i = 0; i < values.size(); i++){\n                cout << \"(\" << values[i].row << \",\" << values[i].column;\n                cout << \",\" << values[i].value << \")\" << endl;\n            }\n        }\n        Sparse operator * (Sparse & sparse2){\n            vector<Entry> temp1;\n            Sparse ans(rows, sparse2.columns);\n            for(int i = 0 ; i < values.size() ; ++i){\n                for(int j = 0 ; j < sparse2.values.size() ; ++j){\n                    if(values[i].column == sparse2.values[j].row){\n                        Entry temp;\n                        temp.row = values[i].row; \n                        temp.column = sparse2.values[j].column;\n                        temp.value = values[i].value * sparse2.values[j].value;\n                        temp1.push_back(temp);\n                    }\n                }\n            }\n            for(int i = 0; i < temp1.size(); ++i){\n                ans.set(temp1[i].row, temp1[i].column, temp1[i].value);\n            }\n            return ans;\n        }\n};",
            1591788465.5525014,
            100,
            "# 答案正确"
        ],
        [
            "8.5 (C++)",
            "马浩宇",
            "class Point3D : public Point2D\n{\nprivate:\n    double z;\n\npublic:\n    Point3D() {\n        setX(0);\n        setY(0);\n        z = 0;\n    }\n\n    ~Point3D() {}\n\n    Point3D(double x1, double y1, double z1) {\n        setX(x1);\n        setY(y1);\n        z = z1;\n    }\n\n    double getZ() {\n\t\treturn z;\n\t}\n\n    virtual double distance(Point2D & point2) {\n\t\tPoint3D & point_temp = dynamic_cast<Point3D &>(point2);\n        double dx = getX() - point_temp.getX();\n\t\tdouble dy = getY() - point_temp.getY();\n        double dz = getZ() - point_temp.getZ();\n\t\treturn sqrt(dx * dx + dy * dy + dz * dz);\n\t}\n};",
            1591843531.3981624,
            100,
            "# 答案正确"
        ],
        [
            "8.6 (C++)",
            "马浩宇",
            "#include <iostream>\nusing namespace std;\n\nclass MyTensor : public Tensor<double>\n{\nprivate:\n\tvector<double> values;\n\tint size;\npublic:\n\tMyTensor(vector<int> sizes):Tensor(sizes){\n\t\tsize = sizes.size();\n\t\tint space = 1;\n\t\tfor(int i = 0 ; i < size ; i++) {\n\t\t\tspace = space * sizes[i];\n\t\t}\n\t\tfor(int i = 0 ; i < space ; i ++) {\n\t\t\tvalues.push_back(0);\n\t\t}\n\t}\n\t~MyTensor() {\n\t}\n\tdouble & get (const vector<int> & indexes) {\n\t\tint dimension = indexes.size();\n\t\tif(dimension == 1) return values[indexes[0] - 1];\n\t\tif(dimension == 2) \n\t\t\treturn values[indexes[1]*sizes[0] + indexes[0] - 1];\n\t\tif(dimension == 3)\n\t\t\treturn values[indexes[2]*sizes[1]*sizes[0] + indexes[1]*sizes[0] + indexes[0] - 1];\n\t\tif(dimension == 4)\n\t\t\treturn values[indexes[3]*sizes[2]*sizes[1]*sizes[0] + indexes[2]*sizes[1]*sizes[0] + indexes[1]*sizes[0] + indexes[0] - 1];\n\t}\n};",
            1592449578.1120248,
            100,
            "# 答案正确"
        ],
        [
            "9.1 (C++)",
            "马浩宇",
            "class Circle \n{\nprivate:\n    double radius;\npublic:\n    Circle() {\n        radius = 0;\n    }\n    Circle(double r){\n        radius = r;\n    }\n    bool operator > (const Circle & b){\n        if(radius > b.radius) return true;\n        else return false;\n    }\n    bool operator < (const Circle & b){\n        if(radius < b.radius) return true;\n        else return false;\n    }\n    bool operator == (const Circle & b){\n        if(radius == b.radius) return true;\n        else return false;\n    }\n    bool operator != (const Circle & b){\n        if(radius != b.radius) return true;\n        else return false;\n    }\n    bool operator >= (const Circle & b){\n        if(radius >= b.radius) return true;\n        else return false;\n    }\n    bool operator <= (const Circle & b){\n        if(radius <= b.radius) return true;\n        else return false;\n    }\n};",
            1592550990.9373572,
            100,
            "# 答案正确"
        ],
        [
            "9.2 (C++)",
            "马浩宇",
            "class I\n{\nprivate:\n    vector<int> sizes;\npublic:\n    I(int a1 = -1, int a2 = -1, int a3 = -1, int a4 = -1) {\n        if(a1 != -1) sizes.push_back(a1);\n        if(a2 != -1) sizes.push_back(a2);\n        if(a3 != -1) sizes.push_back(a3);\n        if(a4 != -1) sizes.push_back(a4);\n    }\n    \n    operator vector<int> ()const {\n        return sizes;\n    }\n\n};\n",
            1592555395.2278986,
            100,
            "# 答案正确"
        ],
        [
            "9.3 (C++)",
            "马浩宇",
            "class Complex\n{\nprivate:\n    double imag1;\n    double real1;\npublic:\n    Complex(double _real, double _imag) {\n        imag1 = _imag;\n        real1 = _real;\n    }\n    Complex(int i) {\n        real1 = i;\n        imag1 = 0;\n    }\n    double real() const{\n        return real1;\n    }\n    double imag() const{\n        return imag1;\n    }\n    Complex operator += (const Complex &b) ;\n    Complex operator -= (const Complex &b) ;\n    Complex operator *= (const Complex &b) ;\n    Complex operator /= (const Complex &b) ;\n    bool operator == (const Complex & b){\n        if(imag1 == b.imag1 && real1 == b.real1) return true;\n        else return false;\n    }\n    bool operator != (const Complex & b){\n        if(imag1 != b.imag1 || real1 != b.real1) return true;\n        else return false;\n    }\n};\n\nComplex operator + (const Complex &a, const Complex &b) {\n    return Complex(a.real() + b.real(), a.imag() + b.imag());\n}\nComplex operator - (const Complex &a, const Complex &b) {\n    return Complex(a.real() - b.real(), a.imag() - b.imag());\n}\nComplex operator * (const Complex &a, const Complex &b) {\n    return Complex(a.real()*b.real() - a.imag()*b.imag(), a.real()*b.imag() + a.imag()*b.real());\n}\nComplex operator / (const Complex &a, const Complex &b) {\n    if (b.imag() == 0)\n        return Complex(a.real() / b.real(), a.imag() / b.real());\n    else\n        return a * Complex(b.real(), -b.imag()) / Complex(b.real()*b.real() + b.imag()*b.imag(), 0);\n}\nComplex Complex :: operator += (const Complex &b) {\n    imag1 = imag1 + b.imag1;\n    real1 = real1 + b.real1;\n    return *this;\n}\nComplex Complex :: operator -= (const Complex &b) {\n    imag1 = imag1 - b.imag1;\n    real1 = real1 - b.real1;\n    return *this;\n}\nComplex Complex :: operator *= (const Complex &b) {\n    double temp1 = real1*b.real1 - imag1*b.imag1;\n    double temp2 = real1*b.imag1 + imag1*b.real1;\n    real1 = temp1;\n    imag1 = temp2;\n    return *this;\n}\nComplex Complex :: operator /= (const Complex &b) {\n    if (b.imag1 == 0) {\n        real1 = real1 / b.real1;\n        imag1 = imag1 / b.real1;\n        return *this;\n    }\n    else {\n        double temp1 = (real1*b.real1 + imag1*b.imag1) / (b.real1*b.real1 + b.imag1*b.imag1);\n        double temp2 = (imag1*b.real1 - real1*b.imag1) / (b.real1*b.real1 + b.imag1*b.imag1);\n        real1 = temp1;\n        imag1 = temp2;\n        return *this;\n    }\n}",
            1592559426.1861863,
            100,
            "# 答案正确"
        ],
        [
            "9.6 (C++)",
            "马浩宇",
            "class Tensor\n{\nprivate:\n    vector<double> values;\n    vector<int> sizes;\n    int size = 0;\npublic:\n    Tensor(int a1 = -1, int a2 = -1, int a3 = -1, int a4 = -1) {\n        int space = 1;\n        if(a1 != -1) {\n            sizes.push_back(a1);\n            size ++;\n            space *= a1;\n        }\n        if(a2 != -1) {\n            sizes.push_back(a2);\n            size ++;\n            space *= a2;\n        }\n        if(a3 != -1) {\n            sizes.push_back(a3);\n            size ++;\n            space *= a3;\n        }\n        if(a4 != -1) {\n            sizes.push_back(a4);\n            size ++;\n            space *= a4;\n        }\n        for(int i = 0 ; i < space ; i ++) values.push_back(0);\n    }\n    double & operator() (int a = -1, int b = -1, int c = -1, int d = -1) {\n        int index = a;\n        if(b != -1) index = index * sizes[1] + b;\n        if(c != -1) index = index * sizes[2] + c;\n        if(d != -1) index = index * sizes[3] + d;\n        return values[index];\n    }\n    const double & operator() (int a = -1, int b = -1, int c = -1, int d = -1) const{\n        int index = a;\n        if(b != -1) index = index * sizes[1] + b;\n        if(c != -1) index = index * sizes[2] + c;\n        if(d != -1) index = index * sizes[3] + d;\n        return values[index];\n    }\n};",
            1592622129.5317109,
            100,
            "# 答案正确"
        ],
        [
            "9.4 (C++)",
            "马浩宇",
            "#include <iostream>\n#include <fstream>\nusing namespace std;\n\nclass Complex\n{\nprivate:\n    double imag1;\n    double real1;\npublic:\n    Complex(double _real, double _imag) {\n        imag1 = _imag;\n        real1 = _real;\n    }\n    Complex() {\n        imag1 = 0;\n        real1 = 0;\n    }\n    Complex(int i) {\n        real1 = i;\n        imag1 = 0;\n    }\n    double real() const{\n        return real1;\n    }\n    double imag() const{\n        return imag1;\n    }\n    Complex operator += (const Complex &b) ;\n    Complex operator -= (const Complex &b) ;\n    Complex operator *= (const Complex &b) ;\n    Complex operator /= (const Complex &b) ;\n    bool operator == (const Complex & b){\n        if(imag1 == b.imag1 && real1 == b.real1) return true;\n        else return false;\n    }\n    bool operator != (const Complex & b){\n        if(imag1 != b.imag1 || real1 != b.real1) return true;\n        else return false;\n    }\n    Complex & operator = (const Complex &b) {\n        if (*this != b) {\n            real1 = b.real1;\n            imag1 = b.imag1;\n        }\n        return *this;\n    }\n};\nComplex operator + (const Complex &a, const Complex &b) {\n    return Complex(a.real() + b.real(), a.imag() + b.imag());\n}\nComplex operator - (const Complex &a, const Complex &b) {\n    return Complex(a.real() - b.real(), a.imag() - b.imag());\n}\nComplex operator * (const Complex &a, const Complex &b) {\n    return Complex(a.real()*b.real() - a.imag()*b.imag(), a.real()*b.imag() + a.imag()*b.real());\n}\nComplex operator / (const Complex &a, const Complex &b) {\n    if (b.imag() == 0)\n        return Complex(a.real() / b.real(), a.imag() / b.real());\n    else\n        return a * Complex(b.real(), -b.imag()) / Complex(b.real()*b.real() + b.imag()*b.imag(), 0);\n}\nComplex Complex :: operator += (const Complex &b) {\n    imag1 = imag1 + b.imag1;\n    real1 = real1 + b.real1;\n    return *this;\n}\nComplex Complex :: operator -= (const Complex &b) {\n    imag1 = imag1 - b.imag1;\n    real1 = real1 - b.real1;\n    return *this;\n}\nComplex Complex :: operator *= (const Complex &b) {\n    double temp1 = real1*b.real1 - imag1*b.imag1;\n    double temp2 = real1*b.imag1 + imag1*b.real1;\n    real1 = temp1;\n    imag1 = temp2;\n    return *this;\n}\nComplex Complex :: operator /= (const Complex &b) {\n    if (b.imag1 == 0) {\n        real1 = real1 / b.real1;\n        imag1 = imag1 / b.real1;\n        return *this;\n    }\n    else {\n        double temp1 = (real1*b.real1 + imag1*b.imag1) / (b.real1*b.real1 + b.imag1*b.imag1);\n        double temp2 = (imag1*b.real1 - real1*b.imag1) / (b.real1*b.real1 + b.imag1*b.imag1);\n        real1 = temp1;\n        imag1 = temp2;\n        return *this;\n    }\n}\n\nostream & operator << (ostream & out, const Complex &a) {\n    out << a.real() << \" + \" << a.imag() << \" i\";\n    return out;\n}\nistream & operator >> (istream & in, Complex &a) {\n    double real, imag;\n    in >> real >> imag;\n    Complex temp(real, imag);\n    a = temp;\n    return in;\n}",
            1592615841.2660902,
            100,
            "# 答案正确"
        ],
        [
            "9.5 (C++)",
            "马浩宇",
            "#include <iostream>\n#include <fstream>\nusing namespace std;\n\nclass Complex\n{\nprivate:\n    double imag1;\n    double real1;\npublic:\n    Complex(double _real, double _imag) {\n        imag1 = _imag;\n        real1 = _real;\n    }\n    Complex() {\n        imag1 = 0;\n        real1 = 0;\n    }\n    Complex(int i) {\n        real1 = i;\n        imag1 = 0;\n    }\n    double real() const{\n        return real1;\n    }\n    double imag() const{\n        return imag1;\n    }\n    Complex operator += (const Complex &b) ;\n    Complex operator -= (const Complex &b) ;\n    Complex operator *= (const Complex &b) ;\n    Complex operator /= (const Complex &b) ;\n    bool operator == (const Complex & b){\n        if(imag1 == b.imag1 && real1 == b.real1) return true;\n        else return false;\n    }\n    bool operator != (const Complex & b){\n        if(imag1 != b.imag1 || real1 != b.real1) return true;\n        else return false;\n    }\n    Complex & operator = (const Complex &b) {\n        if (*this != b) {\n            real1 = b.real1;\n            imag1 = b.imag1;\n        }\n        return *this;\n    }\n    Complex & operator ++ () {\n        real1++;\n        return *this;\n    }\n    Complex operator ++ (int) {\n        Complex temp(real1, imag1);\n        real1++;\n        return temp;\n    }\n    operator double () const {\n        return real1;\n    }\n};\nComplex operator + (const Complex &a, const Complex &b) {\n    return Complex(a.real() + b.real(), a.imag() + b.imag());\n}\nComplex operator - (const Complex &a, const Complex &b) {\n    return Complex(a.real() - b.real(), a.imag() - b.imag());\n}\nComplex operator * (const Complex &a, const Complex &b) {\n    return Complex(a.real()*b.real() - a.imag()*b.imag(), a.real()*b.imag() + a.imag()*b.real());\n}\nComplex operator / (const Complex &a, const Complex &b) {\n    if (b.imag() == 0)\n        return Complex(a.real() / b.real(), a.imag() / b.real());\n    else\n        return a * Complex(b.real(), -b.imag()) / Complex(b.real()*b.real() + b.imag()*b.imag(), 0);\n}\nComplex Complex :: operator += (const Complex &b) {\n    imag1 = imag1 + b.imag1;\n    real1 = real1 + b.real1;\n    return *this;\n}\nComplex Complex :: operator -= (const Complex &b) {\n    imag1 = imag1 - b.imag1;\n    real1 = real1 - b.real1;\n    return *this;\n}\nComplex Complex :: operator *= (const Complex &b) {\n    double temp1 = real1*b.real1 - imag1*b.imag1;\n    double temp2 = real1*b.imag1 + imag1*b.real1;\n    real1 = temp1;\n    imag1 = temp2;\n    return *this;\n}\nComplex Complex :: operator /= (const Complex &b) {\n    if (b.imag1 == 0) {\n        real1 = real1 / b.real1;\n        imag1 = imag1 / b.real1;\n        return *this;\n    }\n    else {\n        double temp1 = (real1*b.real1 + imag1*b.imag1) / (b.real1*b.real1 + b.imag1*b.imag1);\n        double temp2 = (imag1*b.real1 - real1*b.imag1) / (b.real1*b.real1 + b.imag1*b.imag1);\n        real1 = temp1;\n        imag1 = temp2;\n        return *this;\n    }\n}\n\nostream & operator << (ostream & out, const Complex &a) {\n    out << a.real() << \" + \" << a.imag() << \" i\";\n    return out;\n}\nistream & operator >> (istream & in, Complex &a) {\n    double real, imag;\n    in >> real >> imag;\n    Complex temp(real, imag);\n    a = temp;\n    return in;\n}",
            1592616165.6861215,
            100,
            "# 答案正确"
        ],
        [
            "9.7 (C++)",
            "马浩宇",
            "class Tensor \n{\nprivate:\n    vector<double> values;\n    vector<int> sizes;\n    int dimension;\npublic:\n    Tensor() {\n        dimension = 0;\n    }\n    Tensor(const Tensor & b) {\n        dimension = b.dimension;\n        int space = 1;\n        for(int i = 0 ; i < dimension ; i ++) {\n            sizes.push_back(b.sizes[i]);\n            space *= b.sizes[i];\n        }\n        for(int i = 0 ; i < space ; i ++) {\n            values.push_back(b.values[i]);\n        }\n    }\n    Tensor(vector<int> _sizes, vector<double> _values, int dimensions) {\n        dimension = dimensions;\n        int space = 1;\n        for(int i = 0 ; i < dimension ; i ++) {\n            sizes.push_back(_sizes[i]);\n            space *= _sizes[i];\n        }\n        for(int i = 0 ; i < space ; i ++) {\n            values.push_back(_values[i]);\n        }\n    }\n    int get_dimension() const {\n        return dimension;\n    }\n    double & operator() (int a = -1, int b = -1, int c = -1, int d = -1) {\n        int index = a;\n        if(b != -1) index = index * sizes[1] + b;\n        if(c != -1) index = index * sizes[2] + c;\n        if(d != -1) index = index * sizes[3] + d;\n        return values[index];\n    }\n    const double & operator() (int a = -1, int b = -1, int c = -1, int d = -1) const{\n        int index = a;\n        if(b != -1) index = index * sizes[1] + b;\n        if(c != -1) index = index * sizes[2] + c;\n        if(d != -1) index = index * sizes[3] + d;\n        return values[index];\n    }\n    vector<int> get_sizes() const {\n        return sizes;\n    }\n};\n\nostream & operator << (ostream & out, const Tensor & a) {\n    out << a.get_dimension() << endl;\n    vector<int> temp = a.get_sizes();\n    for(int i = 0 ; i < a.get_dimension() ; i ++) {\n        out << temp[i] << \" \";\n    }\n    out << endl << endl;\n    if(a.get_dimension() == 1) {\n        for(int i = 1 ; i <= temp[0] ; i ++) out << a(i-1) << \" \";\n        out << endl;\n    }\n    if(a.get_dimension() == 2) {\n        for(int i = 1 ; i <= temp[0] ; i ++) {\n            for (int j = 1 ; j <= temp[1]; j ++) {\n                out << a(i-1,j-1) << \" \";\n            }\n            out << endl;\n        }\n        out << endl;\n    }\n    if(a.get_dimension() == 3) {\n        for(int i = 1 ; i <= temp[0] ; i ++) {\n            for(int j = 1 ; j <= temp[1] ; j ++) {\n                for(int k = 1 ; k <= temp[2] ; k ++) {\n                    out << a(i-1,j-1,k-1) << \" \";\n                }\n                out << endl;\n            }\n            out << endl;\n        }\n    }\n    if(a.get_dimension() == 4) {\n        for(int i = 1 ; i <= temp[0] ; i ++) {\n            for(int m = 1 ; m <= temp[1] ; m ++) {\n                for(int j = 1 ; j <= temp[2] ; j ++) {\n                    for(int k = 1 ; k <= temp[3] ; k ++) {\n                        out << a(i-1,m-1,j-1,k-1) << \" \";\n                    }\n                    out << endl;\n                }\n                out << endl;\n            }\n        }   \n    }\n    return out;\n}\n\nistream & operator >> (istream & in, Tensor & a) {\n    int _dimension;\n    in >> _dimension;\n    vector<int> temp1;\n    vector<double> temp2;\n    int space = 1;\n    for(int i = 0 ; i < _dimension ; i ++) {\n        int b;\n        in >> b;\n        temp1.push_back(b);\n        space *= b;\n    }\n    for(int i = 0 ; i < space ; i ++) {\n        double c;\n        in >> c;\n        temp2.push_back(c);\n    }\n    Tensor temp(temp1, temp2, _dimension);\n    a = temp;\n    return in;\n}\n",
            1592621944.6541047,
            100,
            "# 答案正确"
        ],
        [
            "10.1 (C++)",
            "马浩宇",
            "#include <stdexcept>\nusing namespace std;\nclass MatrixSizesDoNotMatchException {};\n\ndouble Matrix :: get(int row, int column) const {\n    if(row > rows || column > columns || row*column > rows*columns) throw out_of_range(\"\");\n    return elements[(row-1)*columns + column - 1];\n}\n\nvoid Matrix :: set(int row, int column, double value) {\n    if(row > rows || column > columns || row*column > rows*columns) throw out_of_range(\"\");\n    elements[(row-1)*columns + column - 1] = value;\n}\n\nMatrix Matrix::operator + (const Matrix & matrix2) const {\n    if(columns != matrix2.columns || rows != matrix2.rows) throw MatrixSizesDoNotMatchException();\n    vector<double> temp;\n    for(int i = 0 ; i < rows * columns ; i ++) {\n        temp.push_back(elements[i] + matrix2.elements[i]);\n    }\n    Matrix temp1(rows, columns);\n    for(int i = 1 ; i <= rows ; i ++) {\n        for(int j = 1 ; j <= columns ; j ++) {\n            temp1.set(i, j, temp[(i-1)*columns + j - 1]);\n        }\n    }\n    return temp1;\n}\n",
            1593314221.8127027,
            100,
            "# 答案正确"
        ],
        [
            "10.2 (C++)",
            "马浩宇",
            "catch(NonPositiveValueException & ex) {\n   cout << \"caught: NonPositiveValueException\" << endl;\n}\ncatch(out_of_range & ex) {\n   cout << \"caught: out_of_range\" << endl;\n}",
            1593655913.7621453,
            100,
            "# 答案正确"
        ],
        [
            "15.1 (C++)",
            "马浩宇",
            "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nclass Table\n{\nprivate:\n\tint Col = 0;\n\tint Row = 0;\n\tvector<string> header;\n\tvector<vector<string>> rows;\npublic:\n\tTable() {\n\t\tCol = 0;\n\t\tRow = 0;\n\t}\n\tvoid addCol(const string a) {\n\t\tCol ++;\n\t\theader.push_back(a);\n\t}\n\tvector<string> & operator [] (int index) {\n\t\tif(Row == index) {\n\t\t\tRow ++;\n\t\t\tvector<string> temp;\n\t\t\trows.push_back(temp);\n\t\t\treturn rows[index];\n\t\t}\n\t\telse {\n\t\t\treturn rows[index];\n\t\t}\n\t}\n\tstring json() const {\n\t\tstring res;\n\t\tres = res + \"{\" + \"\\n\" + \"\\t\";\n\t\tres = res + \"headers: [\";\n\t\tfor(int i = 0 ; i < Col ; i ++) {\n\t\t\tres = res + \"'\" + header[i] + \"',\";\n\t\t}\n\t\tres = res + \"],\\n\\t\" + \"rows: [\\n\";\n\t\tfor(int i = 0 ; i < Row ; i ++) {\n\t\t\tres = res + \"\\t\\t[\";\n\t\t\tfor(int j = 0 ; j < Col ; j ++) {\n\t\t\t\tres = res + \"'\" + rows[i][j] + \"',\";\n\t\t\t}\n\t\t\tres = res + \"],\\n\";\n\t\t}\n\t\tres = res + \"\\t],\\n}\";\n\t\treturn res;\n\t}\n};",
            1593746852.8613162,
            100,
            "# 答案正确"
        ],
        [
            "2020-07-09 LAB",
            "马浩宇",
            "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nclass Integer\n{\nprivate:\n\tint val;\n\tstatic int size;\n\tstatic vector<Integer*> store;\npublic:\n\tInteger() {\n\t\tval = 0;\n\t\tstore.push_back(this);\n\t}\n\tint get_val() const{\n\t\treturn val;\n\t}\n\tint & get_val() {\n\t\treturn val;\n\t}\n\tInteger(int num) {\n\t\tval = num;\n\t\tsize ++;\n\t\tstore.push_back(this);\n\t}\n\tstatic void increase_all(int num) {\n\t\tfor(int i = 0 ; i < size ; i ++) {\n\t\t\t(*store[i]).get_val() += num;\n\t\t}\n\t}\n\tstatic void increase_all(Integer num) {\n\t\tint num1 = num.get_val();\n\t\tfor(int i = 0 ; i < size ; i ++) {\n\t\t\t(*store[i]).get_val() += num1;\n\t\t}\n\t}\n};\n\nint Integer :: size = 0;\nvector<Integer*> Integer::store;\n\nostream& operator << (ostream& out, const Integer & a) {\n\tout << a.get_val();\n\treturn out;\n}\n\nistream& operator >> (istream& in, Integer & a) {\n\tint val;\n\tin >> val;\n\tInteger temp(val);\n\ta = temp;\n\treturn in;\n}",
            1594263102.5798702,
            100,
            "# 答案正确"
        ],
        [
            "A.1 (C++)",
            "马浩宇",
            "private:\n\tNode<E> * get_node(int index) const {\n\t\tif (index < 0 || index >= _size) \n\t\t\tthrow NotSuchElementException();\n\t\tif (index < _size / 2) {\n\t\t\tNode<E> * node = head;\n\t\t\tNode<E> * prev_node1 = NULL;\n\t\t\tI(i, index) {\n\t\t\t\tNode<E>*temp = node;\n\t\t\t\tnode = node->next_node(prev_node1);\n\t\t\t\tprev_node1 = temp;\n\t\t\t}\n\t\t\treturn node;\n\t\t}\n\t\telse {\n\t\t\tNode<E> * node = tail;\n\t\t\tNode<E> * next_node1 = NULL;\n\t\t\tI(i, (_size-1-index)) {\n\t\t\t\tNode<E>* temp = node;\n\t\t\t\tnode = node->prev_node(next_node1);\n\t\t\t\tnext_node1 = temp;\n\t\t\t}\n\t\t\treturn node;\n\t\t}\n\t}\n\n\npublic:\n\tE & get(int index) const {\n\t\tNode<E> * node = get_node(index);\n\t\treturn node->element;\n\t}\n\tvoid set(int index, const E & e) {\n\t\tNode<E> * node = get_node(index);\n\t\tnode->element = e;\n\t}\n\n\tE & getFirst() const {\n\t\treturn get(0);\n\t}\n\n\tE & getLast() const {\n\t\treturn get(_size - 1);\n\t}\n\n\tvoid remove (int index) {\n\t\tNode<E> * node = get_node(index);\n\t\tNode<E> * prev_node = (index == 0 ? 0 : get_node(index-1));\n\t\tNode<E> * next_node = (index == _size - 1 ? 0 : get_node(index+1));\n\t\tNode<E>* temp1 = prev_node;\n\t\tNode<E>* temp2 = next_node;\n\t\tif (prev_node != 0) prev_node->update_next_node(node,temp2);\n\t\tif (next_node != 0) next_node->update_prev_node(node,temp1);\n\t\tif (prev_node == 0) head = next_node;\n\t\tif (next_node == 0) tail = prev_node;\n\t\tdelete node;\n\t\t-- _size;\n\t}\n\n\tvoid removeFirst () {\n\t\tremove(0);\n\t}\n\n\tvoid removeLast () {\n\t\tremove(_size-1);\n\t}\n\n\tvoid add(int index, const E & e) {\n\t\tif (index < 0 || index > _size) \n\t\t\tthrow NotSuchElementException();\n\t\tNode<E> * node = new Node<E>();\n\t\tnode->element = e;\n\t\tNode<E> * next_node = (index == _size ? 0 : get_node(index));\n\t\tNode<E> * prev_node = (next_node == 0 ? tail : (index == 0 ? 0 : get_node(index-1)));\n\t\tNode<E> * temp1 = next_node;\n\t\tNode<E> * temp2 = prev_node;\n\t\tnode->update_prev_and_next_node(prev_node, next_node);\n\t\tif (prev_node != 0) prev_node->update_next_node(temp1, node);\n\t\tif (next_node != 0) next_node->update_prev_node(temp2, node);\n\t\tif (prev_node == 0) head = node;\n\t\tif (next_node == 0) tail = node;\n\t\t++ _size;\n\t}\n\n\tvoid addFirst (const E & e) {\n\t\tadd(0, e);\n\t}\n\n\tvoid addLast (const E & e) {\n\t\tadd(_size, e);\n\t}\n\n\t// copy and clear\n\n\tvoid clear() {\n\t\twhile (_size > 0) removeFirst();\n\t}\n\n\tvoid addAll(const LinkedList & list, int index=-1) {\n\t\tif (index == -1) index = _size;\n\t\tI(i, list._size) {\n\t\t\tNode<E> * node = list.get_node(i);\n\t\t\tadd(index + i, node->element);\n\t\t}\n\t}\n\n\tLinkedList(const LinkedList & list) : _size(0), head(0), tail(0) {\n\t\taddAll(list);\n\t}\n\n\tLinkedList & operator = (const LinkedList & list) {\n\t\tclear();\n\t\taddAll(list);\n\t\treturn *this;\n\t}\n\n\t~LinkedList() {\n\t\tclear();\n\t}\n\n\tint indexOf(const E & e) const {\n\t\tNode<E> * node = head;\n\t\tNode<E> * prev_node1 = NULL;\n\t\tI(i, _size) {\n\t\t\tif (node->element == e) return i;\n\t\t\tNode<E>*temp = node;\n\t\t\tnode = node->next_node(prev_node1);\n\t\t\tprev_node1 = temp;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tint lastIndexOf(const E & e) const {\n\t\tNode<E> * node = tail;\n\t\tNode<E> * next_node1 = NULL;\n\t\tI(i, _size) {\n\t\t\tif (node->element == e) return i;\n\t\t\tNode<E>*temp = node;\n\t\t\tnode = node->prev_node(next_node1);\n\t\t\tnext_node1 = temp;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tbool contains(const E & e) const {\n\t\treturn indexOf(e) >= 0;\n\t}\n\n\tvoid removeFirstOccurrence(const E & e) {\n\t\tint index = indexOf(e);\n\t\tif (index == -1)\n\t\t\tthrow NotSuchElementException();\n\t\tremove(index);\n\t}\n\n\tvoid removeLastOccurrence(const E & e) {\n\t\tint index = lastIndexOf(e);\n\t\tif (index == -1)\n\t\t\tthrow NotSuchElementException();\n\t\tremove(index);\n\t}",
            1594784233.680153,
            100,
            "# 答案正确"
        ],
        [
            "A.2 (C++)",
            "马浩宇",
            "template <typename E>\nvoid LinkedList<E>::removeAll(const E & e) {\n\tint flag = 0;\n\twhile(1) {\n\t\tint index = indexOf(e);\n\t\tif(index == -1) {\n\t\t\tif(flag == 1) break;\n\t\t\telse throw  NotSuchElementException();\n\t\t}\n\t\tflag = 1;\n\t\tremove(index);\n\t}\n}",
            1594865653.5073106,
            100,
            "# 答案正确"
        ],
        [
            "A.4 (C++)",
            "马浩宇",
            "#include <iostream>\n#include <vector>\nusing namespace std;\n\nstring i_to_string(const int & a) {\n\tstring res;\n\tint temp = a;\n\twhile(temp > 0) {\n\t\tint num = temp % 10;\n\t\tres.push_back(num + '0');\n\t\ttemp = temp / 10;\n\t}\n\tfor(int i = 0 ; i < res.size() / 2 ; i ++){\n\t\tchar a = res[i];\n\t\tres[i] = res[res.size() - i - 1];\n\t\tres[res.size() - i - 1] = a;\n\t}\n\treturn res;\n}\n\n\nclass KeyAndValue\n{\nprivate:\n\tint key_i;\n\tstring key_s;\npublic:\n\tKeyAndValue() : key_i(0), key_s(string()) {}\n\tKeyAndValue(int a) : key_i(a), key_s(string()) {}\n\tKeyAndValue(string s) : key_i(0), key_s(s) {}\n\n\toperator int() { return key_i; } \n\toperator string() { return key_s; }\n\n\toperator int() const { return key_i; } \n \toperator string() const { return key_s; } \n\n\tbool operator == (const KeyAndValue & other) {\n\t\tif(key_i != other.key_i || key_s != other.key_s) return false;\n\t\telse return true;\n\t}\n};\n\nclass element\n{\nprivate:\n\tKeyAndValue key;\n\tKeyAndValue value;\npublic:\n\tbool in_use;\n\tKeyAndValue key1() const{ return key;}\n\tKeyAndValue value1() const{ return value;}\n\tKeyAndValue & key2() {return key;}\n\tKeyAndValue & value2() { return value;}\n\n\telement() : in_use(false) {}\n\telement(KeyAndValue a, KeyAndValue b): key(a), value(b), in_use(true) {}\n};\n\nsize_t circular_shift(size_t bits, int shift_bits) {\n\tconst int num_bits = 8 * sizeof(size_t);\n\tshift_bits = shift_bits % num_bits;\n\treturn bits << shift_bits | bits >> (num_bits - shift_bits);\n}\n\nsize_t hash_function (const KeyAndValue & key) {\n\tstring temp;\n\tif((int)key == 0) temp = string(key);\n\telse temp = i_to_string((int)key);\n\tsize_t code = 0;\n\tfor(int i = 0 ; i < temp.size() ; i++) {\n\t\tcode ^= circular_shift(temp[i], i * 5);\n\t}\n\treturn code;\n}\n\n\nclass HT\n{\nprivate:\n\tvector<element> tuples;\n\tsize_t _size;\n\n\tsize_t indexOfKey1(const KeyAndValue & key) const {\n\t\tsize_t hash_code = hash_function(key);\n\t\treturn hash_code % tuples.size();\n\t}\n\n\tsize_t indexOfKey(const KeyAndValue & key) const {\n\t\tsize_t index = indexOfKey1(key);\n\t\twhile(true) {\n\t\t\tif(! tuples[index].in_use) return index;\n\t\t\tif(tuples[index].key1() == key) return index;\n\t\t\tindex = (index + 1) % tuples.size();\n\t\t}\n\t}\npublic:\n\tHT() : _size(0) {\n\t\ttuples.resize(2);\n\t}\n\n\tvoid put (KeyAndValue a, KeyAndValue b) {\n\t\tsize_t index = indexOfKey(a);\n\t\ttuples[index].value2() = b;\n\t\ttuples[index].key2() = a;\n\t\tif(tuples[index].in_use == 1) return;\n\t\t_size ++;\n\t\ttuples[index].in_use = 1;\n\t\tif(2 * _size > tuples.size())\n\t\t\t_double_tuples();\n\t}\n\n\tvoid clear() {\n\t\tfor(int i = 0; i < tuples.size() ; i ++) {\n\t\t\ttuples[i].in_use = 0;\t\n\t\t}\n\t\t_size = 0;\n\t}\n\n\tvoid _double_tuples() {\n\t\tvector<element> non_empty_tuples;\n\t\tfor(int i = 0 ; i < tuples.size() ; i ++) {\n\t\t\tif(tuples[i].in_use)\n\t\t\t\tnon_empty_tuples.push_back(tuples[i]);\n\t\t}\n\t\tclear();\n\t\ttuples.resize(tuples.size() * 2);\n\t\tclear();\n\t\tfor (int i = 0 ; i < non_empty_tuples.size() ; i ++)\n\t\t\tput(non_empty_tuples[i].key1(), non_empty_tuples[i].value1());\n\t}\n\n\tKeyAndValue operator [] (const KeyAndValue & a) {\n\t\tsize_t index = indexOfKey(a);\n\t\treturn tuples[index].value1();\n\t}\n\n\tsize_t size() { return _size; }\n};",
            1595477083.118684,
            100,
            "# 答案正确"
        ],
        [
            "A.5 (C++)",
            "马浩宇",
            "#include <iostream>\n#include <vector>\nusing namespace std;\n\nstring i_to_string(const int & a) {\n\tstring res;\n\tint temp = a;\n\twhile(temp > 0) {\n\t\tint num = temp % 10;\n\t\tres.push_back(num + '0');\n\t\ttemp = temp / 10;\n\t}\n\tfor(int i = 0 ; i < res.size() / 2 ; i ++){\n\t\tchar a = res[i];\n\t\tres[i] = res[res.size() - i - 1];\n\t\tres[res.size() - i - 1] = a;\n\t}\n\treturn res;\n}\n\n\nclass KeyAndValue\n{\nprivate:\n\tint key_i;\n\tstring key_s;\npublic:\n\tKeyAndValue() : key_i(0), key_s(string()) {}\n\tKeyAndValue(int a) : key_i(a), key_s(string()) {}\n\tKeyAndValue(string s) : key_i(0), key_s(s) {}\n\n\toperator int() { return key_i; } \n\toperator string() { return key_s; }\n\n\toperator int() const { return key_i; } \n \toperator string() const { return key_s; } \n\n\tbool operator == (const KeyAndValue & other) {\n\t\tif(key_i != other.key_i || key_s != other.key_s) return false;\n\t\telse return true;\n\t}\n};\n\nclass element\n{\nprivate:\n\tKeyAndValue key;\n\tKeyAndValue value;\npublic:\n\tbool in_use;\n\tKeyAndValue key1() const{ return key;}\n\tKeyAndValue value1() const{ return value;}\n\tKeyAndValue & key2() {return key;}\n\tKeyAndValue & value2() { return value;}\n\n\telement() : in_use(false) {}\n\telement(KeyAndValue a, KeyAndValue b): key(a), value(b), in_use(true) {}\n\telement(const element & a) {\n\t\tkey = a.key1();\n\t\tvalue = a.value1();\n\t\tin_use = 1;\n\t}\n};\n\nsize_t circular_shift(size_t bits, int shift_bits) {\n\tconst int num_bits = 8 * sizeof(size_t);\n\tshift_bits = shift_bits % num_bits;\n\treturn bits << shift_bits | bits >> (num_bits - shift_bits);\n}\n\nsize_t hash_function (const KeyAndValue & key) {\n\tstring temp;\n\tif((int)key == 0) temp = string(key);\n\telse temp = i_to_string((int)key);\n\tsize_t code = 0;\n\tfor(int i = 0 ; i < temp.size() ; i++) {\n\t\tcode ^= circular_shift(temp[i], i * 5);\n\t}\n\treturn code;\n}\n\n\nclass HT\n{\nprivate:\n\tvector<element> tuples;\n\tsize_t _size;\n\n\tsize_t indexOfKey1(const KeyAndValue & key) const {\n\t\tsize_t hash_code = hash_function(key);\n\t\treturn hash_code % tuples.size();\n\t}\n\n\tsize_t indexOfKey(const KeyAndValue & key) const {\n\t\tsize_t index = indexOfKey1(key);\n\t\twhile(true) {\n\t\t\tif(! tuples[index].in_use) return index;\n\t\t\tif(tuples[index].key1() == key) return index;\n\t\t\tindex = (index + 1) % tuples.size();\n\t\t}\n\t}\npublic:\n\tHT() : _size(0) {\n\t\ttuples.resize(2);\n\t}\n\n\tKeyAndValue & operator [] (const KeyAndValue & a) {\n\t\tif(2 * _size > tuples.size()) {\n\t\t\t_double_tuples();\n\t\t}\n\t\tsize_t index = indexOfKey(a);\n\t\tif(tuples[index].in_use == 0) {\n\t\t\ttuples[index].key2() = a;\n\t\t\t_size++;\n\t\t\ttuples[index].in_use = 1;\n\t\t\treturn tuples[index].value2();\n\t\t}\n\t\telse{\n\t\t\treturn tuples[index].value2();\n\t\t}\n\t}\n\n\tvoid put (KeyAndValue a, KeyAndValue b) {\n\t\tsize_t index = indexOfKey(a);\n\t\ttuples[index].value2() = b;\n\t\ttuples[index].key2() = a;\n\t\tif(tuples[index].in_use == 1) return;\n\t\t_size ++;\n\t\ttuples[index].in_use = 1;\n\t\tif(2 * _size > tuples.size())\n\t\t\t\t_double_tuples();\n\t}\n\n\tvoid clear() {\n\t\tfor(int i = 0; i < tuples.size() ; i ++) {\n\t\t\ttuples[i].in_use = 0;\t\n\t\t}\n\t\t_size = 0;\n\t}\n\n\tvoid _double_tuples() {\n\t\tvector<element> non_empty_tuples;\n\t\tfor(int i = 0 ; i < tuples.size() ; i ++) {\n\t\t\tif(tuples[i].in_use)\n\t\t\t\tnon_empty_tuples.push_back(tuples[i]);\n\t\t}\n\t\ttuples.resize(tuples.size() * 2);\n\t\tclear();\n\t\tfor (int i = 0 ; i < non_empty_tuples.size() ; i ++)\n\t\t\tput(non_empty_tuples[i].key1(), non_empty_tuples[i].value1());\n\t}\n\n\tsize_t size() { return _size; }\n};",
            1595476838.2167652,
            100,
            "# 答案正确"
        ],
        [
            "A.3 (C++)",
            "马浩宇",
            "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <stdexcept>\nusing namespace std;\n\n#define I(i,n) for (size_t i = 0; i < n; ++ i)\n\nclass NoSuchKeyException {};\n\nsize_t circular_shift(size_t bits, int shift_bits) {\n\tconst int num_bits = 8 * sizeof(size_t);\n\tshift_bits = shift_bits % num_bits;\n\treturn bits << shift_bits | bits >> (num_bits - shift_bits);\n}\n\nsize_t hash_function(const string & key) {\n\tsize_t code = 0;\n\tI(i, key.size())\n\t\tcode ^= circular_shift(key[i], i * 5);\n\treturn code;\n}\n\nstring itos(const int & a) {\n\tstring res;\n\tint temp = a;\n\twhile(temp > 0) {\n\t\tint num = temp % 10;\n\t\tres.push_back(num + '0');\n\t\ttemp = temp / 10;\n\t}\n\tfor(int i = 0 ; i < res.size() / 2 ; i ++){\n\t\tchar a = res[i];\n\t\tres[i] = res[res.size() - i - 1];\n\t\tres[res.size() - i - 1] = a;\n\t}\n\treturn res;\n}\n\ntemplate <typename V>\nclass HT\n{\n\tclass Tuple\n\t{\n\tpublic:\n\t\tint key;\n\t\tV val;\n\t\tbool in_use;\n\n\t\tTuple() : in_use(false) {}\n\t};\n\n\tvector<Tuple> tuples;\n\tsize_t _size;\n\n\tsize_t canonical_index(const int & key) const {\n\t\tstring temp = itos(key);\n\t\tsize_t hash_code = hash_function(temp); // needs hash_function(K)\n\t\treturn hash_code % tuples.size();\n\t}\n\n\t// the returned tuple is either empty or with the same key\n\tsize_t indexOfKey(const int & key) const {\n\t\tsize_t index = canonical_index(key);\n\t\twhile (true) { // will enter a dead loop if there is not empty tuple\n\t\t\tif (! tuples[index].in_use) return index;\n\t\t\tif (tuples[index].key == key) return index;\n\t\t\tindex = (index + 1) % tuples.size();\n\t\t}\n\t}\n\npublic:\n\tHT() : _size(0) {\n\t\ttuples.resize(2);\n\t}\n\n\tbool containsKey(const int & key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\treturn tuples[index].in_use;\n\t}\n\n\tconst V & operator [] (const int & key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples[index].val;\n\t}\n\n\tV & operator [] (const int & key) {\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples[index].val;\n\t}\n\n\tvoid put(const int & key, const V & val) {\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].key = key;\n\t\ttuples[index].val = val;\n\t\tif (tuples[index].in_use) return;\n\t\ttuples[index].in_use = true;\n\t\t++ _size;\n\t\t// make sure empty > size / 2\n\t\tif (2 * _size > tuples.size())\n\t\t\t_double_tuples();\n\t}\n\n\tvoid _double_tuples() {\n\t\tvector<Tuple> non_empty_tuples;\n\t\tI(i, tuples.size())\n\t\t\tif (tuples[i].in_use)\n\t\t\t\tnon_empty_tuples.push_back(tuples[i]);\n\t\tclear();\n\t\ttuples.resize(tuples.size() * 2);\n\t\tI(i, non_empty_tuples.size())\n\t\t\tput(non_empty_tuples[i].key, non_empty_tuples[i].val);\n\t}\n\n\tstatic bool _between(size_t hole, size_t canonical, size_t tuple_index) {\n\t\tif (hole < tuple_index)\n\t\t\treturn canonical > hole && canonical <= tuple_index;\n\t\telse\n\t\t\treturn canonical > hole || canonical <= tuple_index;\n\t}\n\n\tvoid remove(const int & key) { \n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\ttuples[index].in_use = false;\n\t\t-- _size;\n\t\t// if there is a hole between a tuple and its canonical position\n\t\t// move the tuple to the hole\n\t\tsize_t hole = index;\n\t\tsize_t tuple_index = hole;\n\t\twhile (true) {\n\t\t\ttuple_index = (tuple_index + 1) % tuples.size();\n\t\t\tif (! tuples[tuple_index].in_use) return;\n\t\t\tsize_t canonical = canonical_index(tuples[tuple_index].key);\n\t\t\tif (_between(hole, canonical, tuple_index)) continue;\n\t\t\ttuples[hole] = tuples[tuple_index];\n\t\t\thole = tuple_index;\n\t\t\ttuples[hole].in_use = false;\n\t\t}\n\t}\n\n\tsize_t size() const { return _size; }\n\n\tvoid clear() {\n\t\tI(i, tuples.size())\n\t\t\ttuples[i].in_use = false;\n\t\t_size = 0;\n\t}\n\n\ttemplate <typename V2>\n\tfriend ostream & operator << (ostream & out, const HT<V2> & dict);\n\n\ttemplate <typename V2>\n\tfriend istream & operator >> (istream & in, HT<V2> & dict);\n\n\tvoid _inspect() const {\n\t\tI(i, tuples.size())\n\t\t\tif (tuples[i].in_use)\n\t\t\t\tcout << \"#\" << i << \" C\" << canonical_index(tuples[i].key) \n\t\t\t\t\t<< \" \" << tuples[i].key << \" \" << tuples[i].val << endl;\n\t}\n\n\tvector<int> getKeys () {\n\t\tvector<int> keys;\n\t\tfor(int i = 0 ; i < tuples.size() ; i ++) {\n\t\t\tif(tuples[i].in_use == true) {\n\t\t\t\tkeys.push_back(tuples[i].key);\n\t\t\t}\n\t\t}\n\t\treturn keys;\n\t}\n};\n\ntemplate <typename V>\nostream & operator << (ostream & out, const HT<V> & dict) {\n\tout << dict.size() << endl;\n\tI(i, dict.tuples.size())\n\t\tif (dict.tuples[i].in_use)\n\t\t\tout << dict.tuples[i].key << \"\\t\" << dict.tuples[i].val << endl;\n\treturn out;\n}\n\ntemplate <typename V>\nistream & operator >> (istream & in, HT<V> & dict) {\n\tdict.clear();\n\tsize_t size;\n\tin >> size;\n\tI(i, size) {\n\t\tint key;\n\t\tV val;\n\t\tin >> key >> val;\n\t\tdict.put(key, val);\n\t}\n\treturn in;\n}",
            1595471576.2341967,
            100,
            "# 答案正确"
        ]
    ],
    "table_name": "答案"
}