{
    "__update_time__": 1595470470.5565627,
    "field_names": [
        "题目名",
        "用户名",
        "答案",
        "提交时间",
        "分数",
        "评语"
    ],
    "field_types": [
        "text",
        "text",
        "text",
        "time",
        "number",
        "text"
    ],
    "foreign_keys": {},
    "primary_keys": [],
    "rows": [
        [
            "测试1",
            "谢浩林",
            "#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n\tstring a[3] ;\n\tfor(int i = 0 ; i < 3 ; i ++) {\n\t\tcin >> a[i] ;\n\t}\n\tfor(int i = 0 ; i < 3 ; i ++) {\n\t\tcout << a[2-i] << \" \" ;\n\t}\n}",
            1587547538.881466,
            100,
            "# 答案正确"
        ],
        [
            "测试2",
            "谢浩林",
            "#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n\tstring a[10] ;\n\tfor(int i = 0 ; i < 10 ; i ++) {\n\t\tcin >> a[i] ;\n\t}\n\tfor(int i = 0 ; i < 10 ; i ++) {\n\t\tfor(int k = 0 ; k < 9 ; k ++) {\n\t\t\tif(a[k]>a[k+1]) {\n\t\t\t\tstring tmp = a[k] ;\n\t\t\t\ta[k] = a[k+1] ;\n\t\t\t\ta[k+1] = tmp ;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0 ; i < 10 ; i ++) {\n\t\tcout << a[i] << \" \" ;\n\t}\n}\n",
            1587608694.0344384,
            100,
            "# 答案正确"
        ],
        [
            "1.1 (C++)",
            "谢浩林",
            "class Matrix5x5 {\n\tpublic:\n\tdouble mar[5][5] ;\n\tMatrix5x5() {\n\t\tfor(int i = 0 ; i < 5 ; i ++) {\n\t\t\tfor(int j = 0 ; j < 5 ; j ++) {\n\t\t\t\tmar[i][j] = 0 ;\n\t\t\t}\n\t\t}\n\t}\n\tvoid set(int x ,int y ,double value) {\n\t\tmar[x][y] = value ;\n\t}\n\tdouble get(int x , int y) {\n\t\treturn mar[x][y] ;\n\t}\n} ;\n\nMatrix5x5 operator + (Matrix5x5 &x, Matrix5x5 &y) {\n\t\tMatrix5x5 c ;\n\t\tfor(int i = 0 ; i < 5 ; i ++) {\n\t\t\tfor(int j = 0 ; j < 5 ; j ++) {\n\t\t\t\tc.mar[i][j] = x.mar[i][j]+y.mar[i][j] ;\n\t\t\t}\n\t\t}\n    return c;\n}\n\n",
            1587697040.2580686,
            100,
            "# 答案正确"
        ],
        [
            "1.2 (C++)",
            "谢浩林",
            "class School {\n\tpublic :\n\tchar* name ;\n\tint age ;\n\tSchool() {\n\t\tname= new char[10];\n\t\tname[0]='N' ;\n\t\tname[1]='O' ;\n\t\tname[2]='_' ;\n\t\tname[3]='N' ;\n\t\tname[4]='A' ;\n\t\tname[5]='M' ;\n\t\tname[6]='E' ;\n\t\tage = 0 ;\n\t}\n\t~School() {\n\t}\n\tvoid setName(char * n) {\n\t\tname = n ;\n\t}\n\tvoid setAge(int a) {\n\t\tage = a ;\n\t}\n} ;\n\nvoid operator ++ (School & school){\n\t\t++ school.age  ;\n}",
            1588213661.415623,
            100,
            "# 答案正确"
        ],
        [
            "2.1 (C++)",
            "谢浩林",
            "#include <iostream>\nusing namespace std ;\nclass Matrix{\n\tprivate :\n\tint row ;\n\tint col ;\n\tpublic:\n\tMatrix() {\n\t\trow = 0 ;\n\t\tcol = 0 ;\n\t}\n\tMatrix(int row_,int col_) {\n\t\trow = row_ ;\n\t\tcol = col_ ;\n\t}\n\tvoid print() {\n\t\tfor(int i = 0 ; i < this-> row ; i ++) {\n\t\t\tfor(int k = 0 ; k < this -> col ; k ++) {\n\t\t\t\tcout << \"    0\" ;\n\t\t\t}\n\t\t\tcout << endl ;\n\t\t}\n\t}\n\t~Matrix(){}\n};",
            1588827155.2034504,
            100,
            "# 答案正确"
        ],
        [
            "2.2 (C++)",
            "谢浩林",
            "#include <iostream>\nusing namespace std ;\nclass Matrix{\n\tprivate :\n\tint row ;\n\tint col ;\n\tdouble val[1000] ;\n\tpublic:\n\tMatrix() {\n\t\trow = 0 ;\n\t\tcol = 0 ;\n\t\tval[0] = 0 ;\n\t}\n\tMatrix(int row_,int col_,double val_[]) {\n\t\trow = row_ ;\n\t\tcol = col_ ;\n\t\tfor(int i = 0 ; i < this-> row ; i ++) {\n\t\t\tfor(int k = 0 ; k < this -> col ; k ++) {\n\t\t\t\tval[i*col+k] = val_[i*col+k] ;\n\t\t\t}\n\t\t}\n\t}\n\tvoid print() {\n\t\tfor(int i = 0 ; i < this-> row ; i ++) {\n\t\t\tfor(int k = 0 ; k < this -> col ; k ++) {\n\t\t\t\tif(val[i*col+k]<10)cout << \"    \"<<val[i*col+k] ;\n\t\t\t\telse cout << \"   \"<<val[i*col+k] ;\n\t\t\t}\n\t\t\tcout << endl ;\n\t\t}\n\t}\n\t~Matrix(){}\n};",
            1588827595.9451768,
            100,
            "# 答案正确"
        ],
        [
            "2.3 (C++)",
            "谢浩林",
            "#include <iostream>\nusing namespace std ;\nclass Matrix{\n\tprivate :\n\tint row ;\n\tint col ;\n\tdouble val[100][100] ;\n\tpublic:\n\tMatrix() {\n\t\trow = 0 ;\n\t\tcol = 0 ;\n\t\tval[0][0] = 0 ;\n\t}\n\tMatrix(int row_,int col_,double val_[]) {\n\t\trow = row_ ;\n\t\tcol = col_ ;\n\t\tfor(int i = 0 ; i < this-> row ; i ++) {\n\t\t\tfor(int k = 0 ; k < this -> col ; k ++) {\n\t\t\t\tval[k][i] = val_[i*col+k] ;\n\t\t\t}\n\t\t}\n\t}\n\tMatrix(const Matrix &m2) {\n\t\tthis->row = m2.row ;\n\t\tthis->col = m2.col ;\n\t\tfor(int i = 0 ; i < this-> row ; i ++) {\n\t\t\tfor(int k = 0 ; k < this -> col ; k ++) {\n\t\t\t\tthis->val[k][i] = m2.val[k][i] ;\n\t\t\t}\n\t\t}\n\t}\n\tvoid print() {\n\t\tfor(int i = 0 ; i < this-> row ; i ++) {\n\t\t\tfor(int k = 0 ; k < this -> col ; k ++) {\n\t\t\t\tcout<< \"    \"<<val[k][i] ;\n\t\t\t}\n\t\t\tcout << endl ;\n\t\t}\n\t}\n\t~Matrix(){}\n};",
            1588827856.6843815,
            100,
            "# 答案正确"
        ],
        [
            "2.5 (C++)",
            "谢浩林",
            "#include <iostream>\nusing namespace std ;\nclass Matrix{\n\tprivate :\n\tint row ;\n\tint col ;\n\tdouble val[100][100] ;\n\tpublic:\n\tMatrix() {\n\t\trow = 0 ;\n\t\tcol = 0 ;\n\t\tval[0][0] = 0 ;\n\t}\n\tMatrix(int row_,int col_) {\n\t\trow = row_ ;\n\t\tcol = col_ ;\n\t\tfor(int i = 0 ; i < this-> row ; i ++) {\n\t\t\tfor(int k = 0 ; k < this -> col ; k ++) {\n\t\t\t\tval[k][i] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tMatrix(int row_,int col_,double val_[]) {\n\t\trow = row_ ;\n\t\tcol = col_ ;\n\t\tfor(int i = 0 ; i < this-> row ; i ++) {\n\t\t\tfor(int k = 0 ; k < this -> col ; k ++) {\n\t\t\t\tval[k][i] = val_[i*col+k] ;\n\t\t\t}\n\t\t}\n\t}\n\tMatrix(const Matrix &m2) {\n\t\tthis->row = m2.row ;\n\t\tthis->col = m2.col ;\n\t\tfor(int i = 0 ; i < this-> row ; i ++) {\n\t\t\tfor(int k = 0 ; k < this -> col ; k ++) {\n\t\t\t\tthis->val[k][i] = m2.val[k][i] ;\n\t\t\t}\n\t\t}\n\t}\n\tMatrix getRow(int row) {\n\t\tMatrix m3(1,this->col);\n\t\tfor(int i = 0 ; i < this -> col ; i ++) {\n\t\t\tm3.val[i][0]=val[i][row-1] ;\n\t\t}\n\t\treturn m3 ;\n\t}\n\tMatrix getColumn(int col) {\n\t\tMatrix m3(this->row,1);\n\t\tfor(int i = 0 ; i < this -> row ; i ++) {\n\t\t\tm3.val[0][i]=val[col-1][i] ;\n\t\t}\n\t\treturn m3 ;\n\t}\n\tvoid print() {\n\t\tfor(int i = 0 ; i < this-> row ; i ++) {\n\t\t\tfor(int k = 0 ; k < this -> col ; k ++) {\n\t\t\t\tcout<< \"    \"<<val[k][i] ;\n\t\t\t}\n\t\t\tcout << endl ;\n\t\t}\n\t}\n\t~Matrix(){}\n};",
            1588828745.9549289,
            100,
            "# 答案正确"
        ],
        [
            "2.6 (C++)",
            "谢浩林",
            "#include <iostream>\nusing namespace std ;\nclass Matrix{\n\tprivate :\n\tint row ;\n\tint col ;\n\tdouble val[100][100] ;\n\tpublic:\n\tMatrix() {\n\t\trow = 0 ;\n\t\tcol = 0 ;\n\t\tval[0][0] = 0 ;\n\t}\n\tMatrix(int row_,int col_) {\n\t\trow = row_ ;\n\t\tcol = col_ ;\n\t\tfor(int i = 0 ; i < this-> row ; i ++) {\n\t\t\tfor(int k = 0 ; k < this -> col ; k ++) {\n\t\t\t\tval[k][i] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tMatrix(int row_,int col_,double val_[]) {\n\t\trow = row_ ;\n\t\tcol = col_ ;\n\t\tfor(int i = 0 ; i < this-> row ; i ++) {\n\t\t\tfor(int k = 0 ; k < this -> col ; k ++) {\n\t\t\t\tval[k][i] = val_[i*col+k] ;\n\t\t\t}\n\t\t}\n\t}\n\tMatrix(const Matrix &m2) {\n\t\tthis->row = m2.row ;\n\t\tthis->col = m2.col ;\n\t\tfor(int i = 0 ; i < this-> row ; i ++) {\n\t\t\tfor(int k = 0 ; k < this -> col ; k ++) {\n\t\t\t\tthis->val[k][i] = m2.val[k][i] ;\n\t\t\t}\n\t\t}\n\t}\n\tMatrix concatenateRows(const Matrix & m2) {\n\tMatrix m3(row*2,col) ;\n\tfor(int i = 0 ; i < row ; i ++ ) {\n\t\tfor(int k = 0 ; k < col ; k ++) {\n\t\t\tm3.val[k][i] = this->val[k][i] ;\n\t\t}\n\t}\n\tfor(int i = 0 ; i < row ; i ++ ) {\n\t\tfor(int k = 0 ; k < col ; k ++) {\n\t\t\tm3.val[k][i+row] = m2.val[k][i] ;\n\t\t}\n\t}\n\treturn m3 ;\n}\n\n\tMatrix concatenateColumns(const Matrix & m2) {\n\tMatrix m3(row,col*2) ;\n\tfor(int i = 0 ; i < row ; i ++ ) {\n\t\tfor(int k = 0 ; k < col ; k ++) {\n\t\t\tm3.val[k][i] = this->val[k][i] ;\n\t\t}\n\t}\n\tfor(int i = 0 ; i < row ; i ++ ) {\n\t\tfor(int k = 0 ; k < col ; k ++) {\n\t\t\tm3.val[k+col][i] = m2.val[k][i] ;\n\t\t}\n\t}\n\treturn m3 ;\n}\n\tvoid print() {\n\t\tfor(int i = 0 ; i < this-> row ; i ++) {\n\t\t\tfor(int k = 0 ; k < this -> col ; k ++) {\n\t\t\t\tcout<< \"    \"<<val[k][i] ;\n\t\t\t}\n\t\t\tcout << endl ;\n\t\t}\n\t}\n\t~Matrix(){}\n};",
            1588829815.6485918,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/08",
            "谢浩林",
            "#include <iostream>\nusing namespace std;\ndouble & Tensor_get(int di, const int size[], double data[], int x0, int x1, int x2, int x3) {\n\tint all[] = {1,1,1,1} ;\n\tfor(int i = 0 ; i < di ; i ++) {\n\t\tfor(int k = i + 1 ; k < di ; k ++) {\n\t\t\tall[i] *= size[k] ;\n\t\t}\n\t}\n\tint count = 0 ;\n\tint wei[] = {x0,x1,x2,x3} ;\n\tfor(int i = 0 ; i < di ; i ++) {\n\t\tcount += wei[i]*all[i] ;\n\t}\n\treturn data[count] ;\n}",
            1588907623.9641654,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/14",
            "谢浩林",
            "#include <iostream>\nusing namespace std ;\nvoid Tensor_print(int di, const int size[], const double data[]) {\n\tif(di == 1) {\n\t\tcout <<\"Tensor of \"<<size[0]<<endl ;\n\t\tfor(int i = 0 ; i < size[0] ; i ++) cout<<data[i]<<endl ;\n\t}\n\tif(di == 2) {\n\t\tcout <<\"Tensor of \"<<size[0]<<\"x\"<<size[1]<<endl ;\n\t\tfor(int i = 0 ; i < size[0] ;i ++) {\n\t\t\tfor(int k = 0 ; k < size[1] ; k ++ ) {\n\t\t\t\tcout <<\"    \"<< data[size[1]*i+k] ;\n\t\t\t}\n\t\t\tcout << endl ;\n\t\t}\n\t}\n\tif(di == 3) {\n\t\tcout <<\"Tensor of \"<<size[0]<<\"x\"<<size[1]<<\"x\"<<size[2]<<endl ;\n\t\tfor(int z = 0 ; z < size[0] ; z ++) {\n\t\t\tcout << \"data[\"<<z<<\"]\"<<endl ;\n\t\t\tfor(int i = 0 ; i < size[1] ;i ++) {\n\t\t\tfor(int k = 0 ; k < size[2] ; k ++ ) {\n\t\t\t\tcout <<\"    \"<< data[size[2]*i+k] ;\n\t\t\t}\n\t\t\tcout << endl ;\n\t\t}\n\t\t}\n\t}\n\tif(di == 4) {\n\t\tcout <<\"Tensor of \"<<size[0]<<\"x\"<<size[1]<<\"x\"<<size[2]<<\"x\"<<size[3]<<endl ;\n\t\tfor(int y = 0 ; y < size[0];y ++) {\n\t\tfor(int z = 0 ; z < size[1] ; z ++) {\n\t\t\tcout << \"data[\"<<y<<\"][\"<<z<<\"]\"<<endl ;\n\t\t\tfor(int i = 0 ; i < size[2] ;i ++) {\n\t\t\tfor(int k = 0 ; k < size[3] ; k ++ ) {\n\t\t\t\tcout <<\"    \"<< data[size[3]*i+k] ;\n\t\t\t}\n\t\t\tcout << endl ;\n\t\t}\n\t\t}\n\t}\n\t}\t\n}",
            1589422432.982619,
            100,
            "# 答案正确"
        ],
        [
            "2.4 (C++)",
            "谢浩林",
            "#include <iostream>\nusing namespace std;\nclass Matrix {\n\tprivate:\n\tint row ;\n\tint col ;\n\tdouble *val;\n\tpublic:\n\tMatrix(int row_ = 0 ,int col_= 0){\n\t\tthis->row = row_ ;\n\t\tthis->col = col_ ;\n\t\tthis->val = new double[col*row+1] ;\n\t\tfor(int i = 0 ; i < row ;i ++) {\n\t\t\tfor(int k = 0 ; k < col ; k ++) {\n\t\t\t\tthis->val[i*col+k] =0 ;\n\t\t\t}\n\t\t}\n\t}\n\tMatrix(int row_, int col_, double val_[]) {\n\t\tthis->row = row_ ;\n\t\tthis->col = col_ ;\n\t\tthis->val = new double[col*row+1] ;\n\t\tfor(int i = 0 ; i < row ;i ++) {\n\t\t\tfor(int k = 0 ; k < col ; k ++) {\n\t\t\t\tthis->val[i*col+k] =val_[i*col+k] ;\n\t\t\t}\n\t\t}\n\t}\n\t~Matrix(){\n\t}\n\tvoid print() {\n\t\tfor(int i = 0 ; i < row ;i ++) {\n\t\t\tfor(int k = 0 ; k < col ; k ++) {\n\t\t\t\tcout << \"    \"<<val[i*col+k] ;\n\t\t\t}\n\t\t\tcout << endl ;\n\t\t}\n\t}\n\tvoid set(int r, int c, double val_) {\n\t\tval[(r-1)*col+c-1] = val_ ;\n\t}\n\tMatrix &operator =(Matrix m1) {\n\t\tthis->row =m1.row;\n\t\tthis->col =m1.col;\n\t\tthis->val = new double[col*row+1] ;\n\t\tfor(int i = 0 ; i < row ;i ++) {\n\t\t\tfor(int k = 0 ; k < col ; k ++) {\n\t\t\t\tthis->val[i*col+k] =m1.val[i*col+k] ;\n\t\t\t}\n\t\t}\n\t}\n} ;\n\n",
            1589530098.2335777,
            100,
            "\n=================================================================\n==2493==ERROR: LeakSanitizer: detected memory leaks\n\nDirect leak of 224 byte(s) in 1 object(s) allocated from:\n    #0 0x7f73f4cd36b2 in operator new[](unsigned long) (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x996b2)\n    #1 0x55a9f9af189d in Matrix::operator=(Matrix) /home/谢浩林/source.cpp:45\n    #2 0x55a9f9af189d in main /home/谢浩林/main.cpp:18\n    #3 0x7f73f450e82f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2082f)\n\nDirect leak of 224 byte(s) in 1 object(s) allocated from:\n    #0 0x7f73f4cd36b2 in operator new[](unsigned long) (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x996b2)\n    #1 0x55a9f9af147e in Matrix::Matrix(int, int, double*) /home/谢浩林/source.cpp:22\n    #2 0x55a9f9af147e in main /home/谢浩林/main.cpp:11\n    #3 0x7f73f450e82f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2082f)\n\nDirect leak of 8 byte(s) in 1 object(s) allocated from:\n    #0 0x7f73f4cd36b2 in operator new[](unsigned long) (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x996b2)\n    #1 0x55a9f9af1905 in Matrix::Matrix(int, int) /home/谢浩林/source.cpp:12\n    #2 0x55a9f9af1905 in main /home/谢浩林/main.cpp:17\n    #3 0x7f73f450e82f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2082f)\n\nSUMMARY: AddressSanitizer: 456 byte(s) leaked in 3 allocation(s).\n"
        ],
        [
            "2.7 (C++)",
            "谢浩林",
            "#include <iostream>\nusing namespace std;\nclass Matrix\n{\nprivate:\n    int row ;\n    int col ;\n    double val[1000];\npublic:\n    Matrix(int row_ = 0,int col_= 0)\n    {\n        this->row = row_ ;\n        this->col = col_ ;\n        for(int i = 0 ; i < row ; i ++)\n        {\n            for(int k = 0 ; k < col ; k ++)\n            {\n                this->val[i*col+k] =0 ;\n            }\n        }\n    }\n    Matrix(int row_, int col_, double val_[])\n    {\n        this->row = row_ ;\n        this->col = col_ ;\n        for(int i = 0 ; i < row ; i ++)\n        {\n            for(int k = 0 ; k < col ; k ++)\n            {\n                this->val[i*col+k] =val_[i*col+k] ;\n            }\n        }\n    }\n    ~Matrix() {\t}\n    void print()\n    {\n        for(int i = 0 ; i < row ; i ++)\n        {\n            for(int k = 0 ; k < col ; k ++)\n            {\n                cout << \"    \"<<val[i*col+k] ;\n            }\n            cout << endl ;\n        }\n    }\n    void set(int r, int c, double val_)\n    {\n        val[(r-1)*col+c-1] = val_ ;\n    }\n    Matrix &operator =(Matrix m1)\n    {\n        this->row =m1.row;\n        this->col =m1.col;\n        for(int i = 0 ; i < row ; i ++)\n        {\n            for(int k = 0 ; k < col ; k ++)\n            {\n                this->val[i*col+k] =m1.val[i*col+k] ;\n            }\n        }\n    }\n    Matrix reshape(int row_, int col_){\n        double t[1000] ;\n        for(int i = 0 ;  i < row ;i ++) {\n            for(int k = 0 ;  k< col ; k ++) {\n                t[k*row+i] =val[i*col+k] ;\n            }\n        }\n        double t2[1000] ;\n        int z = 0 ;\n        for(int k = 0 ; k < col_ ; k ++) {\n            for(int i = 0 ; i < row_ ; i ++) {\n                t2[k+i*col_] = t[z++] ;\n            }\n        }\n        Matrix m1(row_, col_, t2) ;\n        return m1 ;\n    }\n} ;\n\n",
            1589533117.1913173,
            100,
            "# 答案正确"
        ],
        [
            "2.8 (C++)",
            "谢浩林",
            "#include <iostream>\nusing namespace std;\nclass Matrix\n{\nprivate:\n    int row ;\n    int col ;\n    double val[1000];\npublic:\n    Matrix(int row_ = 0,int col_= 0)\n    {\n        this->row = row_ ;\n        this->col = col_ ;\n        for(int i = 0 ; i < row ; i ++)\n        {\n            for(int k = 0 ; k < col ; k ++)\n            {\n                this->val[i*col+k] =0 ;\n            }\n        }\n    }\n    Matrix(int row_, int col_, double val_[])\n    {\n        this->row = row_ ;\n        this->col = col_ ;\n        for(int i = 0 ; i < row ; i ++)\n        {\n            for(int k = 0 ; k < col ; k ++)\n            {\n                this->val[i*col+k] =val_[i*col+k] ;\n            }\n        }\n    }\n    ~Matrix() {\t}\n    void print()\n    {\n        for(int i = 0 ; i < row ; i ++)\n        {\n            for(int k = 0 ; k < col ; k ++)\n            {\n                cout << \"    \"<<val[i*col+k] ;\n            }\n            cout << endl ;\n        }\n    }\n    void set(int r, int c, double val_)\n    {\n        val[(r-1)*col+c-1] = val_ ;\n    }\n    Matrix &operator =(Matrix m1)\n    {\n        this->row =m1.row;\n        this->col =m1.col;\n        for(int i = 0 ; i < row ; i ++)\n        {\n            for(int k = 0 ; k < col ; k ++)\n            {\n                this->val[i*col+k] =m1.val[i*col+k] ;\n            }\n        }\n    }\n    Matrix transpose() {\n        double t[1000] ;\n        for(int i = 0 ;  i < row ;i ++) {\n            for(int k = 0 ;  k< col ; k ++) {\n                t[k*row+i] =val[i*col+k] ;\n            }\n        }\n        Matrix m1(col, row, t) ;\n        return m1;\n    }\n} ;",
            1589533324.827272,
            100,
            "# 答案正确"
        ],
        [
            "2.10 (C++)",
            "谢浩林",
            "#include <iostream>\nusing namespace std;\nclass Matrix\n{\nprivate:\n    int row ;\n    int col ;\n    double val[1000];\npublic:\n    Matrix(int row_ = 0,int col_= 0)\n    {\n        this->row = row_ ;\n        this->col = col_ ;\n        for(int i = 0 ; i < row ; i ++)\n        {\n            for(int k = 0 ; k < col ; k ++)\n            {\n                this->val[i*col+k] =0 ;\n            }\n        }\n    }\n    Matrix(int row_, int col_, double val_[])\n    {\n        this->row = row_ ;\n        this->col = col_ ;\n        for(int i = 0 ; i < row ; i ++)\n        {\n            for(int k = 0 ; k < col ; k ++)\n            {\n                this->val[i*col+k] =val_[i*col+k] ;\n            }\n        }\n    }\n    ~Matrix() {\t}\n    void print()\n    {\n        for(int i = 0 ; i < row ; i ++)\n        {\n            for(int k = 0 ; k < col ; k ++)\n            {\n                cout << \"    \"<<val[i*col+k] ;\n            }\n            cout << endl ;\n        }\n    }\n    void set(int r, int c, double val_)\n    {\n        val[(r-1)*col+c-1] = val_ ;\n    }\n    Matrix &operator =(Matrix m1)\n    {\n        this->row =m1.row;\n        this->col =m1.col;\n        for(int i = 0 ; i < row ; i ++)\n        {\n            for(int k = 0 ; k < col ; k ++)\n            {\n                this->val[i*col+k] =m1.val[i*col+k] ;\n            }\n        }\n    }\n    Matrix operator * (const Matrix & m2) {\n        double t[1000] ;\n         for(int i = 0 ; i < row ; i ++) {\n            for(int k = 0 ; k < m2.col ; k ++) {\n                t[i*m2.col+k] = 0 ;\n            }\n        }\n        for(int i = 0 ; i < row ; i ++) {\n            for(int k = 0 ; k < m2.col ; k ++) {\n                for (int z = 0 ; z < col ; z ++) {\n                    t[i*m2.col+k] += val[i*col+z] * m2.val[k+z*m2.col] ;\n                }\n            }\n        }\n        Matrix m1(row,m2.col,t) ;\n        return m1 ;\n    }\n    Matrix operator * (double value) {\n        double t[1000] ;\n        for(int i = 0 ; i < row ; i ++)\n        {\n            for(int k = 0 ; k < col ; k ++)\n            {\n                t[i*col+k] =val[i*col+k]*value ;\n            }\n        }\n        Matrix m1(row,col,t) ;\n        return m1 ;\n    }\n} ;\n",
            1589534492.941885,
            100,
            "# 答案正确"
        ],
        [
            "2.11 (C++)",
            "谢浩林",
            "#include <iostream>\nusing namespace std;\nclass Matrix\n{\nprivate:\n    int row ;\n    int col ;\n    double val[1000];\npublic:\n    Matrix(int row_ = 0,int col_= 0)\n    {\n        this->row = row_ ;\n        this->col = col_ ;\n        for(int i = 0 ; i < row ; i ++)\n        {\n            for(int k = 0 ; k < col ; k ++)\n            {\n                this->val[i*col+k] =0 ;\n            }\n        }\n    }\n    Matrix(int row_, int col_, double val_[])\n    {\n        this->row = row_ ;\n        this->col = col_ ;\n        for(int i = 0 ; i < row ; i ++)\n        {\n            for(int k = 0 ; k < col ; k ++)\n            {\n                this->val[i*col+k] =val_[i*col+k] ;\n            }\n        }\n    }\n    ~Matrix() {\t}\n    void print()\n    {\n        for(int i = 0 ; i < row ; i ++)\n        {\n            for(int k = 0 ; k < col ; k ++)\n            {\n                cout << \"    \"<<val[i*col+k] ;\n            }\n            cout << endl ;\n        }\n    }\n    void set(int r, int c, double val_)\n    {\n        val[(r-1)*col+c-1] = val_ ;\n    }\n    Matrix &operator =(Matrix m1)\n    {\n        this->row =m1.row;\n        this->col =m1.col;\n        for(int i = 0 ; i < row ; i ++)\n        {\n            for(int k = 0 ; k < col ; k ++)\n            {\n                this->val[i*col+k] =m1.val[i*col+k] ;\n            }\n        }\n    }\n    Matrix max() {\n        if(row!=1) {\n        double tmp = 0 ;\n        for(int k = 0 ;  k < col ;  k ++)\n        {\n            for(int i = 0 ;i < row ; i ++)\n            {\n                for(int j = 0 ; j < row - 1 ; j ++) {\n                    if(val[j*col+k]<val[(j+1)*col+k]) {\n                       tmp = val[(j+1)*col+k] ;\n                       val[(j+1)*col+k] = val[j*col+k] ;\n                       val[j*col+k] = tmp ;\n                    }\n                }\n            }\n        }\n        double t2[30] ;\n        for(int k = 0 ; k < col ; k ++) {\n            t2[k] = val[k] ;\n        }\n        Matrix m1(1,col,t2) ;\n        return m1 ;\n        }\n        else {\n            double coun = 0 ;\n            for(int i = 0; i < col ; i ++) {\n                if(val[i] > coun) {\n                    coun = val[i] ;\n                }\n            }\n            double t2[1] ;\n            t2[0] = coun ;\n            Matrix m1(1,1,t2) ;\n            return m1 ;\n         }\n    }\n    Matrix min() ;\n    Matrix sum() ;\n} ;\n\nMatrix Matrix::sum() {\n    if(row!=1) {\n        double t[30] ;\n        for(int i = 0 ; i < col ; i ++) t[i] = 0 ;\n        for(int i = 0 ; i < row ; i ++)\n        {\n            for(int k = 0 ; k < col ; k ++)\n            {\n                t[k]+= val[i*col+k] ;\n            }\n        }\n        Matrix m1(1,col,t) ;\n        return m1 ;\n    }\n    else {\n        double t[1] = {0} ;\n        for(int i = 0 ; i < col ; i ++) {\n            t[0] += val[i] ;\n        }\n        Matrix m1(1,1,t) ;\n        return m1 ;\n    }\n}\n\nMatrix Matrix::min() {\n        if(row!=1) {\n        double tmp = 0 ;\n        for(int k = 0 ;  k < col ;  k ++)\n        {\n            for(int i = 0 ;i < row ; i ++)\n            {\n                for(int j = 0 ; j < row - 1 ; j ++) {\n                    if(val[j*col+k]>val[(j+1)*col+k]) {\n                       tmp = val[(j+1)*col+k] ;\n                       val[(j+1)*col+k] = val[j*col+k] ;\n                       val[j*col+k] = tmp ;\n                    }\n                }\n            }\n        }\n        double t2[30] ;\n        for(int k = 0 ; k < col ; k ++) {\n            t2[k] = val[k] ;\n        }\n        Matrix m1(1,col,t2) ;\n        return m1 ;\n        }\n        else {\n            double coun =  100000 ;\n            for(int i = 0; i < col ; i ++) {\n                if(val[i] < coun) {\n                    coun = val[i] ;\n                }\n            }\n            double t2[1] ;\n            t2[0] = coun ;\n            Matrix m1(1,1,t2) ;\n            return m1 ;\n         }\n    }\n\n",
            1589536832.573928,
            100,
            "# 答案正确"
        ],
        [
            "2.12 (C++)",
            "谢浩林",
            "#include <iostream>\n#include <cmath>\nusing namespace std;\nclass Matrix\n{\nprivate:\n    int row ;\n    int col ;\n    double val[1000];\npublic:\n    Matrix(int row_ = 0,int col_= 0)\n    {\n        this->row = row_ ;\n        this->col = col_ ;\n        for(int i = 0 ; i < row ; i ++)\n        {\n            for(int k = 0 ; k < col ; k ++)\n            {\n                this->val[i*col+k] =0 ;\n            }\n        }\n    }\n    Matrix(int row_, int col_, double val_[])\n    {\n        this->row = row_ ;\n        this->col = col_ ;\n        for(int i = 0 ; i < row ; i ++)\n        {\n            for(int k = 0 ; k < col ; k ++)\n            {\n                this->val[i*col+k] =val_[i*col+k] ;\n            }\n        }\n    }\n    ~Matrix() {\t}\n    void print()\n    {\n        for(int i = 0 ; i < row ; i ++)\n        {\n            for(int k = 0 ; k < col ; k ++)\n            {\n                cout << \"    \"<<val[i*col+k] ;\n            }\n            cout << endl ;\n        }\n    }\n    void set(int r, int c, double val_)\n    {\n        val[(r-1)*col+c-1] = val_ ;\n    }\n    Matrix &operator =(Matrix m1)\n    {\n        this->row =m1.row;\n        this->col =m1.col;\n        for(int i = 0 ; i < row ; i ++)\n        {\n            for(int k = 0 ; k < col ; k ++)\n            {\n                this->val[i*col+k] =m1.val[i*col+k] ;\n            }\n        }\n    }\n    Matrix exp() ;\n    Matrix log() ;\n    Matrix abs() ;\n    Matrix pow(double ex) ;\n} ;\n\n\nMatrix Matrix::pow(double ex)  {\n    double t2[1000] ;\n    for(int i = 0 ; i < col*row ; i ++) {\n        t2[i] = std::pow(val[i],ex) ;\n    }\n    Matrix m1(row,col,t2) ;\n    return m1 ;\n}\n\nMatrix Matrix::exp() {\n    double t2[1000] ;\n    for(int i = 0 ; i < col*row ; i ++) {\n        t2[i] = std::exp(val[i]) ;\n    }\n    Matrix m1(row,col,t2) ;\n    return m1 ;\n}\nMatrix Matrix::log()  {\n    double t2[1000] ;\n    for(int i = 0 ; i < col*row ; i ++) {\n        t2[i] = std::log(val[i]) ;\n    }\n    Matrix m1(row,col,t2) ;\n    return m1 ;\n}\nMatrix Matrix::abs() {\n    double t2[1000] ;\n    for(int i = 0 ; i < col*row ; i ++) {\n        t2[i] = std::abs(val[i]) ;\n    }\n    Matrix m1(row,col,t2) ;\n    return m1 ;\n}\n\n",
            1589538796.4620516,
            100,
            "# 答案正确"
        ],
        [
            "2.9 (C++)",
            "谢浩林",
            "#include <iostream>\nusing namespace std;\nclass Matrix\n{\nprivate:\n    int row ;\n    int col ;\n    double val[1000];\npublic:\n    Matrix(int row_ = 0,int col_= 0)\n    {\n        this->row = row_ ;\n        this->col = col_ ;\n        for(int i = 0 ; i < row ; i ++)\n        {\n            for(int k = 0 ; k < col ; k ++)\n            {\n                this->val[i*col+k] =0 ;\n            }\n        }\n    }\n    Matrix(int row_, int col_, double val_[])\n    {\n        this->row = row_ ;\n        this->col = col_ ;\n        for(int i = 0 ; i < row ; i ++)\n        {\n            for(int k = 0 ; k < col ; k ++)\n            {\n                this->val[i*col+k] =val_[i*col+k] ;\n            }\n        }\n    }\n    ~Matrix() {\t}\n    void print()\n    {\n        for(int i = 0 ; i < row ; i ++)\n        {\n            for(int k = 0 ; k < col ; k ++)\n            {\n                cout << \"    \"<<val[i*col+k] ;\n            }\n            cout << endl ;\n        }\n    }\n    void set(int r, int c, double val_)\n    {\n        val[(r-1)*col+c-1] = val_ ;\n    }\n    Matrix &operator =(Matrix m1)\n    {\n        this->row =m1.row;\n        this->col =m1.col;\n        for(int i = 0 ; i < row ; i ++)\n        {\n            for(int k = 0 ; k < col ; k ++)\n            {\n                this->val[i*col+k] =m1.val[i*col+k] ;\n            }\n        }\n    }\n\tMatrix operator +(Matrix m1) {\n\t\tdouble t[1000] ;\n\t\tfor(int i = 0 ; i < row ; i ++)\n        {\n            for(int k = 0 ; k < col ; k ++)\n            {\n                t[i*col+k]=this->val[i*col+k]+m1.val[i*col+k] ;\n            }\n        }\n\t\tMatrix m2(row,col,t) ;\n\t\treturn m2;\n\t}\n\tMatrix operator +(double val_) {\n\t\tdouble t[1000] ;\n\t\tfor(int i = 0 ; i < row ; i ++)\n        {\n            for(int k = 0 ; k < col ; k ++)\n            {\n                t[i*col+k]=this->val[i*col+k]+val_ ;\n            }\n        }\n\t\tMatrix m1(row,col,t) ;\n\t\treturn m1;\n\t}\n\tMatrix operator -(Matrix m1) {\n\t\tdouble t[1000] ;\n\t\tfor(int i = 0 ; i < row ; i ++)\n        {\n            for(int k = 0 ; k < col ; k ++)\n            {\n                t[i*col+k]=this->val[i*col+k]-m1.val[i*col+k] ;\n            }\n        }\n\t\tMatrix m2(row,col,t) ;\n\t\treturn m2;\n\t}\n\tMatrix operator -(double val_) {\n\t\tdouble t[1000] ;\n\t\tfor(int i = 0 ; i < row ; i ++)\n        {\n            for(int k = 0 ; k < col ; k ++)\n            {\n                t[i*col+k]=this->val[i*col+k]-val_ ;\n            }\n        }\n\t\tMatrix m1(row,col,t) ;\n\t\treturn m1;\n\t}\n} ;",
            1590026874.7411718,
            100,
            "# 答案正确"
        ],
        [
            "6.1 (C++)",
            "谢浩林",
            "#include <iostream>\n#include <string>\n#include <cstring>\nusing namespace std;\n\ntemplate <typename T>\nclass Matrix\n{\nprivate:\n    int row ;\n    int col ;\n    T *val;\npublic:\n    Matrix(int row_ = 0,int col_= 0)\n    {\n        this->row = row_ ;\n        this->col = col_ ;\n\t\tthis -> val = new T[row*col] ;\n        memset(val,0,row*col*sizeof(T)) ;\n    }\n    Matrix(int row_, int col_, const T val_[])\n    {\n        this->row = row_ ;\n        this->col = col_ ;\n        this -> val = new T[row*col] ;\n        for(int i = 0 ; i < row ; i ++)\n        {\n            for(int k = 0 ; k < col ; k ++)\n            {\n                this->val[i*col+k] =val_[i*col+k] ;\n            }\n        }\n    }\n    ~Matrix() {\n\t\tdelete[] val ;\n    }\n    void print()\n    {\n        for(int i = 0 ; i < row ; i ++)\n        {\n            for(int k = 0 ; k < col ; k ++)\n            {\n                cout << \"    \"<<val[i*col+k] ;\n            }\n            cout << endl ;\n        }\n    }\n    Matrix &operator =(const Matrix &m2)\n    {\n\t\tdelete[]val ;                       //we have to delete old one and new a new one\n        this->row =m2.row;\n        this->col =m2.col;\n\t\tthis -> val = new T[row*col] ;\n        for(int i = 0 ; i < row ; i ++)\n        {\n            for(int k = 0 ; k < col ; k ++)\n            {\n                this->val[i*col+k] =m2.val[i*col+k] ;\n            }\n        }\n\t\treturn *this ;\n    }\n\tMatrix (Matrix &m2) {                    //if we dont have this m2->m3,is one thing\n\t\tthis->row =m2.row;\n     \tthis->col =m2.col;\n\t\tval= new T[row*col] ;\n        for(int i = 0 ; i < row ; i ++)\n        {\n            for(int k = 0 ; k < col ; k ++)\n            {\n                val[i*col+k] =m2.val[i*col+k] ;\n            }\n        }\n\t}\n    T &get(int x, int y) {\n        return this->val[(y-1)*col+x-1] ;\n    }\n} ;",
            1590636425.1925871,
            100,
            "# 答案正确"
        ],
        [
            "6.3 (C++)",
            "谢浩林",
            "#include <iostream>\nusing namespace std ;\n#include <string>\n#include <cstring>\n#include <vector>\n\ntemplate <typename T>\nclass Matrix {\nprivate:\n    int row ;\n    int col ;\n    vector <T> val ;\npublic:\n    Matrix(int row_ = 1,int col_= 1) {\n        this->row = row_ ;\n        this->col = col_ ;\n        for(int i =0 ; i < row*col; i++) val.push_back(0) ;\n    }\n    Matrix(int row_, int col_, const vector<T> val_) {\n        this->row = row_ ;\n        this->col = col_ ;\n        for(int i = 0 ; i < row ; i ++) {\n            for(int k = 0 ; k < col ; k ++) {\n                val.push_back(val_[i*col+k]) ;\n            }\n        }\n    }\n    ~Matrix() {\n    }\n    void print() {\n        for(int i = 0 ; i < row ; i ++) {\n            for(int k = 0 ; k < col ; k ++) {\n                cout << \"    \"<<val[i*col+k] ;\n            }\n            cout << endl ;\n        }\n    }\n    Matrix &operator =(const Matrix &m2) {\n        val.clear() ;\n        this->row =m2.row;\n        this->col =m2.col;\n        for(int i = 0 ; i < row ; i ++) {\n            for(int k = 0 ; k < col ; k ++) {\n                val.push_back(m2.val[i*col+k]) ;\n            }\n        }\n        return *this ;\n    }\n    Matrix (Matrix &m2) {\n        this->row =m2.row;\n        this->col =m2.col;\n        for(int i = 0 ; i < row ; i ++) {\n            for(int k = 0 ; k < col ; k ++) {\n                val.push_back(m2.val[i*col+k]) ;\n            }\n        }\n    }\n    T &get(int x, int y) {\n        return this->val[(y-1)*col+x-1] ;\n    }\n    Matrix getColumn(int x) {\n        int r = row;\n        int c = 1 ;\n        vector<T> t;\n        for(int i = 0 ; i < row ; i ++) {\n            t.push_back( val[i*col+x-1]) ;\n        }\n        Matrix m1(r,c,t) ;\n        return m1 ;\n    }\n    Matrix getRow(int x) {\n        int r = 1;\n        int c = col ;\n        vector<T> t;\n        for(int i = 0 ; i < row ; i ++) {\n            t.push_back( val[(x-1)*row+i]) ;\n        }\n        Matrix m1(r,c,t) ;\n        return m1 ;\n    }\n    Matrix concatenateRows(Matrix m2) {\n        int r = row+m2.row;\n        int c = col ;\n        vector<T> t;\n        for(int i = 0 ; i < row ; i ++) {\n            for(int k = 0 ; k < col ; k ++) {\n                t.push_back(val[i*col+k]) ;\n            }\n        }\n        for(int i = 0 ; i < row ; i ++) {\n            for(int k = 0 ; k < col ; k ++) {\n                t.push_back(m2.val[i*col+k]) ;\n            }\n        }\n        Matrix m1(r,c,t) ;\n        return m1 ;\n    }\n    Matrix concatenateColumns(Matrix m2) {\n        int r = row;\n        int c = col+m2.col ;\n        vector<T> t;\n        for(int i = 0 ; i < c ; i ++) {\n            for(int k = 0 ; k < c ; k ++) {\n                t.push_back(0) ;\n            }\n        }\n        for(int k = 0 ; k < col ; k ++){\n        for(int i = 0 ; i < row ; i ++)\n             {\n                t[i*c+k] = val[i*col+k] ;\n            }\n        }\n        for(int i = 0 ; i < row ; i ++) {\n            for(int k = 0 ; k < col ; k ++) {\n                t[i*c+k+col] = m2.val[i*col+k] ;\n            }\n        }\n        Matrix m1(r,c,t) ;\n        return m1 ;\n    }\n    Matrix reshape(int row_ ,int col_) {\n        int r = row_;\n        int c = col_ ;\n        vector<T> t1;\n        vector<T> t2;\n        for(int i = 0 ; i < r ; i ++) {\n            for(int k = 0 ; k < c ; k ++) {\n                t1.push_back(1) ;\n                t2.push_back(1) ;\n            }\n        }\n        int y = 0 ;\n        for(int k = 0 ; k < col ; k ++) {\n            for(int i = 0 ; i < row ; i ++) {\n                t2[y++] = val[i*col+k] ;\n            }\n        }\n        int z = 0 ;\n        for(int k = 0 ; k < c ; k ++) {\n            for(int i = 0 ; i < r ; i ++) {\n                t1[i*c+k] = t2[z++] ;\n            }\n        }\n        Matrix m1(r,c,t1) ;\n        return m1 ;\n    }\n    Matrix transpose(){\n        vector<T> t;\n        for(int i = 0 ; i < row ; i ++) {\n            for(int k = 0 ; k < col ; k ++) {\n                t.push_back(1) ;\n            }\n        }\n        int y = 0 ;\n        for(int k = 0 ; k < col ; k ++) {\n            for(int i = 0 ; i < row ; i ++) {\n                t[y++] = val[i*col+k] ;\n            }\n        }\n        Matrix m1(col,row,t) ;\n        return m1 ;\n    }\n    Matrix operator + (Matrix m2) {\n        vector<T> t;\n        for(int i = 0 ; i < row ; i ++) {\n            for(int k = 0 ; k < col ; k ++) {\n                t.push_back(m2.val[i*col+k]+val[i*col+k]) ;\n            }\n        }\n        Matrix m1(row,col,t) ;\n        return m1 ;\n    }\n    Matrix operator + (T n) {\n        vector<T> t;\n        for(int i = 0 ; i < row ; i ++) {\n            for(int k = 0 ; k < col ; k ++) {\n                t.push_back(n+val[i*col+k]) ;\n            }\n        }\n        Matrix m1(row,col,t) ;\n        return m1 ;\n    }\n    Matrix operator - (Matrix m2) {\n        vector<T> t;\n        for(int i = 0 ; i < row ; i ++) {\n            for(int k = 0 ; k < col ; k ++) {\n                t.push_back(-m2.val[i*col+k]+val[i*col+k]) ;\n            }\n        }\n        Matrix m1(row,col,t) ;\n        return m1 ;\n    }\n    Matrix operator - (T n) {\n        vector<T> t;\n        for(int i = 0 ; i < row ; i ++) {\n            for(int k = 0 ; k < col ; k ++) {\n                t.push_back(-n+val[i*col+k]) ;\n            }\n        }\n        Matrix m1(row,col,t) ;\n        return m1 ;\n    }\n    Matrix operator * (Matrix m2) {\n        vector<T> t;\n        for(int i = 0 ; i < row ; i ++) {\n            for(int k = 0 ; k < m2.col ; k ++) {\n                t.push_back(0) ;\n            }\n        }\n        for(int i = 0 ; i < row ; i ++) {\n            for(int k = 0 ; k < m2.col ; k ++) {\n                for(int z = 0 ; z < col ; z ++) t[i*m2.col+k] += val[i*col+z]*m2.val[k+z*m2.col] ;\n            }\n        }\n        Matrix m1(row,m2.col,t) ;\n        return m1 ;\n    }\n    Matrix operator * (T n) {\n        vector<T> t;\n        for(int i = 0 ; i < row ; i ++) {\n            for(int k = 0 ; k < col ; k ++) {\n                t.push_back(val[i*col+k]*n) ;\n            }\n        }\n        Matrix m1(row,col,t) ;\n        return m1 ;\n    }\n    Matrix max() {\n        vector<T> t;\n        if(col == 1) {\n            t.push_back(0) ;\n            T now = val[0] ;\n            for(int i = 0 ;i < row ; i ++) {\n                if(val[i]>now) now = val[i] ;\n            }\n            t[0] = now ;\n            Matrix m1(1,1,t) ;\n            return m1 ;\n        }\n        else{\n            for(int i = 0 ; i < row ; i ++) {\n                t.push_back(0) ;\n                T now = val[i*col] ;\n                for(int k = 0 ;k < col ; k ++) {\n                if(val[i*col+k]>now) now = val[i*col+k] ;\n                }\n                t[i] = now ;\n            }\n            Matrix m1(row,1,t) ;\n            return m1 ;\n        }\n    }\n    Matrix min() {\n        vector<T> t;\n        if(col == 1) {\n            t.push_back(0) ;\n            T now = val[0] ;\n            for(int i = 0 ;i < row ; i ++) {\n                if(val[i]<now) now = val[i] ;\n            }\n            t[0] = now ;\n            Matrix m1(1,1,t) ;\n            return m1 ;\n        }\n        else{\n            for(int i = 0 ; i < row ; i ++) {\n                t.push_back(0) ;\n                T now = val[i*col] ;\n                for(int k = 0 ;k < col ; k ++) {\n                if(val[i*col+k]<now) now = val[i*col+k] ;\n                }\n                t[i] = now ;\n            }\n            Matrix m1(row,1,t) ;\n            return m1 ;\n        }\n    }\n    Matrix sum() {\n        vector<T> t;\n        if(col == 1) {\n            t.push_back(0) ;\n            for(int i = 0 ;i < row ; i ++) {\n                t[0]+=val[i] ;\n            }\n            Matrix m1(1,1,t) ;\n            return m1 ;\n        }\n        else{\n            for(int i = 0 ; i < row ; i ++) {\n                t.push_back(0) ;\n                for(int k = 0 ;k < col ; k ++) {\n                t[i] += val[i*col+k] ;\n                }\n            }\n            Matrix m1(row,1,t) ;\n            return m1 ;\n        }\n    }\n} ;",
            1590588445.3661919,
            100,
            "# 答案正确"
        ],
        [
            "6.2 (C++)",
            "谢浩林",
            "#include <iostream>\n#include <string>\n#include <cstring>\nusing namespace std;\n\ntemplate <typename T>\nclass Matrix\n{\nprivate:\n    int row ;\n    int col ;\n    T *val;\npublic:\n    Matrix(int row_ = 0,int col_= 0)\n    {\n        this->row = row_ ;\n        this->col = col_ ;\n\t\tthis -> val = new T[row*col] ;\n        memset(val,0,row*col*sizeof(T)) ;\n    }\n    Matrix(int row_, int col_, const T val_[])\n    {\n        this->row = row_ ;\n        this->col = col_ ;\n        this -> val = new T[row*col] ;\n        for(int i = 0 ; i < row ; i ++)\n        {\n            for(int k = 0 ; k < col ; k ++)\n            {\n                this->val[i*col+k] =val_[i*col+k] ;\n            }\n        }\n    }\n    ~Matrix() {\n        if(val!=NULL){\n\t\t\tdelete[] val ;\n\t\t\tval = NULL ;\n\t\t}\n    }\n    void print()\n    {\n        for(int i = 0 ; i < row ; i ++)\n        {\n            for(int k = 0 ; k < col ; k ++)\n            {\n                cout << \"    \"<<val[i*col+k] ;\n            }\n            cout << endl ;\n        }\n    }\n    Matrix &operator =(const Matrix &m2)\n    {\n\t\tdelete[]val ;                       //we have to delete old one and new a new one\n        this->row =m2.row;\n        this->col =m2.col;\n\t\tthis -> val = new T[row*col] ;\n        for(int i = 0 ; i < row ; i ++)\n        {\n            for(int k = 0 ; k < col ; k ++)\n            {\n                this->val[i*col+k] =m2.val[i*col+k] ;\n            }\n        }\n\t\treturn *this ;\n    }\n\tMatrix (Matrix &m2) {                    //if we dont have this m2->m3,is one thing\n\t\tthis->row =m2.row;\n     \tthis->col =m2.col;\n\t\tval= new T[row*col] ;\n        for(int i = 0 ; i < row ; i ++)\n        {\n            for(int k = 0 ; k < col ; k ++)\n            {\n                val[i*col+k] =m2.val[i*col+k] ;\n            }\n        }\n\t}\n    T &get(int x, int y) {\n        return this->val[(y-1)*col+x-1] ;\n    }\n} ;",
            1590631500.5715184,
            100,
            "# 答案正确"
        ],
        [
            "7.1 (C++)",
            "谢浩林",
            "#include <cmath>\nclass Triangle:public GeometricObject\n{\nprivate :\n    double side1, side2, side3 ;\npublic :\n    Triangle()\n    {\n        side1 = 1.0 ;\n        side2 = 1.0 ;\n        side3 = 1.0 ;\n    }\n    Triangle(double side1_,double side2_,double side3_)\n    {\n        side1 =  side1_ ;\n        side2 = side2_ ;\n        side3 = side3_ ;\n    }\n    double getSide1() {\n        return side1 ;\n    }\n    double getSide2() {\n        return side2 ;\n    }\n    double getSide3() {\n        return side3;\n    }\n    double getPerimeter() {\n        return (side1+side2+side3) ;\n    }\n    double getArea() {\n        double s = (side1 + side2 + side3) / 2;\n        return sqrt(s * (s - side1) * (s - side2) * (s - side3));\n    }\n};\n",
            1590725494.334494,
            100,
            "# 答案正确"
        ],
        [
            "7.3 (C++)",
            "谢浩林",
            "template <typename A, typename R>\nvector<R> map2(const vector<A> & x, const vector<A> & y,R (*map_func)(const A &,const A &)) {\n\tvector<R> res;\n\tfor (int i = 0; i < x.size(); ++ i)\n\t\tres.push_back(map_func(x[i],y[i]));\n\treturn res;\n}\ntemplate <typename A, typename R>\nvector<R> map2(const vector<A> & x, const A & y,R (*map_func)(const A &,const A &)) {\n\tvector<R> res;\n\tfor (int i = 0; i < x.size(); ++ i)\n\t\tres.push_back(map_func(x[i],y));\n\treturn res;\n}\n",
            1590726229.737704,
            100,
            "# 答案正确"
        ],
        [
            "7.2 (C++)",
            "谢浩林",
            "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nvector <string> split(const string &line ,const string &de = \" \" ) {\n\tvector <string> mm ;\n\tint now = 0 ;\n\tint end ;\n\twhile(now < line.size()) {\n\t\tend = line.find(de,now) ;\n\t\tif(now == end) now += de.size() ;\n\t\telse {\n\t\t\tif(end == -1) {\n\t\t\t\tmm.push_back(line.substr(now)) ;\n\t\t\t\tbreak ;\n\t\t\t}\n\t\t\tmm.push_back(line.substr(now,end-now)) ;\n\t\t\tnow = end += de.size() ;\n\t\t}\n\t}\n\treturn mm ;\n}",
            1591237187.181183,
            100,
            "# 答案正确"
        ],
        [
            "8.1 (C++)",
            "谢浩林",
            "class Full:public Matrix {\n    private:\n    int r ;\n    int c ;\n    double *val ;\n    public:\n    int size(int dimension) const {\n        if(dimension == 1) return r ;\n        else return c ;\n    }\n\tFull (int row , int column) {\n        val = new double[row*column] ;\n        r = row ;\n        c = column ;\n        for(int i = 0 ; i < r*c ; i ++) {\n            val[i] = 0 ;\n        }\n\t}\n\tFull (const Matrix & matrix2) {\n        r = matrix2.size(1) ;\n        c = matrix2.size(2);\n        val = new double[r*c] ;\n        for(int i = 0 ; i < r ; i ++) {\n            for(int k = 0 ; k < c ; k ++) {\n                val[i*c+k] = matrix2.get(i,k) ;\n            }\n        }\n\t}\n\tFull (int row , int column,double value[]) {\n        val = new double[row*column] ;\n        r = row ;\n        c = column ;\n        for(int i = 0 ; i < r*c ; i ++) {\n            val[i] = value[i] ;\n        }\n\t}\n\tvoid set(int row, int column, double value) {\n        val[row*c+column] = value ;\n\t}\n\n\tdouble get(int row, int column) const {\n        return val[row*c+column] ;\n\t}\n\n\tvoid print() const {\n        for(int i = 0 ; i < r ; i ++) {\n            for(int k = 0 ; k < c ; k ++) {\n                cout <<\"    \"<< val[i*c+k] ;\n            }\n            cout << endl ;\n        }\n\t}\n\t~Full() {\n        delete[]val ;\n\t}\n\tMatrix & operator = (const Matrix & matrix2) {\n        if(val != NULL) delete[]val ;\n        r = matrix2.size(1) ;\n        c = matrix2.size(2) ;\n        val = new double[r*c] ;\n        for(int i = 0 ; i < r ; i ++) {\n            for(int k = 0 ; k < c ; k ++) {\n                val[i*c+k] = matrix2.get(i,k) ;\n            }\n        }\n\t}\n};",
            1591345376.5410814,
            100,
            "# 答案正确"
        ],
        [
            "8.3 (C++)",
            "谢浩林",
            "#include <iostream>\nusing namespace std;\n#include <vector>\n\nclass Sparse:public Matrix\n{\nprivate:\n    vector <Entry> w;\n    int r ;\n    int c ;\npublic:\n    Sparse (int row,int col)\n    {\n        r = row ;\n        c = col ;\n    }\n    int size(int dimension) const\n    {\n        if(dimension == 1) return r ;\n        else return c ;\n    }\n    void set(int row, int column,double value)\n    {\n        for(int i = 0 ; i < w.size() ; i ++)\n        {\n            if(w[i].row == row && w[i].column==column)\n            {\n                w[i].value =value ;\n                return ;\n            }\n        }\n        Entry tmp ;\n        tmp.row = row ;\n        tmp.column = column ;\n        tmp.value = value ;\n        w.push_back(tmp) ;\n    }\n    void add(int row, int column,double value)\n    {\n        for(int i = 0 ; i < w.size() ; i ++)\n        {\n            if(w[i].row == row && w[i].column==column)\n            {\n                w[i].value +=value ;\n                return ;\n            }\n        }\n        Entry tmp ;\n        tmp.row = row ;\n        tmp.column = column ;\n        tmp.value = value ;\n        w.push_back(tmp) ;\n    }\n    ~Sparse() {}\n    double get(int row, int column) const\n    {\n        for(int i = 0 ; i < w.size() ; i ++)\n        {\n            if(w[i].row == row && w[i].column==column)\n            {\n                return w[i].value ;\n            }\n        }\n        return -1 ;\n    }\n    virtual void print()\n    {\n        for(int i = 0 ; i < w.size() ; i ++)\n        {\n            if(get(w[i].row,w[i].column)!= 0)cout <<\"(\"<<w[i].row<<\",\"<<w[i].column <<\",\"<<get(w[i].row,w[i].column)<<\")\"<<endl ;\n        }\n    }\n    Sparse operator + (const Sparse s2)\n    {\n        Sparse s3(r,c) ;\n        Entry ww[10] ;\n        int z = 0 ;\n        for(int i = 0 ; i < w.size() ; i ++)\n        {\n            s3.add(w[i].row,w[i].column,w[i].value) ;\n        }\n        for(int k = 0 ; k < s2.w.size() ; k ++)\n        {\n            {\n                s3.add(s2.w[k].row,s2.w[k].column,s2.w[k].value) ;\n            }\n        }\n        return s3 ;\n    }\n    Sparse operator * (const Sparse s2)\n    {\n        Sparse s3(r,s2.c) ;\n        for(int i = 0 ; i <w.size() ; i ++)\n        {\n            for(int k = 0 ; k < s2.w.size() ; k ++)\n            {\n                if(w[i].column == s2.w[k].row)s3.add(w[i].row,s2.w[k].column,w[i].value*s2.w[k].value) ;\n            }\n        }\n        for(int i = 0 ; i < s3.w.size() ; i ++)\n        {\n            for(int k = 0 ; k < s3.w.size() - 1; k ++)\n            {\n                if(s3.w[k].row > s3.w[k+1].row||(s3.w[k].row == s3.w[k+1].row&&s3.w[k].column > s3.w[k+1].column))\n                {\n                    Entry tmp = s3.w[k];\n                    s3.w[k] = s3.w[k+1] ;\n                    s3.w[k+1] = tmp ;\n                }\n            }\n        }\n        return s3 ;\n    }\n} ;\n\n",
            1591359807.3910017,
            100,
            "# 答案正确"
        ],
        [
            "8.4 (C++)",
            "谢浩林",
            "#include <iostream>\nusing namespace std;\n#include <vector>\n\nclass Sparse:public Matrix {\n    private:\n    vector <Entry> w;\n    int r ;\n    int c ;\n    public:\n    Sparse (int row,int col) {\n        r = row ;\n        c = col ;\n    }\n    int size(int dimension) const {\n        if(dimension == 1) return r ;\n        else return c ;\n    }\n    void set(int row, int column,double value) {\n        for(int i = 0 ; i < w.size() ; i ++){\n            if(w[i].row == row && w[i].column==column) {\n                w[i].value =value ;\n                return ;\n            }\n        }\n        Entry tmp ;\n        tmp.row = row ;\n        tmp.column = column ;\n        tmp.value = value ;\n        w.push_back(tmp) ;\n    }\n    void add(int row, int column,double value) {\n        for(int i = 0 ; i < w.size() ; i ++){\n            if(w[i].row == row && w[i].column==column) {\n                w[i].value +=value ;\n                return ;\n            }\n        }\n        Entry tmp ;\n        tmp.row = row ;\n        tmp.column = column ;\n        tmp.value = value ;\n        w.push_back(tmp) ;\n    }\n    ~Sparse() {}\n    double get(int row, int column) const {\n        for(int i = 0 ; i < w.size() ; i ++){\n            if(w[i].row == row && w[i].column==column) {\n                return w[i].value ;\n            }\n        }\n        return -1 ;\n    }\n    virtual void print() {\n        for(int i = 0 ; i < w.size() ; i ++){\n            if(get(w[i].row,w[i].column)!= 0)cout <<\"(\"<<w[i].row<<\",\"<<w[i].column <<\",\"<<get(w[i].row,w[i].column)<<\")\"<<endl ;\n        }\n    }\n    Sparse operator + (const Sparse s2) {\n        Sparse s3(r,c) ;\n        Entry ww[10] ;\n        int z = 0 ;\n        for(int i = 0 ; i < w.size() ; i ++) {\n            for(int k = 0 ; k < s2.w.size() ; k ++) {\n            {\n                    s3.add(s2.w[k].row ,s2.w[k].column ,s2.w[k].value+w[i].value) ;\n                }\n            }\n        }\n        return s3 ;\n    }\n    Sparse operator * (const Sparse s2) {\n        Sparse s3(r,s2.c) ;\n        for(int i = 0 ; i <w.size() ; i ++) {\n            for(int k = 0 ; k < s2.w.size() ; k ++) {\n                if(w[i].column == s2.w[k].row)s3.add(w[i].row,s2.w[k].column,w[i].value*s2.w[k].value) ;\n            }\n        }\n        for(int i = 0 ; i < s3.w.size() ; i ++) {\n            for(int k = 0 ; k < s3.w.size() - 1; k ++) {\n                if(s3.w[k].row > s3.w[k+1].row||(s3.w[k].row == s3.w[k+1].row&&s3.w[k].column > s3.w[k+1].column)) {\n                    Entry tmp = s3.w[k];\n                    s3.w[k] = s3.w[k+1] ;\n                    s3.w[k+1] = tmp ;\n                }\n            }\n        }\n        return s3 ;\n    }\n} ;\n",
            1591359616.9743743,
            100,
            "# 答案正确"
        ],
        [
            "8.5 (C++)",
            "谢浩林",
            "#include <iostream>\nusing namespace std;\n\nclass Point3D:public Point2D {\n    private:\n    double z ;\n    public:\n    double getZ() {\n        return z ;\n    }\n    Point3D() {\n        setX(0) ;\n        setY(0) ;\n        z = 0 ;\n    }\n    Point3D(double x_,double y_,double z_) {\n        setX(x_) ;\n        setY(y_) ;\n        z = z_ ;\n    }\n    virtual double distance(Point2D & point2) {\n        Point3D *p = dynamic_cast<Point3D *> (&point2) ;\n\t\tdouble dx = getX() -p ->getX();\n\t\tdouble dy = getY() -p->getY();\n\t\tdouble dz =z - p-> z;\n\t\treturn sqrt(dx * dx + dy * dy + dz * dz);\n\t}\n} ;\n",
            1591842604.6770065,
            100,
            "# 答案正确"
        ],
        [
            "8.6 (C++)",
            "谢浩林",
            "#include <iostream>\nusing namespace std;\nclass MyTensor :public Tensor<double> {\n    private:\n    double *data;\n    public:\n    virtual double & get(const vector<int> & indexes) {\n        if(sizes.size()==1) return data[indexes[0]] ;\n        if(sizes.size()==2) return data[indexes[0]+sizes[0]*indexes[1]] ;\n        if(sizes.size()==3) return data[indexes[0]+sizes[0]*indexes[1]+sizes[0]*sizes[1]*indexes[2]] ;\n        if(sizes.size()==4) return data[indexes[0]+sizes[0]*indexes[1]+sizes[0]*sizes[1]*indexes[2]+sizes[0]*sizes[1]*sizes[2]*indexes[3]] ;\n    }\n    MyTensor(vector<int> s):Tensor<double> (s) {\n        int total = 1 ;\n        for(int i = 0 ; i< s.size() ; i ++) total*=s[i] ;\n        data = new double[total] ;\n    }\n    ~MyTensor() {\n        delete[]data ;\n    }\n} ;\n",
            1592449372.494858,
            100,
            "# 答案正确"
        ],
        [
            "9.1 (C++)",
            "谢浩林",
            "#include <iostream>\nusing namespace std;\n\nclass Circle {\n    private:\n    double x ;\n    public:\n    Circle() {\n        x = 0 ;\n    }\n    Circle(double x_) {\n        x = x_ ;\n    }\n    bool operator >(Circle m) {\n        return (x>m.x) ;\n    }\n    bool operator ==(Circle m) {\n        return (x==m.x) ;\n    }\n    bool operator >=(Circle m) {\n        return (x>=m.x) ;\n    }\n    bool operator <=(Circle m) {\n        return (x<=m.x) ;\n    }\n    bool operator <(Circle m) {\n        return (x<m.x) ;\n    }\n    bool operator !=(Circle m) {\n        return (x!=m.x) ;\n    }\n};\n",
            1592535935.0221007,
            100,
            "# 答案正确"
        ],
        [
            "9.2 (C++)",
            "谢浩林",
            "class I:public Tensor {\n    private:\n    vector <int>index ;\n    vector<int> turn(int i1, int i2=-1, int i3=-1, int i4=-1)\n    {\n\tvector<int> indexes;\n\tindexes.push_back(i1);\n\tif (i2 != -1) indexes.push_back(i2);\n\tif (i3 != -1) indexes.push_back(i3);\n\tif (i4 != -1) indexes.push_back(i4);\n\treturn indexes;\n    };\n    public:\n    I(int i1, int i2=-1, int i3=-1, int i4=-1):Tensor (turn(i1,i2,i3,i4)){\n        index = turn(i1,i2,i3,i4) ;\n    }\n    operator vector<int> () {\n        return index ;\n    }\n} ;\n",
            1592538287.8180828,
            100,
            "# 答案正确"
        ],
        [
            "9.3 (C++)",
            "谢浩林",
            "#include <iostream>\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\nclass Complex {\n    private:\n    double r;\n    double i ;\n    public:\n    Complex(double x = 0 ,double y = 0 ) {\n        r = x ;\n        i = y ;\n    }\n    double real() const {\n        return r ;\n    }\n    double imag() const {\n        return i ;\n    }\n    Complex &operator +=(Complex &m2) {\n    r += m2.real() ;\n    i += m2.imag() ;\n    }\n\n    Complex &operator -=(Complex &m2) {\n    r -= m2.real() ;\n    i -= m2.imag() ;\n    }\n    Complex &operator *=(Complex &m2) {\n    double r_ = r*m2.real() - i * m2. imag() ;\n    double i_ = r*m2.imag() + i * m2. real() ;\n    r = r_ ;\n    i = i_ ;\n    }\n    Complex &operator /=(Complex &m2) {\n    double a = r ;\n    double b = i ;\n    double c = m2.real() ;\n    double d = m2. imag() ;\n    r = (a*c + b *d)/(c*c+d*d) ;\n    i = (b*c -a*d) / (c*c + d*d) ;\n    }\n    Complex &operator ++() {\n        r ++ ;\n\t\treturn *this ;\n    }\n    Complex operator ++(int) {\n        Complex tmp(r,i) ;\n        r ++ ;\n        return tmp ;\n    }\n    //operator double() {return r ;}\n};\n\nComplex operator +(Complex m1,Complex m2) {\n    Complex m(m2.real() + m1.real(),m2.imag() + m1.imag()) ;\n    return m ;\n}\n\nComplex operator -(Complex m1,Complex m2) {\n    Complex m(m1.real() - m2.real(),m1.imag() - m2.imag()) ;\n    return m ;\n}\n\nComplex operator /(Complex m1,Complex m2) {\n    double a = m1.real() ;\n    double b = m1.imag() ;\n    double c = m2.real() ;\n    double d = m2. imag() ;\n    double r = (a*c + b *d)/(c*c+d*d) ;\n    double i = (b*c -a*d) / (c*c + d*d) ;\n    Complex m(r,i) ;\n    return m ;\n}\n\nComplex operator *(Complex m1,Complex m2) {\n    double r = m1.real()*m2.real() - m1.imag() * m2. imag() ;\n    double i = m1.real()*m2.imag() + m1.imag() * m2. real() ;\n    Complex m(r,i) ;\n    return m ;\n}\n\nbool operator ==(Complex m1,Complex m2) {\n    if(m1.real() == m2.real() && m1.imag() == m2.imag()) return 1 ;\n    else return 0 ;\n}\n\nbool operator !=(Complex m1,Complex m2) {\n    if(m1.real() == m2.real() && m1.imag() == m2.imag()) return 0 ;\n    else return 1 ;\n}\n\nostream &operator << (ostream &out,const Complex &m) {\n    out << m.real() << \" + \" << m.imag() << \" i \" ;\n    return out ;\n}\n\nistream &operator >> (istream &in , Complex &m) {\n    double r ;\n    double i ;\n    in >> r >> i ;\n    Complex tmp(r,i) ;\n    m = tmp ;\n    return in ;\n}\n\nint main(){\n    Complex c1(25, 35);\n    Complex c2(10, 20);\n    Complex c3(1, 2);\n    Complex c4(4, 9);\n    Complex c5(34, 6);\n    Complex c6(80, 90);\n\n    Complex c7 = c1 + c2;\n    Complex c8 = c1 - c2;\n    Complex c9 = c1 * c2;\n    Complex c10 = c1 / c2;\n    Complex c11 = 10 + c2;\n    Complex c12 = c2 - 20;\n    cout << \"c7 = \" << c7.real() << \" + \" << c7.imag() << \"i\" << endl;\n    cout << \"c8 = \" << c8.real() << \" + \" << c8.imag() << \"i\" << endl;\n    cout << \"c9 = \" << c9.real() << \" + \" << c9.imag() << \"i\" << endl;\n    cout << \"c10 = \" << c10.real() << \" + \" << c10.imag() << \"i\" << endl;\n    cout << \"c11 = \" << c11.real() << \" + \" << c11.imag() << \"i\" << endl;\n    cout << \"c12 = \" << c12.real() << \" + \" << c12.imag() << \"i\" << endl;\n\n    c3 += c1;\n    c4 -= c2;\n    c5 *= c2;\n    c6 /= c2;\n    cout << \"c3 = \" << c3.real() << \" + \" << c3.imag() << \"i\" << endl;\n    cout << \"c4 = \" << c4.real() << \" + \" << c4.imag() << \"i\" << endl;\n    cout << \"c5 = \" << c5.real() << \" + \" << c5.imag() << \"i\" << endl;\n    cout << \"c6 = \" << c6.real() << \" + \" << c6.imag() << \"i\" << endl;\n    if(c1 == c2){\n        cout << \"c1 == c2\" << endl;\n    }\n    if(c1 != c2){\n        cout << \"c1 != c2\" << endl;\n    }\n    Complex cc1, cc2, cc3;\n    cin >> cc1 >> cc2;\n    cc3 = cc1 + cc2;\n    cout << \"c1 + c2 = \" << cc3 << endl;\n    cc3 = cc1 - cc2;\n    cout << \"c1 - c2 = \" << cc3 << endl;\n    Complex ccc1;\n    cin >> ccc1;\n    cout << \"++ c1 = \" << ++ ccc1 << endl; // 实部 += 1\n    cout << \"c1 ++ = \" << ccc1 ++ << endl; // 实部 += 1\n\t//double real = ccc1; // 获取实部\n    //cout << \"real = \" << real << endl;\n}\n\n",
            1592540388.0136075,
            100,
            "main.cpp: In function ‘int main()’:\nmain.cpp:7:5: error: redefinition of ‘int main()’\n int main(){\n     ^\nIn file included from main.cpp:5:0:\nsource.cpp:108:5: note: ‘int main()’ previously defined here\n int main(){\n     ^\n"
        ],
        [
            "9.4 (C++)",
            "谢浩林",
            "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nclass Complex {\n    private:\n    double r;\n    double i ;\n    public:\n    Complex(double x = 0,double y = 0) {\n        r = x ;\n        i = y ;\n    }\n    double real() const {\n        return r ;\n    }\n    double imag() const {\n        return i ;\n    }\n    Complex &operator +=(Complex &m2) {\n    r += m2.real() ;\n    i += m2.imag() ;\n    }\n\n    Complex &operator -=(Complex &m2) {\n    r -= m2.real() ;\n    i -= m2.imag() ;\n    }\n    Complex &operator *=(Complex &m2) {\n    double r_ = r*m2.real() - i * m2. imag() ;\n    double i_ = r*m2.imag() + i * m2. real() ;\n    r = r_ ;\n    i = i_ ;\n    }\n    Complex &operator /=(Complex &m2) {\n    double a = r ;\n    double b = i ;\n    double c = m2.real() ;\n    double d = m2. imag() ;\n    r = (a*c + b *d)/(c*c+d*d) ;\n    i = (b*c -a*d) / (c*c + d*d) ;\n    }\n    Complex &operator ++() {\n        r ++ ;\n\t\treturn *this ;\n    }\n    Complex operator ++(int) {\n        Complex tmp(r,i) ;\n        r ++ ;\n        return tmp ;\n    }\n    operator double() {return r ;}\n};\n\nComplex operator +(Complex m1,Complex m2) {\n    Complex m(m2.real() + m1.real(),m2.imag() + m1.imag()) ;\n    return m ;\n}\n\nComplex operator -(Complex m1,Complex m2) {\n    Complex m(m1.real() - m2.real(),m1.imag() - m2.imag()) ;\n    return m ;\n}\n\nComplex operator /(Complex m1,Complex m2) {\n    double a = m1.real() ;\n    double b = m1.imag() ;\n    double c = m2.real() ;\n    double d = m2. imag() ;\n    double r = (a*c + b *d)/(c*c+d*d) ;\n    double i = (b*c -a*d) / (c*c + d*d) ;\n    Complex m(r,i) ;\n    return m ;\n}\n\nComplex operator *(Complex m1,Complex m2) {\n    double r = m1.real()*m2.real() - m1.imag() * m2. imag() ;\n    double i = m1.real()*m2.imag() + m1.imag() * m2. real() ;\n    Complex m(r,i) ;\n    return m ;\n}\n\nbool operator ==(Complex m1,Complex m2) {\n    if(m1.real() == m2.real() && m1.imag() == m2.imag()) return 1 ;\n    else return 0 ;\n}\n\nbool operator !=(Complex m1,Complex m2) {\n    if(m1.real() == m2.real() && m1.imag() == m2.imag()) return 0 ;\n    else return 1 ;\n}\n\nostream &operator << (ostream &out,const Complex &m) {\n    out << m.real() << \" + \" << m.imag() << \" i \" ;\n    return out ;\n}\n\nistream &operator >> (istream &in , Complex &m) {\n    double r ;\n    double i ;\n    in >> r >> i ;\n    Complex tmp(r,i) ;\n    m = tmp ;\n    return in ;\n}\n",
            1592543669.9820986,
            100,
            "# 答案正确"
        ],
        [
            "9.5 (C++)",
            "谢浩林",
            "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nclass Complex {\n    private:\n    double r;\n    double i ;\n    public:\n    Complex(double x = 0,double y = 0) {\n        r = x ;\n        i = y ;\n    }\n    double real() const {\n        return r ;\n    }\n    double imag() const {\n        return i ;\n    }\n    Complex &operator +=(Complex &m2) {\n    r += m2.real() ;\n    i += m2.imag() ;\n    }\n\n    Complex &operator -=(Complex &m2) {\n    r -= m2.real() ;\n    i -= m2.imag() ;\n    }\n    Complex &operator *=(Complex &m2) {\n    double r_ = r*m2.real() - i * m2. imag() ;\n    double i_ = r*m2.imag() + i * m2. real() ;\n    r = r_ ;\n    i = i_ ;\n    }\n    Complex &operator /=(Complex &m2) {\n    double a = r ;\n    double b = i ;\n    double c = m2.real() ;\n    double d = m2. imag() ;\n    r = (a*c + b *d)/(c*c+d*d) ;\n    i = (b*c -a*d) / (c*c + d*d) ;\n    }\n    Complex &operator ++() {\n        r ++ ;\n\t\treturn *this ;\n    }\n    Complex operator ++(int) {\n        Complex tmp(r,i) ;\n        r ++ ;\n        return tmp ;\n    }\n    operator double() {return r ;}\n};\n\nComplex operator +(Complex m1,Complex m2) {\n    Complex m(m2.real() + m1.real(),m2.imag() + m1.imag()) ;\n    return m ;\n}\n\nComplex operator -(Complex m1,Complex m2) {\n    Complex m(m1.real() - m2.real(),m1.imag() - m2.imag()) ;\n    return m ;\n}\n\nComplex operator /(Complex m1,Complex m2) {\n    double a = m1.real() ;\n    double b = m1.imag() ;\n    double c = m2.real() ;\n    double d = m2. imag() ;\n    double r = (a*c + b *d)/(c*c+d*d) ;\n    double i = (b*c -a*d) / (c*c + d*d) ;\n    Complex m(r,i) ;\n    return m ;\n}\n\nComplex operator *(Complex m1,Complex m2) {\n    double r = m1.real()*m2.real() - m1.imag() * m2. imag() ;\n    double i = m1.real()*m2.imag() + m1.imag() * m2. real() ;\n    Complex m(r,i) ;\n    return m ;\n}\n\nbool operator ==(Complex m1,Complex m2) {\n    if(m1.real() == m2.real() && m1.imag() == m2.imag()) return 1 ;\n    else return 0 ;\n}\n\nbool operator !=(Complex m1,Complex m2) {\n    if(m1.real() == m2.real() && m1.imag() == m2.imag()) return 0 ;\n    else return 1 ;\n}\n\nostream &operator << (ostream &out,const Complex &m) {\n    out << m.real() << \" + \" << m.imag() << \" i \" ;\n    return out ;\n}\n\nistream &operator >> (istream &in , Complex &m) {\n    double r ;\n    double i ;\n    in >> r >> i ;\n    Complex tmp(r,i) ;\n    m = tmp ;\n    return in ;\n}\n\n",
            1592543649.6261594,
            100,
            "# 答案正确"
        ],
        [
            "9.6 (C++)",
            "谢浩林",
            "#include <vector>\n#include <iostream>\nusing namespace std;\n\n#include <vector>\n#include <iostream>\nusing namespace std;\n\nclass Tensor\n{\n\tvector<int> sizes;\n\tvector<double> values;\n\n\tint _index(const vector<int> & indexes) const {\n\t\tint index = 0;\n\t\tfor (int i = 0; i < this->sizes.size(); ++ i) {\n\t\t\tindex *= sizes[i];\n\t\t\tindex += indexes[i];\n\t\t}\n\t\treturn index;\n\t}\n\npublic:\n\tint numel() const {\n\t\tif (this->sizes.size() == 0) return 0;\n\t\tint size = 1;\n\t\tfor (int i = 0; i < this->sizes.size(); ++ i) size *= sizes[i];\n\t\treturn size;\n\t}\n    vector<int> s() {\n        return sizes ;\n    }\n\tTensor(vector<int> sizes) {\n\t\tthis->sizes = sizes;\n\t\tthis->values.resize(this->numel());\n\t\tfor (int i = 0; i < this->numel(); ++ i) this->values[i] = 0;\n\t}\n\n\tdouble & get(const vector<int> & indexes)  {\n\t\treturn values[this->_index(indexes)];\n\t}\n\tTensor(int t1 = -1 ,int t2 = -1 ,int t3 = -1 ,int t4 = -1) {\n        sizes.push_back(t1);\n        if (t2 != -1) sizes.push_back(t2);\n        if (t3 != -1) sizes.push_back(t3);\n        if (t4 != -1) sizes.push_back(t4);\n        this->values.resize(this->numel());\n    }\n    double & operator ()(int i1 = -1 ,int i2 = -1 ,int i3 = -1 ,int i4 = -1)  {\n        vector<int> indexes;\n        indexes.push_back(i1);\n        if (i2 != -1) indexes.push_back(i2);\n        if (i3 != -1) indexes.push_back(i3);\n        if (i4 != -1) indexes.push_back(i4);\n\t\treturn values[this->_index(indexes)];\n\t}\n};\n",
            1592556943.3182468,
            100,
            "# 答案正确"
        ],
        [
            "9.7 (C++)",
            "谢浩林",
            "#include <vector>\n#include <iostream>\n#include <fstream>\nusing namespace std;\n\nclass Tensor {\n    private:\n    vector <double> value ;\n    int dim ;\n    vector <int> sizes ;\n    int _index(const vector<int> & indexes) const {\n\t\tint index = 0;\n\t\tfor (int i = 0; i < this->sizes.size(); ++ i) {\n\t\t\tindex *= sizes[i];\n\t\t\tindex += indexes[i];\n\t\t}\n\t\treturn index;\n\t}\n    public:\n    int di() {\n        return dim ;\n    }\n    int s(int i) {\n        return sizes[i] ;\n    }\n    Tensor() {\n        dim = 0 ;\n    }\n    int numel() {\n        int lar = 1 ;\n        for(int i = 0 ;i < sizes.size() ; i ++) {\n            lar *= sizes[i] ;\n        }\n        return lar ;\n    }\n    Tensor(vector <int> size_) {\n        dim = size_.size() ;\n        sizes = size_ ;\n        value.resize(numel()) ;\n        for (int i = 0; i < this->numel(); ++ i) this->value[i] = 0;\n    }\n    Tensor(vector <int> size_,vector <double> val_) {\n        dim = size_.size() ;\n        sizes = size_ ;\n        value.resize(numel()) ;\n        for (int i = 0; i < this->numel(); ++ i) this->value[i] = val_[i];\n    }\n    double & get(const vector<int> & indexes) {\n\t\treturn value[this->_index(indexes)];\n\t}\n\tdouble & get(int index) {\n\t\treturn value[index];\n\t}\n} ;\n\n\nint onumel(vector <int> sizes) {\n        int lar = 1 ;\n        for(int i = 0 ;i < sizes.size() ; i ++) {\n            lar *= sizes[i] ;\n        }\n        return lar ;\n}\n\nistream &operator >> (istream &in , Tensor & t) {\n    int lar ;\n    vector <int> sizes ;\n    int nows ;\n    double nowv;\n    vector <double> value ;\n    in >> lar ;\n    for(int i = 0 ; i < lar ;i ++) {\n        in >> nows ;\n        sizes.push_back(nows) ;\n    }\n    for(int i = 0 ; i < onumel(sizes);i ++){\n        in >> nowv ;\n        value.push_back(nowv) ;\n    }\n    Tensor tmp(sizes,value) ;\n    t = tmp ;\n    return in ;\n}\n\nostream &operator << (ostream &out , Tensor & t) {\n    out << t.di() << endl;\n    for(int i = 0 ; i < t.di() ; i ++) out << t.s(i) << \" \" ;\n    out << endl <<endl;\n    if(t.di() > 2){\n        int dim = t.di() ;\n        int bid =t.numel()/(t.s(dim-1)*t.s(dim-2)) ;\n        int row = t.s(dim-2) ;\n        int col =  t.s(dim-1);\n        for(int j = 0 ; j < bid ; j ++) {\n            for(int i = 0 ; i < row; i ++) {\n                for(int k = 0 ; k < col; k ++) {\n                    out << t.get(k+col*i+j*col*row) << \" \" ;\n                }\n                out << endl ;\n            }\n            out << endl ;\n        }\n    }\n    return out ;\n}\n",
            1592559905.3572392,
            100,
            "# 答案正确"
        ],
        [
            "10.1 (C++)",
            "谢浩林",
            "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<stdbool.h>\n#include<ctype.h>\n\nstruct Goods {\n\t\tchar name[100]; //记录货物名\n\t\tint count;  //记录货物数量\n};\nchar n;//当前操作类型\nchar nam[100] = {0};//当前操作货物名\nint t = 0;//货物种类数\nint cnt = 0;//当前操作货物数\nstruct Goods goods[10005];//仓库\nFILE *fp = NULL;\n\n///显示当前库存列表，包括商品名及其库存量\nvoid show_goods()\n{\n\tfor(int i = 0; i <= t; ++i)\n\t{\n\t\tprintf(\"%s剩余库存%d件\\n\", goods[i].name, goods[i].count);\n\t\tfprintf(fp, \"%s剩余库存%d件\\n\", goods[i].name, goods[i].count);\n\t}\n\n};\n//查看仓库中的name商品\nvoid find_goods()\n{\n\tprintf(\"请输入商品名称(全英文字符串)：\\n\");\n\tfprintf(fp, \"请输入商品名称(全英文字符串)：\\n\");\n\tscanf(\"%s\",nam) ;\n\t//gets(nam);\n\tfprintf(fp, \"查询货物： %s\\n\", nam);\n\tint i;\n\tfor(i = 0; i <= t; ++i)\n\tif(!strcmp(nam, goods[i].name))\n\t{\n\t\tprintf(\"%s剩余库存%d件\\n\", nam, goods[i].count);\n\t\tfprintf(fp, \"%s剩余库存%d件\\n\", nam, goods[i].count);\n\t\tbreak;\n\t}\n\tif(i == i+1)\n\t{\n\t\tprintf(\"查无此货\\n\");\n\t\tfprintf(fp, \"查无此货\\n\");\n\t}\n};\n\n//选择进货功能\nvoid out_add1()\n{\n\tprintf(\"您已选择进货模块\\n请输入商品名称(全英文字符串)：\\n\");\n\tfprintf(fp, \"您已选择进货模块\\n请输入商品名称(全英文字符串)：\\n\");\n\t//gets(nam);\n\tscanf(\"%s\",nam) ;\n\tfprintf(fp, \"进货货物：%s\\n\", nam);\n}\nvoid out_add2()\n{\n\tprintf(\"您已选择进货模块\\n请输入进货数量(整数)：\\n\");\n\tfprintf(fp, \"您已选择进货模块\\n请输入进货数量(整数)：\\n\");\n\tscanf(\"%d\", &cnt);\n\tfprintf(fp, \"进货数量： %d\\n\", cnt);\n}\nvoid out_erroradd1()\n{\n\tprintf(\"您的输入不符合规范，请重新输入\\n\");\n\tout_add1();\n}\nvoid out_erroradd2()\n{\n\tprintf(\"您的输入不符合规范，请重新输入\\n\");\n\tout_add2();\n}\n\n//选择出货功能\nvoid out_del1()\n{\n\tprintf(\"您已选择出货模块\\n请输入商品名称(全英文字符串)：\\n\");\n\tfprintf(fp, \"您已选择出货模块\\n请输入商品名称(全英文字符串)：\\n\");\n\t//gets(nam);\n\tscanf(\"%s\",nam) ;\n\tfprintf(fp, \"出货货物： %s\\n\", nam);\n}\nvoid out_del2()\n{\n\tprintf(\"您已选择出货模块\\n请输入出货数量(整数)：\\n\");\n\tfprintf(fp, \"您已选择出货模块\\n请输入出货数量(整数)：\\n\");\n\tscanf(\"%d\", &cnt);\n\tfprintf(fp, \"需求数量： %d\\n\", cnt);\n}\n\n//选择查询功能\nvoid out_show()\n{\n\tprintf(\"您已选择查询模块\\n若要显示库存请输入1\\n若要查找商品请输入2\\n\");\n\tfprintf(fp, \"您已选择查询模块\\n若要显示库存请输入1\\n若要查找商品请输入2\\n\");\n}\nvoid out_errorshow()\n{\n\tprintf(\"您的输入不符合规范，请重新输入\\n\");\n\tfprintf(fp, \"您的输入不符合规范，请重新输入\\n\");\n\tout_show();\n}\n\nvoid tips()\n{\n\tprintf(\"操作成功\\n\");\n\tfprintf(fp, \"操作成功\\n\");\n }\n\n void goods_in()\n{\n\tout_add1();\n\tout_add2();\n\tint i;\n\t//在goods中查找名为nam的货物\n\tfor(i = 0; i <= t; ++i)\n\t\tif(!strcmp(nam, goods[i].name))//找到时进行增加库存操作\n\t\t{\n\t\t\tgoods[i].count+=cnt;\n\t\t\tbreak;\n\t\t}\n\t//goods中没有名为nam货物时进行新增商品操作\n\tif(i == i+1)\n\t{\n\t\tt++;\n\t\tstrcpy(goods[t].name, nam);\n\t\tgoods[t].count = cnt;\n\t}\n}\n//出货\nvoid goods_out()\n{\n\tout_del1();\n\tout_del2();\n\tint i;\n\t//在goods中查找名为nam的货物\n\tfor(i = 0; i <= t; ++i)\n\t\tif(!strcmp(nam, goods[i].name))\t//找到时进行出货操作\n\t\t{\n\t\t\t//库存富余时进行减少库存操作\n\t\t\tif((goods[i].count-cnt)>0)\n\t\t\t{\n\t\t\t\tgoods[i].count-=cnt;\n\t\t\t\ttips();\n\t\t\t}\n\t\t\telse\n\t\t\t\t//库存刚好时进行删除商品操作\n\t\t\t\tif((goods[i].count-cnt)==0)\n\t\t\t\t{\n\t\t\t\t\tgoods[i].count-=cnt;\n\t\t\t\t\tt--;\n\t\t\t\t\ttips();\n\t\t\t\t}else\n\t\t\t\t\t//库存不足时不出货并提示操作失败\n\t\t\t\t\tif((goods[i].count-cnt)<0)\n\t\t\t\t\t\tprintf(\"%s数量不足，出货失败\\n\", nam);\n\t\t\tbreak;\n\t\t}\n\t//goods中没有名为nam货物时不出货并提示操作失败\n\tif(i == i+1)\n\t{\n\t\tprintf(\"查无此货，出货失败\\n\");\n\t\tfprintf(fp, \"查无此货，出货失败\\n\");\n\t}\n\n\n}\n//查询\nvoid goods_find()\n{\n\t\tchar m;\n\t\tout_show();\n\t\tscanf(\"%c\", &m);\n\t\t//限制m为十进制数字\n\t\twhile(!isdigit(m))\n\t\t{\n\t\t\tout_errorshow();\n\t\t\tscanf(\"%c\", &m);\n\t\t}\n\t\t//限制m为1、2\n\t\twhile(m>=63||m<=60)\n\t\t{\n\t\t\tout_errorshow();\n\t\t\tscanf(\"%c\", &m);\n\t\t}\n\t\tif(m == '1')\tshow_goods();\n\t\telse if(m == '2') find_goods();\n }\n//选择操作模块\nvoid out_tip()\n{\n\tprintf(\"若要进货请输入1\\n若要出货请输入2\\n若要查询请输入3\\n\");\n}\nvoid out_errortip()\n{\n\tprintf(\"您的输入不符合规范，请重新输入\\n\");\n\tout_tip();\n}\nvoid Try()\n{\n\tout_tip();\n\tscanf(\"%c\", &n);\n\t//限制输入为数字\n\twhile(!isdigit(n))\n\t{\n\t\tout_errortip();\n\t\tscanf(\"%c\", &n);\n\t}\n\t//限制输入数字为1、2、3\n\twhile(n>=64||n<=60)\n\t{\n\t\tout_errortip();\n\t\tscanf(\"%c\", &n);\n\t}\n\t//n为1时进入进货模块\n\tif(n == '1')\n\t{\n\t\tgoods_in();\n\t\ttips();\n\t}\n\telse\n\t\t//n为2时进入出货模块\n\t\tif(n == '2') goods_out();\n\t\telse\n\t\t\t//n为3时进入查询模块\n\t\t\tif(n == '3') goods_find();\n}\n\nvoid _end()\n{\n\tprintf(\"开始本次系统使用请输入1，结束本次系统使用请输入0\\n\");\n\tfprintf(fp, \"开始本次系统使用请输入1，结束本次系统使用请输入0\\n\");\n}\nint main()\n{\n\tint p;\n\tfp = fopen(\"C:\\tmp\\system_log.txt\", \"a\");//系统日志文件\n\t_end();\n\tscanf(\"%d\", &p);\n\twhile(p)\n\t{\n\t\tTry();\n\t\tprintf(\"——————————————————————\\n\");\n\t\t_end();\n\t}\n\tprintf(\"感谢使用该仓库管理系统，不足之处欢迎指正\\n\");\n\tfprintf(fp, \"感谢使用该仓库管理系统，不足之处欢迎指正\\n\");\n\tfclose(fp);\n\treturn 0;\n}\n",
            1593316273.3205025,
            100,
            "In file included from main.cpp:35:0:\nsource.cpp: In function ‘int main()’:\nsource.cpp:241:13: warning: unknown escape sequence: '\\s'\n  fp = fopen(\"C:\\tmp\\system_log.txt\", \"a\");//系统日志文件\n             ^\nmain.cpp: In function ‘void test2(const Matrix&)’:\nmain.cpp:89:10: error: ‘MatrixSizesDoNotMatchException’ does not name a type\n   catch (MatrixSizesDoNotMatchException & ex) {\n          ^\nmain.cpp: In function ‘int main()’:\nmain.cpp:95:5: error: redefinition of ‘int main()’\n int main() {\n     ^\nIn file included from main.cpp:35:0:\nsource.cpp:238:5: note: ‘int main()’ previously defined here\n int main()\n     ^\nsource.cpp: In function ‘void find_goods()’:\nsource.cpp:33:18: warning: ignoring return value of ‘int scanf(const char*, ...)’, declared with attribute warn_unused_result [-Wunused-result]\n  scanf(\"%s\",nam) ;\n                  ^\nsource.cpp: In function ‘void out_add1()’:\nsource.cpp:57:18: warning: ignoring return value of ‘int scanf(const char*, ...)’, declared with attribute warn_unused_result [-Wunused-result]\n  scanf(\"%s\",nam) ;\n                  ^\nsource.cpp: In function ‘void out_add2()’:\nsource.cpp:64:19: warning: ignoring return value of ‘int scanf(const char*, ...)’, declared with attribute warn_unused_result [-Wunused-result]\n  scanf(\"%d\", &cnt);\n                   ^\nsource.cpp: In function ‘void out_del1()’:\nsource.cpp:84:18: warning: ignoring return value of ‘int scanf(const char*, ...)’, declared with attribute warn_unused_result [-Wunused-result]\n  scanf(\"%s\",nam) ;\n                  ^\nsource.cpp: In function ‘void out_del2()’:\nsource.cpp:91:19: warning: ignoring return value of ‘int scanf(const char*, ...)’, declared with attribute warn_unused_result [-Wunused-result]\n  scanf(\"%d\", &cnt);\n                   ^\nsource.cpp: In function ‘void goods_find()’:\nsource.cpp:177:18: warning: ignoring return value of ‘int scanf(const char*, ...)’, declared with attribute warn_unused_result [-Wunused-result]\n   scanf(\"%c\", &m);\n                  ^\nsource.cpp:182:19: warning: ignoring return value of ‘int scanf(const char*, ...)’, declared with attribute warn_unused_result [-Wunused-result]\n    scanf(\"%c\", &m);\n                   ^\nsource.cpp:188:19: warning: ignoring return value of ‘int scanf(const char*, ...)’, declared with attribute warn_unused_result [-Wunused-result]\n    scanf(\"%c\", &m);\n                   ^\nsource.cpp: In function ‘void Try()’:\nsource.cpp:206:17: warning: ignoring return value of ‘int scanf(const char*, ...)’, declared with attribute warn_unused_result [-Wunused-result]\n  scanf(\"%c\", &n);\n                 ^\nsource.cpp:211:18: warning: ignoring return value of ‘int scanf(const char*, ...)’, declared with attribute warn_unused_result [-Wunused-result]\n   scanf(\"%c\", &n);\n                  ^\nsource.cpp:217:18: warning: ignoring return value of ‘int scanf(const char*, ...)’, declared with attribute warn_unused_result [-Wunused-result]\n   scanf(\"%c\", &n);\n                  ^\nsource.cpp: In function ‘int main()’:\nsource.cpp:243:17: warning: ignoring return value of ‘int scanf(const char*, ...)’, declared with attribute warn_unused_result [-Wunused-result]\n  scanf(\"%d\", &p);\n                 ^\n"
        ],
        [
            "10.2 (C++)",
            "谢浩林",
            "catch (NonPositiveValueException & ex) {\n            cout << \"caught: NonPositiveValueException\" << endl ;\n        }\n\n        catch (out_of_range &ex){\n            cout << \"caught: out_of_range\" << endl ;\n        }\n",
            1593656260.5204017,
            100,
            "# 答案正确"
        ],
        [
            "15.1 (C++)",
            "谢浩林",
            "\n#include <iostream>\n#include <string>\n#include <vector>\n\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n\nclass Table {\n    private:\n    string head ;\n    vector <string> s[3] ;\n    int r ;\n    public:\n    Table() {\n        head = \"[]\" ;\n        r = 0 ;\n    }\n    void addCol(string a) {\n        head.pop_back() ;\n        head.push_back('\\'') ;\n        head+=a ;\n        head += \"\\',]\" ;\n    }\n    vector <string>  & operator [] (int a){\n        r ++ ;\n        return s[a];\n    }\n    string json() const{\n        string io ;\n        io+= \"{\" ;\n        io += \"\\n\\t\" ;\n        io += \"headers: \" ;\n        io += head ;\n        io += \",\\n\\trows: [\" ;\n        for(int i = 0 ; i < r ; i ++) {\n            io+=\"\\n\\t\\t[]\" ;\n            for(int k = 0 ; k < s[i].size() ; k ++){\n            io.pop_back() ;\n            io.push_back('\\'') ;\n            io +=s[i][k] ;\n            io += \"\\',]\" ;\n            }\n\t\t\tio.push_back(',') ;\n        }\n        io +=\"\\n\\t],\" ;\n        io +=\"\\n}\" ;\n        return io ;\n    }\n} ;\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Integer\n{\n\tint value;\n\tstatic vector<Integer*> all;\n\npublic:\n\tInteger(int v=0) : value(v) {\n\t\tall.push_back(this);\n\t}\n\n\t~Integer() {\n\t\tfor (int i = 0; i < all.size(); ++ i) {\n\t\t\tif (all[i] == this) {\n\t\t\t\tall[i] = all[all.size()-1];\n\t\t\t\tall.pop_back();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\toperator int() { return value; }\n\n\tstatic void increase_all(int inc) {\n\t\tfor (int i = 0; i < all.size(); ++ i) {\n\t\t\tall[i]->value += inc;\n\t\t}\n\t}\n\n\tfriend istream & operator >> (istream & in, Integer & integer);\n};\n\nvector<Integer*> Integer::all;\n\nistream & operator >> (istream & in, Integer & integer) {\n\tin >> integer.value;\n\treturn in;\n}\n",
            1594266632.2181706,
            100,
            "# 答案正确"
        ],
        [
            "2020-07-09 LAB",
            "谢浩林",
            "\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Integer {\n    static vector <int> val ;\n    static int id ;\n    int idd ;\n    public:\n    Integer() {\n        val.push_back(0) ;\n        idd = id ;\n        id ++ ;\n    }\n    Integer(int v) {\n        val.push_back(v) ;\n        idd = id ;\n        id ++ ;\n    }\n    static void increase_all(const int v) {\n        for(int i = 0 ; i < id ; i ++) {\n            val[i] += v ;\n        }\n    }\n    static void increase_all(Integer &m) {\n        for(int i = 0 ; i < id ; i ++) {\n            val[i] += m.get_val();\n        }\n    }\n    int get_val() {\n        return val[idd] ;\n    }\n} ;\n\nvector <int> Integer :: val;\nint Integer :: id ;\n\nistream &operator >> (istream &in , Integer &m) {\n    int v ;\n    in >> v ;\n    Integer tmp(v);\n    m = tmp ;\n    return in ;\n}\n\nostream &operator << (ostream &out,Integer &m) {\n    out << m.get_val();\n    return out ;\n}\n",
            1594262373.998032,
            100,
            "# 答案正确"
        ],
        [
            "A.1 (C++)",
            "谢浩林",
            "\n\n    Node <E> * get_next(Node <E> *node) const {\n        if(node == tail) return NULL;\n        Node <E> * prev = head;\n        Node <E> * now  = head;\n        Node <E> * ge  =  head -> next_node(NULL);\n        if(node == head) return ge ;\n        while(1) {\n            if(ge == NULL) return NULL ;\n            prev = ge ;\n            ge = ge -> next_node(now) ;\n            if(prev == node) return ge ;\n            now = prev ;\n        }\n    }\n    Node <E> *get_prev(Node <E> *node) const {\n        if(node == head) return NULL ;\n        Node <E> * next = tail;\n        Node <E> * now  = tail;\n        Node <E> * ge  =  tail -> prev_node(NULL);\n        if(node == tail) return ge ;\n        while(1) {\n            if(ge == NULL ) return NULL ;\n            next = ge ;\n            ge = ge -> prev_node(now) ;\n            if(next == node) return ge ;\n            now = next ;\n        }\n    }\n    Node<E> * get_node(int index) const {\n\t\tif (index < 0 || index >= _size)\n\t\t\tthrow NotSuchElementException();\n\t\tif (index < _size / 2) {\n\t\t\tNode<E> * node = head;\n\t\t\tI(i, index) node = get_next(node);\n\t\t\treturn node;\n\t\t}\n\t\telse {\n\t\t\tNode<E> * node = tail;\n\t\t\tI(i, (_size-1-index)) {\n                node = get_prev(node);\n\t\t\t}\n\t\t\treturn node;\n\t\t}\n\t}\n\tE & get(int index) const {\n\t\tNode<E> * node = get_node(index);\n\t\treturn node->element;\n\t}\n\tvoid set(int index, const E & e) {\n\t\tNode<E> * node = get_node(index);\n\t\tnode->element = e;\n\t}\n\n\tE & getFirst() const {\n\t\treturn get(0);\n\t}\n\n\tE & getLast() const {\n\t\treturn get(_size - 1);\n\t}\n\tvoid remove (int index) {\n\t\tNode<E> * node = get_node(index);\n\t\tNode<E> * prev_node = get_prev(node);\n\t\tNode<E> * next_node = get_next(node) ;\n\t\tif (prev_node != 0) prev_node->update_next_node(node, next_node);\n\t\tif (next_node != 0) next_node->update_prev_node(node,prev_node);\n\t\tif (prev_node == 0) head = next_node;\n\t\tif (next_node == 0) tail = prev_node;\n\t\tdelete node;\n\t\t-- _size;\n\t}\n\n\tvoid removeFirst () {\n\t\tremove(0);\n\t}\n\n\tvoid removeLast () {\n\t\tremove(_size-1);\n\t}\n    void add(int index, const E & e) {\n\t\tif (index < 0 || index > _size)\n\t\t\tthrow NotSuchElementException();\n\t\tNode<E> * node = new Node<E>();\n\t\tnode->element = e;\n\t\tNode<E> * next_node = (index == _size ? 0 : get_node(index));\n\t\tNode<E> * prev_node ;\n\t\tif(index >= 1)prev_node = (next_node == 0 ? tail : get_node(index-1));\n\t\telse prev_node = (next_node == 0 ? tail : NULL);\n\t\tnode -> update_prev_and_next_node(next_node,prev_node) ;\n\t\tif (prev_node != 0) prev_node->update_next_node(next_node,node);\n\t\tif (next_node != 0) next_node->update_prev_node(prev_node,node);\n\t\tif (prev_node == 0) head = node;\n\t\tif (next_node == 0) tail = node;\n\t\t++ _size;\n\t}\n\n    void addFirst (const E & e) {\n\t\tadd(0, e);\n\t}\n\n\tvoid addLast (const E & e) {\n\t\tadd(_size, e);\n\t}\n\n\t/*void addFirst (const E & e) {\n\t\tNode<E> * node = new Node <E> () ;\n\t\tnode -> element = e ;\n\t\tif(_size == 0) {\n            node->update_prev_and_next_node(NULL,NULL) ;\n            head = node ;\n            tail = node ;\n\t\t}\n\t\tnode->update_prev_and_next_node(NULL,head) ;\n\t\thead = node ;\n\t\t++ _size ;\n\t}\n\n\tvoid addLast (const E & e) {\n\t\tNode<E> * node = new Node <E> () ;\n\t\tnode -> element = e ;\n\t\tif(_size == 0) {\n            node->update_prev_and_next_node(NULL,NULL) ;\n            head = node ;\n            tail = node ;\n\t\t}\n\t\tnode->update_prev_and_next_node(tail,NULL) ;\n\t\ttail = node ;\n\t\t++ _size ;\n\t}*/\n\tvoid print() {\n        Node <E> *node = head;\n        I(i,_size){\n            cout << node -> element  << \" \" << get_node(i) -> element<<endl ;\n            node =  get_next(node) ;\n        }\n\t}\n\tvoid clear() {\n\t\twhile (_size > 0) removeFirst();\n\t}\n\n\tvoid addAll(const LinkedList & list, int index=-1) {\n\t\tif (index == -1) index = _size;\n\t\tI(i, list._size) {\n\t\t\tNode<E> * node = list.get_node(i);\n\t\t\tadd(index + i, node->element);\n\t\t}\n\t}\n\n\n\tLinkedList(const LinkedList & list) : _size(0), head(0), tail(0) {\n\t\taddAll(list);\n\t}\n\n\tLinkedList & operator = (const LinkedList & list) {\n\t\tclear();\n\t\taddAll(list);\n\t\treturn list;\n\t}\n\n\t~LinkedList() {\n\t\tclear();\n\t}\n\tint indexOf(const E & e) const {\n\t\tNode<E> * node = head;\n\t\tI(i, _size) {\n\t\t\tif (node->element == e) return i;\n\t\t\tnode = get_next(node);\n\t\t}\n\t\treturn -1;\n\t}\n\n\tint lastIndexOf(const E & e) const {\n\t\tNode<E> * node = tail;\n\t\tI(i, _size) {\n\t\t\tif (node->element == e) return i;\n\t\t\tnode = get_prev(node);\n\t\t}\n\t\treturn -1;\n\t}\n\tbool contains(const E & e) const {\n\t\treturn indexOf(e) >= 0;\n\t}\n\n\tvoid removeFirstOccurrence(const E & e) {\n\t\tint index = indexOf(e);\n\t\tif (index == -1)\n\t\t\tthrow NotSuchElementException();\n\t\tremove(index);\n\t}\n\n\tvoid removeLastOccurrence(const E & e) {\n\t\tint index = lastIndexOf(e);\n\t\tif (index == -1)\n\t\t\tthrow NotSuchElementException();\n\t\tremove(index);\n\t}",
            1594363294.4606066,
            100,
            "# 答案正确"
        ],
        [
            "A.2 (C++)",
            "谢浩林",
            "template <typename E>\nvoid LinkedList<E>:: removeAll(const E & e) {\n    if (indexOf(e) == -1)\n        throw NotSuchElementException();\n        int index ;\n        while(1) {\n            index = indexOf(e) ;\n            if(indexOf(e) == -1) return ;\n            remove(index) ;\n        }\n}",
            1594865201.0302737,
            100,
            "# 答案正确"
        ],
        [
            "A.4 (C++)",
            "谢浩林",
            "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <stdexcept>\n#include <cstring>\nusing namespace std;\n\n#define I(i,n) for (size_t i = 0; i < n; ++ i)\n\nclass NoSuchKeyException {};\n\nsize_t circular_shift(size_t bits, int shift_bits) {\n\tconst int num_bits = 8 * sizeof(size_t);\n\tshift_bits = shift_bits % num_bits;\n\treturn bits << shift_bits | bits >> (num_bits - shift_bits);\n}\n\nsize_t hash_function(const string & key) {\n\tsize_t code = 0;\n\tI(i, key.size())\n\t\tcode ^= circular_shift(key[i], i * 5);\n\treturn code;\n}\n\nclass turn {\n    string val ;\n    public:\n    turn(string val_) {\n        val = val_ ;\n    }\n    turn (int val_) {\n        val = to_string(val_) ;\n    }\n    operator int() {\n    int get = 0;\n    for(int i = 0 ; i < val.size() ; i ++) {\n        get *= 10 ;\n        get += val[i] - '0';\n    }\n    return get ;\n    }\n    operator string() {\n        return val ;\n    }\n} ;\n\nclass HT\n{\n\tclass Tuple\n\t{\n\tpublic:\n\t\tstring key;\n\t\tstring val;\n\t\tbool in_use;\n\n\t\tTuple() : in_use(false) {}\n\t};\n\n\tvector<Tuple> tuples;\n\tsize_t _size;\n\n\tsize_t canonical_index(const string & key) const {\n\t\tsize_t hash_code = hash_function(key); // needs hash_function(K)\n\t\treturn hash_code % tuples.size();\n\t}\n\n\t// the returned tuple is either empty or with the same key\n\tsize_t indexOfKey(const string & key) const {\n\t\tsize_t index = canonical_index(key);\n\t\twhile (true) { // will enter a dead loop if there is not empty tuple\n\t\t\tif (! tuples[index].in_use) return index;\n\t\t\tif (tuples[index].key == key) return index;\n\t\t\tindex = (index + 1) % tuples.size();\n\t\t}\n\t}\n\npublic:\n\tHT() : _size(0) {\n\t\ttuples.resize(2);\n\t}\n\n\n\tturn  operator [] (const string & key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use)\n\t\t\tthrow NoSuchKeyException();\n\t\tturn now(tuples[index].val);\n\t\tcout << indexOfKey(key) << \"#\"<< endl ;\n\t\treturn now ;\n\t}\n\n\tturn  operator [] (const int & key_) const {\n        string key = to_string(key_) ;\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use)\n\t\t\tthrow NoSuchKeyException();\n\t\tturn now(tuples[index].val);\n\t\tcout << indexOfKey(key) << \"#\"<< endl ;\n\t\treturn now ;\n\t}\n\n\n\tvoid put(const string & key, const string & val) {\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].key = key;\n\t\ttuples[index].val = val;\n\t\tif (tuples[index].in_use) return;\n\t\ttuples[index].in_use = true;\n\t\t++ _size;\n\t\t// make sure empty > size / 2\n\t\tif (2 * _size > tuples.size())\n\t\t\t_double_tuples();\n\t}\n\tvoid put(const int & key, const int & val) {\n        string key_ = to_string (key) ;\n        string val_ = to_string (val) ;\n\t\tsize_t index = indexOfKey(key_);\n\t\ttuples[index].key = key_;\n\t\ttuples[index].val = val_;\n\t\tif (tuples[index].in_use) return;\n\t\ttuples[index].in_use = true;\n\t\t++ _size;\n\t\t// make sure empty > size / 2\n\t\tif (2 * _size > tuples.size())\n\t\t\t_double_tuples();\n\t}\n\tvoid put(const string & key, const int & val) {\n        string val_ = to_string (val) ;\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].key = key;\n\t\ttuples[index].val = val_;\n\t\tif (tuples[index].in_use) return;\n\t\ttuples[index].in_use = true;\n\t\t++ _size;\n\t\t// make sure empty > size / 2\n\t\tif (2 * _size > tuples.size())\n\t\t\t_double_tuples();\n\t}\n\tvoid put(const int & key, const string & val) {\n        string key_ = to_string (key) ;\n\t\tsize_t index = indexOfKey(key_);\n\t\ttuples[index].key = key_;\n\t\ttuples[index].val = val;\n\t\tif (tuples[index].in_use) return;\n\t\ttuples[index].in_use = true;\n\t\t++ _size;\n\t\t// make sure empty > size / 2\n\t\tif (2 * _size > tuples.size())\n\t\t\t_double_tuples();\n\t}\n\n\tvoid _double_tuples() {\n\t\tvector<Tuple> non_empty_tuples;\n\t\tI(i, tuples.size())\n\t\t\tif (tuples[i].in_use)\n\t\t\t\tnon_empty_tuples.push_back(tuples[i]);\n\t\tclear();\n\t\ttuples.resize(tuples.size() * 2);\n\t\tI(i, non_empty_tuples.size())\n\t\t\tput(non_empty_tuples[i].key, non_empty_tuples[i].val);\n\t}\n\n\n\tsize_t size() const { return _size; }\n\n\tvoid clear() {\n\t\tI(i, tuples.size())\n\t\t\ttuples[i].in_use = false;\n\t\t_size = 0;\n\t}\n\n\n};\n\n\n",
            1595140959.0457222,
            100,
            "# 答案不正确\n\n# 随机输入:\n5 95 8 70 84 35 48 68 \n\n# 参考答案:\n4\n95\n70\n35\n68\n\n\n# 我的答案:\n4\n5#\n95\n0#\n70\n1#\n35\n4#\n68\n"
        ],
        [
            "A.5 (C++)",
            "谢浩林",
            "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <stdexcept>\n#include <cstring>\nusing namespace std;\n\n#define I(i,n) for (size_t i = 0; i < n; ++ i)\nclass NO {} ;\n\nclass Tuple {\n    public:\n    int key2 ;\n    string val ;\n};\n\nint turn(const string &val){\n        int get = 0;\n        for(int i = 0 ; i < val.size() ; i ++) {\n            get *= 10 ;\n            get += val[i] - '0';\n        }\n        return get ;\n}\n\nclass HT {\n    vector<Tuple> tuples;\n\n    size_t indexof(const int &key) const {\n        I(i , tuples.size()) if(tuples[i].key2 == key) return i ;\n        return -1 ;\n    }\n    size_t indexof(const string &key) const {\n        int key2 = turn(key) ;\n        I(i , tuples.size()) if(tuples[i].key2 == key2) return i ;\n        return -1 ;\n    }\n    public:\n\n    bool constains(const int  &key) const {\n        return indexof(key) != -1 ;\n    }\n    void put(const int &key , const string & val) {\n        size_t index = indexof(key) ;\n        if(index == -1) {\n            Tuple tuple ;\n            tuple.key2 = key ;\n            tuple.val =val ;\n            tuples.push_back(tuple) ;\n        }\n        else {\n            tuples[index].val = val ;\n        }\n    }\n    void put(const string &key_ , const string & val) {\n        int key = turn(key_) ;\n        size_t index = indexof(key) ;\n        if(index == -1) {\n            Tuple tuple ;\n            tuple.key2 = key ;\n            tuple.val =val ;\n            tuples.push_back(tuple) ;\n        }\n        else {\n            tuples[index].val = val ;\n        }\n    }\n    class TupleRef {\n        public :\n        HT *ht ;\n        Tuple * tu ;\n        int key2 ;\n\n        TupleRef(HT *ht , Tuple * tu  ,int key2) : ht(ht) , tu(tu) ,  key2(key2) {};\n\n        operator string() const {\n            if(tu == 0) throw NO() ;\n            return tu -> val ;\n        }\n\n        operator int() const{\n            if(tu == 0) throw NO() ;\n            int get = 0;\n            for(int i = 0 ; i < tu -> val.size() ; i ++) {\n            get *= 10 ;\n            get += tu -> val[i] - '0';\n            }\n            return get ;\n        }\n\n        TupleRef & operator = (const string & val) {\n            if(tu== 0) ht -> put(key2,val) ;\n            else tu-> val = val ;\n            return *this ;\n        }\n        TupleRef & operator = (const int & val_) {\n            const string &val = to_string(val_) ;\n            if(tu== 0) ht -> put(key2,val) ;\n            else tu-> val = val ;\n            return *this ;\n        }\n        };\n        TupleRef operator [] (const int &key) {\n            size_t index = indexof(key) ;\n            if(index == -1) {\n                return TupleRef(this , 0 ,key) ;\n            }\n            return TupleRef(this, &tuples[index],key) ;\n        }\n         TupleRef operator [] (const string &key_) {\n            int key = turn(key_) ;\n            size_t index = indexof(key) ;\n            if(index == -1) {\n                return TupleRef(this , 0 ,key) ;\n            }\n            return TupleRef(this, &tuples[index],key) ;\n        }\n        size_t size() const{\n        return tuples.size() ;\n        }\n\n} ;\n",
            1595294848.0701218,
            100,
            "# 答案正确"
        ],
        [
            "A.3 (C++)",
            "谢浩林",
            "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <stdexcept>\nusing namespace std;\n#include <sstream>\n\n#define I(i,n) for (size_t i = 0; i < n; ++ i)\n\nclass NoSuchKeyException {};\n\nsize_t circular_shift(size_t bits, int shift_bits) {\n\tconst int num_bits = 8 * sizeof(size_t);\n\tshift_bits = shift_bits % num_bits;\n\treturn bits << shift_bits | bits >> (num_bits - shift_bits);\n}\n\nsize_t hash_function(const string & key) {\n\tsize_t code = 0;\n\tI(i, key.size())\n\t\tcode ^= circular_shift(key[i], i * 5);\n\treturn code;\n}\n\ntemplate <typename K>\nclass HT\n{\n\tclass Tuple\n\t{\n\tpublic:\n\t\tint key;\n\t\tK val;\n\t\tbool in_use;\n\n\t\tTuple() : in_use(false) {}\n\t};\n\n\tvector<Tuple> tuples;\n\tsize_t _size;\n\n\tsize_t canonical_index(const int & key) const {\n        string key_ = to_string(key) ;\n\t\tsize_t hash_code = hash_function(key_); // needs hash_function(K)\n\t\treturn hash_code % tuples.size();\n\t}\n\n\t// the returned tuple is either empty or with the same key\n\tsize_t indexOfKey(const int & key) const {\n\t\tsize_t index = canonical_index(key);\n\t\twhile (true) { // will enter a dead loop if there is not empty tuple\n\t\t\tif (! tuples[index].in_use) return index;\n\t\t\tif (tuples[index].key == key) return index;\n\t\t\tindex = (index + 1) % tuples.size();\n\t\t}\n\t}\n\npublic:\n\tHT() : _size(0) {\n\t\ttuples.resize(2);\n\t}\n\n\tbool containsKey(const int & key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\treturn tuples[index].in_use;\n\t}\n\n\tconst K & operator [] (const int & key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use)\n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples[index].val;\n\t}\n\n\tK & operator [] (const int & key) {\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use)\n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples[index].val;\n\t}\n\n\tvoid put(const int & key, const K & val) {\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].key = key;\n\t\ttuples[index].val = val;\n\t\tif (tuples[index].in_use) return;\n\t\ttuples[index].in_use = true;\n\t\t++ _size;\n\t\t// make sure empty > size / 2\n\t\tif (2 * _size > tuples.size())\n\t\t\t_double_tuples();\n\t}\n\n\tvoid _double_tuples() {\n\t\tvector<Tuple> non_empty_tuples;\n\t\tI(i, tuples.size())\n\t\t\tif (tuples[i].in_use)\n\t\t\t\tnon_empty_tuples.push_back(tuples[i]);\n\t\tclear();\n\t\ttuples.resize(tuples.size() * 2);\n\t\tI(i, non_empty_tuples.size())\n\t\t\tput(non_empty_tuples[i].key, non_empty_tuples[i].val);\n\t}\n\n\tstatic bool _between(size_t hole, size_t canonical, size_t tuple_index) {\n\t\tif (hole < tuple_index)\n\t\t\treturn canonical > hole && canonical <= tuple_index;\n\t\telse\n\t\t\treturn canonical > hole || canonical <= tuple_index;\n\t}\n\n\tvoid remove(const int & key) {\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use)\n\t\t\tthrow NoSuchKeyException();\n\t\ttuples[index].in_use = false;\n\t\t-- _size;\n\t\t// if there is a hole between a tuple and its canonical position\n\t\t// move the tuple to the hole\n\t\tsize_t hole = index;\n\t\tsize_t tuple_index = hole;\n\t\twhile (true) {\n\t\t\ttuple_index = (tuple_index + 1) % tuples.size();\n\t\t\tif (! tuples[tuple_index].in_use) return;\n\t\t\tsize_t canonical = canonical_index(tuples[tuple_index].key);\n\t\t\tif (_between(hole, canonical, tuple_index)) continue;\n\t\t\ttuples[hole] = tuples[tuple_index];\n\t\t\thole = tuple_index;\n\t\t\ttuples[hole].in_use = false;\n\t\t}\n\t}\n\n\tsize_t size() const { return _size; }\n\n\tvoid clear() {\n\t\tI(i, tuples.size())\n\t\t\ttuples[i].in_use = false;\n\t\t_size = 0;\n\t}\n\n    vector <int> getKeys() {\n        vector <int> keys ;\n        I(i,tuples.size()) {\n            if(tuples[i].in_use == true) keys.push_back(tuples[i].key) ;\n        }\n        return keys ;\n    }\n\n\ttemplate <typename K2>\n\tfriend ostream & operator << (ostream & out, const HT<K2> & dict);\n\n\ttemplate <typename K2>\n\tfriend istream & operator >> (istream & in, HT<K2> & dict);\n\n\tvoid _inspect() const {\n\t\tI(i, tuples.size())\n\t\t\tif (tuples[i].in_use)\n\t\t\t\tcout << \"#\" << i << \" C\" << canonical_index(tuples[i].key)\n\t\t\t\t\t<< \" \" << tuples[i].key << \" \" << tuples[i].val << endl;\n\t}\n};\n\ntemplate <typename K>\nostream & operator << (ostream & out, const HT<K> & dict) {\n\tout << dict.size() << endl;\n\tI(i, dict.tuples.size())\n\t\tif (dict.tuples[i].in_use)\n\t\t\tout << dict.tuples[i].key << \"\\t\" << dict.tuples[i].val << endl;\n\treturn out;\n}\n\ntemplate <typename K>\nistream & operator >> (istream & in, HT<K> & dict) {\n\tdict.clear();\n\tsize_t size;\n\tin >> size;\n\tI(i, size) {\n\t\tint key;\n\t\tK val;\n\t\tin >> key >> val;\n\t\tdict.put(key, val);\n\t}\n\treturn in;\n}",
            1595470468.5621705,
            100,
            "# 答案正确"
        ]
    ],
    "table_name": "答案"
}