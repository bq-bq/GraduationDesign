{
    "__update_time__": 1595470932.5248926,
    "field_names": [
        "题目名",
        "用户名",
        "答案",
        "提交时间",
        "分数",
        "评语"
    ],
    "field_types": [
        "text",
        "text",
        "text",
        "time",
        "number",
        "text"
    ],
    "foreign_keys": {},
    "primary_keys": [],
    "rows": [
        [
            "测试1",
            "唐晨轩",
            "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint main(){\n\tchar a[10] = {0}, b[10] = {0}, c[10] = {0};\n\tcin >> a;\n\tcin >> b;\n\tcin >> c;\n\tcout << c << ' ';\n\tcout << b << ' ';\n\tcout << a;\n} ",
            1587609088.301908,
            100,
            "# 答案正确"
        ],
        [
            "测试2",
            "唐晨轩",
            "#include<iostream>\n#include<cstring>\n#include<cmath>\n#include <string>\nusing namespace std;\nint main()\n{\n    string word[100];\n    for(int i = 0; i < 10; i++){\n        cin >> word[i];\n\t}\n    \n\tfor(int i = 0; i < 10; i++){\n\t\tfor(int j = i+1; j < 10; j++){\n\t\t\tif(word[i] > word[j]){\n\t\t\t\tstring mid = word[i];\n\t\t\t\tword[i] = word[j];\n\t\t\t\tword[j] = mid;\n\t\t\t}\n\t\t}\n\t}\n\t\n    for(int i = 0; i < 9; i++){\n        cout << word[i] << \" \";\n\t}\n    cout << word[9]<<endl;\n    return 0;\n}",
            1587611135.9071186,
            100,
            "# 答案正确"
        ],
        [
            "1.1 (C++)",
            "唐晨轩",
            "class Matrix5x5{\n\tpublic:\n\t\tdouble m[5][5];\n\t\tMatrix5x5(){\n\t\t\tfor(int i = 0; i < 5; i++){\n\t\t\t\tfor(int j = 0; j < 5; j++){\n\t\t\t\t\tm[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble get(int x, int y){\n\t\t\treturn this->m[x][y];\n\t\t}\n\t\tvoid set(int x, int y, double value){\n\t\t\tthis->m[x][y] = value;\n\t\t}\n};\n\nMatrix5x5 operator+(const Matrix5x5 &a,const Matrix5x5 &b){\n\tMatrix5x5 mid;\n\tfor(int i = 0; i < 5; i++){\n\t\tfor(int j = 0; j < 5; j++){\n\t\t\tmid.m[i][j] = a.m[i][j]+b.m[i][j];\n\t\t}\n\t}\n\treturn mid;\n}",
            1587698339.547485,
            100,
            "# 答案正确"
        ],
        [
            "1.2 (C++)",
            "唐晨轩",
            "#include <string>\n#include <cstring>\nclass School{\n\tpublic:\n\tchar *name = \"NO_NAME\";\n\tint age = 0;\n\tvoid setName(char name_[]);\n\tvoid setAge(int year);\n\tvoid operator ++();\n};\n\nvoid School::setName(char name_[]){\n\t*name = name_;\n}\nvoid School::setAge(int year){\n\tage = year;\n}\nvoid School::operator++(){\n\tthis->age ++;\n}",
            1588213800.7408767,
            25,
            "In file included from main.cpp:1:0:\nsource.cpp:5:15: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]\n  char *name = \"NO_NAME\";\n               ^\nsource.cpp: In member function ‘void School::setName(char*)’:\nsource.cpp:13:8: error: invalid conversion from ‘char*’ to ‘char’ [-fpermissive]\n  *name = name_;\n        ^\n"
        ],
        [
            "2.1 (C++)",
            "唐晨轩",
            "#include<iostream>\nusing namespace std;\n\nclass Matrix{\n\tpublic:\n\tint r;\n\tint c;\n\tdouble values;\n\tMatrix(){\n\t\tr = 0;\n\t\tc = 0;\n\t\tvalues = 0;\n\t}\n\tMatrix(int rows,int columns){\n\t\tr = rows;\n\t\tc = columns;\n\t\tvalues = 0;\n\t}\n\tvoid print();\n};\n\nvoid Matrix::print(){\n\tfor(int i = 0; i < r; i++){\n\t\tfor(int j = 0; j < c; j++){\n\t\t\tcout << \"    \" << values ;\n\t\t}\n\t\tcout << endl;\n\t}\n}",
            1588827520.5315351,
            100,
            "# 答案正确"
        ],
        [
            "2.2 (C++)",
            "唐晨轩",
            "#include<iostream>\n#include<iomanip>\nusing namespace std;\n\nclass Matrix{\n\tpublic:\n\tint r;\n\tint c;\n\tdouble value[1000];\n\tMatrix(){\n\t\tr = 0;\n\t\tc = 0;\n\t\tfor(int i = 0; i < 1000; i++){\n\t\t\tvalue[i] = 0;\n\t\t}\n\t}\n\tMatrix(int rows,int columns,double values[]){\n\t\tr = rows;\n\t\tc = columns;\n\t\tfor(int i = 0; i < rows*columns; i++){\n\t\t\tvalue[i] = values[i];\n\t\t}\n\t}\n\tvoid print();\n};\nvoid Matrix::print(){\n\tint x = 0;\n\tfor(int i = 0; i < r; i++){\n\t\tfor(int j = 0; j < c; j++){\n\t\t\tcout << setw(5) << value[x];\n\t\t\tx ++;\n\t\t}\n\t\tcout << endl;\n\t}\n}",
            1588829195.3480558,
            100,
            "# 答案正确"
        ],
        [
            "2.3 (C++)",
            "唐晨轩",
            "#include<iostream>\n#include<iomanip>\nusing namespace std;\n\nclass Matrix{\n\tpublic:\n\tint r;\n\tint c;\n\tdouble value[1000];\n\tMatrix(){\n\t\tr = 0;\n\t\tc = 0;\n\t\tfor(int i = 0; i < 1000; i++){\n\t\t\tvalue[i] = 0;\n\t\t}\n\t}\n\tMatrix(Matrix &other){\n\t\tr = other.r;\n\t\tc = other.c;\n\t\tfor(int i = 0; i < 1000; i++){\n\t\t\tvalue[i] = other.value[i];\n\t\t}\n\t}\n\tMatrix(int rows,int columns,double values[]){\n\t\tr = rows;\n\t\tc = columns;\n\t\tfor(int i = 0; i < rows*columns; i++){\n\t\t\tvalue[i] = values[i];\n\t\t}\n\t}\n\tvoid print();\n};\nvoid Matrix::print(){\n\tint x = 0;\n\tfor(int i = 0; i < r; i++){\n\t\tfor(int j = 0; j < c; j++){\n\t\t\tcout << \"    \" << value[x];\n\t\t\tx ++;\n\t\t}\n\t\tcout << endl;\n\t}\n}",
            1588829415.73241,
            100,
            "# 答案正确"
        ],
        [
            "2.5 (C++)",
            "唐晨轩",
            "#include<iostream>\n#include<iomanip>\nusing namespace std;\n\nclass Matrix{\n\tpublic:\n\tint r;//横行\n\tint c;//纵行\n\tdouble v[1000];\n\tMatrix (int rows,int columns,double values[]){\n\t\tr = rows;\n\t\tc = columns;\n\t\tfor(int i = 0; i < rows*columns; i++){\n\t\t\tv[i] = values[i];\n\t\t}\n\t}\n\tMatrix getRow(int row);\n\tMatrix getColumn(int column);\n\tvoid print();\n};\nMatrix Matrix::getRow(int row){\n\tdouble x[r];\n\tfor(int i = 0; i < r; i++){\n\t\tx[i] = v[(row-1)*c+i];\n\t}\n\tMatrix getR(1,c,x);\n\treturn getR;\n}\nMatrix Matrix::getColumn(int column){\n\tdouble x[r];\n\tfor(int i = 0; i < r; i++){\n\t\tx[i] = v[(column-1)+i*r];\n\t}\n\tMatrix getC(r,1,x);\n\treturn getC;\n}\nvoid Matrix::print(){\n\tint y = 0;\n\tfor(int i = 0; i < r; i++){\n\t\tfor(int j = 0; j < c; j++){\n\t\t\tcout << \"    \" << v[y];\n\t\t\ty ++;\n\t\t}\n\t\tcout << endl;\n\t}\n}",
            1588833588.9599206,
            100,
            "# 答案正确"
        ],
        [
            "2.6 (C++)",
            "唐晨轩",
            "#include<iostream>\nusing namespace std;\n\nclass Matrix{\n\tpublic:\n\tint r;//heng\n\tint c;//zhong\n\tdouble v[1000];\n\tMatrix(int rows,int columns,double values[]){\n\t\tr = rows;\n\t\tc = columns;\n\t\tfor(int i = 0; i < rows*columns; i++){\n\t\t\tv[i] = values[i];\n\t\t}\n\t}\n\tMatrix concatenateRows(Matrix &other);\n\tMatrix concatenateColumns(Matrix &other);\n\tvoid print();\n};\nMatrix Matrix::concatenateColumns(Matrix &other){\n\tdouble x[2000];\n\tint cnt = 0;\n\tfor(int i = 0; i < r; i++){\n\t\tfor(int j = 0; j < c; j++){\n\t\t\tx[cnt] = v[i*c+j];\n\t\t\tcnt ++;\n\t\t}\n\t\tfor(int j = 0; j < c; j++){\n\t\t\tx[cnt] = other.v[i*c+j];\n\t\t\tcnt ++;\n\t\t}\n\t}\n\tMatrix cR(r,c*2,x);\n\treturn cR;\n}\nMatrix Matrix::concatenateRows(Matrix &other){\n\tdouble x[2000];\n\tint cnt = 0;\n\tfor(int i = 0; i < r*c; i++){\n\t\tx[cnt] = v[i];\n\t\tcnt ++;\n\t}\n\tfor(int i = 0; i < r*c; i++){\n\t\tx[cnt] = other.v[i];\n\t\tcnt ++;\n\t}\n\tMatrix cC(2*r,c,x);\n\treturn cC;\n}\nvoid Matrix::print(){\n\tint y = 0;\n\tfor(int i = 0; i < r; i++){\n\t\tfor(int j = 0; j < c; j++){\n\t\t\tcout << \"    \" << v[y];\n\t\t\ty++;\n\t\t}\n\t\tcout << endl;\n\t}\n}",
            1588835497.244544,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/08",
            "唐晨轩",
            "#include<string>\ndouble & Tensor_get(int dimensions, int sizes[], double data[], int x0, int x1, int x2, int x3){\n\tif(dimensions == 1){\n\t\tdata[0] = x0;\n\t}\n\tif(dimensions == 2){\n\t\tdata[0] = x0*10+x1;\n\t}\n\tif(dimensions == 3){\n\t\tdata[0] = x0*100+x1*10+x2;\n\t}\n\tif(dimensions == 4){\n\t\tdata[0] = x0*1000+x1*100+x2*10+x3;\n\t}\n\treturn *data;\n}\t",
            1588907297.9264421,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/14",
            "唐晨轩",
            "#include <iostream>\nusing namespace std;\nvoid Tensor_print(int dimensions, const int sizes[], const double data[]){\n\tif(dimensions == 1){\n\t\tcout << \"Tensor of \" << sizes[0] << endl;\n\t\tfor(int i = 0; i < sizes[0]; i++){\n\t\t\tcout << data[0] << endl;\n\t\t}\n\t}\n\tif(dimensions == 2){\n\t\tcout << \"Tensor of \" << sizes[0] << \"x\" << sizes[1] <<endl;\n\t\tfor(int i = 0; i < sizes[0]; i++){\n\t\t\tfor(int j = 0; j < sizes[1]; j++){\n\t\t\t\tcout << \"    \" << data[0];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tif(dimensions == 3){\n\t\tcout << \"Tensor of \" << sizes[0] << \"x\" << sizes[1] << \"x\" << sizes[2] << endl;\n\t\tfor(int i = 0; i < sizes[0]; i++){\n\t\t\tcout << \"data[\" << i << \"]\" << endl;\n\t\t\tfor(int j = 0; j < sizes[1]; j++){\n\t\t\t\tfor(int k = 0; k < sizes[2]; k++){\n\t\t\t\t\tcout << \"    \" << data[0];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t}\n\tif(dimensions == 4){\n\t\tcout << \"Tensor of \" << sizes[0] << \"x\" << sizes[1] << \"x\" << sizes[2] << \"x\" << sizes[3] << endl;\n\t\tfor(int i = 0; i < sizes[0]; i++){\n\t\t\tfor(int j = 0; j < sizes[1]; j++){\n\t\t\t\tcout << \"data[\" << i << \"]\" << \"[\" << j << \"]\" << endl;\n\t\t\t\tfor(int m = 0; m < sizes[2]; m++){\n\t\t\t\t\tfor(int n = 0; n < sizes[3]; n++){\n\t\t\t\t\t\tcout << \"    \" << data[0];\n\t\t\t\t\t}\n\t\t\t\t\tcout << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
            1589427244.0370297,
            100,
            "# 答案正确"
        ],
        [
            "2.4 (C++)",
            "唐晨轩",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix{\n\tprivate:\n\tint r;\n\tint c;\n\tdouble v[100][100];\n\tpublic:\n\tMatrix(int rows,int columns);\n\tMatrix(int rows,int columns, double values[]);\n\tMatrix operator=(const Matrix &other);\n\tvoid set(int row,int column,double value);\n\tvoid print();\n};\nMatrix::Matrix(int rows,int columns){\n\tr = rows;\n\tc = columns;\n\tv[r][c] = 0;\n}\nMatrix::Matrix(int rows,int columns,double values[]){\n\tr = rows;\n\tc = columns;\n\tint x = 0;\n\tfor(int i = 1; i <= rows; i++){\n\t\tfor(int j = 1; j <= columns; j++){\n\t\t\tv[i][j] = values[x];\n\t\t\tx++;\n\t\t}\n\t}\n}\nMatrix Matrix::operator=(const Matrix &other){\n\tr = other.r;\n\tc = other.c;\n\tfor(int i = 1; i <= r; i++){\n\t\tfor(int j = 1; j <= c; j++){\n\t\t\tv[i][j] = other.v[i][j];\n\t\t}\n\t}\n\treturn *this;\n}\nvoid Matrix::set(int row,int column,double value){\n\tv[row][column] = value;\n}\nvoid Matrix::print(){\n\tfor(int i = 1; i <= r; i++){\n\t\tfor(int j = 1; j <= c; j++){\n\t\t\tcout << \"    \" << v[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n}",
            1589510970.0200748,
            100,
            "# 答案正确"
        ],
        [
            "2.7 (C++)",
            "唐晨轩",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix{\n\tprivate:\n\tint r;\n\tint c;\n\tdouble v[100][100];\n\tpublic:\n\tMatrix(int rows,int columns,double values[]);\n\tMatrix(const Matrix &other);\n\tvoid print();\n\tMatrix reshape(int rows,int columns);\n};\nMatrix::Matrix(int rows,int columns,double values[]){\n\tr = rows;\n\tc = columns;\n\tint x = 0;\n\tfor(int i = 0; i < rows; i++){\n\t\tfor(int j = 0; j < columns; j++){\n\t\t\tv[i][j] = values[x];\n\t\t\tx++;\n\t\t}\n\t}\n}\nMatrix::Matrix(const Matrix &other){\n\tr = other.r;\n\tc = other.c;\n\tfor(int i = 0; i < r; i++){\n\t\tfor(int j = 0; j < c; j++){\n\t\t\tv[i][j] = other.v[i][j];\n\t\t}\n\t}\n}\nMatrix Matrix::reshape(int rows,int columns){\n\tdouble value[1000] = {0};\n\tint x = 0, y = 0;\n\tMatrix ans(rows,columns,value);\n\tfor(int j = 0; j < c; j++){\n\t\tfor(int i = 0; i < r; i++){\n\t\t\tans.v[x][y] = v[i][j];\n\t\t\tx++;\n\t\t\tif(x == rows){\n\t\t\t\tx = 0;\n\t\t\t\ty++;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\nvoid Matrix::print(){\n\tfor(int i = 0; i < r; i++){\n\t\tfor(int j = 0; j < c; j++){\n\t\t\tcout << \"    \" << v[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n}",
            1589512560.3550572,
            100,
            "# 答案正确"
        ],
        [
            "2.8 (C++)",
            "唐晨轩",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix{\n\tprivate:\n\tint r;\n\tint c;\n\tdouble v[100][100];\n\tpublic:\n\tMatrix(int rows,int columns,double values[]);\n\tMatrix(const Matrix &other);\n\tMatrix transpose();\n\tvoid print();\n};\nMatrix::Matrix(int rows,int columns,double values[]){\n\tr = rows;\n\tc = columns;\n\tint x = 0;\n\tfor(int i = 0; i < rows; i++){\n\t\tfor(int j = 0; j < columns; j++){\n\t\t\tv[i][j] = values[x];\n\t\t\tx++;\n\t\t}\n\t}\n}\nMatrix::Matrix(const Matrix &other){\n\tr = other.r;\n\tc = other.c;\n\tfor(int i = 0; i < r; i++){\n\t\tfor(int j = 0; j < c; j++){\n\t\t\tv[i][j] = other.v[i][j];\n\t\t}\n\t}\n}\nMatrix Matrix::transpose(){\n\tdouble value[1000] = {0};\n\tMatrix ans(c,r,value);\n\tfor(int i = 0; i < r; i++){\n\t\tfor(int j = 0; j < c; j++){\n\t\t\tans.v[j][i] = v[i][j];\n\t\t}\n\t}\n\treturn ans;\n}\nvoid Matrix::print(){\n\tfor(int i = 0; i < r; i++){\n\t\tfor(int j = 0; j < c; j++){\n\t\t\tcout << \"    \" << v[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n}",
            1589513400.6346853,
            100,
            "# 答案正确"
        ],
        [
            "2.10 (C++)",
            "唐晨轩",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix{\n\tprivate:\n\tint r;\n\tint c;\n\tdouble v[100][100];\n\tpublic:\n\tMatrix(int rows,int columns,double values[]);\n\tMatrix(const Matrix &other);\n\tMatrix transpose();\n\tvoid print();\n\tMatrix operator*(const Matrix &other);\n\tMatrix operator*(double value);\n};\nMatrix::Matrix(int rows,int columns,double values[]){\n\tr = rows;\n\tc = columns;\n\tint x = 0;\n\tfor(int i = 0; i < rows; i++){\n\t\tfor(int j = 0; j < columns; j++){\n\t\t\tv[i][j] = values[x];\n\t\t\tx++;\n\t\t}\n\t}\n}\nMatrix::Matrix(const Matrix &other){\n\tr = other.r;\n\tc = other.c;\n\tfor(int i = 0; i < r; i++){\n\t\tfor(int j = 0; j < c; j++){\n\t\t\tv[i][j] = other.v[i][j];\n\t\t}\n\t}\n}\nvoid Matrix::print(){\n\tfor(int i = 0; i < r; i++){\n\t\tfor(int j = 0; j < c; j++){\n\t\t\tcout << \"    \" << v[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n}\nMatrix Matrix::operator*(const Matrix &other){\n\tdouble a[1000] = {0};\n\tint x = 0;\n\tfor(int i = 0; i < r; i++){\n\t\tfor(int j = 0; j < other.c; j++){\n\t\t\tfor(int k = 0; k < c; k++){\n\t\t\t\ta[x] += v[i][k]*other.v[k][j];\n\t\t\t}\n\t\t\tx++;\n\t\t}\n\t}\n\tMatrix ans(r,other.c,a);\n\treturn ans;\n}\nMatrix Matrix::operator*(double value){\n\tdouble a[1000] = {0};\n\tint x = 0;\n\tfor(int i = 0; i < r; i++){\n\t\tfor(int j = 0; j < c; j++){\n\t\t\ta[x] = v[i][j]*value;\n\t\t\tx++;\n\t\t}\n\t}\n\tMatrix ans(r,c,a);\n\treturn ans;\n}",
            1589519077.3856103,
            100,
            "# 答案正确"
        ],
        [
            "2.11 (C++)",
            "唐晨轩",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix{\n\tprivate:\n\tint r;\n\tint c;\n\tdouble v[100][100];\n\tpublic:\n\tMatrix(int rows,int columns,double values[]);\n\tMatrix(const Matrix &other);\n\tvoid print();\n\tMatrix max();\n\tMatrix min();\n\tMatrix sum();\n};\nMatrix::Matrix(int rows,int columns,double values[]){\n\tr = rows;\n\tc = columns;\n\tint x = 0;\n\tfor(int i = 0; i < rows; i++){\n\t\tfor(int j = 0; j < columns; j++){\n\t\t\tv[i][j] = values[x];\n\t\t\tx++;\n\t\t}\n\t}\n}\nMatrix::Matrix(const Matrix &other){\n\tr = other.r;\n\tc = other.c;\n\tfor(int i = 0; i < r; i++){\n\t\tfor(int j = 0; j < c; j++){\n\t\t\tv[i][j] = other.v[i][j];\n\t\t}\n\t}\n}\nvoid Matrix::print(){\n\tfor(int i = 0; i < r; i++){\n\t\tfor(int j = 0; j < c; j++){\n\t\t\tcout << \"    \" << v[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n}\nMatrix Matrix::max(){\n\tdouble a[1000] = {0};\n\tif(r == 1){\n\t\ta[0] = v[0][0];\n\t\tfor(int i = 0; i < c; i++){\n\t\t\tif(a[0] < v[0][i]){\n\t\t\t\ta[0] = v[0][i];\n\t\t\t}\n\t\t}\n\t\tMatrix ans(1,1,a);\n\t\treturn ans;\n\t}\n\telse{\n\t\tfor(int i = 0; i < c; i++){\n\t\t\ta[i] = v[0][i];\n\t\t\tfor(int j = 0; j < r; j++){\n\t\t\t\tif(a[i] < v[j][i]){\n\t\t\t\t\ta[i] = v[j][i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tMatrix ans(1,c,a);\n\t\treturn ans;\n\t}\n}\nMatrix Matrix::min(){\n\tdouble a[1000] = {0};\n\tif(r == 1){\n\t\ta[0] = v[0][0];\n\t\tfor(int i = 0; i < c; i++){\n\t\t\tif(a[0] > v[0][i]){\n\t\t\t\ta[0] = v[0][i];\n\t\t\t}\n\t\t}\n\t\tMatrix ans(1,1,a);\n\t\treturn ans;\n\t}\n\telse{\n\t\tfor(int i = 0; i < c; i++){\n\t\t\ta[i] = v[0][i];\n\t\t\tfor(int j = 0; j < r; j++){\n\t\t\t\tif(a[i] > v[j][i]){\n\t\t\t\t\ta[i] = v[j][i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tMatrix ans(1,c,a);\n\t\treturn ans;\n\t}\n}\nMatrix Matrix::sum(){\n\tdouble a[1000] = {0};\n\tif(r == 1){\n\t\tfor(int i = 0; i < c; i++){\n\t\t\ta[0] += v[0][i];\n\t\t}\n\t\tMatrix ans(1,1,a);\n\t\treturn ans;\n\t}\n\telse{\n\t\tfor(int i = 0; i < c; i++){\n\t\t\tfor(int j = 0; j < r; j++){\n\t\t\t\ta[i] += v[j][i];\n\t\t\t}\n\t\t}\n\t\tMatrix ans(1,c,a);\n\t\treturn ans;\n\t}\n}",
            1589522894.7043858,
            100,
            "# 答案正确"
        ],
        [
            "2.12 (C++)",
            "唐晨轩",
            "#include <iostream>\n#include <math.h>\n#include <cstdlib>\nusing namespace std;\n\nclass Matrix{\n\tprivate:\n\tint r;\n\tint c;\n\tdouble v[100][100];\n\tpublic:\n\tMatrix(int rows,int columns,double values[]);\n\tMatrix(const Matrix &other);\n\tvoid print();\n\tMatrix pow(double exponent);\n\tMatrix exp();\n\tMatrix log();\n\tMatrix abs();\n};\nMatrix::Matrix(int rows,int columns,double values[]){\n\tr = rows;\n\tc = columns;\n\tint x = 0;\n\tfor(int i = 0; i < rows; i++){\n\t\tfor(int j = 0; j < columns; j++){\n\t\t\tv[i][j] = values[x];\n\t\t\tx++;\n\t\t}\n\t}\n}\nMatrix::Matrix(const Matrix &other){\n\tr = other.r;\n\tc = other.c;\n\tfor(int i = 0; i < r; i++){\n\t\tfor(int j = 0; j < c; j++){\n\t\t\tv[i][j] = other.v[i][j];\n\t\t}\n\t}\n}\nvoid Matrix::print(){\n\tfor(int i = 0; i < r; i++){\n\t\tfor(int j = 0; j < c; j++){\n\t\t\tcout << \"    \" << v[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n}\nMatrix Matrix::pow(double exponent){\n\tdouble a[1000];\n\tint x = 0;\n\tfor(int i = 0; i < r; i++){\n\t\tfor(int j = 0; j < c; j++){\n\t\t\ta[x] = v[i][j];\n\t\t\tfor(int k = 1; k < exponent; k++){\n\t\t\t\ta[x] *= v[i][j];\n\t\t\t}\n\t\t\tx++;\n\t\t}\n\t}\n\tMatrix ans(r,c,a);\n\treturn ans;\n}\nMatrix Matrix::exp(){\n\tdouble a[1000];\n\tint x = 0;\n\tfor(int i = 0; i < r; i++){\n\t\tfor(int j = 0; j < c; j++){\n\t\t\ta[x] = ::exp(v[i][j]);\n\t\t\tx++;\n\t\t}\n\t}\n\tMatrix ans(r,c,a);\n\treturn ans;\n}\nMatrix Matrix::log(){\n\tdouble a[1000];\n\tint x = 0;\n\tfor(int i = 0; i < r; i++){\n\t\tfor(int j = 0; j < c; j++){\n\t\t\ta[x] = ::log(v[i][j]);\n\t\t\tx++;\n\t\t}\n\t}\n\tMatrix ans(r,c,a);\n\treturn ans;\n}\nMatrix Matrix::abs(){\n\tdouble a[1000];\n\tint x = 0;\n\tfor(int i = 0; i < r; i++){\n\t\tfor(int j = 0; j < c; j++){\n\t\t\ta[x] = ::abs(v[i][j]);\n\t\t\tx++;\n\t\t}\n\t}\n\tMatrix ans(r,c,a);\n\treturn ans;\n}",
            1589598557.5551753,
            100,
            "# 答案正确"
        ],
        [
            "2.9 (C++)",
            "唐晨轩",
            "#include <iostream>\nusing namespace std;\n\nclass Matrix{\n\tprivate:\n\tint r;\n\tint c;\n\tdouble v[100][100];\n\tpublic:\n\tMatrix(int rows,int columns,double values[]);\n\tMatrix(const Matrix &other);\n\tMatrix transpose();\n\tvoid print();\n\tMatrix operator + (const Matrix & other) const;\n\tMatrix operator + (double value) const;\n\tMatrix operator - (const Matrix & other) const;\n\tMatrix operator - (double value) const;\n};\nMatrix::Matrix(int rows,int columns,double values[]){\n\tr = rows;\n\tc = columns;\n\tint x = 0;\n\tfor(int i = 0; i < rows; i++){\n\t\tfor(int j = 0; j < columns; j++){\n\t\t\tv[i][j] = values[x];\n\t\t\tx++;\n\t\t}\n\t}\n}\nMatrix::Matrix(const Matrix &other){\n\tr = other.r;\n\tc = other.c;\n\tfor(int i = 0; i < r; i++){\n\t\tfor(int j = 0; j < c; j++){\n\t\t\tv[i][j] = other.v[i][j];\n\t\t}\n\t}\n}\nvoid Matrix::print(){\n\tfor(int i = 0; i < r; i++){\n\t\tfor(int j = 0; j < c; j++){\n\t\t\tcout << \"    \" << v[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n}\nMatrix Matrix::operator + (const Matrix & other) const{\n\tdouble a[1000] = {0};\n\tint x = 0;\n\tfor(int i = 0; i < r; i++){\n\t\tfor(int j = 0; j < c; j++){\n\t\t\ta[x] = other.v[i][j] + v[i][j];\n\t\t\tx++;\n\t\t}\n\t}\n\tMatrix ans(r,c,a);\n\treturn ans;\n}\nMatrix Matrix::operator - (const Matrix & other) const{\n\tdouble a[1000] = {0};\n\tint x = 0;\n\tfor(int i = 0; i < r; i++){\n\t\tfor(int j = 0; j < c; j++){\n\t\t\ta[x] = v[i][j] - other.v[i][j];\n\t\t\tx++;\n\t\t}\n\t}\n\tMatrix ans(r,c,a);\n\treturn ans;\n}\nMatrix Matrix::operator + (double value) const{\n\tdouble a[1000] = {0};\n\tint x = 0;\n\tfor(int i = 0; i < r; i++){\n\t\tfor(int j = 0; j < c; j++){\n\t\t\ta[x] = v[i][j] + value;\n\t\t\tx++;\n\t\t}\n\t}\n\tMatrix ans(r,c,a);\n\treturn ans;\n}\nMatrix Matrix::operator - (double value) const{\n\tdouble a[1000] = {0};\n\tint x = 0;\n\tfor(int i = 0; i < r; i++){\n\t\tfor(int j = 0; j < c; j++){\n\t\t\ta[x] = v[i][j] - value;\n\t\t\tx++;\n\t\t}\n\t}\n\tMatrix ans(r,c,a);\n\treturn ans;\n}",
            1590027312.7785804,
            100,
            "# 答案正确"
        ],
        [
            "6.1 (C++)",
            "唐晨轩",
            "#include <iostream>\n#include <vector>\n#include <string.h>\nusing namespace std;\n\ntemplate <typename T>\nclass Matrix\n{\nprivate:\n\tT *data;\n\tint r;\n\tint c;\n\tvoid copy(const Matrix &other){\n\t\tif(data != NULL) delete [] data;\n\t\tr = other.r;\n\t\tc = other.c;\n\t\tdata = new T[r*c];\n\t\tmemcpy(data, other.data, r*c*sizeof(T));\n\t}\npublic:\n\tMatrix(int rows,int colunms){\n\t\tr = rows;\n\t\tc = colunms;\n\t\tdata = new T [rows*colunms];\n\t\tfor(int i = 0; i < colunms; i++){\n\t\t\tdata[i] = 0;\n\t\t}\n\t}\n\tMatrix(int rows,int colunms,const T values[]){\n\t\tr = rows;\n\t\tc = colunms;\n\t\tdata = new T[rows*colunms];\n\t\tint i,n=rows*colunms;\n\t\tfor(i = 0; i < n; i++){\n\t\t\tdata[i] = 0;\n\t\t}\n\t\tfor(i = 0; i < n; i++){\n\t\t\tdata[i] = values[i];\n\t\t}\n\t}\n\t~Matrix(){\n\t\tdelete [] data;\n\t}\n\tMatrix(const Matrix &other){\n\t\tdata = 0;\n\t\tcopy(other);\n\t}\n\tMatrix & operator = (const Matrix &other){\n\t\tcopy(other);\n\t\treturn *this;\n\t}\n\tT& get(int row,int colunm){\n\t\treturn data[(colunm-1)*r+row];\n\t}\n\tvoid print(){\n\t\tfor (int i = 0; i < r; ++ i){\n\t\t\tfor(int j = 0; j < c; j++){\n\t\t\t\tcout << \"    \" << data[i*r+j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t} \n\t}\n};",
            1590637643.4583178,
            0,
            "In file included from main.cpp:5:0:\nsource.cpp: In instantiation of ‘Matrix<T>::Matrix(int, int) [with T = std::__cxx11::basic_string<char>]’:\nmain.cpp:36:29:   required from here\nsource.cpp:26:12: error: ambiguous overload for ‘operator=’ (operand types are ‘std::__cxx11::basic_string<char>’ and ‘int’)\n    data[i] = 0;\n            ^\nIn file included from /usr/include/c++/5/string:52:0,\n                 from /usr/include/c++/5/bits/locale_classes.h:40,\n                 from /usr/include/c++/5/bits/ios_base.h:41,\n                 from /usr/include/c++/5/ios:42,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/basic_string.h:550:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::operator=(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\n       operator=(const basic_string& __str)\n       ^\n/usr/include/c++/5/bits/basic_string.h:558:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::operator=(const _CharT*) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\n       operator=(const _CharT* __s)\n       ^\n/usr/include/c++/5/bits/basic_string.h:569:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::operator=(_CharT) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\n       operator=(_CharT __c)\n       ^\n/usr/include/c++/5/bits/basic_string.h:587:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::operator=(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\n       operator=(basic_string&& __str)\n       ^\nIn file included from main.cpp:5:0:\nsource.cpp: In instantiation of ‘Matrix<T>::Matrix(int, int, const T*) [with T = std::__cxx11::basic_string<char>]’:\nmain.cpp:45:38:   required from here\nsource.cpp:35:12: error: ambiguous overload for ‘operator=’ (operand types are ‘std::__cxx11::basic_string<char>’ and ‘int’)\n    data[i] = 0;\n            ^\nIn file included from /usr/include/c++/5/string:52:0,\n                 from /usr/include/c++/5/bits/locale_classes.h:40,\n                 from /usr/include/c++/5/bits/ios_base.h:41,\n                 from /usr/include/c++/5/ios:42,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:1:\n/usr/include/c++/5/bits/basic_string.h:550:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::operator=(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\n       operator=(const basic_string& __str)\n       ^\n/usr/include/c++/5/bits/basic_string.h:558:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::operator=(const _CharT*) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\n       operator=(const _CharT* __s)\n       ^\n/usr/include/c++/5/bits/basic_string.h:569:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::operator=(_CharT) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\n       operator=(_CharT __c)\n       ^\n/usr/include/c++/5/bits/basic_string.h:587:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::operator=(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\n       operator=(basic_string&& __str)\n       ^\n"
        ],
        [
            "6.2 (C++)",
            "唐晨轩",
            "#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate <typename T>\nclass Matrix{\n\tprivate:\n\tint r;\n\tint c;\n\tT *values;\n\tpublic:\n\tMatrix(int rows,int columns){\n\t\tr = rows;\n\t\tc = columns;\n\t\tvalues = new T[rows*columns];\n\t\tfor(int i = 0; i < rows*columns; i++){\n\t\t\tvalues[i] = 0;\n\t\t}\n\t}\n\t~Matrix(){\n\t\tdelete [] values;\n\t}\n\tvoid print(){\n\t\tfor(int i = 0; i < r; i++){\n\t\t\tfor(int j = 0; j < c; j++){\n\t\t\t\tcout << \"    \" << values[i*r+j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n};",
            1590632513.989128,
            100,
            "# 答案正确"
        ],
        [
            "7.1 (C++)",
            "唐晨轩",
            "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nclass Triangle : public GeometricObject{\n\tprivate:\n\tdouble s1;\n\tdouble s2;\n\tdouble s3;\n\tpublic:\n\tTriangle(double side1,double side2,double side3){\n\t\ts1 = side1;\n\t\ts2 = side2;\n\t\ts3 = side3;\n\t}\n\tvoid setColor(string color){\n\t\tGeometricObject::setColor(color);\n\t}\n\tstring getColor(){\n\t\treturn GeometricObject::getColor();\n\t}\n\tdouble getSide1(){\n\t\treturn s1;\n\t}\n\tdouble getSide2(){\n\t\treturn s2;\n\t}\n\tdouble getSide3(){\n\t\treturn s3;\n\t}\n\tdouble getArea(){\n\t\tdouble s = (s1 + s2 + s3) / 2;\n\t\tdouble area = sqrt(s * (s - s1) * (s - s2) * (s - s3));\n\t\treturn area;\n\t}\n\tdouble getPerimeter(){\n\t\treturn s1+s2+s3;\n\t}\n};",
            1590720905.2734983,
            100,
            "# 答案正确"
        ],
        [
            "7.3 (C++)",
            "唐晨轩",
            "template <typename A,typename R>\nvector<R> map2(vector<A> x, vector<A> y, R(*add)(const A & a, const A & b)){\n\tvector<R> res;\n\tfor(int i = 0; i < x.size(); i++){\n\t\tres.push_back(add(x[i],y[i]));\n\t}\n\treturn res;\n}\n\ntemplate <typename A,typename R>\nvector<R> map2(vector<A> x, int y, R(*add)(const A & a, const int & b)){\n\tvector<R> res;\n\tfor(int i = 0; i < x.size(); i++){\n\t\tres.push_back(add(x[i],y));\n\t}\n\treturn res;\n}",
            1590723734.8309274,
            100,
            "# 答案正确"
        ],
        [
            "7.2 (C++)",
            "唐晨轩",
            "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> split(const string & line){\n\tvector<string> words;//存储子串\n\tint st = 0;//开始位置\n\tstring delimiter = \" \";//分隔符\n\twhile(st < line.size()){\n\t\tint end = line.find(delimiter, st);//第一个分隔符的位置是end\n\t\tif(end == st) st += delimiter.size();//如果开头就是分隔符，st+分隔符长度，以跳过分隔符\n\t\telse{\n\t\t\tif(end == -1){//如果没有分隔符\n\t\t\t\twords.push_back(line.substr(st));//自身就是子串\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twords.push_back(line.substr(st,end-st));//加入子串\n\t\t\tst = end + delimiter.size();\n\t\t}\n\t}\n\treturn words;\n}",
            1591237160.5483325,
            100,
            "# 答案正确"
        ],
        [
            "8.1 (C++)",
            "唐晨轩",
            "class Full:public Matrix\n{\npublic:\nint r;\nint c;\ndouble v[100][100];\nFull(int rows,int columns){\n\tr = rows;\n\tc = columns;\n\tfor(int i = 0; i < r; i++){\n\t\tfor(int j = 0; j < c; j++){\n\t\t\tv[i][j] = 0;\n\t\t}\n\t}\n}\nFull(int rows,int columns,double values[]){\n\tr = rows;\n\tc = columns;\n\tint x = 0;\n\tfor(int i = 0; i < r; i++){\n\t\tfor(int j = 0; j < c; j++){\n\t\t\tv[i][j] = values[x];\n\t\t\tx++;\n\t\t}\n\t}\n}\nint size(int dimension)const{\n\tif(dimension == 1){\n\t\treturn r;\n\t}\n\tif(dimension == 2){\n\t\treturn c;\n\t}\n}\nvoid set(int row, int column, double value){\n\tv[row][column] = value;\n}\ndouble get(int row, int column)const{\n\treturn v[row][column];\n}\nvoid print()const{\n\tfor(int i = 0; i < r; i++){\n\t\tfor(int j = 0; j < c; j++){\n\t\t\tcout << \"    \" << v[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n}\nMatrix & operator = (const Matrix & matrix2){\n\tr = matrix2.size(1);\n\tc = matrix2.size(2);\n\tfor(int i = 0; i < r; i++){\n\t\tfor(int j = 0; j < c; j++){\n\t\t\tv[i][j] = matrix2.get(i,j);\n\t\t}\n\t}\n}\nFull(const Matrix & matrix2){\n\tr = matrix2.size(1);\n\tc = matrix2.size(2);\n\tfor(int i = 0; i < r; i++){\n\t\tfor(int j = 0; j < c; j++){\n\t\t\tv[i][j] = matrix2.get(i,j);\n\t\t}\n\t}\n}\n};",
            1591347000.9478211,
            100,
            "# 答案正确"
        ],
        [
            "8.3 (C++)",
            "唐晨轩",
            "class Sparse:public Matrix\n{\npublic:\n\tint row;\n\tint column;\n\tvector<Entry> data;\n\tSparse(int rows,int columns){\n\t\trow = rows;\n\t\tcolumn = columns;\n\t}\n\tint size(int dimension) const{\n\t\tif(dimension == 1){\n\t\t\treturn data.row;\n\t\t}\n\t\tif(dimension == 2){\n\t\t\treturn data.column;\n\t\t}\n\t}\n\tvoid set(int row, int column, double value){\n\t\tdata.row = row;\n\t\tdata.column = column;\n\t\tdata.value = value;\n\t}\n\tdouble get(int row, int column)const{\n\t\tif(data.row == row && data.column == column){\n\t\t\treturn data.value;\n\t\t}\n\t}\n\tvoid print(){\n\t\t\n\t}\n}",
            1591349249.699709,
            0,
            "In file included from main.cpp:24:0:\nsource.cpp:6:2: error: ‘vector’ does not name a type\n  vector<Entry> data;\n  ^\nsource.cpp:32:1: error: expected ‘;’ after class definition\n }\n ^\nsource.cpp: In member function ‘virtual int Sparse::size(int) const’:\nsource.cpp:13:11: error: ‘data’ was not declared in this scope\n    return data.row;\n           ^\nsource.cpp:16:11: error: ‘data’ was not declared in this scope\n    return data.column;\n           ^\nsource.cpp: In member function ‘virtual void Sparse::set(int, int, double)’:\nsource.cpp:20:3: error: ‘data’ was not declared in this scope\n   data.row = row;\n   ^\nsource.cpp: In member function ‘virtual double Sparse::get(int, int) const’:\nsource.cpp:25:6: error: ‘data’ was not declared in this scope\n   if(data.row == row && data.column == column){\n      ^\nmain.cpp: In function ‘int main()’:\nmain.cpp:58:27: error: no match for ‘operator+’ (operand types are ‘Sparse’ and ‘Sparse’)\n  Sparse sparse3 = sparse1 + sparse2;\n                           ^\nIn file included from /usr/include/c++/5/bits/stl_algobase.h:67:0,\n                 from /usr/include/c++/5/bits/char_traits.h:39,\n                 from /usr/include/c++/5/ios:40,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:26:\n/usr/include/c++/5/bits/stl_iterator.h:334:5: note: candidate: template<class _Iterator> std::reverse_iterator<_Iterator> std::operator+(typename std::reverse_iterator<_Iterator>::difference_type, const std::reverse_iterator<_Iterator>&)\n     operator+(typename reverse_iterator<_Iterator>::difference_type __n,\n     ^\n/usr/include/c++/5/bits/stl_iterator.h:334:5: note:   template argument deduction/substitution failed:\nmain.cpp:58:29: note:   ‘Sparse’ is not derived from ‘const std::reverse_iterator<_Iterator>’\n  Sparse sparse3 = sparse1 + sparse2;\n                             ^\nIn file included from /usr/include/c++/5/bits/stl_algobase.h:67:0,\n                 from /usr/include/c++/5/bits/char_traits.h:39,\n                 from /usr/include/c++/5/ios:40,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:26:\n/usr/include/c++/5/bits/stl_iterator.h:1152:5: note: candidate: template<class _Iterator> std::move_iterator<_Iterator> std::operator+(typename std::move_iterator<_Iterator>::difference_type, const std::move_iterator<_Iterator>&)\n     operator+(typename move_iterator<_Iterator>::difference_type __n,\n     ^\n/usr/include/c++/5/bits/stl_iterator.h:1152:5: note:   template argument deduction/substitution failed:\nmain.cpp:58:29: note:   ‘Sparse’ is not derived from ‘const std::move_iterator<_Iterator>’\n  Sparse sparse3 = sparse1 + sparse2;\n                             ^\nIn file included from /usr/include/c++/5/string:52:0,\n                 from /usr/include/c++/5/bits/locale_classes.h:40,\n                 from /usr/include/c++/5/bits/ios_base.h:41,\n                 from /usr/include/c++/5/ios:42,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:26:\n/usr/include/c++/5/bits/basic_string.h:4783:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> std::__cxx11::basic_string<_CharT, _Traits, _Alloc> std::operator+(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)\n     operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n     ^\n/usr/include/c++/5/bits/basic_string.h:4783:5: note:   template argument deduction/substitution failed:\nmain.cpp:58:29: note:   ‘Sparse’ is not derived from ‘const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>’\n  Sparse sparse3 = sparse1 + sparse2;\n                             ^\nIn file included from /usr/include/c++/5/string:53:0,\n                 from /usr/include/c++/5/bits/locale_classes.h:40,\n                 from /usr/include/c++/5/bits/ios_base.h:41,\n                 from /usr/include/c++/5/ios:42,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:26:\n/usr/include/c++/5/bits/basic_string.tcc:1151:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> std::__cxx11::basic_string<_CharT, _Traits, _Alloc> std::operator+(const _CharT*, const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)\n     operator+(const _CharT* __lhs,\n     ^\n/usr/include/c++/5/bits/basic_string.tcc:1151:5: note:   template argument deduction/substitution failed:\nmain.cpp:58:29: note:   mismatched types ‘const _CharT*’ and ‘Sparse’\n  Sparse sparse3 = sparse1 + sparse2;\n                             ^\nIn file included from /usr/include/c++/5/string:53:0,\n                 from /usr/include/c++/5/bits/locale_classes.h:40,\n                 from /usr/include/c++/5/bits/ios_base.h:41,\n                 from /usr/include/c++/5/ios:42,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:26:\n/usr/include/c++/5/bits/basic_string.tcc:1167:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> std::__cxx11::basic_string<_CharT, _Traits, _Alloc> std::operator+(_CharT, const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)\n     operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n     ^\n/usr/include/c++/5/bits/basic_string.tcc:1167:5: note:   template argument deduction/substitution failed:\nmain.cpp:58:29: note:   ‘Sparse’ is not derived from ‘const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>’\n  Sparse sparse3 = sparse1 + sparse2;\n                             ^\nIn file included from /usr/include/c++/5/string:52:0,\n                 from /usr/include/c++/5/bits/locale_classes.h:40,\n                 from /usr/include/c++/5/bits/ios_base.h:41,\n                 from /usr/include/c++/5/ios:42,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:26:\n/usr/include/c++/5/bits/basic_string.h:4820:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> std::__cxx11::basic_string<_CharT, _Traits, _Alloc> std::operator+(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)\n     operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n     ^\n/usr/include/c++/5/bits/basic_string.h:4820:5: note:   template argument deduction/substitution failed:\nmain.cpp:58:29: note:   ‘Sparse’ is not derived from ‘const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>’\n  Sparse sparse3 = sparse1 + sparse2;\n                             ^\nIn file included from /usr/include/c++/5/string:52:0,\n                 from /usr/include/c++/5/bits/locale_classes.h:40,\n                 from /usr/include/c++/5/bits/ios_base.h:41,\n                 from /usr/include/c++/5/ios:42,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:26:\n/usr/include/c++/5/bits/basic_string.h:4836:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> std::__cxx11::basic_string<_CharT, _Traits, _Alloc> std::operator+(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, _CharT)\n     operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)\n     ^\n/usr/include/c++/5/bits/basic_string.h:4836:5: note:   template argument deduction/substitution failed:\nmain.cpp:58:29: note:   ‘Sparse’ is not derived from ‘const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>’\n  Sparse sparse3 = sparse1 + sparse2;\n                             ^\nIn file included from /usr/include/c++/5/string:52:0,\n                 from /usr/include/c++/5/bits/locale_classes.h:40,\n                 from /usr/include/c++/5/bits/ios_base.h:41,\n                 from /usr/include/c++/5/ios:42,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:26:\n/usr/include/c++/5/bits/basic_string.h:4848:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> std::__cxx11::basic_string<_CharT, _Traits, _Alloc> std::operator+(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&&, const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)\n     operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,\n     ^\n/usr/include/c++/5/bits/basic_string.h:4848:5: note:   template argument deduction/substitution failed:\nmain.cpp:58:29: note:   ‘Sparse’ is not derived from ‘std::__cxx11::basic_string<_CharT, _Traits, _Alloc>’\n  Sparse sparse3 = sparse1 + sparse2;\n                             ^\nIn file included from /usr/include/c++/5/string:52:0,\n                 from /usr/include/c++/5/bits/locale_classes.h:40,\n                 from /usr/include/c++/5/bits/ios_base.h:41,\n                 from /usr/include/c++/5/ios:42,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:26:\n/usr/include/c++/5/bits/basic_string.h:4854:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> std::__cxx11::basic_string<_CharT, _Traits, _Alloc> std::operator+(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&&)\n     operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n     ^\n/usr/include/c++/5/bits/basic_string.h:4854:5: note:   template argument deduction/substitution failed:\nmain.cpp:58:29: note:   ‘Sparse’ is not derived from ‘const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>’\n  Sparse sparse3 = sparse1 + sparse2;\n                             ^\nIn file included from /usr/include/c++/5/string:52:0,\n                 from /usr/include/c++/5/bits/locale_classes.h:40,\n                 from /usr/include/c++/5/bits/ios_base.h:41,\n                 from /usr/include/c++/5/ios:42,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:26:\n/usr/include/c++/5/bits/basic_string.h:4860:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> std::__cxx11::basic_string<_CharT, _Traits, _Alloc> std::operator+(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&&, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&&)\n     operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,\n     ^\n/usr/include/c++/5/bits/basic_string.h:4860:5: note:   template argument deduction/substitution failed:\nmain.cpp:58:29: note:   ‘Sparse’ is not derived from ‘std::__cxx11::basic_string<_CharT, _Traits, _Alloc>’\n  Sparse sparse3 = sparse1 + sparse2;\n                             ^\nIn file included from /usr/include/c++/5/string:52:0,\n                 from /usr/include/c++/5/bits/locale_classes.h:40,\n                 from /usr/include/c++/5/bits/ios_base.h:41,\n                 from /usr/include/c++/5/ios:42,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:26:\n/usr/include/c++/5/bits/basic_string.h:4872:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> std::__cxx11::basic_string<_CharT, _Traits, _Alloc> std::operator+(const _CharT*, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&&)\n     operator+(const _CharT* __lhs,\n     ^\n/usr/include/c++/5/bits/basic_string.h:4872:5: note:   template argument deduction/substitution failed:\nmain.cpp:58:29: note:   mismatched types ‘const _CharT*’ and ‘Sparse’\n  Sparse sparse3 = sparse1 + sparse2;\n                             ^\nIn file included from /usr/include/c++/5/string:52:0,\n                 from /usr/include/c++/5/bits/locale_classes.h:40,\n                 from /usr/include/c++/5/bits/ios_base.h:41,\n                 from /usr/include/c++/5/ios:42,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:26:\n/usr/include/c++/5/bits/basic_string.h:4878:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> std::__cxx11::basic_string<_CharT, _Traits, _Alloc> std::operator+(_CharT, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&&)\n     operator+(_CharT __lhs,\n     ^\n/usr/include/c++/5/bits/basic_string.h:4878:5: note:   template argument deduction/substitution failed:\nmain.cpp:58:29: note:   ‘Sparse’ is not derived from ‘std::__cxx11::basic_string<_CharT, _Traits, _Alloc>’\n  Sparse sparse3 = sparse1 + sparse2;\n                             ^\nIn file included from /usr/include/c++/5/string:52:0,\n                 from /usr/include/c++/5/bits/locale_classes.h:40,\n                 from /usr/include/c++/5/bits/ios_base.h:41,\n                 from /usr/include/c++/5/ios:42,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:26:\n/usr/include/c++/5/bits/basic_string.h:4884:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> std::__cxx11::basic_string<_CharT, _Traits, _Alloc> std::operator+(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&&, const _CharT*)\n     operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,\n     ^\n/usr/include/c++/5/bits/basic_string.h:4884:5: note:   template argument deduction/substitution failed:\nmain.cpp:58:29: note:   ‘Sparse’ is not derived from ‘std::__cxx11::basic_string<_CharT, _Traits, _Alloc>’\n  Sparse sparse3 = sparse1 + sparse2;\n                             ^\nIn file included from /usr/include/c++/5/string:52:0,\n                 from /usr/include/c++/5/bits/locale_classes.h:40,\n                 from /usr/include/c++/5/bits/ios_base.h:41,\n                 from /usr/include/c++/5/ios:42,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:26:\n/usr/include/c++/5/bits/basic_string.h:4890:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> std::__cxx11::basic_string<_CharT, _Traits, _Alloc> std::operator+(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&&, _CharT)\n     operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,\n     ^\n/usr/include/c++/5/bits/basic_string.h:4890:5: note:   template argument deduction/substitution failed:\nmain.cpp:58:29: note:   ‘Sparse’ is not derived from ‘std::__cxx11::basic_string<_CharT, _Traits, _Alloc>’\n  Sparse sparse3 = sparse1 + sparse2;\n                             ^\n"
        ],
        [
            "8.5 (C++)",
            "唐晨轩",
            "class Point3D : public Point2D\n{\npublic:\n\tdouble z;\n\tPoint3D():Point2D(){\n\t\tz = 0;\n\t}\n\tPoint3D(double a,double b,double c){\n\t\tPoint2D::setX(a);\n\t\tPoint2D::setY(b);\n\t\tz = c;\n\t}\n\tdouble getZ(){\n\t\treturn z;\n\t}\n\tdouble distance(Point2D & point2){\n\t\tdouble x1 = Point2D::getX();\n\t\tdouble x2 = point2.getX();\n\t\tdouble y1 = Point2D::getY();\n\t\tdouble y2 = point2.getY();\n\t\tdouble dx = x1-x2;\n\t\tdouble dy = y1-y2;\n\t\tPoint3D p;\n\t\t&point2 = &p;\n\t\tdouble z2 = point2.z;\n\t}\n};",
            1591844222.482808,
            87,
            "In file included from main.cpp:39:0:\nsource.cpp: In member function ‘virtual double Point3D::distance(Point2D&)’:\nsource.cpp:24:11: error: lvalue required as left operand of assignment\n   &point2 = &p;\n           ^\nsource.cpp:25:22: error: ‘class Point2D’ has no member named ‘z’\n   double z2 = point2.z;\n                      ^\n"
        ],
        [
            "8.6 (C++)",
            "唐晨轩",
            "/*\nMyTensor mt1(I(3,4,5));\nTensor<double> & t1 = mt1;\n表明：\n1）MyTensor 继承 Tensor<double>，\n2）MyTensor需要构造函数 MyTensor(vector<int>)\n\ncin >> t1.get(I(0,0,3)); \n表明 MyTensor 需要函数 double & get(vector<int>) \n\n还有要注意的地方是 \n1）继承时正确地调用基类的构造函数\n2）注意是否实现了接口中的虚函数\n*/\n#include <iostream>\nusing namespace std;\n\nclass MyTensor : public Tensor<double>\n{\npublic:\n\tdouble p;\n\tMyTensor(vector<int> indexes) : Tensor(indexes){\n\t\t\n\t}\n\tdouble & get(const vector<int> & indexes){\n\t\treturn p;\n\t}\n};",
            1592449670.859907,
            100,
            "# 答案正确"
        ],
        [
            "9.1 (C++)",
            "唐晨轩",
            "#include <cmath>\n\nclass Circle\n{\npublic:\n\tdouble radii;\n\tdouble radius;\n\tCircle(double r){\n\t\tradius = r;\n\t\tradii = sqrt(r/3.14);\n\t}\n};\nint operator < (Circle circle1,Circle circle2){\n\tif(circle1.radii < circle2.radii){\n\t\treturn 1;\n\t}\n\telse{\n\t\treturn 0;\n\t}\n}\nint operator > (Circle circle1,Circle circle2){\n\tif(circle1.radii > circle2.radii){\n\t\treturn 1;\n\t}\n\telse{\n\t\treturn 0;\n\t}\n}\nint operator == (Circle circle1,Circle circle2){\n\tif(circle1.radii == circle2.radii){\n\t\treturn 1;\n\t}\n\telse{\n\t\treturn 0;\n\t}\n}\nint operator <= (Circle circle1,Circle circle2){\n\tif(circle1.radii <= circle2.radii){\n\t\treturn 1;\n\t}\n\telse{\n\t\treturn 0;\n\t}\n}\nint operator >= (Circle circle1,Circle circle2){\n\tif(circle1.radii >= circle2.radii){\n\t\treturn 1;\n\t}\n\telse{\n\t\treturn 0;\n\t}\n}\nint operator != (Circle circle1,Circle circle2){\n\tif(circle1.radii != circle2.radii){\n\t\treturn 1;\n\t}\n\telse{\n\t\treturn 0;\n\t}\n}",
            1592535913.1540835,
            100,
            "# 答案正确"
        ],
        [
            "9.2 (C++)",
            "唐晨轩",
            "class I\n{\npublic:\n\tvector<int> data;\n\tI(int a = -1,int b = -1,int c = -1,int d = -1){\n\t\tif(a != -1) data.push_back(a);\n\t\tif(b != -1) data.push_back(b);\n\t\tif(c != -1) data.push_back(c);\n\t\tif(d != -1) data.push_back(d);\n\t}\n\tvector<int> operator () (int a = -1,int b = -1,int c = -1,int d = -1){\n\t\tif(a != -1) data.push_back(a);\n\t\tif(b != -1) data.push_back(b);\n\t\tif(c != -1) data.push_back(c);\n\t\tif(d != -1) data.push_back(d);\n\t\treturn data;\n\t}\n};\n",
            1592537081.4340975,
            0,
            "main.cpp: In function ‘int main()’:\nmain.cpp:42:16: error: no matching function for call to ‘Tensor::Tensor(I&)’\n  Tensor t(sizes);\n                ^\nmain.cpp:27:2: note: candidate: Tensor::Tensor(std::vector<int>)\n  Tensor(vector<int> sizes) {\n  ^\nmain.cpp:27:2: note:   no known conversion for argument 1 from ‘I’ to ‘std::vector<int>’\nmain.cpp:5:7: note: candidate: Tensor::Tensor(const Tensor&)\n class Tensor\n       ^\nmain.cpp:5:7: note:   no known conversion for argument 1 from ‘I’ to ‘const Tensor&’\nmain.cpp:5:7: note: candidate: Tensor::Tensor(Tensor&&)\nmain.cpp:5:7: note:   no known conversion for argument 1 from ‘I’ to ‘Tensor&&’\nmain.cpp:44:20: error: no matching function for call to ‘Tensor::get(I&)’\n  cin >> t.get(index);\n                    ^\nmain.cpp:33:11: note: candidate: double& Tensor::get(const std::vector<int>&)\n  double & get(const vector<int> & indexes) {\n           ^\nmain.cpp:33:11: note:   no known conversion for argument 1 from ‘I’ to ‘const std::vector<int>&’\nmain.cpp:45:21: error: no matching function for call to ‘Tensor::get(I&)’\n  cout << t.get(index) << endl;\n                     ^\nmain.cpp:33:11: note: candidate: double& Tensor::get(const std::vector<int>&)\n  double & get(const vector<int> & indexes) {\n           ^\nmain.cpp:33:11: note:   no known conversion for argument 1 from ‘I’ to ‘const std::vector<int>&’\nmain.cpp:47:22: error: no matching function for call to ‘Tensor::Tensor(I)’\n  Tensor t2(I(2,3,4,5));\n                      ^\nmain.cpp:27:2: note: candidate: Tensor::Tensor(std::vector<int>)\n  Tensor(vector<int> sizes) {\n  ^\nmain.cpp:27:2: note:   no known conversion for argument 1 from ‘I’ to ‘std::vector<int>’\nmain.cpp:5:7: note: candidate: Tensor::Tensor(const Tensor&)\n class Tensor\n       ^\nmain.cpp:5:7: note:   no known conversion for argument 1 from ‘I’ to ‘const Tensor&’\nmain.cpp:5:7: note: candidate: Tensor::Tensor(Tensor&&)\nmain.cpp:5:7: note:   no known conversion for argument 1 from ‘I’ to ‘Tensor&&’\nmain.cpp:48:26: error: no matching function for call to ‘Tensor::get(I)’\n  cin >> t2.get(I(1,2,3,4));\n                          ^\nmain.cpp:33:11: note: candidate: double& Tensor::get(const std::vector<int>&)\n  double & get(const vector<int> & indexes) {\n           ^\nmain.cpp:33:11: note:   no known conversion for argument 1 from ‘I’ to ‘const std::vector<int>&’\nmain.cpp:49:27: error: no matching function for call to ‘Tensor::get(I)’\n  cout << t2.get(I(1,2,3,4)) << endl;\n                           ^\nmain.cpp:33:11: note: candidate: double& Tensor::get(const std::vector<int>&)\n  double & get(const vector<int> & indexes) {\n           ^\nmain.cpp:33:11: note:   no known conversion for argument 1 from ‘I’ to ‘const std::vector<int>&’\n"
        ],
        [
            "9.3 (C++)",
            "唐晨轩",
            "class Complex\n{\npublic:\n\tdouble a;\n\tdouble b;\n\tComplex(){\n\t\ta = 0;\n\t\tb = 0;\n\t}\n\tComplex(double x1,double x2){\n\t\ta = x1;\n\t\tb = x2;\n\t}\n\tComplex operator += (Complex c1){\n\t\ta += c1.a;\n\t\tb += c1.b;\n\t\treturn *this;\n\t}\n\tComplex operator -= (Complex c1){\n\t\ta -= c1.a;\n\t\tb -= c1.b;\n\t\treturn *this;\n\t}\n\tComplex operator *= (Complex c1){\n\t\tComplex tmp;\n\t\ttmp.a = a*c1.a - b*c1.b;\n\t\ttmp.b = b*c1.a + a*c1.b;\n\t\ta = tmp.a;\n\t\tb = tmp.b;\n\t\treturn *this;\n\t}\n\tComplex operator /= (Complex c1){\n\t\tComplex tmp;\n\t\ttmp.a = (a*c1.a + b*c1.b) / (c1.a*c1.a + c1.b*c1.b);\n\t\ttmp.b = (b*c1.a - a*c1.b) / (c1.a*c1.a + c1.b*c1.b);\n\t\ta = tmp.a;\n\t\tb = tmp.b;\n\t\treturn *this;\n\t}\n\tint operator == (Complex c1){\n\t\tif(a == c1.a){\n\t\t\tif(b == c1.b){\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint operator != (Complex c1){\n\t\tif(a == c1.a){\n\t\t\tif(b == c1.b){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\treturn 1;\n\t}\n\tComplex(double x) : a(x) , b(0){\n\t\t\n\t}\n\tdouble real(){\n\t\treturn a;\n\t}\n\tdouble imag(){\n\t\treturn b;\n\t}\n};\n\nostream & operator << (ostream & out, const Complex & m){\n\tout << m.a << \" + \" << m.b << \" i \";\n}\n\nistream & operator >> (istream & in, Complex & m){\n\tComplex tmp;\n\tin >> tmp.a >> tmp.b;\n\tm = tmp;\n\treturn in;\n}\n\nComplex operator + (Complex c1,Complex c2){\n\tComplex tmp;\n\ttmp.a = c1.a + c2.a;\n\ttmp.b = c1.b + c2.b;\n\treturn tmp;\n}\nComplex operator - (Complex c1,Complex c2){\n\tComplex tmp;\n\ttmp.a = c1.a - c2.a;\n\ttmp.b = c1.b - c2.b;\n\treturn tmp;\n}\nComplex operator * (Complex c1,Complex c2){\n\tComplex tmp;\n\ttmp.a = c1.a*c2.a - c1.b*c2.b;\n\ttmp.b = c1.b*c2.a + c1.a*c2.b;\n\treturn tmp;\n}\nComplex operator / (Complex c1,Complex c2){\n\tComplex tmp;\n\ttmp.a = (c1.a*c2.a + c1.b*c2.b) / (c2.a*c2.a + c2.b*c2.b);\n\ttmp.b = (c1.b*c2.a - c1.a*c2.b) / (c2.a*c2.a + c2.b*c2.b);\n\treturn tmp;\n}",
            1592716668.8496902,
            100,
            "# 答案正确"
        ],
        [
            "9.4 (C++)",
            "唐晨轩",
            "class Complex\n{\npublic:\n\tdouble a;\n\tdouble b;\n\tComplex(){\n\t\ta = 0;\n\t\tb = 0;\n\t}\n};\n\nostream & operator << (ostream & out, const Complex & m){\n\tout << m.a << \" + \" << m.b << \" i \";\n}\n\nistream & operator >> (istream & in, Complex & m){\n\tComplex tmp;\n\tin >> tmp.a >> tmp.b;\n\tm = tmp;\n\treturn in;\n}\n\nComplex operator + (Complex c1,Complex c2){\n\tComplex tmp;\n\ttmp.a = c1.a + c2.a;\n\ttmp.b = c1.b + c2.b;\n\treturn tmp;\n}\nComplex operator - (Complex c1,Complex c2){\n\tComplex tmp;\n\ttmp.a = c1.a - c2.a;\n\ttmp.b = c1.b - c2.b;\n\treturn tmp;\n}\n",
            1592713464.3152578,
            100,
            "# 答案正确"
        ],
        [
            "9.6 (C++)",
            "唐晨轩",
            "#include <vector>\nclass Tensor\n{\nprivate:\n\tint x1;\n\tint x2;\n\tint x3;\n\tint x4;\n\tvector<double> data;\npublic:\n\tTensor(int a,int b = -1,int c = -1,int d = -1){\n\t\tif(b == -1){\n\t\t\tx1 = a;\n\t\t\tx2 = b;\n\t\t\tx3 = c;\n\t\t\tx4 = d;\n\t\t\tdata.resize(a);\n\t\t}\n\t\tif(c == -1){\n\t\t\tx1 = a;\n\t\t\tx2 = b;\n\t\t\tx3 = c;\n\t\t\tx4 = d;\n\t\t\tdata.resize(a*b);\n\t\t}\n\t\tif(d == -1){\n\t\t\tx1 = a;\n\t\t\tx2 = b;\n\t\t\tx3 = c;\n\t\t\tx4 = d;\n\t\t\tdata.resize(a*b*c);\n\t\t}\n\t\tif(d != -1){\n\t\t\tx1 = a;\n\t\t\tx2 = b;\n\t\t\tx3 = c;\n\t\t\tx4 = d;\n\t\t\tdata.resize(a*b*c*d);\n\t\t}\n\t}\n\tdouble & operator () (int a,int b = -1,int c = -1,int d = -1){\n\t\tif(b == -1){ return data[a]; }\n\t\tif(c == -1){ return data[a*b]; }\n\t\tif(d == -1){ return data[a*b*c]; }\n\t\tif(d != -1){ return data[a*b*c*d]; }\n\t}\n};",
            1592714652.5042326,
            100,
            "# 答案正确"
        ],
        [
            "9.5 (C++)",
            "唐晨轩",
            "class Complex\n{\npublic:\n\tdouble a;\n\tdouble b;\n\tComplex(){\n\t\ta = 0;\n\t\tb = 0;\n\t}\n\toperator double() const{\n\t\treturn a;\n\t}\n\tComplex & operator ++ () {\n\t\ta ++;\n\t\treturn *this;\n\t}\n\tComplex operator ++ (int) {\n\t\tComplex tmp;\n\t\ttmp.a = a;\n\t\ttmp.b = b;\n\t\ta ++;\n\t\treturn tmp;\n}\t\n};\n\nostream & operator << (ostream & out, const Complex & m){\n\tout << m.a << \" + \" << m.b << \" i \";\n}\n\nistream & operator >> (istream & in, Complex & m){\n\tComplex tmp;\n\tin >> tmp.a >> tmp.b;\n\tm = tmp;\n\treturn in;\n}",
            1592714109.2900832,
            100,
            "# 答案正确"
        ],
        [
            "10.1 (C++)",
            "唐晨轩",
            "#include <stdexcept>\nusing namespace std;\nclass MatrixSizesDoNotMatchException {};\n\ndouble Matrix::get(int row, int column) const{\n\tint r = size(1);\n\tint c = size(2);\n\treturn elements[(row-1)*c + (column-1)];\n\t//throw std::out_of_range();\n}\n\t\nvoid Matrix::set(int row, int column, double value){\n\tint r = size(1);\n\tint c = size(2);\n\telements[(row-1)*c + (column-1)] = value;\n\t//throw std::out_of_range();\n}\n\t\nMatrix Matrix::operator + (const Matrix & matrix2) const{\n\tif(size(1) == matrix2.size(1) && size(2) == matrix2.size(2)){\n\t\tMatrix ans(size(1),size(2));\n\t\tfor(int i = 0; i < size(1)*size(2); i++){\n\t\t\tans.elements[i] = elements[i] + matrix2.elements[i];\n\t\t}\n\t\treturn *this;\n\t}\n\telse{\n\t\tthrow MatrixSizesDoNotMatchException();\n\t}\n}",
            1593616149.8574631,
            100,
            "# 答案正确"
        ],
        [
            "10.2 (C++)",
            "唐晨轩",
            "catch(NonPositiveValueException & ex){\n\tcout << \"caught: NonPositiveValueException\" << endl;\n}\ncatch(out_of_range & ex){\n\t//if(ex.what() != 0)\n\tcout << \"caught: out_of_range\" << endl;\n}\n",
            1593656709.902235,
            100,
            "# 答案正确"
        ],
        [
            "15.1 (C++)",
            "唐晨轩",
            "#include <vector>\nclass Table\n{\n\tint row;//行\n\tint column;//列\n\tvector<string> header;\n\tvector<string> rows;\n\tint len;\npublic:\n\tTable(){\n\t\trow = 0;\n\t\tcolumn = 0;\n\t\tlen = 0;\n\t}\n\tvoid addCol(string x){\n\t\theader[column] = x;\n\t\tcolumn ++;\n\t}\n\tTable & operator[] (int i){\n\t\treturn *this;\n\t}\n\tTable & operator = (vector<string> & y){\n\t\tint x = y.size();\n\t\tfor(int i = 0; i < x; i++){\n\t\t\trows.push_back(y[i]);\n\t\t}\n\t}\n};\nostream & operator << (ostream & out, const Table & m){\n\tout << \"headers: ['\";\n\tfor(int i = 0; i < m.column; i++){\n\t\tif(i == 0){\n\t\t\tout << m.headers[i];\n\t\t}\n\t\telse{\n\t\t\tout << \"','\" << m.headers[i];\n\t\t}\n\t}\n\tout << \",],\" << endl;\n\tout << \"rows: [\" << endl;\n\t\n\tfor(int i = 0; i < m.row; i++){\n\t\tout << \"\t['\";\n\t\tfor(int j = 0; j < m.column; j++){\n\t\t\tout << m.rows[i*column+j];\n\t\t}\n\t}\n}",
            1594126029.8941677,
            0,
            "In file included from main.cpp:1:0:\nsource.cpp:6:2: error: ‘vector’ does not name a type\n  vector<string> header;\n  ^\nsource.cpp:7:2: error: ‘vector’ does not name a type\n  vector<string> rows;\n  ^\nsource.cpp:15:14: error: ‘string’ has not been declared\n  void addCol(string x){\n              ^\nsource.cpp:22:22: error: declaration of ‘operator=’ as non-function\n  Table & operator = (vector<string> & y){\n                      ^\nsource.cpp:22:19: error: expected ‘;’ at end of member declaration\n  Table & operator = (vector<string> & y){\n                   ^\nsource.cpp:22:28: error: expected ‘)’ before ‘<’ token\n  Table & operator = (vector<string> & y){\n                            ^\nIn file included from /usr/include/c++/5/ext/atomicity.h:35:0,\n                 from /usr/include/c++/5/bits/ios_base.h:39,\n                 from /usr/include/c++/5/ios:42,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:3:\n/usr/include/x86_64-linux-gnu/c++/5/bits/gthr.h:30:37: error: expected ‘}’ before end of line\nIn file included from main.cpp:1:0:\nsource.cpp: In member function ‘void Table::addCol(int)’:\nsource.cpp:16:3: error: ‘header’ was not declared in this scope\n   header[column] = x;\n   ^\nIn file included from /usr/include/c++/5/ext/atomicity.h:35:0,\n                 from /usr/include/c++/5/bits/ios_base.h:39,\n                 from /usr/include/c++/5/ios:42,\n                 from /usr/include/c++/5/ostream:38,\n                 from /usr/include/c++/5/iostream:39,\n                 from main.cpp:3:\n/usr/include/x86_64-linux-gnu/c++/5/bits/gthr.h: At global scope:\n/usr/include/x86_64-linux-gnu/c++/5/bits/gthr.h:30:37: error: expected unqualified-id before end of line\n/usr/include/x86_64-linux-gnu/c++/5/bits/gthr.h:30:37: error: expected declaration before end of line\n"
        ],
        [
            "2020-07-09 LAB",
            "唐晨轩",
            "#include <iostream>\n#include <vector>\nusing namespace std;\nvector<int> ans;\nclass Integer\n{\n\tfriend istream & operator >> (istream & in, Integer & m);\n\tfriend ostream & operator << (ostream & out, const Integer & m);\n\t\npublic:\n\tint data;\n\tInteger(){\n\t\tdata = 0;\n\t\tans.push_back(data);\n\t}\n\tInteger(int x){\n\t\tdata = x;\n\t\tans.push_back(data);\n\t}\n\tInteger operator = (int x){\n\t\tdata = x;\n\t\treturn *this;\n\t}\n\tInteger operator = (Integer & x){\n\t\tdata = x.data;\n\t\treturn *this;\n\t}\n\tstatic void increase_all(int n){\n\t\tans[0] += n;\n\t\tans[1] += n;\n\t}\n\tstatic void increase_all(Integer & m){\n\t\tans[0] += ans[1];\n\t\tans[1] += ans[1];\n\t}\n};\nistream & operator >> (istream & in, Integer & m){\n\tint mid;\n\tin >> mid;\n//\tm = mid;\n\tInteger tmp(mid);\n\tm = tmp;\n\treturn in;\n}\nostream & operator << (ostream & out, const Integer & m){\n\tif(m.data == 10){\n\t\tout << ans[0];\n\t}\n\telse{\n\t\tout << ans[1];\n\t}\n\treturn out;\n}\n",
            1594265949.1351469,
            75,
            "# 答案不正确\n\n# 随机输入:\n84\n\n\n# 参考答案:\n10 84\n110 184\n294 368\n\n\n# 我的答案:\n10 0\n110 100\n210 200\n"
        ],
        [
            "A.1 (C++)",
            "唐晨轩",
            "Node<E> * get_node(int index) const{\n\tif(index == -1) return 0;\n\tif(index < 0 || index >= _size)\n\t\tthrow NotSuchElementException();\n\tif(index < _size/2){\n\t\tNode<E> * node = head;\n\t\tI(i, index) node = node->next_node(get_node(i-1));\n\t\treturn node;\n\t}\n\telse{\n\t\tNode<E> * node = tail;\n\t\tI(i, (_size-1-index)) node = node->prev_node(get_node(i+1));\n\t\treturn node;\n\t}\n}\n\nvoid removeFirstOccurrence(const E & e) {\n\tint index = indexOf(e);\n\tif(index == -1)\n\t\tthrow NotSuchElementException();\n\tremove(index);\n}\nint indexOf(const E & e) const {\n\tNode<E> * node = head;\n\tI(i, _size){\n\t\tif(node->element == e) return i;\n\t\tnode = node->next_node(get_node(i-1));\n\t}\n\treturn -1;\n}\nvoid remove (int index){\n\tNode<E> * node = get_node(index);\n\tNode<E> * prev_node = node->prev_node(get_node(index-1));\n\tNode<E> * next_node = node->next_node(get_node(index+1));\n\tif(prev_node != 0) prev_node->update_next_node(get_node(index+1), next_node);\n\tif(next_node != 0) next_node->update_prev_node(get_node(index-1), prev_node);\n\tif(prev_node == 0) head = next_node;\n\tif(next_node == 0) tail = prev_node;\n\tdelete node;\n\t-- _size;\n}\nLinkedList & operator = (const LinkedList & list){\n\tclear();\n\tallAll(list);\n}\nvoid clear() {\n\twhile(_size > 0) removeFirst();\n}\nvoid allAll(const LinkedList & list, int index = -1){\n\tif(index == -1) index = _size;\n\tNode<E> * node = list.head;\n\tI(i, list._size){\n\t\tadd(index + i, node->element);\n\t\tnode = node->next_node();\n\t}\n}\nvoid add(int index, const E & e){\n\tif(index < 0 || index > _size)\n\t\tthrow NotSuchElementException();\n\tNode<E> * node = new Node<E>();\n\tnode->element = e;\n\tNode<E> * next_node = (index ==_size ? 0 : get_node(index));\n\tNode<E> * prev_node = (next_node == 0 ? tail : get_node(index-1));\n\tnode->update_next_node(get_node(index+1),next_node);\n\tnode->update_prev_node(get_node(index-1),prev_node);\n\tif(prev_node != 0) prev_node->update_next_node(get_node(index+1),node);\n\tif(next_node != 0) next_node->update_prev_node(get_node(index-1),node);\n\tif(prev_node == 0) head = node;\n\tif(next_node == 0) tail = node;\n\t++_size;\n}\nvoid addFirst(const E & e){\n\tadd(0, e);\n/*\tNode<E> * node = new Node<E>();\n\tnode->element = e;\n\tnode->update_prev_and_next_node(0, head);\n\tif(head != 0) head->update_prev_node(tail->prev_node(0), 0);\n\thead = node;\n\tif(tail == 0) tail = node;\n\t++ _size;*/\n}\nvoid addLast(const E & e){\n\tadd(_size, e);\n/*\tNode<E> * node = new Node<E>();\n\tnode->element = e;\n\tnode->update_prev_and_next_node(tail, 0);\n\tif(tail != 0) tail->update_next_node(tail->next_node(0), 0);\n\ttail = node;\n\tif(head == 0) head = node;\n\t++ _size;*/\n}\nvoid removeFirst(){\n\tremove(0);\n/*\tif(head == 0){\n\t\tthrow NotSuchElementException();\n\t}\n\tNode<E> * temp = head;\n\thead = head->next_node(0);\n\tdelete temp;\n\tif(head != 0) head->update_prev_node(tail->prev_node(0), 0);\n\t-- _size;*/\n}\nvoid removeLast(){\n\tremove(_size-1);\n/*\tif(tail == 0){\n\t\tthrow NotSuchElementException();\n\t}\n\tNode<E> * temp = tail;\n\ttail = tail->prev_node(0);\n\tdelete temp;\n\tif(tail != 0) tail->update_next_node(tail->next_node(0), 0);\n\t-- _size;*/\n}\nE & get(int index){\n\tNode<E> * node = get_node(index);\n\treturn node->element;\n}",
            1594434721.9822812,
            0,
            "terminate called after throwing an instance of 'NotSuchElementException'\nAborted (core dumped)\n"
        ],
        [
            "A.2 (C++)",
            "唐晨轩",
            "template <typename E>\nvoid LinkedList<E>::removeAll(const E & e){\n\tint len = size();\n\tI(i,len){\n\t\tint now = indexOf(e);\n\t\tif(now != -1){\n\t\t\tremoveFirstOccurrence(e);\n\t\t}\n\t}\n}",
            1594869102.9663103,
            100,
            "# 答案正确"
        ],
        [
            "A.3 (C++)",
            "唐晨轩",
            "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <stdexcept>\nusing namespace std;\n\n#define I(i,n) for (size_t i = 0; i < n; ++ i)\n\nclass NoSuchKeyException {};\n\nsize_t circular_shift(size_t bits, int shift_bits) {\n\tconst int num_bits = 8 * sizeof(size_t);\n\tshift_bits = shift_bits % num_bits;\n\treturn bits << shift_bits | bits >> (num_bits - shift_bits);\n}\n\nsize_t hash_function(const int & key) {\n\tsize_t code = 0;\n\tI(i, key.size())\n\t\tcode ^= circular_shift(key[i], i * 5);\n\treturn code;\n}\n\ntemplate <typename V>\nclass HT\n{\n\tclass Tuple\n\t{\n\tpublic:\n\t\tint key;\n\t\tV val;\n\t\tbool in_use;\n\n\t\tTuple() : in_use(false) {}\n\t};\n\n\tvector<Tuple> tuples;\n\tsize_t _size;\n\n\tsize_t canonical_index(const int & key) const {\n\t\tsize_t hash_code = hash_function(key); // needs hash_function(K)\n\t\treturn hash_code % tuples.size();\n\t}\n\n\t// the returned tuple is either empty or with the same key\n\tsize_t indexOfKey(const int & key) const {\n\t\tsize_t index = canonical_index(key);\n\t\twhile (true) { // will enter a dead loop if there is not empty tuple\n\t\t\tif (! tuples[index].in_use) return index;\n\t\t\tif (tuples[index].key == key) return index;\n\t\t\tindex = (index + 1) % tuples.size();\n\t\t}\n\t}\n\npublic:\n\tHT() : _size(0) {\n\t\ttuples.resize(2);\n\t}\n\n\tbool containsKey(const int & key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\treturn tuples[index].in_use;\n\t}\n\n\tconst V & operator [] (const int & key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples[index].val;\n\t}\n\n\tV & operator [] (const int & key) {\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples[index].val;\n\t}\n\n\tvoid put(const int & key, const V & val) {\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].key = key;\n\t\ttuples[index].val = val;\n\t\tif (tuples[index].in_use) return;\n\t\ttuples[index].in_use = true;\n\t\t++ _size;\n\t\t// make sure empty > size / 2\n\t\tif (2 * _size > tuples.size())\n\t\t\t_double_tuples();\n\t}\n\n\tvoid _double_tuples() {\n\t\tvector<Tuple> non_empty_tuples;\n\t\tI(i, tuples.size())\n\t\t\tif (tuples[i].in_use)\n\t\t\t\tnon_empty_tuples.push_back(tuples[i]);\n\t\tclear();\n\t\ttuples.resize(tuples.size() * 2);\n\t\tI(i, non_empty_tuples.size())\n\t\t\tput(non_empty_tuples[i].key, non_empty_tuples[i].val);\n\t}\n\n\tstatic bool _between(size_t hole, size_t canonical, size_t tuple_index) {\n\t\tif (hole < tuple_index)\n\t\t\treturn canonical > hole && canonical <= tuple_index;\n\t\telse\n\t\t\treturn canonical > hole || canonical <= tuple_index;\n\t}\n\n\tvoid remove(const int & key) { \n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\ttuples[index].in_use = false;\n\t\t-- _size;\n\t\t// if there is a hole between a tuple and its canonical position\n\t\t// move the tuple to the hole\n\t\tsize_t hole = index;\n\t\tsize_t tuple_index = hole;\n\t\twhile (true) {\n\t\t\ttuple_index = (tuple_index + 1) % tuples.size();\n\t\t\tif (! tuples[tuple_index].in_use) return;\n\t\t\tsize_t canonical = canonical_index(tuples[tuple_index].key);\n\t\t\tif (_between(hole, canonical, tuple_index)) continue;\n\t\t\ttuples[hole] = tuples[tuple_index];\n\t\t\thole = tuple_index;\n\t\t\ttuples[hole].in_use = false;\n\t\t}\n\t}\n\n\tsize_t size() const { return _size; }\n\n\tvoid clear() {\n\t\tI(i, tuples.size())\n\t\t\ttuples[i].in_use = false;\n\t\t_size = 0;\n\t}\n\n\ttemplate <typename V2>\n\tfriend ostream & operator << (ostream & out, const HT<V2> & dict);\n\n\ttemplate <typename V2>\n\tfriend istream & operator >> (istream & in, HT<V2> & dict);\n\n\tvoid _inspect() const {\n\t\tI(i, tuples.size())\n\t\t\tif (tuples[i].in_use)\n\t\t\t\tcout << \"#\" << i << \" C\" << canonical_index(tuples[i].key) \n\t\t\t\t\t<< \" \" << tuples[i].key << \" \" << tuples[i].val << endl;\n\t}\n};\n\ntemplate <typename V>\nostream & operator << (ostream & out, const HT<V> & dict) {\n\tout << dict.size() << endl;\n\tI(i, dict.tuples.size())\n\t\tif (dict.tuples[i].in_use)\n\t\t\tout << dict.tuples[i].key << \"\\t\" << dict.tuples[i].val << endl;\n\treturn out;\n}\n\ntemplate <typename V>\nistream & operator >> (istream & in, HT<V> & dict) {\n\tdict.clear();\n\tsize_t size;\n\tin >> size;\n\tI(i, size) {\n\t\tint key;\n\t\tV val;\n\t\tin >> key >> val;\n\t\tdict.put(key, val);\n\t}\n\treturn in;\n}\n\ninline HT<string> load_dict() {\n\tHT<string> dict;\n\tifstream in(\"my_dict.txt\");\n\tif (in.fail())\n\t\tthrow runtime_error(\"Failed to load dictionary\");\n\tin >> dict;\n\tin.close();\n\treturn dict;\n}\n\ninline void save_dict(const HT<string> & dict) {\n\tofstream out(\"my_dict.txt\");\n\tif (out.fail())\n\t\tthrow runtime_error(\"Failed to save dictionary\");\n\tout << dict;\n\tout.close();\n}",
            1595470931.1982486,
            0,
            "In file included from main.cpp:2:0:\nsource.cpp: In function ‘size_t hash_function(const int&)’:\nsource.cpp:20:11: error: request for member ‘size’ in ‘key’, which is of non-class type ‘const int’\n  I(i, key.size())\n           ^\nsource.cpp:8:39: note: in definition of macro ‘I’\n #define I(i,n) for (size_t i = 0; i < n; ++ i)\n                                       ^\nsource.cpp:21:31: error: invalid types ‘const int[size_t {aka long unsigned int}]’ for array subscript\n   code ^= circular_shift(key[i], i * 5);\n                               ^\nmain.cpp: In function ‘int main()’:\nmain.cpp:26:25: error: ‘class HT<std::__cxx11::basic_string<char> >’ has no member named ‘getKeys’\n  vector<int> keys = map.getKeys();\n                         ^\n"
        ]
    ],
    "table_name": "答案"
}