{
    "__update_time__": 1596199257.6649125,
    "field_names": [
        "题目名",
        "用户名",
        "答案",
        "提交时间",
        "分数",
        "评语"
    ],
    "field_types": [
        "text",
        "text",
        "text",
        "time",
        "number",
        "text"
    ],
    "foreign_keys": {},
    "primary_keys": [],
    "rows": [
        [
            "测试2",
            "万金诚",
            "#include<iostream>\n#include<cstring>\nusing namespace std;\nvoid sort(char **a){\n\tfor(int i=0;i<10;i++){\n\t\tfor(int j=0;j<9;j++){\n\t\t\tif(strcmp(a[j],a[j+1])>0){\n\t\t\t\tchar temp[20];\n\t\t\t\tstrcpy(temp,a[j]);\n\t\t\t\tstrcpy(a[j],a[j+1]);\n\t\t\t\tstrcpy(a[j+1],temp);\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tchar **a=new char* [10];\n\tfor(int i=0;i<10;i++){\n\t\ta[i]=new char[20];\n\t\tcin>>a[i];\n\t}\n\tsort(a);\n\tfor(int i=0;i<10;i++){\n\t\tcout<<a[i]<<\" \";\n\t}\n\tfor(int i=10;i>=0;i--){\n\t\tdelete a[i];\n\t}\n\tdelete a;\n}",
            1587609704.5514095,
            100,
            "# 答案正确"
        ],
        [
            "测试1",
            "万金诚",
            "#include <iostream>\nusing namespace std;\nint main(){\n\tchar **a=new char* [3];\n\tfor(int i=0;i<3;i++){\n\t\ta[i]=new char[50];\n\t\tcin>>a[i];\n\t}\n\tfor(int i=2;i>=0;i--){\n\t\tcout<<a[i]<<' ';\n\t\tdelete a[i];\n\t}\n\tdelete a;\n}",
            1587609915.0994031,
            100,
            "# 答案正确"
        ],
        [
            "1.1 (C++)",
            "万金诚",
            "#include<cstring>\nclass Matrix5x5{\n\tdouble a[5][5];\n\tpublic :\n\t\tMatrix5x5(){\n\t\t\tmemset(a,0,sizeof(a));\t\n\t\t}\n\t\tdouble get(int row,int col){\n\t\t\treturn a[row][col];\n\t\t}\n\t\tvoid set(int y,int x,double n){\n\t\t\ta[y][x]=n;\n\t\t}\n\t\tMatrix5x5 operator +(Matrix5x5 &b){\n\t\t\tMatrix5x5 temp;\n\t\t\tfor(int i=0;i<5;i++){\n\t\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\t\ttemp.set(i,j,this->get(i,j)+b.get(i,j));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn temp;\n\t\t}\n};",
            1587697242.6512702,
            100,
            "# 答案正确"
        ],
        [
            "1.2 (C++)",
            "万金诚",
            "#include<iostream>\n#include<cstring>\n\nusing namespace std;\nclass  School{\n\tpublic :\n\t\tint age;\n\t\tchar name[50];\n\t\tSchool(){\n\t\t\tage=0;\n\t\t\tstrcpy(name,\"NO_NAME\");\n\t\t}\n\t\tvoid setName(char name[]){\n\t\t\tstrcpy(this->name,name);\n\t\t}\n\t\tvoid setAge(int year){\n\t\t\tage=year;\n\t\t}\n\t\tvoid operator ++ (){\n\t\t\tage++;\n\t\t}\n};",
            1588212739.6714294,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/08",
            "万金诚",
            "double & Tensor_get(int dimensions, const int sizes[], double data[], int x0, int x1, int x2, int x3){\n\tint cnt=0;\n\tint x[4];\n\tx[0]=x0;\n\tx[1]=x1;\n\tx[2]=x2;\n\tx[3]=x3;\n\tfor(int i=0;i<4;i++){\n\t\tif(x[i]>0){\n\t\t\tint temp=1;\n\t\t\tfor(int j=dimensions;j>i;j--){\n\t\t\t\ttemp*=sizes[j];\n\t\t\t}\n\t\t\tcnt+=x[i]*temp;\n\t\t}\n\t\tif(x[i]==-1)\n\t\tbreak;\n\t}\n\treturn data[cnt];\n}",
            1588907660.249439,
            100,
            "# 答案正确"
        ],
        [
            "2.1 (C++)",
            "万金诚",
            "#include<iostream>\n#include<iomanip>\n#include<cstring>\nusing namespace std;\nclass Matrix{\n\tprivate:\n\t\tint rows;\n\t\tint columens;\n\t\tdouble *values;\n\tpublic:\n\t\tMatrix(int r,int c){\n\t\t\tthis->rows=r,this->columens=c;\n\t\t\tvalues=new double [r*c];\n\t\t\tmemset(values,0,sizeof(double)*r*c);\n\t\t}\n\t\t~Matrix(){\n\t\t\tdelete [] values;\n\t\t}\n\t\tvoid print(){\n\t\t\tfor(int i=0;i<this->rows;i++){\n\t\t\t\tfor(int j=0;j<this->columens;j++){\n\t\t\t\t\tcout<<setw(5)<<values[i*this->columens+j];\n\t\t\t\t}\n\t\t\t\tcout<<endl;\n\t\t\t}\n\t\t}\n}; ",
            1589035813.3261104,
            100,
            "# 答案正确"
        ],
        [
            "2.2 (C++)",
            "万金诚",
            "#include<iostream>\n#include<iomanip>\nusing namespace std;\nclass Matrix{\n\tprivate:\n\t\tint rows;\n\t\tint columens;\n\t\tdouble *values;\n\tpublic:\n\t\tMatrix(int r,int c,double *v){\n\t\t\tthis->rows=r,this->columens=c;\n\t\t\tvalues=new double [r*c];\n\t\t\tfor(int i=0;i<r;i++){\n\t\t\t\tfor(int j=0;j<c;j++){\n\t\t\t\t\tthis->values[i*c+j]=v[i*c+j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t~Matrix(){\n\t\t\tdelete [] values;\n\t\t}\n\t\tvoid print(){\n\t\t\tfor(int i=0;i<this->rows;i++){\n\t\t\t\tfor(int j=0;j<this->columens;j++){\n\t\t\t\t\tcout<<setw(5)<<values[i*this->columens+j];\n\t\t\t\t}\n\t\t\t\tcout<<endl;\n\t\t\t}\n\t\t}\n}; ",
            1589036096.4527123,
            100,
            "# 答案正确"
        ],
        [
            "2.3 (C++)",
            "万金诚",
            "#include<iostream>\n#include<iomanip>\nusing namespace std;\nclass Matrix{\n\tprivate:\n\t\tint rows;\n\t\tint columns;\n\t\tdouble *values;\n\tpublic:\n\t\tMatrix(int r,int c,double *v){\n\t\t\tthis->rows=r,this->columns=c;\n\t\t\tvalues=new double [r*c];\n\t\t\tfor(int i=0;i<r;i++){\n\t\t\t\tfor(int j=0;j<c;j++){\n\t\t\t\t\tthis->values[i*c+j]=v[i*c+j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t~Matrix(){\n\t\t\tdelete [] values;\n\t\t}\n\t\tvoid print(){\n\t\t\tfor(int i=0;i<this->rows;i++){\n\t\t\t\tfor(int j=0;j<this->columns;j++){\n\t\t\t\t\tcout<<\"    \"<<values[i*this->columns+j];\n\t\t\t\t}\n\t\t\t\tcout<<endl;\n\t\t\t}\n\t\t}\n\t\tMatrix(Matrix &a):columns(a.columns),rows(a.rows){\n\t\t\tvalues=new double [columns*rows];\n\t\t\tfor(int i=0;i<rows*columns;i++){\n\t\t\t\tthis->values[i]=a.values[i];\n\t\t\t}\n\t\t}\n};",
            1589036870.9362085,
            100,
            "# 答案正确"
        ],
        [
            "2.5 (C++)",
            "万金诚",
            "#include<iostream>\n#include<iomanip>\nusing namespace std;\nclass Matrix{\n\tprivate:\n\t\tint rows;\n\t\tint columns;\n\t\tdouble *values;\n\tpublic:\n\t\tMatrix(int r,int c,double *v){\n\t\t\tthis->rows=r,this->columns=c;\n\t\t\tvalues=new double [r*c];\n\t\t\tfor(int i=0;i<r;i++){\n\t\t\t\tfor(int j=0;j<c;j++){\n\t\t\t\t\tthis->values[i*c+j]=v[i*c+j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t~Matrix(){\n\t\t\tdelete [] values;\n\t\t}\n\t\tvoid print(){\n\t\t\tfor(int i=0;i<this->rows;i++){\n\t\t\t\tfor(int j=0;j<this->columns;j++){\n\t\t\t\t\tcout<<\"    \"<<values[i*this->columns+j];\n\t\t\t\t}\n\t\t\t\tcout<<endl;\n\t\t\t}\n\t\t}\n\t\tMatrix(Matrix &a):columns(a.columns),rows(a.rows){\n\t\t\tvalues=new double [columns*rows];\n\t\t\tfor(int i=0;i<rows*columns;i++){\n\t\t\t\tthis->values[i]=a.values[i];\n\t\t\t}\n\t\t}\n\t\tMatrix getRow(int r){\n\t\t\tdouble a[this->columns];\n\t\t\tfor(int i=0;i<this->columns;i++){\n\t\t\t\ta[i]=this->values[(r-1)*this->columns+i];\n\t\t\t}\n\t\t\tMatrix temp(1,this->columns,a);\n\t\t\treturn temp;\n\t\t}\n\t\tMatrix getColumn(int c){\n\t\t\tdouble a[this->rows];\n\t\t\tfor(int i=0;i<this->rows;i++){\n\t\t\t\ta[i]=this->values[i*this->columns+c-1];\n\t\t\t}\n\t\t\tMatrix temp(this->rows,1,a);\n\t\t\treturn temp;\n\t\t}\n}; ",
            1589040371.1965988,
            100,
            "# 答案正确"
        ],
        [
            "2.6 (C++)",
            "万金诚",
            "#include<iostream>\n#include<iomanip>\nusing namespace std;\nclass Matrix{\n\tprivate:\n\t\tint rows;\n\t\tint columns;\n\t\tdouble *values;\n\tpublic:\n\t\tMatrix(int r,int c,double *v){\n\t\t\tthis->rows=r,this->columns=c;\n\t\t\tvalues=new double [r*c];\n\t\t\tfor(int i=0;i<r;i++){\n\t\t\t\tfor(int j=0;j<c;j++){\n\t\t\t\t\tthis->values[i*c+j]=v[i*c+j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t~Matrix(){\n\t\t\tdelete [] values;\n\t\t}\n\t\tvoid print(){\n\t\t\tfor(int i=0;i<this->rows;i++){\n\t\t\t\tfor(int j=0;j<this->columns;j++){\n\t\t\t\t\tcout<<\"    \"<<values[i*this->columns+j];\n\t\t\t\t}\n\t\t\t\tcout<<endl;\n\t\t\t}\n\t\t}\n\t\tMatrix(const Matrix &a):columns(a.columns),rows(a.rows){\n\t\t\tvalues=new double [columns*rows];\n\t\t\tfor(int i=0;i<rows*columns;i++){\n\t\t\t\tthis->values[i]=a.values[i];\n\t\t\t}\n\t\t}\n\t\tMatrix getRow(int r){\n\t\t\tdouble a[this->columns];\n\t\t\tfor(int i=0;i<this->columns;i++){\n\t\t\t\ta[i]=this->values[r*this->columns+i];\n\t\t\t}\n\t\t\tMatrix temp(1,this->columns,a);\n\t\t\treturn temp;\n\t\t}\n\t\tMatrix getColumn(int c){\n\t\t\tdouble a[this->rows];\n\t\t\tfor(int i=0;i<this->rows;i++){\n\t\t\t\ta[i]=this->values[i*this->columns+i];\n\t\t\t}\n\t\t\tMatrix temp(this->rows,1,a);\n\t\t}\n\t\tMatrix concatenateColumns(const Matrix & matrix2) const{\n\t\t\tint sum=this->columns*this->rows+matrix2.columns*matrix2.rows;\n\t\t\tdouble a[sum];\n\t\t\tint m=0,n=0;\n\t\t\tfor(int i=0;i<this->rows;i++){\n\t\t\t\tfor(int j=0;j<this->columns;j++){\n\t\t\t\t\ta[i*(this->columns+matrix2.columns)+j]=this->values[m++];\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<matrix2.columns;j++){\n\t\t\t\t\ta[i*(this->columns+matrix2.columns)+this->columns+j]=matrix2.values[n++];\n\t\t\t\t}\n\t\t\t}\n\t\t\tMatrix temp(this->rows,sum/this->rows,a);\n\t\t\treturn temp;\n\t\t}\n\t\tMatrix concatenateRows(const Matrix & matrix2) const{\n\t\t\tint sum=this->columns*this->rows+matrix2.columns*matrix2.rows;\n\t\t\tdouble a[sum];\n\t\t\tfor(int i=0;i<sum;i++){\n\t\t\t\tif(i<this->columns*this->rows){\n\t\t\t\t\ta[i]=this->values[i];\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse \n\t\t\t\ta[i]=matrix2.values[i-this->columns*this->rows];\n\t\t\t}\n\t\t\tMatrix temp(sum/this->columns,this->columns,a);\n\t\t\treturn temp;\n\t\t}\n}; ",
            1589042115.155415,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/14",
            "万金诚",
            "#include<iostream>\nusing namespace std;\nvoid Tensor_print(int dimensions, const int sizes[], const double data[]){\n\tcout<<\"Tensor of \"<<sizes[0];\n\tfor(int i=2;i<=dimensions;i++){\n\t\tcout<<\"x\"<<sizes[i-1];\n\t}\n\tcout<<endl;\n\tswitch(dimensions){\n\t\tcase 1:\n\t\tfor(int i=0;i<sizes[0];i++){\n\t\t\tcout<<data[i]<<endl;\n\t\t}\n\t\tbreak;\n\t\tcase 2:\n\t\tfor(int i=0;i<sizes[0];i++){\n\t\t\tfor(int j=0;j<sizes[1];j++){\n\t\t\t\tcout<<\"    \"<<data[i*sizes[1]+j];\n\t\t\t} cout<<endl;\n\t\t}\n\t\tbreak;\n\t\tcase 3:\n\t\tfor(int i=0;i<sizes[0];i++){\n\t\t\tcout<<\"data[\"<<i<<\"]\"<<endl;\n\t\t\tfor(int j=0;j<sizes[1];j++){\n\t\t\t\tfor(int k=0;k<sizes[2];k++){\n\t\t\t\t\tcout<<\"    \"<<data[j*sizes[2]+k];\n\t\t\t\t}cout<<endl;\n\t\t\t}\n\t\t\t\n\t\t} break;\n\t\tcase 4:\t\n\t\tfor(int i=0;i<sizes[0];i++){\n\t\t\tfor(int j=0;j<sizes[1];j++){\n\t\t\t\tcout<<\"data[\"<<i<<\"]\"<<\"[\"<<j<<\"]\"<<endl;\n\t\t\t\tfor(int k=0;k<sizes[2];k++){\n\t\t\t\t\tfor(int l=0;l<sizes[3];l++){\n\t\t\t\t\t\tcout<<\"    \"<<data[k*sizes[3]+l];\n\t\t\t\t\t}cout<<endl;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n}",
            1589424691.51252,
            100,
            "# 答案正确"
        ],
        [
            "2.4 (C++)",
            "万金诚",
            "#include<bits/stdc++.h>\nusing namespace std;\nclass Matrix{\n\tprivate:\n\t\tint rows;\n\t\tint columns;\n\t\tdouble * values;\n\tpublic:\n\t\tMatrix(int row, int column):rows(row),columns(column){\n\t\t\tvalues=NULL;\n\t\t}\n\t\t Matrix(int rows, int columns, double value[]){\n\t\t \tthis->columns=columns;\n\t\t \tthis->rows=rows;\n\t\t \tthis->values=new double[(rows+1)*(columns+1)];\n\t\t \tfor(int i=1;i<=rows;i++){\n\t\t \t\tfor(int j=1;j<=columns;j++){\n\t\t \t\t\tthis->values[i*columns+j]=value[(i-1)*columns+j-1];\n\t\t\t\t }\n\t\t\t }\n\t\t }\n\t\t ~Matrix(){\n\t\t \tif(this->values!=NULL){\n\t\t \t\tdelete[] this->values;\n\t\t\t\tvalues=NULL;\n\t\t\t }\n\t\t }\n\t\t void print(){\n\t\t\t if(values==NULL)\n\t\t\t\t return ;\n\t\t \tfor(int i=1;i<=rows;i++){\n\t\t \t\tfor(int j=1;j<=columns;j++){\n\t\t \t\t\tcout<<\"    \"<<this->values[i*columns+j];\n\t\t\t\t }cout<<endl;\n\t\t\t }\n\t\t }\n\t\tvoid set(int row, int column, double value){\n\t\t\tvalues[row*columns+column]=value;\n}\n\t Matrix & operator =( Matrix &a){\n\t\t rows=a.rows;\n\t\t columns=a.columns;\n\t\t values=new double [(rows+1)*(columns+1)];\n\t\t for(int i=1;i<=rows;i++){\n\t\t\t for(int j=1;j<=columns;j++){\n\t\t\t\t values[i*columns+j]=a.values[i*columns+j];\n\t\t\t }\n\t\t }\n\t\t return (*this);\n\t }\n\t\t \n};",
            1589810169.1024058,
            100,
            "# 答案正确"
        ],
        [
            "2.7 (C++)",
            "万金诚",
            "#include<bits/stdc++.h>\nusing namespace std;\nclass Matrix{\n\tprivate:\n\t\tint rows;\n\t\tint columns;\n\t\tdouble * values;\n\t\tvoid assign(){\n\t\t\tif(values!=0)\n\t\t\tdelete [] values;\n\t\t}\n\tpublic:\n\t\tMatrix(int rows, int column, double values[]){\n\t\t\t\n\t\t\tthis->columns=column;\n\t\t\tthis->rows=rows;\n\t\t\tthis->values=new double[rows*columns];\n\t\t\tfor(int i=0;i<rows*columns;i++){\n\t\t\t\tthis->values[i]=values[i];\n\t\t\t}\n\t\t}\n\t\tMatrix(const Matrix & matrix2):rows(matrix2.rows),columns(matrix2.columns){\n\t\t\tassign();\n\t\t\tvalues=new double[rows*columns];\n\t\t\tfor(int i=0;i<rows;i++){\n\t\t\t\tfor(int j=0;j<columns;j++){\n\t\t\t\t\tvalues[i*columns+j]=matrix2.values[i*columns+j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t~Matrix(){\n\t\t\tassign();\n\t\t}\n\tMatrix & operator =(Matrix & a){\n\t\t \tassign();\n\t\t \tthis->columns=a.columns;\n\t\t \tthis->rows=a.rows;\n\t\t \tvalues=new double[rows*columns];\n\t\t\tfor(int i=0;i<rows;i++){\n\t\t\t\tfor(int j=0;j<columns;j++){\n\t\t\t\t\tthis->values[i*columns+j]=a.values[i*columns+j];\n\t\t\t\t}\n\t\t\t}\n\t\treturn (*this);\n\t\t }\n\t\t void print(){\n\t\t\tif(values==NULL)\n\t\t\treturn ;\n\t\t\tfor(int i=0;i<rows;i++){\n\t\t\t\tfor(int j=0;j<columns;j++){\n\t\t\t\t\tcout<<\"    \"<<values[i*columns+j];\n\t\t\t\t}cout<<endl;\n\t\t\t}\n\t\t }\n\t\t  Matrix reshape(int rows, int columns) const;\n\t\t \n\t\t \n};\n Matrix Matrix::reshape(int rows, int columns) const{\n \tdouble temp1[1000];\n\t int k=0;\n \tfor(int i=0;i<this->columns;i++){\n\t\tfor(int j=0;j<this->rows;j++){\n\t\t\ttemp1[k++]=this->values[i+j*this->columns];\n\t\t}\n\t}k=0;double temp[1000];\n\t for(int i=0;i<columns;i++){\n\t\tfor(int j=0;j<rows;j++){\n\t\t\ttemp[j*columns+i]=temp1[k++];\n\t\t}\n\t}\n\t Matrix a(rows,columns,temp);\n \treturn a;\n }\n",
            1589935088.9513404,
            100,
            "# 答案正确"
        ],
        [
            "2.8 (C++)",
            "万金诚",
            "#include<bits/stdc++.h>\nusing namespace std;\nclass Matrix{\n\tprivate:\n\t\tint rows;\n\t\tint columns;\n\t\tdouble * values;\n\t\tvoid assign(){\n\t\t\tif(values!=0)\n\t\t\tdelete [ ] values;\n\t\t}\n\tpublic:\n\t\tMatrix(int rows, int column, double values[]){\n\t\t\tthis->columns=column;\n\t\t\tthis->rows=rows;\n\t\t\tthis->values=new double[rows*columns];\n\t\t\tfor(int i=0;i<rows;i++){\n\t\t\t\tfor(int j=0;j<columns;j++){\n\t\t\t\t\tthis->values[i*columns+j]=values[i*columns+j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tMatrix(const Matrix & matrix2):rows(matrix2.rows),columns(matrix2.columns){\n\t\t\tassign();\n\t\t\tvalues=new double[rows*columns];\n\t\t\tfor(int i=0;i<rows;i++){\n\t\t\t\tfor(int j=0;j<columns;j++){\n\t\t\t\t\tvalues[i*columns+j]=matrix2.values[i*columns+j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t~Matrix(){\n\t\t\tassign();\n\t\t}\n\t\t void print(){\n\t\t \t//cout<<\"print\";\n\t\t\tif(values==NULL)\n\t\t\treturn ;\n\t\t\tfor(int i=0;i<rows;i++){\n\t\t\t\tfor(int j=0;j<columns;j++){\n\t\t\t\t\tcout<<\"    \"<<values[i*columns+j];\n\t\t\t\t}cout<<endl;\n\t\t\t}\n\t\t }\n\t\t  //Matrix reshape(int rows, int columns) const;\n\t\t Matrix transpose(){\n\t\t \tdouble a[1000];\n\t\t \tfor(int i=0;i<columns;i++){\n\t\t \t\tfor(int j=0;j<rows;j++){\n\t\t \t\t\ta[i*rows+j]=values[j*columns+i];\n\t\t\t\t }\n\t\t\t }\n\t\t \tMatrix temp(columns,rows,a);\n\t\t \treturn temp;\n\t\t }\n\t\t \n};\n\n \n",
            1589818254.738461,
            100,
            "# 答案正确"
        ],
        [
            "2.10 (C++)",
            "万金诚",
            "#include<bits/stdc++.h>\nusing namespace std;\nclass Matrix{\n\tprivate:\n\t\tint rows;\n\t\tint columns;\n\t\tdouble * values;\n\t\tvoid assign(){\n\t\t\tif(values!=0)\n\t\t\tdelete [ ] values;\n\t\t}\n\tpublic:\n\t\tMatrix(int rows, int column, double values[]){\n\t\t\tthis->columns=column;\n\t\t\tthis->rows=rows;\n\t\t\tthis->values=new double[rows*columns];\n\t\t\tfor(int i=0;i<rows;i++){\n\t\t\t\tfor(int j=0;j<columns;j++){\n\t\t\t\t\tthis->values[i*columns+j]=values[i*columns+j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tMatrix(const Matrix & matrix2):rows(matrix2.rows),columns(matrix2.columns){\n\t\t\tassign();\n\t\t\tvalues=new double[rows*columns];\n\t\t\tfor(int i=0;i<rows;i++){\n\t\t\t\tfor(int j=0;j<columns;j++){\n\t\t\t\t\tvalues[i*columns+j]=matrix2.values[i*columns+j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t~Matrix(){\n\t\t\tassign();\n\t\t}\n\t\t void print(){\n\t\t \t//cout<<\"print\";\n\t\t\tif(values==NULL)\n\t\t\treturn ;\n\t\t\tfor(int i=0;i<rows;i++){\n\t\t\t\tfor(int j=0;j<columns;j++){\n\t\t\t\t\tcout<<\"    \"<<values[i*columns+j];\n\t\t\t\t}cout<<endl;\n\t\t\t}\n\t\t }\n\t\t  //Matrix reshape(int rows, int columns) const;\n\t\t Matrix transpose(){\n\t\t \tdouble a[1000];\n\t\t \tfor(int i=0;i<columns;i++){\n\t\t \t\tfor(int j=0;j<rows;j++){\n\t\t \t\t\ta[i*rows+j]=values[j*columns+i];\n\t\t\t\t }\n\t\t\t }\n\t\t \tMatrix temp(columns,rows,a);\n\t\t \treturn temp;\n\t\t }\n\t\t Matrix operator * (const Matrix & matrix2) const{\n\t\t \tdouble temp[1000];\n\t\t\tmemset(temp,0,sizeof(temp));\n\t\t \tfor(int i=0;i<rows;i++){\n\t\t \t\t//for(int j=0;j<columns;j++){\n\t\t \t\t\tfor(int j=0;j<matrix2.columns;j++){\n\t\t \t\t\t\tfor(int k=0;k<columns;k++){\n\t\t \t\t\t\t    temp[i*matrix2.columns+j]+=this->values[i*columns+k]*matrix2.values[k*matrix2.columns+j];\t\n\t\t\t\t\t\t }\n\t\t \t\t\t\t\n\t\t\t\t\t }\n\t\t\t\t //}\n\t\t}\n\t\t \tMatrix a(rows,matrix2.columns,temp);\n\t\t \treturn a;\n\t\t }\n\t\t Matrix operator * (double value) const{\n\t\t \tdouble temp[1000];\n\t\t\t memset(temp,0,sizeof(temp));\n\t\t\t for(int i=0;i<rows*columns;i++){\n\t\t\t \t\ttemp[i]=values[i]*value;\n\t\t\t\t }\n\t\t\t\t Matrix a(rows,columns,temp);\n\t\t\t\t return a;\n\t\t }\n};",
            1589820294.481394,
            100,
            "# 答案正确"
        ],
        [
            "2.11 (C++)",
            "万金诚",
            "#include<bits/stdc++.h>\nusing namespace std;\n#define mem0(x) memset(x,0,sizeof(x));\n#define memI(x) memset(x,0x3f,sizeof(x));\nclass Matrix{\n\tprivate:\n\t\tint rows;\n\t\tint columns;\n\t\tdouble * values;\n\t\tvoid assign(){\n\t\t\tif(values!=0)\n\t\t\tdelete [ ] values;\n\t\t}\n\tpublic:\n\t\tMatrix(int rows, int column, double values[]){\n\t\t\tthis->columns=column;\n\t\t\tthis->rows=rows;\n\t\t\tthis->values=new double[rows*columns];\n\t\t\tfor(int i=0;i<rows;i++){\n\t\t\t\tfor(int j=0;j<columns;j++){\n\t\t\t\t\tthis->values[i*columns+j]=values[i*columns+j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tMatrix(const Matrix & matrix2):rows(matrix2.rows),columns(matrix2.columns){\n\t\t\tassign();\n\t\t\tvalues=new double[rows*columns];\n\t\t\tfor(int i=0;i<rows;i++){\n\t\t\t\tfor(int j=0;j<columns;j++){\n\t\t\t\t\tvalues[i*columns+j]=matrix2.values[i*columns+j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t~Matrix(){\n\t\t\tassign();\n\t\t}\n\t\t void print(){\n\t\t \t//cout<<\"print\";\n\t\t\tif(values==NULL)\n\t\t\treturn ;\n\t\t\tfor(int i=0;i<rows;i++){\n\t\t\t\tfor(int j=0;j<columns;j++){\n\t\t\t\t\tcout<<\"    \"<<values[i*columns+j];\n\t\t\t\t}cout<<endl;\n\t\t\t}\n\t\t }\n\t\t  //Matrix reshape(int rows, int columns) const;\n\t\t Matrix transpose(){\n\t\t \tdouble a[1000];\n\t\t \tfor(int i=0;i<columns;i++){\n\t\t \t\tfor(int j=0;j<rows;j++){\n\t\t \t\t\ta[i*rows+j]=values[j*columns+i];\n\t\t\t\t }\n\t\t\t }\n\t\t \tMatrix temp(columns,rows,a);\n\t\t \treturn temp;\n\t\t }\n\t\t Matrix operator * (const Matrix & matrix2) const{\n\t\t \tdouble temp[1000];\n\t\t \tfor(int i=0;i<rows;i++){\n\t\t \t\t//for(int j=0;j<columns;j++){\n\t\t \t\t\tfor(int j=0;j<matrix2.columns;j++){\n\t\t \t\t\t\tfor(int k=0;k<columns;k++){\n\t\t \t\t\t\t    temp[i*matrix2.columns+j]+=this->values[i*columns+k]*matrix2.values[k*matrix2.columns+j];\t\n\t\t\t\t\t\t }\n\t\t \t\t\t\t\n\t\t\t\t\t }\n\t\t\t\t //}\n\t\t}\n\t\t \tMatrix a(rows,columns,temp);\n\t\t \treturn a;\n\t\t }\n\t\t Matrix operator * (double value) const{\n\t\t \tdouble temp[1000];\n\t\t\t for(int i=0;i<rows*columns;i++){\n\t\t\t \t\ttemp[i]=values[i]*value;\n\t\t\t\t }\n\t\t\t\t Matrix a(rows,columns,temp);\n\t\t\t\t return a;\n\t\t }\n\t\t  Matrix max() const{\n\t\t  \tint max=0;\n\t\t  \t//int maxrow=0;\n\t\t  \tdouble temp[1000];\n\t\t  \tmem0(temp);\n\t\t\tif(rows>1){\n\t\t\t\tfor(int i=0;i<rows;i++){\n\t\t\t\t\tfor(int j=0;j<columns;j++){\n\t\t\t\t\t\tif(this->values[i*columns+j]>temp[j]){\n\t\t\t\t\t\t\ttemp[j]=this->values[i*columns+j];\n\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tMatrix a(1,columns,temp);return a;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int i=0;i<columns;i++){\n\t\t\t\t\tif(values[i]>max)\n\t\t\t\t\tmax=values[i];\n\t\t\t\t}\n\t\t\t\ttemp[0]=max;\n\t\t\t\tMatrix a(1,1,temp);\n\t\t\t\treturn a;\n\t\t\t}\n\t\t\t\n\t\t  }\n\t\t  Matrix min() const{\n\t\t  \tint max=999;\n\t\t  \tint maxrow=0;\n\t\t  \tdouble temp[1000];\n\t\t  \tfor(int i=0;i<columns;i++)\n\t\t  \ttemp[i]=999;\n\t\t  \tif(rows>1){\n\t\t\t\tfor(int i=0;i<rows;i++){\n\t\t\t\t\tfor(int j=0;j<columns;j++){\n\t\t\t\t\t\tif(this->values[i*columns+j]<temp[j]){\n\t\t\t\t\t\t\ttemp[j]=this->values[i*columns+j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tMatrix a(1,columns,temp);return a;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int i=0;i<columns;i++){\n\t\t\t\t\tif(values[i]<max)\n\t\t\t\t\tmax=values[i];\n\t\t\t\t}\n\t\t\t\ttemp[0]=max;\n\t\t\t\tMatrix a(1,1,temp);\n\t\t\t\treturn a;\n\t\t\t}\n\t\t  \n\t\t  }\n\t\t  Matrix sum() const{\n\t\t  \tint max=0;\n\t\t  \tint maxrow=0;\n\t\t  \tdouble temp[1000];\n\t\t  \tmem0(temp);\n\t\t  \tif(rows>1){\n\t\t\t\tfor(int i=0;i<rows;i++){\n\t\t\t\t\tfor(int j=0;j<columns;j++){\n\t\t\t\t\t\ttemp[j]+=values[i*columns+j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tMatrix a(1,columns,temp);return a;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int i=0;i<columns;i++){\n\t\t\t\t\ttemp[0]+=values[i];\n\t\t\t\t}\n\t\t\t\tMatrix a(1,1,temp);\n\t\t\t\treturn a;\n\t\t\t}\n\t\t  }\n};\n",
            1589821727.048867,
            100,
            "# 答案正确"
        ],
        [
            "2.12 (C++)",
            "万金诚",
            "#include<bits/stdc++.h>\nusing namespace std;\n#define mem0(x) memset(x,0,sizeof(x));\n#define memI(x) memset(x,0x3f3f3f,sizeof(x));\n#define f(m,n) for(int i=m;i<n;i++)\n#define df(m,n) for(int j=m;j<n;j++)\nclass Matrix{\n\tprivate:\n\t\tint rows;\n\t\tint columns;\n\t\tdouble * values;\n\t\tvoid assign(){\n\t\t\tif(values!=0)\n\t\t\tdelete [ ] values;\n\t\t}\n\tpublic:\n\t\tMatrix(int rows, int column, double values[]){\n\t\t\tthis->columns=column;\n\t\t\tthis->rows=rows;\n\t\t\tthis->values=new double[rows*columns];\n\t\t\tfor(int i=0;i<rows;i++){\n\t\t\t\tfor(int j=0;j<columns;j++){\n\t\t\t\t\tthis->values[i*columns+j]=values[i*columns+j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tMatrix(const Matrix & matrix2):rows(matrix2.rows),columns(matrix2.columns){\n\t\t\tassign();\n\t\t\tvalues=new double[rows*columns];\n\t\t\tfor(int i=0;i<rows;i++){\n\t\t\t\tfor(int j=0;j<columns;j++){\n\t\t\t\t\tvalues[i*columns+j]=matrix2.values[i*columns+j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t~Matrix(){\n\t\t\tassign();\n\t\t}\n\t\t void print(){\n\t\t \t//cout<<\"print\";\n\t\t\tif(values==NULL)\n\t\t\treturn ;\n\t\t\tfor(int i=0;i<rows;i++){\n\t\t\t\tfor(int j=0;j<columns;j++){\n\t\t\t\t\tcout<<\"    \"<<values[i*columns+j];\n\t\t\t\t}cout<<endl;\n\t\t\t}\n\t\t }\n\t\t  //Matrix reshape(int rows, int columns) const;\n\t\t Matrix transpose(){\n\t\t \tdouble a[1000];\n\t\t \tfor(int i=0;i<columns;i++){\n\t\t \t\tfor(int j=0;j<rows;j++){\n\t\t \t\t\ta[i*rows+j]=values[j*columns+i];\n\t\t\t\t }\n\t\t\t }\n\t\t \tMatrix temp(columns,rows,a);\n\t\t \treturn temp;\n\t\t }\n\t\t Matrix operator * (const Matrix & matrix2) const{\n\t\t \tdouble temp[1000];\n\t\t \tfor(int i=0;i<rows;i++){\n\t\t \t\t//for(int j=0;j<columns;j++){\n\t\t \t\t\tfor(int j=0;j<matrix2.columns;j++){\n\t\t \t\t\t\tfor(int k=0;k<columns;k++){\n\t\t \t\t\t\t    temp[i*matrix2.columns+j]+=this->values[i*columns+k]*matrix2.values[k*matrix2.columns+j];\t\n\t\t\t\t\t\t }\n\t\t \t\t\t\t\n\t\t\t\t\t }\n\t\t\t\t //}\n\t\t}\n\t\t \tMatrix a(rows,columns,temp);\n\t\t \treturn a;\n\t\t }\n\t\t Matrix operator * (double value) const{\n\t\t \tdouble temp[1000];\n\t\t\t for(int i=0;i<rows*columns;i++){\n\t\t\t \t\ttemp[i]=values[i]*value;\n\t\t\t\t }\n\t\t\t\t Matrix a(rows,columns,temp);\n\t\t\t\t return a;\n\t\t }\n\t\t  Matrix max() const{\n\t\t  \tint max=0;\n\t\t  \t//int maxrow=0;\n\t\t  \tdouble temp[1000];\n\t\t  \tmem0(temp);\n\t\t\tif(rows>1){\n\t\t\t\tfor(int i=0;i<rows;i++){\n\t\t\t\t\tfor(int j=0;j<columns;j++){\n\t\t\t\t\t\tif(this->values[i*columns+j]>temp[j]){\n\t\t\t\t\t\t\ttemp[j]=this->values[i*columns+j];\n\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tMatrix a(1,columns,temp);return a;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int i=0;i<columns;i++){\n\t\t\t\t\tif(values[i]>max)\n\t\t\t\t\tmax=values[i];\n\t\t\t\t}\n\t\t\t\ttemp[0]=max;\n\t\t\t\tMatrix a(1,1,temp);\n\t\t\t\treturn a;\n\t\t\t}\n\t\t\t\n\t\t  }\n\t\t  Matrix min() const{\n\t\t  \tint max=999;\n\t\t  \tint maxrow=0;\n\t\t  \tdouble temp[1000];\n\t\t  \tfor(int i=0;i<columns;i++)\n\t\t  \ttemp[i]=999;\n\t\t  \tif(rows>1){\n\t\t\t\tfor(int i=0;i<rows;i++){\n\t\t\t\t\tfor(int j=0;j<columns;j++){\n\t\t\t\t\t\tif(this->values[i*columns+j]<temp[j]){\n\t\t\t\t\t\t\ttemp[j]=this->values[i*columns+j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tMatrix a(1,columns,temp);return a;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int i=0;i<columns;i++){\n\t\t\t\t\tif(values[i]<max)\n\t\t\t\t\tmax=values[i];\n\t\t\t\t}\n\t\t\t\ttemp[0]=max;\n\t\t\t\tMatrix a(1,1,temp);\n\t\t\t\treturn a;\n\t\t\t}\n\t\t  \n\t\t  }\n\t\t  Matrix sum() const{\n\t\t  \tint max=0;\n\t\t  \tint maxrow=0;\n\t\t  \tdouble temp[1000];\n\t\t  \tmem0(temp);\n\t\t  \tif(rows>1){\n\t\t\t\tfor(int i=0;i<rows;i++){\n\t\t\t\t\tfor(int j=0;j<columns;j++){\n\t\t\t\t\t\ttemp[j]+=values[i*columns+j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tMatrix a(1,columns,temp);return a;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int i=0;i<columns;i++){\n\t\t\t\t\ttemp[0]+=values[i];\n\t\t\t\t}\n\t\t\t\tMatrix a(1,1,temp);\n\t\t\t\treturn a;\n\t\t\t}\n\t\t  }\n\t\t  Matrix pow(double exponent){\n\t\t  \tdouble temp[1000];\n\t\t  \tmem0(temp);\n\t\t  \tf(0,rows){\n\t\t  \t\tdf(0,columns){\n\t\t  \t\t\ttemp[i*columns+j]=::pow(values[i*columns+j],exponent);\n\t\t\t\t  }\n\t\t\t  }\n\t\t\t  Matrix a(rows,columns,temp);\n\t\t\t  return a;\n\t\t  }\n\t\t  Matrix exp() {\n\t\t  \tdouble temp[1000];\n\t\t  \tmem0(temp);\n\t\t  \tf(0,rows){\n\t\t  \t\tdf(0,columns){\n\t\t  \t\t\ttemp[i*columns+j]=::exp(values[i*columns+j]);\n\t\t\t\t  }\n\t\t\t  }\n\t\t\t  Matrix a(rows,columns,temp);\n\t\t\t  return a;\n\t\t  }\n\t\t  Matrix log(){\n\t\t  \tdouble temp[1000];\n\t\t  \tmem0(temp);\n\t\t  \tf(0,rows){\n\t\t  \t\tdf(0,columns){\n\t\t  \t\t\ttemp[i*columns+j]=::log(values[i*columns+j]);\n\t\t\t\t  }\n\t\t\t  }\n\t\t\t  Matrix a(rows,columns,temp);\n\t\t\t  return a;\n\t\t  }\n\t\t  Matrix abs(){\n\t\t  \tdouble temp[1000];\n\t\t  \tmem0(temp);\n\t\t  \tf(0,rows){\n\t\t  \t\tdf(0,columns){\n\t\t  \t\t\ttemp[i*columns+j]=::abs(values[i*columns+j]);\n\t\t\t\t  }\n\t\t\t  }\n\t\t\t  Matrix a(rows,columns,temp);\n\t\t\t  return a;\n\t\t  }\n};",
            1589822760.0325348,
            100,
            "# 答案正确"
        ],
        [
            "2.9 (C++)",
            "万金诚",
            "#include<bits/stdc++.h>\nusing namespace std;\nclass  Matrix{\n\tprivate:\n\t\tint rows;\n\t\tint columns;\n\t\tdouble * values;\n\t\tvoid assign(){\n\t\t\tif(values!=NULL){\n\t\t\t\tdelete[]values;\n\t\t\t\tvalues=NULL;\n\t\t\t}\n\t\t}\n\tpublic:\n\t\t Matrix(int r, int c, double value[]):rows(r),columns(c){\n\t\t \t\n\t\t \tvalues=new double[rows*this->columns];\n\t\t \tfor(int i=0;i<this->rows*this->columns;i++){\n\t\t \t\tvalues[i]=value[i];\n\t\t\t }\n\t\t }\n\t\t Matrix(const Matrix & matrix2){\n\t\t \tassign();\n\t\t \trows=matrix2.rows;\n\t\t \tcolumns=matrix2.columns;\n\t\t \tvalues=new double[rows*columns];\n\t\t \tfor(int i=0;i<rows*columns;i++){\n\t\t \t\tvalues[i]=matrix2.values[i];\n\t\t\t }\n\t\t }\n\t\t ~Matrix(){\n\t\t \tassign();\n\t\t }\n\t\t void print(){\n\t\t \tfor(int i=0;i<rows;i++){\n\t\t \t\tfor(int j=0;j<columns;j++){\n\t\t \t\t\tcout<<\"    \"<<values[i*columns+j];\n\t\t\t\t }cout<<endl;\n\t\t\t }\n\t\t }\n\t\t  Matrix operator + (const Matrix & matrix2) const{\n\t\t  \tdouble temp[1000];\n\t\t  \tmemset(temp,0,sizeof(temp));\n\t\t  \tfor(int i=0;i<rows*columns;i++){\n\t\t  \t\ttemp[i]=values[i]+matrix2.values[i];\n\t\t\t  }\n\t\t\t  Matrix a(rows,columns,temp);\n\t\t\t  return a;\n\t\t  }\n\t\t  Matrix operator + (double value) const{\n\t\t  \tdouble temp[1000];\n\t\t  \tfor(int i=0;i<rows*columns;i++){\n\t\t  \t\ttemp[i]=values[i]+value;\n\t\t\t  }\n\t\t\t  Matrix a(rows,columns,temp);\n\t\t\t  return a;\n\t\t  }\n\t\t  Matrix operator - (const Matrix & matrix2) const{\n\t\t  \tdouble temp[1000];\n\t\t  \tmemset(temp,0,sizeof(temp));\n\t\t  \tfor(int i=0;i<rows*columns;i++){\n\t\t  \t\ttemp[i]=values[i]-matrix2.values[i];\n\t\t\t  }\n\t\t\t  Matrix a(rows,columns,temp);\n\t\t\t  return a;\n\t\t  }\n\t\t  Matrix operator - (double value)const{\n\t\t  \tdouble temp[1000];\n\t\t  \tfor(int i=0;i<rows*columns;i++){\n\t\t  \t\ttemp[i]=values[i]-value;\n\t\t\t  }\n\t\t\t  Matrix a(rows,columns,temp);\n\t\t\t  return a;\n\t\t  }\n};",
            1590029165.9913614,
            100,
            "# 答案正确"
        ],
        [
            "6.1 (C++)",
            "万金诚",
            "#include<bits/stdc++.h>\nusing namespace std;\n//ios::sync_with_stdio(false);\ntemplate <typename T>\nclass Matrix{\n\tprivate:\n\t\tint rows;\n\t\tint col;\n\t\tT*val;\n\t\tvoid assign(){\n\t\t\tif(val!=0)\n\t\t\tdelete[]val;\n\t\t\tval=0;\n\t\t}\n\tpublic:\n\t\tMatrix(int r,int c):rows(r),col(c){\n\t\t\tval=new T[rows*col];\n\t\t\tmemset(val,0,sizeof(T)*rows*col);\n\t\t}\n\t\tMatrix(int r,int c,const T* v):rows(r),col(c){\n\t\t\tval=new T[rows*col];\n\t\t\tfor(int i=0;i<rows*col;i++){\n\t\t\t\tval[i]=v[i];\n\t\t\t}\n\t\t}\n\t\tvoid print(){\n\t\t\tfor(int i=0;i<rows;i++){\n\t\t\t\tfor(int j=0;j<col;j++){\n\t\t\t\t\tcout<<\"    \"<<val[i*col+j];\n\t\t\t\t}cout<<endl;\n\t\t\t}\n\t\t}\n\t\tMatrix& operator=(Matrix& a){\n\t\t\tassign();\n\t\t\trows=a.rows;\n\t\t\tcol=a.col;\n\t\t\tval=new T[rows*col];\n\t\t\tfor(int i=0;i<rows*col;i++)\n\t\t\tval[i]=a.val[i];\n\t\t\treturn *this;\n\t\t}\n\t\tMatrix(Matrix & a):rows(a.rows),col(a.col){\n\t\t\tval=new T[rows*col];\n\t\t\tfor(int i=0;i<rows*col;i++)\n\t\t\tval[i]=a.val[i];\n\t\t}\n\t\tT& get(int i,int j){\n\t\t\treturn val[(i-1)*col+j-1];\n\t\t}\n\t~Matrix(){\n\t\tassign();\n}\n}; ",
            1590510230.1046655,
            100,
            "# 答案正确"
        ],
        [
            "6.3 (C++)",
            "万金诚",
            "\n#include<bits/stdc++.h>\nusing namespace std;\n//ios::sync_with_stdio(false);\ntemplate <typename T>\nclass Matrix{\n\tprivate:\n\t\tint rows;\n\t\tint col;\n\t\tvector <T> val;\n\t\tvoid assign(){\n\t\t\tval.clear();\n\t\t}\n\tpublic:\n\t\tMatrix(int r,int c):rows(r),col(c){\n\t\t\tfor(int i=0;i<rows*col;i++)\n\t\t\tval.push_back(0);\n\t\t}\n\t\tMatrix(int r,int c,vector <T> v):rows(r),col(c){\n\t\t\tfor(int i=0;i<rows*col;i++)\n\t\t\tval.push_back(v[i]);\n\t\t}\n\t\tvoid print(){\n\t\t\tfor(int i=0;i<rows;i++){\n\t\t\t\tfor(int j=0;j<col;j++){\n\t\t\t\t\tcout<<\"    \"<<val[i*col+j];\n\t\t\t\t}cout<<endl;\n\t\t\t}\n\t\t}\n\t\t/*Matrix& operator=(Matrix& a){\n\t\t\trows=a.rows;\n\t\t\tcol=a.col;\n\t\t\tfor(int i=0;i<rows*col;i++)\n\t\t\tval.push_back(a.val[i]);\n\t\t\treturn *this;\n\t\t}\n\t\tMatrix(Matrix & a):rows(a.rows),col(a.col){\n\t\t\tfor(int i=0;i<rows*col;i++)\n\t\t\tval.push_back(a.val[i]);\n\t\t}*/\n\t\tT& get(int i,int j){\n\t\t\treturn val[(i-1)*col+j-1];\n\t\t}\n\t\tMatrix getColumn(int a){\n\t\t\tvector<T> temp;\n\t\t\tfor(int i=0;i<rows;i++){\n\t\t\t\ttemp.push_back(val[i*col+(a-1)]);\n\t\t\t}\n\t\t\tMatrix b(rows,1,temp);\n\t\t\treturn b;\n\t\t}\n\t\tMatrix getRow(int a){\n\t\t\tvector<T> temp;\n\t\t\tfor(int i=0;i<col;i++){\n\t\t\t\ttemp.push_back(val[i+(a-1)*rows]);\n\t\t\t}\n\t\t\tMatrix b(1,col,temp);\n\t\t\treturn b;\n\t\t}\n\t\tMatrix concatenateRows(Matrix a){\n\t\t\tvector <T> temp;\n\t\t\tfor(int i=0;i<rows*col;i++)\n\t\t\ttemp.push_back(val[i]);\n\t\t\tfor(int i=0;i<a.col*a.rows;i++){\n\t\t\t\ttemp.push_back(a.val[i]);\n\t\t\t}\n\t\t\tMatrix b(rows+a.rows,col,temp);\n\t\t\treturn b;\n\t\t}\n\t\tMatrix concatenateColumns(Matrix a){\n\t\t\tvector <T> temp;\n\t\t\tfor(int i=0;i<rows;i++)\n\t\t\t{\n\t\t\t\tfor(int j=0;j<col;j++){\n\t\t\t\t\ttemp.push_back(val[i*col+j]);\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<a.col;j++)\n\t\t\t\ttemp.push_back(a.val[i*a.col+j]);\n\t\t\t}\n\t\t\tMatrix b(rows,col+a.col,temp);\n\t\t\treturn b;\n\t\t}\n\t\tMatrix reshape(int r,int c){\n\t\t\tvector <T> temp(rows*col);\n\t\t\tvector<T> t1(rows*col);\n\t\t\tint k=0;\n\t\t\tfor(int i=0;i<col;i++){\n\t\t\t\tfor(int j=0;j<rows;j++){\n\t\t\t\t\tt1[k++]=val[i+j*col];\n\t\t\t\t}\n\t\t\t}\n\t\t\tk=0;\n\t\t\tfor(int i=0;i<c;i++){\n\t\t\t\tfor(int j=0;j<r;j++){\n\t\t\t\t\ttemp[i+j*c]=t1[k++];\n\t\t\t\t}\n\t\t\t}\n\t\t\tMatrix b(r,c,temp);\n\t\t\treturn b;\n\t\t}\n\t\tMatrix transpose(){\n\t\t\t//vector <T> temp(rows*col);\n\t\t\tvector<T> t1(rows*col);\n\t\t\tint k=0;\n\t\t\tfor(int i=0;i<col;i++){\n\t\t\t\tfor(int j=0;j<rows;j++){\n\t\t\t\t\tt1[k++]=val[i+j*col];\n\t\t\t\t}\n\t\t\t}\n\t\t\tMatrix b(rows,col,t1);\n\t\t\treturn b;\n\t\t}\n\t\tMatrix operator +(Matrix a){\n\t\t\tvector <T> temp;\n\t\t\tfor(int i=0;i<rows*col;i++)\n\t\t\ttemp.push_back(val[i]+a.val[i]);\n\t\t\tMatrix b(rows,col,temp);\n\t\t\treturn b;\n\t\t}\n\t\tMatrix operator +(T a){\n\t\t\tvector <T> temp;\n\t\t\tfor(int i=0;i<rows*col;i++)\n\t\t\ttemp.push_back(val[i]+a);\n\t\t\tMatrix b(rows,col,temp);\n\t\t\treturn b;\n\t\t}\n\t\tMatrix operator -(Matrix a){\n\t\t\tvector <T> temp;\n\t\t\tfor(int i=0;i<rows*col;i++)\n\t\t\ttemp.push_back(val[i]-a.val[i]);\n\t\t\tMatrix b(rows,col,temp);\n\t\t\treturn b;\n\t\t}\n\t\tMatrix operator -(T a){\n\t\t\tvector <T> temp;\n\t\t\tfor(int i=0;i<rows*col;i++)\n\t\t\ttemp.push_back(val[i]-a);\n\t\t\tMatrix b(rows,col,temp);\n\t\t\treturn b;\n\t\t}\n\t\tMatrix operator *(Matrix a){\n\t\t\tvector <T> temp(rows*a.col,0);\n\t\t\tfor(int i=0;i<rows;i++){\n\t\t\t\tfor(int j=0;j<a.col;j++){\n\t\t\t\t\tfor(int k=0;k<col;k++){\n\t\t\t\t\t\ttemp[i*a.col+j]+=val[i*col+k]*a.val[k*a.col+j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//temp.push_back(val[i]+a.val[i]);\n\t\t\tMatrix b(rows,col,temp);\n\t\t\treturn b;\n\t\t}\n\t\tMatrix operator *(T a){\n\t\t\tvector <T> temp(rows*col);\n\t\t\tfor(int i=0;i<rows*col;i++){\n\t\t\t\ttemp[i]=val[i]*a;\n\t\t\t}\n\t\t\t//temp.push_back(val[i]+a.val[i]);\n\t\t\tMatrix b(rows,col,temp);\n\t\t\treturn b;\n\t\t}\n\t\t\tMatrix max(){\n\t\t\tvector <T> temp;\n\t\t\tT max=val[0];\n\t\t\tint maxrow=0;\n\t\t\t\tfor(int i=0;i<rows*col;i++){\n\t\t\t\t\t\n\t\t\t\t\tif(max<val[i]){\n\t\t\t\t\t\tmax=val[i];\n\t\t\t\t\t\tmaxrow=i/col;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(rows==1){\n\t\t\t\ttemp.push_back(max);\n\t\t\t\treturn Matrix(1,1,temp);\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\telse{\n\t\t\t\tfor(int i=0;i<col;i++){\n\t\t\t\t\ttemp.push_back(val[i+maxrow*col]);\n\t\t\t\t\t//cout<<\"  \"<<\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn Matrix(1,col,temp);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\n\t\tMatrix min(){\n\t\t\tvector <T> temp;\n\t\t\tT max=val[0];\n\t\t\tint maxrow=0;\n\t\t\t\tfor(int i=0;i<rows*col;i++){\n\t\t\t\t\t\n\t\t\t\t\tif(max>val[i]){\n\t\t\t\t\t\tmax=val[i];\n\t\t\t\t\t\tmaxrow=i/col;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(rows==1){\n\t\t\t\ttemp.push_back(max);\n\t\t\t\treturn Matrix(1,1,temp);\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\telse{\n\t\t\t\tfor(int i=0;i<col;i++)\n\t\t\t\ttemp.push_back(val[i+maxrow*col]);\n\t\t\t\treturn Matrix(1,col,temp);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\tMatrix sum(){\n\t\t\tvector <T> temp;\n\t\t\tint sum=0;\n\t\t\tif(rows==1){\n\t\t\t\tfor(int i=0;i<col;i++)\n\t\t\t\tsum+=val[i];\n\t\t\t\t\n\t\t\t\ttemp.push_back(sum);\n\t\t\t\treturn Matrix(1,1,temp);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int i=0;i<rows;i++){\n\t\t\t\t\tsum=0;\n\t\t\t\t\tfor(int j=0;j<col;j++){\n\t\t\t\t\t\tsum+=val[i*col+j];\n\t\t\t\t\t}\n\t\t\t\t\ttemp.push_back(sum);\n\t\t\t\t}\n\t\t\t\t\n\t\t\treturn Matrix(1,col,temp);\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n}; \n\n\n",
            1590546742.0413787,
            100,
            "# 答案正确"
        ],
        [
            "6.2 (C++)",
            "万金诚",
            "#include<iostream>\n#include<vector>\n#include<cstring>\nusing namespace std;\ntemplate <typename T>\nclass  Matrix{\n\tprivate:\n\tint rows;\n\tint columns;\n\tT * values;\n\tpublic:\n\t\tMatrix(int rows, int column){\n\t\t\tthis->rows=rows;\n\t\t\tthis->columns=column;\n\t\t\tthis->values=new T[rows*columns];\n\t\t\tmemset(this->values,0,sizeof(T)*rows*columns);\n\t\t\t//for(int i=0;i<rows*columns;i++) values[i]=0;\n\t\t}\n\t\t~Matrix(){\n\t\t\tdelete [] values;\n\t\t}\n\t\tvoid print(){\n\t\t\tfor(int i=0;i<rows;i++){\n\t\t\t\tfor(int j=0;j<columns;j++){\ncout<<\"    \"<<values[i*columns+j];}cout<<endl;\n\t\t\t}\n\t\t}\n};",
            1590633415.003987,
            100,
            "# 答案正确"
        ],
        [
            "7.1 (C++)",
            "万金诚",
            "#include<iostream>\n#include<cmath>\nusing namespace std;\nclass  Triangle : public GeometricObject{\n\tpublic:\n\tdouble side1,side2,side3;\n\tpublic :\n\t\tTriangle(){\n\t\t\tside1=side2=side3=1.0;\n\t\t}\n\t\tTriangle(double s1,double s2,double s3){\n\t\t\tside1=s1;\n\t\t\tside2=s2;\n\t\t\tside3=s3;\n\t\t}\n\t\tdouble getSide1() {\n\t\t\treturn side1;\n\t\t}\n\t\tdouble getSide2() {\n\t\t\treturn side2;\n\t\t}\n\t\tdouble getSide3() {\n\t\t\treturn side3;\n\t\t}\n\t\tdouble getArea(){\n\t\t\tdouble s=(side1+side2+side3)/2;\n\t\t\treturn sqrt(s*(s-side1)*(s-side2)*(s-side3));\n\t\t}\n\t\tdouble getPerimeter(){\n\t\t\treturn side1+side2+side3;\n\t\t}\n};",
            1591202482.4460695,
            100,
            "# 答案正确"
        ],
        [
            "7.3 (C++)",
            "万金诚",
            "#include<iostream>\n#include<vector>\n#include<string>\nusing namespace std;\ntemplate <typename A,typename B>\nvector<B> map2(vector<A> a,vector<A> b,B (*fun)(const int&,const int &)){\n\tvector<B> temp;\n\tfor(int i=0;i<a.size();i++){\n\t\ttemp.push_back(fun(a[i],b[i]));\n\t}\n\treturn temp;\n}\ntemplate <typename A,typename B>\nvector<B> map2(vector<A> a,A b,B (*fun)(const int&,const int &)){\n\tvector<B> temp;\n\tfor(int i=0;i<a.size();i++){\n\t\ttemp.push_back(fun(a[i],b));\n\t}\n\treturn temp;\n}",
            1591203264.3714333,
            100,
            "# 答案正确"
        ],
        [
            "7.2 (C++)",
            "万金诚",
            "#include<bits/stdc++.h>\n\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n vector<string> split(string A){\n \tstring t;\n \tvector<string>temp;\n \tfor(int i=0;i<A.size();i++){\n \t\tif(A[i]==' '){\n \t\t\tif(t.size()){\n \t\t\t\t\n \t\t\t\ttemp.push_back(t);\n \t\t\t\t//cout<<t<<endl;\n \t\t\t\tt.clear();\n \t\t\t//\tcout<<temp.size();\n\t\t\t }\n\t\t\t else\n\t\t\t continue;\n\t\t }\n\t\t else{\n\t\t \tt+=A[i];\n\t\t \t\n\t\t }\n\t} \n\t\n\treturn temp;\n }",
            1591238657.3871117,
            100,
            "# 答案正确"
        ],
        [
            "8.1 (C++)",
            "万金诚",
            "#include<bits/stdc++.h>\nusing namespace std;\nclass Full: public Matrix{\n\tprivate :\n\t\tint rows,col;\n\t\tdouble *val;\n\t\tpublic:\n\t\t\tFull(int rows, int column){\n\t\t\t\tthis->rows=rows;\n\t\t\t\tthis->col=column;\n\t\t\t\tval=new double[rows*col];\n\t\t\t\tmemset(val,0,sizeof(double)*rows*col);\n\t\t\t}\n\t\t\tFull(int rows, int column, double values[]){\n\t\t\t\tthis->rows=rows;\n\t\t\t\tthis->col=column;\n\t\t\t\tval=new double[rows*col];\n\t\t\t\tfor(int i=0;i<rows*col;i++)\n\t\t\t\tval[i]=values[i];\n\t\t\t}\n\t\t\tFull(const Matrix & matrix2){\n\t\t\t\trows=matrix2.size(1);\n\t\t\t\tcol=matrix2.size(2);\n\t\t\t\tval=new double[rows*col];\n\t\t\t\tfor(int i=0;i<rows;i++){\n\t\t\t\t\tfor(int j=0;j<col;j++)\n\t\t\t\t\tval[i*col+j]=matrix2.get(i+1,j+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint size(int dimension) const {\n\t\t\t\tif(dimension==1)\n\t\t\t\treturn rows;\n\t\t\t\telse \n\t\t\t\treturn col;\n\t\t\t}\n\t\t\tvoid set(int row, int column, double value){\n\t\t\t\tval[(row-1)*col+column]=value;\n\t\t\t}\n\t\t\tdouble get(int row, int column) const{\n\t\t\t\treturn val[(row-1)*col+column-1];\n\t\t\t}\n\t\t\tvoid print() const{\n\t\t\t\tfor(int i=0;i<rows;i++){\n\t\t\t\t\tfor(int j=0;j<col;j++){\n\t\t\t\t\t\tcout<<\"    \"<<val[i*col+j];\n\t\t\t\t\t}cout<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\tMatrix & operator = (const Matrix & matrix2){\n\t\t\t\trows=matrix2.size(1),col=matrix2.size(2);\n\t\t\t\t//double temp[rows*col];\n\t\t\t\tif(val!=0){\n\t\t\t\t\tdelete[]val;\n\t\t\t\t}\n\t\t\t\tval=new double[rows*col];\n\t\t\t\tfor(int i=0;i<rows;i++){\n\t\t\t\t\tfor(int j=0;j<col;j++){\n\t\t\t\t\t\tval[i*col+j]=matrix2.get(i+1,j+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t\t~Full(){\n\t\t\t\tdelete[]val;\n\t\t\t}\n};",
            1591717886.2700436,
            100,
            "# 答案正确"
        ],
        [
            "8.3 (C++)",
            "万金诚",
            "#include<bits/stdc++.h>\nusing namespace std;\nvoid sort(Entry *val,int cnt){\n\tfor(int i=0;i<cnt;i++){\n\t\tfor(int j=0;j<cnt-1;j++){\n\t\t\tif(val[j].row>val[j+1].row || (val[j].row==val[j+1].row && val[j].column>val[j+1].column))\n\t\t\t{\n\t\t\t\tEntry temp=val[j];\n\t\t\t\tval[j]=val[j+1];\n\t\t\t\tval[j+1]=temp;\n\t\t\t}\n\t\t}\n\t}\n}\nclass Sparse :public Matrix{\n\tpublic:\n\t\tint cnt;\n\t\tEntry val[100];\n\tSparse(int rows, int column){\n\t\tcnt=0;\n\t}\n\tint size(int dimension) const{\n\t\treturn cnt;\n\t}\n\tvoid set(int row, int column,\tdouble value){\n\t\tint flag=0;\n\t\tint i;\n\t\tfor( i=0;i<cnt;i++){\n\t\t\tif(val[i].row==row && val[i].column==column){\n\t\t\t\tflag=1;break;\n\t\t\t}\t\n\t\t}\n\t\tif(flag){\n\t\t\tval[i].value=value;\n\t\t}\n\t\telse {\n\t\t\tcnt++;\n\t\t\tval[cnt-1].row=row,val[cnt-1].column=column;\n\t\t\tval[cnt-1].value=value;\n\t\t}\n\t}\n\tdouble get(int row, int column) const{\n\t\tfor(int i=0;i<cnt;i++){\n\t\t\tif(val[i].row==row && val[i].column==column){\n\t\t\t\treturn val[i].value;\n\t\t\t}\n\t\t}\n\t} \n\tvoid print(){\n\t\tsort(val,cnt);\n\t\tfor(int i=0;i<cnt;i++){\n\t\t\tcout<<\"(\"<<val[i].row<<\",\"<<val[i].column<<\",\"<<val[i].value<<\")\"<<endl; \n\t\t}\n\t}\n\tSparse operator + (Sparse & sparse2){\n\t\tSparse temp=*this;\n\t\tfor(int i=0;i<sparse2.cnt;i++){\n\t\t\tint flag=0;\n\t\t\tfor(int j=0;j<cnt;j++){\n\t\t\t\tif(temp.val[j].row==sparse2.val[i].row && temp.val[j].column==sparse2.val[i].column){\n\t\t\t\t\ttemp.val[j].value+=sparse2.val[i].value;\n\t\t\t\t\tif(temp.val[j].value==0){\n\t\t\t\t\t\ttemp.cnt--;\n\t\t\t\t\t\ttemp.val[j]=temp.val[temp.cnt];\n\t\t\t\t\t}\n\t\t\t\t\tflag=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag==0){\n\t\t\t\ttemp.val[temp.cnt++]=sparse2.val[i];\n\t\t\t}\n\t\t}\n\t\treturn temp;\n\t}\n};",
            1591721404.4627204,
            100,
            "# 答案正确"
        ],
        [
            "8.4 (C++)",
            "万金诚",
            "#include<bits/stdc++.h>\nusing namespace std;\nvoid sort(Entry *val,int cnt){\n\tfor(int i=0;i<cnt;i++){\n\t\tfor(int j=0;j<cnt-1;j++){\n\t\t\tif(val[j].row>val[j+1].row || (val[j].row==val[j+1].row && val[j].column>val[j+1].column))\n\t\t\t{\n\t\t\t\tEntry temp=val[j];\n\t\t\t\tval[j]=val[j+1];\n\t\t\t\tval[j+1]=temp;\n\t\t\t}\n\t\t}\n\t}\n}\nclass Sparse :public Matrix{\n\tpublic:\n\t\tint cnt;\n\t\tEntry val[100];\n\tSparse(int rows, int column){\n\t\tcnt=0;\n\t}\n\tint size(int dimension) const{\n\t\treturn cnt;\n\t}\n\tvoid set(int row, int column,\tdouble value){\n\t\tint flag=0;\n\t\tint i;\n\t\tfor( i=0;i<cnt;i++){\n\t\t\tif(val[i].row==row && val[i].column==column){\n\t\t\t\tflag=1;break;\n\t\t\t}\t\n\t\t}\n\t\tif(flag){\n\t\t\tval[i].value=value;\n\t\t}\n\t\telse {\n\t\t\tcnt++;\n\t\t\tval[cnt-1].row=row,val[cnt-1].column=column;\n\t\t\tval[cnt-1].value=value;\n\t\t}\n\t\tsort(val,cnt);\n\t}\n\tdouble get(int row, int column) const{\n\t\tfor(int i=0;i<cnt;i++){\n\t\t\tif(val[i].row==row && val[i].column==column){\n\t\t\t\treturn val[i].value;\n\t\t\t}\n\t\t}\n\t} \n\tvoid print(){\n\t\tsort(val,cnt);\n\t\tfor(int i=0;i<cnt;i++){\n\t\t\tcout<<\"(\"<<val[i].row<<\",\"<<val[i].column<<\",\"<<val[i].value<<\")\"<<endl; \n\t\t}\n\t}\n\tSparse operator * (Sparse & sparse2){\n\t\tSparse temp(0,0);\n\t\tmemset(temp.val,0,sizeof(double)*100);\n\t\tfor(int i=0;i<sparse2.cnt;i++){\n\t\t\tfor(int j=0;j<cnt;j++){\n\t\t\t\tif( val[j].column==sparse2.val[i].row){\n\t\t\t\t\tint flag=1;\n\t\t\t\t\tfor(int k=0;k<temp.cnt;k++){\n\t\t\t\t\t\tif(temp.val[k].row==val[j].row && temp.val[k].column==sparse2.val[i].column){\n\t\t\t\t\t\t\ttemp.val[k].value+=val[j].value*sparse2.val[i].value;\n\t\t\t\t\t\t\tflag=0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(flag){\n\t\t\t\t\t\ttemp.val[temp.cnt].row=val[j].row;\n\t\t\t\t\t\ttemp.val[temp.cnt].column=sparse2.val[i].column;\n\t\t\t\t\t\ttemp.val[temp.cnt].value+=val[j].value*sparse2.val[i].value;\n\t\t\t\t\t\ttemp.cnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn temp;\n\t}\n};",
            1591724990.1447012,
            100,
            "# 答案正确"
        ],
        [
            "8.5 (C++)",
            "万金诚",
            "#include<bits/stdc++.h>\nusing namespace std;\nclass Point3D : public Point2D{\n\tprivate :\n\t\tdouble z;\n\t\tpublic:\n\t\t\tPoint3D(double x1,double y1,double z1):z(z1){\n\t\t\t\tsetX(x1);\n\t\t\t\tsetY(y1);\n\t\t\t}\n\t\t double getZ(){\n\t\t\treturn z;\n\t\t}\n\t\tvirtual double distance(Point2D & point2){\n\t\t\tPoint3D *p=static_cast<Point3D *>(&point2);\n\t\t\tdouble dx=abs(getX()-p->getX());\n\t\t\tdouble dy=abs(getY()-p->getY());\n\t\t\tdouble dz=abs(getZ()-p->getZ());\n\t\t\treturn sqrt(dx*dx+dy*dy+dz*dz);\n\t\t}\n};",
            1591844431.7338061,
            100,
            "# 答案正确"
        ],
        [
            "8.6 (C++)",
            "万金诚",
            "#include<bits/stdc++.h>\nusing namespace std;\nclass MyTensor : public Tensor<double>{\n\tprivate :\n\t\tdouble n;\n\t\tpublic:\n\t\tMyTensor(vector<int> s):Tensor(s){\n\t\t}\n\t\tvirtual double & get(const vector<int> & indexes){\n\t\t\treturn n;\n\t\t}\n}; ",
            1592448821.4027152,
            100,
            "# 答案正确"
        ],
        [
            "9.1 (C++)",
            "万金诚",
            "#include<bits/stdc++.h>\nusing namespace std;\nclass Circle{\n\tpublic:\n\tdouble radii;\n\tpublic :\n\tCircle(double r):radii(r){\n\t} \n\t/*operator double(){\n\t\treturn radii;\n\t}*/\n};\nbool operator <(Circle a,Circle b){\n\treturn a.radii<b.radii;\n}\nbool operator <=(Circle a,Circle b){\n\treturn a.radii<=b.radii;\n}\nbool operator ==(Circle a,Circle b){\n\treturn a.radii==b.radii;\n}\nbool operator !=(Circle a,Circle b){\n\treturn a.radii!=b.radii;\n}\nbool operator >(Circle a,Circle b){\n\treturn a.radii>b.radii;\n}\nbool operator >=(Circle a,Circle b){\n\treturn a.radii>=b.radii;\n}\n",
            1593054436.1941192,
            100,
            "# 答案正确"
        ],
        [
            "9.2 (C++)",
            "万金诚",
            "#include<bits/stdc++.h>\n#include<vector>\nusing namespace std;\nclass I{\n\tvector<int> a;\n\tpublic:\n\t\tI(int s1, int s2=-1,int s3=-1,int s4=-1){\n\t\t\ta.push_back(s1);\n\t\t\tif(s2!=-1)a.push_back(s2);\n\t\t\tif(s3!=-1)a.push_back(s3);\n\t\t\tif(s4!=-1)a.push_back(s4);\n\t\t}\n\t\toperator vector<int>(){\n\t\t\treturn a;\n\t\t}\n};",
            1593057363.2021618,
            100,
            "# 答案正确"
        ],
        [
            "9.3 (C++)",
            "万金诚",
            "#include<bits/stdc++.h>\n#include<vector>\nusing namespace std;\nclass Complex{\n\tdouble x;\n\tdouble y;\n\tpublic:\n\tComplex(double a,double b=0):x(a),y(b){\n\t}\n\tComplex(double a):x(a),y(0){\n\t}\n\tComplex():x(0),y(0){\n\t}\n\tdouble real(){\n\t\treturn x;\n\t}\n\tdouble imag(){\n\t\treturn y;\n\t}\n\tComplex operator +(Complex t){\n\t\tComplex temp;\n\t\ttemp.x=x+t.x;\n\t\ttemp.y=y+t.y;\n\t\treturn temp; \n\t}\n\tComplex operator +(int a){\n\t\tComplex temp;\n\t\ttemp.x=x+a;\n\t\ttemp.y=y;\n\t\treturn temp; \n\t}\n\tComplex operator -(Complex t){\n\t\tComplex temp;\n\t\ttemp.x=x-t.x;\n\t\ttemp.y=y-t.y;\n\t\treturn temp; \n\t}\n\tComplex operator -(int a ){\n\t\tComplex temp;\n\t\ttemp.x=x-a;\n\t\ttemp.y=y;\n\t\treturn temp; \n\t}\n\tComplex operator *(Complex t){\n\t\tComplex temp;\n\t\ttemp.x=x*t.x-y*t.y;\n\t\ttemp.y=t.x*y+x*t.y;\n\t\treturn temp; \n\t}\n\tComplex operator /(Complex t){\n\t\tComplex temp(t.x,-t.y);\n\t\tdouble i=t.x*t.x+t.y*t.y;\n\t\ttemp*=(*this); \n\t\treturn Complex(temp.x/i,temp.y/i);\n\t}\n\tComplex &operator +=(Complex t){\n\t\tx=x+t.x;\n\t\ty=y+t.y;\n\t\treturn (*this); \n\t}\n\tComplex &operator -=(Complex t){\n\t\tx-=t.x;\n\t\ty-=t.y;\n\t\treturn (*this); \n\t}\n\tComplex &operator *=(Complex t){\n\t\t*this=(*this) *t;\n\t\treturn *this;\n\t}\n\tComplex &operator /=(Complex t){\n\t\t*this=(*this) /t;\n\t\treturn *this;\n\t}\n\tbool operator ==(Complex t){\n\t\treturn (x==t.x && y==t.y);\n\t}\n\tbool operator !=(Complex t){\n\t\treturn (x!=t.x || y!=t.y);\n\t}\n\t\n};\nComplex operator +(int a,Complex t){\n\t\treturn t+a; \n\t}\n",
            1593060054.558106,
            100,
            "# 答案正确"
        ],
        [
            "9.4 (C++)",
            "万金诚",
            "#include<bits/stdc++.h>\n#include<vector>\nusing namespace std;\nclass Complex{\n\tdouble x;\n\tdouble y;\n\tpublic:\n\tComplex(double a,double b=0):x(a),y(b){\n\t}\n\tComplex(double a){\n\t\tx=a;\n\t\ty=0;\n\t}\n\tComplex():x(0),y(0){\n\t}\n\tdouble real(){\n\t\treturn x;\n\t}\n\tdouble imag(){\n\t\treturn y;\n\t}\n\tComplex operator +(Complex t){\n\t\tComplex temp;\n\t\ttemp.x=x+t.x;\n\t\ttemp.y=y+t.y;\n\t\treturn temp; \n\t}\n\tComplex operator -(Complex t){\n\t\tComplex temp;\n\t\ttemp.x=x-t.x;\n\t\ttemp.y=y-t.y;\n\t\treturn temp; \n\t}/*\n\tComplex operator *(Complex t){\n\t\tComplex temp;\n\t\ttemp.x=x*t.x-y*t.y;\n\t\ttemp.y=t.x*y+x*t.y;\n\t\treturn temp; \n\t}\n\tComplex operator /(Complex t){\n\t\tComplex temp(t.x,-t.y);\n\t\treturn (*this)*temp; \n\t}\n\tComplex &operator +=(Complex t){\n\t\tx=x+t.x;\n\t\ty=y+t.y;\n\t\treturn (*this); \n\t}\n\tComplex &operator -=(Complex t){\n\t\tx-=t.x;\n\t\ty-=t.y;\n\t\treturn (*this); \n\t}\n\tComplex &operator *=(Complex t){\n\t\t*this=(*this) *t;\n\t\treturn *this;\n\t}\n\tComplex &operator /=(Complex t){\n\t\t*this=(*this) /t;\n\t\treturn *this;\n\t}\n\tbool operator ==(Complex t){\n\t\treturn (x==t.x && y==t.y);\n\t}\n\tbool operator !=(Complex t){\n\t\treturn (x!=t.x || y!=t.y);\n\t}*/\n};\nostream & operator <<(ostream & out,Complex &a){\n\tout<<a.real()<<\" + \"<<a.imag()<<\" i\";\n\treturn out;\n}\nistream & operator>>(istream &in,Complex &a){\n\tdouble x, y;\n\tin>>x>>y;\n\tComplex temp(x,y);\n\ta=temp;\n\treturn in;\n}",
            1593061443.7861931,
            100,
            "# 答案正确"
        ],
        [
            "9.5 (C++)",
            "万金诚",
            "#include<bits/stdc++.h>\n#include<vector>\nusing namespace std;\nclass Complex{\n\tdouble x;\n\tdouble y;\n\tpublic:\n\tComplex(double a,double b=0):x(a),y(b){\n\t}\n\tComplex(double a){\n\t\tx=a;\n\t\ty=0;\n\t}\n\tComplex():x(0),y(0){\n\t}\n\tdouble real(){\n\t\treturn x;\n\t}\n\tdouble imag(){\n\t\treturn y;\n\t}\n\tComplex operator +(Complex t){\n\t\tComplex temp;\n\t\ttemp.x=x+t.x;\n\t\ttemp.y=y+t.y;\n\t\treturn temp; \n\t}\n\tComplex operator -(Complex t){\n\t\tComplex temp;\n\t\ttemp.x=x-t.x;\n\t\ttemp.y=y-t.y;\n\t\treturn temp; \n\t}\n\tComplex operator *(Complex t){\n\t\tComplex temp;\n\t\ttemp.x=x*t.x-y*t.y;\n\t\ttemp.y=t.x*y+x*t.y;\n\t\treturn temp; \n\t}\n\tComplex operator /(Complex t){\n\t\tComplex temp(t.x,-t.y);\n\t\treturn (*this)*temp; \n\t}\n\tComplex &operator +=(Complex t){\n\t\tx=x+t.x;\n\t\ty=y+t.y;\n\t\treturn (*this); \n\t}\n\tComplex &operator -=(Complex t){\n\t\tx-=t.x;\n\t\ty-=t.y;\n\t\treturn (*this); \n\t}\n\tComplex &operator *=(Complex t){\n\t\t*this=(*this) *t;\n\t\treturn *this;\n\t}\n\tComplex &operator /=(Complex t){\n\t\t*this=(*this) /t;\n\t\treturn *this;\n\t}\n\tbool operator ==(Complex t){\n\t\treturn (x==t.x && y==t.y);\n\t}\n\tbool operator !=(Complex t){\n\t\treturn (x!=t.x || y!=t.y);\n\t}\n\tComplex operator ++ (){\n\t\tx++;\n\t\treturn (*this);\n\t}\n\tComplex operator ++ (int ){\n\t\tComplex temp=*this;\n\t\tx++;\n\t\treturn temp;\n\t}\n\toperator double(){\n\treturn x;\n\t}\n};\nostream & operator <<(ostream & out,Complex a){\n\tout<<a.real()<<\" + \"<<a.imag()<<\" i\";\n\treturn out;\n}\nistream & operator>>(istream &in,Complex &a){\n\tdouble x, y;\n\tin>>x>>y;\n\tComplex temp(x,y);\n\ta=temp;\n\treturn in;\n}",
            1593071586.085681,
            100,
            "# 答案正确"
        ],
        [
            "9.6 (C++)",
            "万金诚",
            "#include<bits/stdc++.h>\nusing namespace std;\nclass Tensor{\n\tvector<int> sizes;\n\tvector<double> data;\n\tpublic :\n\t\tTensor(int s1,int s2=-1,int s3=-1,int s4=-1){\n\t\t\tsizes.push_back(s1);\n\t\t\tif(s2!=-1)sizes.push_back(s2);\n\t\t\tif(s3!=-1)sizes.push_back(s3);\n\t\t\tif(s4!=-1)sizes.push_back(s4);\n\t\t\tdata.resize(numel());\n\t\t}\n\t\tint numel(){\n\t\t\tint sum=1;\n\t\t\tif(sizes.size()==0)return 0;\n\t\t\telse {\n\t\t\t\tfor(int i=0;i<sizes.size();i++){\n\t\t\t\t\tsum*=sizes[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t\tdouble & operator()(int s1,int s2=-1,int s3=-1,int s4=-1){\n\t\t\tvector<int> index;\n\t\t\tindex.push_back(s1);\n\t\t\tif(s2!=-1)index.push_back(s2);\n\t\t\tif(s3!=-1)index.push_back(s3);\n\t\t\tif(s4!=-1)index.push_back(s4);\n\t\t\tint sum=0;\n\t\t\tfor(int i=0;i<sizes.size();i++){\n\t\t\t\tsum*=sizes[i];\n\t\t\t\tsum+=index[i];\n\t\t\t}\n\t\t\treturn data[sum];\n\t\t}\n};\n",
            1593073242.082147,
            100,
            "# 答案正确"
        ],
        [
            "9.7 (C++)",
            "万金诚",
            "#include<bits/stdc++.h>\nusing namespace std;\nclass Tensor{\n\tpublic:\n\tint tem;\n\tvector<int> sizes;\n\tvector<double> data;\n\tpublic :\n\t\tTensor(){\n\t\t\ttem=0;\n\t\t}\n\t\tTensor(int tem,vector<int> size,vector<double>sum):tem(tem),sizes(size),data(sum){\n\t\t}\n\tint numel(){\n\t\tif(tem==0) return 0;\n\t\tint sum=1;\n\t\tfor(int i=0;i<sizes.size();i++)\n\t\tsum*=sizes[i];\n\t}\t\n};\nistream & operator >> (istream & in,Tensor &a){\n\tint tem;\n\tin>>tem;\n\tvector<int> size;\n\tvector<double> sum;\n\tint n;int num=1;\n\tfor(int i=0;i<tem;i++){\n\t\tin>>n;\n\t\tsize.push_back(n);\n\t\tnum*=n;\n\t}\n\tdouble m;\n\tfor(int i=0;i<num;i++){\n\t\tin>>m;\n\t\tsum.push_back(m);\n\t}\n\tTensor temp(tem,size,sum);\n\ta=temp;\n\treturn in;\n}\nostream & operator << (ostream & out ,Tensor & a){\n\tout<<a.tem<<endl;\n\tfor(int i=0;i<a.tem;i++){\n\t\tout<<a.sizes[i]<<\" \";\n\t}\n\tout<<endl<<endl;\n\tif(a.tem==0) \n\t\treturn out;\n\telse if(a.tem==1) {\n\t\tfor(int i=0;i<a.sizes[0];i++){\n\t\tout<<a.data[i]<<\" \";\n\t\t}\n\t}\n\t\n\telse if (a.tem==2){\n\t\tfor(int i=0;i<a.sizes[0];i++){\n\t\t\tfor(int j=0;j<a.sizes[1];i++){\n\t\t\t\tout<<a.data[i*a.sizes[1]+j]<<\" \";\n\t\t\t}\n\t\t\tout<<endl;\n\t\t}\n\t}\n\telse if(a.tem==3){\n\t\tfor(int i=0;i<a.sizes[0];i++){\n\t\t\tfor(int j=0;j<a.sizes[1];j++){\n\t\t\t\tfor(int k=0;k<a.sizes[2];k++){\n\t\t\t\t\tout<<a.data[i*a.sizes[1]*a.sizes[2]+j*a.sizes[2]+k]<<\" \";\n\t\t\t\t}out<<endl;\n\t\t\t}out<<endl;\n\t\t}\n\t}\n\telse {\n\t\tfor(int i=0;i<a.sizes[0]*a.sizes[1];i++){\n\t\t\tfor(int j=0;j<a.sizes[2];j++){\n\t\t\t\tfor(int k=0;k<a.sizes[3];k++){\n\t\t\t\t\tout<<a.data[i*a.sizes[2]*a.sizes[3]+j*a.sizes[3]+k]<<\" \";\n\t\t\t\t}out<<endl;\n\t\t\t}out<<endl;\n\t\t}\n\t}\n\treturn out;\n}",
            1593076829.1903462,
            100,
            "# 答案正确"
        ],
        [
            "10.2 (C++)",
            "万金诚",
            "\ncatch(NonPositiveValueException & a){\n\tcout<<\"caught: NonPositiveValueException\"<<endl;\n} \ncatch(out_of_range & a){\n\tcout<<\"caught: out_of_range\"<<endl;\n}\n\n",
            1593657879.246791,
            100,
            "# 答案正确"
        ],
        [
            "10.1 (C++)",
            "万金诚",
            "#include<bits/stdc++.h>\nusing std::cin;\nusing std::cout;\nusing std::endl;\nusing std::vector;\nusing std::out_of_range;\nclass MatrixSizesDoNotMatchException :public out_of_range {\n\tpublic:\n\tMatrixSizesDoNotMatchException(const char* a) : out_of_range(a){\n\t}\n};\ndouble Matrix::get(int row, int column) const{\n\tif(row>this->rows || column>this->columns){\n\t\tthrow out_of_range(\"get\");\n\t}\n\treturn elements[(row-1)*columns+column-1];\n}\nvoid Matrix::set(int row, int column, double value){\n\tif(row>this->rows || column>this->columns){\n\t\tthrow out_of_range(\"set\");\n\t}\n\telements[(row-1)*columns+column-1]=value;\n}\nMatrix  Matrix:: operator + (const Matrix & matrix2) const{\n\tif(rows!=matrix2.rows || columns!=matrix2.columns){\n\t\tthrow MatrixSizesDoNotMatchException(\"+\");\n\t}\n\tMatrix temp(rows,columns);\n\tfor(int i=0;i<rows*columns;i++){\n\t\ttemp.elements[i]=elements[i]+matrix2.elements[i];\n\t}\n\treturn temp;\n}",
            1593659788.8314672,
            100,
            "# 答案正确"
        ],
        [
            "15.1 (C++)",
            "万金诚",
            "#include<bits/stdc++.h>\nusing namespace std;\nclass Table{\n\tvector<string> data1;\n\tvector<vector<string>> data2;\n\tpublic:\n\t\tTable(){\n\t\t\tdata2.resize(2);\n\t\t\tfor(int i=0;i<2;i++)\n\t\t\tdata2[i].resize(2);\n\t\t}\n\t\tvoid addCol(string add){\n\t\t\tdata1.push_back(add);\n\t\t}\n\t\tvector<string> & operator [](double i){\n\t\t\treturn data2[i];\n\t\t}\n\t\tstring json ()const{\n\t\t\tstring a(\"{\");\n\t\t\ta=a+\"\\n\"+\"\theaders: [\";\n\t\t\tfor(int i=0;i<data1.size();i++){\n\t\t\t\ta+=\"'\"+data1[i]+\"',\";\n\t\t\t}\n\t\t\ta=a+\"],\"+\"\\n\"+\"\trows: [\";\n\t\t\tfor(int i=0;i<data2.size();i++){\n\t\t\t\ta=a+\"\\n\"+\"\t\t[\";\n\t\t\t\tfor(int j=0;j<data2[i].size();j++){\n\t\t\t\t\ta+=\"'\"+data2[i][j]+\"',\";\n\t\t\t\t}\n\t\t\t\ta=a+\"],\";\n\t\t\t}\n\t\t\ta=a+\"\\n\t],\\n}\";\n\t\t\treturn a;\n\t\t}\n}; ",
            1594145920.1741843,
            100,
            "# 答案正确"
        ],
        [
            "2020-07-09 LAB",
            "万金诚",
            "#include<bits/stdc++.h>\nusing namespace std;\n\nclass Integer {\n\tstatic int m;\n\tint sum;\n\tpublic:\n\t\tInteger(){\n\t\t\tsum=0;\n\t\t}\n\t\tInteger(int x){\n\t\t\tsum=x;\n\t\t}\n\t\toperator int (){\n\t\t\treturn (sum+m);\n\t\t}\n\t\tstatic void increase_all(int x){\n\t\t\tm+=x;\n\t\t}\n};\nint Integer::m=0;\nistream & operator >>(istream &out,Integer & x){\n\tint n;\n\tout>>n;\n\tInteger temp(n);\n\tx=temp;\n\treturn out;\n}",
            1594263527.2774236,
            100,
            "# 答案正确"
        ],
        [
            "A.1 (C++)",
            "万金诚",
            "LinkedList(const LinkedList &o) : _size(0), head(0), tail(0)\n{\n\taddAll(o);\n}\nLinkedList & operator= (const LinkedList & o)\n{\n\tclear();\n\taddAll(o);\n}\n~LinkedList()\n{\n\tclear();\n}\nvoid clear()\n{\n\twhile(_size > 0) removeFirst();\n}\nvoid addAll(const LinkedList & o)\n{\n\tNode<E> *temp = o.head;\n\tNode<E> *prev = 0;\n\tNode<E> *next = temp->next_node(prev);\n\tfor (int i = 0; i < o._size-1;i++)\n\t{\n\t\tadd( i, temp->element);\n\t\tprev = temp;\n\t\ttemp = next;\n\t\tnext = next->next_node(prev);\n\t}\n\tadd(o._size, temp->element);\n}\nvoid print(const LinkedList &o)\n{\n\tNode<E> *temp = o.head;\n\tNode<E> *prev = 0;\n\tNode<E> *next = temp->next_node(prev);\n\tfor (int i = 0; i < o._size-1;i++)\n\t{\n\t\tcout << temp->element << \" \";\n\t\tprev = temp;\n\t\ttemp = next;\n\t\tnext = next->next_node(prev);\n\t}\n\tcout <<temp->element<< endl;\n}\nvoid add(int index,const E o)\n{\n\tNode<E> *node = new Node<E>();\n\tnode->element = o;\n\tif(this->head == 0)\n\t{\n\t\tthis->head = node;\n\t\tthis->tail = this->head;\n\t}\n\telse if(index==0 && this->head != 0)\n\t{\n\t\thead->update_prev_node(0, node);\n\t\tnode->update_next_node(0, head);\n\t\thead = node;\n\t}\n\telse if(index=this->_size)\n\t{\n\t\tNode<E> *temp = this->tail;\n\t\tNode<E> *next = 0;\n\t\tnext = node;\n\t\tnode->update_prev_node(0, temp);\n\t\ttemp->update_next_node(0, next);\n\t\ttail = node;\n\t}\n\t++_size;\n}\nvoid remove(int index)\n{\n\tif(index==0)\n\t{\n\t\tNode<E> *temp = this->head;\n\t\tNode<E> *next = temp->next_node(0);\n\t\tNode<E> *prev = 0;\n\t\tif(next!=0)\n\t\t{\n\t\t\tnext->update_prev_node(head,0);\n\t\t}\n\t\thead = next;\n\t\tdelete temp;\n\t}\n\telse\n\t{\n\t\tNode<E> *temp = this->tail;\n\t\tNode<E> *prev = temp->prev_node(0);\n\t\tthis->tail = prev;\n\t\tprev->update_next_node(temp, 0);\n\t\tdelete temp;\n\t}\n\tthis->_size--;\n}\nvoid addFirst(E val)\n{\n\tadd(0, val);\n}\nvoid addLast(E val)\n{\n\tadd(_size, val);\n}\nvoid removeFirstOccurrence(int val)\n{\n\tNode<E> *temp = this->head;\n\tNode<E> *next = temp->next_node(0);\n\tNode<E> *prev = 0;\n\tif(this->tail->element == val)\n\t{\n\t\tremoveLast();\n\t\treturn;\n\t}\n\telse if(this->head->element==val)\n\t{\n\t\tremoveFirst();\n\t\treturn;\n\t}\n\tfor (int i = 0; i < this->_size-1;i++)\n\t{\n\t\tprev = temp, temp = next;\n\t\tnext = temp->next_node(prev);\n\t\tif (temp->element == val) break;\n\t}\n\tprev->update_next_node(temp, next);\n\tnext->update_prev_node(temp, prev);\n\tdelete temp;\n\tthis->_size--;\n}\nint get(int index)\n{\n\tNode<E> *temp = this->head;\n\tNode<E> *prev = 0;\n\tNode<E> *next = temp->next_node(prev);\n\tif(index==this->_size-1) return this->tail->element;\n\telse if(index==0)\n\t{\n\t\treturn temp->element;\n\t}\n\treturn temp->element;\n}\nvoid removeLast()\n{\n\tremove(this->_size);\n}\nvoid removeFirst()\n{\n\tremove(0);\n}\n",
            1594903042.19584,
            100,
            "# 答案正确"
        ],
        [
            "A.2 (C++)",
            "万金诚",
            "#include<bits/stdc++.h>\ntemplate<typename E>\nvoid LinkedList<E>:: removeAll(const E & e){\n\twhile(indexOf(e)!=-1){\n\t\tremove(indexOf(e)); \n\t} \n}",
            1594865490.350219,
            100,
            "# 答案正确"
        ],
        [
            "A.3 (C++)",
            "万金诚",
            "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <stdexcept>\n#include <sstream>\nusing namespace std;\n\n#define I(i,n) for (size_t i = 0; i < n; ++ i)\n\nclass NoSuchKeyException {};\nsize_t circular_shift(size_t bits, int shift_bits) {\n\tconst int num_bits = 8 * sizeof(size_t);\n\tshift_bits = shift_bits % num_bits;\n\treturn bits << shift_bits | bits >> (num_bits - shift_bits);\n}\n\nsize_t hash_function(const int & key) {\n\tsize_t code = 0;\n\tstring s;\n\tstringstream ss;\n\tss<<key;\n\ts=ss.str();\n\tI(i, s.size())\n\t\tcode ^= circular_shift(s[i], i * 5);\n\treturn code;\n}\n\n\ntemplate<typename V>\nclass HT\n{\n\tclass Tuple\n\t{\n\tpublic:\n\t\tint key;\n\t\tV val;\n\t\tbool in_use;\n\n\t\tTuple() : in_use(false) {}\n\t};\n\n\tvector<Tuple> tuples;\n\tsize_t _size;\n\n\tsize_t canonical_index(const int & key) const {\n\t\tsize_t hash_code = hash_function(key); // needs hash_function(K)\n\t\treturn hash_code % tuples.size();\n\t}\n\n\t// the returned tuple is either empty or with the same key\n\tsize_t indexOfKey(const int & key) const {\n\t\tsize_t index = canonical_index(key);\n\t\twhile (true) { // will enter a dead loop if there is not empty tuple\n\t\t\tif (! tuples[index].in_use) return index;\n\t\t\tif (tuples[index].key == key) return index;\n\t\t\tindex = (index + 1) % tuples.size();\n\t\t}\n\t}\n\npublic:\n\tHT() : _size(0) {\n\t\ttuples.resize(2);\n\t}\n\n\tbool containsKey(const int & key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\treturn tuples[index].in_use;\n\t}\n\n\tconst V & operator [] (const int & key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples[index].val;\n\t}\n\n\tV & operator [] (const int & key) {\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples[index].val;\n\t}\n\n\tvoid put(const int & key, const V & val) {\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].key = key;\n\t\ttuples[index].val = val;\n\t\tif (tuples[index].in_use) return;\n\t\ttuples[index].in_use = true;\n\t\t++ _size;\n\t\t// make sure empty > size / 2\n\t\tif (2 * _size > tuples.size())\n\t\t\t_double_tuples();\n\t}\n\n\tvoid _double_tuples() {\n\t\tvector<Tuple> non_empty_tuples;\n\t\tI(i, tuples.size())\n\t\t\tif (tuples[i].in_use)\n\t\t\t\tnon_empty_tuples.push_back(tuples[i]);\n\t\tclear();\n\t\ttuples.resize(tuples.size() * 2);\n\t\tI(i, non_empty_tuples.size())\n\t\t\tput(non_empty_tuples[i].key, non_empty_tuples[i].val);\n\t}\n\n\tstatic bool _between(size_t hole, size_t canonical, size_t tuple_index) {\n\t\tif (hole < tuple_index)\n\t\t\treturn canonical > hole && canonical <= tuple_index;\n\t\telse\n\t\t\treturn canonical > hole || canonical <= tuple_index;\n\t}\n\n\tvoid remove(const int & key) { \n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\ttuples[index].in_use = false;\n\t\t-- _size;\n\t\t// if there is a hole between a tuple and its canonical position\n\t\t// move the tuple to the hole\n\t\tsize_t hole = index;\n\t\tsize_t tuple_index = hole;\n\t\twhile (true) {\n\t\t\ttuple_index = (tuple_index + 1) % tuples.size();\n\t\t\tif (! tuples[tuple_index].in_use) return;\n\t\t\tsize_t canonical = canonical_index(tuples[tuple_index].key);\n\t\t\tif (_between(hole, canonical, tuple_index)) continue;\n\t\t\ttuples[hole] = tuples[tuple_index];\n\t\t\thole = tuple_index;\n\t\t\ttuples[hole].in_use = false;\n\t\t}\n\t}\n\n\tsize_t size() const { return _size; }\n\n\tvoid clear() {\n\t\tI(i, tuples.size())\n\t\t\ttuples[i].in_use = false;\n\t\t_size = 0;\n\t}\n\n\ttemplate <typename V2>\n\tfriend ostream & operator << (ostream & out, const HT<V2> & dict);\n\n\ttemplate <typename V2>\n\tfriend istream & operator >> (istream & in, HT<V2> & dict);\n\n\tvoid _inspect() const {\n\t\tI(i, tuples.size())\n\t\t\tif (tuples[i].in_use)\n\t\t\t\tcout << \"#\" << i << \" C\" << canonical_index(tuples[i].key) \n\t\t\t\t\t<< \" \" << tuples[i].key << \" \" << tuples[i].val << endl;\n\t}\n\tvector<int> getKeys(){\n\t\tvector<int> temp;\n\t\tfor(int i=0;i<tuples.size();i++){\n\t\tif(tuples[i].in_use){\n\t\t\ttemp.push_back(tuples[i].key);\n\t\t}\n\t\t}\n\t\treturn temp;\n\t}\n};\n\ntemplate < typename V>\nostream & operator << (ostream & out, const HT<V> & dict) {\n\tout << dict.size() << endl;\n\tI(i, dict.tuples.size())\n\t\tif (dict.tuples[i].in_use)\n\t\t\tout << dict.tuples[i].key << \"\\t\" << dict.tuples[i].val << endl;\n\treturn out;\n}\n\ntemplate <typename V>\nistream & operator >> (istream & in, HT<V> & dict) {\n\tdict.clear();\n\tsize_t size;\n\tin >> size;\n\tI(i, size) {\n\t\tint key;\n\t\tV val;\n\t\tin >> key >> val;\n\t\tdict.put(key, val);\n\t}\n\treturn in;\n}",
            1595473538.1890984,
            100,
            "# 答案正确"
        ],
        [
            "A.4 (C++)",
            "万金诚",
            "#include <iostream>\n#include <sstream>\n#include <string>\nusing namespace std;\nclass Tuple\n{\n\tpublic:\n\t\tint key;\n\t\tint value;\n\t\tTuple() {}\n\t\tTuple(int key, int value)\n\t\t{\n\t\t\tthis->key = key;\n\t\t\tthis->value = value;\n\t\t}\n\t\toperator int()\n\t\t{\n\t\t\treturn this->value;\n\t\t}\n\t\toperator string()\n\t\t{\n\t\t\tstring result;\n\t\t\tstringstream s_s;\n\t\t\ts_s << this->value;\n\t\t\ts_s >> result;\n\t\t\treturn result;\n\t\t}\n};\nclass HT\n{\n\tprivate:\n\t\tTuple dict[10];\n\t\tint _size;\n\tpublic:\n\t\tHT(): _size(0) {}\n\t\t~HT(){}\n\t\ttemplate<typename K,typename V>\n\t\tvoid put(K key,V value)\n\t\t{\n\t\t\tint k;\n\t\t\tint val;\n\t\t\tk = str_to_int(key);\n\t\t\tval = str_to_int(value);\n\t\t\tTuple ling(k, val);\n\t\t\tdict[this->_size] = ling;\n\t\t\tthis->_size ++;\n\t\t}\n\t\tint size()\n\t\t{\n\t\t\treturn this->_size;\n\t\t}\n\t\tint str_to_int(int str)\n\t\t{\n\t\t\treturn str;\n\t\t}\n\t\tint str_to_int(string str)\n\t\t{\n\t\t\tstringstream s_s;\n\t\t\ts_s << str;\n\t\t\tint res;\n\t\t\ts_s >> res;\n\t\t\treturn res;\n\t\t}\n\t\tstring int_to_str(string v)\n\t\t{\n\t\t\treturn v;\n\t\t}\n\t\tstring int_to_str(int v)\n\t\t{\n\t\t\tstring result;\n\t\t\tstringstream s_s;\n\t\t\ts_s << v;\n\t\t\ts_s >> result;\n\t\t\treturn result;\n\t\t}\n\t\ttemplate < typename V>\n\t\tTuple operator[](const V &index)\n\t\t{\n\t\t\tint ling;\n\t\t\tling = str_to_int(index);\n\t\t\tfor (int i = 0; i <= 10;i++)\n\t\t\t{\n\t\t\t\tif(dict[i].key == ling)\n\t\t\t\t{\n\t\t\t\t\treturn dict[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n};\n",
            1595852454.565506,
            100,
            "# 答案正确"
        ],
        [
            "A.5 (C++)",
            "万金诚",
            "#include<bits/stdc++.h>\nusing namespace std;\nint to = 0;\nclass V {\npublic:\n\tstring s;\n\tint i;\n\tV(int _i) :i(_i) {\n\t}\n\tV(string _s) :s(_s) {\n\t}\n\toperator string() {\n\t\treturn s;\n\t}\n\toperator int() {\n\t\treturn i;\n\t}\n\tV& operator=(int val){\n\t\t\ti=val;\n\t\t\treturn *this;\n\t}\n\tV& operator=(string val){\n\t\ts=val;\n\t\treturn *this;\n\t}\n};\n\nclass HT {\n\tclass Tuple1 {\n\tpublic:\n\t\tint key;\n\t\tV value;\n\t\tTuple1(int _key, int _value) :key(_key), value(_value) { to++; };\n\t\tTuple1(int _key, string _value) :key(_key), value(_value) { to++; };\n\t};\n\tclass Tuple2 {\n\tpublic:\n\t\tstring key;\n\t\tV value;\n\t\tTuple2(string _key, string _value) :key(_key), value(_value) { to++; };\n\t\tTuple2(string _key, int _value) :key(_key), value(_value) { to++; };\n\t\tvoid operator=(int val){\n\t\t\tvalue=val;\n\t\t}\n\t\tvoid operator=(string val){\n\t\t\tvalue=val;\n\t\t}\n\t};\n\tvector<Tuple1>t1;\n\tvector<Tuple2>t2;\n\npublic:\n\tint size() { return to; }\n\tvoid put(int _key, int _value) {\n\t\tt1.push_back(Tuple1(_key, _value));\n\t}\n\tvoid put(int _key, string _value) {\n\t\tt1.push_back(Tuple1(_key, _value));\n\t}\n\tvoid put(string _key, int _value) {\n\t\tt2.push_back(Tuple2(_key, _value));\n\t}\n\tvoid put(string _key, string _value) {\n\t\tt2.push_back(Tuple2(_key, _value));\n\t}\n\tV& operator [] (const int& key) {\n\t\tfor (int i = 0; i < t1.size(); ++i) {\n\t\t\tif (t1[i].key == key) return t1[i].value;\n\t\t}\n\t\tput(key,5);\n\t\tfor (int i = 0; i < t1.size(); ++i) {\n\t\t\tif (t1[i].key == key) {\n\t\t\t\treturn t1[i].value;\n\t\t\t}\n\t\t}\n\t}\n\tV& operator [] (const string& key) {\n\t\tfor (int i = 0; i < t2.size(); ++i) {\n\t\t\tif (t2[i].key == key) return t2[i].value;\n\t\t}\n\t\tput(key,5);\n\t\tfor (int i = 0; i < t2.size(); ++i) {\n\t\t\tif (t2[i].key == key) {\n\t\t\t\treturn t2[i].value;\n\t\t\t}\n\t\t}\n\t}\n\n};",
            1596199254.327658,
            100,
            "# 答案正确"
        ]
    ],
    "table_name": "答案"
}