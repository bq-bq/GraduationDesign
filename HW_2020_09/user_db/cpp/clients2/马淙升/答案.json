{
    "__update_time__": 1595474197.016798,
    "field_names": [
        "题目名",
        "用户名",
        "答案",
        "提交时间",
        "分数",
        "评语"
    ],
    "field_types": [
        "text",
        "text",
        "text",
        "time",
        "number",
        "text"
    ],
    "foreign_keys": {},
    "primary_keys": [],
    "rows": [
        [
            "测试1",
            "马淙升",
            "#include <iostream>\nusing namespace std;\nint main() {\n\tstring a,b,c;\n\tcin >> a >> b >> c;\n\tcout << c << ' '<< b << ' '<< a;\n}",
            1587607440.1623769,
            100,
            "# 答案正确"
        ],
        [
            "测试2",
            "马淙升",
            "#include <iostream>\nusing namespace std;\nint main() {\n\tstring s[10];\n\tfor(int i = 0;i < 10;++ i) cin >> s[i];\n\tfor(int i = 0;i < 10;++ i) {\n\t\tfor(int j = i;j < 10;++ j) {\n\t\t\tif(s[i] > s[j]) {\n\t\t\t\tstring temp = s[i];\n\t\t\t\ts[i] = s[j];\n\t\t\t\ts[j] = temp;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0;i < 10;++ i) cout << s[i] << ' ';\n}",
            1587608530.2511983,
            100,
            "# 答案正确"
        ],
        [
            "1.1 (C++)",
            "马淙升",
            "\nclass Matrix5x5{\n\tpublic :\n\tdouble num[5][5];\n\tMatrix5x5() {\n\t\tfor(int i = 0;i < 5;++ i) \n\t\t\tfor(int j = 0;j < 5;++ j) num[i][j] = 0;\n\t}\n\tvoid set(int a,int b,double x) {\n\t\tnum[a][b] = x;\n\t}\n\tdouble get(int a,int b) {\n\t\treturn num[a][b];\n\t}\n\tMatrix5x5& operator + (Matrix5x5 a) {\n\t\tfor(int i = 0;i < 5;++ i)\n\t\t\tfor(int j = 0;j<5;++ j)\n\t\t\t\tthis->num[i][j] = this->num[i][j] + a.num[i][j];\n\t\treturn *this;\n\t}\n};",
            1587697466.8790927,
            100,
            "# 答案正确"
        ],
        [
            "1.2 (C++)",
            "马淙升",
            "#include <iostream>\nusing namespace std;\nclass School {\n\tpublic:\n\tstring name;\n\tint age;\n\tSchool() {\n\t\tname = \"NO_NAME\";\n\t\tage = 0;\n\t}\n\tvoid setName(char name[]) {\n\t\tthis->name = name;\n\t}\n\tvoid setAge(int year) {\n\t\tage = year;\n\t}\n\tvoid operator ++ () {\n\t\tage++;\n\t}\n};",
            1588213605.0891697,
            100,
            "# 答案正确"
        ],
        [
            "2.1 (C++)",
            "马淙升",
            "#include<iostream>\n#include<cstring>\nusing namespace std;\nclass Matrix{\n\tprivate:\n\tint rows,columns;\n\tdouble *values;\n\tpublic:\n\tMatrix() {\n\t\trows = columns = 0;\n\t\tvalues = new double[1];\n\t}\n\tMatrix(int row,int col) {\n\t\trows = row;\n\t\tcolumns = col;\n\t\tdelete [] values;\n\t\tvalues = new double[row*col+1];\n\t\tmemset(values,0,sizeof(values));\n\t}\n\t~Matrix() {\n\t\tdelete [] values;\n\t}\n\tvoid print() {\n\t\tfor(int i = 0;i < rows;++ i) {\n\t\t\tfor(int j = 0;j < columns;++ j) {\n\t\t\t\tcout << values[i*columns+j] << \"    \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n};",
            1588833300.6140604,
            100,
            "# 答案正确"
        ],
        [
            "2.2 (C++)",
            "马淙升",
            "#include<iostream>\n#include<iomanip>\nusing namespace std;\nclass Matrix{\n\tprivate:\n\tint rows,columns;\n\tdouble *values;\n\tpublic:\n\tMatrix(int row,int col,double *p) {\n\t\trows = row;\n\t\tcolumns = col;\n\t\tint elem = row*col;\n\t\tvalues = new double[elem];\n\t\tfor(int i = 0;i < elem;++ i) {\n\t\t\tvalues[i] = p[i];\n\t\t}\n\t}\n\t~Matrix() {\n\t\tdelete [] values;\n\t}\n\tvoid print() {\n\t\tfor(int i = 0;i < rows;++ i) {\n\t\t\tfor(int j = 0;j < columns;++ j) {\n\t\t\t\tcout.width(5);\n\t\t\t\tcout << values[i*columns+j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n};",
            1588834953.3892195,
            100,
            "# 答案正确"
        ],
        [
            "2.3 (C++)",
            "马淙升",
            "#include<iostream>\n#include<iomanip>\nusing namespace std;\nclass Matrix{\n\tprivate:\n\tint rows,columns;\n\tdouble *values;\n\tpublic:\n\tMatrix(int row,int col,double *p) {\n\t\trows = row;\n\t\tcolumns = col;\n\t\tint elem = row*col;\n\t\tvalues = new double[elem];\n\t\tfor(int i = 0;i < elem;++ i) {\n\t\t\tvalues[i] = p[i];\n\t\t}\n\t}\n\tMatrix(const Matrix & matrix2) {\n\t\trows = matrix2.rows;\n\t\tcolumns = matrix2.columns;\n\t\tvalues = new double[rows*columns];\n\t\tfor(int i = 0;i < columns*rows;++ i) {\n\t\t\tvalues[i] = matrix2.values[i];\n\t\t}\n\t}\n\t~Matrix() {\n\t\tdelete [] values;\n\t}\n\tvoid print() {\n\t\tfor(int i = 0;i < rows;++ i) {\n\t\t\tfor(int j = 0;j < columns;++ j) {\n\t\t\t\tcout << \"    \" << values[i*columns+j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n};",
            1588835493.2275798,
            100,
            "# 答案正确"
        ],
        [
            "2.5 (C++)",
            "马淙升",
            "#include<iostream>\n#include<iomanip>\nusing namespace std;\nclass Matrix{\n\tprivate:\n\tint rows,columns;\n\tdouble *values;\n\tpublic:\n\tMatrix(int row,int col,double *p) {\n\t\trows = row;\n\t\tcolumns = col;\n\t\tint elem = row*col;\n\t\tvalues = new double[elem];\n\t\tfor(int i = 0;i < elem;++ i) {\n\t\t\tvalues[i] = p[i];\n\t\t}\n\t}\n\tMatrix(const Matrix & matrix2) {\n\t\trows = matrix2.rows;\n\t\tcolumns = matrix2.columns;\n\t\tvalues = new double[rows*columns];\n\t\tfor(int i = 0;i < columns*rows;++ i) {\n\t\t\tvalues[i] = matrix2.values[i];\n\t\t}\n\t}\n\t~Matrix() {\n\t\tdelete [] values;\n\t}\n\tMatrix getRow(int row) {\n\t\tdouble temp[columns];\n\t\trow -= 1;\n\t\tfor(int i = 0;i < columns;++ i) {\n\t\t\ttemp[i] = values[row*columns+i];\n\t\t}\n\t\tMatrix res(1,columns,temp);\n\t\treturn res;\n\t}\n\tMatrix getColumn(int column) {\n\t\tdouble temp[rows];\n\t\tcolumn -= 1;\n\t\tfor(int i = 0;i < rows;++ i) {\n\t\t\ttemp[i] = values[i*columns+column];\n\t\t}\n\t\tMatrix res(rows,1,temp);\n\t\treturn res;\n\t}\n\tvoid print() {\n\t\tfor(int i = 0;i < rows;++ i) {\n\t\t\tfor(int j = 0;j < columns;++ j) {\n\t\t\t\tcout << \"    \" << values[i*columns+j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n};",
            1588837179.6127462,
            100,
            "# 答案正确"
        ],
        [
            "2.6 (C++)",
            "马淙升",
            "#include<iostream>\n#include<iomanip>\nusing namespace std;\nclass Matrix{\n\tprivate:\n\tint rows,columns;\n\tdouble *values;\n\tpublic:\n\tMatrix(int row,int col,double *p) {\n\t\trows = row;\n\t\tcolumns = col;\n\t\tint elem = row*col;\n\t\tvalues = new double[elem];\n\t\tfor(int i = 0;i < elem;++ i) {\n\t\t\tvalues[i] = p[i];\n\t\t}\n\t}\n\tMatrix(const Matrix & matrix2) {\n\t\trows = matrix2.rows;\n\t\tcolumns = matrix2.columns;\n\t\tvalues = new double[rows*columns];\n\t\tfor(int i = 0;i < columns*rows;++ i) {\n\t\t\tvalues[i] = matrix2.values[i];\n\t\t}\n\t}\n\t~Matrix() {\n\t\tdelete [] values;\n\t}\n\tMatrix concatenateRows(const Matrix & matrix2) const {\n\t\tdouble temp[rows*columns+matrix2.rows*matrix2.columns];\n\t\tint i = 0;\n\t\tfor(;i < rows*columns;++ i) temp[i] = values[i];\n\t\tint elem = rows*columns+matrix2.rows*matrix2.columns;\n\t\tfor(;i < elem;++ i) temp[i] = matrix2.values[i - rows*columns];\n\t\tMatrix res(rows+matrix2.rows,columns,temp);\n\t\treturn res;\n\t}\n\tMatrix concatenateColumns(const Matrix & matrix2) const {\n\t\tdouble temp[rows*columns+matrix2.rows*matrix2.columns];\n\t\tint index = 0;\n\t\tfor(int i = 0;i < rows;++ i) {\n\t\t\tfor(int j = 0;j < columns;++ j) \n\t\t\t\ttemp[index++] = values[i*columns+j];\n\t\t\tfor(int j = 0;j < columns;++ j)\n\t\t\t\ttemp[index++] = matrix2.values[i*columns+j];\n\t\t}\n\t\tMatrix res(rows,columns+matrix2.columns,temp);\n\t\treturn res;\n\t}\n\tvoid print() {\n\t\tfor(int i = 0;i < rows;++ i) {\n\t\t\tfor(int j = 0;j < columns;++ j) {\n\t\t\t\tcout << \"    \" << values[i*columns+j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n};",
            1588856915.2815623,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/08",
            "马淙升",
            "double & Tensor_get(int dimensions, const int sizes[],double data[], int x0, int x1, int x2, int x3) {\n\tint index = 0;\n\tint k[4] = {x0,x1,x2,x3};\n\tfor(int i = dimensions;i > 0;-- i) {\n\t\tindex = k[i-1]+index*sizes[i-1];\n\t}\n\treturn data[index];\n}",
            1588906360.9709783,
            100,
            "# 答案正确"
        ],
        [
            "2020/05/14",
            "马淙升",
            "#include<iostream>\nusing namespace std;\nvoid print(const double *p,int index,const int a,const int b) {\n\tfor(int i = 0;i < a;++ i) {\n\t\tfor(int j = 0;j < b;++ j) {\n\t\t\tcout.width(7);\n\t\t\tcout << p[index+i*a+b];\n\t\t}\n\t\tcout << endl;\n\t}\n}\nvoid Tensor_print(int dimensions,const int*sizes,const double *data) {\n\tif(dimensions == 1) {\n\t\tcout << \"Tensor of \" << sizes[0] << endl;\n\t\tfor(int i = 0;i < sizes[0];++ i) {\n\t\t\tcout << data[i] << endl;\n\t\t}\n\t}\n\telse if(dimensions == 2) {\n\t\tcout << \"Tensor of \" << sizes[0] << 'x' << sizes[1] << endl; \n\t\tprint(data,0,sizes[0],sizes[1]);\n\t}\n\telse if(dimensions == 3) {\n\t\tcout << \"Tensor of \" << sizes[0] << 'x' << sizes[1] << 'x' << sizes[2] << endl;\n\t\tfor(int i = 0;i < sizes[0];++ i) {\n\t\t\tcout << \"data[\" << i << ']' << endl;\n\t\t\tprint(data,i*sizes[1]*sizes[2],sizes[1],sizes[2]);\n\t\t}\n\t}\n\telse if(dimensions == 4) {\n\t\tcout << \"Tensor of \" << sizes[0] << 'x' << sizes[1] << 'x' << sizes[2] << 'x' << sizes[3] << endl;\n\t\tfor(int i = 0;i < sizes[0];++ i) {\n\t\t\tfor(int j = 0;j < sizes[1];++ j) {\n\t\t\t\tcout << \"data[\" << i << \"][\" << j << ']' << endl;\n\t\t\t\tint index = i*sizes[1]*sizes[2]*sizes[3]+j*sizes[2]*sizes[3];\n\t\t\t\tprint(data,index,sizes[2],sizes[3]);\n\t\t\t}\n\t\t}\n\t}\n}",
            1589425113.9358654,
            100,
            "# 答案正确"
        ],
        [
            "2.4 (C++)",
            "马淙升",
            "#include<iostream>\n#include<cstring>\nusing namespace std;\nclass Matrix {\nprivate:\n\tint rows,columns;\n\tdouble* values;\npublic:\n\tMatrix(int rows,int columns) {\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tvalues = new double[rows*columns+1];\n\t\tfor (int i = 0; i < rows*columns; ++ i)\n\t\t\tvalues[i] = 0;\n\t}\n\tMatrix(int rows, int columns, double values[]) {\n\t\tthis->rows = rows;\n\t\tthis->columns = columns;\n\t\tthis -> values = new double[rows*columns+1];\n\t\tfor(int i = 0;i < rows*columns;++ i)\n\t\t\tthis->values[i] = values[i];\n\t}\n\t~Matrix() {\n\t\tdelete [] values;\n\t}\n\tvoid print() {\n\t\tfor(int i = 0;i < rows;++ i) {\n\t\t\tfor(int j = 0;j < columns;++ j) {\n\t\t\t\tcout << \"    \" << values[i*columns+j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t} \n\tvoid set(int row, int column, double value) {\n\t\tvalues[(row-1)*columns+column-1] = value;\n\t}\n\tMatrix& operator = (const Matrix& p) {\n\t\trows = p.rows;\n\t\tcolumns = p.columns;\n\t\tdelete [] values;\n\t\tvalues = new double[p.rows*p.columns+1];\n\t\tfor (int i = 0; i < rows*columns; ++ i)\n\t\t\tvalues[i] = p.values[i];\n\t\treturn *this;\n\t}\n};",
            1589511163.659551,
            100,
            "# 答案正确"
        ],
        [
            "2.7 (C++)",
            "马淙升",
            "#include <iostream>\nusing namespace std;\nclass Matrix{\nprivate:\n\tint rows,columns;\n\tdouble *values;\npublic:\n\tMatrix(int rows, int column, double values[]) {\n\t\tthis->rows = rows;\n\t\tthis->columns = column;\n\t\tthis -> values = new double[rows*column];\n\t\tfor(int i = 0;i < rows*column;++ i) \n\t\t\tthis->values[i] = values[i];\n\t}\n\tMatrix(const Matrix & matrix2) {\n\t\trows = matrix2.rows;\n\t\tcolumns = matrix2.columns;\n\t\tvalues = new double[rows*columns];\n\t\tfor(int i = 0;i < rows*columns;++ i) {\n\t\t\tvalues[i] = matrix2.values[i];\n\t\t}\n\t}\n\t~Matrix() {\n\t\tdelete [] values;\n\t}\n\tvoid print() {\n\t\tfor(int i = 0;i < rows;++ i) {\n\t\t\tfor (int j = 0; j < columns; ++ j) {\n\t\t\t\tcout << \"    \" << values[i*columns+j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tMatrix reshape(int rows, int columns) const {\n\t\tdouble temp[rows*columns];\n\t\tint counter = 0;\n\t\tfor (int i = 0; i < this -> columns; ++ i) {\n\t\t\tfor(int j = 0;j < this->rows;++ j) {\n\t\t\t\ttemp[counter/rows+(counter%rows)*columns] = values[j*this->columns+i];\n\t\t\t\tcounter++;\n\t\t\t}\n\t\t} \n\t\tMatrix res(rows,columns,temp);\n\t\treturn res;\n\t}\n};",
            1589514581.567919,
            100,
            "# 答案正确"
        ],
        [
            "2.8 (C++)",
            "马淙升",
            "#include <iostream>\nusing namespace std;\nclass Matrix{\nprivate:\n\tint rows,columns;\n\tdouble *values;\npublic:\n\tMatrix(int rows, int column, double values[]) {\n\t\tthis->rows = rows;\n\t\tthis->columns = column;\n\t\tthis -> values = new double[rows*column];\n\t\tfor(int i = 0;i < rows*column;++ i) \n\t\t\tthis->values[i] = values[i];\n\t}\n\tMatrix(const Matrix & matrix2) {\n\t\trows = matrix2.rows;\n\t\tcolumns = matrix2.columns;\n\t\tvalues = new double[rows*columns];\n\t\tfor(int i = 0;i < rows*columns;++ i) {\n\t\t\tvalues[i] = matrix2.values[i];\n\t\t}\n\t}\n\t~Matrix() {\n\t\tdelete [] values;\n\t}\n\tvoid print() {\n\t\tfor(int i = 0;i < rows;++ i) {\n\t\t\tfor (int j = 0; j < columns; ++ j) {\n\t\t\t\tcout << \"    \" << values[i*columns+j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tMatrix transpose() const {\n\t\tdouble temp[rows*columns];\n\t\tint counter = 0;\n\t\tfor (int i = 0; i < rows; ++ i) {\n\t\t\tfor(int j = 0;j < columns;++ j) {\n\t\t\t\ttemp[j*rows+i] = values[i*columns+j];\n\t\t\t}\n\t\t} \n\t\tMatrix res(columns,rows,temp);\n\t\treturn res;\n\t}\n};",
            1589515008.5224946,
            100,
            "# 答案正确"
        ],
        [
            "2.10 (C++)",
            "马淙升",
            "#include <iostream>\nusing namespace std;\nclass Matrix{\nprivate:\n\tint rows,columns;\n\tdouble *values;\npublic:\n\tMatrix(int rows, int column, double values[]) {\n\t\tthis->rows = rows;\n\t\tthis->columns = column;\n\t\tthis -> values = new double[rows*column];\n\t\tfor(int i = 0;i < rows*column;++ i) \n\t\t\tthis->values[i] = values[i];\n\t}\n\tMatrix(const Matrix & matrix2) {\n\t\trows = matrix2.rows;\n\t\tcolumns = matrix2.columns;\n\t\tvalues = new double[rows*columns];\n\t\tfor(int i = 0;i < rows*columns;++ i) {\n\t\t\tvalues[i] = matrix2.values[i];\n\t\t}\n\t}\n\t~Matrix() {\n\t\tdelete [] values;\n\t}\n\tvoid print() {\n\t\tfor(int i = 0;i < rows;++ i) {\n\t\t\tfor (int j = 0; j < columns; ++ j) {\n\t\t\t\tcout << \"    \" << values[i*columns+j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tMatrix operator * (const Matrix & matrix2) const {\n\t\tdouble temp[rows*matrix2.columns];\n\t\tfor(int i = 0;i < rows;++ i) {\n\t\t\tfor(int j = 0;j < matrix2.columns;++ j) {\n\t\t\t\tdouble num = 0;\n\t\t\t\tfor(int k = 0;k < columns;++ k) {\n\t\t\t\t\tnum += values[i*columns+k] * matrix2.values[k*matrix2.columns+j];\n\t\t\t\t}\n\t\t\t\ttemp[i*matrix2.columns+j] = num;\n\t\t\t}\n\t\t}\n\t\tMatrix res(rows,matrix2.columns,temp);\n\t\treturn res;\n\t}\n\tMatrix operator * (double value) const {\n\t\tMatrix res(*this);\n\t\tfor(int i = 0;i < rows*columns;++ i) \n\t\t\tres.values[i] *= value;\n\t\treturn res;\n\t}\n};",
            1589517603.8015394,
            100,
            "# 答案正确"
        ],
        [
            "2.11 (C++)",
            "马淙升",
            "#include <iostream>\n#define inf 666666\nusing namespace std;\nclass Matrix{\nprivate:\n\tint rows,columns;\n\tdouble *values;\npublic:\n\tMatrix(int rows, int column, double values[]) {\n\t\tthis->rows = rows;\n\t\tthis->columns = column;\n\t\tthis -> values = new double[rows*column+1];\n\t\tfor(int i = 0;i < rows*column;++ i) \n\t\t\tthis->values[i] = values[i];\n\t}\n\tMatrix(const Matrix & matrix2) {\n\t\trows = matrix2.rows;\n\t\tcolumns = matrix2.columns;\n\t\tvalues = new double[rows*columns];\n\t\tfor(int i = 0;i < rows*columns;++ i) {\n\t\t\tvalues[i] = matrix2.values[i];\n\t\t}\n\t}\n\t~Matrix() {\n\t\tdelete [] values;\n\t}\n\tvoid print() {\n\t\tfor(int i = 0;i < rows;++ i) {\n\t\t\tfor (int j = 0; j < columns; ++ j) {\n\t\t\t\tcout << \"    \" << values[i*columns+j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tMatrix max() const {\n\t\tif(rows == 1) {\n\t\t\tdouble maxa[2];\n\t\t\tmaxa[0] = 0;\n\t\t\tfor(int i = 0;i < columns;++ i) {\n\t\t\t\tif(values[i] > maxa[0]) maxa[0] = values[i];\n\t\t\t}\n\t\t\tMatrix res(1,1,maxa);\n\t\t\treturn res;\n\t\t}\n\t\tdouble temp[columns] = {0};\n\t\tfor(int i = 0;i < rows;++ i) {\n\t\t\tfor(int j = 0;j < columns;++ j) {\n\t\t\t\tif(temp[j] < values[i*columns+j])\n\t\t\t\t\ttemp[j] = values[i*columns+j];\n\t\t\t}\n\t\t}\n\t\tMatrix res(1,columns,temp);\n\t\treturn res;\n\t}\n\tMatrix min() const{\n\t\tif(rows == 1) {\n\t\t\tdouble mina[2];\n\t\t\tmina[0] = inf;\n\t\t\tfor(int i = 0;i < columns;++ i) {\n\t\t\t\tif(values[i] < mina[0]) mina[0] = values[i];\n\t\t\t}\n\t\t\tMatrix res(1,1,mina);\n\t\t\treturn res;\n\t\t}\n\t\tdouble temp[columns];\n\t\tfor(int i = 0;i < columns;++ i) \n\t\t\ttemp[i] = inf;\n\t\tfor(int i = 0;i < rows;++ i) {\n\t\t\tfor(int j = 0;j < columns;++ j) {\n\t\t\t\tif(temp[j] > values[i*columns+j])\n\t\t\t\t\ttemp[j] = values[i*columns+j];\n\t\t\t}\n\t\t}\n\t\tMatrix res(1,columns,temp);\n\t\treturn res;\n\t}\n\tMatrix sum() const{\n\t\tif(rows == 1) {\n\t\t\tdouble total[2];\n\t\t\ttotal[0] = 0;\n\t\t\tfor(int i = 0;i < columns;++ i) {\n\t\t\t\ttotal[0] += values[i];\n\t\t\t}\n\t\t\tMatrix res(1,1,total);\n\t\t\treturn res;\n\t\t}\n\t\tdouble temp[columns] = {0};\n\t\tdouble maxv = 0;\n\t\tfor(int i = 0;i < rows;++ i) {\n\t\t\tfor(int j = 0;j < columns;++ j) \n\t\t\t\ttemp[j] += values[i*columns+j];\n\t\t}\n\t\tMatrix res(1,columns,temp);\n\t\treturn res;\n\t}\n};",
            1589552845.9483151,
            100,
            "# 答案正确"
        ],
        [
            "2.12 (C++)",
            "马淙升",
            "#include <iostream>\n#include<cmath>\nusing std::cin;\nusing std::cout;\nusing std::endl;\nclass Matrix{\nprivate:\n\tint rows,columns;\n\tdouble *values;\npublic:\n\tMatrix(int rows, int column, double values[]) {\n\t\tthis->rows = rows;\n\t\tthis->columns = column;\n\t\tthis -> values = new double[rows*column];\n\t\tfor(int i = 0;i < rows*column;++ i) \n\t\t\tthis->values[i] = values[i];\n\t}\n\tMatrix(const Matrix & matrix2) {\n\t\trows = matrix2.rows;\n\t\tcolumns = matrix2.columns;\n\t\tvalues = new double[rows*columns];\n\t\tfor(int i = 0;i < rows*columns;++ i) {\n\t\t\tvalues[i] = matrix2.values[i];\n\t\t}\n\t}\n\t~Matrix() {\n\t\tdelete [] values;\n\t}\n\tvoid print() {\n\t\tfor(int i = 0;i < rows;++ i) {\n\t\t\tfor (int j = 0; j < columns; ++ j) {\n\t\t\t\tcout << \"    \" << values[i*columns+j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tMatrix pow(double exponent) {\n\t\tMatrix res(*this);\n\t\tint index = rows * columns;\n\t\tfor(int i = 0;i < index;++ i) {\n\t\t\tres.values[i] = ::pow(res.values[i],exponent);\n\t\t}\n\t\treturn res;\n\t}\n\tMatrix exp() {\n\t\tMatrix res(*this);\n\t\tint index = rows*columns;\n\t\tfor(int i = 0;i < index;++ i) \n\t\t\tres.values[i] = ::exp(res.values[i]);\n\t\treturn res;\n\t}\n\tMatrix log() {\n\t\tMatrix res(*this);\n\t\tint index = rows*columns;\n\t\tfor(int i = 0;i < index;++ i) \n\t\t\tres.values[i] = ::log(res.values[i]);\n\t\treturn res;\n\t}\n\tMatrix abs() {\n\t\tMatrix res(*this);\n\t\tint index = rows*columns;\n\t\tfor(int i = 0;i < index;++ i) \n\t\t\tres.values[i] = ::abs(res.values[i]);\n\t\treturn res;\n\t}\n};",
            1589555069.627233,
            100,
            "# 答案正确"
        ],
        [
            "2.9 (C++)",
            "马淙升",
            "#include <iostream>\nusing namespace std;\nclass Matrix{\nprivate:\n\tint rows,columns;\n\tdouble *values;\npublic:\n\tMatrix(int rows, int column, double values[]) {\n\t\tthis->rows = rows;\n\t\tthis -> columns = column;\n\t\tthis->values = new double[rows*column];\n\t\tfor(int i = 0;i < rows*column;++ i)\n\t\t\tthis->values[i] = values[i];\n\t}\n\tMatrix(const Matrix & matrix2) {\n\t\tthis->rows = matrix2.rows;\n\t\tthis->columns = matrix2.columns;\n\t\tthis->values = new double[rows*columns];\n\t\tfor(int i = 0;i < rows*columns;++ i) \n\t\t\tthis->values[i] = matrix2.values[i];\n\t}\n\t~Matrix() {\n\t\tdelete [] values;\n\t}\n\tvoid print() {\n\t\tfor(int i = 0;i < rows;++ i) {\n\t\t\tfor(int j = 0;j < columns;++ j) {\n\t\t\t\tcout << \"    \" << values[i*columns+j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tMatrix operator + (const Matrix & matrix2) const {\n\t\tMatrix res(*this);\n\t\tfor(int i = 0;i < rows;++ i) {\n\t\t\tfor(int j = 0;j < columns;++ j) {\n\t\t\t\tres.values[i*columns+j] += matrix2.values[i*columns+j];\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tMatrix operator + (double value) const{\n\t\tMatrix res(*this);\n\t\tfor (int i = 0; i < rows; ++ i) \n\t\t\tfor(int j = 0;j < columns;++ j) \n\t\t\t\tres.values[i*columns+j] += value;\n\t\treturn res;\n\t}\n\tMatrix operator - (const Matrix & matrix2) const {\n\t\tMatrix res(*this);\n\t\tfor(int i = 0;i < rows;++ i) {\n\t\t\tfor(int j = 0;j < columns;++ j) {\n\t\t\t\tres.values[i*columns+j] -= matrix2.values[i*columns+j];\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tMatrix operator - (double value) const{\n\t\tMatrix res(*this);\n\t\tfor (int i = 0; i < rows; ++ i) \n\t\t\tfor(int j = 0;j < columns;++ j) \n\t\t\t\tres.values[i*columns+j] -= value;\n\t\treturn res;\n\t}\n};",
            1590027676.1813788,
            100,
            "# 答案正确"
        ],
        [
            "6.1 (C++)",
            "马淙升",
            "#include<iostream>\n#include<cstring>\nusing namespace std;\ntemplate <typename T>\nclass Matrix {\nprivate:\n\tT * store;\n\tint rows,columns;\npublic:\n\tMatrix(int a,int b) {\n\t\trows = a;\n\t\tcolumns = b;\n\t\tstore = (T*)new T[a*b];\n\t\tmemset(store,0,sizeof(T)*a*b);\n\n\t}\n\tMatrix(int a,int b,const T *from) {\n\t\trows = a;\n\t\tcolumns = b;\n\t\tstore = new T[a*b];\n\t\tfor(int i = 0;i < rows;++ i)\n\t\t\tfor(int j = 0;j < columns;++ j) \n\t\t\t\tstore[i*columns+j] = from[i*columns+j]; \n\t}\n\tMatrix(const Matrix& other) {\n\t\trows = other.rows;\n\t\tcolumns = other.columns;\n\t\tstore = new T[rows*columns];\n\t\t//memcpy(store,other.store,sizeof(store));\n\t\tfor(int i = 0;i < rows;++ i)\n\t\t\tfor(int j = 0;j < columns;++ j) \n\t\t\t\tstore[i*columns+j] =other.store[i*columns+j]; \n\t}\n\t~Matrix() {\n\t\tdelete [] store;\n\t}\n\tT& get(int a,int b) {\n\t\treturn store[(a-1)*columns+b-1];\n\t}\n\tvoid print() {\n\t\tfor(int i = 0;i < rows;++ i) {\n\t\t\tfor(int j = 0;j < columns;++ j) {\n\t\t\t\tcout << \"    \" << store[i*columns+j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tMatrix& operator =(const Matrix other){\n\t\tthis->rows = other.rows;\n\t\tthis->columns = other.columns;\n\t\tdelete [] store;\n\t\tstore = new T[rows*columns];\n\t\t//memcpy(store,other.store,sizeof(store));\n\t\tfor(int i = 0;i < rows;++ i)\n\t\t\tfor(int j = 0;j < columns;++ j) \n\t\t\t\tstore[i*columns+j] = other.store[i*columns+j]; \n\t\treturn *this;\n\t}\n};\n",
            1590123444.4428244,
            100,
            "# 答案正确"
        ],
        [
            "6.3 (C++)",
            "马淙升",
            "#include<iostream>\n#include<vector>\n#define inf 66666\nusing namespace std;\ntemplate <typename T>\nclass Matrix{\nprivate:\n\tint rows,columns;\n\tvector<T> values;\npublic:\n\tMatrix(int a,int b) {\n\t\tint index = a*b;\n\t\trows = a;\n\t\tcolumns = b;\n\t\tfor (int i = 0; i < index; ++ i)\n\t\t\tvalues.push_back(0);\n\t}\n\tMatrix(int a,int b,int c) {\n\t\trows = a;\n\t\tcolumns = b;\n\t}\n\t//template <typename E>\n\tMatrix(int a,int b,const vector<T> from):rows(a),columns(b) {\n\t\tint index = a*b;\n\t\tfor (int i = 0; i < index; ++ i)\n\t\t\tvalues.push_back(from[i]);\n\t}\n\tMatrix(int a,int b,const T*from) :rows(a),columns(b) {\n\t\tint index = a*b;\n\t\tfor (int i = 0; i < index; ++ i)\n\t\t\tvalues.push_back(from[i]);\n\t}\n\t//Matrix& operator = (const Matrix from) {\n\t//\trows = from.rows;\n\t//\tcolumns = from.columns;\n\t//\tvalues = from.values;\n\t//\treturn *this;\n\t//}\n\tMatrix operator + (const Matrix from) {\n\t\tMatrix res(rows,columns,0);\n\t\tfor (int i = 0; i < rows*columns; ++ i) \n\t\t\tres.values.push_back(values[i]+from.values[i]);\n\t\treturn res;\n\t}\n\tMatrix operator + (T a) {\n\t\tMatrix res(rows,columns,0);\n\t\tfor (int i = 0; i < rows*columns; ++ i)\n\t\t\tres.values.push_back(values[i]+a);\n\t\treturn res;\n\t}\n\tMatrix operator - (const Matrix from) {\n\t\tMatrix res(rows,columns,0);\n\t\tfor (int i = 0; i < rows*columns; ++ i) \n\t\t\tres.values.push_back(values[i]-from.values[i]);\n\t\treturn res;\n\t}\n\tMatrix operator - (T a) {\n\t\tMatrix res(rows,columns,0);\n\t\tfor (int i = 0; i < rows*columns; ++ i)\n\t\t\tres.values.push_back(values[i]-a);\n\t\treturn res;\n\t}\n\tMatrix operator * (const Matrix from) {\n\t\tMatrix<T> res(rows,from.columns,0);\n\t\tfor (int i = 0; i < rows; ++ i) {\n\t\t\tfor(int j = 0;j < from.columns;++ j) {\n\t\t\t\tT temp = 0;\n\t\t\t\tfor(int k = 0;k < columns;++ k)\n\t\t\t\t\ttemp += values[i*columns+k]*from.values[k*from.columns+j];\n\t\t\t\tres.values.push_back(temp);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tMatrix operator * (T a) {\n\t\tMatrix res(rows,columns,0);\n\t\tfor (int i = 0; i < rows*columns; ++ i)\n\t\t\tres.values.push_back(values[i]*a);\n\t\treturn res;\n\t}\n\tMatrix getRow(int a) {\n\t\tT temp[columns];\n\t\tfor (int i = 0; i < columns; ++ i)\n\t\t\ttemp[i] = values[(a-1)*columns+i];\n\t\tMatrix<T> res(1,columns,temp);\n\t\treturn res;\n\t}\n\tMatrix getColumn(int a) {\n\t\tT temp[rows];\n\t\tfor(int i = 0;i < rows;++ i)\n\t\t\ttemp[i] = values[i*columns+a-1];\n\t\tMatrix<T> res(rows,1,temp);\n\t\treturn res;\n\t}\n\tMatrix concatenateRows(const Matrix<T> from) {\n\t\tMatrix<T> res(rows+from.rows,columns,0);\n\t\tfor(int i = 0;i < rows*columns;++ i) \n\t\t\tres.values.push_back(values[i]);\n\t\tfor (int i = 0; i < from.rows*from.columns; ++ i)\n\t\t\tres.values.push_back(from.values[i]);\n\t\treturn res;\n\t}\n\tMatrix concatenateColumns(const Matrix<T> from) {\n\t\tMatrix<T> res(rows,columns+from.columns,0);\n\t\tfor(int i = 0;i < rows;++ i) {\n\t\t\tfor (int j = 0; j < columns; ++ j)\n\t\t\t\tres.values.push_back(values[i*columns+j]);\n\t\t\tfor(int j = 0;j < from.columns;++ j)\n\t\t\t\tres.values.push_back(from.values[i*from.columns+j]);\n\t\t}\n\t\treturn res;\n\t}\n\tMatrix reshape(int a,int b) {\n\t\tT temp[a*b];\n\t\tint k = 0;\n\t\tMatrix other = this -> transpose();\n\t\tfor (int i = 0; i < b; ++ i)\n\t\t\tfor(int j = 0;j < a;++ j)\n\t\t\t\ttemp[i+j*b] = other.values[k++];\n\t\tMatrix res(a,b,temp);\n\t\treturn res;\n\t}\n\tMatrix transpose() {\n\t\tMatrix<T> res(columns,rows,0);\n\t\tint k = 0;\n\t\tfor (int i = 0; i < columns; ++ i)\n\t\t\tfor(int j = 0;j < rows;++ j)\n\t\t\t\tres.values.push_back(values[i+j*columns]);\n\t\treturn res;\n\t}\n\tT& get(int a,int b) {\n\t\treturn values[(a-1)*columns+b-1];\n\t}\n\tMatrix sum() {\n\t\tif(rows == 1) {\n\t\t\tMatrix<T> res(1,1,0);\n\t\t\tT total;\n\t\t\tfor (int i = 0; i < columns; ++ i)\n\t\t\t\ttotal += values[i];\n\t\t\tres.values.push_back(total);\n\t\t\treturn res;\n\t\t}\n\t\tT temp[columns];\n\t\tfor (int i = 0; i < columns; ++ i)\n\t\t\ttemp[i] = 0;\n\t\tfor (int i = 0; i < rows; ++ i) {\n\t\t\tfor(int j = 0;j < columns;++ j) \n\t\t\t\ttemp[j] += values[i*columns+j];\n\t\t} \n\t\tMatrix<T> res(1,columns,temp);\n\t\treturn res;\n\t}\n\tMatrix max() {\n\t\tif(rows == 1) {\n\t\t\tMatrix<T> res(1,1,0);\n\t\t\tT temp = -inf;\n\t\t\tfor (int i = 0; i < columns; ++ i)\n\t\t\t\tif(values[i] > temp) temp = values[i];\n\t\t\tres.values.push_back(temp);\n\t\t\treturn res;\n\t\t}\n\t\tT temp[columns];\n\t\tfor (int i = 0; i < columns; ++ i) {\n\t\t\ttemp[i] = -inf;\n\t\t\tfor(int j = 0;j < rows;++ j) {\n\t\t\t\tif(temp[i] < values[j*columns+i])\n\t\t\t\t\ttemp[i] = values[j*columns+i];\n\t\t\t}\n\t\t} \n\t\tMatrix<T> res(1,columns,temp);\n\t\treturn res;\n\t}\n\tMatrix min() {\n\t\tif(rows == 1) {\n\t\t\tMatrix<T> res(1,1,0);\n\t\t\tT temp = inf;\n\t\t\tfor (int i = 0; i < columns; ++ i)\n\t\t\t\tif(values[i] < temp) temp = values[i];\n\t\t\tres.values.push_back(temp);\n\t\t\treturn res;\n\t\t}\n\t\tT temp[columns];\n\t\tfor (int i = 0; i < columns; ++ i) {\n\t\t\ttemp[i] = inf;\n\t\t\tfor(int j = 0;j < rows;++ j) {\n\t\t\t\tif(temp[i] > values[j*columns+i])\n\t\t\t\t\ttemp[i] = values[j*columns+i];\n\t\t\t}\n\t\t} \n\t\tMatrix<T> res(1,columns,temp);\n\t\treturn res;\n\t}\n\tvoid print() {\n\t\tfor (int i = 0; i < rows; ++ i) {\n\t\t\tfor(int j = 0;j < columns;++ j)\n\t\t\t\tcout << \"    \" << values[i*columns+j];\n\t\t\tcout << endl;\n\t\t}\n\t}\n};",
            1590214459.0866659,
            100,
            "# 答案正确"
        ],
        [
            "6.2 (C++)",
            "马淙升",
            "#include<iostream>\nusing namespace std;\ntemplate <typename T>\nclass Matrix{\nprivate:\n\tint rows,columns;\n\tT * values;\npublic:\n\tMatrix(int rows,int columns):rows(rows),columns(columns) {\n\t\tvalues = new T[rows*columns];\n\t\tfor (int i = 0; i < rows*columns; ++ i)\n\t\t\tvalues[i] = T();\n\t}\n\t~Matrix(){\n\t\tdelete [] values;\n\t}\n\tvoid print() {\n\t\tfor(int i = 0;i < rows;++ i) {\n\t\t\tfor(int j = 0;j < columns;++ j) {\n\t\t\t\tcout << \"    \" << values[i*columns+j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n};",
            1590631716.1610515,
            100,
            "# 答案正确"
        ],
        [
            "7.1 (C++)",
            "马淙升",
            "#include<cmath>\nusing namespace std;\nclass Triangle : public GeometricObject{\nprivate: \n\tdouble size1,size2,size3;\npublic:\n\tTriangle() {\n\t\tsize1 = size2= size3 = 1;\n\t}\n\tTriangle(double a,double b,double c):size1(a),size2(b),size3(c) {};\n\tdouble getSide1() {\n\t\treturn size1;\n\t}\n\tdouble getSide2() {\n\t\treturn size2;\n\t}\n\tdouble getSide3() {\n\t\treturn size3;\n\t}\n\tdouble getArea() {\n\t\tdouble s = (size1+size2+size3)/2;\n\t\treturn sqrt(s*(s-size1)*(s-size2)*(s-size3));\n\t}\n\tdouble getPerimeter() {\n\t\treturn size1 + size2 + size3;\n\t}\n};",
            1590719607.0507216,
            100,
            "# 答案正确"
        ],
        [
            "7.3 (C++)",
            "马淙升",
            "#include <iostream>\nusing namespace std;\ntemplate <typename A>\nvector<A> map2(const vector<A> data1,const vector<A>data2,A (*fun)(const A&,const A&)) {\n\tvector<A> res;\n\tfor (int i = 0; i < data1.size(); ++ i)\n\t\tres.push_back(fun(data1[i],data2[i]));\n\treturn res;\n}\ntemplate <typename A>\nvector<A> map2(const vector<A> data1,const int& data2,A(*fun)(const A&,const int&)) {\n\tvector<A> res;\n\tfor (int i = 0; i < data1.size(); ++ i)\n\t\tres.push_back(fun(data1[i],data2));\n\treturn res;\n}",
            1590725940.844607,
            100,
            "# 答案正确"
        ],
        [
            "7.2 (C++)",
            "马淙升",
            "#include <iostream>\n#include<vector>\nusing namespace std;\nvector<string> split(string sentence) {\n\tvector<string> res;\n\tint k = 0,judge = 0;\n\tres.push_back(string());\n\tfor (int i = 0; i < sentence.size(); ++ i) {\n\t\tif(sentence[i] == ' ') {\n\t\t\tif(judge == 1) {\n\t\t\t\tres.push_back(string());\n\t\t\t\tjudge = 0;\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tres[k].push_back(sentence[i]);\n\t\t\tjudge = 1;\n\t\t}\n\t} \n\tres.pop_back();\n\treturn res;\n}",
            1591240969.138249,
            100,
            "# 答案正确"
        ],
        [
            "8.1 (C++)",
            "马淙升",
            "#include <iostream>\n#include<cstring>\nusing namespace std;\nclass Full:public Matrix {\nprivate:\n\tint rows,columns;\n\tdouble *store;\npublic:\n\tFull(int rows, int column):rows(rows),columns(column) {\n\t\tstore = new double[rows*column];\n\t\tmemset(store,0,sizeof(double)*rows*columns);\n\t}\n\tFull(int rows, int column, double values[]):rows(rows),columns(column) {\n\t\tstore = new double[rows*column];\n\t\tint elem = rows*column;\n\t\tfor (int i = 0; i < elem; ++ i)\n\t\t\tstore[i] = values[i];\n\t}\n\tFull(const Matrix & matrix2) {\n\t\tint a = 1;\n\t\trows = matrix2.size(a++);\n\t\tcolumns = matrix2.size(a);\n\t\tstore = new double[rows*columns];\n\t\tfor(int i = 0;i < rows;++ i) {\n\t\t\tfor(int j = 0;j < columns;++ j)\n\t\t\t\tstore[i*columns+j] = matrix2.get(i,j);\n\t\t}\n\t}\n\t/*Full(const Full & matrix2) {\n\t\tint a = 1;\n\t\trows = matrix2.size(a++);\n\t\tcolumns = matrix2.size(a);\n\t\tstore = new double[rows*columns];\n\t\tfor(int i = 0;i < rows;++ i) {\n\t\t\tfor(int j = 0;j < columns;++ j)\n\t\t\t\tstore[i*columns+j] = matrix2.get(i,j);\n\t\t}\n\t}*/\n\t~Full() {\n\t\tdelete [] store;\n\t}\n\tint size(int dem) const{\n\t\tif(dem == 1) return rows;\n\t\treturn columns;\n\t}\n\tvoid set(int row, int column, double value) {\n\t\tstore[row*columns+column] = value;\n\t}\n\tdouble get(int row, int column) const{\n\t\treturn store[row*columns+column];\n\t}\n\tMatrix & operator = (const Matrix & matrix2) {\n\t\trows = size(1);\n\t\tcolumns = size(2);\n\t\tdelete []store;\n\t\tstore = new double[rows*columns];\n\t\tfor(int i = 0;i < rows;++ i) \n\t\t\tfor(int j = 0;j < columns;++ j)\n\t\t\t\tstore[i*columns+j] = matrix2.get(i,j);\n\t\treturn *this;\n\t}\n\tvoid print() const {\n\t\tfor(int i = 0;i < rows;++ i) {\n\t\t\tfor(int j = 0;j < columns;++ j) \n\t\t\t\tcout << \"    \" << store[i*columns+j];\n\t\t\tcout << endl;\n\t\t}\n\t}\n};",
            1591370963.9612896,
            100,
            "# 答案正确"
        ],
        [
            "8.3 (C++)",
            "马淙升",
            "#include <iostream>\nusing namespace std;\n\nclass Sparse: public Matrix{\nprivate:\n\tint rows,columns,sizes;\n\tEntry store[100];\npublic:\n\tSparse(int rows, int column):rows(rows),columns(column) {\n\t\tsizes = 0;\n\t}\n\tint size(int dimension) const{\n\t\treturn sizes;\n\t}\n\tvoid set(int row, int column, double value) {\n\t\tint i = 0;\n\t\tfor (; i < sizes; ++ i) {\n\t\t\tif(row < store[i].row||(row == store[i].row&&column < store[i].column))\n\t\t\t\tbreak;\n\t\t} \n\t\tfor(int j = i;j < sizes;++ j) {\n\t\t\tstore[sizes+i-j] = store[sizes+i-j-1];\n\t\t}\n\t\tsizes++;\n\t\tstore[i].row = row; store[i].column=column; store[i].value=value;\n\t}\n\tdouble get(int row, int column) const{\n\t\tfor (int i = 0; i < sizes; ++ i) {\n\t\t\tif(store[i].row == row&&store[i].column == column) {\n\t\t\t\treturn store[i].value;\n\t\t\t}\n\t\t} \n\t\treturn 0;\n\t}\n\tSparse operator + (Sparse & sparse2) {\n\t\tSparse res(*this);\n\t\tint i = 0,j = 0,k = 0;\n\t\twhile(i < sizes&&j < sparse2.sizes) {\n\t\t\tif(store[i].row == sparse2.store[j].row) {\n\t\t\t\tif(store[i].column == sparse2.store[j].column) {\n\t\t\t\t\tres.store[k].row = store[i].row;\n\t\t\t\t\tres.store[k].column = store[i].column;\n\t\t\t\t\tres.store[k++].value = store[i++].value+sparse2.store[j++].value;\n\t\t\t\t}\n\t\t\t\telse if(store[i].column > sparse2.store[j].column) {\n\t\t\t\t\tres.store[k].row = sparse2.store[j].row;\n\t\t\t\t\tres.store[k].column = sparse2.store[j].column;\n\t\t\t\t\tres.store[k++].value = sparse2.store[j++].value;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tres.store[k].row = store[i].row;\n\t\t\t\t\tres.store[k].column = store[i].column;\n\t\t\t\t\tres.store[k++].value = store[i++].value;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(store[i].row > sparse2.store[j].row) {\n\t\t\t\tres.store[k].row = sparse2.store[j].row;\n\t\t\t\tres.store[k].column = sparse2.store[j].column;\n\t\t\t\tres.store[k++].value = sparse2.store[j++].value;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tres.store[k].row = store[i].row;\n\t\t\t\tres.store[k].column = store[i].column;\n\t\t\t\tres.store[k++].value = store[i++].value;\n\t\t\t}\n\t\t}\n\t\twhile(i < sizes) {\n\t\t\tres.store[k].row = store[i].row;\n\t\t\tres.store[k].column = store[i].column;\n\t\t\tres.store[k++].value = store[i++].value;\n\t\t} \n\t\twhile(j < sparse2.sizes) {\n\t\t\tres.store[k].row = sparse2.store[j].row;\n\t\t\tres.store[k].column = sparse2.store[j].column;\n\t\t\tres.store[k++].value = sparse2.store[j++].value;\n\t\t}\n\t\tres.sizes = k;\n\t\treturn res;\n\t}\n\tvoid print() {\n\t\tfor(int i = 0;i < sizes;++ i) {\n\t\t\tif(store[i].value != 0) {\n\t\t\t\tcout << '(' << store[i].row << ',' << store[i].column\n\t\t\t\t\t<< ',' << store[i].value << ')' << endl;\n\t\t\t}\n\t\t}\n\t}\n};",
            1591368680.7016737,
            100,
            "# 答案正确"
        ],
        [
            "8.4 (C++)",
            "马淙升",
            "#include <iostream>\nusing namespace std;\n\nclass Sparse: public Matrix{\nprivate:\n\tint rows,columns,sizes;\n\tEntry store[100];\npublic:\n\tSparse(int rows, int column):rows(rows),columns(column) {\n\t\tsizes = 0;\n\t}\n\tint size(int dimension) const{\n\t\treturn sizes;\n\t}\n\tvoid set(int row, int column, double value) {\n\t\tint i = 0;\n\t\tfor (; i < sizes; ++ i) {\n\t\t\tif(row == store[i].row&&column == store[i].column) {\n\t\t\t\tstore[i].value += value;\n\t\t\t\treturn ;\n\t\t\t}\n\t\t\tif(row < store[i].row||(row == store[i].row&&column < store[i].column))\n\t\t\t\tbreak;\n\t\t} \n\t\tfor(int j = i;j < sizes;++ j) {\n\t\t\tstore[sizes+i-j] = store[sizes+i-j-1];\n\t\t}\n\t\tsizes++;\n\t\tstore[i].row = row; store[i].column=column; store[i].value=value;\n\t}\n\tdouble get(int row, int column) const{\n\t\tfor (int i = 0; i < sizes; ++ i) {\n\t\t\tif(store[i].row == row&&store[i].column == column) {\n\t\t\t\treturn store[i].value;\n\t\t\t}\n\t\t} \n\t\treturn 0;\n\t}\n\tSparse operator * (Sparse & sparse2) {\n\t\tSparse res(rows,sparse2.columns);\n\t\tEntry temp[200];\n\t\tint k = 0,elem = 0;\n\t\tfor(int i = 0;i < sizes;++ i) {\n\t\t\tfor(int j = 0;j < sparse2.sizes;++ j) {\n\t\t\t\tif(store[i].column == sparse2.store[j].row) {\n\t\t\t\t\ttemp[k].row = store[i].row;\n\t\t\t\t\ttemp[k].column = sparse2.store[j].column;\n\t\t\t\t\ttemp[k++].value = store[i].value*sparse2.store[j].value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0;i < k;++ i) {\n\t\t\tres.set(temp[i].row,temp[i].column,temp[i].value);\n\t\t}\n\t\treturn res;\n\t}\n\tvoid print() {\n\t\tfor(int i = 0;i < sizes;++ i) {\n\t\t\tif(store[i].value != 0) {\n\t\t\t\tcout << '(' << store[i].row << ',' << store[i].column\n\t\t\t\t\t<< ',' << store[i].value << ')' << endl;\n\t\t\t}\n\t\t}\n\t}\n};",
            1591409502.5406778,
            100,
            "# 答案正确"
        ],
        [
            "8.5 (C++)",
            "马淙升",
            "#include <iostream>\nusing namespace std;\nclass Point3D: public Point2D {\nprivate:\n\tdouble z;\npublic:\n\tPoint3D() {\n\t\tz = 0;\n\t}\n\tPoint3D(int x,int y,int z) :z(z){\n\t\tsetX(x);\n\t\tsetY(y);\n\t}\n\tdouble distance(Point2D & point2) {\n\t\tPoint3D& other = static_cast<Point3D&>(point2);\n\t\tdouble a = point2.Point2D::distance(*this);\n\t\tdouble b = z - other.z;\n\t\treturn sqrt(a*a+b*b);\n\t}\n\tdouble getZ() {\n\t\treturn z;\n\t}\n};",
            1591843952.2184083,
            100,
            "# 答案正确"
        ],
        [
            "8.6 (C++)",
            "马淙升",
            "#include<iostream>\nclass MyTensor:public Tensor<double>{\nprivate:\n\tvector<double> p;\n\tint size;\npublic:\n\tMyTensor(const vector<int> & indexes):Tensor(indexes) {\n\t\tint index = 1;\n\t\tsize = sizes.size();\n\t\tfor (int i = 0; i < size; ++ i)  {\n\t\t\tif(indexes[i]!=-1) index *= indexes[i];\n\t\t}\n\t\tfor (int i = 0; i < index; ++ i) p.push_back(0);\n\t}\n\tdouble & get(const vector<int> & indexes){\n\t\tint index = indexes[0];\n\t\tfor (int i = 1; i < size; ++ i) {\n\t\t\tindex = sizes[i]*index+indexes[i];\n\t\t} \n\t\treturn p[index];\n\t}\n};",
            1592450271.2616951,
            100,
            "# 答案正确"
        ],
        [
            "9.1 (C++)",
            "马淙升",
            "#include<iostream>\nusing namespace std;\nclass Circle{\n\tdouble value;\npublic:\n\tCircle(double n): value(n) {}\n\tCircle(): value(0){}\n\tbool operator < (Circle b) {\n\t\treturn this->value < b.value;\n\t}\n\tbool operator > (Circle b) {\n\t\treturn this->value > b.value;\n\t}\n\tbool operator <= (Circle b) {\n\t\treturn this->value <= b.value;\n\t}\n\tbool operator >= (Circle b) {\n\t\treturn this->value >= b.value;\n\t}\n\tbool operator == (Circle b) {\n\t\treturn this->value == b.value;\n\t}\n\tbool operator != (Circle b) {\n\t\treturn this->value != b.value;\n\t}\n};",
            1592534261.7301254,
            100,
            "# 答案正确"
        ],
        [
            "9.2 (C++)",
            "马淙升",
            "#include<vector>\nusing namespace std;\nclass I {\n\tvector<int> p;\npublic:\n\tI(int a = -1,int b = -1,int c = -1,int d = -1) {\n\t\tif(a != -1) p.push_back(a);\n\t\tif(b != -1) p.push_back(b);\n\t\tif(c != -1) p.push_back(c);\n\t\tif(d != -1) p.push_back(d);\n\t}\n\tI(vector<int> k) {\n\t\tfor (int i = 0; i < k.size(); ++ i) {\n\t\t\tp.push_back(k[i]);\n\t\t} \n\t}\n\toperator vector<int>() const{\n\t\treturn p;\n\t}\n};",
            1592536723.2861345,
            100,
            "# 答案正确"
        ],
        [
            "9.3 (C++)",
            "马淙升",
            "\nclass Complex{\n\tdouble Re,Im;\npublic:\n\tComplex(double a,double b) :Re(a),Im(b){}\n\tComplex(double a) :Re(a),Im(0){}\n\tconst double& real() const{\n\t\treturn Re;\n\t}\n\tconst double& imag() const{\n\t\treturn Im;\n\t}\n\tbool operator == (Complex& other) {\n\t\treturn Re == other.Re&&Im == other.Im;\n\t}\n\tbool operator != (Complex& other) {\n\t\treturn Re != other.Re&&Im != other.Im;\n\t}\n\tComplex& operator += (Complex&other) {\n\t\tdouble a = this->real() + other.Re;\n\t\tdouble b = this->imag() + other.Im;\n\t\tComplex temp(a,b);\n\t\t*this = temp;\n\t\treturn *this;\n\t}\n\tComplex& operator -= (Complex&other) {\n\t\tdouble a = this->real() - other.Re;\n\t\tdouble b = this->imag() - other.Im;\n\t\tComplex temp(a,b);\n\t\t*this = temp;\n\t\treturn *this;\n\t}\n\tComplex& operator *= (Complex&other) {\n\t\tdouble a = Re*other.Re-Im*other.Im;\n\t\tdouble b = Re*other.Im+Im*other.Re;\n\t\tComplex temp(a,b);\n\t\t*this = temp;\n\t\treturn *this;\n\t}\n\tComplex& operator /= (Complex&other) {\n\t\tdouble k = other.Re*other.Re + other.Im*other.Im;\n\t\tdouble a = (Re*other.Re+Im*other.Im)/k;\n\t\tdouble b = (-Re*other.Im+Im*other.Re)/k;\n\t\tComplex temp(a,b);\n\t\t*this = temp;\n\t\treturn *this;\n\t}\n};\nComplex operator + (const Complex&A,const Complex&other) {\n\tdouble a = A.real(),b = A.imag(),c = other.real(),d = other.imag();\n\tComplex res(a+c,b+d);\n\treturn res;\n}\nComplex operator - (const Complex&A,const Complex&other) {\n\tdouble a = A.real(),b = A.imag(),c = other.real(),d = other.imag();\n\tComplex res(a-c,b-d);\n\treturn res;\n}\nComplex operator * (const Complex&A,const Complex&other) {\n\tdouble a = A.real(),b = A.imag(),c = other.real(),d = other.imag();\n\tComplex res(a*c-b*d,a*d+b*c);\n\treturn res;\n}\nComplex operator / (const Complex&A,const Complex&other) {\n\tdouble a = A.real(),b = A.imag(),c = other.real(),d = other.imag();\n\tdouble k = c*c+d*d;\n\tComplex res((a*c+b*d)/k,(-a*d+b*c)/k);\n\treturn res;\n}",
            1592543798.4039752,
            100,
            "# 答案正确"
        ],
        [
            "9.4 (C++)",
            "马淙升",
            "#include <iostream>\n#include<iomanip>\nusing namespace std;\nclass Complex{\n\tdouble a,b;\npublic:\n\tComplex(double a,double b):a(a),b(b){};\n\tComplex():a(0),b(0){}\n\tconst double& real() const{return a;}\n\tconst double& ima() const{return b;}\n\tComplex operator +(Complex &other) {\n\t\tComplex res(a+other.a,b+other.b);\n\t\treturn res;\n\t}\n\tComplex operator -(Complex &other) {\n\t\tComplex res(a-other.a,b-other.b);\n\t\treturn res;\n\t}\n};\nistream& operator >> (istream&in,Complex& m) {\n\tdouble a,b;\n\tin >> a >> b;\n\tComplex temp(a,b);\n\tm = temp;\n\treturn in;\n} \nostream& operator << (ostream&out,const Complex& n) {\n\t\tout << n.real() << \" + \" << n.ima() << \" i\";\n}",
            1592544116.2340178,
            100,
            "# 答案正确"
        ],
        [
            "9.5 (C++)",
            "马淙升",
            "class Complex {\n\tdouble a,b;\npublic:\n\tComplex(double a,double b):a(a),b(b){}\n\tComplex() :a(0),b(0){}\n\tComplex& operator ++() {\n\t\ta += 1;\n\t\treturn *this;\n\t}\n\tComplex operator ++(int) {\n\t\tComplex temp = *this;\n\t\t++(*this);\n\t\treturn temp;\n\t}\n\tconst double& real() const{\n\t\treturn a;\n\t}\n\tconst double& imag() const{\n\t\treturn b;\n\t}\n\toperator double() {\n\t\treturn a;\n\t}\n};\nistream& operator >> (istream&in,Complex& m) {\n\tdouble a,b;\n\tin >> a >> b;\n\tComplex temp(a,b);\n\tm = temp;\n\treturn in;\n} \nostream& operator << (ostream&out,const Complex& n) {\n\t\tout << n.real() << \" + \" << n.imag() << \" i\";\n}",
            1592544630.3452063,
            100,
            "# 答案正确"
        ],
        [
            "9.6 (C++)",
            "马淙升",
            "#include<iostream>\nusing namespace std;\nclass Tensor{\n\tvector<double> store;\n\tint demension;\n\tint size[5];\npublic:\n\tTensor(int a = -1,int b = -1,int c = -1,int d = -1) {\n\t\tdemension = 0;\n\t\tint index = 1;\n\t\tif(a != -1) {\n\t\t\tdemension++; size[1] = a;\n\t\t\tindex *= a;\n\t\t}\n\t\tif(b != -1) {\n\t\t\tdemension++; size[2] = b;\n\t\t\tindex *= b;\n\t\t}\n\t\tif(c != -1) {\n\t\t\tdemension++; size[3] = c;\n\t\t\tindex *= a;\n\t\t}\n\t\tif(d != -1) {\n\t\t\tdemension++; size[4] = d;\n\t\t\tindex *= d;\n\t\t}\n\t\tfor (int i = 0; i < index; ++ i) store.push_back(0);\n\t}\n\tint getd() {return demension;}\n\tint* gets() {return size;}\n\tdouble& operator()(int a = -1,int b = -1,int c = -1,int d = -1) {\n\t\tint index = a;\n\t\tif(b != -1) index = index*size[2] + b;\n\t\tif(c != -1) index = index*size[3] + c;\n\t\tif(d != -1) index = index*size[4] + d;\n\t\treturn store[index];\n\t}\n\t/*const double& operator()(int a = -1,int b = -1,int c = -1,int d = -1)const {\n\t\tint index = a;\n\t\tif(b != -1) index = index*size[2] + b;\n\t\tif(c != -1) index = index*size[3] + c;\n\t\tif(d != -1) index = index*size[4] + d;\n\t\treturn store[index];\n\t} */\n};\n/*istream& operator >>(istream&in,double&p) {\n\tin >> p;\n\treturn in;\n}\nostream& operator <<(ostream&out,double&p) {\n\tout << p;\n\treturn out;\n}*/",
            1592618387.085414,
            100,
            "# 答案正确"
        ],
        [
            "9.7 (C++)",
            "马淙升",
            "#include<iostream>\n#include<vector>\nusing namespace std;\nclass Tensor{\n\tvector<double> store;\n\tvector<int> size;\npublic:\n\tTensor() {};\n\tTensor(vector<double>&a,vector<int>&b): store(a),size(b){};\n\tvector<double>& getStore() {return store;}\n\tvector<int>& getSize() {return size;}\n};\nistream& operator >> (istream&in,Tensor& p) {\n\tvector<int> a;\n\tvector<double> b;\n\tint size,total = 1;\n\tin >> size;\n\tfor(int i = 0;i < size;++ i) {\n\t\tint k;\n\t\tin >> k; total *= k;\n\t\ta.push_back(k);\n\t} \n\tfor (int i = 0; i < total; ++ i) {\n\t\tdouble temp;\n\t\tin >> temp;\n\t\tb.push_back(temp);\n\t} \n\tTensor temp(b,a);\n\tp = temp;\n\treturn in;\n}\nostream& operator << (ostream&out,Tensor& p) {\n\tvector<int> a = p.getSize();\n\tvector<double> b = p.getStore();\n\tint sizes = a.size();\n\tout << sizes << endl;\n\tfor (int i = 0; i < sizes; ++ i) \n\t\tout << a[i] << ' ';\n\tout << endl << endl;\n\tif(sizes == 1) {\n\t\tfor (int i = 0; i < a[0]; ++ i)\n\t\t\tout << b[i] << ' ';\n\t\tout << endl;\n\t\treturn out;\n\t}\n\tint one = a[sizes-1]*a[sizes-2],m = a[sizes-1];\n\tint all = 1;\n\tfor (int i = 0; i < sizes - 2; ++ i) {\n\t\tall *= a[i];\n\t} \n\tfor (int i = 0; i < all; ++ i) {\n\t\tfor (int j = 0; j < one; ++ j) {\n\t\t\tout << b[i*one+j] << ' ';\n\t\t\tif((j+1)%m == 0) out << endl;\n\t\t}  \n\t\tout << endl;\n\t} \n\treturn out;\n}",
            1592621635.6543396,
            100,
            "# 答案正确"
        ],
        [
            "10.1 (C++)",
            "马淙升",
            "#include<stdexcept>\nclass MatrixSizesDoNotMatchException{};\ndouble Matrix::get(int row, int column) const {\n\tif(row > this -> size(1)||row <= 0||column > this->size(2)||column <= 0)\n\t\tthrow out_of_range(\"caught: out_of_range\");\n\treturn elements[(row-1)*(this->size(2))+column-1];\n}\nvoid Matrix::set(int row, int column, double value) {\n\tif(row > this -> size(1)||row <= 0||column > this->size(2)||column <= 0)\n\t\tthrow out_of_range(\"caught: out_of_range\");\n\telements[(row-1)*(this->size(2))+column-1] = value;\n}\nMatrix Matrix::operator + (const Matrix & matrix2) const{\n\tif(this->size(1)!=matrix2.size(1)||this->size(2)!=matrix2.size(2)) \n\t\tthrow MatrixSizesDoNotMatchException();\n\tMatrix res(this->rows,this->columns);\n\tfor(int i = 0;i < res.rows;++ i) {\n\t\tfor(int j = 0;j < res.columns;++ j) {\n\t\t\tdouble sum = this->get(i+1,j+1) + matrix2.get(i+1,j+1);\n\t\t\tres.set(i+1,j+1,sum);\n\t\t}\n\t}\n\treturn res;\t\n}",
            1593655341.882128,
            100,
            "# 答案正确"
        ],
        [
            "10.2 (C++)",
            "马淙升",
            "catch(NonPositiveValueException &ex) {\n\tcout << \"caught: NonPositiveValueException\\n\";\n}\ncatch(out_of_range &ex) {\n\tcout << \"caught: out_of_range\\n\";\n}\n",
            1593655949.861426,
            100,
            "# 答案正确"
        ],
        [
            "15.1 (C++)",
            "马淙升",
            "#include<vector>\n#include<iostream>\nusing namespace std;\nclass Table {\nprivate:\n\tvector<string> col;\n\tvector<vector<string>> store;\npublic:\n\tvoid addCol(string a) {\n\t\tcol.push_back(a);\n\t}\n\tvector<string> & operator [] (int i) {\n\t\tif(store.size() > i) return store[i];\n\t\telse {\n\t\t\tstore.push_back(vector<string>());\n\t\t\treturn store[i];\n\t\t}\n\t}\n\tstring json() const{\n\t\tstring res;\n\t\tres += \"{\\n\\theaders: [\";\n\t\tfor (int i = 0; i < col.size(); ++ i) {\n\t\t\tres += \"'\"; res += col[i];\n\t\t\tres += \"',\";\n\t\t} \n\t\tres += \"],\\n\\trows: [\\n\";\n\t\tfor (int i = 0; i < store.size(); ++ i) {\n\t\t\tres += \"\\t\\t['\";\n\t\t\tres += store[i][0]; res += \"\\','\";\n\t\t\tres += store[i][1]; res += \"',],\\n\";\n\t\t} \n\t\tres += \"\\t],\\n}\";\n\t\treturn res;\n\t}\n};",
            1593749864.2046852,
            100,
            "# 答案正确"
        ],
        [
            "2020-07-09 LAB",
            "马淙升",
            "#include<vector>\n#include<iostream>\nusing namespace std;\nclass Integer{\n\tint now;\n\tstatic vector<int> store;\n\tstatic int index;\npublic:\n\tInteger() {\n\t\tnow = index;\n\t\tstore.push_back(0);\n\t\tindex++;\n\t}\n\tInteger(int a) {\n\t\tnow = index;\n\t\tstore.push_back(a);\n\t\tindex++;\n\t}\n\tint id() {\n\t\treturn now;\n\t}\n\tstatic void increase_all(Integer y) {\n\t\tint p = store[y.id()];\n\t\tfor (int i = 0; i < index; ++ i)\n\t\t\tstore[i] += p;\n\t}\n\tstatic int &get(int a) {\n\t\treturn store[a];\n\t}\n};\nint Integer::index = 0;\nvector<int> Integer::store;\nistream& operator >> (istream& in,Integer& b) {\n\tint a;\n\tin >> a;\n\tInteger::get(b.id()) = a;\n\treturn in;\n}\nostream& operator << (ostream& out,Integer& b) {\n\tout << Integer::get(b.id());\n\treturn out;\n}",
            1594262857.8024979,
            100,
            "# 答案正确"
        ],
        [
            "A.1 (C++)",
            "马淙升",
            "void addFirst(E val) {\n\tNode<E>* temp = new Node<E>;\n\ttemp -> element = val;\n\ttemp->update_prev_and_next_node(0,head);\n\tif(head != 0) head -> update_prev_node(0,temp);\n\thead = temp;\n\tif(_size == 0) tail = temp;\n\t_size++;\n}\nvoid addLast(E val) {\n\tNode<E>* temp = new Node<E>;\n\ttemp -> element = val;\n\ttemp->update_prev_and_next_node(0,tail);\n\tif(tail != 0) tail->update_next_node(0,temp);\n\ttail = temp;\n\tif(_size == 0) head = temp;\n\t_size++;\n}\nvoid removeFirst() {\n\tif(_size == 0) throw NotSuchElementException();\n\tif(_size == 1) {\n\t\tdelete head;\n\t\thead = tail = 0;\n\t}\n\telse {\n\t\tNode<E>* next = head -> next_node(0);\n\t\tnext -> update_prev_node(head,0);\n\t\tdelete head;\n\t\thead = next;\n\t}\n\t--_size;\n}\nvoid removeLast() {\n\tif(_size == 0) throw NotSuchElementException();\n\tif(_size == 1) {\n\t\tdelete head;\n\t\thead = tail = 0;\n\t}\n\telse {\n\t\tNode<E>* pre = tail -> prev_node(0);\n\t\tpre -> update_next_node(tail,0);\n\t\tdelete tail;\n\t\ttail = pre;\n\t}\n\t--_size;\n}\nE get(int index) {\n\t//if(index < 0||index >= _size) throw NotSuchElementException();\n\tNode<E>* now = head,*pre = NULL;\n\tI(i,index) {\n\t\tNode<E>* temp = pre;\n\t\tpre = now;\n\t\tnow = now -> next_node(temp);\n\t}\n\treturn now -> element;\n}\nvoid removeFirstOccurrence(E val) {\n\tNode<E>* now = head,*pre = NULL;\n\tI(i,_size) {\n\t\tif(now -> element == val) {\n\t\t\tif(i == 0) removeFirst();\n\t\t\telse if(i == _size - 1) removeLast();\n\t\t\telse {\n\t\t\t\tNode<E>* next = now -> next_node(pre);\n\t\t\t\tpre->update_prev_and_next_node(pre->prev_node(now),next);\n\t\t\t\tnext->update_prev_and_next_node(next->prev_node(now),pre);\n\t\t\t\tdelete now;\n\t\t\t}\n\t\t\t-- _size;\n\t\t\treturn ;\n\t\t}\n\t\tNode<E>* temp = pre;\n\t\tpre = now;\n\t\tnow = now -> next_node(temp);\n\t}\n\tthrow NotSuchElementException();\n}",
            1594373323.4178631,
            100,
            "# 答案正确"
        ],
        [
            "A.2 (C++)",
            "马淙升",
            "template <typename E>\nvoid LinkedList<E>::removeAll(const E & e) {\n\tint index = indexOf(e);\n\twhile(index != -1) {\n\t\tremove(index);\n\t\tindex = indexOf(e);\n\t}\n}",
            1594866424.940123,
            100,
            "# 答案正确"
        ],
        [
            "A.4 (C++)",
            "马淙升",
            "#include<iostream>\n\nusing namespace std;\nclass type{\npublic:\n\tint key1,used;\n\tstring key2;\n\ttype(int a):key1(a),used(0),key2(string()) {}\n\ttype(string b):key2(b),used(1),key1(0){}\n\ttype():key1(-1),key2(string()),used(-1){}\n\tbool operator == (type other) {\n\t\tif(key1 != other.key1) return false;\n\t\tif(key2 != other.key2) return false;\n\t\tif(used != other.used) return false;\n\t\treturn true;\n\t}\n\toperator int() {return key1;}\n\toperator string() {return key2;}\n};\nclass word{\npublic:\n\ttype key,value;\n\tint state;\n\tword(type a,type b) :key(a),value(b),state(1) {}\n\tword(){state = 0;}\n};\nclass HT{\n\tword *dict;\n\tint _size[2],capci;\n\tint haxifind(type a) {\n\t\tint res;\n\t\tif(a.used == 0) res = a.key1%(capci/2 - 1);\n\t\telse res = atoi(a.key2.c_str())%(capci/2)+capci/2;\n\t\treturn res;\n\t}\npublic:\n\tHT():capci(1000) {\n\t\tdict = new word[capci]();\n\t\t_size[0] = _size[1] = 0;\n\t}\n\t~HT(){\n\t\tdelete []dict;\n\t}\n\tvoid renew() {\n\t\tcapci *= 2;\n\t\tword *temp = new word[capci]();\n\t\tfor(int i = 0;i < capci/2;++ i) {\n\t\t\tif(dict[i].state == 1) {\n\t\t\t\tint index = haxifind(dict[i].value);\n\t\t\t\ttemp[index] = dict[i];\n\t\t\t}\n\t\t}\n\t\tdelete []dict;\n\t\tdict = temp;\n\t}\n\tvoid put(type a,type b) {\n\t\tword temp(a,b);\n\t\tint TOF = haxifind(a);\n\t\tif(dict[TOF].state == 0) {\n\t\t\tdict[TOF] = temp;\n\t\t\tdict[TOF].state = 1;\n\t\t\t_size[dict[TOF].key.used] ++;\n\t\t\tif(_size[dict[TOF].key.used]*2 > capci) renew();\n\t\t}\n\t\telse dict[TOF].value = b;\n\t}\n\tint size() {return _size[0]+_size[1];}\n\ttype operator [] (type key) {\n\t\tint index = haxifind(key);\n\t\treturn dict[index].value;\n\t}\n};",
            1595174639.9821594,
            100,
            "# 答案正确"
        ],
        [
            "A.5 (C++)",
            "马淙升",
            "#include<iostream>\n\nusing namespace std;\nclass type{\npublic:\n\tint key1,used;\n\tstring key2;\n\ttype(int a):key1(a),used(0),key2(string()) {}\n\ttype(string b):key2(b),used(1),key1(0){}\n\ttype():key1(-1),key2(string()),used(-1){}\n\tbool operator == (type other) {\n\t\tif(key1 != other.key1) return false;\n\t\tif(key2 != other.key2) return false;\n\t\tif(used != other.used) return false;\n\t\treturn true;\n\t}\n\toperator int() {return key1;}\n\toperator string() {return key2;}\n};\nclass word{\npublic:\n\ttype key,value;\n\tint state;\n\tword(type a,type b) :key(a),value(b),state(1) {}\n\tword(){state = 0;}\n};\nclass HT{\n\tword *dict;\n\tint _size[2],capci;\n\tint haxifind(type a) {\n\t\tint res;\n\t\tif(a.used == 0) res = a.key1%(capci/2 - 1);\n\t\telse res = atoi(a.key2.c_str())%(capci/2)+capci/2;\n\t\treturn res;\n\t}\npublic:\n\tHT():capci(1000) {\n\t\tdict = new word[capci]();\n\t\t_size[0] = _size[1] = 0;\n\t}\n\t~HT(){\n\t\tdelete []dict;\n\t}\n\tvoid renew() {\n\t\tcapci *= 2;\n\t\tword *temp = new word[capci]();\n\t\tfor(int i = 0;i < capci/2;++ i) {\n\t\t\tif(dict[i].state == 1) {\n\t\t\t\tint index = haxifind(dict[i].value);\n\t\t\t\ttemp[index] = dict[i];\n\t\t\t}\n\t\t}\n\t\tdelete []dict;\n\t\tdict = temp;\n\t}\n\tint size() {return _size[0]+_size[1];}\n\ttype& operator [] (type key) {\n\t\tint index = haxifind(key);\n\t\tif(dict[index].state == 0) \n\t\t\t_size[key.used] ++;\n\t\tdict[index].state = 1;\n\t\treturn dict[index].value;\n\t}\n};",
            1595174944.689266,
            100,
            "# 答案正确"
        ],
        [
            "A.3 (C++)",
            "马淙升",
            "#include <iostream>\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <stdexcept>\nusing namespace std;\n\n#define I(i,n) for (size_t i = 0; i < n; ++ i)\n\nclass NoSuchKeyException {};\n\nsize_t circular_shift(size_t bits, int shift_bits) {\n\tconst int num_bits = 8 * sizeof(size_t);\n\tshift_bits = shift_bits % num_bits;\n\treturn bits << shift_bits | bits >> (num_bits - shift_bits);\n}\n\nsize_t hash_function(const string & key) {\n\tsize_t code = 0;\n\tI(i, key.size())\n\t\tcode ^= circular_shift(key[i], i * 5);\n\treturn code;\n}\n\nstring itos(const int & a) {\n\tstring res;\n\tint temp = a;\n\twhile(temp > 0) {\n\t\tint num = temp % 10;\n\t\tres.push_back(num + '0');\n\t\ttemp = temp / 10;\n\t}\n\tfor(int i = 0 ; i < res.size() / 2 ; i ++){\n\t\tchar a = res[i];\n\t\tres[i] = res[res.size() - i - 1];\n\t\tres[res.size() - i - 1] = a;\n\t}\n\treturn res;\n}\n\ntemplate <typename V>\nclass HT\n{\n\tclass Tuple\n\t{\n\tpublic:\n\t\tint key;\n\t\tV val;\n\t\tbool in_use;\n\n\t\tTuple() : in_use(false) {}\n\t};\n\n\tvector<Tuple> tuples;\n\tsize_t _size;\n\n\tsize_t canonical_index(const int & key) const {\n\t\tstring temp = itos(key);\n\t\tsize_t hash_code = hash_function(temp); // needs hash_function(K)\n\t\treturn hash_code % tuples.size();\n\t}\n\n\t// the returned tuple is either empty or with the same key\n\tsize_t indexOfKey(const int & key) const {\n\t\tsize_t index = canonical_index(key);\n\t\twhile (true) { // will enter a dead loop if there is not empty tuple\n\t\t\tif (! tuples[index].in_use) return index;\n\t\t\tif (tuples[index].key == key) return index;\n\t\t\tindex = (index + 1) % tuples.size();\n\t\t}\n\t}\n\npublic:\n\tHT() : _size(0) {\n\t\ttuples.resize(2);\n\t}\n\n\tbool containsKey(const int & key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\treturn tuples[index].in_use;\n\t}\n\n\tconst V & operator [] (const int & key) const {\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples[index].val;\n\t}\n\n\tV & operator [] (const int & key) {\n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\treturn tuples[index].val;\n\t}\n\n\tvoid put(const int & key, const V & val) {\n\t\tsize_t index = indexOfKey(key);\n\t\ttuples[index].key = key;\n\t\ttuples[index].val = val;\n\t\tif (tuples[index].in_use) return;\n\t\ttuples[index].in_use = true;\n\t\t++ _size;\n\t\t// make sure empty > size / 2\n\t\tif (2 * _size > tuples.size())\n\t\t\t_double_tuples();\n\t}\n\n\tvoid _double_tuples() {\n\t\tvector<Tuple> non_empty_tuples;\n\t\tI(i, tuples.size())\n\t\t\tif (tuples[i].in_use)\n\t\t\t\tnon_empty_tuples.push_back(tuples[i]);\n\t\tclear();\n\t\ttuples.resize(tuples.size() * 2);\n\t\tI(i, non_empty_tuples.size())\n\t\t\tput(non_empty_tuples[i].key, non_empty_tuples[i].val);\n\t}\n\n\tstatic bool _between(size_t hole, size_t canonical, size_t tuple_index) {\n\t\tif (hole < tuple_index)\n\t\t\treturn canonical > hole && canonical <= tuple_index;\n\t\telse\n\t\t\treturn canonical > hole || canonical <= tuple_index;\n\t}\n\n\tvoid remove(const int & key) { \n\t\tsize_t index = indexOfKey(key);\n\t\tif (! tuples[index].in_use) \n\t\t\tthrow NoSuchKeyException();\n\t\ttuples[index].in_use = false;\n\t\t-- _size;\n\t\t// if there is a hole between a tuple and its canonical position\n\t\t// move the tuple to the hole\n\t\tsize_t hole = index;\n\t\tsize_t tuple_index = hole;\n\t\twhile (true) {\n\t\t\ttuple_index = (tuple_index + 1) % tuples.size();\n\t\t\tif (! tuples[tuple_index].in_use) return;\n\t\t\tsize_t canonical = canonical_index(tuples[tuple_index].key);\n\t\t\tif (_between(hole, canonical, tuple_index)) continue;\n\t\t\ttuples[hole] = tuples[tuple_index];\n\t\t\thole = tuple_index;\n\t\t\ttuples[hole].in_use = false;\n\t\t}\n\t}\n\n\tsize_t size() const { return _size; }\n\n\tvoid clear() {\n\t\tI(i, tuples.size())\n\t\t\ttuples[i].in_use = false;\n\t\t_size = 0;\n\t}\n\n\ttemplate <typename V2>\n\tfriend ostream & operator << (ostream & out, const HT<V2> & dict);\n\n\ttemplate <typename V2>\n\tfriend istream & operator >> (istream & in, HT<V2> & dict);\n\n\tvoid _inspect() const {\n\t\tI(i, tuples.size())\n\t\t\tif (tuples[i].in_use)\n\t\t\t\tcout << \"#\" << i << \" C\" << canonical_index(tuples[i].key) \n\t\t\t\t\t<< \" \" << tuples[i].key << \" \" << tuples[i].val << endl;\n\t}\n\n\tvector<int> getKeys () {\n\t\tvector<int> keys;\n\t\tfor(int i = 0 ; i < tuples.size() ; i ++) {\n\t\t\tif(tuples[i].in_use == true) {\n\t\t\t\tkeys.push_back(tuples[i].key);\n\t\t\t}\n\t\t}\n\t\treturn keys;\n\t}\n};\n\ntemplate <typename V>\nostream & operator << (ostream & out, const HT<V> & dict) {\n\tout << dict.size() << endl;\n\tI(i, dict.tuples.size())\n\t\tif (dict.tuples[i].in_use)\n\t\t\tout << dict.tuples[i].key << \"\\t\" << dict.tuples[i].val << endl;\n\treturn out;\n}\n\ntemplate <typename V>\nistream & operator >> (istream & in, HT<V> & dict) {\n\tdict.clear();\n\tsize_t size;\n\tin >> size;\n\tI(i, size) {\n\t\tint key;\n\t\tV val;\n\t\tin >> key >> val;\n\t\tdict.put(key, val);\n\t}\n\treturn in;\n}\n",
            1595474195.0182705,
            100,
            "# 答案正确"
        ]
    ],
    "table_name": "答案"
}